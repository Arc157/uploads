================================================================================
Function: sub_24FA560 (0x24FA560)
================================================================================

__int64 __fastcall sub_24FA560(__int64 a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x19
  __int64 result; // x0
  __int64 v7; // [xsp+0h] [xbp-10h] BYREF

  v4 = *(_QWORD *)(a2 + 8);
  if ( v4 )
  {
    (*(void (__fastcall **)(__int64 *__return_ptr, _QWORD))(*(_QWORD *)v4 + 40LL))(&v7, *(_QWORD *)(a2 + 8));
    v5 = v7;
    if ( v7 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
      if ( v7 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 32LL))(v7);
    }
  }
  else
  {
    v5 = 0LL;
  }
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  if ( result )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)result + 32LL))(result);
  *(_QWORD *)(a1 + 8) = v5;
  if ( v5 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 24LL))(v5);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 32LL))(v5);
  }
  return result;
}


================================================================================
Function: sub_24FD568 (0x24FD568)
================================================================================

void __fastcall __noreturn sub_24FD568(__int64 a1)
{
  __int64 v2; // x19

  v2 = sub_6861FD0(16LL);
  sub_24FD5B8(v2, a1);
  sub_6862048(v2, (__int64)&`typeinfo for'std::length_error, (__int64)sub_68652A0);
}


================================================================================
Function: sub_24FD5B8 (0x24FD5B8)
================================================================================

__int64 __fastcall sub_24FD5B8(_QWORD *a1, char *a2)
{
  __int64 result; // x0

  result = sub_6849410((int)a1, a2);
  *a1 = off_6C5EF58;
  return result;
}


================================================================================
Function: sub_24FE128 (0x24FE128)
================================================================================

unsigned __int64 __fastcall sub_24FE128(__int64 a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 v3; // x9
  __int64 v4; // x10
  __int64 v5; // x13
  __int64 v6; // x15
  __int64 v7; // x16
  __int64 v8; // x14
  __int64 v9; // x10
  unsigned __int64 v10; // x8
  unsigned __int64 result; // x0
  __int64 v12; // x12
  unsigned __int64 v13; // x9
  __int64 v14; // x11
  unsigned __int64 v15; // x9
  unsigned __int64 v16; // x8
  __int64 v17; // x11
  __int64 v18; // x14
  __int64 v19; // x12
  __int64 v20; // x3
  __int64 v21; // x4
  __int64 v22; // x17
  unsigned __int64 v23; // x15
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x16
  __int64 v26; // x6
  __int64 v27; // x13
  __int64 v28; // x14
  unsigned __int64 v29; // x0
  __int64 v30; // x11
  _QWORD *v31; // x1
  __int64 v32; // x17
  __int64 v33; // t1
  __int64 v34; // x12
  unsigned __int64 v35; // x13
  unsigned __int64 v36; // x14
  __int64 v37; // x15
  unsigned __int64 v38; // x16
  __int64 v39; // x2
  __int64 v40; // x5
  unsigned __int64 v41; // x4
  unsigned __int64 v42; // x10
  __int64 v43; // x14
  __int64 v44; // x6
  __int64 v45; // x16
  __int64 v46; // x3
  __int64 v47; // x4
  __int64 v48; // x19
  __int64 v49; // x7
  unsigned __int64 v50; // x12
  __int64 v51; // x2
  unsigned __int64 v52; // x12
  unsigned __int64 v53; // x9
  unsigned __int64 v54; // x10
  __int64 v55; // x9
  unsigned __int64 v56; // x10
  __int64 v57; // x9
  unsigned __int64 v58; // x8
  unsigned __int64 v59; // x8

  if ( a3 > 0x20 )
  {
    if ( a3 > 0x40 )
    {
      v18 = *(__int64 *)((char *)a2 + a3 - 56);
      v17 = *(__int64 *)((char *)a2 + a3 - 48);
      v19 = *(__int64 *)((char *)a2 + a3 - 24);
      v20 = *(__int64 *)((char *)a2 + a3 - 40);
      v22 = *(__int64 *)((char *)a2 + a3 - 16);
      v21 = *(__int64 *)((char *)a2 + a3 - 8);
      v23 = *(__int64 *)((char *)a2 + a3 - 64) + a3;
      v24 = v18 + v22;
      v25 = (0x9DDFEA08EB382D69LL * (v19 ^ (v17 + a3))) ^ v19 ^ ((0x9DDFEA08EB382D69LL * (v19 ^ (v17 + a3))) >> 47);
      v26 = v23 + v18 + v17;
      v27 = v18 + v22 + *(__int64 *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      v28 = v27 + v19 + v22;
      v29 = 0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * v25) ^ ((0x9DDFEA08EB382D69LL * v25) >> 47));
      v30 = v28 + v21;
      v33 = *a2;
      v31 = a2 + 4;
      v32 = v33;
      v34 = __ROR8__(v28, 44) + v27 + __ROR8__(v27 + v20 + v21, 21);
      v35 = 64 - ((a3 - 1) & 0xFFFFFFFFFFFFFFC0LL);
      v36 = __ROR8__(v26, 44)
          + v23
          + __ROR8__(
              v20 + v23 - 0x622015F714C7D297LL * ((0x9DDFEA08EB382D69LL * v25) ^ ((0x9DDFEA08EB382D69LL * v25) >> 47)),
              21);
      v37 = v26 + v20;
      v38 = v33 - 0x4B6D499041670D8DLL * v20;
      while ( 1 )
      {
        v39 = v31[2];
        v40 = v31[3];
        v41 = v24 + v36;
        v42 = v38 + v37 + v24;
        v43 = v32 - 0x4B6D499041670D8DLL * v36;
        v44 = v31[1];
        v45 = v41 + v39;
        v46 = *(v31 - 3);
        v47 = *(v31 - 2);
        v48 = *(v31 - 1);
        v49 = __ROR8__(v42 + v46, 37);
        v24 = v44 + v37 - 0x4B6D499041670D8DLL * __ROR8__(v45, 42);
        v38 = 0xB492B66FBE98F273LL * __ROR8__(v29 + v30, 33);
        v29 = (0xB492B66FBE98F273LL * v49) ^ v34;
        v50 = v38 + v34 + *v31;
        v51 = v50 + v44 + v39;
        v37 = v43 + v46 + v47 + v48;
        v36 = __ROR8__(v43 + v46 + v47, 44) + v43 + __ROR8__(v43 + v30 + v29 + v48, 21);
        v30 = v51 + v40;
        v34 = __ROR8__(v51, 44) + v50 + __ROR8__(v24 + v47 + v50 + v40, 21);
        if ( !v35 )
          break;
        v32 = v31[4];
        v35 += 64LL;
        v31 += 8;
      }
      v52 = 0x9DDFEA08EB382D69LL
          * ((0x9DDFEA08EB382D69LL * (v34 ^ v36)) ^ v34 ^ ((0x9DDFEA08EB382D69LL * (v34 ^ v36)) >> 47));
      v53 = v29
          - 0x4B6D499041670D8DLL * (v24 ^ (v24 >> 47))
          - 0x622015F714C7D297LL
          * ((0x9DDFEA08EB382D69LL
            * ((0x9DDFEA08EB382D69LL * (v30 ^ v37)) ^ v30 ^ ((0x9DDFEA08EB382D69LL * (v30 ^ v37)) >> 47))) ^ ((0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v30 ^ v37)) ^ v30 ^ ((0x9DDFEA08EB382D69LL * (v30 ^ v37)) >> 47))) >> 47));
      v54 = v38 - 0x622015F714C7D297LL * (v52 ^ (v52 >> 47));
      return 0x9DDFEA08EB382D69LL
           * ((0x9DDFEA08EB382D69LL
             * ((0x9DDFEA08EB382D69LL * (v54 ^ v53)) ^ v54 ^ ((0x9DDFEA08EB382D69LL * (v54 ^ v53)) >> 47))) ^ ((0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v54 ^ v53)) ^ v54 ^ ((0x9DDFEA08EB382D69LL * (v54 ^ v53)) >> 47))) >> 47));
    }
    else
    {
      v3 = *(__int64 *)((char *)a2 + a3 - 16);
      v4 = *a2 - 0x3C5A37A36834CED9LL * (v3 + a3);
      v6 = a2[2];
      v5 = a2[3];
      v7 = *(__int64 *)((char *)a2 + a3 - 32) + v6;
      v8 = v4 + a2[1] + v6;
      v9 = __ROR8__(v4 + a2[1], 7) + __ROR8__(v4, 37) + __ROR8__(v4 + v5, 52) + __ROR8__(v8, 31);
      v10 = 0xC3A5C85C97CB3127LL
          * (*(__int64 *)((char *)a2 + a3 - 24) + v7 + v3 + *(__int64 *)((char *)a2 + a3 - 8) + v5 + v9)
          - 0x651E95C4D06FBFB1LL
          * (v8
           + v5
           + __ROR8__(v7, 37)
           + __ROR8__(*(__int64 *)((char *)a2 + a3 - 24) + v7, 7)
           + __ROR8__(*(__int64 *)((char *)a2 + a3 - 8) + v5 + v7, 52)
           + __ROR8__(*(__int64 *)((char *)a2 + a3 - 24) + v7 + v3, 31));
      return 0x9AE16A3B2F90404FLL
           * ((v9 - 0x3C5A37A36834CED9LL * (v10 ^ (v10 >> 47))) ^ ((v9 - 0x3C5A37A36834CED9LL * (v10 ^ (v10 >> 47))) >> 47));
    }
  }
  else if ( a3 > 0x10 )
  {
    v12 = a2[1];
    v13 = 0xB492B66FBE98F273LL * *a2;
    v14 = __ROR8__(v13 - v12, 43);
    v15 = v13 + a3 + __ROR8__(v12 ^ 0xC949D7C7509E6557LL, 20) - 0x9AE16A3B2F90404FLL * *(__int64 *)((char *)a2 + a3 - 8);
    v16 = 0x9DDFEA08EB382D69LL
        * ((__ROR8__(0x9AE16A3B2F90404FLL * *(__int64 *)((char *)a2 + a3 - 8), 30)
          + v14
          - 0x3C5A37A36834CED9LL * *(__int64 *)((char *)a2 + a3 - 16)) ^ v15);
    return 0x9DDFEA08EB382D69LL
         * ((0x9DDFEA08EB382D69LL * (v16 ^ v15 ^ (v16 >> 47))) ^ ((0x9DDFEA08EB382D69LL * (v16 ^ v15 ^ (v16 >> 47))) >> 47));
  }
  else if ( a3 < 9 )
  {
    if ( a3 < 4 )
    {
      result = 0x9AE16A3B2F90404FLL;
      if ( a3 )
      {
        v59 = (0xC949D7C7509E6557LL * (a3 + 4LL * *((unsigned __int8 *)a2 + a3 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                       * (*(unsigned __int8 *)a2 | ((unsigned __int64)*((unsigned __int8 *)a2 + (a3 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v59 ^ (v59 >> 47));
      }
    }
    else
    {
      v57 = *(unsigned int *)((char *)a2 + a3 - 4);
      v58 = 0x9DDFEA08EB382D69LL * (((unsigned int)(8 * *(_DWORD *)a2) + a3) ^ v57);
      return 0x9DDFEA08EB382D69LL
           * ((0x9DDFEA08EB382D69LL * (v58 ^ v57 ^ (v58 >> 47))) ^ ((0x9DDFEA08EB382D69LL * (v58 ^ v57 ^ (v58 >> 47))) >> 47));
    }
  }
  else
  {
    v55 = *(__int64 *)((char *)a2 + a3 - 8);
    v56 = ((v55 + a3) << -(char)a3) | ((v55 + a3) >> a3);
    return (0x9DDFEA08EB382D69LL
          * ((0x9DDFEA08EB382D69LL
            * ((0x9DDFEA08EB382D69LL * (v56 ^ *a2)) ^ v56 ^ ((0x9DDFEA08EB382D69LL * (v56 ^ *a2)) >> 47))) ^ ((0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v56 ^ *a2)) ^ v56 ^ ((0x9DDFEA08EB382D69LL * (v56 ^ *a2)) >> 47))) >> 47))) ^ v55;
  }
  return result;
}


================================================================================
Function: sub_25095A8 (0x25095A8)
================================================================================

void __noreturn sub_25095A8()
{
  _QWORD *v0; // x0

  v0 = (_QWORD *)sub_6861FD0(8LL);
  *v0 = off_686F760;
  sub_6862048((__int64)v0, (__int64)&`typeinfo for'std::bad_function_call, (__int64)sub_6865238);
}


================================================================================
Function: sub_250DE24 (0x250DE24)
================================================================================

__int64 __fastcall sub_250DE24(char a1)
{
  int v1; // w8
  __int64 result; // x0

  v1 = a1 - 65;
  result = 1LL;
  switch ( v1 )
  {
    case 0:
      result = 8LL;
      break;
    case 1:
      result = 6LL;
      break;
    case 4:
      result = 10LL;
      break;
    case 5:
      result = 12LL;
      break;
    case 6:
      result = 14LL;
      break;
    case 23:
      result = 4LL;
      break;
    case 32:
      result = 7LL;
      break;
    case 33:
      result = 5LL;
      break;
    case 34:
      result = 15LL;
      break;
    case 35:
      return result;
    case 36:
      result = 9LL;
      break;
    case 37:
      result = 11LL;
      break;
    case 38:
      result = 13LL;
      break;
    case 46:
      result = 2LL;
      break;
    case 47:
      result = 17LL;
      break;
    case 50:
      result = 16LL;
      break;
    case 55:
      result = 3LL;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}


================================================================================
Function: sub_250E72C (0x250E72C)
================================================================================

unsigned __int64 __fastcall sub_250E72C(unsigned int *a1, char a2)
{
  unsigned int v2; // w9
  unsigned __int64 result; // x0
  _BYTE v4[8]; // [xsp+0h] [xbp-10h] BYREF

  v2 = a1[4];
  v4[0] = a2;
  switch ( v2 )
  {
    case 1u:
      result = *a1;
      if ( (result & 0x80000000) != 0 )
        goto LABEL_13;
      return result;
    case 2u:
      result = *a1;
      goto LABEL_9;
    case 3u:
      result = *(_QWORD *)a1;
      if ( (result & 0x8000000000000000LL) != 0 )
        goto LABEL_13;
      goto LABEL_9;
    case 4u:
    case 6u:
      goto LABEL_8;
    case 5u:
      if ( (*((_QWORD *)a1 + 1) & 0x8000000000000000LL) != 0 )
LABEL_13:
        sub_68070E4((__int64)v4, (__int64)"negative width");
LABEL_8:
      result = *(_QWORD *)a1;
LABEL_9:
      if ( result >> 31 )
        sub_68070E4((__int64)v4, (__int64)"number is too big");
      return result;
    default:
      sub_68070E4((__int64)v4, (__int64)"width is not integer");
  }
}


================================================================================
Function: sub_250E7F8 (0x250E7F8)
================================================================================

long double __usercall sub_250E7F8@<Q0>(__int64 *a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, __int64 a4@<X8>)
{
  __int64 v4; // x25
  __int64 v6; // x24
  __int64 v7; // x8
  _QWORD *v8; // x8
  __int64 v9; // x26
  unsigned int *v12; // x27
  const char *v13; // x23
  size_t v14; // x0
  long double result; // q0
  bool v16; // zf
  size_t v17; // x2
  size_t v18; // x22
  __int64 v19; // x8
  __int64 v20; // x8

  v4 = *a1;
  if ( (*a1 & 0x4000000000000000LL) == 0 )
    goto LABEL_21;
  v6 = a1[1];
  v7 = -32LL;
  if ( v4 >= 0 )
    v7 = -16LL;
  v8 = (_QWORD *)(v6 + v7);
  v9 = v8[1];
  if ( !v9 )
    goto LABEL_21;
  v12 = (unsigned int *)(*v8 + 8LL);
  while ( 1 )
  {
    v13 = (const char *)*((_QWORD *)v12 - 1);
    v14 = strlen(v13);
    v16 = v14 == a3;
    if ( v14 >= a3 )
      v17 = a3;
    else
      v17 = v14;
    if ( v17 )
    {
      v18 = v14;
      v16 = !memcmp(v13, a2, v17) && v18 == a3;
    }
    if ( v16 )
      break;
    v12 += 4;
    if ( !--v9 )
      goto LABEL_21;
  }
  v19 = *v12;
  if ( (v19 & 0x80000000) == 0 )
  {
    *(_DWORD *)(a4 + 16) = 0;
    if ( v4 < 0 )
    {
      if ( (int)v19 < (int)v4 )
      {
        v20 = v6 + 32 * v19;
        result = *(long double *)v20;
        LODWORD(v20) = *(_DWORD *)(v20 + 16);
        *(long double *)a4 = result;
        *(_DWORD *)(a4 + 16) = v20;
      }
    }
    else if ( (unsigned int)v19 <= 0xE )
    {
      *(_DWORD *)(a4 + 16) = ((unsigned __int64)v4 >> (4 * (unsigned __int8)v19)) & 0xF;
      if ( (((unsigned __int64)v4 >> (4 * (unsigned __int8)v19)) & 0xF) != 0 )
      {
        result = *(long double *)(v6 + 16 * v19);
        *(long double *)a4 = result;
      }
    }
  }
  else
  {
LABEL_21:
    *(_DWORD *)(a4 + 16) = 0;
  }
  return result;
}


================================================================================
Function: sub_250E90C (0x250E90C)
================================================================================

unsigned __int64 __fastcall sub_250E90C(unsigned int *a1, char a2)
{
  unsigned int v2; // w9
  unsigned __int64 result; // x0
  _BYTE v4[8]; // [xsp+0h] [xbp-10h] BYREF

  v2 = a1[4];
  v4[0] = a2;
  switch ( v2 )
  {
    case 1u:
      result = *a1;
      if ( (result & 0x80000000) != 0 )
        goto LABEL_13;
      return result;
    case 2u:
      result = *a1;
      goto LABEL_9;
    case 3u:
      result = *(_QWORD *)a1;
      if ( (result & 0x8000000000000000LL) != 0 )
        goto LABEL_13;
      goto LABEL_9;
    case 4u:
    case 6u:
      goto LABEL_8;
    case 5u:
      if ( (*((_QWORD *)a1 + 1) & 0x8000000000000000LL) != 0 )
LABEL_13:
        sub_68070E4((__int64)v4, (__int64)"negative precision");
LABEL_8:
      result = *(_QWORD *)a1;
LABEL_9:
      if ( result >> 31 )
        sub_68070E4((__int64)v4, (__int64)"number is too big");
      return result;
    default:
      sub_68070E4((__int64)v4, (__int64)"precision is not integer");
  }
}


================================================================================
Function: sub_250E9D8 (0x250E9D8)
================================================================================

__int64 __fastcall sub_250E9D8(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, _DWORD *a4)
{
  unsigned __int64 v7; // x8
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x24
  __int64 v12; // x24
  _DWORD *v13; // x25
  __int64 v14; // x0
  __int64 v15; // x8
  __int64 v16; // x3
  _QWORD v18[2]; // [xsp+8h] [xbp-28h] BYREF
  __int64 v19; // [xsp+18h] [xbp-18h] BYREF
  _DWORD v20[2]; // [xsp+20h] [xbp-10h] BYREF

  v7 = (unsigned int)a4[1];
  if ( a3 <= v7 || (int)v7 <= -1 )
    v9 = a3;
  else
    v9 = (unsigned int)a4[1];
  if ( *a4 )
  {
    v10 = a2;
    v19 = 0LL;
    v18[0] = &v19;
    if ( v9 >= 4 )
    {
      v10 = a2;
      v11 = a2 + v9 - 3;
      while ( v10 < v11 )
      {
        v10 = sub_250ED2C(v18, v10, v10);
        if ( !v10 )
          goto LABEL_17;
      }
    }
    v12 = a2 + v9 - v10;
    if ( a2 + v9 != v10 )
    {
      *(_DWORD *)((char *)v20 + 3) = 0;
      v20[0] = 0;
      __memcpy_chk();
      v13 = v20;
      do
      {
        v14 = sub_250ED2C(v18, v13, v10);
        if ( !v14 )
          break;
        v15 = v14 - (_QWORD)v13;
        v13 = (_DWORD *)v14;
        v10 += v15;
      }
      while ( v14 - (__int64)v20 < v12 );
    }
LABEL_17:
    v16 = v19;
  }
  else
  {
    v16 = 0LL;
  }
  v18[0] = a2;
  v18[1] = v9;
  return sub_250EB28(a1, a4, v9, v16, v18);
}


================================================================================
Function: sub_250EB28 (0x250EB28)
================================================================================

__int64 __fastcall sub_250EB28(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 *a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x19
  _BYTE *v8; // x20
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x21
  unsigned __int64 v12; // x8
  __int64 v13; // x21
  unsigned __int64 v14; // x22
  __int64 v15; // x10
  __int64 v16; // x23
  __int64 v17; // x24
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x12
  unsigned __int64 v20; // x8
  __int64 v21; // x11
  _BYTE *v22; // x9
  char *v23; // x13
  unsigned __int64 v24; // x14
  __int64 v25; // x15
  _OWORD *v26; // x13
  __int128 *v27; // x14
  unsigned __int64 v28; // x16
  __int128 v29; // q0
  __int128 v30; // q1
  __int64 *v31; // x16
  _QWORD *v32; // x11
  __int64 v33; // x15
  __int64 v34; // t1
  char v35; // t1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_D1C7E0[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_250EF44(a1, v10 >> v9, v8);
  v12 = a5[1];
  v13 = v10 - v11;
  if ( v12 )
  {
    v14 = *a5;
    v15 = *(_QWORD *)(v7 + 16);
    v16 = v14 + v12;
    v17 = v12 + v14;
    do
    {
      v18 = *(_QWORD *)(v7 + 24);
      if ( v18 < v16 - v14 + v15 )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v15 = *(_QWORD *)(v7 + 16);
        v18 = *(_QWORD *)(v7 + 24);
      }
      v19 = v18 - v15;
      if ( v18 - v15 >= v16 - v14 )
        v20 = v16 - v14;
      else
        v20 = v18 - v15;
      if ( !v20 )
        goto LABEL_9;
      v21 = *(_QWORD *)(v7 + 8);
      v22 = (_BYTE *)(v21 + v15);
      if ( v20 >= 8 )
      {
        if ( (unsigned __int64)v22 >= v14 + v20 || (v24 = v20, v23 = (char *)v14, v14 >= v21 + v15 + v20) )
        {
          if ( v20 < 0x20 )
          {
            v25 = 0LL;
LABEL_26:
            v31 = (__int64 *)(v14 + v25);
            if ( v17 - v14 < v19 )
              v19 = v17 - v14;
            v32 = (_QWORD *)(v21 + v15 + v25);
            v23 = (char *)(v14 + (v19 & 0xFFFFFFFFFFFFFFF8LL));
            v22 += v19 & 0xFFFFFFFFFFFFFFF8LL;
            v24 = v20 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            v33 = v25 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v34 = *v31++;
              v33 += 8LL;
              *v32++ = v34;
            }
            while ( v33 );
            if ( v19 == (v19 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_8;
            goto LABEL_33;
          }
          v25 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          v26 = (_OWORD *)(v21 + v15 + 16);
          v27 = (__int128 *)(v14 + 16);
          v28 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v29 = *(v27 - 1);
            v30 = *v27;
            v27 += 2;
            v28 -= 32LL;
            *(v26 - 1) = v29;
            *v26 = v30;
            v26 += 2;
          }
          while ( v28 );
          if ( v20 == v25 )
            goto LABEL_8;
          if ( (v20 & 0x18) != 0 )
            goto LABEL_26;
          v24 = v20 & 0x1F;
          v22 += v25;
          v23 = (char *)(v14 + v25);
        }
      }
      else
      {
        v23 = (char *)v14;
        v24 = v20;
      }
      do
      {
LABEL_33:
        v35 = *v23++;
        --v24;
        *v22++ = v35;
      }
      while ( v24 );
LABEL_8:
      v15 = *(_QWORD *)(v7 + 16);
LABEL_9:
      v15 += v20;
      v14 += v20;
      *(_QWORD *)(v7 + 16) = v15;
    }
    while ( v14 != v16 );
  }
  result = v7;
  if ( v13 )
    return sub_250EF44(v7, v13, v8);
  return result;
}


================================================================================
Function: sub_250ED2C (0x250ED2C)
================================================================================

char *__fastcall sub_250ED2C(_QWORD **a1, unsigned __int8 *a2)
{
  unsigned int v2; // w13
  unsigned int v3; // w15
  unsigned int v4; // w17
  unsigned __int64 v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w10
  __int64 v9; // x11
  int32x4_t v10; // q1
  unsigned __int64 v11; // d0
  _QWORD *v12; // x9
  char *result; // x0

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = ((0x80FF0000uLL >> (*a2 >> 3)) & 1) + byte_D1C6D0[*a2 >> 3];
  v6 = (((dword_D1C790[v5] & (char)*a2) << 18) | ((v2 & 0x3F) << 12) | ((v3 & 0x3F) << 6) | v4 & 0x3F) >> dword_D1C7B8[v5];
  if ( (((v3 >> 4) & 0xC | (v2 >> 2) & 0x30 | (v4 >> 6) & 0xFFFFFE3F | ((v6 < dword_D1C7A4[v5]) << 6) & 0x7F | ((HIWORD(v6) > 0x10u) << 8) | ((v6 >> 11 == 27) << 7)) ^ 0x2A) >> dword_D1C7CC[v5] )
    v7 = -1;
  else
    v7 = (((dword_D1C790[v5] & (char)*a2) << 18) | ((v2 & 0x3F) << 12) | ((v3 & 0x3F) << 6) | v4 & 0x3F) >> dword_D1C7B8[v5];
  if ( v7 >> 8 < 0x11 )
  {
    v9 = 1LL;
  }
  else if ( v7 >> 5 >= 0x8B && v7 - 9001 >= 2 )
  {
    v10 = vdupq_n_s32(v7);
    v11 = vmovn_s16(
            vuzp1q_s16(
              vcgtq_u32((uint32x4_t)xmmword_AFBA60, vaddq_s32(v10, (int32x4_t)xmmword_AFDC60)),
              vcgtq_u32((uint32x4_t)xmmword_AFCD70, vaddq_s32(v10, (int32x4_t)xmmword_B03560)))).n64_u64[0];
    v9 = 2LL;
    if ( !(v11 & 1 | (unsigned __int8)(2 * (BYTE1(v11) & 1)) & 0xC3 | (unsigned __int8)(4 * (BYTE2(v11) & 1)) & 0xC7 | (unsigned __int8)(8 * (BYTE3(v11) & 1)) & 0xCF | (unsigned __int8)(16 * (BYTE4(v11) & 1)) & 0xDF | (unsigned __int8)(32 * (BYTE5(v11) & 1)) | ((BYTE6(v11) & 1u) << 6) | (unsigned __int8)(HIBYTE(v11) << 7))
      && (v7 - 44032) >> 2 >= 0xAE9
      && (v7 == 12351 || (v7 - 11904) >> 4 >= 0x765) )
    {
      if ( v7 >> 8 == 505 )
        v9 = 2LL;
      else
        v9 = 1LL;
    }
  }
  else
  {
    v9 = 2LL;
  }
  v12 = *a1;
  result = (char *)&a2[v5];
  *v12 += v9;
  return result;
}


================================================================================
Function: sub_250EF44 (0x250EF44)
================================================================================

__int64 __fastcall sub_250EF44(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 v3; // x22
  __int64 v5; // x20
  char v7; // w9
  __int64 v8; // x10
  __int64 v9; // x8
  __int64 v10; // x1
  __int64 v11; // x23
  _BYTE *v12; // x24
  __int64 v13; // x10
  _BYTE *v14; // x25
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x26
  unsigned __int64 v17; // x12
  unsigned __int64 v18; // x8
  __int64 v19; // x11
  _BYTE *v20; // x9
  char *v21; // x13
  unsigned __int64 v22; // x14
  __int64 v23; // x15
  _OWORD *v24; // x13
  __int128 *v25; // x14
  unsigned __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  _QWORD *v29; // x11
  __int64 *v30; // x16
  __int64 v31; // x15
  __int64 v32; // t1
  char v33; // t1

  v3 = (unsigned __int8)a3[4];
  v5 = a2;
  if ( (_DWORD)v3 != 1 )
  {
    if ( !a2 )
      return a1;
    v11 = 0LL;
    v12 = &a3[v3];
    while ( !(_DWORD)v3 )
    {
LABEL_9:
      if ( ++v11 == v5 )
        return a1;
    }
    v13 = *(_QWORD *)(a1 + 16);
    v14 = a3;
    while ( 1 )
    {
      v15 = *(_QWORD *)(a1 + 24);
      v16 = v12 - v14;
      if ( v15 < v12 - v14 + v13 )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v13 = *(_QWORD *)(a1 + 16);
        v15 = *(_QWORD *)(a1 + 24);
      }
      v17 = v15 - v13;
      if ( v15 - v13 >= v16 )
        v18 = v12 - v14;
      else
        v18 = v15 - v13;
      if ( !v18 )
        goto LABEL_13;
      v19 = *(_QWORD *)(a1 + 8);
      v20 = (_BYTE *)(v19 + v13);
      if ( v18 >= 8 )
      {
        if ( v20 >= &v14[v18] || (v22 = v18, v21 = v14, (unsigned __int64)v14 >= v19 + v13 + v18) )
        {
          if ( v18 < 0x20 )
          {
            v23 = 0LL;
LABEL_30:
            if ( v16 < v17 )
              v17 = v12 - v14;
            v29 = (_QWORD *)(v19 + v13 + v23);
            v30 = (__int64 *)&v14[v23];
            v21 = &v14[v17 & 0xFFFFFFFFFFFFFFF8LL];
            v20 += v17 & 0xFFFFFFFFFFFFFFF8LL;
            v22 = v18 - (v17 & 0xFFFFFFFFFFFFFFF8LL);
            v31 = v23 - (v17 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v32 = *v30++;
              v31 += 8LL;
              *v29++ = v32;
            }
            while ( v31 );
            if ( v17 == (v17 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_12;
            goto LABEL_37;
          }
          v23 = v18 & 0xFFFFFFFFFFFFFFE0LL;
          v24 = (_OWORD *)(v19 + v13 + 16);
          v25 = (__int128 *)(v14 + 16);
          v26 = v18 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v27 = *(v25 - 1);
            v28 = *v25;
            v25 += 2;
            v26 -= 32LL;
            *(v24 - 1) = v27;
            *v24 = v28;
            v24 += 2;
          }
          while ( v26 );
          if ( v18 == v23 )
            goto LABEL_12;
          if ( (v18 & 0x18) != 0 )
            goto LABEL_30;
          v22 = v18 & 0x1F;
          v20 += v23;
          v21 = &v14[v23];
        }
      }
      else
      {
        v21 = v14;
        v22 = v18;
      }
      do
      {
LABEL_37:
        v33 = *v21++;
        --v22;
        *v20++ = v33;
      }
      while ( v22 );
LABEL_12:
      v13 = *(_QWORD *)(a1 + 16);
LABEL_13:
      v13 += v18;
      v14 += v18;
      *(_QWORD *)(a1 + 16) = v13;
      if ( v14 == v12 )
        goto LABEL_9;
    }
  }
  if ( a2 )
  {
    do
    {
      v9 = *(_QWORD *)(a1 + 16);
      v10 = v9 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v9 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v9 = *(_QWORD *)(a1 + 16);
        v10 = v9 + 1;
      }
      --v5;
      v7 = *a3;
      v8 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v10;
      *(_BYTE *)(v8 + v9) = v7;
    }
    while ( v5 );
  }
  return a1;
}


================================================================================
Function: sub_25226F8 (0x25226F8)
================================================================================

__int64 __fastcall sub_25226F8(__int64 result)
{
  _BYTE *v1; // x19

  v1 = (_BYTE *)result;
  if ( (*(_BYTE *)(result + 24) & 1) != 0 )
    result = sub_65ECAF4();
  if ( (*v1 & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_2527530 (0x2527530)
================================================================================

__int64 __fastcall sub_2527530(unsigned __int64 **a1, __int128 *a2)
{
  unsigned __int64 v3; // x21
  unsigned __int64 v4; // x9
  unsigned __int64 v6; // x23
  __int64 v7; // x0
  unsigned __int64 *v8; // x21
  unsigned __int64 v9; // x23
  __int64 result; // x0
  unsigned __int64 *v11; // x8
  unsigned __int64 *v12; // x10
  unsigned __int64 *v13; // x9
  __int128 v14; // q0
  bool v15; // zf
  unsigned __int64 *v16; // x20
  unsigned __int64 *v17; // x19
  char v18; // t1

  v3 = 0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1);
  v4 = v3 + 1;
  if ( v3 + 1 > 0xAAAAAAAAAAAAAAALL )
    sub_684DBEC();
  if ( 0x5555555555555556LL * (a1[2] - *a1) >= v4 )
    v4 = 0x5555555555555556LL * (a1[2] - *a1);
  if ( 0xAAAAAAAAAAAAAAABLL * (a1[2] - *a1) >= 0x555555555555555LL )
    v6 = 0xAAAAAAAAAAAAAAALL;
  else
    v6 = v4;
  if ( v6 )
  {
    if ( v6 > 0xAAAAAAAAAAAAAAALL )
      sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    v7 = sub_65ECAAC();
  }
  else
  {
    v7 = 0LL;
  }
  v8 = (unsigned __int64 *)(v7 + 24 * v3);
  v9 = v7 + 24 * v6;
  result = (__int64)sub_68497A0(v8, a2);
  v11 = *a1;
  v12 = a1[1];
  v13 = v8 + 3;
  if ( v12 == *a1 )
  {
    v16 = *a1;
  }
  else
  {
    do
    {
      v14 = *(_OWORD *)(v12 - 3);
      *(v8 - 1) = *(v12 - 1);
      *(_OWORD *)(v8 - 3) = v14;
      v8 -= 3;
      *(v12 - 2) = 0LL;
      *(v12 - 1) = 0LL;
      v15 = v12 - 3 == v11;
      *(v12 - 3) = 0LL;
      v12 -= 3;
    }
    while ( !v15 );
    v16 = *a1;
    v11 = a1[1];
  }
  *a1 = v8;
  a1[1] = v13;
  a1[2] = (unsigned __int64 *)v9;
  if ( v11 != v16 )
  {
    v17 = v11;
    do
    {
      v18 = *((_BYTE *)v17 - 24);
      v17 -= 3;
      if ( (v18 & 1) != 0 )
        result = sub_65ECAF4();
    }
    while ( v17 != v16 );
  }
  if ( v16 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_2527820 (0x2527820)
================================================================================

__int64 __fastcall sub_2527820(__int64 result, __int64 a2)
{
  __int64 v2; // x9
  __int64 v3; // x8
  __int64 *v4; // x11
  _BYTE *v5; // x11
  int v6; // t1
  __int64 v7; // x11
  int v8; // t1
  __int64 *v9; // x10
  __int64 v10; // x11
  __int64 v11; // x10
  __int64 *v12; // x9
  __int64 v13; // x10
  __int64 **v14; // x10
  __int64 v15; // x11

  *(_BYTE *)(a2 + 24) = a2 == result;
  if ( a2 != result )
  {
    do
    {
      v2 = *(_QWORD *)(a2 + 16);
      if ( *(_BYTE *)(v2 + 24) )
        return result;
      v3 = *(_QWORD *)(v2 + 16);
      v4 = *(__int64 **)v3;
      if ( *(_QWORD *)v3 == v2 )
      {
        v7 = *(_QWORD *)(v3 + 8);
        if ( !v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8) )
        {
          if ( *(_QWORD *)v2 == a2 )
          {
            v9 = *(__int64 **)(a2 + 16);
          }
          else
          {
            v9 = *(__int64 **)(v2 + 8);
            v10 = *v9;
            *(_QWORD *)(v2 + 8) = *v9;
            if ( v10 )
            {
              *(_QWORD *)(v10 + 16) = v2;
              v3 = *(_QWORD *)(v2 + 16);
            }
            v9[2] = v3;
            *(_QWORD *)(*(_QWORD *)(v2 + 16) + 8LL * (**(_QWORD **)(v2 + 16) != v2)) = v9;
            *(_QWORD *)(v2 + 16) = v9;
            v3 = v9[2];
            *v9 = v2;
          }
          v12 = *(__int64 **)v3;
          v15 = *(_QWORD *)(*(_QWORD *)v3 + 8LL);
          *((_BYTE *)v9 + 24) = 1;
          *(_BYTE *)(v3 + 24) = 0;
          *(_QWORD *)v3 = v15;
          if ( v15 )
            *(_QWORD *)(v15 + 16) = v3;
          v14 = (__int64 **)(v3 + 16);
          v12[2] = *(_QWORD *)(v3 + 16);
          *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8LL * (**(_QWORD **)(v3 + 16) != v3)) = v12;
          v12[1] = v3;
          goto LABEL_27;
        }
      }
      else if ( !v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6) )
      {
        if ( *(_QWORD *)v2 == a2 )
        {
          v11 = *(_QWORD *)(a2 + 8);
          *(_QWORD *)v2 = v11;
          if ( v11 )
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = *(_QWORD *)(v2 + 16);
          }
          *(_QWORD *)(a2 + 16) = v3;
          *(_QWORD *)(*(_QWORD *)(v2 + 16) + 8LL * (**(_QWORD **)(v2 + 16) != v2)) = a2;
          *(_QWORD *)(v2 + 16) = a2;
          v3 = *(_QWORD *)(a2 + 16);
          *(_QWORD *)(a2 + 8) = v2;
        }
        else
        {
          a2 = *(_QWORD *)(a2 + 16);
        }
        v12 = *(__int64 **)(v3 + 8);
        v13 = *v12;
        *(_BYTE *)(a2 + 24) = 1;
        *(_BYTE *)(v3 + 24) = 0;
        *(_QWORD *)(v3 + 8) = v13;
        if ( v13 )
          *(_QWORD *)(v13 + 16) = v3;
        v14 = (__int64 **)(v3 + 16);
        v12[2] = *(_QWORD *)(v3 + 16);
        *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8LL * (**(_QWORD **)(v3 + 16) != v3)) = v12;
        *v12 = v3;
LABEL_27:
        *v14 = v12;
        return result;
      }
      a2 = *(_QWORD *)(v2 + 16);
      *(_BYTE *)(v2 + 24) = 1;
      *(_BYTE *)(v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while ( v3 != result );
  }
  return result;
}


================================================================================
Function: sub_252A00C (0x252A00C)
================================================================================

__int64 __fastcall sub_252A00C(__int64 a1, _QWORD *a2)
{
  _QWORD *v3; // x9
  __int64 v4; // x8
  __int64 v5; // x1
  __int64 v6; // x0
  __int64 v7; // x0
  _QWORD *v8; // x20
  _QWORD *v9; // x22
  __int64 v10; // x0
  __int64 v11; // x0
  __int64 v12; // x0
  __int64 v13; // x0
  __int64 v14; // x20
  __int64 v15; // x21
  char v16; // t1
  __int64 v17; // x20
  __int64 v18; // x21
  __int64 v19; // x22
  __int64 v20; // x20
  __int64 v21; // x21
  char v22; // t1
  __int64 v23; // x20
  __int64 v24; // x21
  char v25; // t1
  __int64 v26; // x20
  __int64 v27; // x21
  char v28; // t1

  v3 = (_QWORD *)(*a2 - 344LL);
  *(_QWORD *)a1 = *a2;
  v4 = a2[1];
  v5 = *(_QWORD *)(a1 + 424);
  *(_QWORD *)(a1 + *v3) = v4;
  sub_252A2E0(a1 + 408, v5);
  v6 = *(_QWORD *)(a1 + 408);
  *(_QWORD *)(a1 + 408) = 0LL;
  if ( v6 )
    sub_65ECAF4();
  if ( *(_BYTE *)(a1 + 392) && (*(_BYTE *)(a1 + 368) & 1) != 0 )
    sub_65ECAF4();
  if ( *(_BYTE *)(a1 + 360) && (*(_BYTE *)(a1 + 336) & 1) != 0 )
    sub_65ECAF4();
  sub_252A384(a1 + 296, *(_QWORD *)(a1 + 312));
  v7 = *(_QWORD *)(a1 + 296);
  *(_QWORD *)(a1 + 296) = 0LL;
  if ( v7 )
    v7 = sub_65ECAF4();
  v8 = *(_QWORD **)(a1 + 272);
  if ( v8 )
  {
    do
    {
      v9 = (_QWORD *)*v8;
      sub_252A418(v7, a1 + 272, v8 + 2);
      v7 = sub_65ECAF4();
      v8 = v9;
    }
    while ( v9 );
  }
  v10 = *(_QWORD *)(a1 + 256);
  *(_QWORD *)(a1 + 256) = 0LL;
  if ( v10 )
    sub_65ECAF4();
  sub_252A4A8(a1 + 216, *(_QWORD *)(a1 + 232));
  v11 = *(_QWORD *)(a1 + 216);
  *(_QWORD *)(a1 + 216) = 0LL;
  if ( v11 )
    sub_65ECAF4();
  sub_252A53C(a1 + 176, *(_QWORD *)(a1 + 192));
  v12 = *(_QWORD *)(a1 + 176);
  *(_QWORD *)(a1 + 176) = 0LL;
  if ( v12 )
    sub_65ECAF4();
  sub_252A5D0(a1 + 136, *(_QWORD *)(a1 + 152));
  v13 = *(_QWORD *)(a1 + 136);
  *(_QWORD *)(a1 + 136) = 0LL;
  if ( v13 )
    sub_65ECAF4();
  v14 = *(_QWORD *)(a1 + 112);
  if ( v14 )
  {
    if ( *(_QWORD *)(a1 + 120) != v14 )
    {
      v15 = *(_QWORD *)(a1 + 120);
      do
      {
        v16 = *(_BYTE *)(v15 - 32);
        v15 -= 32LL;
        if ( (v16 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v15 != v14 );
    }
    *(_QWORD *)(a1 + 120) = v14;
    sub_65ECAF4();
  }
  v17 = *(_QWORD *)(a1 + 88);
  if ( v17 )
  {
    v18 = *(_QWORD *)(a1 + 96);
    if ( v18 != v17 )
    {
      do
      {
        if ( (*(_BYTE *)(v18 - 24) & 1) != 0 )
          sub_65ECAF4();
        v19 = v18 - 48;
        if ( (*(_BYTE *)(v18 - 48) & 1) != 0 )
          sub_65ECAF4();
        v18 -= 48LL;
      }
      while ( v19 != v17 );
    }
    *(_QWORD *)(a1 + 96) = v17;
    sub_65ECAF4();
  }
  v20 = *(_QWORD *)(a1 + 64);
  if ( v20 )
  {
    if ( *(_QWORD *)(a1 + 72) != v20 )
    {
      v21 = *(_QWORD *)(a1 + 72);
      do
      {
        v22 = *(_BYTE *)(v21 - 32);
        v21 -= 32LL;
        if ( (v22 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v21 != v20 );
    }
    *(_QWORD *)(a1 + 72) = v20;
    sub_65ECAF4();
  }
  v23 = *(_QWORD *)(a1 + 40);
  if ( v23 )
  {
    if ( *(_QWORD *)(a1 + 48) != v23 )
    {
      v24 = *(_QWORD *)(a1 + 48);
      do
      {
        v25 = *(_BYTE *)(v24 - 32);
        v24 -= 32LL;
        if ( (v25 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v24 != v23 );
    }
    *(_QWORD *)(a1 + 48) = v23;
    sub_65ECAF4();
  }
  v26 = *(_QWORD *)(a1 + 16);
  if ( v26 )
  {
    if ( *(_QWORD *)(a1 + 24) != v26 )
    {
      v27 = *(_QWORD *)(a1 + 24);
      do
      {
        v28 = *(_BYTE *)(v27 - 32);
        v27 -= 32LL;
        if ( (v28 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v27 != v26 );
    }
    *(_QWORD *)(a1 + 24) = v26;
    sub_65ECAF4();
  }
  return nullsub_255(a1 + 8);
}


================================================================================
Function: sub_252A2E0 (0x252A2E0)
================================================================================

__int64 __fastcall sub_252A2E0(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 *v4; // x21
  __int64 *v5; // x20
  __int64 *v6; // x22
  char v7; // t1

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = v2[5];
      v5 = *v2;
      if ( v4 )
      {
        if ( v2[6] != v4 )
        {
          v6 = v2[6];
          do
          {
            v7 = *((_BYTE *)v6 - 24);
            v6 -= 3;
            if ( (v7 & 1) != 0 )
              sub_65ECAF4();
          }
          while ( v6 != v4 );
        }
        v2[6] = v4;
        sub_65ECAF4();
      }
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_65ECAF4();
      result = sub_65ECAF4();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_252A384 (0x252A384)
================================================================================

__int64 __fastcall sub_252A384(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_65ECAF4();
          sub_65ECAF4();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_65ECAF4();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_65ECAF4();
      result = sub_65ECAF4();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_252A418 (0x252A418)
================================================================================

__int64 __fastcall sub_252A418(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 **v4; // x20
  __int64 result; // x0
  __int64 *v6; // x21

  v4 = *(__int64 ***)(a3 + 40);
  if ( v4 )
  {
    do
    {
      v6 = *v4;
      if ( ((_BYTE)v4[5] & 1) != 0 )
        sub_65ECAF4();
      if ( ((_BYTE)v4[2] & 1) != 0 )
        sub_65ECAF4();
      sub_65ECAF4();
      v4 = (__int64 **)v6;
    }
    while ( v6 );
  }
  result = *(_QWORD *)(a3 + 24);
  *(_QWORD *)(a3 + 24) = 0LL;
  if ( result )
    result = sub_65ECAF4();
  if ( (*(_BYTE *)a3 & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_252A4A8 (0x252A4A8)
================================================================================

__int64 __fastcall sub_252A4A8(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_65ECAF4();
          sub_65ECAF4();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_65ECAF4();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_65ECAF4();
      result = sub_65ECAF4();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_252A53C (0x252A53C)
================================================================================

__int64 __fastcall sub_252A53C(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_65ECAF4();
          sub_65ECAF4();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_65ECAF4();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_65ECAF4();
      result = sub_65ECAF4();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_252A5D0 (0x252A5D0)
================================================================================

__int64 __fastcall sub_252A5D0(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_65ECAF4();
          sub_65ECAF4();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_65ECAF4();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_65ECAF4();
      result = sub_65ECAF4();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_252D9E8 (0x252D9E8)
================================================================================

__int64 **__fastcall sub_252D9E8(_QWORD *a1, unsigned __int8 *a2)
{
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x8
  bool v6; // zf
  unsigned __int64 v7; // x8
  __int64 *v8; // x1
  unsigned __int64 v9; // x2
  unsigned __int64 v10; // x0
  int8x8_t v11; // x24
  unsigned __int64 v12; // x19
  uint8x8_t v13; // d0
  unsigned __int64 v14; // x25
  unsigned __int64 v15; // x26
  __int64 ***v16; // x8
  size_t v17; // x10
  unsigned __int8 *v18; // x11
  unsigned __int8 *v19; // x12
  unsigned __int64 v20; // x9
  __int64 **v21; // x20
  size_t v22; // x21
  unsigned __int8 *v23; // x22
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x10
  unsigned __int64 v26; // x11
  __int64 *v27; // x0
  __int64 v28; // x9
  __int64 v30; // [xsp+0h] [xbp-10h] BYREF

  v4 = *((_QWORD *)a2 + 1);
  v5 = *a2;
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
    v8 = (__int64 *)(a2 + 1);
  else
    v8 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v6 )
    v9 = v7;
  else
    v9 = v4;
  v10 = sub_24FE128((__int64)&v30, v8, v9);
  v11.n64_u64[0] = a1[1];
  if ( !v11.n64_u64[0] )
    return 0LL;
  v12 = v10;
  v13.n64_u64[0] = vcnt_s8(v11).n64_u64[0];
  v13.n64_u16[0] = vaddlv_u8(v13);
  v14 = v13.n64_u32[0];
  if ( v13.n64_u32[0] > 1uLL )
  {
    v15 = v10;
    if ( v10 >= v11.n64_u64[0] )
      v15 = v10 % v11.n64_u64[0];
  }
  else
  {
    v15 = (v11.n64_u64[0] - 1) & v10;
  }
  v16 = *(__int64 ****)(*a1 + 8 * v15);
  if ( !v16 )
    return 0LL;
  v17 = *((_QWORD *)a2 + 1);
  v18 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  v19 = a2 + 1;
  v20 = *a2;
  v21 = *v16;
  if ( (v20 & 1) != 0 )
    v22 = v17;
  else
    v22 = v20 >> 1;
  if ( (v20 & 1) != 0 )
    v23 = v18;
  else
    v23 = v19;
  for ( ; v21; v21 = (__int64 **)*v21 )
  {
    v24 = (unsigned __int64)v21[1];
    if ( v24 == v12 )
    {
      v25 = *((unsigned __int8 *)v21 + 16);
      v26 = (unsigned __int64)v21[3];
      if ( (v25 & 1) == 0 )
        v26 = v25 >> 1;
      if ( v26 == v22 )
      {
        if ( (v25 & 1) != 0 )
          v27 = v21[4];
        else
          v27 = (__int64 *)((char *)v21 + 17);
        if ( (v25 & 1) != 0 )
        {
          if ( !v22 || !memcmp(v27, v23, v22) )
            return v21;
        }
        else
        {
          if ( !v22 )
            return v21;
          v28 = 0LL;
          while ( *((unsigned __int8 *)v21 + v28 + 17) == v23[v28] )
          {
            if ( v25 >> 1 == ++v28 )
              return v21;
          }
        }
      }
    }
    else
    {
      if ( v14 <= 1 )
      {
        v24 &= v11.n64_u64[0] - 1;
      }
      else if ( v24 >= v11.n64_u64[0] )
      {
        v24 %= v11.n64_u64[0];
      }
      if ( v24 != v15 )
        return 0LL;
    }
  }
  return v21;
}


================================================================================
Function: sub_252DBAC (0x252DBAC)
================================================================================

__int64 **__fastcall sub_252DBAC(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3, __int64 *a4)
{
  unsigned __int64 v4; // x27
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  bool v10; // zf
  unsigned __int64 v11; // x8
  __int64 *v12; // x1
  unsigned __int64 v13; // x2
  unsigned __int64 v14; // x0
  unsigned __int64 v15; // x20
  unsigned __int64 v16; // x26
  uint8x8_t v17; // d0
  unsigned __int64 v18; // x28
  __int64 ***v19; // x8
  unsigned __int64 v20; // x10
  unsigned __int8 *v21; // x11
  unsigned __int8 *v22; // x12
  unsigned __int64 v23; // x9
  __int64 **v24; // x22
  size_t v25; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x11
  __int64 *v30; // x0
  __int64 v31; // x9
  __int64 v32; // x0
  __int64 v33; // x8
  __int64 v34; // x9
  __int64 v35; // x8
  float v36; // s1
  float v37; // s0
  _BOOL8 v38; // x9
  unsigned __int64 v39; // x10
  unsigned __int64 v40; // x1
  _QWORD *v41; // x8
  __int64 v42; // x9
  unsigned __int64 v43; // x9
  _QWORD v45[2]; // [xsp+0h] [xbp-20h] BYREF
  char v46; // [xsp+10h] [xbp-10h]

  v8 = *((_QWORD *)a2 + 1);
  v9 = *a2;
  v10 = (v9 & 1) == 0;
  v11 = v9 >> 1;
  if ( v10 )
    v12 = (__int64 *)(a2 + 1);
  else
    v12 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v10 )
    v13 = v11;
  else
    v13 = v8;
  v14 = sub_24FE128((__int64)v45, v12, v13);
  v15 = v14;
  v16 = *(_QWORD *)(a1 + 8);
  if ( v16 )
  {
    v17.n64_u64[0] = vcnt_s8((int8x8_t)v16).n64_u64[0];
    v17.n64_u16[0] = vaddlv_u8(v17);
    v18 = v17.n64_u32[0];
    if ( v17.n64_u32[0] > 1uLL )
    {
      v4 = v14;
      if ( v14 >= v16 )
        v4 = v14 % v16;
    }
    else
    {
      v4 = (v16 - 1) & v14;
    }
    v19 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v4);
    if ( v19 )
    {
      v20 = *((_QWORD *)a2 + 1);
      v21 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v22 = a2 + 1;
      v23 = *a2;
      v24 = *v19;
      v25 = (v23 & 1) != 0 ? v20 : v23 >> 1;
      for ( i = (v23 & 1) != 0 ? v21 : v22; v24; v24 = (__int64 **)*v24 )
      {
        v27 = (unsigned __int64)v24[1];
        if ( v27 != v15 )
        {
          if ( v18 > 1 )
          {
            if ( v27 >= v16 )
              v27 %= v16;
          }
          else
          {
            v27 &= v16 - 1;
          }
          if ( v27 != v4 )
            break;
        }
        v28 = *((unsigned __int8 *)v24 + 16);
        v29 = (unsigned __int64)v24[3];
        if ( (v28 & 1) == 0 )
          v29 = v28 >> 1;
        if ( v29 == v25 )
        {
          if ( (v28 & 1) != 0 )
            v30 = v24[4];
          else
            v30 = (__int64 *)((char *)v24 + 17);
          if ( (v28 & 1) != 0 )
          {
            if ( !v25 || !memcmp(v30, i, v25) )
              return v24;
          }
          else
          {
            if ( !v25 )
              return v24;
            v31 = 0LL;
            while ( *((unsigned __int8 *)v24 + v31 + 17) == i[v31] )
            {
              if ( v28 >> 1 == ++v31 )
                return v24;
            }
          }
        }
      }
    }
  }
  v32 = sub_65ECAAC();
  v33 = *a4;
  v45[0] = v32;
  v45[1] = a1 + 16;
  v34 = *(_QWORD *)(v33 + 16);
  *(_OWORD *)(v32 + 16) = *(_OWORD *)v33;
  *(_QWORD *)(v32 + 32) = v34;
  *(_QWORD *)(v33 + 8) = 0LL;
  *(_QWORD *)(v33 + 16) = 0LL;
  *(_QWORD *)v33 = 0LL;
  v35 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v32 + 48) = 0LL;
  *(_QWORD *)(v32 + 56) = 0LL;
  v36 = *(float *)(a1 + 32);
  *(_QWORD *)(v32 + 40) = 0LL;
  v46 = 1;
  *(_QWORD *)v32 = 0LL;
  *(_QWORD *)(v32 + 8) = v15;
  v37 = (float)(unsigned __int64)(v35 + 1);
  if ( !v16 || (float)(v36 * (float)v16) < v37 )
  {
    v38 = v16 < 3 || (v16 & (v16 - 1)) != 0;
    v39 = vcvtps_u32_f32(v37 / v36);
    if ( (v38 | (2 * v16)) >= v39 )
      v40 = v38 | (2 * v16);
    else
      v40 = v39;
    sub_252DEFC(a1, v40);
    v16 = *(_QWORD *)(a1 + 8);
    if ( (v16 & (v16 - 1)) != 0 )
    {
      if ( v15 >= v16 )
        v4 = v15 % v16;
      else
        v4 = v15;
    }
    else
    {
      v4 = (v16 - 1) & v15;
    }
  }
  v41 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if ( v41 )
  {
    *(_QWORD *)v45[0] = *v41;
    *v41 = v45[0];
  }
  else
  {
    *(_QWORD *)v45[0] = *(_QWORD *)(a1 + 16);
    v42 = *(_QWORD *)a1;
    *(_QWORD *)(a1 + 16) = v45[0];
    *(_QWORD *)(v42 + 8 * v4) = a1 + 16;
    if ( *(_QWORD *)v45[0] )
    {
      v43 = *(_QWORD *)(*(_QWORD *)v45[0] + 8LL);
      if ( (v16 & (v16 - 1)) != 0 )
      {
        if ( v43 >= v16 )
          v43 %= v16;
      }
      else
      {
        v43 &= v16 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v43) = v45[0];
    }
  }
  v24 = (__int64 **)v45[0];
  ++*(_QWORD *)(a1 + 24);
  return v24;
}


================================================================================
Function: sub_252DEFC (0x252DEFC)
================================================================================

unsigned __int64 __fastcall sub_252DEFC(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  unsigned __int64 v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3 = 2LL;
  }
  else
  {
    v3 = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_681B888(a2);
      v3 = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3 > v4.n64_u64[0] )
    return sub_252E034(v2, v3);
  if ( v3 < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_681B888(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3 < result )
      v3 = result;
    if ( v3 < v4.n64_u64[0] )
      return sub_252E034(v2, v3);
  }
  return result;
}


================================================================================
Function: sub_252E034 (0x252E034)
================================================================================

__int64 __fastcall sub_252E034(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // x8
  __int64 result; // x0
  __int64 v6; // x8
  _QWORD *v7; // x13
  unsigned __int64 v8; // x11
  uint8x8_t v9; // d0
  unsigned __int64 v10; // x10
  __int64 *v11; // x26
  unsigned __int64 v12; // x12
  unsigned __int64 v13; // x27
  __int64 v14; // x8
  unsigned __int64 v15; // x24
  _QWORD *v16; // x28
  size_t v17; // x21
  _QWORD *v18; // x23
  __int64 v19; // x8
  char v20; // w9
  unsigned int v21; // t1
  unsigned __int64 v22; // x10
  unsigned __int64 v23; // x11
  unsigned __int8 *v24; // x1
  unsigned __int8 *v25; // x8
  unsigned __int64 v26; // x9
  unsigned __int64 v27; // [xsp+8h] [xbp-18h]
  _QWORD *v28; // [xsp+10h] [xbp-10h]
  unsigned __int64 v29; // [xsp+18h] [xbp-8h]

  if ( a2 )
  {
    if ( a2 >> 61 )
      sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    v4 = sub_65ECAAC();
    result = *a1;
    *a1 = v4;
    if ( result )
      result = sub_65ECAF4();
    v6 = 0LL;
    a1[1] = a2;
    do
      *(_QWORD *)(*a1 + 8 * v6++) = 0LL;
    while ( a2 != v6 );
    v7 = (_QWORD *)a1[2];
    if ( v7 )
    {
      v8 = v7[1];
      v9.n64_u64[0] = vcnt_s8((int8x8_t)a2).n64_u64[0];
      v9.n64_u16[0] = vaddlv_u8(v9);
      v10 = v9.n64_u32[0];
      if ( v9.n64_u32[0] > 1uLL )
      {
        if ( v8 >= a2 )
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v8) = a1 + 2;
      v11 = (__int64 *)*v7;
      if ( *v7 )
      {
        v12 = a2 - 1;
        v27 = v9.n64_u32[0];
        do
        {
          v13 = v11[1];
          if ( v10 > 1 )
          {
            if ( v13 >= a2 )
              v13 %= a2;
          }
          else
          {
            v13 &= v12;
          }
          if ( v13 == v8 )
          {
            v7 = v11;
          }
          else if ( *(_QWORD *)(*a1 + 8 * v13) )
          {
            v14 = *v11;
            if ( *v11 )
            {
              v15 = *((unsigned __int8 *)v11 + 16);
              v16 = v11;
              v28 = v7;
              v29 = v8;
              if ( (v15 & 1) != 0 )
                v17 = v11[3];
              else
                v17 = v15 >> 1;
              while ( 1 )
              {
                v18 = v16;
                v16 = (_QWORD *)v14;
                v21 = *(unsigned __int8 *)(v14 + 16);
                v19 = v14 + 16;
                v20 = v21;
                v22 = *(_QWORD *)(v19 + 8);
                v23 = (unsigned __int64)v21 >> 1;
                if ( (v21 & 1) == 0 )
                  v22 = v23;
                if ( v17 != v22 )
                  break;
                if ( (v15 & 1) != 0 )
                  result = v11[4];
                else
                  result = (__int64)v11 + 17;
                if ( (v20 & 1) != 0 )
                  v24 = (unsigned __int8 *)v16[4];
                else
                  v24 = (unsigned __int8 *)(v19 + 1);
                if ( (v15 & 1) != 0 )
                {
                  if ( v17 )
                  {
                    result = memcmp((const void *)result, v24, v17);
                    if ( (_DWORD)result )
                      break;
                  }
                }
                else
                {
                  v25 = (unsigned __int8 *)v11 + 17;
                  v26 = v15 >> 1;
                  if ( v17 )
                  {
                    while ( *v25 == *v24 )
                    {
                      --v26;
                      ++v25;
                      ++v24;
                      if ( !v26 )
                        goto LABEL_29;
                    }
                    break;
                  }
                }
LABEL_29:
                v14 = *v16;
                if ( !*v16 )
                {
                  v18 = v16;
                  v16 = 0LL;
                  break;
                }
              }
              v12 = a2 - 1;
              v10 = v27;
              v8 = v29;
              v7 = v28;
            }
            else
            {
              v16 = 0LL;
              v18 = v11;
            }
            *v7 = v16;
            *v18 = **(_QWORD **)(*a1 + 8 * v13);
            **(_QWORD **)(*a1 + 8 * v13) = v11;
          }
          else
          {
            *(_QWORD *)(*a1 + 8 * v13) = v7;
            v7 = v11;
            v8 = v13;
          }
          v11 = (__int64 *)*v7;
        }
        while ( *v7 );
      }
    }
  }
  else
  {
    result = *a1;
    *a1 = 0LL;
    if ( result )
      result = sub_65ECAF4();
    a1[1] = 0LL;
  }
  return result;
}


================================================================================
Function: sub_2530DB0 (0x2530DB0)
================================================================================

_QWORD *__fastcall sub_2530DB0(_QWORD *a1, int a2, int a3)
{
  char *v6; // x22
  int v7; // w5
  __int64 v8; // x23
  int v9; // w26
  __int64 v10; // x2
  __int64 *v11; // x0
  char v12; // w24
  int v13; // w2
  _BYTE v15[16]; // [xsp+0h] [xbp-20h] BYREF
  __int64 v16; // [xsp+10h] [xbp-10h] BYREF

  sub_681DD74(v15, a1);
  if ( v15[0] )
  {
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_DWORD *)v6 + 36);
    v8 = *((_QWORD *)v6 + 5);
    v9 = *((_DWORD *)v6 + 2);
    if ( v7 == -1 )
    {
      sub_681C794(&v16, (char *)a1 + *(_QWORD *)(*a1 - 24LL));
      v11 = sub_683BBD0(&v16, (__int64)&unk_79D7E58, v10);
      v12 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*v11 + 56))(v11, 32LL);
      sub_683B844(&v16);
      v7 = v12;
      *((_DWORD *)v6 + 36) = v12;
    }
    if ( (v9 & 0xB0) == 0x20 )
      v13 = a2 + a3;
    else
      v13 = a2;
    if ( !sub_2530F38(v8, a2, v13, a2 + a3, (int)v6, v7) )
      sub_681F428((char *)a1 + *(_QWORD *)(*a1 - 24LL), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 5u);
  }
  sub_681DDC8(v15);
  return a1;
}


================================================================================
Function: sub_2530F38 (0x2530F38)
================================================================================

__int64 __fastcall sub_2530F38(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int c)
{
  __int64 v6; // x19
  __int64 v7; // x8
  bool v12; // cc
  size_t v13; // x8
  __int64 v14; // x25
  size_t v15; // x23
  char *v16; // x25
  _QWORD *v17; // x1
  __int64 v18; // x24
  __int64 v19; // x22
  _QWORD v21[2]; // [xsp+0h] [xbp-20h] BYREF
  _QWORD *v22; // [xsp+10h] [xbp-10h]

  v6 = a1;
  if ( a1 )
  {
    v7 = *(_QWORD *)(a5 + 24);
    v12 = v7 <= a4 - a2;
    v13 = v7 - (a4 - a2);
    v14 = a3 - a2;
    if ( v12 )
      v15 = 0LL;
    else
      v15 = v13;
    if ( v14 >= 1 && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 96LL))(a1) != v14 )
      return 0LL;
    if ( v15 )
    {
      if ( v15 >= 0x17 )
      {
        v16 = (char *)sub_65ECAAC();
        v21[1] = v15;
        v22 = v16;
        v21[0] = (v15 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        v16 = (char *)v21 + 1;
        LOBYTE(v21[0]) = 2 * v15;
      }
      memset(v16, c, v15);
      v16[v15] = 0;
      v17 = (v21[0] & 1) != 0 ? v22 : (_QWORD *)((char *)v21 + 1);
      v18 = (*(__int64 (__fastcall **)(__int64, _QWORD *, size_t))(*(_QWORD *)v6 + 96LL))(v6, v17, v15);
      if ( (v21[0] & 1) != 0 )
        sub_65ECAF4();
      if ( v18 != v15 )
        return 0LL;
    }
    v19 = a4 - a3;
    if ( v19 < 1 || (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 96LL))(v6, a3, v19) == v19 )
      *(_QWORD *)(a5 + 24) = 0LL;
    else
      return 0LL;
  }
  return v6;
}


================================================================================
Function: sub_2532638 (0x2532638)
================================================================================

void __fastcall __noreturn sub_2532638(__int64 a1)
{
  __int64 v2; // x19

  v2 = sub_6861FD0(16LL);
  sub_2532688(v2, a1);
  sub_6862048(v2, (__int64)&`typeinfo for'std::out_of_range, (__int64)sub_68652A0);
}


================================================================================
Function: sub_2532688 (0x2532688)
================================================================================

__int64 __fastcall sub_2532688(_QWORD *a1, char *a2)
{
  __int64 result; // x0

  result = sub_6849410((int)a1, a2);
  *a1 = off_6C5EF98;
  return result;
}


================================================================================
Function: sub_2532D50 (0x2532D50)
================================================================================

__int64 __fastcall sub_2532D50(__int64 *a1, __int128 **a2)
{
  __int128 *v3; // x8
  __int64 result; // x0
  unsigned __int64 v5; // x22
  unsigned __int64 *v7; // x20
  __int128 *i; // x21
  __int128 *v9; // x22

  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  v3 = a2[1];
  result = (char *)v3 - (char *)*a2;
  if ( v3 != *a2 )
  {
    v5 = 0xAAAAAAAAAAAAAAABLL * (result >> 3);
    if ( v5 >= 0xAAAAAAAAAAAAAABLL )
      sub_684DBEC();
    result = sub_65ECAAC();
    *a1 = result;
    a1[1] = result;
    v7 = (unsigned __int64 *)result;
    a1[2] = result + 24 * v5;
    v9 = *a2;
    for ( i = a2[1]; v9 != i; v7 += 3 )
    {
      result = (__int64)sub_68497A0(v7, v9);
      v9 = (__int128 *)((char *)v9 + 24);
    }
    a1[1] = (__int64)v7;
  }
  return result;
}


================================================================================
Function: sub_2533228 (0x2533228)
================================================================================

__int64 __fastcall sub_2533228(__int64 a1)
{
  unsigned __int64 v2; // x20
  unsigned __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_6867450(1LL, a1 + 56);
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65EFD58(0LL, "Reference count overflow");
  if ( v2 >> 62 != 2 )
  {
    sub_65EF508(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7301220);
      v5 = sub_65FD0A0(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_253344C(v5);
      sub_6867600(0x8000000000000000LL, a1 + 56);
    }
    sub_6848B0C(a1 + 8);
  }
  return a1;
}


================================================================================
Function: sub_253344C (0x253344C)
================================================================================

__int64 sub_253344C()
{
  __int64 v0; // x19

  v0 = sub_65ED63C(3648LL, 16LL);
  sub_629F290();
  return v0;
}


================================================================================
Function: sub_253ABD8 (0x253ABD8)
================================================================================

void __noreturn sub_253ABD8()
{
  __int64 v0; // x19

  v0 = sub_6861FD0(8LL);
  sub_68656D0();
  sub_6862048(v0, (__int64)&`typeinfo for'std::bad_cast, (__int64)sub_68656E8);
}


================================================================================
Function: sub_2563FCC (0x2563FCC)
================================================================================

__int64 *__fastcall sub_2563FCC(__int64 *result, __int64 *a2)
{
  __int64 v2; // x9
  __int64 *v3; // x10
  __int64 *v4; // x8
  int v5; // w11
  __int64 **v6; // x12
  __int64 *v7; // x8
  int v8; // w12
  __int64 v9; // x13
  __int64 v10; // x13
  __int64 v11; // x14
  __int64 **v12; // x10
  _QWORD *v13; // x10
  _QWORD *v14; // x11
  __int64 *v15; // x11
  __int64 *v16; // x12
  __int64 *v17; // x12
  __int64 *v18; // x11
  __int64 *v19; // x10
  __int64 *v20; // x11
  __int64 *v21; // x10
  __int64 v22; // x9
  __int64 v23; // x9
  __int64 *v24; // x8
  __int64 v25; // x9
  __int64 v26; // x10
  __int64 v27; // x8
  __int64 *v28; // x9
  __int64 v29; // x10

  v2 = *a2;
  v3 = a2;
  if ( *a2 )
  {
    v4 = (__int64 *)a2[1];
    if ( !v4 )
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (__int64 *)*v4;
    }
    while ( v4 );
  }
  v2 = v3[1];
  if ( v2 )
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (__int64 **)v3[2];
  v7 = *v6;
  if ( *v6 == v3 )
  {
    *v6 = (__int64 *)v2;
    if ( v3 == result )
    {
      v7 = 0LL;
      result = (__int64 *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (__int64 *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if ( v3 != a2 )
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8LL * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if ( v10 )
      *(_QWORD *)(v10 + 16) = v3;
    if ( result == a2 )
      result = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
  }
  if ( !v8 || !result )
    return result;
  if ( !v5 )
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while ( 1 )
  {
    v12 = (__int64 **)v7[2];
    if ( *v12 == v7 )
      break;
    if ( *((_BYTE *)v7 + 24) )
    {
      v13 = (_QWORD *)*v7;
      if ( !*v7 )
        goto LABEL_37;
    }
    else
    {
      v15 = v12[1];
      *((_BYTE *)v7 + 24) = 1;
      *((_BYTE *)v12 + 24) = 0;
      v16 = (__int64 *)*v15;
      v12[1] = (__int64 *)*v15;
      if ( v16 )
        v16[2] = (__int64)v12;
      v15[2] = (__int64)v12[2];
      v12[2][*v12[2] != (_QWORD)v12] = (__int64)v15;
      *v15 = (__int64)v12;
      v17 = (__int64 *)*v7;
      v12[2] = v15;
      if ( result == v17 )
        result = v7;
      v7 = (__int64 *)v17[1];
      v13 = (_QWORD *)*v7;
      if ( !*v7 )
        goto LABEL_37;
    }
    if ( !*((_BYTE *)v13 + 24) )
    {
      v18 = (__int64 *)v7[1];
      if ( !v18 )
        goto LABEL_59;
LABEL_58:
      if ( *((_BYTE *)v18 + 24) )
      {
LABEL_59:
        v22 = v13[1];
        *((_BYTE *)v13 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        *v7 = v22;
        if ( v22 )
          *(_QWORD *)(v22 + 16) = v7;
        v13[2] = v7[2];
        v18 = v7;
        *(_QWORD *)(v7[2] + 8LL * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v13;
        v13[1] = v7;
        v7[2] = (__int64)v13;
      }
      else
      {
        v13 = v7;
      }
      v27 = v13[2];
      v28 = *(__int64 **)(v27 + 8);
      *((_BYTE *)v13 + 24) = *(_BYTE *)(v27 + 24);
      v29 = *v28;
      *(_BYTE *)(v27 + 24) = 1;
      *((_BYTE *)v18 + 24) = 1;
      *(_QWORD *)(v27 + 8) = v29;
      if ( v29 )
        *(_QWORD *)(v29 + 16) = v27;
      v28[2] = *(_QWORD *)(v27 + 16);
      *(_QWORD *)(*(_QWORD *)(v27 + 16) + 8LL * (**(_QWORD **)(v27 + 16) != v27)) = v28;
      *v28 = v27;
      *(_QWORD *)(v27 + 16) = v28;
      return result;
    }
LABEL_37:
    v18 = (__int64 *)v7[1];
    if ( v18 && !*((_BYTE *)v18 + 24) )
      goto LABEL_58;
    v19 = (__int64 *)v7[2];
    *((_BYTE *)v7 + 24) = 0;
    if ( v19 == result )
    {
      v19 = result;
LABEL_56:
      *((_BYTE *)v19 + 24) = 1;
      return result;
    }
    if ( !*((_BYTE *)v19 + 24) )
      goto LABEL_56;
LABEL_23:
    v7 = *(__int64 **)(v19[2] + 8LL * (*(_QWORD *)v19[2] == (_QWORD)v19));
  }
  if ( *((_BYTE *)v7 + 24) )
  {
    v14 = (_QWORD *)*v7;
    if ( !*v7 )
      goto LABEL_48;
LABEL_47:
    if ( !*((_BYTE *)v14 + 24) )
      goto LABEL_68;
  }
  else
  {
    v20 = (__int64 *)v7[1];
    *((_BYTE *)v7 + 24) = 1;
    *((_BYTE *)v12 + 24) = 0;
    *v12 = v20;
    if ( v20 )
      v20[2] = (__int64)v12;
    v7[2] = (__int64)v12[2];
    if ( result == (__int64 *)v12 )
      result = v7;
    v12[2][*v12[2] != (_QWORD)v12] = (__int64)v7;
    v7[1] = (__int64)v12;
    v12[2] = v7;
    v7 = *v12;
    v14 = (_QWORD *)**v12;
    if ( v14 )
      goto LABEL_47;
  }
LABEL_48:
  v21 = (__int64 *)v7[1];
  if ( !v21 || *((_BYTE *)v21 + 24) )
  {
    v19 = (__int64 *)v7[2];
    *((_BYTE *)v7 + 24) = 0;
    if ( !*((_BYTE *)v19 + 24) || v19 == result )
      goto LABEL_56;
    goto LABEL_23;
  }
  if ( !v14 )
    goto LABEL_65;
  if ( *((_BYTE *)v14 + 24) )
  {
    v21 = (__int64 *)v7[1];
LABEL_65:
    v23 = *v21;
    *((_BYTE *)v21 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v7[1] = v23;
    if ( v23 )
      *(_QWORD *)(v23 + 16) = v7;
    v21[2] = v7[2];
    v14 = v7;
    *(_QWORD *)(v7[2] + 8LL * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v21;
    *v21 = (__int64)v7;
    v7[2] = (__int64)v21;
  }
  else
  {
LABEL_68:
    v21 = v7;
  }
  v24 = (__int64 *)v21[2];
  v25 = *v24;
  *((_BYTE *)v21 + 24) = *((_BYTE *)v24 + 24);
  v26 = *(_QWORD *)(v25 + 8);
  *((_BYTE *)v24 + 24) = 1;
  *((_BYTE *)v14 + 24) = 1;
  *v24 = v26;
  if ( v26 )
    *(_QWORD *)(v26 + 16) = v24;
  *(_QWORD *)(v25 + 16) = v24[2];
  *(_QWORD *)(v24[2] + 8LL * (*(_QWORD *)v24[2] != (_QWORD)v24)) = v25;
  *(_QWORD *)(v25 + 8) = v24;
  v24[2] = v25;
  return result;
}


================================================================================
Function: sub_256AE00 (0x256AE00)
================================================================================

__int64 __fastcall sub_256AE00(__int64 a1)
{
  unsigned __int64 *v2; // x20
  __int64 result; // x0

  v2 = *(unsigned __int64 **)(a1 + 464);
  if ( !v2 || sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v2 + 1)) )
  {
    if ( (*(_BYTE *)(a1 + 424) & 1) == 0 )
      goto LABEL_5;
    goto LABEL_4;
  }
  (*(void (__fastcall **)(unsigned __int64 *))(*v2 + 16))(v2);
  sub_68488BC(v2);
  if ( (*(_BYTE *)(a1 + 424) & 1) != 0 )
LABEL_4:
    sub_65ECAF4();
LABEL_5:
  if ( (*(_BYTE *)(a1 + 392) & 1) != 0 )
    sub_65ECAF4();
  result = sub_256B1A8(a1);
  if ( (*(_BYTE *)a1 & 1) == 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_256B1A8 (0x256B1A8)
================================================================================

__int64 __fastcall sub_256B1A8(__int64 result)
{
  int v1; // w9
  unsigned int v2; // w8
  unsigned __int8 *v3; // x10
  unsigned __int8 *v4; // t1
  unsigned __int8 *v5; // x20
  unsigned __int8 *v6; // x21
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x10
  int v9; // w8
  unsigned __int64 v10; // x9
  __int64 v11; // x10
  __int16 v12; // [xsp+0h] [xbp-20h]
  char v13; // [xsp+2h] [xbp-1Eh]

  v1 = *(_DWORD *)result;
  if ( (*(_DWORD *)result & 1) != 0 )
    v2 = 8;
  else
    v2 = *(_DWORD *)(result + 16);
  if ( v2 )
  {
    v4 = *(unsigned __int8 **)(result + 8);
    result += 8LL;
    v3 = v4;
    if ( (v1 & 1) != 0 )
      v5 = (unsigned __int8 *)result;
    else
      v5 = v3;
    v6 = &v5[48 * v2];
    HIBYTE(v12) = 95;
    v13 = 0;
    do
    {
      v7 = *v5;
      v8 = *((_QWORD *)v5 + 1);
      v9 = v7 & 1;
      v10 = v7 >> 1;
      if ( !v9 )
        v8 = v10;
      if ( v8 )
      {
        if ( v8 == 1 )
        {
          if ( v9 )
          {
            if ( **((_BYTE **)v5 + 2) == 95 )
            {
LABEL_10:
              result = sub_65ECAF4();
              goto LABEL_11;
            }
          }
          else
          {
            v11 = 0LL;
            while ( v5[v11 + 1] == *((unsigned __int8 *)&v12 + v11 + 1) )
            {
              if ( v10 == ++v11 )
                goto LABEL_11;
            }
          }
        }
        if ( (v5[24] & 1) != 0 )
        {
          result = sub_65ECAF4();
          v9 = *v5 & 1;
        }
      }
      if ( v9 )
        goto LABEL_10;
LABEL_11:
      v5 += 48;
    }
    while ( v5 != v6 );
  }
  return result;
}


================================================================================
Function: sub_256C7D8 (0x256C7D8)
================================================================================

unsigned __int64 __fastcall sub_256C7D8(unsigned __int64 *a1, char *s)
{
  unsigned __int64 result; // x0
  size_t v5; // x20
  void *v6; // x19
  unsigned __int64 v7; // x22
  __int64 v8; // x0

  result = strlen(s);
  if ( result >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v5 = result;
  if ( result >= 0x17 )
  {
    v7 = (result + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = sub_65ECAAC();
    a1[1] = v5;
    a1[2] = v8;
    *a1 = v7 | 1;
    v6 = (void *)v8;
  }
  else
  {
    *(_BYTE *)a1 = 2 * result;
    v6 = (char *)a1 + 1;
    if ( !result )
      goto LABEL_7;
  }
  result = (unsigned __int64)memcpy(v6, s, v5);
LABEL_7:
  *((_BYTE *)v6 + v5) = 0;
  return result;
}


================================================================================
Function: sub_25706F4 (0x25706F4)
================================================================================

_QWORD *sub_25706F4()
{
  return sub_6866980(qword_6C7C4C8);
}


================================================================================
Function: sub_25750D0 (0x25750D0)
================================================================================

__int64 __fastcall sub_25750D0(__int64 result, __int128 *a2, __int128 *a3)
{
  __int64 v3; // x8
  unsigned __int64 *v4; // x22
  __int128 *v6; // x21
  _QWORD *v7; // x19
  unsigned __int64 v8; // x24
  unsigned __int64 *v9; // x23
  char v10; // t1
  __int64 v11; // x8
  __int128 *v12; // x23
  unsigned __int64 v13; // x26
  __int128 *v14; // x25
  unsigned __int64 *v15; // x21
  unsigned __int64 *v16; // x20
  char v17; // t1
  unsigned __int64 v18; // x8
  __int64 v19; // x10
  unsigned __int64 v20; // x8
  __int64 v21; // x23

  v3 = *(_QWORD *)(result + 16);
  v4 = *(unsigned __int64 **)result;
  v6 = a2;
  v7 = (_QWORD *)result;
  v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)a3 - (char *)a2) >> 3);
  if ( v8 > 0xAAAAAAAAAAAAAAABLL * ((v3 - *(_QWORD *)result) >> 3) )
  {
    if ( v4 )
    {
      if ( *(unsigned __int64 **)(result + 8) != v4 )
      {
        v9 = *(unsigned __int64 **)(result + 8);
        do
        {
          v10 = *((_BYTE *)v9 - 24);
          v9 -= 3;
          if ( (v10 & 1) != 0 )
            sub_65ECAF4();
        }
        while ( v9 != v4 );
      }
      v7[1] = v4;
      sub_65ECAF4();
      v3 = 0LL;
      *v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }
    if ( v8 > 0xAAAAAAAAAAAAAAALL )
      goto LABEL_34;
    v18 = 0xAAAAAAAAAAAAAAABLL * (v3 >> 3);
    v19 = 2 * v18;
    if ( 2 * v18 < v8 )
      v19 = v8;
    v20 = v18 >= 0x555555555555555LL ? 0xAAAAAAAAAAAAAAALL : v19;
    if ( v20 > 0xAAAAAAAAAAAAAAALL )
LABEL_34:
      sub_684DBEC();
    v21 = 24 * v20;
    result = sub_65ECAAC();
    v4 = (unsigned __int64 *)result;
    *v7 = result;
    v7[1] = result;
    for ( v7[2] = result + v21; v6 != a3; v4 += 3 )
    {
      result = (__int64)sub_68497A0(v4, v6);
      v6 = (__int128 *)((char *)v6 + 24);
    }
LABEL_32:
    v7[1] = v4;
    return result;
  }
  v11 = *(_QWORD *)(result + 8) - (_QWORD)v4;
  v12 = (__int128 *)((char *)a2 + v11);
  v13 = 0xAAAAAAAAAAAAAAABLL * (v11 >> 3);
  if ( v8 <= v13 )
    v14 = a3;
  else
    v14 = (__int128 *)((char *)a2 + v11);
  if ( v14 != a2 )
  {
    do
    {
      result = (__int64)sub_684A438((unsigned __int8 *)v4, (unsigned __int8 *)v6);
      v6 = (__int128 *)((char *)v6 + 24);
      v4 += 3;
    }
    while ( v6 != v14 );
  }
  v15 = (unsigned __int64 *)v7[1];
  if ( v8 <= v13 )
  {
    if ( v15 != v4 )
    {
      v16 = (unsigned __int64 *)v7[1];
      do
      {
        v17 = *((_BYTE *)v16 - 24);
        v16 -= 3;
        if ( (v17 & 1) != 0 )
          result = sub_65ECAF4();
      }
      while ( v16 != v4 );
    }
    goto LABEL_32;
  }
  if ( v14 != a3 )
  {
    do
    {
      result = (__int64)sub_68497A0(v15, v12);
      v12 = (__int128 *)((char *)v12 + 24);
      v15 += 3;
    }
    while ( v12 != a3 );
  }
  v7[1] = v15;
  return result;
}


================================================================================
Function: sub_257C30C (0x257C30C)
================================================================================

__int64 __fastcall sub_257C30C(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v6; // x10
  __int64 result; // x0
  __int64 v8; // x10

  v2 = a1 + 8;
  *(_QWORD *)a1 = off_6871690;
  *(_QWORD *)(a1 + 72) = off_68716E8;
  sub_6247F88(a1 + 8);
  v6 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)a1 = off_6C19748;
  *(_DWORD *)(a1 + 12) = 33;
  *(_QWORD *)(a1 + 16) = v6;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)((char *)&dword_0 + a1) = off_6C19748;
  sub_68497A0(a1 + 32, a2);
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 60) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 68) = 0;
  sub_6247FBC(v2);
  sub_6247F88(a1 + 80);
  *(_QWORD *)(a1 + 72) = off_6C198E8;
  *(_BYTE *)(a1 + 408) = 0;
  *(_BYTE *)(a1 + 432) = 0;
  *(_QWORD *)((char *)&dword_0 + a1 + 72) = off_6C198E8;
  *(_QWORD *)(a1 + 232) = 0LL;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 240) = 1065353216;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 280) = 1065353216;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_DWORD *)(a1 + 320) = 1065353216;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_DWORD *)(a1 + 360) = 1065353216;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_DWORD *)(a1 + 400) = 1065353216;
  *(_BYTE *)(a1 + 440) = 0;
  *(_BYTE *)(a1 + 464) = 0;
  *(_BYTE *)(a1 + 472) = 0;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_DWORD *)(a1 + 512) = 1065353216;
  *(_DWORD *)(a1 + 520) = 0;
  result = sub_6247FBC(a1 + 80);
  v8 = a1 + 528;
  *(_QWORD *)(a1 + 528) = &unk_6C19A90;
  *(_QWORD *)(v8 + unk_6C19A40) = off_6C19B20;
  *(_QWORD *)(v8 + *(_QWORD *)(*(_QWORD *)(a1 + 528) - 88LL)) = off_6C19CA8;
  *(_QWORD *)a1 = off_6C192F8;
  *(_QWORD *)(a1 + 72) = off_6C194A8;
  *(_QWORD *)(a1 + 528) = &unk_6C19650;
  *(_QWORD *)(a1 + 536) = 0x3FF0000000000000LL;
  return result;
}


================================================================================
Function: sub_25884CC (0x25884CC)
================================================================================

__int64 __fastcall sub_25884CC(unsigned __int64 *a1, __int128 *a2)
{
  unsigned __int64 v3; // x21
  unsigned __int64 v4; // x10
  unsigned __int64 v6; // x22
  __int64 result; // x0
  __int128 v8; // q0
  __int64 v9; // x9
  __int128 v10; // q1
  unsigned __int64 v11; // x10
  __int64 v12; // x12
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x11
  unsigned __int64 v15; // x20
  unsigned __int64 v16; // x9
  __int128 v17; // q0
  __int64 v18; // x12
  __int128 v19; // q0
  bool v20; // zf
  unsigned __int64 v21; // x20
  unsigned __int64 v22; // x21
  unsigned __int64 v23; // x19

  v3 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(a1[1] - *a1) >> 4);
  v4 = v3 + 1;
  if ( v3 + 1 > 0x555555555555555LL )
    sub_684DBEC();
  if ( 0x5555555555555556LL * ((__int64)(a1[2] - *a1) >> 4) >= v4 )
    v4 = 0x5555555555555556LL * ((__int64)(a1[2] - *a1) >> 4);
  if ( 0xAAAAAAAAAAAAAAABLL * ((__int64)(a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL )
    v6 = 0x555555555555555LL;
  else
    v6 = v4;
  if ( v6 )
  {
    if ( v6 > 0x555555555555555LL )
      sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    result = sub_65ECAAC();
  }
  else
  {
    result = 0LL;
  }
  v8 = *a2;
  *(_QWORD *)a2 = 0LL;
  *((_QWORD *)a2 + 1) = 0LL;
  v9 = *((_QWORD *)a2 + 2);
  v10 = *(__int128 *)((char *)a2 + 24);
  *((_QWORD *)a2 + 2) = 0LL;
  *((_QWORD *)a2 + 3) = 0LL;
  v11 = result + 48 * v3;
  v12 = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 4) = 0LL;
  *((_QWORD *)a2 + 5) = 0LL;
  v13 = result + 48 * v6;
  v15 = *a1;
  v14 = a1[1];
  *(_QWORD *)(v11 + 16) = v9;
  v16 = v11 + 48;
  *(_OWORD *)v11 = v8;
  *(_QWORD *)(v11 + 40) = v12;
  *(_OWORD *)(v11 + 24) = v10;
  if ( v14 == v15 )
  {
    *a1 = v11;
    a1[1] = v16;
    a1[2] = v13;
    if ( v15 )
      return sub_65ECAF4();
  }
  else
  {
    do
    {
      v17 = *(_OWORD *)(v14 - 48);
      *(_QWORD *)(v11 - 32) = *(_QWORD *)(v14 - 32);
      *(_OWORD *)(v11 - 48) = v17;
      v18 = *(_QWORD *)(v14 - 8);
      *(_QWORD *)(v14 - 40) = 0LL;
      *(_QWORD *)(v14 - 32) = 0LL;
      v19 = *(_OWORD *)(v14 - 24);
      *(_QWORD *)(v14 - 48) = 0LL;
      *(_QWORD *)(v11 - 8) = v18;
      *(_OWORD *)(v11 - 24) = v19;
      v11 -= 48LL;
      *(_QWORD *)(v14 - 16) = 0LL;
      *(_QWORD *)(v14 - 8) = 0LL;
      v20 = v14 - 48 == v15;
      *(_QWORD *)(v14 - 24) = 0LL;
      v14 -= 48LL;
    }
    while ( !v20 );
    v21 = *a1;
    v22 = a1[1];
    *a1 = v11;
    a1[1] = v16;
    a1[2] = v13;
    if ( v22 != v21 )
    {
      do
      {
        if ( (*(_BYTE *)(v22 - 24) & 1) != 0 )
          result = sub_65ECAF4();
        v23 = v22 - 48;
        if ( (*(_BYTE *)(v22 - 48) & 1) != 0 )
          result = sub_65ECAF4();
        v22 -= 48LL;
      }
      while ( v23 != v21 );
    }
    if ( v21 )
      return sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_25A0260 (0x25A0260)
================================================================================

size_t *__fastcall sub_25A0260(size_t *result, void *src, size_t n, size_t a4, void *a5, size_t a6)
{
  size_t *v9; // x19
  void *v12; // x25
  _QWORD *v13; // x23
  size_t v14; // x26
  void *v15; // x23

  v9 = result;
  if ( !src )
  {
    *result = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
    v13 = result + 3;
    if ( a5 )
      goto LABEL_11;
    goto LABEL_7;
  }
  if ( n >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( n >= 0x17 )
  {
    v14 = (n + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (void *)sub_65ECAAC();
    v9[1] = n;
    v9[2] = (size_t)v12;
    *v9 = v14 | 1;
    goto LABEL_9;
  }
  *(_BYTE *)result = 2 * n;
  v12 = (char *)result + 1;
  if ( n )
LABEL_9:
    result = (size_t *)memcpy(v12, src, n);
  *((_BYTE *)v12 + n) = 0;
  v13 = v9 + 3;
  if ( a5 )
  {
LABEL_11:
    if ( a6 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_6849630();
    if ( a6 >= 0x17 )
    {
      v15 = (void *)sub_65ECAAC();
      v9[4] = a6;
      v9[5] = (size_t)v15;
      v9[3] = (a6 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      *(_BYTE *)v13 = 2 * a6;
      v15 = (char *)v13 + 1;
      if ( !a6 )
        goto LABEL_17;
    }
    result = (size_t *)memcpy(v15, a5, a6);
LABEL_17:
    *((_BYTE *)v15 + a6) = 0;
    goto LABEL_18;
  }
LABEL_7:
  *v13 = 0LL;
  v13[1] = 0LL;
  v13[2] = 0LL;
LABEL_18:
  v9[6] = a4;
  return result;
}


================================================================================
Function: sub_25B06C8 (0x25B06C8)
================================================================================

__int64 **__fastcall sub_25B06C8(unsigned __int64 a1, unsigned __int8 *a2, __int128 *a3)
{
  unsigned __int64 v3; // x27
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  __int64 *v11; // x1
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x26
  uint8x8_t v16; // d0
  unsigned __int64 v17; // x28
  __int64 ***v18; // x8
  unsigned __int64 v19; // x10
  unsigned __int8 *v20; // x11
  unsigned __int8 *v21; // x12
  unsigned __int64 v22; // x9
  __int64 **v23; // x22
  size_t v24; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  __int64 *v29; // x0
  __int64 v30; // x9
  __int64 *v31; // x24
  _QWORD *v32; // x22
  __int64 v33; // x8
  float v34; // s1
  float v35; // s0
  _BOOL8 v36; // x9
  unsigned __int64 v37; // x10
  unsigned __int64 v38; // x1
  __int64 v39; // x8
  _QWORD *v40; // x9
  __int64 v41; // x9
  unsigned __int64 v42; // x9
  _QWORD v44[2]; // [xsp+0h] [xbp-20h] BYREF
  char v45; // [xsp+10h] [xbp-10h]

  v7 = *((_QWORD *)a2 + 1);
  v8 = *a2;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v11 = (__int64 *)(a2 + 1);
  else
    v11 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v9 )
    v12 = v10;
  else
    v12 = v7;
  v13 = sub_24FE128((__int64)v44, v11, v12);
  v14 = v13;
  v15 = *(_QWORD *)(a1 + 8);
  if ( v15 )
  {
    v16.n64_u64[0] = vcnt_s8((int8x8_t)v15).n64_u64[0];
    v16.n64_u16[0] = vaddlv_u8(v16);
    v17 = v16.n64_u32[0];
    if ( v16.n64_u32[0] > 1uLL )
    {
      v3 = v13;
      if ( v13 >= v15 )
        v3 = v13 % v15;
    }
    else
    {
      v3 = (v15 - 1) & v13;
    }
    v18 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v3);
    if ( v18 )
    {
      v19 = *((_QWORD *)a2 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v21 = a2 + 1;
      v22 = *a2;
      v23 = *v18;
      v24 = (v22 & 1) != 0 ? v19 : v22 >> 1;
      for ( i = (v22 & 1) != 0 ? v20 : v21; v23; v23 = (__int64 **)*v23 )
      {
        v26 = (unsigned __int64)v23[1];
        if ( v26 != v14 )
        {
          if ( v17 > 1 )
          {
            if ( v26 >= v15 )
              v26 %= v15;
          }
          else
          {
            v26 &= v15 - 1;
          }
          if ( v26 != v3 )
            break;
        }
        v27 = *((unsigned __int8 *)v23 + 16);
        v28 = (unsigned __int64)v23[3];
        if ( (v27 & 1) == 0 )
          v28 = v27 >> 1;
        if ( v28 == v24 )
        {
          if ( (v27 & 1) != 0 )
            v29 = v23[4];
          else
            v29 = (__int64 *)((char *)v23 + 17);
          if ( (v27 & 1) != 0 )
          {
            if ( !v24 || !memcmp(v29, i, v24) )
              return v23;
          }
          else
          {
            if ( !v24 )
              return v23;
            v30 = 0LL;
            while ( *((unsigned __int8 *)v23 + v30 + 17) == i[v30] )
            {
              if ( v27 >> 1 == ++v30 )
                return v23;
            }
          }
        }
      }
    }
  }
  v31 = (__int64 *)(a1 + 16);
  v32 = (_QWORD *)sub_65ECAAC();
  v44[0] = v32;
  v44[1] = a1 + 16;
  v45 = 0;
  sub_68497A0(v32 + 2, a3);
  sub_68497A0(v32 + 5, (__int128 *)((char *)a3 + 24));
  v33 = *(_QWORD *)(a1 + 24);
  v34 = *(float *)(a1 + 32);
  *v32 = 0LL;
  v32[1] = v14;
  v45 = 1;
  v35 = (float)(unsigned __int64)(v33 + 1);
  if ( !v15 || (float)(v34 * (float)v15) < v35 )
  {
    v36 = v15 < 3 || (v15 & (v15 - 1)) != 0;
    v37 = vcvtps_u32_f32(v35 / v34);
    if ( (v36 | (2 * v15)) >= v37 )
      v38 = v36 | (2 * v15);
    else
      v38 = v37;
    sub_252DEFC(a1, v38);
    v15 = *(_QWORD *)(a1 + 8);
    if ( (v15 & (v15 - 1)) != 0 )
    {
      if ( v14 >= v15 )
        v3 = v14 % v15;
      else
        v3 = v14;
    }
    else
    {
      v3 = (v15 - 1) & v14;
    }
  }
  v39 = *(_QWORD *)a1;
  v40 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if ( v40 )
  {
    *v32 = *v40;
    *v40 = v32;
  }
  else
  {
    v41 = *v31;
    *v31 = (__int64)v32;
    *v32 = v41;
    *(_QWORD *)(v39 + 8 * v3) = v31;
    if ( *(_QWORD *)v44[0] )
    {
      v42 = *(_QWORD *)(*(_QWORD *)v44[0] + 8LL);
      if ( (v15 & (v15 - 1)) != 0 )
      {
        if ( v42 >= v15 )
          v42 %= v15;
      }
      else
      {
        v42 &= v15 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v42) = v44[0];
    }
  }
  v23 = (__int64 **)v44[0];
  ++*(_QWORD *)(a1 + 24);
  return v23;
}


================================================================================
Function: sub_25B1368 (0x25B1368)
================================================================================

__int64 **__fastcall sub_25B1368(__int64 *a1, unsigned __int8 *a2, __int64 a3, __int128 **a4)
{
  unsigned __int64 v4; // x27
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  bool v10; // zf
  unsigned __int64 v11; // x8
  __int64 *v12; // x1
  unsigned __int64 v13; // x2
  unsigned __int64 v14; // x0
  unsigned __int64 v15; // x20
  unsigned __int64 v16; // x26
  uint8x8_t v17; // d0
  unsigned __int64 v18; // x28
  __int64 ***v19; // x8
  unsigned __int64 v20; // x10
  unsigned __int8 *v21; // x11
  unsigned __int8 *v22; // x12
  unsigned __int64 v23; // x9
  __int64 **v24; // x22
  size_t v25; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x11
  __int64 *v30; // x0
  __int64 v31; // x9
  __int64 *v32; // x23
  _QWORD *v33; // x22
  __int128 *v34; // x1
  __int64 v35; // x8
  float v36; // s1
  float v37; // s0
  _BOOL8 v38; // x9
  unsigned __int64 v39; // x10
  __int64 v40; // x1
  __int64 v41; // x8
  _QWORD *v42; // x9
  __int64 v43; // x9
  unsigned __int64 v44; // x9
  _QWORD v46[2]; // [xsp+0h] [xbp-20h] BYREF
  char v47; // [xsp+10h] [xbp-10h]

  v8 = *((_QWORD *)a2 + 1);
  v9 = *a2;
  v10 = (v9 & 1) == 0;
  v11 = v9 >> 1;
  if ( v10 )
    v12 = (__int64 *)(a2 + 1);
  else
    v12 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v10 )
    v13 = v11;
  else
    v13 = v8;
  v14 = sub_24FE128((__int64)v46, v12, v13);
  v15 = v14;
  v16 = a1[1];
  if ( v16 )
  {
    v17.n64_u64[0] = vcnt_s8((int8x8_t)v16).n64_u64[0];
    v17.n64_u16[0] = vaddlv_u8(v17);
    v18 = v17.n64_u32[0];
    if ( v17.n64_u32[0] > 1uLL )
    {
      v4 = v14;
      if ( v14 >= v16 )
        v4 = v14 % v16;
    }
    else
    {
      v4 = (v16 - 1) & v14;
    }
    v19 = *(__int64 ****)(*a1 + 8 * v4);
    if ( v19 )
    {
      v20 = *((_QWORD *)a2 + 1);
      v21 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v22 = a2 + 1;
      v23 = *a2;
      v24 = *v19;
      v25 = (v23 & 1) != 0 ? v20 : v23 >> 1;
      for ( i = (v23 & 1) != 0 ? v21 : v22; v24; v24 = (__int64 **)*v24 )
      {
        v27 = (unsigned __int64)v24[1];
        if ( v27 != v15 )
        {
          if ( v18 > 1 )
          {
            if ( v27 >= v16 )
              v27 %= v16;
          }
          else
          {
            v27 &= v16 - 1;
          }
          if ( v27 != v4 )
            break;
        }
        v28 = *((unsigned __int8 *)v24 + 16);
        v29 = (unsigned __int64)v24[3];
        if ( (v28 & 1) == 0 )
          v29 = v28 >> 1;
        if ( v29 == v25 )
        {
          if ( (v28 & 1) != 0 )
            v30 = v24[4];
          else
            v30 = (__int64 *)((char *)v24 + 17);
          if ( (v28 & 1) != 0 )
          {
            if ( !v25 || !memcmp(v30, i, v25) )
              return v24;
          }
          else
          {
            if ( !v25 )
              return v24;
            v31 = 0LL;
            while ( *((unsigned __int8 *)v24 + v31 + 17) == i[v31] )
            {
              if ( v28 >> 1 == ++v31 )
                return v24;
            }
          }
        }
      }
    }
  }
  v32 = a1 + 2;
  v33 = (_QWORD *)sub_65ECAAC();
  v34 = *a4;
  v47 = 0;
  v46[0] = v33;
  v46[1] = a1 + 2;
  sub_68497A0(v33 + 2, v34);
  v35 = a1[3];
  v36 = *((float *)a1 + 8);
  v33[5] = 0LL;
  v33[6] = 0LL;
  v33[7] = 0LL;
  v47 = 1;
  *v33 = 0LL;
  v33[1] = v15;
  v37 = (float)(unsigned __int64)(v35 + 1);
  if ( !v16 || (float)(v36 * (float)v16) < v37 )
  {
    v38 = v16 < 3 || (v16 & (v16 - 1)) != 0;
    v39 = vcvtps_u32_f32(v37 / v36);
    if ( (v38 | (2 * v16)) >= v39 )
      v40 = v38 | (2 * v16);
    else
      v40 = v39;
    sub_252DEFC(a1, v40);
    v16 = a1[1];
    if ( (v16 & (v16 - 1)) != 0 )
    {
      if ( v15 >= v16 )
        v4 = v15 % v16;
      else
        v4 = v15;
    }
    else
    {
      v4 = (v16 - 1) & v15;
    }
  }
  v41 = *a1;
  v42 = *(_QWORD **)(*a1 + 8 * v4);
  if ( v42 )
  {
    *v33 = *v42;
    *v42 = v33;
  }
  else
  {
    v43 = *v32;
    *v32 = (__int64)v33;
    *v33 = v43;
    *(_QWORD *)(v41 + 8 * v4) = v32;
    if ( *(_QWORD *)v46[0] )
    {
      v44 = *(_QWORD *)(*(_QWORD *)v46[0] + 8LL);
      if ( (v16 & (v16 - 1)) != 0 )
      {
        if ( v44 >= v16 )
          v44 %= v16;
      }
      else
      {
        v44 &= v16 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v44) = v46[0];
    }
  }
  v24 = (__int64 **)v46[0];
  ++a1[3];
  return v24;
}


================================================================================
Function: sub_25BABCC (0x25BABCC)
================================================================================

__int64 __fastcall sub_25BABCC(__int64 a1)
{
  unsigned int v2; // w0
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  *(_DWORD *)(a1 + 3) = 0;
  *(_DWORD *)a1 = 0;
  v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 8), 0LL);
  if ( v2 )
  {
    sub_25C1BEC(v4, v2, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25C1ABC((__int64)v4);
  }
  sub_25C1984(a1 + 48);
  sub_25C1984(a1 + 136);
  return sub_25C1984(a1 + 224);
}


================================================================================
Function: sub_25BD18C (0x25BD18C)
================================================================================

__int64 __usercall sub_25BD18C@<X0>(_QWORD *a1@<X0>, __int64 a2@<X1>, _QWORD *a3@<X8>)
{
  int v6; // w19
  _QWORD *v7; // x0
  _QWORD *v8; // x22
  __int64 v9; // x8
  __int64 v10; // x8
  __int64 v11; // x0

  v6 = sub_65EBFB8(dword_72FB548);
  sub_65F5C18(a1);
  v7 = (_QWORD *)sub_65F54E8(96LL);
  v7[2] = 0LL;
  v7[3] = 0LL;
  v8 = v7;
  v9 = *a1;
  v7[1] = sub_25D0034;
  *v7 = 0x100000000LL;
  v7[4] = v9;
  if ( v9 )
  {
    sub_68673F0(1u, (atomic_uint *)(v9 + 4));
    v10 = v8[3] | 4LL;
  }
  else
  {
    v10 = 4LL;
  }
  v8[3] = v10;
  v11 = *(_QWORD *)(a2 + 32);
  v8[5] = sub_25D0058;
  if ( v11 )
  {
    if ( a2 == v11 )
    {
      v8[10] = v8 + 6;
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 32) + 24LL))(*(_QWORD *)(a2 + 32));
      goto LABEL_9;
    }
    v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
  }
  v8[10] = v11;
LABEL_9:
  sub_65F4B5C(*a1, v8);
  *a3 = v8;
  sub_68673F0(1u, (atomic_uint *)((char *)v8 + 4));
  return sub_65EBFB8(v6);
}


================================================================================
Function: sub_25C1984 (0x25C1984)
================================================================================

__int64 __fastcall sub_25C1984(__int64 a1)
{
  __int64 result; // x0
  _BYTE v3[56]; // [xsp+0h] [xbp-40h] BYREF

  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0LL) )
  {
    sub_25C1BEC(v3);
    sub_25C1ABC((__int64)v3);
  }
  result = pthread_cond_init((pthread_cond_t *)(a1 + 40), 0LL);
  if ( (_DWORD)result )
  {
    pthread_mutex_destroy((pthread_mutex_t *)a1);
    sub_25C1BEC(v3);
    sub_25C1ABC((__int64)v3);
  }
  return result;
}


================================================================================
Function: sub_25C1ABC (0x25C1ABC)
================================================================================

void __fastcall __noreturn sub_25C1ABC(__int64 a1)
{
  __int64 v2; // x19
  _QWORD v3[2]; // [xsp+0h] [xbp-60h] BYREF
  __int128 v4; // [xsp+10h] [xbp-50h]
  unsigned __int64 v5[7]; // [xsp+20h] [xbp-40h] BYREF
  int v6; // [xsp+58h] [xbp-8h]

  v2 = sub_6861FD0(104LL);
  sub_68495F8(v3, a1);
  v4 = *(_OWORD *)(a1 + 16);
  v3[0] = off_6877DD8;
  sub_68497A0(v5, (__int128 *)(a1 + 32));
  memset(&v5[4], 0, 24);
  v6 = -1;
  v3[0] = off_6877F60;
  v5[3] = (unsigned __int64)off_6877F88;
  sub_25C1D2C(v2, v3);
  sub_6862048(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error>>,
    (__int64)sub_25C1C4C);
}


================================================================================
Function: sub_25C1BEC (0x25C1BEC)
================================================================================

__int64 __fastcall sub_25C1BEC(_QWORD *a1, unsigned int a2, char *a3)
{
  __int64 v6; // x22
  __int64 result; // x0

  v6 = sub_67DDA30();
  result = sub_684956C((int)a1, a3);
  a1[2] = a2;
  a1[3] = v6;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[4] = 0LL;
  *a1 = off_6877FA8;
  return result;
}


================================================================================
Function: sub_25C1D2C (0x25C1D2C)
================================================================================

__int64 __fastcall sub_25C1D2C(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int128 v5; // q0

  *(_QWORD *)(a1 + 96) = off_686EC48;
  sub_68495F8(a1, a2);
  *(_QWORD *)a1 = off_6877DD8;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_68497A0((unsigned __int64 *)(a1 + 32), (__int128 *)(a2 + 32));
  v4 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)a1 = off_6877FA8;
  *(_QWORD *)(a1 + 56) = off_686EB38;
  *(_QWORD *)(a1 + 64) = v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(_QWORD *)a1 = off_6877EC0;
  *(_QWORD *)(a1 + 56) = off_6877EF8;
  *(_QWORD *)(a1 + 96) = &off_6877F30;
  return sub_24FA560(a1 + 56, a2 + 56);
}


================================================================================
Function: sub_25C5D24 (0x25C5D24)
================================================================================

void __fastcall __noreturn sub_25C5D24(__int64 a1)
{
  __int64 v2; // x19
  _QWORD v3[2]; // [xsp+0h] [xbp-60h] BYREF
  __int128 v4; // [xsp+10h] [xbp-50h]
  unsigned __int64 v5[7]; // [xsp+20h] [xbp-40h] BYREF
  int v6; // [xsp+58h] [xbp-8h]

  v2 = sub_6861FD0(104LL);
  sub_68495F8(v3, a1);
  v4 = *(_OWORD *)(a1 + 16);
  v3[0] = off_6877DD8;
  sub_68497A0(v5, (__int128 *)(a1 + 32));
  memset(&v5[4], 0, 24);
  v6 = -1;
  v3[0] = off_68784F0;
  v5[3] = (unsigned __int64)off_6878518;
  sub_25C60F4(v2, v3);
  sub_6862048(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error>>,
    (__int64)sub_25C6014);
}


================================================================================
Function: sub_25C5E54 (0x25C5E54)
================================================================================

__int64 __fastcall sub_25C5E54(_QWORD *a1, unsigned int a2, char *a3)
{
  __int64 v6; // x22
  __int64 result; // x0

  v6 = sub_67DDA30();
  result = sub_684956C((int)a1, a3);
  a1[2] = a2;
  a1[3] = v6;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[4] = 0LL;
  *a1 = off_6878538;
  return result;
}


================================================================================
Function: sub_25C5EF4 (0x25C5EF4)
================================================================================

__int64 __fastcall sub_25C5EF4(__int64 a1)
{
  int v2; // w9
  pthread_mutex_t *v3; // x19
  unsigned int v4; // w1
  _BYTE v6[8]; // [xsp+8h] [xbp-58h] BYREF
  _QWORD v7[7]; // [xsp+10h] [xbp-50h] BYREF
  pthread_mutex_t *v8; // [xsp+48h] [xbp-18h] BYREF
  unsigned __int8 v9; // [xsp+50h] [xbp-10h]

  sub_67DFD68(v6);
  v9 = 0;
  v8 = (pthread_mutex_t *)(a1 + 8);
  sub_25C6ADC((__int64)&v8);
  while ( *(unsigned __int8 *)(a1 + 4) | *(unsigned __int8 *)(a1 + 6) )
    sub_25C6934((pthread_mutex_t *)(a1 + 48), (__int64)&v8);
  v2 = v9;
  ++*(_DWORD *)a1;
  if ( v2 )
  {
    v3 = v8;
    do
      v4 = pthread_mutex_unlock(v3);
    while ( v4 == 4 );
    if ( v4 )
    {
      sub_25C5E54(v7, v4, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24((__int64)v7);
    }
  }
  return sub_67DFE60(v6);
}


================================================================================
Function: sub_25C60F4 (0x25C60F4)
================================================================================

__int64 __fastcall sub_25C60F4(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int128 v5; // q0

  *(_QWORD *)(a1 + 96) = off_686EC48;
  sub_68495F8((_QWORD *)a1, a2);
  *(_QWORD *)a1 = off_6877DD8;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_68497A0((unsigned __int64 *)(a1 + 32), (__int128 *)(a2 + 32));
  v4 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)a1 = off_6878538;
  *(_QWORD *)(a1 + 56) = off_686EB38;
  *(_QWORD *)(a1 + 64) = v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(_QWORD *)a1 = off_6878450;
  *(_QWORD *)(a1 + 56) = off_6878488;
  *(_QWORD *)(a1 + 96) = &off_68784C0;
  return sub_24FA560(a1 + 56, a2 + 56);
}


================================================================================
Function: sub_25C6934 (0x25C6934)
================================================================================

__int64 __fastcall sub_25C6934(pthread_mutex_t *a1, __int64 a2)
{
  pthread_cond_t *v4; // x21
  unsigned int v5; // w22
  __int64 v6; // x0
  __int64 result; // x0
  _BYTE v8[56]; // [xsp+10h] [xbp-40h] BYREF

  v4 = (pthread_cond_t *)&a1[1];
  sub_25C6BC8(v8, a1, &a1[1]);
  sub_25C70F0(a2);
  do
    v5 = pthread_cond_wait(v4, a1);
  while ( v5 == 4 );
  sub_25C6D08(v8);
  v6 = sub_25C6ADC(a2);
  result = sub_67DFB28(v6);
  if ( v5 )
  {
    sub_25C6F24(v8, v5, "boost::condition_variable::wait failed in pthread_cond_wait");
    sub_25C6DF4(v8);
  }
  return result;
}


================================================================================
Function: sub_25C6ADC (0x25C6ADC)
================================================================================

__int64 __fastcall sub_25C6ADC(__int64 a1)
{
  pthread_mutex_t *v1; // x20
  __int64 result; // x0
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  v1 = *(pthread_mutex_t **)a1;
  if ( !*(_QWORD *)a1 )
  {
    sub_25C5E54(v4, 1u, "boost unique_lock has no mutex");
    sub_25C5D24((__int64)v4);
  }
  if ( *(_BYTE *)(a1 + 8) )
  {
    sub_25C5E54(v4, 0x23u, "boost unique_lock owns already the mutex");
    sub_25C5D24((__int64)v4);
  }
  do
    result = pthread_mutex_lock(v1);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    sub_25C5E54(v4, result, "boost: mutex lock failed in pthread_mutex_lock");
    sub_25C5D24((__int64)v4);
  }
  *(_BYTE *)(a1 + 8) = 1;
  return result;
}


================================================================================
Function: sub_25C6BC8 (0x25C6BC8)
================================================================================

__int64 __fastcall sub_25C6BC8(__int64 *a1, pthread_mutex_t *a2, __int64 a3)
{
  __int64 v6; // x0
  int v7; // w8
  __int64 v8; // x8
  pthread_mutex_t *v9; // x19
  __int64 result; // x0
  __int64 v11; // x0
  pthread_mutex_t *mutex; // [xsp+8h] [xbp-48h] BYREF
  _QWORD v13[7]; // [xsp+10h] [xbp-40h] BYREF

  v6 = sub_67DE7A8();
  *a1 = v6;
  a1[1] = (__int64)a2;
  if ( !v6 )
  {
    *((_BYTE *)a1 + 16) = 0;
    return pthread_mutex_lock(a2);
  }
  v7 = *(unsigned __int8 *)(v6 + 408);
  *((_BYTE *)a1 + 16) = v7;
  if ( !v7 )
    return pthread_mutex_lock(a2);
  sub_25C6F84(&mutex, (pthread_mutex_t *)(v6 + 48));
  v8 = *a1;
  if ( *(_BYTE *)(*a1 + 409) )
  {
    *(_BYTE *)(v8 + 409) = 0;
    v11 = sub_6861FD0(1LL);
    sub_6862048(v11, (__int64)&`typeinfo for'boost::thread_interrupted, 0LL);
  }
  *(_QWORD *)(v8 + 344) = a2;
  *(_QWORD *)(v8 + 352) = a3;
  pthread_mutex_lock((pthread_mutex_t *)a1[1]);
  v9 = mutex;
  do
    result = pthread_mutex_unlock(v9);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    sub_25C5E54(v13, result, "boost: mutex unlock failed in pthread_mutex_unlock");
    sub_25C5D24((__int64)v13);
  }
  return result;
}


================================================================================
Function: sub_25C6D08 (0x25C6D08)
================================================================================

__int64 __fastcall sub_25C6D08(__int64 *a1)
{
  int v2; // w8
  pthread_mutex_t *v3; // x0
  __int64 v4; // x8
  pthread_mutex_t *v5; // x19
  __int64 result; // x0
  pthread_mutex_t *mutex; // [xsp+8h] [xbp-48h] BYREF
  _QWORD v8[7]; // [xsp+10h] [xbp-40h] BYREF

  v2 = *((unsigned __int8 *)a1 + 16);
  v3 = (pthread_mutex_t *)a1[1];
  if ( !v2 )
    return pthread_mutex_unlock(v3);
  pthread_mutex_unlock(v3);
  sub_25C6F84(&mutex, (pthread_mutex_t *)(*a1 + 48));
  v4 = *a1;
  v5 = mutex;
  *(_QWORD *)(v4 + 344) = 0LL;
  *(_QWORD *)(v4 + 352) = 0LL;
  do
    result = pthread_mutex_unlock(v5);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    sub_25C5E54(v8, result, "boost: mutex unlock failed in pthread_mutex_unlock");
    sub_25C5D24((__int64)v8);
  }
  return result;
}


================================================================================
Function: sub_25C6DF4 (0x25C6DF4)
================================================================================

void __fastcall __noreturn sub_25C6DF4(__int64 a1)
{
  __int64 v2; // x19
  _QWORD v3[2]; // [xsp+0h] [xbp-60h] BYREF
  __int128 v4; // [xsp+10h] [xbp-50h]
  unsigned __int64 v5[7]; // [xsp+20h] [xbp-40h] BYREF
  int v6; // [xsp+58h] [xbp-8h]

  v2 = sub_6861FD0(104LL);
  sub_68495F8(v3, a1);
  v4 = *(_OWORD *)(a1 + 16);
  v3[0] = off_6877DD8;
  sub_68497A0(v5, (__int128 *)(a1 + 32));
  memset(&v5[4], 0, 24);
  v6 = -1;
  v3[0] = off_68786A0;
  v5[3] = (unsigned __int64)off_68786C8;
  sub_25C72B8(v2, v3);
  sub_6862048(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::condition_error>>,
    (__int64)sub_25C71D8);
}


================================================================================
Function: sub_25C6F24 (0x25C6F24)
================================================================================

void *__fastcall sub_25C6F24(_QWORD *a1, unsigned int a2, char *a3)
{
  __int64 *v6; // x22
  void *result; // x0

  v6 = sub_67DDA30();
  result = sub_684956C(a1, a3);
  a1[2] = a2;
  a1[3] = v6;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[4] = 0LL;
  *a1 = off_68786E8;
  return result;
}


================================================================================
Function: sub_25C6F84 (0x25C6F84)
================================================================================

__int64 __fastcall sub_25C6F84(_QWORD *a1, pthread_mutex_t *mutex)
{
  __int64 result; // x0
  unsigned int v4; // w20
  __int64 v5; // x19
  _QWORD v6[7]; // [xsp+0h] [xbp-40h] BYREF

  *a1 = mutex;
  do
    result = pthread_mutex_lock(mutex);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    v4 = result;
    v5 = sub_67DDA30();
    sub_684956C((int)v6, "boost: mutex lock failed in pthread_mutex_lock");
    v6[3] = v5;
    memset(&v6[4], 0, 24);
    v6[2] = v4;
    v6[0] = off_6878538;
    sub_25C5D24((__int64)v6);
  }
  return result;
}


================================================================================
Function: sub_25C70F0 (0x25C70F0)
================================================================================

__int64 __fastcall sub_25C70F0(__int64 a1)
{
  pthread_mutex_t *v1; // x20
  __int64 result; // x0
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  v1 = *(pthread_mutex_t **)a1;
  if ( !*(_QWORD *)a1 )
  {
    sub_25C5E54(v4, 1u, "boost unique_lock has no mutex");
    sub_25C5D24((__int64)v4);
  }
  if ( !*(_BYTE *)(a1 + 8) )
  {
    sub_25C5E54(v4, 1u, "boost unique_lock doesn't own the mutex");
    sub_25C5D24((__int64)v4);
  }
  do
    result = pthread_mutex_unlock(v1);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    sub_25C5E54(v4, result, "boost: mutex unlock failed in pthread_mutex_unlock");
    sub_25C5D24((__int64)v4);
  }
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}


================================================================================
Function: sub_25C72B8 (0x25C72B8)
================================================================================

__int64 __fastcall sub_25C72B8(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int128 v5; // q0

  *(_QWORD *)(a1 + 96) = off_686EC48;
  sub_68495F8((_QWORD *)a1, a2);
  *(_QWORD *)a1 = off_6877DD8;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_68497A0((unsigned __int64 *)(a1 + 32), (__int128 *)(a2 + 32));
  v4 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)a1 = off_68786E8;
  *(_QWORD *)(a1 + 56) = off_686EB38;
  *(_QWORD *)(a1 + 64) = v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(_QWORD *)a1 = off_6878600;
  *(_QWORD *)(a1 + 56) = off_6878638;
  *(_QWORD *)(a1 + 96) = &off_6878670;
  return sub_24FA560(a1 + 56, a2 + 56);
}


================================================================================
Function: sub_25C7AF8 (0x25C7AF8)
================================================================================

__int64 __fastcall sub_25C7AF8(__int64 a1)
{
  __int64 result; // x0
  pthread_mutex_t *v4; // x19
  pthread_mutex_t *mutex; // [xsp+0h] [xbp-50h] BYREF
  char v6; // [xsp+8h] [xbp-48h]
  __int64 v7; // [xsp+10h] [xbp-40h] BYREF
  char v8; // [xsp+18h] [xbp-38h]

  mutex = (pthread_mutex_t *)(a1 + 8);
  v6 = 0;
  result = sub_25C6ADC((__int64)&mutex);
  if ( (*(_DWORD *)a1)-- != 1 )
  {
    if ( !v6 )
      return result;
    goto LABEL_8;
  }
  if ( *(_BYTE *)(a1 + 5) )
  {
    *(_WORD *)(a1 + 4) = 1;
    sub_25C70F0(&mutex);
    v8 = 1;
    v7 = a1 + 224;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 224));
    pthread_cond_signal((pthread_cond_t *)(a1 + 264));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 224));
  }
  else
  {
    *(_BYTE *)(a1 + 6) = 0;
    sub_25C70F0(&mutex);
  }
  result = sub_25C7C54(a1);
  if ( v6 )
  {
LABEL_8:
    v4 = mutex;
    do
      result = pthread_mutex_unlock(v4);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25C5E54(&v7, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24((__int64)&v7);
    }
  }
  return result;
}


================================================================================
Function: sub_25C7C54 (0x25C7C54)
================================================================================

__int64 __fastcall sub_25C7C54(__int64 a1)
{
  pthread_mutex_t *v2; // x20

  v2 = (pthread_mutex_t *)(a1 + 136);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 136));
  pthread_cond_signal((pthread_cond_t *)(a1 + 176));
  pthread_mutex_unlock(v2);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 88));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 48));
}


================================================================================
Function: sub_25F4F30 (0x25F4F30)
================================================================================

__int64 __fastcall sub_25F4F30(__int64 a1, unsigned int a2)
{
  unsigned int v3; // w8
  __int64 result; // x0
  unsigned int v5; // w20
  __int64 v6; // x22
  int v7; // w9
  __int64 v8; // x8
  unsigned __int64 *v9; // x20
  __int64 v10; // x19
  __int128 v11; // [xsp+0h] [xbp-20h] BYREF

  v3 = *(_DWORD *)a1 & 0xFFFFFFFE | (a2 < 9);
  *(_DWORD *)a1 = v3;
  if ( a2 > 8 )
  {
    v6 = a2;
    v5 = a2;
    result = sub_65ECAAC();
    v3 = *(_DWORD *)a1;
    *(_QWORD *)(a1 + 8) = result;
    *(_QWORD *)(a1 + 16) = v6;
  }
  else
  {
    result = *(_QWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 16);
  }
  v7 = v3 & 1;
  if ( (v3 & 1) != 0 )
    v8 = 8LL;
  else
    v8 = v5;
  if ( v7 )
    v9 = (unsigned __int64 *)(a1 + 8);
  else
    v9 = (unsigned __int64 *)result;
  LOWORD(v11) = 0;
  *(_DWORD *)a1 = v7;
  *(_DWORD *)(a1 + 4) = 0;
  if ( (_DWORD)v8 )
  {
    v10 = 48 * v8;
    do
    {
      result = (__int64)sub_68497A0(v9, &v11);
      v9 += 6;
      v10 -= 48LL;
    }
    while ( v10 );
    if ( (v11 & 1) != 0 )
      return sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_2638B34 (0x2638B34)
================================================================================

__int64 **__fastcall sub_2638B34(_QWORD *a1, unsigned __int8 *a2)
{
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x8
  bool v6; // zf
  unsigned __int64 v7; // x8
  __int64 *v8; // x1
  unsigned __int64 v9; // x2
  unsigned __int64 v10; // x0
  int8x8_t v11; // x24
  unsigned __int64 v12; // x19
  uint8x8_t v13; // d0
  unsigned __int64 v14; // x25
  unsigned __int64 v15; // x26
  __int64 ***v16; // x8
  size_t v17; // x10
  unsigned __int8 *v18; // x11
  unsigned __int8 *v19; // x12
  unsigned __int64 v20; // x9
  __int64 **v21; // x20
  size_t v22; // x21
  unsigned __int8 *v23; // x22
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x10
  unsigned __int64 v26; // x11
  __int64 *v27; // x0
  __int64 v28; // x9
  __int64 v30; // [xsp+0h] [xbp-10h] BYREF

  v4 = *((_QWORD *)a2 + 1);
  v5 = *a2;
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
    v8 = (__int64 *)(a2 + 1);
  else
    v8 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v6 )
    v9 = v7;
  else
    v9 = v4;
  v10 = sub_24FE128((__int64)&v30, v8, v9);
  v11.n64_u64[0] = a1[1];
  if ( !v11.n64_u64[0] )
    return 0LL;
  v12 = v10;
  v13.n64_u64[0] = vcnt_s8(v11).n64_u64[0];
  v13.n64_u16[0] = vaddlv_u8(v13);
  v14 = v13.n64_u32[0];
  if ( v13.n64_u32[0] > 1uLL )
  {
    v15 = v10;
    if ( v10 >= v11.n64_u64[0] )
      v15 = v10 % v11.n64_u64[0];
  }
  else
  {
    v15 = (v11.n64_u64[0] - 1) & v10;
  }
  v16 = *(__int64 ****)(*a1 + 8 * v15);
  if ( !v16 )
    return 0LL;
  v17 = *((_QWORD *)a2 + 1);
  v18 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  v19 = a2 + 1;
  v20 = *a2;
  v21 = *v16;
  if ( (v20 & 1) != 0 )
    v22 = v17;
  else
    v22 = v20 >> 1;
  if ( (v20 & 1) != 0 )
    v23 = v18;
  else
    v23 = v19;
  for ( ; v21; v21 = (__int64 **)*v21 )
  {
    v24 = (unsigned __int64)v21[1];
    if ( v12 == v24 )
    {
      v25 = *((unsigned __int8 *)v21 + 16);
      v26 = (unsigned __int64)v21[3];
      if ( (v25 & 1) == 0 )
        v26 = v25 >> 1;
      if ( v26 == v22 )
      {
        if ( (v25 & 1) != 0 )
          v27 = v21[4];
        else
          v27 = (__int64 *)((char *)v21 + 17);
        if ( (v25 & 1) != 0 )
        {
          if ( !v22 || !memcmp(v27, v23, v22) )
            return v21;
        }
        else
        {
          if ( !v22 )
            return v21;
          v28 = 0LL;
          while ( *((unsigned __int8 *)v21 + v28 + 17) == v23[v28] )
          {
            if ( v25 >> 1 == ++v28 )
              return v21;
          }
        }
      }
    }
    else
    {
      if ( v14 <= 1 )
      {
        v24 &= v11.n64_u64[0] - 1;
      }
      else if ( v24 >= v11.n64_u64[0] )
      {
        v24 %= v11.n64_u64[0];
      }
      if ( v24 != v15 )
        return 0LL;
    }
  }
  return v21;
}


================================================================================
Function: sub_26D904C (0x26D904C)
================================================================================

unsigned __int8 *__fastcall sub_26D904C(__int64 a1)
{
  unsigned __int8 *v1; // x20
  unsigned __int8 *result; // x0
  int v4; // w8
  unsigned __int8 *v5; // x10
  unsigned __int64 v6; // x9
  bool v7; // zf
  unsigned __int64 v8; // x9
  unsigned __int8 *v9; // x9
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x21
  unsigned __int8 *v12; // x9
  unsigned __int8 *v13; // x9
  unsigned __int64 v14; // x1
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x8
  bool v17; // zf
  unsigned __int64 v18; // x11
  unsigned __int8 *v19; // x8
  char v20; // w9
  __int64 v21; // x10
  unsigned __int64 v22; // x9

  v1 = (unsigned __int8 *)(a1 + 64);
  result = (unsigned __int8 *)sub_684A438(a1 + 64);
  v4 = *(_DWORD *)(a1 + 96);
  *(_QWORD *)(a1 + 88) = 0LL;
  if ( (v4 & 8) != 0 )
  {
    v5 = *(unsigned __int8 **)(a1 + 80);
    v6 = *(unsigned __int8 *)(a1 + 64);
    v7 = (v6 & 1) == 0;
    v8 = v6 >> 1;
    if ( v7 )
      v5 = v1 + 1;
    if ( !v7 )
      v8 = *(_QWORD *)(a1 + 72);
    v9 = &v5[v8];
    *(_QWORD *)(a1 + 16) = v5;
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 88) = v9;
    *(_QWORD *)(a1 + 32) = v9;
  }
  if ( (v4 & 0x10) != 0 )
  {
    v10 = *(unsigned __int8 *)(a1 + 64);
    if ( (v10 & 1) != 0 )
      v11 = *(_QWORD *)(a1 + 72);
    else
      v11 = v10 >> 1;
    if ( (v10 & 1) != 0 )
      v12 = *(unsigned __int8 **)(a1 + 80);
    else
      v12 = v1 + 1;
    v13 = &v12[v11];
    if ( (v10 & 1) != 0 )
      v14 = (*(_QWORD *)(a1 + 64) & 0xFFFFFFFFFFFFFFFELL) - 1;
    else
      v14 = 22LL;
    *(_QWORD *)(a1 + 88) = v13;
    result = sub_684A708(v1, v14, 0);
    v15 = *(_QWORD *)(a1 + 72);
    v16 = *(unsigned __int8 *)(a1 + 64);
    v17 = (v16 & 1) == 0;
    v18 = v16 >> 1;
    if ( (v16 & 1) != 0 )
      v19 = *(unsigned __int8 **)(a1 + 80);
    else
      v19 = v1 + 1;
    v20 = *(_BYTE *)(a1 + 96);
    if ( v17 )
      v15 = v18;
    *(_QWORD *)(a1 + 40) = v19;
    *(_QWORD *)(a1 + 48) = v19;
    *(_QWORD *)(a1 + 56) = &v19[v15];
    if ( (v20 & 3) != 0 )
    {
      if ( v11 >> 31 )
      {
        v21 = ((v11 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        v22 = 0x7FFFFFFF * ((v21 + ((v11 - 0x80000000 - v21) >> 1)) >> 30);
        v19 += v22 + 0x7FFFFFFF;
        v11 = v11 - v22 - 0x7FFFFFFF;
        *(_QWORD *)(a1 + 48) = v19;
      }
      if ( v11 )
        *(_QWORD *)(a1 + 48) = &v19[(unsigned int)v11];
    }
  }
  return result;
}


================================================================================
Function: sub_2706758 (0x2706758)
================================================================================

long double __fastcall sub_2706758(__int64 a1)
{
  long double result; // q0
  _BYTE v3[56]; // [xsp+0h] [xbp-40h] BYREF

  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)a1 = off_6C58320;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 48), 0LL) )
  {
    sub_25C1BEC(v3);
    sub_25C1ABC((__int64)v3);
  }
  sub_25C1984(a1 + 88);
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 176), 0LL) )
  {
    sub_25C1BEC(v3);
    sub_25C1ABC((__int64)v3);
  }
  sub_25C1984(a1 + 216);
  *(_OWORD *)&result = 0uLL;
  *(_WORD *)(a1 + 304) = 0;
  *(_BYTE *)(a1 + 306) = 0;
  *(_QWORD *)(a1 + 312) = 0LL;
  *(_QWORD *)(a1 + 320) = a1 + 328;
  *(_QWORD *)(a1 + 328) = 0LL;
  *(_QWORD *)(a1 + 336) = 0LL;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_WORD *)(a1 + 408) = 1;
  return result;
}


================================================================================
Function: sub_2706CA4 (0x2706CA4)
================================================================================

__int64 __fastcall sub_2706CA4(_QWORD *a1)
{
  __int64 v2; // x20
  __int64 result; // x0

  v2 = sub_67DDA30();
  result = sub_684956C((int)a1, "boost::thread_resource_error");
  a1[2] = 11LL;
  a1[3] = v2;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[4] = 0LL;
  *a1 = off_6877FA8;
  return result;
}


================================================================================
Function: sub_2AFF1BC (0x2AFF1BC)
================================================================================

void sub_2AFF1BC()
{
  unsigned __int8 v0; // w8
  __int64 v1; // x19
  __int64 v2; // x23
  __int64 v3; // x22
  int v4; // w19
  __int128 v5; // [xsp+0h] [xbp-20h] BYREF
  char *v6; // [xsp+10h] [xbp-10h]

  if ( dword_6CD5F20 )
  {
    v0 = atomic_load(byte_6CD6158);
    if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8(byte_6CD6158) )
    {
      dword_6CD6150 = dword_6CD60B0;
      sub_6862850(byte_6CD6158);
    }
    v1 = sub_65F7C30();
    v2 = *(_QWORD *)sub_65FAAE0(&qword_6CD6130);
    v3 = v1 - v2;
    if ( v1 - v2 >= (unsigned __int64)dword_6CD5F20 )
    {
      v4 = dword_6CD60B4;
      if ( v4 != (unsigned int)sub_68671E0((unsigned int)dword_6CD60B4, &dword_6CD6150) )
      {
        if ( v2 )
        {
          if ( v3 < 0 )
          {
            if ( !dword_6CD5EF4 )
              atomic_store(dword_6CD60B4, (unsigned int *)&dword_6CD6128);
            v6 = (char *)sub_65ECAAC(64LL);
            v5 = xmmword_AFF840;
            strcpy(v6, "GameLdr-PerformanceCheck0,GameLdr-PerformanceCheck2");
            sub_3C03FD0(&v5, 0LL);
          }
          else
          {
            if ( !dword_6CD5F08 )
              atomic_store(dword_6CD60B4, (unsigned int *)&dword_6CD6128);
            v6 = (char *)sub_65ECAAC(64LL);
            v5 = xmmword_AFF840;
            strcpy(v6, "GameLdr-PerformanceCheck0,GameLdr-PerformanceCheck3");
            sub_3C03FD0(&v5, 0LL);
          }
        }
        else
        {
          atomic_store(dword_6CD60B4, (unsigned int *)&dword_6CD6128);
          v6 = (char *)sub_65ECAAC(64LL);
          v5 = xmmword_AFF840;
          strcpy(v6, "GameLdr-PerformanceCheck0,GameLdr-PerformanceCheck1");
          sub_3C03FD0(&v5, 0LL);
        }
        if ( (v5 & 1) != 0 )
          sub_65ECAF4(v6);
      }
    }
  }
}


================================================================================
Function: sub_2CE06A0 (0x2CE06A0)
================================================================================

bool __fastcall sub_2CE06A0(pthread_mutex_t *a1, __int64 a2, const struct timespec *a3)
{
  pthread_cond_t *v6; // x22
  unsigned int v7; // w20
  __int64 v8; // x0
  _BYTE v10[56]; // [xsp+10h] [xbp-40h] BYREF

  v6 = (pthread_cond_t *)&a1[1];
  sub_25C6BC8(v10, a1, &a1[1]);
  sub_25C70F0(a2);
  v7 = pthread_cond_timedwait(v6, a1, a3);
  v8 = sub_25C6D08(v10);
  sub_67DFB28(v8);
  if ( v7 && v7 != 110 )
  {
    sub_25C6F24(v10, v7, "boost::condition_variable::do_wait_until failed in pthread_cond_timedwait");
    sub_25C6DF4(v10);
  }
  sub_25C6ADC(a2);
  return v7 != 110;
}


================================================================================
Function: sub_2D6A56C (0x2D6A56C)
================================================================================

__int64 __fastcall sub_2D6A56C(unsigned __int8 *a1, __int64 *a2, void *a3, __int64 a4, char *a5, char *a6, void *a7)
{
  char *v8; // x8
  unsigned __int8 *v9; // x28
  char v10; // w10
  unsigned __int8 *v11; // x9
  unsigned __int8 *v15; // x25
  unsigned __int8 *v16; // x4
  unsigned __int8 *v17; // x26
  _QWORD *v18; // x1
  __int64 v19; // x2
  unsigned __int8 *v20; // x9
  unsigned __int64 v21; // x10
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x8
  char *v24; // x11
  __int64 v25; // x12
  __int64 v26; // x13
  unsigned __int8 *v27; // x5
  __int64 v28; // x8
  __int64 v29; // x15
  __int64 v30; // x14
  __int64 v31; // x14
  __int64 v32; // x0
  unsigned __int64 v33; // x9
  bool v34; // zf
  unsigned __int64 v35; // x12
  unsigned __int8 *v36; // x9
  unsigned __int64 v37; // x10
  unsigned __int8 *v38; // x1
  _QWORD *v39; // x2
  _QWORD *v40; // x4
  __int64 v41; // x3
  __int64 v42; // x5
  __int64 v43; // x19
  __int64 v44; // x20
  unsigned __int64 v45; // x8
  unsigned __int64 v46; // x8
  __int64 v47; // x8
  __int64 result; // x0
  __int128 v49; // [xsp+0h] [xbp-40h] BYREF
  __int128 v50; // [xsp+10h] [xbp-30h]
  __int128 v51; // [xsp+20h] [xbp-20h]
  char v52; // [xsp+30h] [xbp-10h] BYREF

  v8 = a6;
  v9 = a1 + 1;
  v10 = *a1;
  v50 = 0u;
  v51 = 0u;
  v11 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  v49 = 0u;
  if ( (v10 & 1) == 0 )
    v11 = a1 + 1;
  if ( a5 == a6 )
  {
    v17 = v11;
    v15 = v11;
  }
  else
  {
    v15 = v11;
    v16 = v11;
    while ( 1 )
    {
      v17 = (unsigned __int8 *)v8;
      v15 = (unsigned __int8 *)sub_2D6A9A0((int)&v52, (int)&v49, (int)a1, v15, v16);
      v18 = (_QWORD *)(*((_QWORD *)&v49 + 1) + ((((_QWORD)v51 + *((_QWORD *)&v51 + 1)) >> 9) & 0x7FFFFFFFFFFFF8LL));
      if ( (_QWORD)v50 == *((_QWORD *)&v49 + 1) )
        LODWORD(v19) = 0;
      else
        v19 = *v18 + (((_WORD)v51 + WORD4(v51)) & 0xFFF);
      sub_2D6B628((int)&v49, (int)v18, v19, a7);
      v21 = *((_QWORD *)a1 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      v22 = *a1;
      v34 = (v22 & 1) == 0;
      v23 = v22 >> 1;
      if ( v34 )
      {
        v20 = v9;
        v21 = v23;
      }
      v24 = (char *)&v20[v21];
      if ( v17 == &v20[v21] )
        break;
      v25 = *a2;
      v26 = a2[1];
      if ( *a2 == v26 )
        break;
      v27 = v17;
LABEL_13:
      v28 = 0LL;
      do
      {
        if ( v27[v28] != *(unsigned __int8 *)(v25 + v28) )
        {
          v31 = v25 + v28;
          v8 = (char *)&v27[v28];
          if ( v31 == v26 )
            goto LABEL_22;
LABEL_20:
          if ( ++v27 != (unsigned __int8 *)v24 )
            goto LABEL_13;
          goto LABEL_26;
        }
        v29 = v28 + 1;
        if ( &v27[v28 + 1] == (unsigned __int8 *)v24 )
          break;
        v30 = v25 + v28++;
      }
      while ( v30 + 1 != v26 );
      v8 = (char *)&v27[v29];
      if ( v25 + v29 != v26 )
        goto LABEL_20;
LABEL_22:
      v16 = v17;
      if ( v27 == (unsigned __int8 *)v8 )
        break;
      a7 = a3;
    }
  }
LABEL_26:
  v32 = sub_2D6A9A0((int)&v52, (int)&v49, (int)a1, v15, v17);
  v33 = *a1;
  v34 = (v33 & 1) == 0;
  v35 = v33 >> 1;
  if ( (v33 & 1) != 0 )
    v36 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  else
    v36 = v9;
  if ( v34 )
    v37 = v35;
  else
    v37 = *((_QWORD *)a1 + 1);
  v38 = &v36[v37];
  if ( *((_QWORD *)&v51 + 1) )
  {
    v39 = (_QWORD *)(*((_QWORD *)&v49 + 1) + (((unsigned __int64)v51 >> 9) & 0x7FFFFFFFFFFFF8LL));
    if ( (_QWORD)v50 == *((_QWORD *)&v49 + 1) )
    {
      v41 = 0LL;
      v42 = 0LL;
      v40 = (_QWORD *)(*((_QWORD *)&v49 + 1) + ((((_QWORD)v51 + *((_QWORD *)&v51 + 1)) >> 9) & 0x7FFFFFFFFFFFF8LL));
    }
    else
    {
      v40 = (_QWORD *)(*((_QWORD *)&v49 + 1) + ((((_QWORD)v51 + *((_QWORD *)&v51 + 1)) >> 9) & 0x7FFFFFFFFFFFF8LL));
      v41 = *v39 + (v51 & 0xFFF);
      v42 = *v40 + ((v51 + *((_QWORD *)&v51 + 1)) & 0xFFF);
    }
    sub_2D6CD9C(a1, v38, v39, v41, v40, v42);
  }
  else
  {
    sub_6849EB4(a1, v32 - (_QWORD)v36, &v38[-v32]);
  }
  v43 = *((_QWORD *)&v49 + 1);
  v44 = v50;
  *((_QWORD *)&v51 + 1) = 0LL;
  v45 = v50 - *((_QWORD *)&v49 + 1);
  if ( (_QWORD)v50 - *((_QWORD *)&v49 + 1) >= 0x11uLL )
  {
    do
    {
      sub_65ECAF4();
      v44 = v50;
      v43 = *((_QWORD *)&v49 + 1) + 8LL;
      v45 = v50 - (*((_QWORD *)&v49 + 1) + 8LL);
      *((_QWORD *)&v49 + 1) += 8LL;
    }
    while ( v45 > 0x10 );
  }
  v46 = v45 >> 3;
  if ( v46 == 1 )
  {
    v47 = 2048LL;
    goto LABEL_44;
  }
  if ( v46 == 2 )
  {
    v47 = 4096LL;
LABEL_44:
    *(_QWORD *)&v51 = v47;
  }
  if ( v43 != v44 )
  {
    do
    {
      v43 += 8LL;
      sub_65ECAF4();
    }
    while ( v43 != v44 );
    if ( (_QWORD)v50 != *((_QWORD *)&v49 + 1) )
      *(_QWORD *)&v50 = v50 + 8 * ~((unsigned __int64)(v50 - *((_QWORD *)&v49 + 1) - 8) >> 3);
  }
  result = v49;
  if ( (_QWORD)v49 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_2D6A9A0 (0x2D6A9A0)
================================================================================

_BYTE *__fastcall sub_2D6A9A0(int a1, int64x2_t *a2, int a3, _BYTE *dest, _BYTE *src, _BYTE *a6)
{
  __int64 v9; // x8
  _BYTE *v10; // x21
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x9
  __int64 v13; // x9
  _BYTE *i; // x21
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x8
  __int64 v17; // x11
  unsigned __int64 v18; // x8
  __int64 v19; // x10
  int64x2_t v20; // q0
  size_t v21; // x19

  v9 = a2[2].n128_i64[1];
  v10 = dest;
  if ( v9 && dest != src )
  {
    v11 = a2[2].n128_u64[0];
    do
    {
      *v10 = *(_BYTE *)(*(_QWORD *)(a2->n128_u64[1] + ((v11 >> 9) & 0x7FFFFFFFFFFFF8LL)) + (v11 & 0xFFF));
      v11 = a2[2].n128_u64[0] + 1;
      v9 = a2[2].n128_u64[1] - 1;
      a2[2].n128_u64[0] = v11;
      a2[2].n128_u64[1] = v9;
      if ( v11 >= 0x2000 )
      {
        sub_65ECAF4();
        v12 = a2[2].n128_u64[0];
        v9 = a2[2].n128_i64[1];
        a2->n128_u64[1] += 8LL;
        v11 = v12 - 4096;
        a2[2].n128_u64[0] = v11;
      }
      ++v10;
    }
    while ( v9 && v10 != src );
  }
  if ( v9 )
  {
    if ( v10 != a6 )
    {
      v13 = a2[2].n128_i64[0];
      for ( i = v10 + 1; ; ++i )
      {
        v15 = a2->n128_u64[1];
        v16 = v9 + v13;
        v17 = ((a2[1].n128_u64[0] - v15) << 9) - 1;
        if ( a2[1].n128_u64[0] == v15 )
          v17 = 0LL;
        if ( v17 == v16 )
        {
          sub_2D6AB64(a2);
          v15 = a2->n128_u64[1];
          v16 = a2[2].n128_u64[0] + a2[2].n128_u64[1];
        }
        *(_BYTE *)(*(_QWORD *)(v15 + ((v16 >> 9) & 0x7FFFFFFFFFFFF8LL)) + (v16 & 0xFFF)) = *(i - 1);
        v18 = a2[2].n128_u64[0];
        v19 = *(_QWORD *)(a2->n128_u64[1] + ((v18 >> 9) & 0x7FFFFFFFFFFFF8LL));
        ++a2[2].n128_u64[1];
        *(i - 1) = *(_BYTE *)(v19 + (v18 & 0xFFF));
        v20 = vaddq_s64(a2[2], (int64x2_t)xmmword_AFE0C0);
        v13 = v20.n128_u64[0];
        a2[2] = v20;
        if ( v20.n128_u64[0] >= 0x2000 )
        {
          sub_65ECAF4();
          v13 = a2[2].n128_u64[0] - 4096;
          a2->n128_u64[1] += 8LL;
          a2[2].n128_u64[0] = v13;
        }
        if ( i == a6 )
          break;
        v9 = a2[2].n128_i64[1];
      }
    }
  }
  else if ( v10 != src )
  {
    v21 = a6 - src;
    if ( v21 )
      memmove(v10, src, v21);
    return &v10[v21];
  }
  return a6;
}


================================================================================
Function: sub_2D6AB64 (0x2D6AB64)
================================================================================

__int64 __fastcall sub_2D6AB64(__int64 *a1)
{
  unsigned __int64 v2; // x8
  bool v3; // cf
  unsigned __int64 v4; // x8
  __int64 *v5; // x9
  __int64 v6; // x8
  __int64 result; // x0
  __int64 v8; // x8
  __int64 v9; // x9
  __int64 v10; // x10
  unsigned __int64 v11; // x22
  unsigned __int64 v12; // x8
  __int64 v13; // x20
  __int64 v14; // x20
  __int64 v15; // x22
  __int128 v16; // q0
  __int64 v17; // x10
  __int64 v18; // x8
  __int64 v19; // x9
  __int64 *v20; // x8
  __int64 v21; // t1
  __int64 v22; // [xsp+8h] [xbp-38h] BYREF
  __int64 v23; // [xsp+10h] [xbp-30h] BYREF
  __int128 v24; // [xsp+18h] [xbp-28h]
  __int64 v25; // [xsp+28h] [xbp-18h]
  _QWORD *v26; // [xsp+30h] [xbp-10h]

  v2 = a1[4];
  v3 = v2 >= 0x1000;
  v4 = v2 - 4096;
  if ( v3 )
  {
    v5 = (__int64 *)a1[1];
    a1[4] = v4;
    v6 = *v5;
    a1[1] = (__int64)(v5 + 1);
    v23 = v6;
    return sub_2D6AD80(a1, &v23);
  }
  v8 = a1[2];
  v9 = a1[3];
  v10 = v9 - *a1;
  v11 = (v8 - a1[1]) >> 3;
  if ( v11 < v10 >> 3 )
  {
    if ( v9 != v8 )
    {
      v23 = sub_65ECAAC();
      return sub_2D6AF38(a1, &v23);
    }
    v23 = sub_65ECAAC();
    sub_2D6B0F0(a1, &v23);
    v20 = (__int64 *)a1[1];
    v21 = *v20;
    a1[1] = (__int64)(v20 + 1);
    v23 = v21;
    return sub_2D6AD80(a1, &v23);
  }
  v12 = v10 >> 2;
  if ( !v10 )
    v12 = 1LL;
  v26 = a1 + 3;
  if ( v12 >> 61 )
    sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v13 = 8 * v12;
  v23 = sub_65ECAAC();
  *(_QWORD *)&v24 = v23 + 8 * v11;
  *((_QWORD *)&v24 + 1) = v24;
  v25 = v23 + v13;
  v22 = sub_65ECAAC();
  sub_2D6B2B0(&v23, &v22);
  v14 = a1[2];
  v15 = v14 + 8;
  while ( v14 != a1[1] )
  {
    v14 -= 8LL;
    v15 -= 8LL;
    sub_2D6B468(&v23, v14);
  }
  result = *a1;
  v16 = v24;
  *a1 = v23;
  v17 = v25;
  v18 = a1[2];
  v19 = a1[3];
  *(_OWORD *)(a1 + 1) = v16;
  v23 = result;
  *(_QWORD *)&v24 = v14;
  a1[3] = v17;
  *((_QWORD *)&v24 + 1) = v18;
  v25 = v19;
  if ( v14 != v18 )
    *((_QWORD *)&v24 + 1) = v18 + 8 * ~((unsigned __int64)(v18 - v15) >> 3);
  if ( result )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_2D6AD80 (0x2D6AD80)
================================================================================

__int64 __fastcall sub_2D6AD80(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_65ECAAC();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_65ECAF4();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_2D6AF38 (0x2D6AF38)
================================================================================

__int64 __fastcall sub_2D6AF38(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_65ECAAC();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_65ECAF4();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_2D6B0F0 (0x2D6B0F0)
================================================================================

__int64 __fastcall sub_2D6B0F0(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_65ECAAC();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_65ECAF4();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_2D6B2B0 (0x2D6B2B0)
================================================================================

__int64 __fastcall sub_2D6B2B0(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_65ECAAC();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_65ECAF4();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_2D6B468 (0x2D6B468)
================================================================================

__int64 __fastcall sub_2D6B468(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_65ECAAC();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_65ECAF4();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_2D6B628 (0x2D6B628)
================================================================================

_QWORD *__fastcall sub_2D6B628(int64x2_t *a1, char *a2, __int64 a3, char *src, char *a5)
{
  unsigned __int64 v5; // x10
  char *v6; // x20
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x21
  unsigned __int64 v11; // x11
  char *v12; // x12
  unsigned __int64 v13; // x13
  __int64 v14; // x14
  unsigned __int64 v15; // x25
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x12
  char **v18; // x22
  char *v19; // x23
  unsigned __int64 v20; // x8
  char *v21; // x8
  char *v22; // x10
  char *v23; // x11
  char *v24; // x9
  char **v25; // x8
  char v26; // t1
  __int64 v27; // t1
  __int64 v28; // x11
  unsigned __int64 v29; // x10
  unsigned __int64 v30; // x11
  _QWORD *v31; // x2
  char *v32; // x3
  unsigned __int64 v33; // x8
  char *v34; // x11
  char *v35; // x12
  _QWORD *v36; // x9
  char *v37; // x10
  char *v38; // t1
  __int64 v39; // x10
  void **v40; // x0
  unsigned __int64 v41; // x11
  char *v42; // x1
  char *v43; // x11
  void **v44; // x10
  char v45; // t1
  __int64 v46; // t1
  __int64 v47; // t1
  __int64 v48; // x8
  _DWORD *v49; // x2
  __int64 v50; // x11
  _QWORD *v51; // x22
  unsigned __int64 v52; // x12
  char *v53; // x23
  _QWORD *v54; // x11
  char *v55; // x12
  char *v56; // t1
  char *v57; // t1
  __int64 v58; // x8
  char *v59; // x9
  unsigned __int64 v60; // x9
  char *v61; // x1
  unsigned __int64 v62; // x9
  __int64 v63; // x8
  __int64 v64; // x8
  char *v65; // x26
  __int64 v66; // x27
  unsigned __int64 v67; // x9
  __int64 v68; // x11
  char *v69; // x8
  __int64 v70; // x25
  char *v71; // t1
  _BYTE *v72; // x9
  char *v73; // x10
  bool v74; // cc
  char *v75; // x0
  __int64 v76; // x27
  __int64 v77; // x8
  unsigned __int64 v78; // x9
  unsigned __int64 v79; // x9
  _QWORD *result; // x0
  __int64 v81; // x1
  __int64 v82; // x8

  v5 = a1[2].n128_u64[0];
  v6 = a5;
  v7 = a1->n128_u64[1];
  v8 = a1[1].n128_u64[0];
  v9 = src;
  v11 = v5 >> 12;
  v12 = (char *)(v7 + 8 * (v5 >> 12));
  v13 = v8 - v7;
  if ( v8 == v7 )
    v14 = 0LL;
  else
    v14 = *(_QWORD *)v12 + (a1[2].n128_u64[0] & 0xFFF);
  v15 = a5 - src;
  if ( a3 == v14 )
    v16 = 0LL;
  else
    v16 = a3 + ((a2 - v12) << 9) - (v14 + *(_QWORD *)a2) + *(_QWORD *)v12;
  v17 = a1[2].n128_u64[1];
  if ( v16 < v17 - v16 )
  {
    if ( v15 > v5 )
    {
      sub_2D6BCB4(a1, v15 - v5);
      v5 = a1[2].n128_u64[0];
      v7 = a1->n128_u64[1];
      v8 = a1[1].n128_u64[0];
      v11 = v5 >> 12;
    }
    v18 = (char **)(v7 + 8 * v11);
    if ( v8 == v7 )
    {
      v19 = 0LL;
      v20 = v15 - v16;
      if ( v15 > v16 )
      {
LABEL_12:
        v21 = &v9[v20];
        if ( v16 >= v15 >> 1 )
          v22 = v21;
        else
          v22 = &v6[-v16];
        if ( v22 == v9 )
        {
          v24 = v19;
          v25 = v18;
          v15 = v16;
          if ( !v16 )
            goto LABEL_111;
        }
        else
        {
          v23 = v22;
          v24 = v19;
          v25 = v18;
          do
          {
            if ( v24 == *v25 )
            {
              v27 = (__int64)*--v25;
              v24 = (char *)(v27 + 4096);
            }
            v26 = *--v23;
            *--v24 = v26;
            a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_B01A10);
          }
          while ( v23 != v9 );
          v9 = v22;
          v15 = v16;
          if ( !v16 )
            goto LABEL_111;
        }
LABEL_46:
        v39 = v19 - *v18 + v15;
        if ( v39 < 1 )
        {
          v39 = 4095 - v39;
          v41 = (unsigned __int64)v39 >> 9;
          LOWORD(v39) = ~(_WORD)v39;
          v40 = (void **)((char *)v18 - (v41 & 0x7FFFFFFFFFFFF8LL));
        }
        else
        {
          v40 = (void **)((char *)v18 + (((unsigned __int64)v39 >> 9) & 0x7FFFFFFFFFFFF8LL));
        }
        v42 = (char *)*v40 + (v39 & 0xFFF);
        if ( v42 != v19 )
        {
          v43 = (char *)*v40 + (v39 & 0xFFF);
          v44 = v40;
          do
          {
            if ( v24 == *v25 )
            {
              v46 = (__int64)*--v25;
              v24 = (char *)(v46 + 4096);
            }
            --v24;
            if ( v43 == *v44 )
            {
              v47 = (__int64)*--v44;
              v43 = (char *)(v47 + 4096);
            }
            v45 = *--v43;
            *v24 = v45;
            a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_B01A10);
          }
          while ( v43 != v19 );
        }
        if ( v15 < v16 )
        {
          v48 = v19 - *v18 + v16;
          if ( v48 < 1 )
          {
            v48 = 4095 - v48;
            v60 = (unsigned __int64)v48 >> 9;
            LOWORD(v48) = ~(_WORD)v48;
            v49 = (_DWORD *)((char *)v18 - (v60 & 0x7FFFFFFFFFFFF8LL));
          }
          else
          {
            v49 = (_DWORD *)((char *)v18 + (((unsigned __int64)v48 >> 9) & 0x7FFFFFFFFFFFF8LL));
          }
          v18 = (char **)sub_2D6C338((int)v40, (int)v42, (int)v49, *v49 + (unsigned int)(v48 & 0xFFF), (int)v18, v19);
          v19 = v61;
        }
        if ( v9 != v6 )
        {
          do
          {
            v64 = *v18 - v19 + 4096;
            if ( v6 - v9 <= v64 )
              v65 = v6;
            else
              v65 = &v9[v64];
            if ( v6 - v9 <= v64 )
              v66 = v6 - v9;
            else
              v66 = *v18 - v19 + 4096;
            if ( v65 != v9 )
              memmove(v19, v9, v65 - v9);
            if ( v66 )
            {
              v63 = v19 - *v18 + v66;
              if ( v63 < 1 )
              {
                v63 = 4095 - v63;
                v62 = (unsigned __int64)v63 >> 9;
                LOWORD(v63) = ~(_WORD)v63;
                v18 = (char **)((char *)v18 - (v62 & 0x7FFFFFFFFFFFF8LL));
              }
              else
              {
                v18 = (char **)((char *)v18 + (((unsigned __int64)v63 >> 9) & 0x7FFFFFFFFFFFF8LL));
              }
              v19 = &(*v18)[v63 & 0xFFF];
            }
            v9 = v65;
          }
          while ( v65 != v6 );
        }
        goto LABEL_111;
      }
    }
    else
    {
      v19 = &(*v18)[v5 & 0xFFF];
      v20 = v15 - v16;
      if ( v15 > v16 )
        goto LABEL_12;
    }
    v24 = v19;
    v25 = v18;
    if ( !v15 )
      goto LABEL_111;
    goto LABEL_46;
  }
  v28 = (v13 << 9) - 1;
  v29 = v17 + v5;
  if ( !v13 )
    v28 = 0LL;
  v30 = v28 - v29;
  if ( v15 > v30 )
  {
    sub_2D6C4C0(a1, v15 - v30);
    v17 = a1[2].n128_u64[1];
    v7 = a1->n128_u64[1];
    v8 = a1[1].n128_u64[0];
    v29 = a1[2].n128_u64[0] + v17;
  }
  v31 = (_QWORD *)(v7 + ((v29 >> 9) & 0x7FFFFFFFFFFFF8LL));
  if ( v8 == v7 )
    v32 = 0LL;
  else
    v32 = (char *)(*v31 + (v29 & 0xFFF));
  v33 = v17 - v16;
  if ( v17 - v16 >= v15 )
  {
    v37 = v32;
    v36 = v31;
    if ( !v15 )
      goto LABEL_111;
  }
  else
  {
    if ( v33 >= v15 >> 1 )
      v34 = &v9[v17 - v16];
    else
      v34 = &v9[v33];
    if ( v34 == v6 )
    {
      v37 = v32;
      v36 = v31;
      v15 = v17 - v16;
      if ( !v33 )
        goto LABEL_111;
    }
    else
    {
      v35 = v34;
      v36 = v31;
      v37 = v32;
      do
      {
        *v37++ = *v35;
        if ( &v37[-*v36] == (char *)&qword_1000 )
        {
          v38 = (char *)v36[1];
          ++v36;
          v37 = v38;
        }
        ++v35;
        ++a1[2].n128_u64[1];
      }
      while ( v35 != v6 );
      v6 = v34;
      v15 = v33;
      if ( !v33 )
        goto LABEL_111;
    }
  }
  v50 = (__int64)&v32[-v15 - *v31];
  if ( v50 < 1 )
  {
    v50 = 4095 - v50;
    v52 = (unsigned __int64)v50 >> 9;
    LOWORD(v50) = ~(_WORD)v50;
    v51 = (_QWORD *)((char *)v31 - (v52 & 0x7FFFFFFFFFFFF8LL));
  }
  else
  {
    v51 = (_QWORD *)((char *)v31 + (((unsigned __int64)v50 >> 9) & 0x7FFFFFFFFFFFF8LL));
  }
  v53 = (char *)(*v51 + (v50 & 0xFFF));
  if ( v53 != v32 )
  {
    v54 = v51;
    v55 = v53;
    do
    {
      *v37++ = *v55;
      if ( &v37[-*v36] == (char *)&qword_1000 )
      {
        v56 = (char *)v36[1];
        ++v36;
        v37 = v56;
      }
      if ( &(++v55)[-*v54] == (char *)&qword_1000 )
      {
        v57 = (char *)v54[1];
        ++v54;
        v55 = v57;
      }
      ++a1[2].n128_u64[1];
    }
    while ( v55 != v32 );
  }
  if ( v15 < v33 )
  {
    v58 = (__int64)&v32[-v33 - *v31];
    if ( v58 < 1 )
    {
      v58 = 4095 - v58;
      v67 = (unsigned __int64)v58 >> 9;
      LOWORD(v58) = ~(_WORD)v58;
      v59 = (char *)v31 - (v67 & 0x7FFFFFFFFFFFF8LL);
    }
    else
    {
      v59 = (char *)v31 + (((unsigned __int64)v58 >> 9) & 0x7FFFFFFFFFFFF8LL);
    }
    v68 = *(_QWORD *)v59 + (v58 & 0xFFF);
    if ( v53 != (char *)v68 )
    {
      v69 = (char *)*v51;
      v70 = (__int64)&v53[512 * ((char *)v51 - v59) - v68 - *v51 + *(_QWORD *)v59];
      if ( v70 >= 1 )
      {
        if ( v53 != v69 )
          goto LABEL_98;
LABEL_97:
        v71 = (char *)*--v51;
        v69 = v71;
        v53 = v71 + 4096;
        while ( 1 )
        {
LABEL_98:
          v72 = (_BYTE *)(v53 - v69);
          v73 = &v53[-v70];
          v74 = v53 - v69 <= v70;
          --v53;
          if ( v74 )
            v75 = v69;
          else
            v75 = v73;
          if ( v74 )
            v76 = (__int64)v72;
          else
            v76 = v70;
          sub_2D6CC84(v75);
          v70 -= v76;
          if ( v76 != 1 )
          {
            v77 = (__int64)&v53[-v76 - *v51 + 1];
            if ( v77 < 1 )
            {
              v77 = 4094LL - (_QWORD)&v53[-v76 - *v51];
              v78 = (unsigned __int64)v77 >> 9;
              LOWORD(v77) = ~(_WORD)v77;
              v51 = (_QWORD *)((char *)v51 - (v78 & 0x7FFFFFFFFFFFF8LL));
            }
            else
            {
              v51 = (_QWORD *)((char *)v51 + (((unsigned __int64)v77 >> 9) & 0x7FFFFFFFFFFFF8LL));
            }
            v53 = (char *)(*v51 + (v77 & 0xFFF));
          }
          if ( v70 < 1 )
            break;
          v69 = (char *)*v51;
          if ( v53 == (char *)*v51 )
            goto LABEL_97;
        }
      }
    }
  }
  sub_2D6C9AC(v9, v6);
LABEL_111:
  v79 = a1->n128_u64[1];
  result = (_QWORD *)(v79 + ((a1[2].n128_u64[0] >> 9) & 0x7FFFFFFFFFFFF8LL));
  if ( a1[1].n128_u64[0] == v79 )
  {
    v81 = 0LL;
    if ( !v16 )
      return result;
  }
  else
  {
    v81 = *result + (a1[2].n128_u64[0] & 0xFFF);
    if ( !v16 )
      return result;
  }
  v82 = v81 - *result + v16;
  if ( v82 < 1 )
    return (_QWORD *)((char *)result - (((unsigned __int64)(4095 - v82) >> 9) & 0x7FFFFFFFFFFFF8LL));
  else
    return (_QWORD *)((char *)result + (((unsigned __int64)v82 >> 9) & 0x7FFFFFFFFFFFF8LL));
}


================================================================================
Function: sub_2D6BCB4 (0x2D6BCB4)
================================================================================

unsigned __int64 *__fastcall sub_2D6BCB4(unsigned __int64 *result, unsigned __int64 a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x11
  __int64 v6; // x10
  unsigned __int64 v7; // x13
  unsigned __int64 v8; // x21
  __int64 v9; // x13
  unsigned __int64 v10; // x26
  unsigned __int64 v11; // x20
  __int64 v12; // x10
  __int64 v13; // x11
  _BOOL8 v14; // x22
  unsigned __int64 v15; // x24
  char *v16; // x0
  unsigned __int64 v17; // t1
  unsigned __int64 v18; // x20
  unsigned __int64 v19; // x8
  unsigned __int64 v20; // t1
  unsigned __int64 v22; // x9
  __int64 v23; // x8
  __int64 v24; // x8
  unsigned __int64 v25; // x21
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // t1
  char *v28; // x9
  unsigned __int64 v29; // x24
  __int64 *v30; // x25
  char *v31; // x22
  unsigned __int64 v32; // x20
  char *v33; // x21
  __int64 v34; // x8
  __int64 v35; // x8
  size_t v36; // x22
  __int64 v37; // x8
  __int64 v38; // x27
  char *v39; // x20
  unsigned __int64 v40; // x27
  __int64 v41; // x0
  unsigned __int64 v42; // x10
  bool v43; // zf
  signed __int64 v44; // x9
  char *v45; // x8
  unsigned __int64 v46; // x11
  char *v47; // x9
  __int64 v48; // x11
  __int128 *v49; // x14
  _OWORD *v50; // x10
  __int64 v51; // x13
  __int64 v52; // x15
  char *v53; // x13
  __int128 v54; // q0
  __int128 v55; // q1
  __int64 v56; // t1
  char *v57; // x22
  __int64 v58; // t1
  __int64 *v59; // x9
  unsigned __int64 v60; // x20
  char *v61; // x21
  __int64 v62; // x8
  __int64 v63; // x8
  size_t v64; // x22
  __int64 v65; // x8
  __int64 v66; // x26
  char *v67; // x20
  unsigned __int64 v68; // x26
  __int64 v69; // x0
  unsigned __int64 v70; // x10
  signed __int64 v71; // x9
  char *v72; // x8
  unsigned __int64 v73; // x11
  char *v74; // x9
  __int64 v75; // x11
  __int128 *v76; // x14
  _OWORD *v77; // x10
  __int64 v78; // x13
  __int64 v79; // x15
  char *v80; // x13
  __int128 v81; // q0
  __int128 v82; // q1
  __int64 v83; // t1
  char *v84; // x8
  char *v85; // x10
  char *v86; // x11
  char *v87; // x9
  unsigned __int64 v88; // x10
  signed __int64 v89; // x8
  __int64 v90; // [xsp+8h] [xbp-38h] BYREF
  unsigned __int64 v91; // [xsp+10h] [xbp-30h] BYREF
  char *v92; // [xsp+18h] [xbp-28h]
  char *v93; // [xsp+20h] [xbp-20h]
  char *v94; // [xsp+28h] [xbp-18h]
  _QWORD *v95; // [xsp+30h] [xbp-10h]

  v2 = result;
  v4 = result[1];
  v3 = result[2];
  v5 = result[4];
  v6 = v3 - v4;
  if ( v3 == v4 )
    v7 = a2 + 1;
  else
    v7 = a2;
  if ( (v7 & 0xFFF) != 0 )
    v8 = (v7 >> 12) + 1;
  else
    v8 = v7 >> 12;
  v9 = (v6 << 9) - 1;
  if ( !v6 )
    v9 = 0LL;
  if ( v8 >= (v9 - (result[5] + v5)) >> 12 )
    v10 = (v9 - (result[5] + v5)) >> 12;
  else
    v10 = v8;
  v11 = v8 - v10;
  if ( v8 == v10 )
  {
    result[4] = v5 + (v10 << 12);
    if ( v10 )
    {
      v17 = *(_QWORD *)(v3 - 8);
      result[2] = v3 - 8;
      v91 = v17;
      result = (unsigned __int64 *)sub_2D6CAC4(result, &v91);
      if ( v10 != 1 )
      {
        v18 = 1 - v10;
        do
        {
          v19 = v2[2];
          v20 = *(_QWORD *)(v19 - 8);
          v2[2] = v19 - 8;
          v91 = v20;
          result = (unsigned __int64 *)sub_2D6CAC4(v2, &v91);
        }
        while ( !__CFADD__(v18++, 1LL) );
      }
    }
  }
  else
  {
    v12 = v6 >> 3;
    v13 = result[3] - *result;
    if ( v11 <= (v13 >> 3) - v12 )
    {
      if ( v4 == *result )
      {
LABEL_32:
        v25 = v11;
        do
        {
          v91 = sub_65ECAAC();
          result = (unsigned __int64 *)sub_2D6AF38(v2, &v91);
          --v25;
        }
        while ( v25 );
        v10 += v11;
        v24 = v2[4];
      }
      else
      {
        while ( 1 )
        {
          v91 = sub_65ECAAC();
          result = (unsigned __int64 *)sub_2D6B0F0(v2, &v91);
          v22 = v2[1];
          v23 = v2[2] - v22 == 8 ? 4095LL : 4096LL;
          --v11;
          v24 = v23 + v2[4];
          v2[4] = v24;
          if ( !v11 )
            break;
          if ( v22 == *v2 )
            goto LABEL_32;
        }
      }
      for ( v2[4] = v24 + (v10 << 12); v10; --v10 )
      {
        v26 = v2[2];
        v27 = *(_QWORD *)(v26 - 8);
        v2[2] = v26 - 8;
        v91 = v27;
        result = (unsigned __int64 *)sub_2D6CAC4(v2, &v91);
      }
    }
    else
    {
      v14 = v3 == v4;
      if ( v13 >> 2 >= v11 + v12 )
        v15 = v13 >> 2;
      else
        v15 = v11 + v12;
      v95 = result + 3;
      if ( v15 )
      {
        if ( v15 >> 61 )
          sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v16 = (char *)sub_65ECAAC();
      }
      else
      {
        v16 = 0LL;
      }
      v28 = &v16[8 * v15];
      v29 = (v8 << 12) - v14;
      v91 = (unsigned __int64)v16;
      v92 = v16;
      v93 = v16;
      v94 = v28;
      do
      {
        v90 = sub_65ECAAC();
        sub_2D6B2B0(&v91, &v90);
        --v11;
      }
      while ( v11 );
      v30 = (__int64 *)v2[2];
      if ( v10 )
      {
        v31 = v93;
        do
        {
          if ( v31 == v94 )
          {
            v32 = v91;
            v33 = v92;
            if ( (unsigned __int64)v92 <= v91 )
            {
              if ( v31 == (char *)v91 )
                v40 = 1LL;
              else
                v40 = (__int64)&v31[-v91] >> 2;
              if ( v40 >> 61 )
                sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
              v41 = sub_65ECAAC();
              v42 = v40 >> 2;
              v44 = v31 - v33;
              v43 = v31 == v33;
              v45 = (char *)(v41 + 8 * (v40 >> 2));
              v31 = v45;
              if ( !v43 )
              {
                v31 = &v45[v44 & 0xFFFFFFFFFFFFFFF8LL];
                v46 = v44 - 8;
                if ( (unsigned __int64)(v44 - 8) < 0x18 )
                {
                  v47 = (char *)(v41 + 8 * (v40 >> 2));
                  goto LABEL_64;
                }
                if ( v41 + 8 * v42 < (unsigned __int64)&v33[(v46 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
                {
                  v47 = (char *)(v41 + 8 * (v40 >> 2));
                  if ( v41 + 8 * v42 + (v46 & 0xFFFFFFFFFFFFFFF8LL) + 8 > (unsigned __int64)v33 )
                    goto LABEL_105;
                }
                v48 = (v46 >> 3) + 1;
                v49 = (__int128 *)(v33 + 16);
                v50 = (_OWORD *)(v41 + 8 * v42 + 16);
                v51 = 8 * (v48 & 0x3FFFFFFFFFFFFFFCLL);
                v52 = v48 & 0x3FFFFFFFFFFFFFFCLL;
                v47 = &v45[v51];
                v53 = &v33[v51];
                do
                {
                  v54 = *(v49 - 1);
                  v55 = *v49;
                  v49 += 2;
                  v52 -= 4LL;
                  *(v50 - 1) = v54;
                  *v50 = v55;
                  v50 += 2;
                }
                while ( v52 );
                v33 = v53;
                if ( v48 != (v48 & 0x3FFFFFFFFFFFFFFCLL) )
                {
LABEL_105:
                  do
                  {
LABEL_64:
                    v56 = *(_QWORD *)v33;
                    v33 += 8;
                    *(_QWORD *)v47 = v56;
                    v47 += 8;
                  }
                  while ( v47 != v31 );
                }
              }
              v91 = v41;
              v92 = (char *)(v41 + 8 * (v40 >> 2));
              v93 = v31;
              v94 = (char *)(v41 + 8 * v40);
              if ( v32 )
              {
                sub_65ECAF4();
                v31 = v93;
              }
              goto LABEL_44;
            }
            v34 = (__int64)&v92[-v91] >> 3;
            if ( v34 + 1 >= 0 )
              v35 = v34 + 1;
            else
              v35 = v34 + 2;
            v36 = v31 - v92;
            v37 = v35 >> 1;
            v38 = -v37;
            v39 = &v92[-8 * v37];
            if ( v36 )
            {
              memmove(&v92[-8 * v37], v92, v36);
              v33 = v92;
            }
            v31 = &v39[v36];
            v92 = &v33[8 * v38];
            v93 = v31;
          }
LABEL_44:
          --v10;
          *(_QWORD *)v31 = *(v30 - 1);
          v31 = v93 + 8;
          v30 = (__int64 *)(v2[2] - 8);
          v93 += 8;
          v2[2] = (unsigned __int64)v30;
        }
        while ( v10 );
      }
      v57 = v93;
      if ( (__int64 *)v2[1] != v30 )
      {
        v30 = (__int64 *)v2[1];
        while ( 1 )
        {
          if ( v57 == v94 )
          {
            v60 = v91;
            v61 = v92;
            if ( (unsigned __int64)v92 <= v91 )
            {
              if ( v57 == (char *)v91 )
                v68 = 1LL;
              else
                v68 = (__int64)&v57[-v91] >> 2;
              if ( v68 >> 61 )
                sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
              v69 = sub_65ECAAC();
              v70 = v68 >> 2;
              v71 = v57 - v61;
              v43 = v57 == v61;
              v72 = (char *)(v69 + 8 * (v68 >> 2));
              v57 = v72;
              if ( !v43 )
              {
                v57 = &v72[v71 & 0xFFFFFFFFFFFFFFF8LL];
                v73 = v71 - 8;
                if ( (unsigned __int64)(v71 - 8) < 0x18 )
                {
                  v74 = (char *)(v69 + 8 * (v68 >> 2));
                  goto LABEL_90;
                }
                if ( v69 + 8 * v70 < (unsigned __int64)&v61[(v73 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
                {
                  v74 = (char *)(v69 + 8 * (v68 >> 2));
                  if ( v69 + 8 * v70 + (v73 & 0xFFFFFFFFFFFFFFF8LL) + 8 > (unsigned __int64)v61 )
                    goto LABEL_106;
                }
                v75 = (v73 >> 3) + 1;
                v76 = (__int128 *)(v61 + 16);
                v77 = (_OWORD *)(v69 + 8 * v70 + 16);
                v78 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
                v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
                v74 = &v72[v78];
                v80 = &v61[v78];
                do
                {
                  v81 = *(v76 - 1);
                  v82 = *v76;
                  v76 += 2;
                  v79 -= 4LL;
                  *(v77 - 1) = v81;
                  *v77 = v82;
                  v77 += 2;
                }
                while ( v79 );
                v61 = v80;
                if ( v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL) )
                {
LABEL_106:
                  do
                  {
LABEL_90:
                    v83 = *(_QWORD *)v61;
                    v61 += 8;
                    *(_QWORD *)v74 = v83;
                    v74 += 8;
                  }
                  while ( v74 != v57 );
                }
              }
              v91 = v69;
              v92 = (char *)(v69 + 8 * (v68 >> 2));
              v93 = v57;
              v94 = (char *)(v69 + 8 * v68);
              if ( v60 )
              {
                sub_65ECAF4();
                v57 = v93;
              }
              goto LABEL_70;
            }
            v62 = (__int64)&v92[-v91] >> 3;
            if ( v62 + 1 >= 0 )
              v63 = v62 + 1;
            else
              v63 = v62 + 2;
            v64 = v57 - v92;
            v65 = v63 >> 1;
            v66 = -v65;
            v67 = &v92[-8 * v65];
            if ( v64 )
            {
              memmove(&v92[-8 * v65], v92, v64);
              v61 = v92;
            }
            v57 = &v67[v64];
            v92 = &v61[8 * v66];
            v93 = v57;
          }
LABEL_70:
          v58 = *v30++;
          *(_QWORD *)v57 = v58;
          v59 = (__int64 *)v2[2];
          v57 = v93 + 8;
          v93 += 8;
          if ( v30 == v59 )
          {
            v84 = (char *)v2[1];
            goto LABEL_95;
          }
        }
      }
      v84 = (char *)v30;
LABEL_95:
      v85 = v92;
      result = (unsigned __int64 *)*v2;
      v86 = v94;
      *v2 = v91;
      v2[1] = (unsigned __int64)v85;
      v87 = (char *)v2[3];
      v88 = v2[4];
      v91 = (unsigned __int64)result;
      v92 = v84;
      v89 = (char *)v30 - v84;
      v2[2] = (unsigned __int64)v57;
      v2[3] = (unsigned __int64)v86;
      v93 = (char *)v30;
      v94 = v87;
      v2[4] = v29 + v88;
      if ( v89 )
        v93 = (char *)&v30[~((unsigned __int64)(v89 - 8) >> 3)];
      if ( result )
        return (unsigned __int64 *)sub_65ECAF4();
    }
  }
  return result;
}


================================================================================
Function: sub_2D6C338 (0x2D6C338)
================================================================================

_QWORD *__fastcall sub_2D6C338(_QWORD *a1, char *a2, char *a3, char *a4, _QWORD *a5, char *dest)
{
  char *v8; // x22
  _QWORD *v9; // x20
  __int64 v10; // x23
  unsigned __int64 v11; // x9
  __int64 v12; // x8
  __int64 v13; // x8
  __int64 v14; // x25
  __int64 v15; // x26
  char *v16; // x1
  unsigned __int64 v17; // x9
  __int64 v18; // x8
  __int64 v19; // x8
  char *v20; // x27
  __int64 v21; // x28

  if ( a4 != a2 )
  {
    v8 = a2;
    v9 = a1;
    v10 = &a4[512 * (a3 - (char *)a1)] - &a2[*(_QWORD *)a3] + *a1;
    if ( v10 >= 1 )
    {
      do
      {
        v13 = *v9 + 4096LL;
        if ( v13 - (__int64)v8 <= v10 )
          v14 = v13 - (_QWORD)v8;
        else
          v14 = v10;
        if ( v13 - (__int64)v8 <= v10 )
          v15 = *v9 + 4096LL;
        else
          v15 = (__int64)&v8[v10];
        if ( v8 != (char *)v15 )
        {
          v16 = v8;
          do
          {
            v19 = *a5 - (_QWORD)dest + 4096LL;
            if ( v15 - (__int64)v16 <= v19 )
              v20 = (char *)v15;
            else
              v20 = &v16[v19];
            if ( v15 - (__int64)v16 <= v19 )
              v21 = v15 - (_QWORD)v16;
            else
              v21 = *a5 - (_QWORD)dest + 4096LL;
            if ( v20 != v16 )
              memmove(dest, v16, v20 - v16);
            if ( v21 )
            {
              v18 = (__int64)&dest[v21 - *a5];
              if ( v18 < 1 )
              {
                v18 = 4095 - v18;
                v17 = (unsigned __int64)v18 >> 9;
                LOWORD(v18) = ~(_WORD)v18;
                a5 = (_QWORD *)((char *)a5 - (v17 & 0x7FFFFFFFFFFFF8LL));
              }
              else
              {
                a5 = (_QWORD *)((char *)a5 + (((unsigned __int64)v18 >> 9) & 0x7FFFFFFFFFFFF8LL));
              }
              dest = (char *)(*a5 + (v18 & 0xFFF));
            }
            v16 = v20;
          }
          while ( v20 != (char *)v15 );
        }
        v10 -= v14;
        if ( v14 )
        {
          v12 = (__int64)&v8[v14 - *v9];
          if ( v12 < 1 )
          {
            v12 = 4095 - v12;
            v11 = (unsigned __int64)v12 >> 9;
            LOWORD(v12) = ~(_WORD)v12;
            v9 = (_QWORD *)((char *)v9 - (v11 & 0x7FFFFFFFFFFFF8LL));
          }
          else
          {
            v9 = (_QWORD *)((char *)v9 + (((unsigned __int64)v12 >> 9) & 0x7FFFFFFFFFFFF8LL));
          }
          v8 = (char *)(*v9 + (v12 & 0xFFF));
        }
      }
      while ( v10 > 0 );
    }
  }
  return a5;
}


================================================================================
Function: sub_2D6C4C0 (0x2D6C4C0)
================================================================================

unsigned __int64 *__fastcall sub_2D6C4C0(unsigned __int64 *result, unsigned __int64 a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 *v3; // x8
  unsigned __int64 *v4; // x9
  unsigned __int64 v5; // x11
  __int64 v6; // x10
  unsigned __int64 v7; // x12
  unsigned __int64 v8; // x12
  unsigned __int64 v9; // x24
  unsigned __int64 v10; // x20
  unsigned __int64 *v11; // x9
  __int64 v12; // x21
  __int64 v13; // x11
  unsigned __int64 v14; // x22
  __int64 v15; // x0
  unsigned __int64 v16; // x8
  unsigned __int64 v17; // x20
  unsigned __int64 *v18; // x8
  unsigned __int64 v19; // t1
  unsigned __int64 v21; // x22
  __int64 v22; // x8
  __int64 v23; // x8
  __int64 v24; // x25
  _QWORD *v25; // x26
  char *v26; // x22
  unsigned __int64 v27; // x20
  char *v28; // x21
  __int64 v29; // x8
  __int64 v30; // x8
  size_t v31; // x22
  __int64 v32; // x8
  __int64 v33; // x27
  __int64 v34; // x20
  unsigned __int64 v35; // x27
  __int64 v36; // x0
  unsigned __int64 v37; // x10
  bool v38; // zf
  signed __int64 v39; // x9
  char *v40; // x8
  unsigned __int64 v41; // x11
  char *v42; // x9
  __int64 v43; // x11
  __int128 *v44; // x14
  _OWORD *v45; // x10
  __int64 v46; // x13
  __int64 v47; // x15
  char *v48; // x13
  __int128 v49; // q0
  __int128 v50; // q1
  __int64 v51; // t1
  unsigned __int64 v52; // x20
  unsigned __int64 v53; // x21
  unsigned __int64 v54; // x10
  __int128 v55; // q0
  unsigned __int64 v56; // x8
  char *v57; // x9
  char *v58; // x11
  unsigned __int64 *v59; // x8
  unsigned __int64 v60; // t1
  __int64 v61; // [xsp+8h] [xbp-38h] BYREF
  unsigned __int64 v62; // [xsp+10h] [xbp-30h] BYREF
  __int128 v63; // [xsp+18h] [xbp-28h]
  char *v64; // [xsp+28h] [xbp-18h]
  _QWORD *v65; // [xsp+30h] [xbp-10h]

  v2 = result;
  v4 = (unsigned __int64 *)result[1];
  v3 = (unsigned __int64 *)result[2];
  v5 = result[4];
  v6 = (char *)v3 - (char *)v4;
  if ( v3 == v4 )
    v7 = a2 + 1;
  else
    v7 = a2;
  if ( (v7 & 0xFFF) != 0 )
    v8 = (v7 >> 12) + 1;
  else
    v8 = v7 >> 12;
  if ( v8 >= v5 >> 12 )
    v9 = v5 >> 12;
  else
    v9 = v8;
  v10 = v8 - v9;
  if ( v8 == v9 )
  {
    result[4] = v5 - (v9 << 12);
    if ( v9 )
    {
      v16 = *v4;
      result[1] = (unsigned __int64)(v4 + 1);
      v62 = v16;
      result = (unsigned __int64 *)sub_2D6AD80(result, &v62);
      if ( v9 != 1 )
      {
        v17 = 1 - v9;
        do
        {
          v18 = (unsigned __int64 *)v2[1];
          v19 = *v18;
          v2[1] = (unsigned __int64)(v18 + 1);
          v62 = v19;
          result = (unsigned __int64 *)sub_2D6AD80(v2, &v62);
        }
        while ( !__CFADD__(v17++, 1LL) );
      }
    }
  }
  else
  {
    v11 = (unsigned __int64 *)result[3];
    v12 = v6 >> 3;
    v13 = (__int64)v11 - *result;
    if ( v10 <= (v13 >> 3) - (v6 >> 3) )
    {
      if ( v11 == v3 )
      {
LABEL_27:
        v21 = v10;
        do
        {
          v62 = sub_65ECAAC();
          result = (unsigned __int64 *)sub_2D6B0F0(v2, &v62);
          --v21;
          if ( v2[2] - v2[1] == 8 )
            v22 = 4095LL;
          else
            v22 = 4096LL;
          v23 = v22 + v2[4];
          v2[4] = v23;
        }
        while ( v21 );
        v9 += v10;
      }
      else
      {
        while ( 1 )
        {
          v62 = sub_65ECAAC();
          result = (unsigned __int64 *)sub_2D6AF38(v2, &v62);
          if ( !--v10 )
            break;
          if ( v2[3] == v2[2] )
            goto LABEL_27;
        }
        v23 = v2[4];
      }
      for ( v2[4] = v23 - (v9 << 12); v9; --v9 )
      {
        v59 = (unsigned __int64 *)v2[1];
        v60 = *v59;
        v2[1] = (unsigned __int64)(v59 + 1);
        v62 = v60;
        result = (unsigned __int64 *)sub_2D6AD80(v2, &v62);
      }
    }
    else
    {
      if ( v13 >> 2 >= v10 + v12 )
        v14 = v13 >> 2;
      else
        v14 = v10 + v12;
      v65 = result + 3;
      if ( v14 )
      {
        if ( v14 >> 61 )
          sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v15 = sub_65ECAAC();
      }
      else
      {
        v15 = 0LL;
      }
      v24 = -4096LL * v9;
      v62 = v15;
      *(_QWORD *)&v63 = v15 + 8 * (v12 - v9);
      *((_QWORD *)&v63 + 1) = v63;
      v64 = (char *)(v15 + 8 * v14);
      do
      {
        v61 = sub_65ECAAC();
        sub_2D6B2B0(&v62, &v61);
        --v10;
      }
      while ( v10 );
      if ( v9 )
      {
        v25 = (_QWORD *)v2[1];
        v26 = (char *)*((_QWORD *)&v63 + 1);
        do
        {
          if ( v26 == v64 )
          {
            v27 = v62;
            v28 = (char *)v63;
            if ( (unsigned __int64)v63 <= v62 )
            {
              if ( v26 == (char *)v62 )
                v35 = 1LL;
              else
                v35 = (__int64)&v26[-v62] >> 2;
              if ( v35 >> 61 )
                sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
              v36 = sub_65ECAAC();
              v37 = v35 >> 2;
              v39 = v26 - v28;
              v38 = v26 == v28;
              v40 = (char *)(v36 + 8 * (v35 >> 2));
              v26 = v40;
              if ( !v38 )
              {
                v26 = &v40[v39 & 0xFFFFFFFFFFFFFFF8LL];
                v41 = v39 - 8;
                if ( (unsigned __int64)(v39 - 8) < 0x18 )
                {
                  v42 = (char *)(v36 + 8 * (v35 >> 2));
                  goto LABEL_59;
                }
                if ( v36 + 8 * v37 < (unsigned __int64)&v28[(v41 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
                {
                  v42 = (char *)(v36 + 8 * (v35 >> 2));
                  if ( v36 + 8 * v37 + (v41 & 0xFFFFFFFFFFFFFFF8LL) + 8 > (unsigned __int64)v28 )
                    goto LABEL_77;
                }
                v43 = (v41 >> 3) + 1;
                v44 = (__int128 *)(v28 + 16);
                v45 = (_OWORD *)(v36 + 8 * v37 + 16);
                v46 = 8 * (v43 & 0x3FFFFFFFFFFFFFFCLL);
                v47 = v43 & 0x3FFFFFFFFFFFFFFCLL;
                v42 = &v40[v46];
                v48 = &v28[v46];
                do
                {
                  v49 = *(v44 - 1);
                  v50 = *v44;
                  v44 += 2;
                  v47 -= 4LL;
                  *(v45 - 1) = v49;
                  *v45 = v50;
                  v45 += 2;
                }
                while ( v47 );
                v28 = v48;
                if ( v43 != (v43 & 0x3FFFFFFFFFFFFFFCLL) )
                {
LABEL_77:
                  do
                  {
LABEL_59:
                    v51 = *(_QWORD *)v28;
                    v28 += 8;
                    *(_QWORD *)v42 = v51;
                    v42 += 8;
                  }
                  while ( v42 != v26 );
                }
              }
              v62 = v36;
              *(_QWORD *)&v63 = v36 + 8 * (v35 >> 2);
              *((_QWORD *)&v63 + 1) = v26;
              v64 = (char *)(v36 + 8 * v35);
              if ( v27 )
              {
                sub_65ECAF4();
                v26 = (char *)*((_QWORD *)&v63 + 1);
              }
              goto LABEL_39;
            }
            v29 = (__int64)(v63 - v62) >> 3;
            if ( v29 + 1 >= 0 )
              v30 = v29 + 1;
            else
              v30 = v29 + 2;
            v31 = (size_t)&v26[-v63];
            v32 = v30 >> 1;
            v33 = -v32;
            v34 = v63 - 8 * v32;
            if ( v31 )
            {
              memmove((void *)(v63 - 8 * v32), (const void *)v63, v31);
              v28 = (char *)v63;
            }
            v26 = (char *)(v34 + v31);
            *(_QWORD *)&v63 = &v28[8 * v33];
            *((_QWORD *)&v63 + 1) = v26;
          }
LABEL_39:
          --v9;
          *(_QWORD *)v26 = *v25;
          v26 = (char *)(*((_QWORD *)&v63 + 1) + 8LL);
          v25 = (_QWORD *)(v2[1] + 8);
          *((_QWORD *)&v63 + 1) += 8LL;
          v2[1] = (unsigned __int64)v25;
        }
        while ( v9 );
      }
      v52 = v2[2];
      v53 = v52 + 8;
      while ( v52 != v2[1] )
      {
        v52 -= 8LL;
        v53 -= 8LL;
        sub_2D6B468(&v62, v52);
      }
      v54 = v2[4];
      result = (unsigned __int64 *)*v2;
      *v2 = v62;
      v55 = v63;
      v56 = v2[2];
      v57 = (char *)v2[3];
      v62 = (unsigned __int64)result;
      *(_QWORD *)&v63 = v52;
      v58 = v64;
      *(_OWORD *)(v2 + 1) = v55;
      *((_QWORD *)&v63 + 1) = v56;
      v64 = v57;
      v2[3] = (unsigned __int64)v58;
      v2[4] = v54 + v24;
      if ( v52 != v56 )
        *((_QWORD *)&v63 + 1) = v56 + 8 * ~((v56 - v53) >> 3);
      if ( result )
        return (unsigned __int64 *)sub_65ECAF4();
    }
  }
  return result;
}


================================================================================
Function: sub_2D6C9AC (0x2D6C9AC)
================================================================================

_QWORD *__fastcall sub_2D6C9AC(char *a1, char *a2, _QWORD *a3, __int64 a4)
{
  char *v6; // x22
  unsigned __int64 v8; // x9
  __int64 v9; // x8
  char *v10; // x8
  __int64 v11; // x10
  __int64 v12; // x9
  unsigned __int64 v13; // x9
  __int64 v14; // x10
  __int64 v15; // x9
  __int64 v16; // x24

  if ( a2 != a1 )
  {
    v6 = a2;
    do
    {
      v10 = v6;
      v11 = ~*a3 + a4;
      if ( v11 < 1 )
      {
        v11 = 4095 - v11;
        v13 = (unsigned __int64)v11 >> 9;
        LOWORD(v11) = ~(_WORD)v11;
        v12 = *(_QWORD *)((char *)a3 - (v13 & 0x7FFFFFFFFFFFF8LL));
      }
      else
      {
        v12 = *(_QWORD *)((char *)a3 + (((unsigned __int64)v11 >> 9) & 0x7FFFFFFFFFFFF8LL));
      }
      v14 = v12 + (v11 & 0xFFF) + 1;
      v15 = v14 - v12;
      if ( v6 - a1 <= v15 )
        v6 = a1;
      else
        v6 -= v15;
      if ( v10 - a1 <= v15 )
        v16 = v10 - a1;
      else
        v16 = v15;
      if ( v10 != v6 )
        memmove((void *)(v14 - (v10 - v6)), v6, v10 - v6);
      if ( v16 )
      {
        v9 = a4 - (v16 + *a3);
        if ( v9 < 1 )
        {
          v9 = 4095 - v9;
          v8 = (unsigned __int64)v9 >> 9;
          LOWORD(v9) = ~(_WORD)v9;
          a3 = (_QWORD *)((char *)a3 - (v8 & 0x7FFFFFFFFFFFF8LL));
        }
        else
        {
          a3 = (_QWORD *)((char *)a3 + (((unsigned __int64)v9 >> 9) & 0x7FFFFFFFFFFFF8LL));
        }
        a4 = *a3 + (v9 & 0xFFF);
      }
    }
    while ( v6 != a1 );
  }
  return a3;
}


================================================================================
Function: sub_2D6CAC4 (0x2D6CAC4)
================================================================================

__int64 __fastcall sub_2D6CAC4(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_65ECAAC();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_65ECAF4();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_2D6CC84 (0x2D6CC84)
================================================================================

_QWORD *__fastcall sub_2D6CC84(char *a1, char *a2, _QWORD *a3, __int64 a4)
{
  char *v6; // x22
  unsigned __int64 v8; // x9
  __int64 v9; // x8
  char *v10; // x8
  __int64 v11; // x10
  __int64 v12; // x9
  unsigned __int64 v13; // x9
  __int64 v14; // x10
  __int64 v15; // x9
  __int64 v16; // x24

  if ( a2 != a1 )
  {
    v6 = a2;
    do
    {
      v10 = v6;
      v11 = ~*a3 + a4;
      if ( v11 < 1 )
      {
        v11 = 4095 - v11;
        v13 = (unsigned __int64)v11 >> 9;
        LOWORD(v11) = ~(_WORD)v11;
        v12 = *(_QWORD *)((char *)a3 - (v13 & 0x7FFFFFFFFFFFF8LL));
      }
      else
      {
        v12 = *(_QWORD *)((char *)a3 + (((unsigned __int64)v11 >> 9) & 0x7FFFFFFFFFFFF8LL));
      }
      v14 = v12 + (v11 & 0xFFF) + 1;
      v15 = v14 - v12;
      if ( v6 - a1 <= v15 )
        v6 = a1;
      else
        v6 -= v15;
      if ( v10 - a1 <= v15 )
        v16 = v10 - a1;
      else
        v16 = v15;
      if ( v10 != v6 )
        memmove((void *)(v14 - (v10 - v6)), v6, v10 - v6);
      if ( v16 )
      {
        v9 = a4 - (v16 + *a3);
        if ( v9 < 1 )
        {
          v9 = 4095 - v9;
          v8 = (unsigned __int64)v9 >> 9;
          LOWORD(v9) = ~(_WORD)v9;
          a3 = (_QWORD *)((char *)a3 - (v8 & 0x7FFFFFFFFFFFF8LL));
        }
        else
        {
          a3 = (_QWORD *)((char *)a3 + (((unsigned __int64)v9 >> 9) & 0x7FFFFFFFFFFFF8LL));
        }
        a4 = *a3 + (v9 & 0xFFF);
      }
    }
    while ( v6 != a1 );
  }
  return a3;
}


================================================================================
Function: sub_2D6CD9C (0x2D6CD9C)
================================================================================

__int64 __fastcall sub_2D6CD9C(__int64 a1, __int64 a2, _QWORD *a3, char *a4, char *a5, char *a6)
{
  char *v9; // x23
  _QWORD *v10; // x22
  unsigned __int64 v11; // x26
  char *v12; // x0
  unsigned int v13; // w8
  char v14; // t1
  char *v15; // t1
  bool v16; // zf
  unsigned __int64 v17; // x8
  char *v18; // x2
  __int64 v19; // x19
  unsigned __int64 v21; // [xsp+0h] [xbp-20h] BYREF
  unsigned __int64 v22; // [xsp+8h] [xbp-18h]
  char *v23; // [xsp+10h] [xbp-10h]

  if ( a6 == a4 )
  {
    v13 = 0;
    v12 = (char *)&v21 + 1;
    LOBYTE(v21) = 0;
  }
  else
  {
    v9 = a4;
    v10 = a3;
    v11 = &a6[512 * (a5 - (char *)a3)] - &a4[*(_QWORD *)a5] + *a3;
    if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_6849630();
    if ( v11 >= 0x17 )
    {
      v12 = (char *)sub_65ECAAC();
      v22 = v11;
      v23 = v12;
      v21 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v12 = (char *)&v21 + 1;
      LOBYTE(v21) = 2 * ((_BYTE)a6 - ((_BYTE)a4 + *a5) + *(_BYTE *)a3);
    }
    do
    {
      v14 = *v9++;
      *v12 = v14;
      if ( &v9[-*v10] == (char *)&qword_1000 )
      {
        v15 = (char *)v10[1];
        ++v10;
        v9 = v15;
      }
      ++v12;
    }
    while ( v9 != a6 );
    v13 = (unsigned __int8)v21;
  }
  *v12 = 0;
  v16 = (v13 & 1) == 0;
  v17 = v13 >> 1;
  if ( v16 )
  {
    v18 = (char *)&v21 + 1;
  }
  else
  {
    v17 = v22;
    v18 = v23;
  }
  v19 = sub_2D6CF24(a1, a2, v18, &v18[v17]);
  if ( (v21 & 1) != 0 )
    sub_65ECAF4();
  return v19;
}


================================================================================
Function: sub_2D6CF24 (0x2D6CF24)
================================================================================

unsigned __int64 __fastcall sub_2D6CF24(_QWORD *a1, __int64 a2, char *a3, char *a4)
{
  unsigned int v5; // w10
  char *v6; // x9
  int v7; // w8
  char *v8; // x28
  size_t v9; // x23
  size_t v10; // x21
  __int64 v11; // x10
  unsigned __int64 v12; // x20
  __int64 v15; // x25
  _BOOL4 v16; // w27
  char *v17; // x21
  unsigned __int64 v18; // x1
  char *v19; // x9
  size_t v20; // x8
  char *v21; // x8
  char *v22; // x10
  unsigned __int64 v23; // x8
  char *v24; // x2
  unsigned __int64 v25; // x11
  __int128 *v26; // x10
  char *v27; // x12
  unsigned __int64 v28; // x13
  __int128 v29; // q0
  __int128 v30; // q1
  char *v31; // x13
  char *v32; // x9
  unsigned __int64 v33; // x11
  __int64 v34; // t1
  char v35; // t1
  char *v36; // x8
  unsigned __int64 v38; // [xsp+0h] [xbp-20h] BYREF
  size_t v39; // [xsp+8h] [xbp-18h]
  char *v40; // [xsp+10h] [xbp-10h]

  v5 = *(unsigned __int8 *)a1;
  v6 = (char *)a1[2];
  v7 = v5 & 1;
  if ( (v5 & 1) != 0 )
    v8 = (char *)a1[2];
  else
    v8 = (char *)a1 + 1;
  v9 = a4 - a3;
  v10 = a2 - (_QWORD)v8;
  if ( a4 == a3 )
  {
LABEL_53:
    if ( v7 )
      v36 = v6;
    else
      v36 = (char *)a1 + 1;
    return (unsigned __int64)&v36[v10];
  }
  v11 = v5 >> 1;
  v12 = (unsigned __int64)a4;
  if ( v7 )
    v15 = a1[1];
  else
    v15 = v11;
  v16 = v8 <= a3 && &v8[v15] > a3;
  if ( !v16 )
  {
    if ( v7 )
      v18 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    else
      v18 = 22LL;
    if ( v18 - v15 >= v9 )
    {
      if ( v15 != v10 )
        memmove(&v8[v10 + v9], &v8[v10], v15 - v10);
      v19 = v8;
    }
    else
    {
      sub_68499C0((__int64)a1, v18, v15 + v9 - v18, v15, v10, 0LL, v9);
      v19 = (char *)a1[2];
    }
    v20 = v15 + v9;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v20;
    else
      *(_BYTE *)a1 = 2 * v20;
    v19[v20] = 0;
    if ( a3 == (char *)v12 )
    {
LABEL_52:
      v6 = (char *)a1[2];
      v7 = *(_BYTE *)a1 & 1;
      goto LABEL_53;
    }
    v21 = &v19[v10];
    if ( v9 < 8 )
    {
      v22 = a3;
      goto LABEL_50;
    }
    if ( (unsigned __int64)v21 < v12 && &v19[v12 + a2 - (unsigned __int64)&v8[(_QWORD)a3]] > a3 )
    {
      v22 = a3;
      goto LABEL_50;
    }
    if ( v9 >= 0x20 )
    {
      v25 = v9 & 0xFFFFFFFFFFFFFFE0LL;
      v26 = (__int128 *)(a3 + 16);
      v27 = &v19[v10 + 16];
      v28 = v9 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v29 = *(v26 - 1);
        v30 = *v26;
        v26 += 2;
        v28 -= 32LL;
        *((_OWORD *)v27 - 1) = v29;
        *(_OWORD *)v27 = v30;
        v27 += 32;
      }
      while ( v28 );
      if ( v9 == v25 )
        goto LABEL_51;
      if ( (v9 & 0x18) == 0 )
      {
        v22 = &a3[v25];
        v21 += v25;
        do
        {
LABEL_50:
          v35 = *v22++;
          *v21++ = v35;
        }
        while ( v22 != (char *)v12 );
        goto LABEL_51;
      }
    }
    else
    {
      v25 = 0LL;
    }
    v21 += v9 & 0xFFFFFFFFFFFFFFF8LL;
    v22 = &a3[v9 & 0xFFFFFFFFFFFFFFF8LL];
    v31 = &a3[v25];
    v32 = &v19[v25 + a2 - (_QWORD)v8];
    v33 = v25 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
    do
    {
      v34 = *(_QWORD *)v31;
      v31 += 8;
      v33 += 8LL;
      *(_QWORD *)v32 = v34;
      v32 += 8;
    }
    while ( v33 );
    if ( v9 != (v9 & 0xFFFFFFFFFFFFFFF8LL) )
      goto LABEL_50;
LABEL_51:
    if ( v16 )
      return v12;
    goto LABEL_52;
  }
  if ( v9 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( v9 <= 0x16 )
  {
    v17 = (char *)&v38 + 1;
    LOBYTE(v38) = 2 * v9;
    if ( a3 == a4 )
      goto LABEL_29;
    goto LABEL_28;
  }
  v17 = (char *)sub_65ECAAC();
  v39 = v9;
  v40 = v17;
  v38 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  if ( a3 != (char *)v12 )
  {
LABEL_28:
    memcpy(v17, a3, v9);
    v17 += v9;
  }
LABEL_29:
  *v17 = 0;
  v23 = (unsigned __int64)(unsigned __int8)v38 >> 1;
  if ( (v38 & 1) != 0 )
    v24 = v40;
  else
    v24 = (char *)&v38 + 1;
  if ( (v38 & 1) != 0 )
    v23 = v39;
  v12 = sub_2D6CF24(a1, a2, v24, &v24[v23]);
  if ( (v38 & 1) != 0 )
    sub_65ECAF4();
  return v12;
}


================================================================================
Function: sub_2DB0BA0 (0x2DB0BA0)
================================================================================

__int64 __fastcall sub_2DB0BA0(__int64 a1, char *s)
{
  size_t v4; // x0
  size_t v5; // x21
  char *v6; // x22
  unsigned __int64 v7; // x23
  unsigned int v8; // w19
  _QWORD v10[3]; // [xsp+0h] [xbp-20h] BYREF

  v4 = strlen(s);
  if ( v4 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v5 = v4;
  if ( v4 >= 0x17 )
  {
    v7 = (v4 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v6 = (char *)sub_65ECAAC();
    v10[1] = v5;
    v10[2] = v6;
    v10[0] = v7 | 1;
    goto LABEL_6;
  }
  v6 = (char *)v10 + 1;
  LOBYTE(v10[0]) = 2 * v4;
  if ( v4 )
LABEL_6:
    memcpy(v6, s, v5);
  v6[v5] = 0;
  v8 = sub_67DADC8(a1, v10);
  if ( (v10[0] & 1) != 0 )
    sub_65ECAF4();
  return v8;
}


================================================================================
Function: sub_2DB1428 (0x2DB1428)
================================================================================

__int64 __fastcall sub_2DB1428(__int64 *a1, __int64 a2)
{
  __int64 result; // x0
  __int64 v4; // x9
  __int64 v5; // x10
  __int64 v6; // x19
  __int64 v7; // [xsp+8h] [xbp-18h] BYREF
  __int64 v8; // [xsp+10h] [xbp-10h] BYREF

  v7 = a2;
  v8 = 0LL;
  result = sub_2DB183C(&v7, a2, &v8);
  v4 = v8;
  v5 = *a1;
  v6 = a1[1];
  *a1 = v7;
  a1[1] = v4;
  v7 = v5;
  v8 = v6;
  if ( v6 )
  {
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 12));
      if ( (_DWORD)result == 1 )
        return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  return result;
}


================================================================================
Function: sub_2DB183C (0x2DB183C)
================================================================================

_QWORD *__fastcall sub_2DB183C(__int64 a1, __int64 a2, __int64 *a3)
{
  _QWORD *result; // x0
  __int64 v6; // x20

  result = (_QWORD *)sub_65ECAAC();
  v6 = *a3;
  result[2] = a2;
  *a3 = (__int64)result;
  *result = off_68EE7D8;
  result[1] = 0x100000001LL;
  if ( v6 )
  {
    result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 12));
      if ( (_DWORD)result == 1 )
        return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  return result;
}


================================================================================
Function: sub_3098E10 (0x3098E10)
================================================================================

__int64 **__fastcall sub_3098E10(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3, __int128 **a4)
{
  unsigned __int64 v4; // x27
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  bool v10; // zf
  unsigned __int64 v11; // x8
  unsigned __int8 *v12; // x1
  unsigned __int64 v13; // x2
  unsigned __int64 v14; // x0
  unsigned __int64 v15; // x20
  unsigned __int64 v16; // x26
  uint8x8_t v17; // d0
  unsigned __int64 v18; // x28
  __int64 ***v19; // x8
  unsigned __int64 v20; // x10
  unsigned __int8 *v21; // x11
  unsigned __int8 *v22; // x12
  unsigned __int64 v23; // x9
  __int64 **v24; // x22
  size_t v25; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x11
  __int64 *v30; // x0
  __int64 v31; // x9
  __int64 *v32; // x23
  __int64 v33; // x22
  __int128 *v34; // x1
  __int64 v35; // x8
  float v36; // s1
  float v37; // s0
  _BOOL8 v38; // x9
  unsigned __int64 v39; // x10
  unsigned __int64 v40; // x1
  __int64 v41; // x8
  __int64 *v42; // x9
  __int64 v43; // x9
  unsigned __int64 v44; // x9
  _QWORD v46[2]; // [xsp+0h] [xbp-20h] BYREF
  char v47; // [xsp+10h] [xbp-10h]

  v8 = *((_QWORD *)a2 + 1);
  v9 = *a2;
  v10 = (v9 & 1) == 0;
  v11 = v9 >> 1;
  if ( v10 )
    v12 = a2 + 1;
  else
    v12 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  if ( v10 )
    v13 = v11;
  else
    v13 = v8;
  v14 = sub_24FE128(v46, v12, v13);
  v15 = v14;
  v16 = *(_QWORD *)(a1 + 8);
  if ( v16 )
  {
    v17.n64_u64[0] = vcnt_s8((int8x8_t)v16).n64_u64[0];
    v17.n64_u16[0] = vaddlv_u8(v17);
    v18 = v17.n64_u32[0];
    if ( v17.n64_u32[0] > 1uLL )
    {
      v4 = v14;
      if ( v14 >= v16 )
        v4 = v14 % v16;
    }
    else
    {
      v4 = (v16 - 1) & v14;
    }
    v19 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v4);
    if ( v19 )
    {
      v20 = *((_QWORD *)a2 + 1);
      v21 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v22 = a2 + 1;
      v23 = *a2;
      v24 = *v19;
      v25 = (v23 & 1) != 0 ? v20 : v23 >> 1;
      for ( i = (v23 & 1) != 0 ? v21 : v22; v24; v24 = (__int64 **)*v24 )
      {
        v27 = (unsigned __int64)v24[1];
        if ( v27 != v15 )
        {
          if ( v18 > 1 )
          {
            if ( v27 >= v16 )
              v27 %= v16;
          }
          else
          {
            v27 &= v16 - 1;
          }
          if ( v27 != v4 )
            break;
        }
        v28 = *((unsigned __int8 *)v24 + 16);
        v29 = (unsigned __int64)v24[3];
        if ( (v28 & 1) == 0 )
          v29 = v28 >> 1;
        if ( v29 == v25 )
        {
          if ( (v28 & 1) != 0 )
            v30 = v24[4];
          else
            v30 = (__int64 *)((char *)v24 + 17);
          if ( (v28 & 1) != 0 )
          {
            if ( !v25 || !memcmp(v30, i, v25) )
              return v24;
          }
          else
          {
            if ( !v25 )
              return v24;
            v31 = 0LL;
            while ( *((unsigned __int8 *)v24 + v31 + 17) == i[v31] )
            {
              if ( v28 >> 1 == ++v31 )
                return v24;
            }
          }
        }
      }
    }
  }
  v32 = (__int64 *)(a1 + 16);
  v33 = sub_65ECAAC();
  v34 = *a4;
  v47 = 0;
  v46[0] = v33;
  v46[1] = a1 + 16;
  sub_68497A0((unsigned __int64 *)(v33 + 16), v34);
  v35 = *(_QWORD *)(a1 + 24);
  v36 = *(float *)(a1 + 32);
  *(_DWORD *)(v33 + 40) = 0;
  *(_QWORD *)v33 = 0LL;
  *(_QWORD *)(v33 + 8) = v15;
  v47 = 1;
  v37 = (float)(unsigned __int64)(v35 + 1);
  if ( !v16 || (float)(v36 * (float)v16) < v37 )
  {
    v38 = v16 < 3 || (v16 & (v16 - 1)) != 0;
    v39 = vcvtps_u32_f32(v37 / v36);
    if ( (v38 | (2 * v16)) >= v39 )
      v40 = v38 | (2 * v16);
    else
      v40 = v39;
    sub_3099144(a1, v40);
    v16 = *(_QWORD *)(a1 + 8);
    if ( (v16 & (v16 - 1)) != 0 )
    {
      if ( v15 >= v16 )
        v4 = v15 % v16;
      else
        v4 = v15;
    }
    else
    {
      v4 = (v16 - 1) & v15;
    }
  }
  v41 = *(_QWORD *)a1;
  v42 = *(__int64 **)(*(_QWORD *)a1 + 8 * v4);
  if ( v42 )
  {
    *(_QWORD *)v33 = *v42;
    *v42 = v33;
  }
  else
  {
    v43 = *v32;
    *v32 = v33;
    *(_QWORD *)v33 = v43;
    *(_QWORD *)(v41 + 8 * v4) = v32;
    if ( *(_QWORD *)v46[0] )
    {
      v44 = *(_QWORD *)(*(_QWORD *)v46[0] + 8LL);
      if ( (v16 & (v16 - 1)) != 0 )
      {
        if ( v44 >= v16 )
          v44 %= v16;
      }
      else
      {
        v44 &= v16 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v44) = v46[0];
    }
  }
  v24 = (__int64 **)v46[0];
  ++*(_QWORD *)(a1 + 24);
  return v24;
}


================================================================================
Function: sub_3099144 (0x3099144)
================================================================================

unsigned __int64 __fastcall sub_3099144(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x13
  unsigned __int64 v10; // x11
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  __int64 *v13; // x26
  unsigned __int64 v14; // x12
  unsigned __int64 v15; // x27
  __int64 v16; // x8
  unsigned __int64 v17; // x24
  _QWORD *v18; // x28
  size_t v19; // x21
  _QWORD *v20; // x23
  __int64 v21; // x8
  char v22; // w9
  unsigned int v23; // t1
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x11
  unsigned __int8 *v26; // x1
  unsigned __int8 *v27; // x8
  unsigned __int64 v28; // x9
  unsigned __int64 v29; // [xsp+8h] [xbp-48h]
  _QWORD *v30; // [xsp+10h] [xbp-40h]
  unsigned __int64 v31; // [xsp+18h] [xbp-38h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_681B888(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_681B888(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24FD568("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_65ECAAC();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_65ECAF4();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = (__int64 *)*v9;
          if ( *v9 )
          {
            v14 = v3.n64_u64[0] - 1;
            v29 = v11.n64_u32[0];
            do
            {
              v15 = v13[1];
              if ( v12 > 1 )
              {
                if ( v15 >= v3.n64_u64[0] )
                  v15 %= v3.n64_u64[0];
              }
              else
              {
                v15 &= v14;
              }
              if ( v15 == v10 )
              {
                v9 = v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v15) )
              {
                v16 = *v13;
                if ( *v13 )
                {
                  v17 = *((unsigned __int8 *)v13 + 16);
                  v18 = v13;
                  v30 = v9;
                  v31 = v10;
                  if ( (v17 & 1) != 0 )
                    v19 = v13[3];
                  else
                    v19 = v17 >> 1;
                  while ( 1 )
                  {
                    v20 = v18;
                    v18 = (_QWORD *)v16;
                    v23 = *(unsigned __int8 *)(v16 + 16);
                    v21 = v16 + 16;
                    v22 = v23;
                    v24 = *(_QWORD *)(v21 + 8);
                    v25 = (unsigned __int64)v23 >> 1;
                    if ( (v23 & 1) == 0 )
                      v24 = v25;
                    if ( v19 != v24 )
                      break;
                    if ( (v17 & 1) != 0 )
                      result = v13[4];
                    else
                      result = (unsigned __int64)v13 + 17;
                    if ( (v22 & 1) != 0 )
                      v26 = (unsigned __int8 *)v18[4];
                    else
                      v26 = (unsigned __int8 *)(v21 + 1);
                    if ( (v17 & 1) != 0 )
                    {
                      if ( v19 )
                      {
                        result = memcmp((const void *)result, v26, v19);
                        if ( (_DWORD)result )
                          break;
                      }
                    }
                    else
                    {
                      v27 = (unsigned __int8 *)v13 + 17;
                      v28 = v17 >> 1;
                      if ( v19 )
                      {
                        while ( *v27 == *v26 )
                        {
                          --v28;
                          ++v27;
                          ++v26;
                          if ( !v28 )
                            goto LABEL_46;
                        }
                        break;
                      }
                    }
LABEL_46:
                    v16 = *v18;
                    if ( !*v18 )
                    {
                      v20 = v18;
                      v18 = 0LL;
                      break;
                    }
                  }
                  v14 = v3.n64_u64[0] - 1;
                  v12 = v29;
                  v10 = v31;
                  v9 = v30;
                }
                else
                {
                  v18 = 0LL;
                  v20 = v13;
                }
                *v9 = v18;
                *v20 = **(_QWORD **)(v2->n64_u64[0] + 8 * v15);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v15) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v15) = v9;
                v9 = v13;
                v10 = v15;
              }
              v13 = (__int64 *)*v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_65ECAF4();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_3206D5C (0x3206D5C)
================================================================================

__int64 **__fastcall sub_3206D5C(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int64 v3; // x27
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  unsigned __int8 *v11; // x1
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x26
  uint8x8_t v16; // d0
  unsigned __int64 v17; // x28
  __int64 ***v18; // x8
  unsigned __int64 v19; // x10
  unsigned __int8 *v20; // x11
  unsigned __int8 *v21; // x12
  unsigned __int64 v22; // x9
  __int64 **v23; // x22
  size_t v24; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  __int64 *v29; // x0
  __int64 v30; // x9
  __int64 *v31; // x23
  __int64 v32; // x22
  __int64 v33; // x8
  int v34; // w9
  float v35; // s1
  float v36; // s0
  _BOOL8 v37; // x9
  unsigned __int64 v38; // x10
  unsigned __int64 v39; // x1
  __int64 v40; // x8
  __int64 *v41; // x9
  __int64 v42; // x9
  unsigned __int64 v43; // x9
  _QWORD v45[2]; // [xsp+0h] [xbp-20h] BYREF
  char v46; // [xsp+10h] [xbp-10h]

  v7 = *((_QWORD *)a2 + 1);
  v8 = *a2;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v11 = a2 + 1;
  else
    v11 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  if ( v9 )
    v12 = v10;
  else
    v12 = v7;
  v13 = sub_24FE128(v45, v11, v12);
  v14 = v13;
  v15 = *(_QWORD *)(a1 + 8);
  if ( v15 )
  {
    v16.n64_u64[0] = vcnt_s8((int8x8_t)v15).n64_u64[0];
    v16.n64_u16[0] = vaddlv_u8(v16);
    v17 = v16.n64_u32[0];
    if ( v16.n64_u32[0] > 1uLL )
    {
      v3 = v13;
      if ( v13 >= v15 )
        v3 = v13 % v15;
    }
    else
    {
      v3 = (v15 - 1) & v13;
    }
    v18 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v3);
    if ( v18 )
    {
      v19 = *((_QWORD *)a2 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v21 = a2 + 1;
      v22 = *a2;
      v23 = *v18;
      v24 = (v22 & 1) != 0 ? v19 : v22 >> 1;
      for ( i = (v22 & 1) != 0 ? v20 : v21; v23; v23 = (__int64 **)*v23 )
      {
        v26 = (unsigned __int64)v23[1];
        if ( v26 != v14 )
        {
          if ( v17 > 1 )
          {
            if ( v26 >= v15 )
              v26 %= v15;
          }
          else
          {
            v26 &= v15 - 1;
          }
          if ( v26 != v3 )
            break;
        }
        v27 = *((unsigned __int8 *)v23 + 16);
        v28 = (unsigned __int64)v23[3];
        if ( (v27 & 1) == 0 )
          v28 = v27 >> 1;
        if ( v28 == v24 )
        {
          if ( (v27 & 1) != 0 )
            v29 = v23[4];
          else
            v29 = (__int64 *)((char *)v23 + 17);
          if ( (v27 & 1) != 0 )
          {
            if ( !v24 || !memcmp(v29, i, v24) )
              return v23;
          }
          else
          {
            if ( !v24 )
              return v23;
            v30 = 0LL;
            while ( *((unsigned __int8 *)v23 + v30 + 17) == i[v30] )
            {
              if ( v27 >> 1 == ++v30 )
                return v23;
            }
          }
        }
      }
    }
  }
  v31 = (__int64 *)(a1 + 16);
  v32 = sub_65ECAAC();
  v46 = 0;
  v45[0] = v32;
  v45[1] = a1 + 16;
  sub_68497A0(v32 + 16, a3);
  v33 = *(_QWORD *)(a1 + 24);
  v34 = *(_DWORD *)(a3 + 24);
  *(_QWORD *)v32 = 0LL;
  *(_QWORD *)(v32 + 8) = v14;
  v35 = *(float *)(a1 + 32);
  v46 = 1;
  *(_DWORD *)(v32 + 40) = v34;
  v36 = (float)(unsigned __int64)(v33 + 1);
  if ( !v15 || (float)(v35 * (float)v15) < v36 )
  {
    v37 = v15 < 3 || (v15 & (v15 - 1)) != 0;
    v38 = vcvtps_u32_f32(v36 / v35);
    if ( (v37 | (2 * v15)) >= v38 )
      v39 = v37 | (2 * v15);
    else
      v39 = v38;
    sub_3099144(a1, v39);
    v15 = *(_QWORD *)(a1 + 8);
    if ( (v15 & (v15 - 1)) != 0 )
    {
      if ( v14 >= v15 )
        v3 = v14 % v15;
      else
        v3 = v14;
    }
    else
    {
      v3 = (v15 - 1) & v14;
    }
  }
  v40 = *(_QWORD *)a1;
  v41 = *(__int64 **)(*(_QWORD *)a1 + 8 * v3);
  if ( v41 )
  {
    *(_QWORD *)v32 = *v41;
    *v41 = v32;
  }
  else
  {
    v42 = *v31;
    *v31 = v32;
    *(_QWORD *)v32 = v42;
    *(_QWORD *)(v40 + 8 * v3) = v31;
    if ( *(_QWORD *)v45[0] )
    {
      v43 = *(_QWORD *)(*(_QWORD *)v45[0] + 8LL);
      if ( (v15 & (v15 - 1)) != 0 )
      {
        if ( v43 >= v15 )
          v43 %= v15;
      }
      else
      {
        v43 &= v15 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v43) = v45[0];
    }
  }
  v23 = (__int64 **)v45[0];
  ++*(_QWORD *)(a1 + 24);
  return v23;
}


================================================================================
Function: sub_3324E40 (0x3324E40)
================================================================================

__int64 __fastcall sub_3324E40(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_6867450(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65EFD58(0);
  if ( v2 >> 62 != 2 )
  {
    sub_65EF508(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7301220);
      v5 = sub_65FD0A0(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_332513C(v5);
      sub_6867600(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_6848B0C((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_332513C (0x332513C)
================================================================================

__int64 sub_332513C()
{
  __int64 v0; // x19

  v0 = sub_65ED63C(0x88uLL);
  sub_64957EC();
  return v0;
}


================================================================================
Function: sub_3C03FD0 (0x3C03FD0)
================================================================================

__int64 __fastcall sub_3C03FD0(__int64 a1, char a2)
{
  __int64 result; // x0
  __int64 v5; // x19
  __int64 v6; // [xsp+8h] [xbp-18h] BYREF
  __int64 v7; // [xsp+10h] [xbp-10h]

  sub_3C0F158(&v6);
  result = v6;
  if ( v6 )
    result = sub_3C04084(v6, a1, a2 & 1);
  v5 = v7;
  if ( v7 )
  {
    result = sub_68674B0(-1LL, v7 + 8);
    if ( !result )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
      return sub_68488BC(v5);
    }
  }
  return result;
}


================================================================================
Function: sub_3C04084 (0x3C04084)
================================================================================

_BYTE *__fastcall sub_3C04084(_BYTE *result, unsigned __int8 *a2, char a3)
{
  _BYTE *v4; // x20
  unsigned __int64 v6; // x22
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x8
  __int64 v9; // x0
  __int64 v10; // x23
  __int64 v11; // x3
  _QWORD *i; // x21
  __int64 **v13; // x19
  __int64 v14; // x0
  __int64 **v15; // x19
  __int64 *v16; // x20
  __int64 *v17; // x20
  int v18; // [xsp+4h] [xbp-7Ch] BYREF
  _BYTE v19[16]; // [xsp+8h] [xbp-78h] BYREF
  __int128 v20; // [xsp+20h] [xbp-60h] BYREF
  __int128 v21; // [xsp+30h] [xbp-50h]
  int v22; // [xsp+40h] [xbp-40h]
  __int128 v23; // [xsp+50h] [xbp-30h] BYREF
  __int128 v24; // [xsp+60h] [xbp-20h]
  int v25; // [xsp+70h] [xbp-10h]

  if ( !*result )
    return result;
  v4 = result;
  if ( !byte_724A7A8 )
  {
    if ( !(_BYTE)qword_6DE6180 )
      goto LABEL_10;
    goto LABEL_9;
  }
  if ( byte_6FF0A20 )
    return result;
  if ( !byte_724A758 )
  {
    if ( !(_BYTE)qword_6DE6180 )
      goto LABEL_10;
LABEL_9:
    sub_65C5C5C();
    goto LABEL_10;
  }
  if ( (unsigned __int8)qword_6DE6180 >= 6u && BYTE1(qword_6DE6180) >= 3u )
    goto LABEL_9;
LABEL_10:
  v6 = 0LL;
  v23 = 0u;
  v24 = 0u;
  v25 = 1065353216;
  do
  {
    v7 = *a2;
    if ( (v7 & 1) != 0 )
      v8 = *((_QWORD *)a2 + 1);
    else
      v8 = v7 >> 1;
    if ( v6 >= v8 )
      break;
    v9 = sub_6849DAC(a2, 44LL, v6);
    v10 = v9;
    if ( v9 == -1 )
      v11 = -1LL;
    else
      v11 = v9 - v6;
    sub_6849CE0(v19, a2, v6, v11, a2);
    v18 = 1;
    sub_3C11BB0(&v23, v19, v19, &v18);
    if ( (v19[0] & 1) != 0 )
      sub_65ECAF4();
    v6 = v10 + 1;
  }
  while ( v10 != -1 );
  v22 = v25;
  v20 = 0u;
  v21 = 0u;
  sub_3099144(&v20, *((_QWORD *)&v23 + 1));
  for ( i = (_QWORD *)v24; i; i = (_QWORD *)*i )
    sub_3206D5C(&v20, i + 2, i + 2);
  sub_3C0D9FC(v4 + 8, &v20, a3 & 1);
  v13 = (__int64 **)v21;
  if ( (_QWORD)v21 )
  {
    do
    {
      v16 = *v13;
      if ( ((_BYTE)v13[2] & 1) != 0 )
        sub_65ECAF4();
      sub_65ECAF4();
      v13 = (__int64 **)v16;
    }
    while ( v16 );
  }
  v14 = v20;
  *(_QWORD *)&v20 = 0LL;
  if ( v14 )
    sub_65ECAF4();
  v15 = (__int64 **)v24;
  if ( (_QWORD)v24 )
  {
    do
    {
      v17 = *v15;
      if ( ((_BYTE)v15[2] & 1) != 0 )
        sub_65ECAF4();
      sub_65ECAF4();
      v15 = (__int64 **)v17;
    }
    while ( v17 );
  }
  result = (_BYTE *)v23;
  *(_QWORD *)&v23 = 0LL;
  if ( result )
    return (_BYTE *)sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_3C07388 (0x3C07388)
================================================================================

long double __usercall sub_3C07388@<Q0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  __int64 v3; // x20
  __int64 v4; // x20
  __int64 v5; // x21
  long double result; // q0

  if ( byte_724A7A8 )
    v2 = byte_7301120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = sub_65ECAAC();
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_QWORD *)v3 = off_6958D60;
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
    *(_OWORD *)(v3 + 136) = 0u;
    *(_OWORD *)(v3 + 152) = 0u;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 168) = 0u;
    sub_67DE848(v3 + 96);
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(v3 + 176) = 0LL;
    *(_QWORD *)(v3 + 168) = 0LL;
    *(_QWORD *)(v3 + 160) = v3 + 168;
    *a1 = v3 + 24;
    a1[1] = v3;
    *(_OWORD *)(v3 + 128) = 0u;
    *(_OWORD *)(v3 + 144) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
  }
  else
  {
    v4 = sub_680599C();
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 192LL, 8LL);
    *(_QWORD *)(v5 + 16) = 0LL;
    *(_QWORD *)(v5 + 24) = v4;
    *(_QWORD *)v5 = off_6958D10;
    *(_QWORD *)(v5 + 8) = 0LL;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    sub_67DE848(v5 + 104);
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(v5 + 184) = 0LL;
    *(_QWORD *)(v5 + 176) = 0LL;
    *(_QWORD *)(v5 + 168) = v5 + 176;
    *a1 = v5 + 32;
    a1[1] = v5;
    *(_OWORD *)(v5 + 152) = 0u;
    *(_OWORD *)(v5 + 136) = 0u;
    *(_OWORD *)(v5 + 120) = 0u;
  }
  return result;
}


================================================================================
Function: sub_3C07E6C (0x3C07E6C)
================================================================================

_QWORD *__fastcall sub_3C07E6C(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // x22
  __int64 v3; // x23
  __int64 v6; // x21
  __int64 v7; // x21

  v3 = *a2;
  v2 = a2[1];
  if ( v2 )
    sub_6867390(1LL, v2 + 8);
  v6 = a1[1];
  *a1 = v3;
  a1[1] = v2;
  if ( v6 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  v7 = a2[1];
  *a2 = 0LL;
  a2[1] = 0LL;
  if ( v7 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
    }
  }
  return a1;
}


================================================================================
Function: sub_3C0B2A4 (0x3C0B2A4)
================================================================================

__int64 __fastcall sub_3C0B2A4(__int64 result)
{
  __int64 *v1; // x19
  __int64 v2; // x8
  __int64 v3; // x19
  unsigned __int64 *v4; // x19
  __int64 v5; // [xsp+8h] [xbp-28h] BYREF
  __int64 v6; // [xsp+10h] [xbp-20h]
  _BYTE v7[8]; // [xsp+18h] [xbp-18h] BYREF
  __int64 v8; // [xsp+20h] [xbp-10h]

  if ( *(_BYTE *)(*(_QWORD *)result + 40LL) )
    return result;
  v1 = (__int64 *)result;
  result = sub_67DF9F4(*(_QWORD *)result + 48LL);
  if ( result )
    return result;
  if ( byte_724A7A8 && byte_724A758 )
  {
    if ( (unsigned __int8)qword_6DE6180 < 6u || BYTE1(qword_6DE6180) < 3u )
      goto LABEL_11;
    goto LABEL_10;
  }
  if ( (_BYTE)qword_6DE6180 )
LABEL_10:
    sub_65C5818();
LABEL_11:
  v2 = v1[1];
  v5 = *v1;
  v6 = v2;
  if ( v2 )
    sub_6867420(1uLL, (atomic_ullong *)(v2 + 8));
  sub_3C0BF68(v7, sub_3C0B460, &v5, 0LL);
  sub_3C07E6C(*v1 + 48, v7);
  result = sub_67DF254(v7);
  v3 = v8;
  if ( v8 )
  {
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v8 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 16LL))(v3);
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v3 + 12));
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 24LL))(v3);
    }
  }
  v4 = (unsigned __int64 *)v6;
  if ( v6 )
  {
    result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v6 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v4 + 16))(v4);
      return sub_68488BC(v4);
    }
  }
  return result;
}


================================================================================
Function: sub_3C0BF68 (0x3C0BF68)
================================================================================

__int64 __fastcall sub_3C0BF68(__int64 *a1, __int64 a2, __int64 *a3)
{
  __int64 v5; // x8
  __int64 v6; // x24
  __int64 v7; // x21
  __int128 v8; // q0
  __int64 v9; // x9
  __int64 result; // x0
  __int64 v11; // [xsp+8h] [xbp-48h]
  __int128 v12; // [xsp+10h] [xbp-40h] BYREF
  __int64 v13; // [xsp+20h] [xbp-30h]

  v6 = *a3;
  v5 = a3[1];
  v11 = v5;
  if ( v5 )
  {
    sub_6867420(1uLL, (atomic_ullong *)(v5 + 8));
    sub_6867420(1uLL, (atomic_ullong *)(v11 + 8));
    sub_6867420(1uLL, (atomic_ullong *)(v11 + 8));
    sub_6867420(1uLL, (atomic_ullong *)(v11 + 8));
    if ( !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v11 + 8)) )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
      sub_68488BC((unsigned __int64 *)v11);
    }
    *(_QWORD *)&v12 = a2;
    *((_QWORD *)&v12 + 1) = v6;
    v13 = v11;
    sub_6867420(1uLL, (atomic_ullong *)(v11 + 8));
    if ( !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v11 + 8)) )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
      sub_68488BC((unsigned __int64 *)v11);
    }
    if ( !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v11 + 8)) )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
      sub_68488BC((unsigned __int64 *)v11);
    }
  }
  else
  {
    *(_QWORD *)&v12 = a2;
    *((_QWORD *)&v12 + 1) = v6;
    v13 = 0LL;
  }
  v7 = sub_65ECAAC();
  sub_2706758(v7);
  v8 = v12;
  v9 = v13;
  *((_QWORD *)&v12 + 1) = 0LL;
  v13 = 0LL;
  *(_OWORD *)(v7 + 416) = v8;
  *(_QWORD *)v7 = off_6958E50;
  *(_QWORD *)(v7 + 432) = v9;
  *a1 = v7;
  a1[1] = 0LL;
  sub_3C2AE38(a1, v7, a1 + 1);
  if ( v11 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v11 + 8)) )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
    sub_68488BC((unsigned __int64 *)v11);
  }
  result = sub_67DE850(a1);
  if ( (result & 1) == 0 )
  {
    sub_2706CA4(&v12);
    sub_25C1ABC(&v12);
  }
  return result;
}


================================================================================
Function: sub_3C0C238 (0x3C0C238)
================================================================================

__int64 __fastcall sub_3C0C238(__int64 a1, __int64 a2, char a3)
{
  _QWORD *v6; // x8
  __int64 v7; // x19
  __int64 v8; // x25
  __int64 v9; // x9
  _QWORD *v10; // x8
  __int64 **v11; // x20
  __int64 result; // x0
  __int64 v13; // x20
  __int64 *v14; // x21
  char v15; // t1
  _QWORD v16[3]; // [xsp+8h] [xbp-48h] BYREF
  __int128 v17; // [xsp+20h] [xbp-30h] BYREF
  __int128 v18; // [xsp+30h] [xbp-20h]
  int v19; // [xsp+40h] [xbp-10h]

  v6 = *(_QWORD **)a2;
  v17 = 0u;
  v18 = 0u;
  v7 = v6[15];
  v8 = v6[16];
  v6[15] = 0LL;
  v6[16] = 0LL;
  v9 = v6[17];
  v6[17] = 0LL;
  v10 = *(_QWORD **)a2;
  v16[2] = v9;
  v16[0] = v7;
  v16[1] = v8;
  v19 = 1065353216;
  sub_3C2B05C(v10 + 18, &v17);
  *(_QWORD *)(*(_QWORD *)a2 + 64LL) = 0x7FFFFFFFFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 8) )
    sub_684D644(1, "unique_lock::unlock: not locked");
  sub_68489D4(*(pthread_mutex_t **)a1);
  *(_BYTE *)(a1 + 8) = 0;
  sub_3C0C7B0(v16, &v17, a3 & 1);
  v11 = (__int64 **)v18;
  if ( (_QWORD)v18 )
  {
    do
    {
      v14 = *v11;
      if ( ((_BYTE)v11[2] & 1) != 0 )
        sub_65ECAF4();
      sub_65ECAF4();
      v11 = (__int64 **)v14;
    }
    while ( v14 );
  }
  result = v17;
  *(_QWORD *)&v17 = 0LL;
  if ( result )
    result = sub_65ECAF4();
  if ( v7 )
  {
    if ( v8 != v7 )
    {
      v13 = v8;
      do
      {
        v15 = *(_BYTE *)(v13 - 32);
        v13 -= 32LL;
        if ( (v15 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v13 != v7 );
    }
    return sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_3C0C7B0 (0x3C0C7B0)
================================================================================

__int64 __usercall sub_3C0C7B0@<X0>(
        unsigned __int8 **a1@<X0>,
        __int64 a2@<X1>,
        char a3@<W2>,
        __int64 a4@<X5>,
        __int64 a5@<X6>,
        __int64 a6@<X7>,
        _OWORD *a7@<X8>,
        long double a8@<Q0>,
        long double a9@<Q1>,
        long double a10@<Q2>,
        long double a11@<Q3>)
{
  __int64 result; // x0
  __int128 *v16; // x24
  unsigned __int8 *v17; // x19
  unsigned __int8 *v18; // x20
  unsigned __int64 v19; // x8
  bool v20; // zf
  unsigned __int64 v21; // x8
  unsigned __int8 *v22; // x3
  unsigned __int64 v23; // x4
  unsigned __int8 *v24; // x20
  const void *v25; // x23
  unsigned __int64 v26; // x0
  size_t v27; // x24
  char *v28; // x25
  unsigned __int64 v29; // x26
  unsigned __int8 *i; // x22
  unsigned __int8 *v31; // x23
  long double v32; // q0
  unsigned __int8 *v33; // x1
  __int64 v34; // x22
  unsigned __int64 *v35; // x22
  __int64 **v36; // x22
  __int128 v37; // q0
  __int64 **j; // x19
  const void *v39; // x22
  unsigned __int64 v40; // x0
  size_t v41; // x23
  char *v42; // x24
  __int64 *v43; // x19
  unsigned __int64 v44; // x25
  __int64 **k; // x20
  __int64 *v46; // x1
  __int64 v47; // x19
  unsigned __int64 *v48; // x19
  __int64 **v49; // x19
  __int64 *v50; // x20
  __int64 v51; // [xsp+0h] [xbp-270h]
  __int64 v52; // [xsp+10h] [xbp-260h] BYREF
  __int64 v53; // [xsp+18h] [xbp-258h]
  __int64 v54; // [xsp+20h] [xbp-250h] BYREF
  size_t v55; // [xsp+28h] [xbp-248h]
  char *v56; // [xsp+30h] [xbp-240h]
  _QWORD v57[2]; // [xsp+38h] [xbp-238h] BYREF
  char v58; // [xsp+50h] [xbp-220h] BYREF
  char v59[15]; // [xsp+51h] [xbp-21Fh] BYREF
  __int64 v60; // [xsp+60h] [xbp-210h]
  __int128 v61; // [xsp+80h] [xbp-1F0h] BYREF
  __int128 v62; // [xsp+90h] [xbp-1E0h]
  int v63; // [xsp+A0h] [xbp-1D0h]
  __int64 v64; // [xsp+A8h] [xbp-1C8h]
  char v65; // [xsp+B0h] [xbp-1C0h]

  result = qword_6DE6180;
  if ( !byte_724A7A8 || !byte_724A758 )
  {
    if ( !(_BYTE)qword_6DE6180 )
      goto LABEL_8;
    goto LABEL_7;
  }
  if ( (unsigned __int8)qword_6DE6180 >= 6u && BYTE1(qword_6DE6180) >= 3u )
LABEL_7:
    result = sub_65C5C5C(
               qword_6DE6180,
               qword_6DE6188,
               (__int64)"[DFLog::AnalyticsDeferredEphemeralReportingDiagnostic] SendNow, # stats = %zu, # counters = %zu",
               (a1[1] - *a1) >> 5,
               *(_QWORD *)(a2 + 24),
               a4,
               a5,
               a6,
               a8,
               a9,
               a10,
               a11,
               v51);
LABEL_8:
  v16 = &xmmword_AFE000;
  v20 = *a1 == a1[1];
  *a7 = 0u;
  a7[1] = 0u;
  if ( v20 )
    goto LABEL_51;
  *(_QWORD *)&v62 = sub_65ECAAC();
  strcpy((char *)v62, "76E5A40C-3AE1-4028-9F10-7C62520BD94F");
  v61 = xmmword_AFEE20;
  sub_3D7EF98(v57, &v61);
  if ( (v61 & 1) != 0 )
    sub_65ECAF4();
  sub_65DA834(&v61, 0LL);
  sub_65DAB00(&v61);
  v18 = *a1;
  v17 = a1[1];
  if ( *a1 != v17 )
  {
    do
    {
      sub_65DAA38(&v61);
      v19 = *v18;
      v20 = (v19 & 1) == 0;
      v21 = v19 >> 1;
      if ( v20 )
        v22 = v18 + 1;
      else
        v22 = (unsigned __int8 *)*((_QWORD *)v18 + 2);
      if ( v20 )
        v23 = v21;
      else
        v23 = *((_QWORD *)v18 + 1);
      sub_65DB020(&v61, "Key", 3LL, v22, v23);
      v24 = v18 + 1;
      sub_65DB080(&v61, "Value", *(double *)(v24 + 23));
      sub_65DAA74(&v61);
      v18 = v24 + 31;
    }
    while ( v18 != v17 );
  }
  sub_65DAB3C(&v61);
  v25 = (const void *)sub_65DB5DC(&v61);
  v26 = sub_65DB680(&v61);
  v27 = v26;
  if ( v26 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( v26 >= 0x17 )
  {
    v29 = (v26 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v28 = (char *)sub_65ECAAC();
    v55 = v27;
    v56 = v28;
    v54 = v29 | 1;
  }
  else
  {
    v28 = (char *)&v54 + 1;
    LOBYTE(v54) = 2 * v26;
    if ( !v26 )
      goto LABEL_25;
  }
  memcpy(v28, v25, v27);
LABEL_25:
  v28[v27] = 0;
  sub_65DA9D8(&v61);
  v31 = *a1;
  for ( i = a1[1]; v31 != i; v31 += 32 )
  {
    sub_648BE34(&v61, (unsigned int)dword_6FF5810, 4LL, (unsigned int)dword_6CA8E84);
    if ( (*v31 & 1) != 0 )
      v33 = (unsigned __int8 *)*((_QWORD *)v31 + 2);
    else
      v33 = v31 + 1;
    *(_QWORD *)&v32 = *((_QWORD *)v31 + 3);
    sub_6490850(&v61, v33, v32);
    v58 = 18;
    strcpy(v59, "Telemetry");
    sub_6491634(&v61, &v58, (unsigned int)dword_6FF5810, 0LL);
    if ( (v58 & 1) != 0 )
      sub_65ECAF4();
    sub_256AE00(&v61);
  }
  if ( (a3 & 1) != 0 )
  {
    result = sub_3C2E9B4(v57, &v54, &byte_6FF2108, 0LL, 0LL);
    v16 = &xmmword_AFE000;
  }
  else
  {
    v64 = 0LL;
    v65 = 0;
    v63 = 1065353216;
    v61 = 0u;
    v62 = 0u;
    sub_62C9268(&v61, 23LL);
    v16 = &xmmword_AFE000;
    sub_62CA0B8(&v58, &v54, &byte_6FF2108, 1LL);
    sub_6294D48(&v52, v57, &v58, &v61);
    sub_3C2A5F8(a7, &v52);
    v34 = v53;
    if ( v53 )
    {
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v53 + 8)) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v34 + 16LL))(v34);
        if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v34 + 12)) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v34 + 24LL))(v34);
      }
    }
    if ( (v60 & 1) != 0 )
      sub_65ECAF4();
    v35 = *(unsigned __int64 **)&v59[7];
    if ( *(_QWORD *)&v59[7] && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(*(_QWORD *)&v59[7] + 8LL)) )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v35 + 16))(v35);
      sub_68488BC(v35);
    }
    v36 = (__int64 **)v62;
    if ( (_QWORD)v62 )
    {
      do
      {
        v43 = *v36;
        if ( ((_BYTE)v36[5] & 1) != 0 )
          sub_65ECAF4();
        if ( ((_BYTE)v36[2] & 1) != 0 )
          sub_65ECAF4();
        sub_65ECAF4();
        v36 = (__int64 **)v43;
      }
      while ( v43 );
    }
    result = v61;
    *(_QWORD *)&v61 = 0LL;
    if ( result )
      result = sub_65ECAF4();
  }
  if ( (v54 & 1) != 0 )
    result = sub_65ECAF4();
  if ( (v57[0] & 1) != 0 )
    result = sub_65ECAF4();
LABEL_51:
  if ( !*(_QWORD *)(a2 + 24) )
    return result;
  *(_QWORD *)&v62 = sub_65ECAAC();
  v37 = v16[226];
  strcpy((char *)v62, "76E5A40C-3AE1-4028-9F10-7C62520BD94F");
  v61 = v37;
  sub_3D7F204(v57, &v61);
  if ( (v61 & 1) != 0 )
    sub_65ECAF4();
  sub_65DA834(&v61, 0LL);
  sub_65DAA38(&v61);
  for ( j = *(__int64 ***)(a2 + 16); j; j = (__int64 **)*j )
    sub_65DB208(&v61, j + 2, *((unsigned int *)j + 10));
  sub_65DAA74(&v61);
  v39 = (const void *)sub_65DB5DC(&v61);
  v40 = sub_65DB680(&v61);
  v41 = v40;
  if ( v40 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( v40 >= 0x17 )
  {
    v44 = (v40 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v42 = (char *)sub_65ECAAC();
    v55 = v41;
    v56 = v42;
    v54 = v44 | 1;
    goto LABEL_66;
  }
  v42 = (char *)&v54 + 1;
  LOBYTE(v54) = 2 * v40;
  if ( v40 )
LABEL_66:
    memcpy(v42, v39, v41);
  v42[v41] = 0;
  sub_65DA9D8(&v61);
  if ( byte_724A7A8 && byte_6FF57C8 )
  {
    sub_648BE34(&v61, (unsigned int)dword_6FF57E8, 5LL, (unsigned int)dword_6CA8E80);
    for ( k = *(__int64 ***)(a2 + 16); k; k = (__int64 **)*k )
    {
      if ( ((_BYTE)k[2] & 1) != 0 )
        v46 = k[4];
      else
        v46 = (__int64 *)((char *)k + 17);
      sub_64909C4(&v61, v46, *((unsigned int *)k + 10));
    }
    v58 = 18;
    strcpy(v59, "Telemetry");
    sub_6491634(&v61, &v58, (unsigned int)dword_6FF57E8, 0LL);
    if ( (v58 & 1) != 0 )
      sub_65ECAF4();
    sub_256AE00(&v61);
  }
  if ( (a3 & 1) != 0 )
  {
    result = sub_3C2E9B4(v57, &v54, &byte_6FF2108, 0LL, 0LL);
  }
  else
  {
    v64 = 0LL;
    v65 = 0;
    v63 = 1065353216;
    v61 = 0u;
    v62 = 0u;
    sub_62C9268(&v61, 23LL);
    sub_62CA0B8(&v58, &v54, &byte_6FF2108, 1LL);
    sub_6294D48(&v52, v57, &v58, &v61);
    sub_3C2A5F8(a7 + 1, &v52);
    v47 = v53;
    if ( v53 )
    {
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v53 + 8)) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v47 + 16LL))(v47);
        if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v47 + 12)) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v47 + 24LL))(v47);
      }
    }
    if ( (v60 & 1) != 0 )
      sub_65ECAF4();
    v48 = *(unsigned __int64 **)&v59[7];
    if ( *(_QWORD *)&v59[7] && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(*(_QWORD *)&v59[7] + 8LL)) )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v48 + 16))(v48);
      sub_68488BC(v48);
    }
    v49 = (__int64 **)v62;
    if ( (_QWORD)v62 )
    {
      do
      {
        v50 = *v49;
        if ( ((_BYTE)v49[5] & 1) != 0 )
          sub_65ECAF4();
        if ( ((_BYTE)v49[2] & 1) != 0 )
          sub_65ECAF4();
        sub_65ECAF4();
        v49 = (__int64 **)v50;
      }
      while ( v50 );
    }
    result = v61;
    *(_QWORD *)&v61 = 0LL;
    if ( result )
      result = sub_65ECAF4();
  }
  if ( (v54 & 1) != 0 )
    result = sub_65ECAF4();
  if ( (v57[0] & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_3C0D0F0 (0x3C0D0F0)
================================================================================

_QWORD *__fastcall sub_3C0D0F0(_QWORD *result, __int64 a2, char a3)
{
  __int64 v3; // x19
  __int64 v4; // x19
  __int64 v5; // [xsp+8h] [xbp-28h] BYREF
  __int64 v6; // [xsp+10h] [xbp-20h]
  __int64 v7; // [xsp+20h] [xbp-10h]

  if ( *(_QWORD *)(*result + 168LL) + ((__int64)(*(_QWORD *)(*result + 128LL) - *(_QWORD *)(*result + 120LL)) >> 5) >= (unsigned __int64)dword_6C84DB4
    || (a3 & 1) != 0 )
  {
    result = sub_3C0C238(&v5, a2, result, a3 & 1);
    v3 = v7;
    if ( v7 )
    {
      result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 16LL))(v3);
        result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v3 + 12));
        if ( (_DWORD)result == 1 )
          result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 24LL))(v3);
      }
    }
    v4 = v6;
    if ( v6 )
    {
      result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 16LL))(v4);
        result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v4 + 12));
        if ( (_DWORD)result == 1 )
          return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_3C0D21C (0x3C0D21C)
================================================================================

long double __usercall sub_3C0D21C@<Q0>(__int64 *a1@<X8>)
{
  bool v2; // zf
  __int64 v3; // x20
  __int64 v4; // x20
  __int64 v5; // x0
  __int64 v6; // x21
  __int64 v7; // x20
  long double result; // q0

  if ( byte_724A7A8 )
    v2 = byte_7301120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = sub_65ECAAC();
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_QWORD *)v3 = off_6958F40;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_OWORD *)(v3 + 128) = 0u;
    *(_OWORD *)(v3 + 144) = 0u;
    *(_OWORD *)(v3 + 160) = 0u;
    *(_OWORD *)(v3 + 176) = 0u;
    *(_OWORD *)(v3 + 192) = 0u;
    *(_OWORD *)(v3 + 208) = 0u;
    *(_OWORD *)(v3 + 224) = 0u;
    *(_OWORD *)(v3 + 240) = 0u;
    *(_OWORD *)(v3 + 256) = 0u;
    *(_OWORD *)(v3 + 272) = 0u;
    *(_OWORD *)(v3 + 288) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    sub_67DE848(v3 + 80);
    *(_QWORD *)(v3 + 200) = 0LL;
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(v3 + 288) = 0LL;
    *a1 = v3 + 32;
    a1[1] = v3;
    *(_QWORD *)(v3 + 96) = 0x7FFFFFFFFFFFFFFFLL;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
    *(_OWORD *)(v3 + 136) = 0u;
    *(_OWORD *)(v3 + 152) = 0u;
    *(_OWORD *)(v3 + 168) = 0u;
    *(_OWORD *)(v3 + 184) = 0u;
    *(_DWORD *)(v3 + 208) = 1065353216;
    *(_OWORD *)(v3 + 216) = 0u;
    *(_OWORD *)(v3 + 232) = 0u;
    *(_DWORD *)(v3 + 248) = 1065353216;
  }
  else
  {
    v4 = sub_680599C();
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 320LL, 16LL);
    *(_QWORD *)(v5 + 32) = v4;
    v6 = v5;
    *(_QWORD *)(v5 + 8) = 0LL;
    *(_QWORD *)(v5 + 16) = 0LL;
    *(_QWORD *)v5 = off_6958EF0;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(_OWORD *)(v5 + 208) = 0u;
    *(_OWORD *)(v5 + 224) = 0u;
    *(_OWORD *)(v5 + 240) = 0u;
    *(_OWORD *)(v5 + 256) = 0u;
    *(_OWORD *)(v5 + 272) = 0u;
    *(_OWORD *)(v5 + 288) = 0u;
    *(_OWORD *)(v5 + 304) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    v7 = v5 + 48;
    *(_OWORD *)(v5 + 96) = 0u;
    sub_67DE848(v5 + 96);
    *(_QWORD *)(v6 + 216) = 0LL;
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(v6 + 304) = 0LL;
    *a1 = v7;
    a1[1] = v6;
    *(_QWORD *)(v6 + 112) = 0x7FFFFFFFFFFFFFFFLL;
    *(_OWORD *)(v6 + 120) = 0u;
    *(_OWORD *)(v6 + 136) = 0u;
    *(_OWORD *)(v6 + 152) = 0u;
    *(_OWORD *)(v6 + 168) = 0u;
    *(_OWORD *)(v6 + 184) = 0u;
    *(_OWORD *)(v6 + 200) = 0u;
    *(_DWORD *)(v6 + 224) = 1065353216;
    *(_OWORD *)(v6 + 232) = 0u;
    *(_OWORD *)(v6 + 248) = 0u;
    *(_DWORD *)(v6 + 264) = 1065353216;
  }
  return result;
}


================================================================================
Function: sub_3C0D9FC (0x3C0D9FC)
================================================================================

pthread_mutex_t **__fastcall sub_3C0D9FC(pthread_mutex_t **result, __int64 a2, char a3)
{
  bool v3; // zf
  pthread_mutex_t **v4; // x20
  __int64 v7; // x0
  __int64 *v8; // x26
  bool v9; // zf
  pthread_mutex_t *v10; // x8
  int v11; // w24
  __int64 v12; // x0
  char v13[8]; // [xsp+8h] [xbp-28h] BYREF
  __int64 *v14; // [xsp+10h] [xbp-20h] BYREF
  pthread_mutex_t *v15; // [xsp+18h] [xbp-18h] BYREF
  char v16; // [xsp+20h] [xbp-10h]

  if ( byte_724A7A8 )
    v3 = byte_6FF0A20 == 0;
  else
    v3 = 1;
  if ( v3 )
  {
    v4 = result;
    v15 = *result;
    v16 = 1;
    sub_6848980(v15);
    v7 = sub_3C0B2A4(v4);
    if ( (*v4)[3].__align != *(&(*v4)[3].__align + 1) || *(&(*v4)[4].__align + 1) )
    {
      v8 = *(__int64 **)(a2 + 16);
      if ( v8 )
        goto LABEL_9;
      goto LABEL_20;
    }
    (*v4)[1].__list.__prev = (struct __pthread_internal_list *)(sub_6819D00(v7) + 1000000000LL * dword_6C84DB0);
    sub_6819DA4(&(*v4)[1].__align + 4);
    v8 = *(__int64 **)(a2 + 16);
    if ( !v8 )
    {
LABEL_20:
      result = (pthread_mutex_t **)sub_3C0D0F0(v4, &v15, a3 & 1);
      if ( v16 )
        return (pthread_mutex_t **)sub_68489D4(v15);
      return result;
    }
    while ( 1 )
    {
LABEL_9:
      if ( byte_724A7A8 )
        v9 = byte_724A758 == 0;
      else
        v9 = 1;
      if ( v9 )
      {
        if ( !(_BYTE)qword_6DE6180 )
          goto LABEL_19;
      }
      else if ( (unsigned __int8)qword_6DE6180 < 6u || BYTE1(qword_6DE6180) < 3u )
      {
        goto LABEL_19;
      }
      sub_65C5C5C();
LABEL_19:
      v10 = *v4;
      v14 = v8 + 2;
      v11 = *((_DWORD *)v8 + 10);
      v12 = sub_3098E10(&v10[3].__align + 3, v8 + 2, &unk_E603E3, &v14, v13);
      *(_DWORD *)(v12 + 40) += v11;
      v8 = (__int64 *)*v8;
      if ( !v8 )
        goto LABEL_20;
    }
  }
  return result;
}


================================================================================
Function: sub_3C0F158 (0x3C0F158)
================================================================================

__int64 __usercall sub_3C0F158@<X0>(_QWORD *a1@<X8>)
{
  unsigned __int8 v2; // w9
  __int64 v3; // x20
  __int64 v4; // x8

  v2 = atomic_load(byte_6DE6548);
  if ( (v2 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6DE6548) )
  {
    sub_3C26DC4(&unk_6DE6508);
    __cxa_atexit((void (*)(void *))sub_3C27184, &unk_6DE6508, &off_686E780);
    sub_6862850(byte_6DE6548);
  }
  v3 = qword_6DE6458;
  sub_6848980(qword_6DE6458);
  if ( qword_6DE6450 )
  {
    v4 = *(_QWORD *)(qword_6DE6450 + 8);
    *a1 = *(_QWORD *)qword_6DE6450;
    a1[1] = v4;
    if ( v4 )
      sub_6867420(1LL, v4 + 8);
  }
  else
  {
    *a1 = 0LL;
    a1[1] = 0LL;
  }
  return sub_68489D4(v3);
}


================================================================================
Function: sub_3C0F668 (0x3C0F668)
================================================================================

void __fastcall __noreturn sub_3C0F668(__int64 a1)
{
  __int64 v2; // x19
  __int128 v3; // q0
  __int64 v4; // x0
  __int128 v5; // q0
  _QWORD v6[2]; // [xsp+8h] [xbp-48h] BYREF
  __int128 v7; // [xsp+18h] [xbp-38h]
  __int64 (__fastcall **v8)(); // [xsp+28h] [xbp-28h] BYREF
  __int64 v9; // [xsp+30h] [xbp-20h]
  __int128 v10; // [xsp+38h] [xbp-18h]
  int v11; // [xsp+48h] [xbp-8h]

  v2 = sub_6861FD0(80LL);
  sub_684949C(v6, a1);
  v10 = 0uLL;
  v3 = *(_OWORD *)(a1 + 16);
  v11 = -1;
  v7 = v3;
  v6[0] = off_69566F8;
  v8 = off_6956720;
  v9 = 0LL;
  *(_QWORD *)(v2 + 72) = off_686EC48;
  sub_684949C(v2, v6);
  *(_OWORD *)(v2 + 16) = v7;
  *(_QWORD *)v2 = off_6956740;
  *(_QWORD *)(v2 + 32) = off_686EB38;
  v4 = v9;
  *(_QWORD *)(v2 + 40) = v9;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = v10;
  *(_DWORD *)(v2 + 64) = v11;
  *(_OWORD *)(v2 + 48) = v5;
  *(_QWORD *)v2 = off_6956658;
  *(_QWORD *)(v2 + 32) = off_6956690;
  *(_QWORD *)(v2 + 72) = &off_69566C8;
  sub_24FA560(v2 + 32, (__int64)&v8);
  sub_6862048(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::promise_moved>>,
    (__int64)sub_3C10FD8);
}


================================================================================
Function: sub_3C0F7E0 (0x3C0F7E0)
================================================================================

__int64 __fastcall sub_3C0F7E0(_QWORD *a1)
{
  __int64 v2; // x20
  __int64 result; // x0
  _QWORD v4[2]; // [xsp+0h] [xbp-20h] BYREF

  v2 = sub_67DE264();
  (*(void (__fastcall **)(_QWORD *__return_ptr))(*(_QWORD *)v2 + 24LL))(v4);
  result = sub_6849378(a1, v4);
  if ( (v4[0] & 1) != 0 )
    result = sub_65ECAF4();
  a1[2] = 4LL;
  a1[3] = v2;
  *a1 = off_6956740;
  return result;
}


================================================================================
Function: sub_3C0F898 (0x3C0F898)
================================================================================

void __fastcall __noreturn sub_3C0F898(__int64 a1)
{
  __int64 v2; // x19
  __int128 v3; // q0
  __int64 v4; // x0
  __int128 v5; // q0
  _QWORD v6[2]; // [xsp+8h] [xbp-48h] BYREF
  __int128 v7; // [xsp+18h] [xbp-38h]
  __int64 (__fastcall **v8)(); // [xsp+28h] [xbp-28h] BYREF
  __int64 v9; // [xsp+30h] [xbp-20h]
  __int128 v10; // [xsp+38h] [xbp-18h]
  int v11; // [xsp+48h] [xbp-8h]

  v2 = sub_6861FD0(80LL);
  sub_684949C(v6, a1);
  v11 = -1;
  v3 = *(_OWORD *)(a1 + 16);
  v6[0] = off_6956898;
  v10 = 0uLL;
  v7 = v3;
  v8 = off_69568C0;
  v9 = 0LL;
  *(_QWORD *)(v2 + 72) = off_686EC48;
  sub_684949C(v2, v6);
  *(_OWORD *)(v2 + 16) = v7;
  *(_QWORD *)v2 = off_69568E0;
  *(_QWORD *)(v2 + 32) = off_686EB38;
  v4 = v9;
  *(_QWORD *)(v2 + 40) = v9;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = v10;
  *(_DWORD *)(v2 + 64) = v11;
  *(_OWORD *)(v2 + 48) = v5;
  *(_QWORD *)v2 = off_69567F8;
  *(_QWORD *)(v2 + 32) = off_6956830;
  *(_QWORD *)(v2 + 72) = &off_6956868;
  sub_24FA560(v2 + 32, (__int64)&v8);
  sub_6862048(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::future_already_retrieved>>,
    (__int64)sub_3C115C0);
}


================================================================================
Function: sub_3C0FA18 (0x3C0FA18)
================================================================================

__int64 __fastcall sub_3C0FA18(_QWORD *a1)
{
  __int64 v2; // x20
  __int64 result; // x0
  _QWORD v4[2]; // [xsp+0h] [xbp-20h] BYREF

  v2 = sub_67DE264();
  (*(void (__fastcall **)(_QWORD *__return_ptr))(*(_QWORD *)v2 + 24LL))(v4);
  result = sub_6849378(a1, v4);
  if ( (v4[0] & 1) != 0 )
    result = sub_65ECAF4();
  a1[2] = 2LL;
  a1[3] = v2;
  *a1 = off_69568E0;
  return result;
}


================================================================================
Function: sub_3C0FD04 (0x3C0FD04)
================================================================================

__int64 __fastcall sub_3C0FD04(__int64 a1)
{
  unsigned int v2; // w1
  __int64 result; // x0
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)a1 = off_6956398;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_WORD *)(a1 + 40) = 0;
  v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 52), 0LL);
  if ( v2 )
  {
    sub_25C1BEC(v4, v2, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25C1ABC((__int64)v4);
  }
  result = sub_25C1984(a1 + 92);
  *(_BYTE *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0LL;
  *(_QWORD *)(a1 + 256) = 0LL;
  *(_QWORD *)(a1 + 200) = 0LL;
  *(_QWORD *)(a1 + 208) = 0LL;
  *(_QWORD *)(a1 + 184) = a1 + 184;
  *(_QWORD *)(a1 + 192) = a1 + 184;
  return result;
}


================================================================================
Function: sub_3C11BB0 (0x3C11BB0)
================================================================================

__int64 **__fastcall sub_3C11BB0(unsigned __int64 a1, unsigned __int8 *a2, __int128 *a3, int *a4)
{
  unsigned __int64 v4; // x28
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x8
  bool v11; // zf
  unsigned __int64 v12; // x8
  unsigned __int8 *v13; // x1
  unsigned __int64 v14; // x2
  unsigned __int64 v15; // x0
  unsigned __int64 v16; // x20
  unsigned __int64 v17; // x27
  uint8x8_t v18; // d0
  unsigned __int64 v19; // x26
  __int64 ***v20; // x8
  unsigned __int64 v21; // x10
  unsigned __int8 *v22; // x11
  unsigned __int8 *v23; // x12
  unsigned __int64 v24; // x9
  __int64 **v25; // x23
  size_t v26; // x24
  unsigned __int8 *i; // x25
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x10
  unsigned __int64 v30; // x11
  __int64 *v31; // x0
  __int64 v32; // x9
  __int64 *v33; // x24
  __int64 v34; // x0
  __int128 v35; // q0
  __int64 v36; // x8
  __int64 v37; // x9
  _QWORD *v38; // x23
  int v39; // w10
  float v40; // s1
  float v41; // s0
  _BOOL8 v42; // x9
  unsigned __int64 v43; // x10
  unsigned __int64 v44; // x1
  __int64 v45; // x8
  _QWORD *v46; // x9
  __int64 v47; // x9
  unsigned __int64 v48; // x9
  _QWORD v50[2]; // [xsp+10h] [xbp-20h] BYREF
  char v51; // [xsp+20h] [xbp-10h]

  v9 = *((_QWORD *)a2 + 1);
  v10 = *a2;
  v11 = (v10 & 1) == 0;
  v12 = v10 >> 1;
  if ( v11 )
    v13 = a2 + 1;
  else
    v13 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  if ( v11 )
    v14 = v12;
  else
    v14 = v9;
  v15 = sub_24FE128(v50, v13, v14);
  v16 = v15;
  v17 = *(_QWORD *)(a1 + 8);
  if ( v17 )
  {
    v18.n64_u64[0] = vcnt_s8((int8x8_t)v17).n64_u64[0];
    v18.n64_u16[0] = vaddlv_u8(v18);
    v19 = v18.n64_u32[0];
    if ( v18.n64_u32[0] > 1uLL )
    {
      v4 = v15;
      if ( v15 >= v17 )
        v4 = v15 % v17;
    }
    else
    {
      v4 = (v17 - 1) & v15;
    }
    v20 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v4);
    if ( v20 )
    {
      v21 = *((_QWORD *)a2 + 1);
      v22 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v23 = a2 + 1;
      v24 = *a2;
      v25 = *v20;
      v26 = (v24 & 1) != 0 ? v21 : v24 >> 1;
      for ( i = (v24 & 1) != 0 ? v22 : v23; v25; v25 = (__int64 **)*v25 )
      {
        v28 = (unsigned __int64)v25[1];
        if ( v28 != v16 )
        {
          if ( v19 > 1 )
          {
            if ( v28 >= v17 )
              v28 %= v17;
          }
          else
          {
            v28 &= v17 - 1;
          }
          if ( v28 != v4 )
            break;
        }
        v29 = *((unsigned __int8 *)v25 + 16);
        v30 = (unsigned __int64)v25[3];
        if ( (v29 & 1) == 0 )
          v30 = v29 >> 1;
        if ( v30 == v26 )
        {
          if ( (v29 & 1) != 0 )
            v31 = v25[4];
          else
            v31 = (__int64 *)((char *)v25 + 17);
          if ( (v29 & 1) != 0 )
          {
            if ( !v26 || !memcmp(v31, i, v26) )
              return v25;
          }
          else
          {
            if ( !v26 )
              return v25;
            v32 = 0LL;
            while ( *((unsigned __int8 *)v25 + v32 + 17) == i[v32] )
            {
              if ( v29 >> 1 == ++v32 )
                return v25;
            }
          }
        }
      }
    }
  }
  v33 = (__int64 *)(a1 + 16);
  v34 = sub_65ECAAC();
  v35 = *a3;
  *(_QWORD *)a3 = 0LL;
  *((_QWORD *)a3 + 1) = 0LL;
  v36 = *((_QWORD *)a3 + 2);
  *((_QWORD *)a3 + 2) = 0LL;
  v37 = *(_QWORD *)(a1 + 24);
  v38 = (_QWORD *)v34;
  *(_OWORD *)(v34 + 16) = v35;
  v39 = *a4;
  *(_QWORD *)(v34 + 32) = v36;
  v40 = *(float *)(a1 + 32);
  v50[0] = v34;
  v50[1] = a1 + 16;
  *(_DWORD *)(v34 + 40) = v39;
  v41 = (float)(unsigned __int64)(v37 + 1);
  v51 = 1;
  *(_QWORD *)v34 = 0LL;
  *(_QWORD *)(v34 + 8) = v16;
  if ( !v17 || (float)(v40 * (float)v17) < v41 )
  {
    v42 = v17 < 3 || (v17 & (v17 - 1)) != 0;
    v43 = vcvtps_u32_f32(v41 / v40);
    if ( (v42 | (2 * v17)) >= v43 )
      v44 = v42 | (2 * v17);
    else
      v44 = v43;
    sub_3099144(a1, v44);
    v17 = *(_QWORD *)(a1 + 8);
    if ( (v17 & (v17 - 1)) != 0 )
    {
      if ( v16 >= v17 )
        v4 = v16 % v17;
      else
        v4 = v16;
    }
    else
    {
      v4 = (v17 - 1) & v16;
    }
  }
  v45 = *(_QWORD *)a1;
  v46 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if ( v46 )
  {
    *v38 = *v46;
    *v46 = v38;
  }
  else
  {
    v47 = *v33;
    *v33 = (__int64)v38;
    *v38 = v47;
    *(_QWORD *)(v45 + 8 * v4) = v33;
    if ( *(_QWORD *)v50[0] )
    {
      v48 = *(_QWORD *)(*(_QWORD *)v50[0] + 8LL);
      if ( (v17 & (v17 - 1)) != 0 )
      {
        if ( v48 >= v17 )
          v48 %= v17;
      }
      else
      {
        v48 &= v17 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v48) = v50[0];
    }
  }
  v25 = (__int64 **)v50[0];
  ++*(_QWORD *)(a1 + 24);
  return v25;
}


================================================================================
Function: sub_3C12CF0 (0x3C12CF0)
================================================================================

_QWORD *__fastcall sub_3C12CF0(_QWORD *result, unsigned __int8 *a2, __int64 *a3)
{
  _QWORD *v4; // x19
  __int64 v5; // x8
  __int64 i; // x9
  unsigned __int8 *v8; // x22
  __int64 *v9; // x23
  __int64 *v10; // x19

  v4 = result;
  v5 = result[1];
  if ( !v5 )
    goto LABEL_9;
  for ( i = 0LL; i != v5; *(_QWORD *)(*result + 8 * i++) = 0LL )
    ;
  v8 = (unsigned __int8 *)result[2];
  result[2] = 0LL;
  result[3] = 0LL;
  if ( v8 )
  {
    while ( a2 != (unsigned __int8 *)a3 )
    {
      sub_684A438(v8 + 16, a2 + 16);
      sub_684A438(v8 + 40, a2 + 40);
      v9 = *(__int64 **)v8;
      result = (_QWORD *)sub_3C12E0C(v4, v8);
      a2 = *(unsigned __int8 **)a2;
      v8 = (unsigned __int8 *)v9;
      if ( !v9 )
        goto LABEL_9;
    }
    do
    {
      v10 = *(__int64 **)v8;
      if ( (v8[40] & 1) != 0 )
        sub_65ECAF4();
      if ( (v8[16] & 1) != 0 )
        sub_65ECAF4();
      result = (_QWORD *)sub_65ECAF4();
      v8 = (unsigned __int8 *)v10;
    }
    while ( v10 );
  }
  else
  {
LABEL_9:
    while ( a2 != (unsigned __int8 *)a3 )
    {
      result = (_QWORD *)sub_3C12FE0(v4, a2 + 16);
      a2 = *(unsigned __int8 **)a2;
    }
  }
  return result;
}


================================================================================
Function: sub_3C12E0C (0x3C12E0C)
================================================================================

__int64 __fastcall sub_3C12E0C(__int64 *a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  bool v5; // zf
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x2
  __int64 *v8; // x1
  _QWORD *v9; // x0
  int8x8_t v10; // x8
  unsigned __int64 v11; // x9
  uint8x8_t v12; // d0
  unsigned __int64 v13; // x10
  __int64 v14; // x12
  __int64 v16; // [xsp+0h] [xbp-10h] BYREF

  v4 = *(unsigned __int8 *)(a2 + 16);
  v5 = (v4 & 1) == 0;
  v6 = v4 >> 1;
  if ( v5 )
    v7 = v6;
  else
    v7 = *(_QWORD *)(a2 + 24);
  if ( v5 )
    v8 = (__int64 *)(a2 + 17);
  else
    v8 = *(__int64 **)(a2 + 32);
  *(_QWORD *)(a2 + 8) = sub_24FE128((__int64)&v16, v8, v7);
  v9 = (_QWORD *)sub_3C13084(a1);
  v10.n64_u64[0] = a1[1];
  v11 = *(_QWORD *)(a2 + 8);
  v12.n64_u64[0] = vcnt_s8(v10).n64_u64[0];
  v12.n64_u16[0] = vaddlv_u8(v12);
  if ( v12.n64_u32[0] > 1uLL )
  {
    if ( v11 >= v10.n64_u64[0] )
      v11 %= v10.n64_u64[0];
  }
  else
  {
    v11 &= v10.n64_u64[0] - 1;
  }
  if ( !v9 )
  {
    *(_QWORD *)a2 = a1[2];
    v14 = *a1;
    a1[2] = a2;
    *(_QWORD *)(v14 + 8 * v11) = a1 + 2;
    if ( !*(_QWORD *)a2 )
      goto LABEL_25;
    v13 = *(_QWORD *)(*(_QWORD *)a2 + 8LL);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v10.n64_u64[0] )
        v13 %= v10.n64_u64[0];
    }
    else
    {
      v13 &= v10.n64_u64[0] - 1;
    }
LABEL_24:
    *(_QWORD *)(*a1 + 8 * v13) = a2;
    goto LABEL_25;
  }
  *(_QWORD *)a2 = *v9;
  *v9 = a2;
  if ( *(_QWORD *)a2 )
  {
    v13 = *(_QWORD *)(*(_QWORD *)a2 + 8LL);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v10.n64_u64[0] )
        v13 %= v10.n64_u64[0];
    }
    else
    {
      v13 &= v10.n64_u64[0] - 1;
    }
    if ( v13 != v11 )
      goto LABEL_24;
  }
LABEL_25:
  ++a1[3];
  return a2;
}


================================================================================
Function: sub_3C12FE0 (0x3C12FE0)
================================================================================

__int64 __fastcall sub_3C12FE0(__int64 a1)
{
  _QWORD v3[3]; // [xsp+0h] [xbp-20h] BYREF

  sub_3C13284(v3);
  return sub_3C12E0C(a1, v3[0]);
}


================================================================================
Function: sub_3C13084 (0x3C13084)
================================================================================

__int64 *__fastcall sub_3C13084(__int64 a1, unsigned __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // x23
  uint8x8_t v7; // d0
  unsigned __int64 v8; // x24
  unsigned __int64 v9; // x25
  __int64 *v10; // x26
  int v11; // w27
  unsigned __int64 v12; // x8
  size_t v13; // x21
  unsigned __int8 *v14; // x22
  _BOOL4 v15; // w8
  int v16; // w9
  __int64 *v17; // x20
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x9
  unsigned __int64 v20; // x9
  unsigned __int64 v21; // x11
  unsigned __int64 v22; // x10
  const void *v23; // x0
  unsigned __int8 *v24; // x9
  unsigned __int64 v25; // x10
  unsigned __int8 *v26; // x11
  int v27; // w8
  int v28; // t1
  int v29; // t1
  bool v30; // zf

  v6 = *(_QWORD *)(a1 + 8);
  if ( !v6 || (float)(*(float *)(a1 + 32) * (float)v6) < (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL) )
  {
    sub_252DEFC();
    v6 = *(_QWORD *)(a1 + 8);
  }
  v7.n64_u64[0] = vcnt_s8((int8x8_t)v6).n64_u64[0];
  v7.n64_u16[0] = vaddlv_u8(v7);
  v8 = v7.n64_u32[0];
  if ( v7.n64_u32[0] > 1uLL )
  {
    v9 = a2;
    if ( v6 <= a2 )
      v9 = a2 % v6;
  }
  else
  {
    v9 = (v6 - 1) & a2;
  }
  v10 = *(__int64 **)(*(_QWORD *)a1 + 8 * v9);
  if ( v10 )
  {
    v11 = 0;
    v12 = *a3;
    if ( (v12 & 1) != 0 )
      v13 = *((_QWORD *)a3 + 1);
    else
      v13 = v12 >> 1;
    if ( (v12 & 1) != 0 )
      v14 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
    else
      v14 = a3 + 1;
    while ( 1 )
    {
      v17 = v10;
      v10 = (__int64 *)*v10;
      if ( !v10 )
        return v17;
      v18 = v10[1];
      if ( v8 > 1 )
      {
        v19 = v10[1];
        if ( v18 >= v6 )
          v19 = v18 % v6;
      }
      else
      {
        v19 = v18 & (v6 - 1);
      }
      if ( v19 != v9 )
        return v17;
      if ( v18 != a2 )
        goto LABEL_15;
      v20 = *((unsigned __int8 *)v10 + 16);
      v21 = v10[3];
      v22 = v20 >> 1;
      if ( (v20 & 1) == 0 )
        v21 = v20 >> 1;
      if ( v21 == v13 )
      {
        if ( (v20 & 1) != 0 )
          v23 = (const void *)v10[4];
        else
          v23 = (char *)v10 + 17;
        if ( (v20 & 1) == 0 )
        {
          if ( v13 )
          {
            v24 = (unsigned __int8 *)v10 + 17;
            v25 = v22 - 1;
            v26 = v14;
            do
            {
              v28 = *v24++;
              v27 = v28;
              v29 = *v26++;
              v30 = v27 == v29;
              v15 = v27 == v29;
              v30 = !v30 || v25-- == 0;
            }
            while ( !v30 );
            goto LABEL_16;
          }
LABEL_41:
          v15 = 1;
          goto LABEL_16;
        }
        if ( !v13 )
          goto LABEL_41;
        v15 = memcmp(v23, v14, v13) == 0;
      }
      else
      {
LABEL_15:
        v15 = 0;
      }
LABEL_16:
      v16 = v11 & !v15;
      v11 |= v15;
      if ( v16 == 1 )
        return v17;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_3C13284 (0x3C13284)
================================================================================

unsigned __int64 __usercall sub_3C13284@<X0>(__int64 a1@<X0>, __int128 *a2@<X1>, __int64 a3@<X8>)
{
  __int64 v4; // x22
  unsigned __int64 *v6; // x20
  __int64 *v7; // x9
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  bool v10; // zf
  unsigned __int64 v11; // x8
  __int64 *v12; // x1
  unsigned __int64 v13; // x2
  unsigned __int64 result; // x0
  __int64 v15; // [xsp+0h] [xbp-10h] BYREF

  v4 = a1 + 16;
  v6 = (unsigned __int64 *)sub_65ECAAC();
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v4;
  *(_BYTE *)(a3 + 16) = 0;
  sub_68497A0(v6 + 2, a2);
  sub_68497A0(v6 + 5, (__int128 *)((char *)a2 + 24));
  v8 = v6[3];
  v7 = (__int64 *)v6[4];
  v9 = *((unsigned __int8 *)v6 + 16);
  *(_BYTE *)(a3 + 16) = 1;
  v10 = (v9 & 1) == 0;
  v11 = v9 >> 1;
  if ( v10 )
    v12 = (__int64 *)((char *)v6 + 17);
  else
    v12 = v7;
  if ( v10 )
    v13 = v11;
  else
    v13 = v8;
  result = sub_24FE128((__int64)&v15, v12, v13);
  *v6 = 0LL;
  v6[1] = result;
  return result;
}


================================================================================
Function: sub_3C21D84 (0x3C21D84)
================================================================================

__int64 __usercall sub_3C21D84@<X0>(__int64 *a1@<X0>, _QWORD *a2@<X8>)
{
  __int64 result; // x0
  __int64 v5; // x23
  __int64 v6; // x19
  _BYTE v7[32]; // [xsp+8h] [xbp-28h] BYREF

  result = sub_3C23870();
  v5 = *a1;
  if ( !*a1 )
  {
    sub_3C0F7E0(v7);
    sub_3C0F668(v7);
  }
  if ( *((_BYTE *)a1 + 16) )
  {
    sub_3C0FA18(v7);
    sub_3C0F898(v7);
  }
  v6 = a1[1];
  *((_BYTE *)a1 + 16) = 1;
  if ( v6 )
  {
    sub_6867390(1u, (atomic_uint *)(v6 + 8));
    sub_6867390(1u, (atomic_uint *)(v6 + 8));
    *a2 = v5;
    a2[1] = v6;
    sub_6867390(1u, (atomic_uint *)(v6 + 8));
    if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 12));
      if ( (_DWORD)result == 1 )
        return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  else
  {
    *a2 = v5;
    a2[1] = 0LL;
  }
  return result;
}


================================================================================
Function: sub_3C23870 (0x3C23870)
================================================================================

__int64 __fastcall sub_3C23870(unsigned __int64 a1)
{
  unsigned __int64 v2; // x23
  __int64 result; // x0
  unsigned int v4; // w21
  __int64 v5; // x20
  __int64 v6; // x25
  _QWORD *v7; // x20
  __int64 v8; // x19
  __int64 v9; // x19
  _QWORD *v10; // [xsp+10h] [xbp-30h] BYREF
  __int64 v11; // [xsp+18h] [xbp-28h] BYREF
  __int128 v12; // [xsp+20h] [xbp-20h] BYREF

  v2 = a1 % 0x29;
  result = sub_68671E0(1u, (atomic_uint *)&dword_6DE6460[a1 % 0x29]);
  if ( (_DWORD)result )
  {
    v4 = 0;
    do
    {
      if ( v4 >= 4 )
      {
        if ( v4 < 0x20 || (v4 & 1) != 0 )
        {
          sched_yield();
        }
        else
        {
          v12 = xmmword_AFE6B0;
          nanosleep((const struct timespec *)&v12, 0LL);
        }
      }
      ++v4;
      result = sub_68671E0(1u, (atomic_uint *)&dword_6DE6460[v2]);
    }
    while ( (_DWORD)result );
  }
  v6 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(a1 + 8);
  if ( !v5 )
  {
    atomic_store(0, &dword_6DE6460[v2]);
    if ( v6 )
      return result;
    goto LABEL_16;
  }
  sub_6867390(1u, (atomic_uint *)(v5 + 8));
  atomic_store(0, &dword_6DE6460[v2]);
  result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v5 + 8));
  if ( (_DWORD)result == 1 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v5 + 12));
    if ( (_DWORD)result == 1 )
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 24LL))(v5);
  }
  if ( !v6 )
  {
LABEL_16:
    v12 = 0uLL;
    v7 = (_QWORD *)sub_65ECAAC();
    sub_3C0FD04();
    v7[33] = 0LL;
    v10 = v7;
    v11 = 0LL;
    *v7 = off_69583A8;
    sub_3C241EC(&v10, v7, &v11);
    result = sub_3C23D5C(a1, &v12, &v10);
    v8 = v11;
    if ( v11 )
    {
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v11 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 16LL))(v8);
        result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v8 + 12));
        if ( (_DWORD)result == 1 )
          result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 24LL))(v8);
      }
    }
    v9 = *((_QWORD *)&v12 + 1);
    if ( *((_QWORD *)&v12 + 1) )
    {
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(*((_QWORD *)&v12 + 1) + 8LL));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v9 + 16LL))(v9);
        result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v9 + 12));
        if ( (_DWORD)result == 1 )
          return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 24LL))(v9);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_3C23D5C (0x3C23D5C)
================================================================================

bool __fastcall sub_3C23D5C(unsigned __int64 a1, _QWORD *a2, _QWORD *a3)
{
  unsigned __int64 v6; // x24
  unsigned int v7; // w26
  __int64 v8; // x26
  __int64 v9; // x27
  _BOOL4 v10; // w21
  __int64 v11; // x9
  __int64 v12; // x20
  __int128 v14; // [xsp+10h] [xbp-20h] BYREF

  v6 = a1 % 0x29;
  if ( (unsigned int)sub_68671E0(1u, (atomic_uint *)&dword_6DE6460[a1 % 0x29]) )
  {
    v7 = 0;
    do
    {
      if ( v7 >= 4 )
      {
        if ( v7 < 0x20 || (v7 & 1) != 0 )
        {
          sched_yield();
        }
        else
        {
          v14 = xmmword_AFE6B0;
          nanosleep((const struct timespec *)&v14, 0LL);
        }
      }
      ++v7;
    }
    while ( (unsigned int)sub_68671E0(1u, (atomic_uint *)&dword_6DE6460[v6]) );
  }
  v8 = *(_QWORD *)a1;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)a1 == *a2 && v9 == a2[1];
  if ( v10 )
  {
    *(_QWORD *)a1 = *a3;
    *a3 = v8;
    v11 = a3[1];
    a3[1] = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v11;
    atomic_store(0, &dword_6DE6460[v6]);
  }
  else
  {
    if ( v9 )
      sub_6867390(1u, (atomic_uint *)(v9 + 8));
    atomic_store(0, &dword_6DE6460[v6]);
    v12 = a2[1];
    *a2 = v8;
    a2[1] = v9;
    if ( v12 )
    {
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v12 + 8)) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 16LL))(v12);
        if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v12 + 12)) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 24LL))(v12);
      }
    }
  }
  return v10;
}


================================================================================
Function: sub_3C241EC (0x3C241EC)
================================================================================

_QWORD *__fastcall sub_3C241EC(__int64 a1, __int64 a2, __int64 *a3)
{
  _QWORD *result; // x0
  __int64 v7; // x21

  result = (_QWORD *)sub_65ECAAC();
  v7 = *a3;
  result[2] = a2;
  *a3 = (__int64)result;
  *result = off_6958408;
  result[1] = 0x100000001LL;
  if ( v7 )
  {
    result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
      result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 12));
      if ( (_DWORD)result == 1 )
        result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
    }
  }
  if ( a2 )
    return (_QWORD *)sub_3C2430C(a2 + 8, a1, a2);
  return result;
}


================================================================================
Function: sub_3C2430C (0x3C2430C)
================================================================================

_QWORD *__fastcall sub_3C2430C(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x20
  __int64 v5; // x8
  __int64 v7; // x19
  __int64 v8; // x8
  __int64 v9; // x22

  v4 = result;
  v5 = result[1];
  if ( v5 )
  {
    if ( atomic_load((unsigned int *)(v5 + 8)) )
      return result;
  }
  v7 = *(_QWORD *)(a2 + 8);
  if ( v7 )
  {
    sub_6867390(1u, (atomic_uint *)(v7 + 8));
    v8 = v4[1];
    *v4 = a3;
    if ( v7 == v8 )
      goto LABEL_11;
    sub_6867390(1u, (atomic_uint *)(v7 + 12));
    v9 = v4[1];
    if ( !v9 )
    {
      v4[1] = v7;
LABEL_11:
      result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
        result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 12));
        if ( (_DWORD)result == 1 )
          return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
      }
      return result;
    }
  }
  else
  {
    v9 = result[1];
    *result = a3;
    if ( !v9 )
      return result;
  }
  result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v9 + 12));
  if ( (_DWORD)result == 1 )
    result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 24LL))(v9);
  v4[1] = v7;
  if ( v7 )
    goto LABEL_11;
  return result;
}


================================================================================
Function: sub_3C26DC4 (0x3C26DC4)
================================================================================

__int64 __fastcall sub_3C26DC4(__int64 a1)
{
  __int64 v2; // x22
  unsigned __int8 v3; // w8
  __int64 v4; // x0
  _QWORD *v5; // x0
  __int64 v6; // x8
  __int64 v7; // x9
  unsigned __int64 *v8; // x23
  unsigned __int64 *v9; // x23
  _QWORD *v10; // x0
  __int64 v11; // x8
  __int64 v12; // x9
  unsigned __int64 *v13; // x23
  unsigned __int64 *v14; // x23
  __int64 v15; // x8
  __int64 v16; // x9
  __int64 v17; // x23
  unsigned __int64 *v18; // x23
  __int64 v19; // x0
  __int64 v20; // x19
  __int64 result; // x0
  __int64 v22; // x8
  __int64 v23; // [xsp+0h] [xbp-50h] BYREF
  __int64 v24; // [xsp+8h] [xbp-48h]
  _QWORD v25[4]; // [xsp+10h] [xbp-40h] BYREF
  _QWORD *v26; // [xsp+30h] [xbp-20h]

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 48) = 0LL;
  v2 = a1 + 48;
  v3 = atomic_load(byte_6CB1570);
  if ( (v3 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6CB1570) )
  {
    qword_6CB1530 = (__int64)off_686F7E8;
    sub_68489F4(&unk_6CB1538);
    qword_6CB1560 = 0LL;
    unk_6CB1568 = 0LL;
    qword_6CB1530 = (__int64)off_6871A40;
    qword_6CB1578 = (__int64)&qword_6CB1530;
    sub_6862850(byte_6CB1570);
  }
  *(_QWORD *)(a1 + 56) = sub_2533228(&qword_6CB1530);
  v4 = sub_6241D14();
  v5 = sub_3C2742C(&v23, v4);
  v6 = v23;
  v7 = v24;
  v23 = 0LL;
  v24 = 0LL;
  v8 = *(unsigned __int64 **)(a1 + 8);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 8) = v7;
  if ( v8 )
  {
    v5 = (_QWORD *)sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v8 + 1));
    if ( !v5 )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v8 + 16))(v8);
      v5 = (_QWORD *)sub_68488BC(v8);
    }
  }
  v9 = (unsigned __int64 *)v24;
  if ( v24 )
  {
    v5 = (_QWORD *)sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8));
    if ( !v5 )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v9 + 16))(v9);
      v5 = (_QWORD *)sub_68488BC(v9);
    }
  }
  v10 = sub_3C27534(&v23, v5);
  v11 = v23;
  v12 = v24;
  v23 = 0LL;
  v24 = 0LL;
  v13 = *(unsigned __int64 **)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(a1 + 24) = v12;
  if ( v13 )
  {
    v10 = (_QWORD *)sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v13 + 1));
    if ( !v10 )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v13 + 16))(v13);
      v10 = (_QWORD *)sub_68488BC(v13);
    }
  }
  v14 = (unsigned __int64 *)v24;
  if ( v24 )
  {
    v10 = (_QWORD *)sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8));
    if ( !v10 )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v14 + 16))(v14);
      v10 = (_QWORD *)sub_68488BC(v14);
    }
  }
  sub_3C2763C(&v23, v10);
  v15 = v23;
  v16 = v24;
  v23 = 0LL;
  v24 = 0LL;
  v17 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 32) = v15;
  *(_QWORD *)(a1 + 40) = v16;
  if ( v17 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v17 + 8)) )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 16LL))(v17);
    sub_68488BC((unsigned __int64 *)v17);
  }
  v18 = (unsigned __int64 *)v24;
  if ( v24 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v18 + 16))(v18);
    sub_68488BC(v18);
  }
  qword_6DE6450 = a1;
  v19 = sub_65ECAAC();
  *(_QWORD *)(v19 + 32) = 0LL;
  qword_6DE6458 = v19;
  v25[0] = off_6958AF0;
  *(_OWORD *)v19 = 0u;
  *(_OWORD *)(v19 + 16) = 0u;
  v26 = v25;
  sub_62CEFD0(&v23, v25);
  if ( (sub_65F43C0(v2, &v23) & 1) != 0 )
  {
    sub_65F3D60(v2);
    sub_65F44E8(v2, &v23);
  }
  v20 = v23;
  if ( v23 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFFLL, v23 + 4) == 1 )
      sub_65F582C(v20);
  }
  result = (__int64)v26;
  if ( v25 == v26 )
  {
    v22 = 4LL;
  }
  else
  {
    if ( !v26 )
      return result;
    v22 = 5LL;
  }
  return (*(__int64 (**)(void))(*v26 + 8 * v22))();
}


================================================================================
Function: sub_3C2742C (0x3C2742C)
================================================================================

__int64 __usercall sub_3C2742C@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  _QWORD *v3; // x20
  __int64 v4; // x20
  _QWORD *v5; // x21
  __int64 result; // x0

  if ( byte_724A7A8 )
    v2 = byte_7301120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = (_QWORD *)sub_65ECAAC();
    v3[1] = 0LL;
    v3[2] = 0LL;
    *v3 = off_6958960;
    result = sub_3C27820(v3 + 3);
    *a1 = v3 + 3;
    a1[1] = v3;
  }
  else
  {
    v4 = sub_680599C();
    v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 216LL, 8LL);
    v5[2] = 0LL;
    v5[3] = v4;
    *v5 = off_6958910;
    v5[1] = 0LL;
    result = sub_3C27820(v5 + 4);
    *a1 = v5 + 4;
    a1[1] = v5;
  }
  return result;
}


================================================================================
Function: sub_3C27534 (0x3C27534)
================================================================================

__int64 __usercall sub_3C27534@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  _QWORD *v3; // x20
  __int64 v4; // x20
  _QWORD *v5; // x21
  __int64 result; // x0

  if ( byte_724A7A8 )
    v2 = byte_7301120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = (_QWORD *)sub_65ECAAC();
    v3[1] = 0LL;
    v3[2] = 0LL;
    *v3 = off_6958A00;
    result = sub_3C27B48(v3 + 3);
    *a1 = v3 + 3;
    a1[1] = v3;
  }
  else
  {
    v4 = sub_680599C();
    v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 280LL, 8LL);
    v5[2] = 0LL;
    v5[3] = v4;
    *v5 = off_69589B0;
    v5[1] = 0LL;
    result = sub_3C27B48(v5 + 4);
    *a1 = v5 + 4;
    a1[1] = v5;
  }
  return result;
}


================================================================================
Function: sub_3C2763C (0x3C2763C)
================================================================================

_QWORD *__usercall sub_3C2763C@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  __int64 v3; // x20
  __int64 v4; // x20
  __int64 v5; // x21
  _QWORD *result; // x0

  if ( byte_724A7A8 )
    v2 = byte_7301120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = sub_65ECAAC();
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_DWORD *)(v3 + 24) = 0;
    *(_QWORD *)(v3 + 40) = 0LL;
    *(_QWORD *)(v3 + 48) = 0LL;
    *(_QWORD *)v3 = off_6958AA0;
    *(_QWORD *)(v3 + 32) = 0LL;
    result = (_QWORD *)sub_65ECAAC();
    *result = 0LL;
    result[1] = 0LL;
    *(_QWORD *)(v3 + 32) = result;
    *(_QWORD *)(v3 + 40) = result + 2;
    *(_QWORD *)(v3 + 48) = result + 2;
    *a1 = v3 + 24;
    a1[1] = v3;
  }
  else
  {
    v4 = sub_680599C();
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 64LL, 8LL);
    *(_QWORD *)(v5 + 16) = 0LL;
    *(_QWORD *)(v5 + 24) = v4;
    *(_QWORD *)(v5 + 48) = 0LL;
    *(_QWORD *)(v5 + 56) = 0LL;
    *(_QWORD *)v5 = off_6958A50;
    *(_QWORD *)(v5 + 8) = 0LL;
    *(_DWORD *)(v5 + 32) = 0;
    *(_QWORD *)(v5 + 40) = 0LL;
    result = (_QWORD *)sub_65ECAAC();
    *(_QWORD *)(v5 + 40) = result;
    *a1 = v5 + 32;
    a1[1] = v5;
    *(_QWORD *)(v5 + 56) = result + 2;
    *result = 0LL;
    result[1] = 0LL;
    *(_QWORD *)(v5 + 48) = result + 2;
  }
  return result;
}


================================================================================
Function: sub_3C27820 (0x3C27820)
================================================================================

long double __fastcall sub_3C27820(_BYTE *a1)
{
  _BYTE *v1; // x19
  long double result; // q0

  v1 = a1;
  *a1 = 1;
  sub_3C0D21C();
  *(_OWORD *)(v1 + 24) = 0u;
  *((_QWORD *)v1 + 7) = 0LL;
  *(_OWORD *)(v1 + 40) = 0u;
  sub_649F0D0(v1 + 64);
  *(_OWORD *)&result = 0uLL;
  *((_QWORD *)v1 + 21) = 0LL;
  *((_QWORD *)v1 + 22) = 0LL;
  v1 += 168;
  *((_QWORD *)v1 - 1) = v1;
  *(_OWORD *)(v1 - 88) = 0u;
  *(_OWORD *)(v1 - 72) = 0u;
  *(_OWORD *)(v1 - 56) = 0u;
  *(_OWORD *)(v1 - 40) = 0u;
  *(_OWORD *)(v1 - 24) = 0u;
  return result;
}


================================================================================
Function: sub_3C27B48 (0x3C27B48)
================================================================================

long double __fastcall sub_3C27B48(__int64 a1)
{
  long double result; // q0

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_DWORD *)(a1 + 112) = 1065353216;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 152) = 1065353216;
  strcpy((char *)sub_65ECAAC(), "EventIngest TimerThread");
  sub_3C07388();
  sub_684A438(*(_QWORD *)(a1 + 160) + 48LL);
  sub_65ECAF4();
  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)(a1 + 240) = 0LL;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  return result;
}


================================================================================
Function: sub_3C2A5F8 (0x3C2A5F8)
================================================================================

_QWORD *__fastcall sub_3C2A5F8(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // x22
  __int64 v3; // x23
  __int64 v6; // x21
  __int64 v7; // x21

  v3 = *a2;
  v2 = a2[1];
  if ( v2 )
    sub_6867390(1u, (atomic_uint *)(v2 + 8));
  v6 = a1[1];
  *a1 = v3;
  a1[1] = v2;
  if ( v6 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v6 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  v7 = a2[1];
  *a2 = 0LL;
  a2[1] = 0LL;
  if ( v7 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
    }
  }
  return a1;
}


================================================================================
Function: sub_3C2AE38 (0x3C2AE38)
================================================================================

_QWORD *__fastcall sub_3C2AE38(__int64 a1, __int64 a2, __int64 *a3)
{
  _QWORD *result; // x0
  __int64 v7; // x21

  result = (_QWORD *)sub_65ECAAC();
  v7 = *a3;
  result[2] = a2;
  *a3 = (__int64)result;
  *result = off_6958E98;
  result[1] = 0x100000001LL;
  if ( v7 )
  {
    result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
      result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 12));
      if ( (_DWORD)result == 1 )
        result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
    }
  }
  if ( a2 )
    return (_QWORD *)sub_3C2AF58(a2 + 8, a1, a2);
  return result;
}


================================================================================
Function: sub_3C2AF58 (0x3C2AF58)
================================================================================

_QWORD *__fastcall sub_3C2AF58(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x20
  __int64 v5; // x8
  __int64 v7; // x19
  __int64 v8; // x8
  __int64 v9; // x22

  v4 = result;
  v5 = result[1];
  if ( v5 )
  {
    if ( atomic_load((unsigned int *)(v5 + 8)) )
      return result;
  }
  v7 = *(_QWORD *)(a2 + 8);
  if ( v7 )
  {
    sub_6867390(1u, (atomic_uint *)(v7 + 8));
    v8 = v4[1];
    *v4 = a3;
    if ( v7 == v8 )
      goto LABEL_11;
    sub_6867390(1u, (atomic_uint *)(v7 + 12));
    v9 = v4[1];
    if ( !v9 )
    {
      v4[1] = v7;
LABEL_11:
      result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
        result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 12));
        if ( (_DWORD)result == 1 )
          return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
      }
      return result;
    }
  }
  else
  {
    v9 = result[1];
    *result = a3;
    if ( !v9 )
      return result;
  }
  result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v9 + 12));
  if ( (_DWORD)result == 1 )
    result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 24LL))(v9);
  v4[1] = v7;
  if ( v7 )
    goto LABEL_11;
  return result;
}


================================================================================
Function: sub_3C2B05C (0x3C2B05C)
================================================================================

__int64 __fastcall sub_3C2B05C(__int64 *a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 v3; // x8
  __int64 v6; // x0
  __int64 result; // x0
  __int64 v8; // x11
  __int64 v9; // x10
  __int64 v10; // x13
  int v11; // s0
  int v12; // s1
  __int64 v13; // x13
  __int64 v14; // x10
  __int64 v15; // x12
  unsigned __int64 v16; // x12
  unsigned __int64 v17; // x11
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x9

  v2 = *a1;
  *a1 = 0LL;
  v3 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0LL;
  v6 = *a1;
  *a1 = v3;
  if ( v6 )
    sub_65ECAF4();
  result = *(_QWORD *)a2;
  *(_QWORD *)a2 = v2;
  if ( result )
    result = sub_65ECAF4();
  v8 = a1[2];
  v9 = *(_QWORD *)(a2 + 8);
  v10 = a1[1];
  v11 = *((_DWORD *)a1 + 8);
  a1[2] = *(_QWORD *)(a2 + 16);
  a1[1] = v9;
  v12 = *(_DWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 8) = v10;
  v13 = *(_QWORD *)(a2 + 24);
  v14 = a1[3];
  *(_QWORD *)(a2 + 16) = v8;
  *((_DWORD *)a1 + 8) = v12;
  a1[3] = v13;
  *(_QWORD *)(a2 + 24) = v14;
  v15 = a1[3];
  *(_DWORD *)(a2 + 32) = v11;
  if ( v15 )
  {
    v16 = a1[1];
    v17 = *(_QWORD *)(a1[2] + 8);
    if ( (v16 & (v16 - 1)) != 0 )
    {
      if ( v17 >= v16 )
        v17 %= v16;
    }
    else
    {
      v17 &= v16 - 1;
    }
    *(_QWORD *)(*a1 + 8 * v17) = a1 + 2;
  }
  if ( v14 )
  {
    v18 = *(_QWORD *)(a2 + 8);
    v19 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8LL);
    if ( (v18 & (v18 - 1)) != 0 )
    {
      if ( v19 >= v18 )
        v19 %= v18;
    }
    else
    {
      v19 &= v18 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a2 + 8 * v19) = a2 + 16;
  }
  return result;
}


================================================================================
Function: sub_3C2E9B4 (0x3C2E9B4)
================================================================================

__int64 __fastcall sub_3C2E9B4(__int128 *a1, unsigned __int8 *a2, unsigned __int8 *a3, char a4, char a5)
{
  char *v9; // x1
  unsigned __int64 v10; // x2
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x9
  __int128 *v15; // x10
  unsigned __int64 v16; // x13
  bool v17; // zf
  size_t v18; // x13
  void *v19; // x3
  size_t v20; // x4
  _BYTE *v21; // x1
  size_t v22; // x2
  __int64 v23; // x8
  __int64 result; // x0
  unsigned __int64 *v25; // x19
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x9
  __int128 *v29; // x2
  unsigned __int64 v30; // x8
  __int64 **v31; // x21
  __int64 v32; // x0
  unsigned __int64 *v33; // x21
  __int64 *v34; // x22
  __int64 v35; // [xsp+0h] [xbp-210h] BYREF
  __int64 v36; // [xsp+8h] [xbp-208h]
  unsigned __int64 v37[3]; // [xsp+10h] [xbp-200h] BYREF
  int v38[2]; // [xsp+28h] [xbp-1E8h] BYREF
  __int64 v39; // [xsp+30h] [xbp-1E0h]
  char v40; // [xsp+38h] [xbp-1D8h]
  __int64 v41; // [xsp+50h] [xbp-1C0h]
  __int64 **v42; // [xsp+60h] [xbp-1B0h]
  char v43; // [xsp+78h] [xbp-198h]
  _QWORD v44[2]; // [xsp+F0h] [xbp-120h] BYREF
  _QWORD v45[2]; // [xsp+100h] [xbp-110h] BYREF
  _QWORD *v46; // [xsp+110h] [xbp-100h]
  __int128 v47; // [xsp+140h] [xbp-D0h]
  __int128 v48; // [xsp+150h] [xbp-C0h]
  int v49; // [xsp+160h] [xbp-B0h]
  _QWORD v50[18]; // [xsp+168h] [xbp-A8h] BYREF
  int v51; // [xsp+1F8h] [xbp-18h]

  if ( (a4 & 1) != 0 )
    sub_65F13AC("%s?%s", v37);
  else
    sub_68497A0(v37, a1);
  if ( byte_724A7A8 && byte_6DE65A8 )
  {
    sub_62CA3FC(v38, 0LL);
    if ( (v37[0] & 1) != 0 )
      v9 = (char *)v37[2];
    else
      v9 = (char *)v37 + 1;
    if ( (v37[0] & 1) != 0 )
      v10 = v37[1];
    else
      v10 = (unsigned __int64)LOBYTE(v37[0]) >> 1;
    sub_62CB67C(*(_QWORD *)v38, v9, v10);
    *(_DWORD *)(*(_QWORD *)v38 + 452LL) = 23;
    sub_62CC248();
    if ( (a4 & 1) == 0 )
    {
      sub_62CBF28(*(_QWORD *)v38);
      v11 = *a2;
      if ( (v11 & 1) != 0 )
        v12 = *((_QWORD *)a2 + 1);
      else
        v12 = v11 >> 1;
      sub_62CC678(*(_QWORD *)v38, a2, v12 > 0x100);
      v13 = *a3;
      if ( (v13 & 1) != 0 )
        v14 = *((_QWORD *)a3 + 1);
      else
        v14 = v13 >> 1;
      if ( v14 )
        v15 = (__int128 *)a3;
      else
        v15 = &xmmword_6FF20F0;
      v16 = *(unsigned __int8 *)v15;
      v17 = (v16 & 1) == 0;
      v18 = v16 >> 1;
      if ( v17 )
        v19 = (char *)v15 + 1;
      else
        v19 = (void *)*((_QWORD *)v15 + 2);
      if ( v17 )
        v20 = v18;
      else
        v20 = *((_QWORD *)v15 + 1);
      if ( (byte_6FF1DE8 & 1) != 0 )
        v21 = (_BYTE *)unk_6FF1DF8;
      else
        v21 = algn_6FF1DE9;
      if ( (byte_6FF1DE8 & 1) != 0 )
        v22 = qword_6FF1DF0;
      else
        v22 = (unsigned __int64)(unsigned __int8)byte_6FF1DE8 >> 1;
      sub_62CAF24(v38[0], v21, v22, v19, v20);
    }
    v46 = v44;
    v44[0] = off_69590B0;
    (***(void (__fastcall ****)(_QWORD, _QWORD *))v38)(*(_QWORD *)v38, v44);
    if ( v44 == v46 )
    {
      v23 = 4LL;
    }
    else
    {
      if ( !v46 )
      {
LABEL_44:
        result = sub_62CC324(*(_QWORD *)v38, 3000LL);
        v25 = (unsigned __int64 *)v39;
        if ( v39 )
        {
          result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v39 + 8));
          if ( !result )
          {
            (*(void (__fastcall **)(unsigned __int64 *))(*v25 + 16))(v25);
            result = sub_68488BC(v25);
          }
        }
        goto LABEL_68;
      }
      v23 = 5LL;
    }
    (*(void (**)(void))(*v46 + 8 * v23))();
    goto LABEL_44;
  }
  v50[0] = off_6887558;
  v44[0] = off_6887530;
  v44[1] = 0LL;
  sub_681F548((__int64)v50, (__int64)v45);
  v50[17] = 0LL;
  v51 = -1;
  v44[0] = off_68874C0;
  v50[0] = off_68874E8;
  sub_681C128((__int64)v45);
  v49 = 8;
  v47 = 0u;
  v48 = 0u;
  v45[0] = off_6874A98;
  sub_26D904C((__int64)v45);
  v35 = qword_72FB4D8;
  v36 = qword_72FB4E0;
  if ( qword_72FB4E0 )
    sub_6867420(1uLL, (atomic_ullong *)(qword_72FB4E0 + 8));
  sub_628BB58(v38, v37, 23LL, 0LL);
  if ( (a4 & 1) != 0 )
  {
    sub_628DEB4((int)v38, (int)&v35, 0, 0, 1);
  }
  else
  {
    v26 = *a3;
    v17 = (v26 & 1) == 0;
    v27 = v26 >> 1;
    if ( !v17 )
      v27 = *((_QWORD *)a3 + 1);
    v28 = *a2;
    if ( v27 )
      v29 = (__int128 *)a3;
    else
      v29 = &xmmword_6FF20F0;
    v30 = v28 >> 1;
    if ( (v28 & 1) != 0 )
      v30 = *((_QWORD *)a2 + 1);
    ((void (__fastcall *)(int *, _QWORD *, __int128 *, bool, __int64 *, _QWORD, _QWORD, __int64))sub_628C134)(
      v38,
      v44,
      v29,
      v30 > 0x100,
      &v35,
      a5 & 1,
      0LL,
      1LL);
  }
  if ( (v43 & 1) != 0 )
    sub_65ECAF4();
  v31 = v42;
  if ( v42 )
  {
    do
    {
      v34 = *v31;
      if ( ((_BYTE)v31[5] & 1) != 0 )
        sub_65ECAF4();
      if ( ((_BYTE)v31[2] & 1) != 0 )
        sub_65ECAF4();
      sub_65ECAF4();
      v31 = (__int64 **)v34;
    }
    while ( v34 );
  }
  v32 = v41;
  v41 = 0LL;
  if ( v32 )
    sub_65ECAF4();
  if ( (v40 & 1) != 0 )
    sub_65ECAF4();
  v33 = (unsigned __int64 *)v36;
  if ( v36 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v36 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v33 + 16))(v33);
    sub_68488BC(v33);
  }
  v50[0] = off_68874E8;
  v44[0] = off_68874C0;
  v45[0] = off_6874A98;
  if ( (v47 & 1) != 0 )
    sub_65ECAF4();
  sub_66013A0(v45);
  sub_681C568();
  result = sub_681C034();
LABEL_68:
  if ( (v37[0] & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_3C5188C (0x3C5188C)
================================================================================

__int64 __fastcall sub_3C5188C(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_6867450(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65EFD58(0);
  if ( v2 >> 62 != 2 )
  {
    sub_65EF508(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7301220);
      v5 = sub_65FD0A0(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_3C51AD4(v5);
      sub_6867600(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_6848B0C((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_3C51AD4 (0x3C51AD4)
================================================================================

__int64 sub_3C51AD4()
{
  __int64 v0; // x19

  v0 = sub_65ED63C(0x68uLL);
  sub_629A1A4();
  return v0;
}


================================================================================
Function: sub_3CD3B2C (0x3CD3B2C)
================================================================================

__int64 __fastcall sub_3CD3B2C(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_6867450(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65EFD58(0);
  if ( v2 >> 62 != 2 )
  {
    sub_65EF508(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7301220);
      v5 = sub_65FD0A0(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_3CD3D74(v5);
      sub_6867600(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_6848B0C((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_3CD3D74 (0x3CD3D74)
================================================================================

__int64 sub_3CD3D74()
{
  __int64 v0; // x19

  v0 = sub_65ED63C(0x378uLL);
  sub_3CD3DA4();
  return v0;
}


================================================================================
Function: sub_3CD3DA4 (0x3CD3DA4)
================================================================================

long double __fastcall sub_3CD3DA4(__int64 a1)
{
  long double result; // q0

  *(_QWORD *)a1 = "BatchedReporterManager";
  *(_QWORD *)(a1 + 8) = 22LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = a1 + 24;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = off_6C1BAD8;
  *(_DWORD *)(a1 + 92) = 2;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 1065353216;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_DWORD *)(a1 + 184) = 1065353216;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_QWORD *)(a1 + 240) = sub_65F7CCC();
  sub_3CD3FFC(a1 + 248);
  *(_QWORD *)(a1 + 472) = 0LL;
  *(_QWORD *)(a1 + 480) = 0LL;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_DWORD *)(a1 + 468) = 1;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_QWORD *)(a1 + 456) = &off_6C1B970;
  *(_QWORD *)(a1 + 568) = off_6960AA8;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_DWORD *)(a1 + 520) = 1065353216;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_QWORD *)(a1 + 560) = 0LL;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_QWORD *)(a1 + 588) = 0LL;
  *(_QWORD *)(a1 + 580) = 0LL;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_DWORD *)(a1 + 596) = 0;
  *(_QWORD *)(a1 + 712) = 0LL;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_DWORD *)(a1 + 720) = 1065353216;
  *(_DWORD *)(a1 + 760) = 1065353216;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_OWORD *)(a1 + 744) = 0u;
  sub_649F0D0((_QWORD *)(a1 + 768));
  *(_QWORD *)(a1 + 816) = 0LL;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  sub_649F0D0((_QWORD *)(a1 + 824));
  *(_OWORD *)&result = 0uLL;
  *(_OWORD *)(a1 + 866) = 0u;
  *(_OWORD *)(a1 + 840) = 0u;
  *(_OWORD *)(a1 + 856) = 0u;
  return result;
}


================================================================================
Function: sub_3CD3FFC (0x3CD3FFC)
================================================================================

__int64 __fastcall sub_3CD3FFC(__int64 a1)
{
  __int64 result; // x0

  *(_DWORD *)(a1 + 12) = 2;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)a1 = off_6C1BD10;
  sub_3CD4578(a1 + 32);
  *(_OWORD *)(a1 + 152) = 0u;
  *(_QWORD *)(a1 + 184) = 0LL;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_QWORD *)(a1 + 192) = sub_6819D00();
  result = sub_65C67A0();
  *(_QWORD *)(a1 + 200) = result;
  return result;
}


================================================================================
Function: sub_3CD4578 (0x3CD4578)
================================================================================

__int64 __fastcall sub_3CD4578(__int64 a1)
{
  _QWORD *v2; // x0
  _QWORD *v3; // x21
  _QWORD *v4; // x0
  __int64 result; // x0
  __int64 v6; // x19
  __int64 v7; // x20
  char v8; // t1
  __int64 v9; // [xsp+0h] [xbp-20h]
  __int64 v10; // [xsp+8h] [xbp-18h]
  __int64 v11; // [xsp+10h] [xbp-10h]

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 112) = 0LL;
  v2 = (_QWORD *)sub_65ECAAC();
  v2[1] = 0LL;
  v2[2] = 0LL;
  v2[4] = 0LL;
  v2[5] = 0LL;
  v2[3] = 0LL;
  v3 = v2 + 3;
  *v2 = &off_6960A58;
  *(_QWORD *)(a1 + 88) = v2 + 3;
  *(_QWORD *)(a1 + 96) = v2;
  v4 = (_QWORD *)sub_65ECAAC();
  v4[1] = 0LL;
  v4[2] = 0LL;
  *v4 = &off_6960A58;
  v4[4] = 0LL;
  v4[5] = 0LL;
  v4[3] = 0LL;
  *(_QWORD *)(a1 + 104) = v4 + 3;
  *(_QWORD *)(a1 + 112) = v4;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  result = sub_65C63EC(v3);
  v6 = v9;
  if ( v9 )
  {
    if ( v10 != v9 )
    {
      v7 = v10;
      do
      {
        v8 = *(_BYTE *)(v7 - 24);
        v7 -= 24LL;
        if ( (v8 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v7 != v6 );
    }
    v10 = v6;
    return sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_3D7EF98 (0x3D7EF98)
================================================================================

__int64 __fastcall sub_3D7EF98(unsigned __int8 *a1)
{
  unsigned __int64 v2; // x12
  char *v3; // x21
  size_t v4; // x20
  unsigned __int8 *v5; // x0
  unsigned __int64 v6; // x1
  char *v7; // x6
  size_t v8; // x7
  __int64 result; // x0
  __int64 v10; // [xsp+10h] [xbp-D0h] BYREF
  _QWORD v11[2]; // [xsp+28h] [xbp-B8h] BYREF
  __int64 v12; // [xsp+38h] [xbp-A8h]
  _QWORD v13[3]; // [xsp+40h] [xbp-A0h] BYREF
  __int64 v14[2]; // [xsp+58h] [xbp-88h] BYREF
  char v15; // [xsp+70h] [xbp-70h]
  char v16; // [xsp+88h] [xbp-58h]
  char v17; // [xsp+A0h] [xbp-40h]
  char v18; // [xsp+B8h] [xbp-28h]

  sub_649DC84(v13);
  v2 = *a1;
  if ( (v13[0] & 1) != 0 )
    v3 = (char *)v13[2];
  else
    v3 = (char *)v13 + 1;
  if ( (v13[0] & 1) != 0 )
    v4 = v13[1];
  else
    v4 = (unsigned __int64)LOBYTE(v13[0]) >> 1;
  if ( (v2 & 1) != 0 )
    v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  else
    v5 = a1 + 1;
  if ( (v2 & 1) != 0 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v2 >> 1;
  sub_658EC24(&v10, v5, v6);
  sub_65F13AC("apiKey=%s", v11);
  if ( (v11[0] & 1) != 0 )
    LODWORD(v7) = v12;
  else
    v7 = (char *)v11 + 1;
  if ( (v11[0] & 1) != 0 )
    v8 = v11[1];
  else
    v8 = (unsigned __int64)LOBYTE(v11[0]) >> 1;
  sub_658FEF4(
    v14,
    "https",
    5uLL,
    v3,
    v4,
    "/v1.0/SequenceStatistics/BatchAddToSequencesV2",
    0x2EuLL,
    (int)v7,
    v8,
    &byte_CC4FFC,
    0LL);
  result = sub_659046C(v14);
  if ( (v18 & 1) != 0 )
  {
    result = sub_65ECAF4();
    if ( (v17 & 1) == 0 )
    {
LABEL_21:
      if ( (v16 & 1) == 0 )
        goto LABEL_22;
      goto LABEL_31;
    }
  }
  else if ( (v17 & 1) == 0 )
  {
    goto LABEL_21;
  }
  result = sub_65ECAF4();
  if ( (v16 & 1) == 0 )
  {
LABEL_22:
    if ( (v15 & 1) == 0 )
      goto LABEL_23;
    goto LABEL_32;
  }
LABEL_31:
  result = sub_65ECAF4();
  if ( (v15 & 1) == 0 )
  {
LABEL_23:
    if ( (v14[0] & 1) == 0 )
      goto LABEL_24;
    goto LABEL_33;
  }
LABEL_32:
  result = sub_65ECAF4();
  if ( (v14[0] & 1) == 0 )
  {
LABEL_24:
    if ( (v11[0] & 1) == 0 )
      goto LABEL_25;
    goto LABEL_34;
  }
LABEL_33:
  result = sub_65ECAF4();
  if ( (v11[0] & 1) == 0 )
  {
LABEL_25:
    if ( (v10 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_35;
  }
LABEL_34:
  result = sub_65ECAF4();
  if ( (v10 & 1) == 0 )
  {
LABEL_26:
    if ( (v13[0] & 1) == 0 )
      return result;
    return sub_65ECAF4();
  }
LABEL_35:
  result = sub_65ECAF4();
  if ( (v13[0] & 1) == 0 )
    return result;
  return sub_65ECAF4();
}


================================================================================
Function: sub_3D7F204 (0x3D7F204)
================================================================================

__int64 __fastcall sub_3D7F204(unsigned __int8 *a1)
{
  unsigned __int64 v2; // x12
  char *v3; // x21
  size_t v4; // x20
  unsigned __int8 *v5; // x0
  unsigned __int64 v6; // x1
  char *v7; // x6
  size_t v8; // x7
  __int64 result; // x0
  __int64 v10; // [xsp+10h] [xbp-D0h] BYREF
  _QWORD v11[2]; // [xsp+28h] [xbp-B8h] BYREF
  __int64 v12; // [xsp+38h] [xbp-A8h]
  _QWORD v13[3]; // [xsp+40h] [xbp-A0h] BYREF
  __int64 v14[2]; // [xsp+58h] [xbp-88h] BYREF
  char v15; // [xsp+70h] [xbp-70h]
  char v16; // [xsp+88h] [xbp-58h]
  char v17; // [xsp+A0h] [xbp-40h]
  char v18; // [xsp+B8h] [xbp-28h]

  sub_649DC84(v13);
  v2 = *a1;
  if ( (v13[0] & 1) != 0 )
    v3 = (char *)v13[2];
  else
    v3 = (char *)v13 + 1;
  if ( (v13[0] & 1) != 0 )
    v4 = v13[1];
  else
    v4 = (unsigned __int64)LOBYTE(v13[0]) >> 1;
  if ( (v2 & 1) != 0 )
    v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  else
    v5 = a1 + 1;
  if ( (v2 & 1) != 0 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v2 >> 1;
  sub_658EC24(&v10, v5, v6);
  sub_65F13AC("apiKey=%s", v11);
  if ( (v11[0] & 1) != 0 )
    LODWORD(v7) = v12;
  else
    v7 = (char *)v11 + 1;
  if ( (v11[0] & 1) != 0 )
    v8 = v11[1];
  else
    v8 = (unsigned __int64)LOBYTE(v11[0]) >> 1;
  sub_658FEF4(v14, "https", 5uLL, v3, v4, "/v1.1/Counters/BatchIncrement", 0x1DuLL, (int)v7, v8, &byte_CC4FFC, 0LL);
  result = sub_659046C(v14);
  if ( (v18 & 1) != 0 )
  {
    result = sub_65ECAF4();
    if ( (v17 & 1) == 0 )
    {
LABEL_21:
      if ( (v16 & 1) == 0 )
        goto LABEL_22;
      goto LABEL_31;
    }
  }
  else if ( (v17 & 1) == 0 )
  {
    goto LABEL_21;
  }
  result = sub_65ECAF4();
  if ( (v16 & 1) == 0 )
  {
LABEL_22:
    if ( (v15 & 1) == 0 )
      goto LABEL_23;
    goto LABEL_32;
  }
LABEL_31:
  result = sub_65ECAF4();
  if ( (v15 & 1) == 0 )
  {
LABEL_23:
    if ( (v14[0] & 1) == 0 )
      goto LABEL_24;
    goto LABEL_33;
  }
LABEL_32:
  result = sub_65ECAF4();
  if ( (v14[0] & 1) == 0 )
  {
LABEL_24:
    if ( (v11[0] & 1) == 0 )
      goto LABEL_25;
    goto LABEL_34;
  }
LABEL_33:
  result = sub_65ECAF4();
  if ( (v11[0] & 1) == 0 )
  {
LABEL_25:
    if ( (v10 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_35;
  }
LABEL_34:
  result = sub_65ECAF4();
  if ( (v10 & 1) == 0 )
  {
LABEL_26:
    if ( (v13[0] & 1) == 0 )
      return result;
    return sub_65ECAF4();
  }
LABEL_35:
  result = sub_65ECAF4();
  if ( (v13[0] & 1) == 0 )
    return result;
  return sub_65ECAF4();
}


================================================================================
Function: sub_463F040 (0x463F040)
================================================================================

bool __fastcall sub_463F040(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3)
{
  __int64 v5; // x2
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x11
  bool v8; // zf
  unsigned __int64 v9; // x8
  unsigned __int8 *v10; // x27
  unsigned __int64 v11; // x24
  unsigned __int8 *v12; // x25
  unsigned __int64 v13; // x26
  unsigned __int64 v14; // x23
  unsigned __int64 v15; // x22
  unsigned __int8 *v16; // x28
  unsigned int v17; // w20
  __int64 *v18; // x0
  unsigned int v19; // w21
  __int64 v20; // x2
  __int64 *v21; // x0
  unsigned __int64 v22; // x9
  _BOOL4 v23; // w19
  unsigned __int8 *v25; // [xsp+8h] [xbp-18h]
  __int64 v26; // [xsp+10h] [xbp-10h] BYREF

  sub_683B82C(&v26, a3);
  v6 = *a1;
  v7 = *a2;
  v8 = (v6 & 1) == 0;
  v9 = v6 >> 1;
  if ( v8 )
    v10 = a1 + 1;
  else
    v10 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( v8 )
    v11 = v9;
  else
    v11 = *((_QWORD *)a1 + 1);
  if ( (v7 & 1) != 0 )
    v12 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v12 = a2 + 1;
  if ( (v7 & 1) != 0 )
    v13 = *((_QWORD *)a2 + 1);
  else
    v13 = v7 >> 1;
  v25 = v10;
  if ( v11 && v13 )
  {
    v14 = v13 - 1;
    v15 = v11 - 1;
    v16 = v12;
    while ( 1 )
    {
      v17 = *v10;
      v18 = sub_683BBD0(&v26, (__int64)&qword_79D7E58, v5);
      LOBYTE(v17) = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*v18 + 24))(v18, v17);
      v19 = *v16;
      v21 = sub_683BBD0(&v26, (__int64)&qword_79D7E58, v20);
      if ( (unsigned __int8)v17 != (*(unsigned __int8 (__fastcall **)(__int64 *, _QWORD))(*v21 + 24))(v21, v19) )
        break;
      ++v10;
      ++v16;
      if ( v15 )
      {
        v22 = v14;
        --v15;
        --v14;
        if ( v22 )
          continue;
      }
      goto LABEL_21;
    }
    v23 = 0;
  }
  else
  {
    v16 = v12;
LABEL_21:
    v23 = v16 == &v12[v13] && v10 == &v25[v11];
  }
  sub_683B844(&v26);
  return v23;
}


================================================================================
Function: sub_465BAD0 (0x465BAD0)
================================================================================

unsigned __int64 *__fastcall sub_465BAD0(__int64 a1, __int64 a2)
{
  _QWORD *i; // x23

  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_68497A0((unsigned __int64 *)(a1 + 16), (__int128 *)(a2 + 16));
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  sub_252DEFC(a1 + 40, *(_QWORD *)(a2 + 48));
  for ( i = *(_QWORD **)(a2 + 56); i; i = (_QWORD *)*i )
    sub_25B06C8(a1 + 40, i + 2, i + 2);
  return sub_68497A0((unsigned __int64 *)(a1 + 80), (__int128 *)(a2 + 80));
}


================================================================================
Function: sub_5247D84 (0x5247D84)
================================================================================

__int64 __fastcall sub_5247D84(__int64 result, char *a2, char *a3)
{
  __int64 v3; // x8
  unsigned __int64 v5; // x1
  unsigned __int64 v7; // x8
  __int64 *v8; // x20
  _BOOL8 v9; // x11
  __int64 v10; // x8
  _QWORD *v11; // x22
  _QWORD *v12; // x9
  char *v13; // x10
  __int64 v14; // x9
  unsigned __int64 v15; // x10
  _QWORD *v16; // x11
  __int64 v17; // x10

  v3 = (a3 - a2) >> 4;
  v5 = *(_QWORD *)(result + 8);
  v7 = *(_QWORD *)(result + 24) - 0x5555555555555555LL * v3;
  v8 = (__int64 *)result;
  if ( v7 > v5 )
  {
    do
    {
      v9 = v5 > 2;
      if ( !byte_724A4D0 )
        v9 = v5;
      if ( v9 )
        v5 = (3 * v5) >> 1;
      else
        v5 = 4LL;
    }
    while ( v5 < v7 );
    result = sub_5247EB4(result);
  }
  if ( a2 != a3 )
  {
    v10 = v8[3];
    v11 = a2 + 32;
    do
    {
      v14 = *v8;
      v15 = (v8[2] + v10) % (unsigned __int64)v8[1];
      v16 = (_QWORD *)*v11;
      if ( *v11 )
      {
        if ( v11 - 4 == v16 )
        {
          *(_QWORD *)(v14 + 48 * v15 + 32) = v14 + 48 * v15;
          result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v11 + 24LL))(*v11);
          v10 = v8[3];
          goto LABEL_13;
        }
        v17 = v14 + 48 * v15;
        v12 = v11;
        *(_QWORD *)(v17 + 32) = v16;
      }
      else
      {
        v12 = (_QWORD *)(v14 + 48 * v15 + 32);
      }
      *v12 = 0LL;
LABEL_13:
      ++v10;
      v13 = (char *)(v11 + 2);
      v11 += 6;
      v8[3] = v10;
    }
    while ( v13 != a3 );
  }
  return result;
}


================================================================================
Function: sub_5247EB4 (0x5247EB4)
================================================================================

__int64 __fastcall sub_5247EB4(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // x21
  unsigned __int64 v7; // x22
  _QWORD *v8; // x23
  __int64 v9; // x8
  __int64 v10; // x25
  __int64 v11; // x8
  _QWORD *v12; // x26
  _QWORD *v13; // x9
  _QWORD *v14; // x0
  __int64 result; // x0

  if ( is_mul_ok(a2, 0x30uLL) )
    v4 = 48 * a2;
  else
    v4 = -1LL;
  v5 = sub_65EE9A8(v4);
  v6 = v5;
  if ( a1[3] )
  {
    v7 = 0LL;
    v8 = (_QWORD *)(v5 + 32);
    while ( 1 )
    {
      v10 = *a1 + 48 * ((v7 + a1[2]) % a1[1]);
      v12 = (_QWORD *)(v10 + 32);
      v11 = *(_QWORD *)(v10 + 32);
      if ( !v11 )
        break;
      if ( v10 != v11 )
      {
        v13 = (_QWORD *)(v10 + 32);
        *v8 = v11;
LABEL_13:
        *v13 = 0LL;
        goto LABEL_15;
      }
      *v8 = v8 - 4;
      (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)*v12 + 24LL))(*v12, v8 - 4);
LABEL_15:
      v14 = (_QWORD *)*v12;
      if ( v10 == *v12 )
      {
        v9 = 4LL;
      }
      else
      {
        if ( !v14 )
          goto LABEL_8;
        v9 = 5LL;
      }
      (*(void (**)(void))(*v14 + 8 * v9))();
LABEL_8:
      ++v7;
      v8 += 6;
      if ( v7 >= a1[3] )
        goto LABEL_18;
    }
    v13 = v8;
    goto LABEL_13;
  }
LABEL_18:
  result = *a1;
  if ( *a1 )
    result = sub_65EEA20(result);
  a1[1] = a2;
  a1[2] = 0LL;
  *a1 = v6;
  return result;
}


================================================================================
Function: sub_535EF40 (0x535EF40)
================================================================================

unsigned __int64 *__fastcall sub_535EF40(unsigned __int64 *a1, char *src, char *a3)
{
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x10
  size_t v7; // x22
  unsigned __int64 v8; // x1
  size_t v9; // x21
  unsigned __int64 v10; // x8
  unsigned __int64 v12; // x10
  char *v13; // x22
  char *v14; // x11
  char *v15; // x8
  char *v16; // x9
  char *v17; // x1
  size_t v18; // x2
  __int128 *v19; // x12
  char *v20; // x11
  unsigned __int64 v21; // x13
  __int128 v22; // q0
  __int128 v23; // q1
  char v24; // t1
  size_t v25; // x8
  unsigned __int64 v27; // [xsp+0h] [xbp-20h] BYREF
  size_t v28; // [xsp+8h] [xbp-18h]
  char *v29; // [xsp+10h] [xbp-10h]

  v5 = *a1;
  v6 = *(unsigned __int8 *)a1;
  if ( (v6 & 1) != 0 )
    v7 = a1[1];
  else
    v7 = v6 >> 1;
  if ( (v6 & 1) != 0 )
    v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v8 = 22LL;
  v9 = a3 - src;
  if ( a3 == src )
    return a1;
  v10 = a1[2];
  if ( (v6 & 1) != 0 )
    v12 = a1[2];
  else
    v12 = (unsigned __int64)a1 + 1;
  if ( v12 > (unsigned __int64)src || v12 + v7 <= (unsigned __int64)src )
  {
    if ( v8 - v7 < v9 )
    {
      sub_68499C0((__int64)a1, v8, v7 + v9 - v8, v7, v7, 0LL, 0LL);
      LOBYTE(v5) = *(_BYTE *)a1;
      v10 = a1[2];
    }
    if ( (v5 & 1) != 0 )
      v14 = (char *)v10;
    else
      v14 = (char *)a1 + 1;
    v15 = &v14[v7];
    if ( src == a3 )
      goto LABEL_42;
    if ( v9 >= 0x20 )
    {
      if ( v15 >= a3 || &v14[&a3[v7] - src] <= src )
      {
        v15 += v9 & 0xFFFFFFFFFFFFFFE0LL;
        v16 = &src[v9 & 0xFFFFFFFFFFFFFFE0LL];
        v19 = (__int128 *)(src + 16);
        v20 = &v14[v7 + 16];
        v21 = v9 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v22 = *(v19 - 1);
          v23 = *v19;
          v19 += 2;
          v21 -= 32LL;
          *((_OWORD *)v20 - 1) = v22;
          *(_OWORD *)v20 = v23;
          v20 += 32;
        }
        while ( v21 );
        if ( v9 == (v9 & 0xFFFFFFFFFFFFFFE0LL) )
          goto LABEL_42;
      }
      else
      {
        v16 = src;
      }
    }
    else
    {
      v16 = src;
    }
    do
    {
      v24 = *v16++;
      *v15++ = v24;
    }
    while ( v16 != a3 );
LABEL_42:
    *v15 = 0;
    v25 = v7 + v9;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v25;
    else
      *(_BYTE *)a1 = 2 * v25;
    return a1;
  }
  if ( v9 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( v9 <= 0x16 )
  {
    v13 = (char *)&v27 + 1;
    LOBYTE(v27) = 2 * v9;
    if ( src == a3 )
      goto LABEL_27;
    goto LABEL_26;
  }
  v13 = (char *)sub_65ECAAC();
  v28 = v9;
  v29 = v13;
  v27 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  if ( src != a3 )
  {
LABEL_26:
    memcpy(v13, src, v9);
    v13 += v9;
  }
LABEL_27:
  *v13 = 0;
  if ( (v27 & 1) != 0 )
    v17 = v29;
  else
    v17 = (char *)&v27 + 1;
  if ( (v27 & 1) != 0 )
    v18 = v28;
  else
    v18 = (unsigned __int64)(unsigned __int8)v27 >> 1;
  sub_65FFB9C(a1, v17, v18);
  if ( (v27 & 1) != 0 )
    sub_65ECAF4();
  return a1;
}


================================================================================
Function: sub_53DCA98 (0x53DCA98)
================================================================================

__int64 __fastcall sub_53DCA98(__int64 a1, char a2, unsigned int *a3, __int64 a4)
{
  __int64 v5; // x20
  int v6; // w8
  unsigned int v7; // w8
  unsigned __int64 v8; // x9
  __int16 v10; // w9
  _BYTE *v11; // x19
  char v12; // w8
  unsigned __int64 v13; // x24
  unsigned __int64 v14; // x22
  __int64 v15; // x8
  __int64 v16; // x22
  __int64 v17; // x1
  __int64 v18; // x9
  __int64 v19; // [xsp+0h] [xbp-10h] BYREF

  v5 = a1;
  v6 = *((unsigned __int8 *)a3 + 8);
  if ( (unsigned int)(v6 - 1) >= 6 )
  {
    if ( *((_BYTE *)a3 + 8) && v6 != 15 )
      sub_68070E4(&v19, "invalid type specifier");
    v10 = *(_WORD *)((char *)a3 + 9);
    if ( (v10 & 0xF) == 4 || (v10 & 0x70) != 0 || (v10 & 0x80) != 0 )
      sub_68070E4(&v19, "invalid format specifier for char");
    v11 = (char *)a3 + 11;
    v12 = byte_1027499[v10 & 0xF];
    if ( *a3 )
      v13 = *a3 - 1LL;
    else
      v13 = 0LL;
    v14 = v13 >> v12;
    if ( v13 >> v12 )
      v5 = sub_250EF44(a1, v13 >> v12, v11);
    v15 = *(_QWORD *)(v5 + 16);
    v16 = v13 - v14;
    v17 = v15 + 1;
    if ( *(_QWORD *)(v5 + 24) < (unsigned __int64)(v15 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v5)(v5);
      v15 = *(_QWORD *)(v5 + 16);
      v17 = v15 + 1;
    }
    v18 = *(_QWORD *)(v5 + 8);
    *(_QWORD *)(v5 + 16) = v17;
    *(_BYTE *)(v18 + v15) = a2;
    if ( v16 )
      return sub_250EF44(v5, v16, v11);
    else
      return v5;
  }
  else
  {
    v7 = a2;
    if ( a2 < 0 )
    {
      v7 = -a2;
      v8 = 0x100002D00000000LL;
    }
    else
    {
      v8 = (unsigned __int64)dword_AFDED0[((unsigned __int64)*(unsigned __int16 *)((char *)a3 + 9) >> 4) & 7] << 32;
    }
    return sub_53DCC60(a1, v8 | v7, a3, a4);
  }
}


================================================================================
Function: sub_53DCC60 (0x53DCC60)
================================================================================

__int64 __fastcall sub_53DCC60(__int64 a1, unsigned __int64 a2, unsigned int *a3, __int64 a4)
{
  int v4; // w23
  unsigned int v6; // w20
  __int64 v7; // x19
  unsigned __int64 v8; // x21
  __int16 v9; // w10
  unsigned __int64 v10; // x8
  unsigned int v11; // w12
  __int64 v12; // x23
  unsigned __int64 v13; // x11
  unsigned __int64 v14; // x23
  unsigned __int64 v15; // x9
  unsigned int v16; // w10
  unsigned __int64 v17; // x11
  __int16 v18; // w10
  int v19; // w8
  unsigned __int64 v20; // x8
  int v21; // w11
  __int64 v22; // x25
  unsigned int v23; // w10
  unsigned __int64 v24; // x9
  unsigned __int64 v25; // x11
  bool v26; // cc
  unsigned __int64 v27; // x26
  __int16 v28; // w11
  int v29; // w8
  unsigned __int64 v30; // x8
  int v31; // w12
  __int64 v32; // x25
  unsigned __int64 v33; // x10
  unsigned int v34; // w11
  unsigned __int64 v35; // x12
  __int16 v36; // w11
  int v37; // w9
  __int64 v38; // x25
  int v40; // w8
  unsigned __int64 v41; // x8
  unsigned int v42; // w11
  unsigned __int64 v43; // x10
  unsigned __int64 v44; // x9
  bool v45; // cc
  unsigned __int64 v46; // x26
  __int64 v47; // x9
  bool v48; // cf
  unsigned __int64 v49; // x9
  unsigned __int64 v50; // x25
  char v51; // w8
  unsigned __int64 v52; // x23
  __int64 v53; // x8
  __int64 v54; // x1
  __int64 v55; // x9
  unsigned int v57; // w21
  __int64 v58; // x8
  __int64 v59; // x10
  _BYTE *v60; // x8
  char v61; // w10
  __int64 v62; // x9
  __int64 v63; // x8
  __int64 v64; // x1
  unsigned int v65; // w21
  __int64 v66; // x8
  __int64 v67; // x9
  __int64 v68; // x9
  const char *v69; // x8
  _BYTE *v70; // x9
  __int64 v71; // x10
  __int64 v72; // x9
  __int64 v73; // x8
  __int64 v74; // x1
  char *v75; // x1
  char *v76; // x8
  char v77; // w10
  const char *v78; // x8
  char *v79; // x9
  __int64 v80; // x10
  unsigned int v81; // w21
  __int64 v82; // x8
  __int64 v83; // x10
  _BYTE *v84; // x8
  char v85; // w10
  __int64 v86; // x9
  __int64 v87; // x8
  __int64 v88; // x1
  unsigned int v89; // w21
  char *v90; // x8
  unsigned int v91; // w14
  unsigned int v92; // w9
  unsigned int v93; // w13
  __int64 v94; // x9
  __int64 v95; // x8
  __int64 v96; // x1
  unsigned __int64 v97; // x8
  unsigned __int64 v98; // x27
  _BYTE *v99; // x22
  char v100; // w10
  unsigned __int64 v101; // x23
  unsigned int v102; // w21
  __int64 v103; // x9
  __int64 v104; // x8
  __int64 v105; // x1
  __int64 v106; // x9
  __int64 v107; // x8
  __int64 v108; // x1
  __int64 v109; // x8
  __int64 v110; // x21
  __int64 v111; // x10
  _BYTE *v112; // x8
  char v113; // w10
  char *v114; // x1
  char *v115; // x8
  char v116; // w10
  bool v117; // vf
  _BYTE *v118; // x20
  char v119; // w11
  unsigned __int64 v120; // x8
  __int64 v121; // x21
  char *v122; // x8
  char v123; // w10
  unsigned __int64 v125; // x8
  unsigned __int64 v126; // x27
  char v127; // w9
  unsigned __int64 v128; // x23
  unsigned int v129; // w21
  __int64 v130; // x9
  __int64 v131; // x8
  __int64 v132; // x1
  __int64 v133; // x9
  __int64 v134; // x8
  __int64 v135; // x1
  __int64 v136; // x8
  __int64 v137; // x10
  _BYTE *v138; // x8
  char v139; // w10
  char *v140; // x8
  char v141; // w10
  __int64 v142; // x0
  __int64 v143; // x1
  _BYTE *v144; // x2
  unsigned __int64 v145; // x8
  char v146; // w10
  _DWORD v147[2]; // [xsp+0h] [xbp-30h] BYREF
  unsigned __int64 v148; // [xsp+8h] [xbp-28h]
  unsigned __int64 v149; // [xsp+10h] [xbp-20h]
  unsigned __int64 v150; // [xsp+18h] [xbp-18h]
  bool v151; // [xsp+20h] [xbp-10h]

  v4 = *((unsigned __int8 *)a3 + 8);
  v6 = a2;
  v7 = a1;
  v8 = HIDWORD(a2);
  switch ( *((_BYTE *)a3 + 8) )
  {
    case 0:
    case 1:
      v9 = *(_WORD *)((char *)a3 + 9);
      if ( (v9 & 0x100) != 0 )
      {
        sub_53DD748((__int64)v147, a4, 1);
        v7 = sub_53DD848(v7, v6, (unsigned int)v8, a3, v147);
        if ( (v147[0] & 1) != 0 )
          sub_65ECAF4();
        return v7;
      }
      v10 = *a3;
      v11 = a3[1];
      v12 = qword_10275E8[__clz(a2 | 1) ^ 0x1F] + (unsigned int)a2;
      if ( !((v11 + 1) | (unsigned int)v10) )
      {
        if ( HIDWORD(a2) )
        {
          v89 = HIDWORD(a2) & 0xFFFFFF;
          if ( (a2 & 0xFFFFFF00000000LL) != 0 )
          {
            do
            {
              v95 = *(_QWORD *)(v7 + 16);
              v96 = v95 + 1;
              if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v95 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v7)(v7);
                v95 = *(_QWORD *)(v7 + 16);
                v96 = v95 + 1;
              }
              v94 = *(_QWORD *)(v7 + 8);
              *(_QWORD *)(v7 + 16) = v96;
              v26 = v89 > 0xFF;
              *(_BYTE *)(v94 + v95) = v89;
              v89 >>= 8;
            }
            while ( v26 );
          }
        }
        v75 = (char *)v147 + (v12 >> 32);
        if ( v6 < 0x64 )
        {
          v90 = (char *)v147 + (v12 >> 32);
          v92 = v6;
          if ( v6 <= 9 )
          {
LABEL_117:
            *(v90 - 1) = v92 + 48;
            return sub_53DDE58((unsigned __int64)v147, (__int64)v75, v7);
          }
        }
        else
        {
          v90 = (char *)v147 + (v12 >> 32);
          do
          {
            v91 = v6 >> 4;
            v92 = v6 / 0x64;
            v93 = v6 % 0x64;
            v6 /= 0x64u;
            *((_WORD *)v90 - 1) = *(_WORD *)&a00010203040506_1[2 * v93];
            v90 -= 2;
          }
          while ( v91 > 0x270 );
          if ( v92 <= 9 )
            goto LABEL_117;
        }
        *((_WORD *)v90 - 1) = *(_WORD *)&a00010203040506_1[2 * v92];
        return sub_53DDE58((unsigned __int64)v147, (__int64)v75, v7);
      }
      v13 = HIDWORD(v12);
      v14 = v12 & 0xFFFFFFFF00000000LL | (unsigned int)a2;
      v15 = (unsigned int)(HIBYTE(HIDWORD(a2)) + v13);
      v16 = v9 & 0xF;
      if ( v16 == 4 )
      {
        v17 = v10 - v15;
        if ( (unsigned int)v10 > (unsigned int)v15 )
        {
          v15 = (unsigned int)v10;
        }
        else
        {
          v17 = 0LL;
          v15 = (unsigned int)v15;
        }
      }
      else
      {
        v117 = __OFSUB__(v11, (_DWORD)v13);
        v17 = v11 - (unsigned int)v13;
        if ( ((v17 & 0x80000000) != 0LL) ^ v117 | ((_DWORD)v17 == 0) )
          v17 = 0LL;
        else
          v15 = v11 + HIBYTE(HIDWORD(a2));
      }
      v48 = v10 >= v15;
      v145 = v10 - v15;
      if ( !v48 )
        v145 = 0LL;
      v147[0] = HIDWORD(a2);
      v118 = (char *)a3 + 11;
      v146 = byte_1027588[v16];
      v148 = v15;
      v149 = v17;
      v150 = v14;
      v121 = v145 - (v145 >> v146);
      if ( v145 >> v146 )
        v7 = sub_250EF44(a1, v145 >> v146, (_BYTE *)a3 + 11);
      v7 = sub_53DDFD8(v147, v7);
      if ( !v121 )
        return v7;
LABEL_195:
      v142 = v7;
      v143 = v121;
      v144 = v118;
      return sub_250EF44(v142, v143, v144);
    case 2:
      v36 = *(_WORD *)((char *)a3 + 9);
      v37 = a3[1];
      v38 = (__clz(a2 | 1) ^ 0x1F) / 3 + 1;
      if ( (v36 & 0x80) != 0 && v37 <= (int)v38 && (_DWORD)a2 != 0 )
      {
        if ( HIDWORD(a2) )
          v40 = 12288;
        else
          v40 = 48;
        LODWORD(v8) = (v40 | HIDWORD(a2)) + 0x1000000;
      }
      v41 = *a3;
      if ( (unsigned int)v41 | (v37 + 1) )
      {
        v42 = v36 & 0xF;
        v43 = BYTE3(v8) + (unsigned int)v38;
        if ( v42 == 4 )
        {
          v44 = v41 - v43;
          v45 = (unsigned int)v41 > (unsigned int)v43;
          if ( (unsigned int)v41 <= (unsigned int)v43 )
            v43 = (unsigned int)v43;
          else
            v43 = (unsigned int)v41;
          if ( v45 )
            v46 = v44;
          else
            v46 = 0LL;
        }
        else
        {
          v46 = (unsigned int)(v37 - v38);
          if ( v37 <= (int)v38 )
            v46 = 0LL;
          else
            v43 = BYTE3(v8) + v37;
        }
        v48 = v41 >= v43;
        v125 = v41 - v43;
        if ( v48 )
          v126 = v125;
        else
          v126 = 0LL;
        v99 = (char *)a3 + 11;
        v127 = byte_1027588[v42];
        v128 = v126 >> v127;
        if ( v126 >> v127 )
          v7 = sub_250EF44(a1, v126 >> v127, (_BYTE *)a3 + 11);
        v129 = v8 & 0xFFFFFF;
        if ( v129 )
        {
          do
          {
            v131 = *(_QWORD *)(v7 + 16);
            v132 = v131 + 1;
            if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v131 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v7)(v7);
              v131 = *(_QWORD *)(v7 + 16);
              v132 = v131 + 1;
            }
            v130 = *(_QWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 16) = v132;
            v48 = v129 >= 0x100;
            *(_BYTE *)(v130 + v131) = v129;
            v129 >>= 8;
          }
          while ( v48 );
        }
        for ( ; v46; *(_BYTE *)(v133 + v134) = 48 )
        {
          v134 = *(_QWORD *)(v7 + 16);
          v135 = v134 + 1;
          if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v134 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v7)(v7);
            v134 = *(_QWORD *)(v7 + 16);
            v135 = v134 + 1;
          }
          --v46;
          v133 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v135;
        }
        v136 = *(_QWORD *)(v7 + 16);
        v110 = v126 - v128;
        if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v136 + v38) )
        {
          v137 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v136 + v38;
          if ( v137 )
          {
            v138 = (_BYTE *)(v38 + v136 + v137 - 1);
            do
            {
              v139 = v6 & 7 | 0x30;
              v48 = v6 >= 8;
              v6 >>= 3;
              *v138-- = v139;
            }
            while ( v48 );
            goto LABEL_187;
          }
        }
        v114 = (char *)v147 + v38;
        v140 = (char *)&v147[-1] + v38 + 3;
        do
        {
          v141 = v6 & 7 | 0x30;
          v26 = v6 > 7;
          v6 >>= 3;
          *v140-- = v141;
        }
        while ( v26 );
        goto LABEL_186;
      }
      if ( (_DWORD)v8 )
      {
        v81 = v8 & 0xFFFFFF;
        if ( v81 )
        {
          do
          {
            v87 = *(_QWORD *)(v7 + 16);
            v88 = v87 + 1;
            if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v87 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v7)(v7);
              v87 = *(_QWORD *)(v7 + 16);
              v88 = v87 + 1;
            }
            v86 = *(_QWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 16) = v88;
            v26 = v81 > 0xFF;
            *(_BYTE *)(v86 + v87) = v81;
            v81 >>= 8;
          }
          while ( v26 );
        }
      }
      v82 = *(_QWORD *)(v7 + 16);
      if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v82 + v38) )
      {
        v83 = *(_QWORD *)(v7 + 8);
        *(_QWORD *)(v7 + 16) = v82 + v38;
        if ( v83 )
        {
          v84 = (_BYTE *)(v38 + v82 + v83 - 1);
          do
          {
            v85 = v6 & 7 | 0x30;
            v48 = v6 >= 8;
            v6 >>= 3;
            *v84-- = v85;
          }
          while ( v48 );
          return v7;
        }
      }
      v75 = (char *)v147 + v38;
      v122 = (char *)&v147[-1] + v38 + 3;
      do
      {
        v123 = v6 & 7 | 0x30;
        v26 = v6 > 7;
        v6 >>= 3;
        *v122-- = v123;
      }
      while ( v26 );
      return sub_53DDE58((unsigned __int64)v147, (__int64)v75, v7);
    case 3:
    case 4:
      v28 = *(_WORD *)((char *)a3 + 9);
      if ( (v28 & 0x80) != 0 )
      {
        if ( v4 == 4 )
          v29 = 22576;
        else
          v29 = 30768;
        if ( HIDWORD(a2) )
          v29 <<= 8;
        LODWORD(v8) = (v29 | HIDWORD(a2)) + 0x2000000;
      }
      v30 = *a3;
      v31 = a3[1];
      v32 = 8 - (__clz(a2 | 1) >> 2);
      if ( !((v31 + 1) | (unsigned int)v30) )
      {
        if ( (_DWORD)v8 )
        {
          v65 = v8 & 0xFFFFFF;
          if ( v65 )
          {
            do
            {
              v73 = *(_QWORD *)(v7 + 16);
              v74 = v73 + 1;
              if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v73 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v7)(v7);
                v73 = *(_QWORD *)(v7 + 16);
                v74 = v73 + 1;
              }
              v72 = *(_QWORD *)(v7 + 8);
              *(_QWORD *)(v7 + 16) = v74;
              v26 = v65 > 0xFF;
              *(_BYTE *)(v72 + v73) = v65;
              v65 >>= 8;
            }
            while ( v26 );
          }
        }
        v66 = *(_QWORD *)(v7 + 16);
        if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v66 + v32) )
        {
          v67 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v66 + v32;
          if ( v67 )
          {
            v68 = v66 + v32 + v67;
            if ( v4 == 4 )
              v69 = "0123456789ABCDEF";
            else
              v69 = "0123456789abcdef";
            v70 = (_BYTE *)(v68 - 1);
            do
            {
              v71 = v6 & 0xF;
              v48 = v6 >= 0x10;
              v6 >>= 4;
              *v70-- = v69[v71];
            }
            while ( v48 );
            return v7;
          }
        }
        v78 = "0123456789abcdef";
        v75 = (char *)v147 + v32;
        if ( v4 == 4 )
          v78 = "0123456789ABCDEF";
        v79 = v75 - 1;
        do
        {
          v80 = v6 & 0xF;
          v26 = v6 > 0xF;
          v6 >>= 4;
          *v79-- = v78[v80];
        }
        while ( v26 );
        return sub_53DDE58((unsigned __int64)v147, (__int64)v75, v7);
      }
      v33 = BYTE3(v8) + (unsigned int)v32;
      v34 = v28 & 0xF;
      if ( v34 == 4 )
      {
        v35 = v30 - v33;
        if ( (unsigned int)v30 > (unsigned int)v33 )
        {
          v33 = (unsigned int)v30;
        }
        else
        {
          v35 = 0LL;
          v33 = (unsigned int)v33;
        }
      }
      else if ( v31 <= (int)v32 )
      {
        v35 = 0LL;
      }
      else
      {
        v33 = v31 + BYTE3(v8);
        v35 = (unsigned int)(v31 - v32);
      }
      v147[0] = v8;
      v118 = (char *)a3 + 11;
      v148 = v33;
      v149 = v35;
      v119 = byte_1027588[v34];
      v48 = v30 >= v33;
      v120 = v30 - v33;
      v150 = (unsigned int)a2 | ((unsigned __int64)(v32 & 0xF) << 32);
      if ( !v48 )
        v120 = 0LL;
      v151 = v4 == 4;
      v121 = v120 - (v120 >> v119);
      if ( v120 >> v119 )
        v7 = sub_250EF44(a1, v120 >> v119, (_BYTE *)a3 + 11);
      v7 = sub_53DE164(v147, v7);
      if ( v121 )
        goto LABEL_195;
      return v7;
    case 5:
    case 6:
      v18 = *(_WORD *)((char *)a3 + 9);
      if ( (v18 & 0x80) != 0 )
      {
        if ( v4 == 6 )
          v19 = 16944;
        else
          v19 = 25136;
        if ( HIDWORD(a2) )
          v19 <<= 8;
        LODWORD(v8) = (v19 | HIDWORD(a2)) + 0x2000000;
      }
      v20 = *a3;
      v21 = a3[1];
      v22 = 32 - __clz(a2 | 1);
      if ( (v21 + 1) | (unsigned int)v20 )
      {
        v23 = v18 & 0xF;
        v24 = BYTE3(v8) + (unsigned int)v22;
        if ( v23 == 4 )
        {
          v25 = v20 - v24;
          v26 = (unsigned int)v20 > (unsigned int)v24;
          if ( (unsigned int)v20 <= (unsigned int)v24 )
            v24 = (unsigned int)v24;
          else
            v24 = (unsigned int)v20;
          if ( v26 )
            v27 = v25;
          else
            v27 = 0LL;
        }
        else if ( v21 <= (int)v22 )
        {
          v27 = 0LL;
        }
        else
        {
          v24 = v21 + BYTE3(v8);
          v27 = (unsigned int)(v21 - v22);
        }
        v48 = v20 >= v24;
        v97 = v20 - v24;
        if ( v48 )
          v98 = v97;
        else
          v98 = 0LL;
        v99 = (char *)a3 + 11;
        v100 = byte_1027588[v23];
        v101 = v98 >> v100;
        if ( v98 >> v100 )
          v7 = sub_250EF44(a1, v98 >> v100, (_BYTE *)a3 + 11);
        v102 = v8 & 0xFFFFFF;
        if ( v102 )
        {
          do
          {
            v104 = *(_QWORD *)(v7 + 16);
            v105 = v104 + 1;
            if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v104 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v7)(v7);
              v104 = *(_QWORD *)(v7 + 16);
              v105 = v104 + 1;
            }
            v103 = *(_QWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 16) = v105;
            v48 = v102 >= 0x100;
            *(_BYTE *)(v103 + v104) = v102;
            v102 >>= 8;
          }
          while ( v48 );
        }
        for ( ; v27; *(_BYTE *)(v106 + v107) = 48 )
        {
          v107 = *(_QWORD *)(v7 + 16);
          v108 = v107 + 1;
          if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v107 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v7)(v7);
            v107 = *(_QWORD *)(v7 + 16);
            v108 = v107 + 1;
          }
          --v27;
          v106 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v108;
        }
        v109 = *(_QWORD *)(v7 + 16);
        v110 = v98 - v101;
        if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v109 + v22)
          && (v111 = *(_QWORD *)(v7 + 8), *(_QWORD *)(v7 + 16) = v109 + v22, v111) )
        {
          v112 = (_BYTE *)(v109 + v22 + v111 - 1);
          do
          {
            v113 = v6 & 1 | 0x30;
            v48 = v6 >= 2;
            v6 >>= 1;
            *v112-- = v113;
          }
          while ( v48 );
        }
        else
        {
          v114 = (char *)v147 + v22;
          v115 = (char *)&v147[-1] + v22 + 3;
          do
          {
            v116 = v6 & 1 | 0x30;
            v26 = v6 > 1;
            v6 >>= 1;
            *v115-- = v116;
          }
          while ( v26 );
LABEL_186:
          v7 = sub_53DDE58((unsigned __int64)v147, (__int64)v114, v7);
        }
LABEL_187:
        if ( v110 )
        {
          v142 = v7;
          v143 = v110;
          v144 = v99;
          return sub_250EF44(v142, v143, v144);
        }
        return v7;
      }
      if ( (_DWORD)v8 )
      {
        v57 = v8 & 0xFFFFFF;
        if ( v57 )
        {
          do
          {
            v63 = *(_QWORD *)(v7 + 16);
            v64 = v63 + 1;
            if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v63 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v7)(v7);
              v63 = *(_QWORD *)(v7 + 16);
              v64 = v63 + 1;
            }
            v62 = *(_QWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 16) = v64;
            v26 = v57 > 0xFF;
            *(_BYTE *)(v62 + v63) = v57;
            v57 >>= 8;
          }
          while ( v26 );
        }
      }
      v58 = *(_QWORD *)(v7 + 16);
      if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v58 + v22) )
      {
        v59 = *(_QWORD *)(v7 + 8);
        *(_QWORD *)(v7 + 16) = v58 + v22;
        if ( v59 )
        {
          v60 = (_BYTE *)(v58 + v22 + v59 - 1);
          do
          {
            v61 = v6 & 1 | 0x30;
            v48 = v6 >= 2;
            v6 >>= 1;
            *v60-- = v61;
          }
          while ( v48 );
          return v7;
        }
      }
      v75 = (char *)v147 + v22;
      v76 = (char *)&v147[-1] + v22 + 3;
      do
      {
        v77 = v6 & 1 | 0x30;
        v26 = v6 > 1;
        v6 >>= 1;
        *v76-- = v77;
      }
      while ( v26 );
      return sub_53DDE58((unsigned __int64)v147, (__int64)v75, v7);
    case 0xF:
      v47 = *a3;
      v48 = v47 != 0;
      v49 = v47 - 1;
      if ( v48 )
        v50 = v49;
      else
        v50 = 0LL;
      v51 = byte_1027499[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v52 = v50 >> v51;
      if ( v50 >> v51 )
        v7 = sub_250EF44(a1, v50 >> v51, (_BYTE *)a3 + 11);
      v53 = *(_QWORD *)(v7 + 16);
      v54 = v53 + 1;
      if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v53 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v53 = *(_QWORD *)(v7 + 16);
        v54 = v53 + 1;
      }
      v55 = *(_QWORD *)(v7 + 8);
      *(_QWORD *)(v7 + 16) = v54;
      *(_BYTE *)(v55 + v53) = v6;
      if ( v50 == v52 )
        return v7;
      return sub_250EF44(v7, v50 - v52, (_BYTE *)a3 + 11);
    default:
      sub_6806F24((__int64)"invalid type specifier");
  }
}


================================================================================
Function: sub_53DD748 (0x53DD748)
================================================================================

__int64 __fastcall sub_53DD748(__int64 result, __int64 a2, char a3)
{
  __int64 v3; // x19
  __int64 v4; // x8
  char v5; // w9
  __int128 v6; // [xsp+8h] [xbp-48h] BYREF
  __int64 v7; // [xsp+18h] [xbp-38h]
  char v8; // [xsp+20h] [xbp-30h]
  __int128 v9; // [xsp+28h] [xbp-28h] BYREF
  char v10; // [xsp+40h] [xbp-10h]

  v3 = result;
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = 0LL;
  *(_QWORD *)(result + 16) = 0LL;
  if ( (a3 & 1) != 0 )
  {
    sub_680833C(&v9, a2);
    result = (__int64)sub_68497A0((unsigned __int64 *)&v6, &v9);
    v8 = v10;
    if ( (v9 & 1) != 0 )
      result = sub_65ECAF4();
    if ( (*(_BYTE *)v3 & 1) != 0 )
      result = sub_65ECAF4();
    v4 = v7;
    v5 = v8;
    *(_OWORD *)v3 = v6;
    *(_QWORD *)(v3 + 16) = v4;
    *(_BYTE *)(v3 + 24) = v5;
  }
  else
  {
    *(_BYTE *)(result + 24) = 0;
  }
  return result;
}


================================================================================
Function: sub_53DD848 (0x53DD848)
================================================================================

__int64 __fastcall sub_53DD848(__int64 a1, unsigned __int64 a2, int a3, __int64 a4, unsigned __int8 *a5)
{
  unsigned __int64 v5; // x8
  __int64 v6; // x9
  _BYTE *v7; // x8
  bool v8; // cc
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x13
  unsigned __int64 v11; // x9
  bool v12; // zf
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x13
  int v15; // w9
  unsigned __int8 *v16; // x11
  int v17; // w10
  int v18; // w12
  unsigned __int8 *v19; // x13
  int v20; // w14
  _QWORD v22[4]; // [xsp+8h] [xbp-58h] BYREF
  int v23; // [xsp+28h] [xbp-38h] BYREF
  int v24; // [xsp+2Ch] [xbp-34h] BYREF
  _BYTE v25[40]; // [xsp+30h] [xbp-30h] BYREF

  v5 = byte_102749E[__clz(a2 | 1) ^ 0x3F];
  v6 = (__PAIR128__(v5, a2) - qword_10274E0[v5]) >> 64;
  v7 = &v25[v6];
  v23 = v6;
  v24 = a3;
  if ( a2 >= 0x64 )
  {
    do
    {
      v8 = a2 >> 4 > 0x270;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64uLL;
      *((_WORD *)v7 - 1) = *(_WORD *)&a00010203040506_1[2 * v10];
      v7 -= 2;
    }
    while ( v8 );
    if ( v9 <= 9 )
      goto LABEL_4;
LABEL_6:
    *((_WORD *)v7 - 1) = *(_WORD *)&a00010203040506_1[2 * v9];
    goto LABEL_7;
  }
  v9 = a2;
  if ( a2 > 9 )
    goto LABEL_6;
LABEL_4:
  *(v7 - 1) = v9 + 48;
LABEL_7:
  v11 = *a5;
  v12 = (v11 & 1) == 0;
  v13 = v11 >> 1;
  if ( v12 )
    v14 = v13;
  else
    v14 = *((_QWORD *)a5 + 1);
  v15 = v23;
  if ( v12 )
    v16 = a5 + 1;
  else
    v16 = (unsigned __int8 *)*((_QWORD *)a5 + 2);
  v17 = 0;
  if ( a5[24] )
  {
    v18 = 0;
    v19 = &v16[v14];
    if ( v19 == v16 )
      goto LABEL_17;
LABEL_15:
    v20 = *v16;
    if ( (unsigned int)(v20 - 127) >= 0xFFFFFF82 )
    {
      ++v16;
      while ( 1 )
      {
        v18 += v20;
        if ( v18 >= v23 )
          break;
        ++v17;
        if ( v19 != v16 )
          goto LABEL_15;
LABEL_17:
        v20 = (char)*(v19 - 1);
      }
    }
  }
  if ( v24 )
    v15 = v23 + 1;
  v22[0] = &v24;
  v22[1] = a5;
  v22[2] = v25;
  v22[3] = &v23;
  return sub_53DD9DC(a1, a4, (unsigned int)(v15 + v17), (unsigned int)(v15 + v17), v22);
}


================================================================================
Function: sub_53DD9DC (0x53DD9DC)
================================================================================

__int64 __fastcall sub_53DD9DC(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x24
  unsigned __int64 v11; // x22
  __int64 v12; // x22
  int v13; // w23
  __int64 v14; // x8
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_1027588[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_250EF44(a1, v10 >> v9, v8);
  v12 = v10 - v11;
  v13 = **a5;
  if ( v13 )
  {
    v14 = *(_QWORD *)(v7 + 16);
    v15 = v14 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v14 = *(_QWORD *)(v7 + 16);
      v15 = v14 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v14) = v13;
  }
  result = sub_53DDAC4((unsigned __int8 *)a5[1], v7, (char *)a5[2], *a5[3]);
  if ( v12 )
    return sub_250EF44(result, v12, v8);
  return result;
}


================================================================================
Function: sub_53DDAC4 (0x53DDAC4)
================================================================================

__int64 __fastcall sub_53DDAC4(unsigned __int8 *a1, __int64 a2, char *a3, int a4)
{
  __int64 v4; // x22
  unsigned __int64 v8; // x11
  int v9; // w9
  unsigned __int8 *v10; // x8
  int v11; // w25
  unsigned __int8 *v12; // x27
  __int64 v13; // x10
  _DWORD *v14; // x8
  unsigned __int8 *v15; // x9
  bool v16; // zf
  __int64 v17; // x11
  unsigned __int8 *v18; // x9
  int v19; // w9
  bool v20; // cc
  __int64 v21; // x10
  int v22; // w11
  __int64 v23; // x9
  int v24; // w25
  __int64 v25; // x9
  __int64 v26; // x8
  unsigned __int8 v27; // w26
  __int64 v28; // x1
  __int64 v29; // x9
  __int64 v30; // x8
  char v31; // w26
  __int64 v32; // x1
  __int64 (__fastcall **v34)(); // [xsp+0h] [xbp-800h] BYREF
  _DWORD *v35; // [xsp+8h] [xbp-7F8h]
  __int128 v36; // [xsp+10h] [xbp-7F0h]
  _DWORD v37[502]; // [xsp+20h] [xbp-7E0h] BYREF

  LODWORD(v4) = a4;
  v8 = *a1;
  v34 = off_6BB8DD0;
  v35 = v37;
  v9 = a1[24];
  v36 = xmmword_AFB900;
  v10 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  v37[0] = 0;
  if ( v9 )
  {
    v11 = 0;
    if ( (v8 & 1) != 0 )
      v12 = v10;
    else
      v12 = a1 + 1;
    v13 = 1LL;
    v14 = v37;
    while ( 1 )
    {
      v15 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      v16 = (v8 & 1) == 0;
      v17 = (unsigned __int8)(v8 >> 1);
      if ( v16 )
        v15 = a1 + 1;
      else
        v17 = *((_QWORD *)a1 + 1);
      v18 = &v15[v17];
      if ( v18 == v12 )
      {
        v19 = (char)*(v18 - 1);
      }
      else
      {
        v19 = *v12;
        if ( (unsigned int)(v19 - 127) < 0xFFFFFF82 )
        {
          LODWORD(v23) = v13;
          if ( (int)v4 >= 1 )
            goto LABEL_26;
          goto LABEL_35;
        }
        ++v12;
      }
      v11 += v19;
      if ( v11 )
        v20 = v11 < (int)v4;
      else
        v20 = 0;
      if ( !v20 )
      {
        LODWORD(v23) = v13;
LABEL_25:
        if ( (int)v4 < 1 )
          goto LABEL_35;
        goto LABEL_26;
      }
      v23 = v13 + 1;
      if ( *((_QWORD *)&v36 + 1) >= (unsigned __int64)(v13 + 1) )
      {
        *(_QWORD *)&v36 = v13 + 1;
        v14[v13] = v11;
      }
      else
      {
        ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v34)(&v34, v13 + 1);
        v14 = v35;
        v21 = v36;
        v22 = a1[24];
        v23 = v36 + 1;
        *(_QWORD *)&v36 = v36 + 1;
        v35[v21] = v11;
        if ( !v22 )
          goto LABEL_25;
      }
      v8 = *a1;
      v13 = v23;
    }
  }
  LODWORD(v23) = 1;
  v14 = v37;
  if ( a4 >= 1 )
  {
LABEL_26:
    v24 = v23 - 1;
    v4 = (unsigned int)v4;
    do
    {
      if ( (_DWORD)v4 == v14[v24] )
      {
        v26 = *(_QWORD *)(a2 + 16);
        v27 = a1[24];
        v28 = v26 + 1;
        if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v26 + 1) )
        {
          (**(void (__fastcall ***)(__int64))a2)(a2);
          v26 = *(_QWORD *)(a2 + 16);
          v28 = v26 + 1;
        }
        --v24;
        v29 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a2 + 16) = v28;
        *(_BYTE *)(v29 + v26) = v27;
      }
      v30 = *(_QWORD *)(a2 + 16);
      v31 = *a3;
      v32 = v30 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v30 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v30 = *(_QWORD *)(a2 + 16);
        v32 = v30 + 1;
      }
      v25 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v32;
      --v4;
      ++a3;
      *(_BYTE *)(v25 + v30) = v31;
      v14 = v35;
    }
    while ( v4 );
  }
LABEL_35:
  if ( v14 != v37 )
    sub_65ECAF4();
  return a2;
}


================================================================================
Function: sub_53DDE58 (0x53DDE58)
================================================================================

__int64 __fastcall sub_53DDE58(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // x21
  __int64 v6; // x10
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x12
  unsigned __int64 v10; // x8
  __int64 v11; // x11
  _BYTE *v12; // x9
  char *v13; // x13
  unsigned __int64 v14; // x14
  __int64 v15; // x15
  _OWORD *v16; // x13
  __int128 *v17; // x14
  unsigned __int64 v18; // x16
  __int128 v19; // q0
  __int128 v20; // q1
  _QWORD *v21; // x11
  __int64 *v22; // x16
  __int64 v23; // x15
  __int64 v24; // t1
  char v25; // t1

  if ( a1 != a2 )
  {
    v5 = a1;
    v6 = *(_QWORD *)(a3 + 16);
    do
    {
      v7 = *(_QWORD *)(a3 + 24);
      v8 = a2 - v5;
      if ( v7 < a2 - v5 + v6 )
      {
        (**(void (__fastcall ***)(__int64))a3)(a3);
        v6 = *(_QWORD *)(a3 + 16);
        v7 = *(_QWORD *)(a3 + 24);
      }
      v9 = v7 - v6;
      if ( v7 - v6 >= v8 )
        v10 = a2 - v5;
      else
        v10 = v7 - v6;
      if ( !v10 )
        goto LABEL_4;
      v11 = *(_QWORD *)(a3 + 8);
      v12 = (_BYTE *)(v11 + v6);
      if ( v10 >= 8 )
      {
        if ( (unsigned __int64)v12 >= v5 + v10 || (v14 = v10, v13 = (char *)v5, v5 >= v11 + v6 + v10) )
        {
          if ( v10 < 0x20 )
          {
            v15 = 0LL;
LABEL_21:
            if ( v9 >= v8 )
              v9 = a2 - v5;
            v21 = (_QWORD *)(v11 + v6 + v15);
            v22 = (__int64 *)(v5 + v15);
            v13 = (char *)(v5 + (v9 & 0xFFFFFFFFFFFFFFF8LL));
            v12 += v9 & 0xFFFFFFFFFFFFFFF8LL;
            v14 = v10 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
            v23 = v15 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v24 = *v22++;
              v23 += 8LL;
              *v21++ = v24;
            }
            while ( v23 );
            if ( v9 == (v9 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_3;
            goto LABEL_28;
          }
          v15 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          v16 = (_OWORD *)(v11 + v6 + 16);
          v17 = (__int128 *)(v5 + 16);
          v18 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v19 = *(v17 - 1);
            v20 = *v17;
            v17 += 2;
            v18 -= 32LL;
            *(v16 - 1) = v19;
            *v16 = v20;
            v16 += 2;
          }
          while ( v18 );
          if ( v10 == v15 )
            goto LABEL_3;
          if ( (v10 & 0x18) != 0 )
            goto LABEL_21;
          v14 = v10 & 0x1F;
          v12 += v15;
          v13 = (char *)(v5 + v15);
        }
      }
      else
      {
        v13 = (char *)v5;
        v14 = v10;
      }
      do
      {
LABEL_28:
        v25 = *v13++;
        --v14;
        *v12++ = v25;
      }
      while ( v14 );
LABEL_3:
      v6 = *(_QWORD *)(a3 + 16);
LABEL_4:
      v6 += v10;
      v5 += v10;
      *(_QWORD *)(a3 + 16) = v6;
    }
    while ( v5 != a2 );
  }
  return a3;
}


================================================================================
Function: sub_53DDFD8 (0x53DDFD8)
================================================================================

__int64 __fastcall sub_53DDFD8(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  unsigned int v13; // w10
  _BYTE *v14; // x1
  _BYTE *v15; // x9
  unsigned int v16; // w15
  unsigned int v17; // w11
  unsigned int v18; // w14
  _BYTE v20[12]; // [xsp+Ch] [xbp-14h] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_DWORD *)(a1 + 24);
  v14 = &v20[*(int *)(a1 + 28)];
  if ( v13 >= 0x64 )
  {
    v15 = &v20[*(int *)(a1 + 28)];
    do
    {
      v16 = v13 >> 4;
      v17 = v13 / 0x64;
      v18 = v13 % 0x64;
      v13 /= 0x64u;
      *((_WORD *)v15 - 1) = *(_WORD *)&a00010203040506_1[2 * v18];
      v15 -= 2;
    }
    while ( v16 > 0x270 );
    if ( v17 <= 9 )
      goto LABEL_15;
LABEL_17:
    *((_WORD *)v15 - 1) = *(_WORD *)&a00010203040506_1[2 * v17];
    return sub_53DDE58((unsigned __int64)v20, (__int64)v14, a2);
  }
  v15 = &v20[*(int *)(a1 + 28)];
  v17 = *(_DWORD *)(a1 + 24);
  if ( v13 > 9 )
    goto LABEL_17;
LABEL_15:
  *(v15 - 1) = v17 + 48;
  return sub_53DDE58((unsigned __int64)v20, (__int64)v14, a2);
}


================================================================================
Function: sub_53DE164 (0x53DE164)
================================================================================

__int64 __fastcall sub_53DE164(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  unsigned int v13; // w8
  __int64 v14; // x10
  __int64 v15; // x11
  __int64 v16; // x9
  unsigned __int64 v17; // x13
  int v18; // w10
  __int64 v19; // x12
  bool v20; // zf
  __int64 v21; // x10
  const char *v22; // x9
  _BYTE *v23; // x10
  __int64 v24; // x11
  _BYTE *v25; // x1
  _BYTE *v26; // x10
  const char *v27; // x9
  __int64 v28; // x11
  bool v29; // cc
  _BYTE v31[12]; // [xsp+Ch] [xbp-14h] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_DWORD *)(a1 + 24);
  v14 = *(unsigned int *)(a1 + 28);
  v15 = *(_QWORD *)(a2 + 16);
  v16 = (int)v14;
  v17 = v15 + v14;
  v18 = *(unsigned __int8 *)(a1 + 32);
  if ( *(_QWORD *)(a2 + 24) >= v17 && (v19 = *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16) = v17, v19) )
  {
    v20 = v18 == 0;
    v21 = v15 + v16 + v19;
    if ( v20 )
      v22 = "0123456789abcdef";
    else
      v22 = "0123456789ABCDEF";
    v23 = (_BYTE *)(v21 - 1);
    do
    {
      v24 = v13 & 0xF;
      v7 = v13 >= 0x10;
      v13 >>= 4;
      *v23-- = v22[v24];
    }
    while ( v7 );
  }
  else
  {
    v25 = &v31[v16];
    v20 = v18 == 0;
    v26 = &v31[v16 - 1];
    if ( v20 )
      v27 = "0123456789abcdef";
    else
      v27 = "0123456789ABCDEF";
    do
    {
      v28 = v13 & 0xF;
      v29 = v13 > 0xF;
      v13 >>= 4;
      *v26-- = v27[v28];
    }
    while ( v29 );
    return sub_53DDE58((unsigned __int64)v31, (__int64)v25, a2);
  }
  return a2;
}


================================================================================
Function: sub_54E48D4 (0x54E48D4)
================================================================================

unsigned __int64 __fastcall sub_54E48D4(unsigned __int64 *a1, char *s)
{
  unsigned __int64 result; // x0
  size_t v5; // x20
  void *v6; // x19
  unsigned __int64 v7; // x22
  __int64 v8; // x0

  result = strlen(s);
  if ( result >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v5 = result;
  if ( result >= 0x17 )
  {
    v7 = (result + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = sub_65ECAAC();
    a1[1] = v5;
    a1[2] = v8;
    *a1 = v7 | 1;
    v6 = (void *)v8;
  }
  else
  {
    *(_BYTE *)a1 = 2 * result;
    v6 = (char *)a1 + 1;
    if ( !result )
      goto LABEL_7;
  }
  result = (unsigned __int64)memcpy(v6, s, v5);
LABEL_7:
  *((_BYTE *)v6 + v5) = 0;
  return result;
}


================================================================================
Function: sub_5508348 (0x5508348)
================================================================================

__int64 __fastcall sub_5508348(int a1)
{
  int v1; // w8
  __int64 result; // x0

  v1 = a1 - 7;
  result = 2LL;
  switch ( v1 )
  {
    case 0:
    case 1:
    case 5:
    case 8:
    case 9:
    case 13:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 46:
    case 48:
    case 51:
    case 53:
    case 59:
    case 67:
    case 68:
    case 70:
    case 71:
    case 72:
    case 73:
      return result;
    default:
      result = 1LL;
      break;
  }
  return result;
}


================================================================================
Function: sub_5550364 (0x5550364)
================================================================================

void *__fastcall sub_5550364(__int64 a1, int a2)
{
  void *result; // x0

  if ( a2 < 1 )
  {
    if ( a2 < -9999 )
      result = (void *)sub_555398C();
    else
      result = (void *)(*(_QWORD *)(a1 + 32) + 16LL * a2);
  }
  else if ( *(_QWORD *)(a1 + 8) + 16 * (unsigned __int64)(unsigned int)(a2 - 1) >= *(_QWORD *)(a1 + 32) )
  {
    result = &unk_10308A8;
  }
  else
  {
    result = (void *)(*(_QWORD *)(a1 + 8) + 16LL * (unsigned int)(a2 - 1));
  }
  if ( result == &unk_10308A8 )
    return 0LL;
  return result;
}


================================================================================
Function: sub_5550480 (0x5550480)
================================================================================

__int64 __fastcall sub_5550480(__int64 result, int a2)
{
  __int64 v2; // x8
  __int64 v3; // x19
  __int64 v5; // x9
  unsigned __int64 v6; // x8

  v2 = *(_QWORD *)(result + 32);
  v3 = result;
  if ( *(_QWORD *)(result + 40) - v2 <= 16 * a2 )
  {
    result = sub_555C64C();
    v2 = *(_QWORD *)(v3 + 32);
  }
  v5 = *(_QWORD *)(v3 + 16);
  v6 = v2 + 16LL * a2;
  if ( *(_QWORD *)(v5 + 16) < v6 )
    *(_QWORD *)(v5 + 16) = v6;
  return result;
}


================================================================================
Function: sub_55506E0 (0x55506E0)
================================================================================

__int64 __fastcall sub_55506E0(__int64 a1)
{
  return (*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 8)) >> 4;
}


================================================================================
Function: sub_5551A68 (0x5551A68)
================================================================================

__int64 __fastcall sub_5551A68(__int64 result, char *s)
{
  __int64 v2; // x19
  size_t v4; // x21
  _QWORD *v5; // x22
  __int64 v6; // x23
  __int64 v7; // x8

  v2 = result;
  if ( s )
  {
    v4 = strlen(s);
    if ( *(_QWORD *)(*(_QWORD *)(v2 + 24) + 88LL) >= *(_QWORD *)(*(_QWORD *)(v2 + 24) + 72LL) )
      sub_555D9A0(v2, 1);
    if ( (*(_BYTE *)v2 & 4) != 0 )
      sub_555E9E8(v2, (_BYTE *)v2, (_QWORD *)(v2 + 96));
    v5 = (_QWORD *)(v2 + 32);
    v6 = *(_QWORD *)(v2 + 32);
    result = sub_55645D8(v2, (int *)s, v4);
    *(_QWORD *)v6 = result;
    v7 = *(_QWORD *)(v2 + 32);
    *(_DWORD *)(v6 + 12) = 5;
  }
  else
  {
    v7 = *(_QWORD *)(result + 32);
    v5 = (_QWORD *)(result + 32);
    *(_DWORD *)(v7 + 12) = 0;
  }
  *v5 = v7 + 16;
  return result;
}


================================================================================
Function: sub_5551BC8 (0x5551BC8)
================================================================================

__int64 sub_5551BC8(__int64 a1, char *a2, ...)
{
  gcc_va_list va1; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-28h] BYREF

  if ( *(_QWORD *)(*(_QWORD *)(a1 + 24) + 88LL) >= *(_QWORD *)(*(_QWORD *)(a1 + 24) + 72LL) )
    sub_555D9A0(a1, 1);
  if ( (*(_BYTE *)a1 & 4) != 0 )
    sub_555E9E8(a1, a1, a1 + 96);
  va_start(va, a2);
  va_copy(va1, va);
  return sub_5563040(a1, a2);
}


================================================================================
Function: sub_555398C (0x555398C)
================================================================================

void *__fastcall sub_555398C(_QWORD *a1, int a2)
{
  void *result; // x0
  __int64 v3; // x8
  __int64 v4; // x9
  _QWORD **v5; // x9
  __int64 *v6; // x9
  __int64 v7; // x8
  int v8; // w11
  __int64 v9; // x8

  switch ( a2 )
  {
    case -10002:
      v3 = a1[3];
      v4 = a1[13];
LABEL_13:
      *(_QWORD *)(v3 + 3200) = v4;
      result = (void *)(a1[3] + 3200LL);
      *(_DWORD *)(v3 + 3212) = 8;
      return result;
    case -10001:
      v5 = (_QWORD **)a1[2];
      v3 = a1[3];
      if ( v5 == (_QWORD **)a1[8] )
        v6 = a1 + 13;
      else
        v6 = (__int64 *)(**v5 + 16LL);
      v4 = *v6;
      goto LABEL_13;
    case -10000:
      return (void *)(a1[3] + 3216LL);
  }
  v7 = **(_QWORD **)a1[2];
  v8 = *(unsigned __int8 *)(v7 + 4);
  v9 = v7 + 16LL * (-10003 - a2) + 48;
  if ( -10002 - a2 <= v8 )
    return (void *)v9;
  else
    return &unk_10308A8;
}


================================================================================
Function: sub_555B7B0 (0x555B7B0)
================================================================================

void __noreturn sub_555B7B0(__int64 a1, char *format, ...)
{
  char s[512]; // [xsp+B0h] [xbp-240h] BYREF
  gcc_va_list va; // [xsp+2B0h] [xbp-40h] BYREF
  gcc_va_list arg; // [xsp+2D0h] [xbp-20h] BYREF

  va_start(va, format);
  va_copy(arg, va);
  vsnprintf(s, 0x200uLL, format, arg);
  sub_5550480(a1, 1LL);
  sub_555BA5C(a1, s);
  sub_555C3F0(a1, 2);
}


================================================================================
Function: sub_555BA5C (0x555BA5C)
================================================================================

__int64 __fastcall sub_555BA5C(__int64 a1, char *s)
{
  int v2; // w20
  __int64 **v3; // x22
  __int64 v4; // x8
  char dest[256]; // [xsp+8h] [xbp-108h] BYREF

  v2 = a1;
  v3 = *(__int64 ***)(a1 + 16);
  if ( *((_DWORD *)*v3 + 3) != 10 )
    return sub_5551A68(a1, s);
  v4 = **v3;
  if ( *(_BYTE *)(v4 + 3) )
    return sub_5551A68(a1, s);
  sub_556321C(
    dest,
    0x100uLL,
    (char *)(*(_QWORD *)(*(_QWORD *)(v4 + 24) + 56LL) + 24LL),
    *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v4 + 24) + 56LL) + 20LL));
  return sub_556310C(v2, "%s:%d: %s");
}


================================================================================
Function: sub_555C330 (0x555C330)
================================================================================

__int64 __fastcall sub_555C330(__int64 a1, void (*a2)(void))
{
  a2();
  return 0LL;
}


================================================================================
Function: sub_555C3F0 (0x555C3F0)
================================================================================

void __fastcall __noreturn sub_555C3F0(__int64 a1, int a2)
{
  __int64 v4; // x0

  v4 = sub_6861FD0(24LL);
  *(_DWORD *)(v4 + 16) = a2;
  *(_QWORD *)v4 = off_6BC3488;
  *(_QWORD *)(v4 + 8) = a1;
  sub_6862048(v4, &`typeinfo for'lua_exception, sub_6865238);
}


================================================================================
Function: sub_555C430 (0x555C430)
================================================================================

char *__fastcall sub_555C430(__int64 a1, int a2, int a3)
{
  __int64 v5; // x22
  char *v6; // x20
  char *result; // x0
  __int64 v8; // x12
  __int64 v9; // x9
  unsigned __int64 v10; // x10
  char *v11; // x12
  unsigned __int64 v12; // x13
  __int64 v13; // x8
  char *v14; // x10
  __int64 v15; // x8
  char *v16; // x10
  __int64 v17; // x8
  char **v18; // x8
  unsigned __int64 i; // x9
  char *v20; // x11
  char *v21; // x12
  __int64 v22; // x8
  __int64 v23; // x10

  if ( a2 >= 67108865 && (_BYTE)word_6F8CB20 )
  {
    if ( a3 && (_BYTE)word_6F8CB38 )
    {
      v22 = *(_QWORD *)(a1 + 16);
      v23 = *(_QWORD *)(v22 - 16);
      *(_QWORD *)(a1 + 32) = *(_QWORD *)(v22 - 24);
      *(_QWORD *)(a1 + 8) = v23;
      *(_QWORD *)(a1 + 16) = v22 - 40;
    }
    sub_555C3F0(a1, 4);
  }
  if ( a2 < -5 )
    sub_5561DFC(a1);
  v5 = (unsigned int)(a2 + 5);
  v6 = *(char **)(a1 + 48);
  result = (char *)sub_556238C(a1, v6, 16LL * *(int *)(a1 + 72), 16 * v5, *(_BYTE *)(a1 + 1));
  v8 = *(int *)(a1 + 72);
  *(_QWORD *)(a1 + 48) = result;
  if ( (int)v8 < (int)v5 )
  {
    v9 = v8;
    v10 = (int)v5 - v8;
    if ( v10 < 2 )
      goto LABEL_9;
    v9 = (v10 & 0xFFFFFFFFFFFFFFFELL) + v8;
    v11 = &result[16 * v8 + 28];
    v12 = v10 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v12 -= 2LL;
      *((_DWORD *)v11 - 4) = 0;
      *(_DWORD *)v11 = 0;
      v11 += 32;
    }
    while ( v12 );
    if ( v10 != (v10 & 0xFFFFFFFFFFFFFFFELL) )
    {
LABEL_9:
      v13 = (int)v5 - v9;
      v14 = &result[16 * v9 + 12];
      do
      {
        --v13;
        *(_DWORD *)v14 = 0;
        v14 += 16;
      }
      while ( v13 );
    }
  }
  v15 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 72) = v5;
  v16 = &result[v15 - (_QWORD)v6];
  v17 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 32) = v16;
  for ( *(_QWORD *)(a1 + 40) = &result[16 * a2]; v17; v17 = *(_QWORD *)(v17 + 32) )
    *(_QWORD *)(v17 + 8) = &result[*(_QWORD *)(v17 + 8) - (_QWORD)v6];
  v18 = *(char ***)(a1 + 64);
  for ( i = *(_QWORD *)(a1 + 16); (unsigned __int64)v18 <= i; v18 += 5 )
  {
    v20 = &result[v18[3] - v6];
    v21 = &result[*v18 - v6];
    v18[2] = &result[v18[2] - v6];
    v18[3] = v20;
    *v18 = v21;
  }
  *(_QWORD *)(a1 + 8) = &result[*(_QWORD *)(a1 + 8) - (_QWORD)v6];
  return result;
}


================================================================================
Function: sub_555C5CC (0x555C5CC)
================================================================================

char *__fastcall sub_555C5CC(__int64 a1, unsigned int a2)
{
  char *v3; // x21
  char *result; // x0
  __int64 v6; // x8

  if ( (a2 & 0x80000000) != 0 )
    sub_5561DFC(a1);
  v3 = *(char **)(a1 + 64);
  result = (char *)sub_556238C(a1, v3, 40LL * *(int *)(a1 + 76), 40LL * a2, *(_BYTE *)(a1 + 1));
  v6 = *(_QWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 76) = a2;
  *(_QWORD *)(a1 + 56) = &result[40 * a2 - 40];
  *(_QWORD *)(a1 + 64) = result;
  *(_QWORD *)(a1 + 16) = &result[v6 - (_QWORD)v3];
  return result;
}


================================================================================
Function: sub_555C64C (0x555C64C)
================================================================================

__int64 sub_555C64C()
{
  return sub_555C430();
}


================================================================================
Function: sub_555D090 (0x555D090)
================================================================================

__int64 __fastcall sub_555D090(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int16 v5; // w25
  __int64 v7; // x23
  __int64 v9; // x24
  int v11; // w26
  unsigned int v12; // w20
  __int64 v13; // x27
  int v14; // w0
  char *v15; // x1
  size_t v16; // x2
  int v17; // w22
  int v18; // w0
  int v20; // w8
  unsigned int v21; // w8
  void (__fastcall *v22)(__int64); // x8
  unsigned __int64 v23; // x23
  __int64 v24; // x21
  int v25; // w0
  char *v26; // x1
  size_t v27; // x2
  __int64 v28; // x22
  __int64 v29; // x8
  __int64 v30; // x0
  __int64 v31; // x8

  v5 = *(_WORD *)(a1 + 80);
  v7 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a1 + 64);
  v11 = *(unsigned __int8 *)(a1 + 5);
  v12 = ((__int64 (*)(void))sub_555C330)();
  if ( !v12 )
    return v12;
  if ( a5 )
  {
    if ( v12 == 2 )
      goto LABEL_14;
    v13 = *(_QWORD *)(a1 + 32);
    switch ( v12 )
    {
      case 3u:
        *(_OWORD *)v13 = *(_OWORD *)(v13 - 16);
        break;
      case 5u:
        v14 = a1;
        v15 = "error in error handling";
        v16 = 23LL;
        goto LABEL_12;
      case 4u:
        v14 = a1;
        v15 = "not enough memory";
        v16 = 17LL;
LABEL_12:
        *(_QWORD *)v13 = sub_55645D8(v14, v15, v16);
        *(_DWORD *)(v13 + 12) = 5;
        break;
    }
    *(_QWORD *)(a1 + 32) = v13 + 16;
LABEL_14:
    v18 = sub_555C330(a1, sub_555D2EC, *(_QWORD *)(a1 + 48) + a5);
    if ( v18 == 4 && v12 == 4 )
      v20 = 4;
    else
      v20 = 5;
    if ( v18 )
      v17 = v20;
    else
      v17 = 2;
    if ( v18 )
      v12 = v20;
    if ( !v11 )
      goto LABEL_26;
    goto LABEL_27;
  }
  v17 = v12;
  if ( !v11 )
LABEL_26:
    *(_BYTE *)(a1 + 5) = 0;
LABEL_27:
  v21 = *(unsigned __int16 *)(a1 + 80);
  *(_WORD *)(a1 + 80) = v5;
  if ( v21 <= *(unsigned __int16 *)(a1 + 82) )
  {
    v22 = *(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 24) + 3352LL);
    if ( v22 )
    {
      v22(a1);
      if ( *(_BYTE *)(a1 + 3) == 6 )
        return 0;
    }
  }
  v23 = v7 - v9;
  v24 = *(_QWORD *)(a1 + 48) + a4;
  sub_555D6E0(a1, v24);
  if ( (unsigned int)(v17 - 2) < 2 )
  {
    *(_OWORD *)v24 = *(_OWORD *)(*(_QWORD *)(a1 + 32) - 16LL);
  }
  else
  {
    if ( v17 == 5 )
    {
      v25 = a1;
      v26 = "error in error handling";
      v27 = 23LL;
      goto LABEL_37;
    }
    if ( v17 == 4 )
    {
      v25 = a1;
      v26 = "not enough memory";
      v27 = 17LL;
LABEL_37:
      *(_QWORD *)v24 = sub_55645D8(v25, v26, v27);
      *(_DWORD *)(v24 + 12) = 5;
    }
  }
  v28 = *(_QWORD *)(a1 + 64);
  v29 = *(unsigned int *)(a1 + 76);
  *(_QWORD *)(a1 + 32) = v24 + 16;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(v28 + v23 + 24);
  *(_QWORD *)(a1 + 16) = v28 + v23;
  if ( (int)v29 >= 20001 && (int)(-858993459 * (v23 >> 3)) <= 19998 )
  {
    v30 = sub_556238C(a1, v28, 40 * v29, 800000LL, *(unsigned __int8 *)(a1 + 1));
    v31 = v30 + *(_QWORD *)(a1 + 16) - v28;
    *(_DWORD *)(a1 + 76) = 20000;
    *(_QWORD *)(a1 + 56) = v30 + 799960;
    *(_QWORD *)(a1 + 64) = v30;
    *(_QWORD *)(a1 + 16) = v31;
  }
  return v12;
}


================================================================================
Function: sub_555D45C (0x555D45C)
================================================================================

long double __fastcall sub_555D45C(__int64 a1)
{
  __int64 v2; // x0
  __int64 v3; // x10
  long double result; // q0
  char v5; // w9
  char v6; // w8

  v2 = sub_5561F60(a1, 176LL, *(unsigned __int8 *)(a1 + 4));
  v3 = *(_QWORD *)(a1 + 24);
  *(_OWORD *)&result = 0uLL;
  v5 = *(_BYTE *)(a1 + 4);
  *(_BYTE *)(v2 + 2) = 11;
  v6 = *(_BYTE *)(v3 + 32);
  *(_BYTE *)(v2 + 1) = v5;
  *(_OWORD *)(v2 + 160) = 0u;
  *(_OWORD *)(v2 + 147) = 0u;
  *(_OWORD *)(v2 + 131) = 0u;
  *(_OWORD *)(v2 + 115) = 0u;
  *(_OWORD *)(v2 + 99) = 0u;
  *(_OWORD *)(v2 + 83) = 0u;
  *(_OWORD *)(v2 + 67) = 0u;
  *(_BYTE *)v2 = v6 & 3;
  *(_OWORD *)(v2 + 51) = 0u;
  *(_OWORD *)(v2 + 35) = 0u;
  *(_OWORD *)(v2 + 19) = 0u;
  *(_OWORD *)(v2 + 3) = 0u;
  return result;
}


================================================================================
Function: sub_555D4D4 (0x555D4D4)
================================================================================

__int64 __fastcall sub_555D4D4(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 result; // x0
  __int64 v9; // x8
  char v10; // w9
  __int64 v11; // x9
  _DWORD *v12; // x10
  __int64 v13; // x11
  __int64 v14; // x8
  _DWORD *v15; // x10

  result = sub_5561F60();
  v9 = *(_QWORD *)(a1 + 24);
  *(_BYTE *)(result + 4) = a2;
  *(_BYTE *)(result + 6) = 0;
  LOBYTE(v9) = *(_BYTE *)(v9 + 32);
  *(_WORD *)(result + 2) = 10;
  *(_BYTE *)(result + 1) = *(_BYTE *)(a1 + 4);
  v10 = *(_BYTE *)(a4 + 4);
  *(_QWORD *)(result + 16) = a3;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)result = v9 & 3;
  *(_BYTE *)(result + 5) = v10;
  if ( a2 >= 1 )
  {
    if ( a2 == 1 )
    {
      v11 = 0LL;
LABEL_7:
      v14 = (unsigned int)a2 - v11;
      v15 = (_DWORD *)(result + 16 * v11 + 44);
      do
      {
        --v14;
        *v15 = 0;
        v15 += 4;
      }
      while ( v14 );
      return result;
    }
    v11 = a2 & 0xFFFFFFFE;
    v12 = (_DWORD *)(result + 60);
    v13 = v11;
    do
    {
      v13 -= 2LL;
      *(v12 - 4) = 0;
      *v12 = 0;
      v12 += 8;
    }
    while ( v13 );
    if ( v11 != a2 )
      goto LABEL_7;
  }
  return result;
}


================================================================================
Function: sub_555D6E0 (0x555D6E0)
================================================================================

__int64 __fastcall sub_555D6E0(__int64 result, unsigned __int64 a2)
{
  _QWORD *v2; // x8
  __int64 v3; // x19
  __int128 v5; // q0

  v2 = *(_QWORD **)(result + 88);
  if ( v2 )
  {
    v3 = result;
    do
    {
      if ( v2[1] < a2 )
        break;
      *(_QWORD *)(v3 + 88) = v2[4];
      *(_QWORD *)(v2[3] + 16LL) = v2[2];
      *(_QWORD *)(v2[2] + 24LL) = v2[3];
      v5 = *(_OWORD *)v2[1];
      v2[1] = v2 + 2;
      *((_OWORD *)v2 + 1) = v5;
      result = sub_555EA08(v3, v2);
      v2 = *(_QWORD **)(v3 + 88);
    }
    while ( v2 );
  }
  return result;
}


================================================================================
Function: sub_555D75C (0x555D75C)
================================================================================

__int64 __fastcall sub_555D75C(__int64 result, char *a2, char a3)
{
  char *v3; // x8
  __int128 v4; // q0

  v3 = a2 + 16;
  *(_QWORD *)(*((_QWORD *)a2 + 3) + 16LL) = *((_QWORD *)a2 + 2);
  *(_QWORD *)(*((_QWORD *)a2 + 2) + 24LL) = *((_QWORD *)a2 + 3);
  if ( (a3 & 1) == 0 )
  {
    v4 = *(_OWORD *)*((_QWORD *)a2 + 1);
    *((_QWORD *)a2 + 1) = v3;
    *(_OWORD *)v3 = v4;
    return sub_555EA08(result, a2);
  }
  return result;
}


================================================================================
Function: sub_555D78C (0x555D78C)
================================================================================

__int64 __fastcall sub_555D78C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x1
  __int64 v7; // x1
  __int64 v8; // x1

  sub_55620F0(a1, *(_QWORD *)(a2 + 8), 4LL * *(int *)(a2 + 168), *(_BYTE *)(a2 + 1));
  sub_55620F0(a1, *(_QWORD *)(a2 + 24), 8LL * *(int *)(a2 + 160), *(_BYTE *)(a2 + 1));
  sub_55620F0(a1, *(_QWORD *)(a2 + 32), 16LL * *(int *)(a2 + 144), *(_BYTE *)(a2 + 1));
  v6 = *(_QWORD *)(a2 + 72);
  if ( v6 )
    sub_55620F0(a1, v6, *(int *)(a2 + 156), *(_BYTE *)(a2 + 1));
  sub_55620F0(a1, *(_QWORD *)(a2 + 80), 24LL * *(int *)(a2 + 148), *(_BYTE *)(a2 + 1));
  sub_55620F0(a1, *(_QWORD *)(a2 + 64), 8LL * *(int *)(a2 + 164), *(_BYTE *)(a2 + 1));
  v7 = *(_QWORD *)(a2 + 104);
  if ( v7 )
    sub_55620F0(a1, v7, *(int *)(a2 + 168), *(_BYTE *)(a2 + 1));
  if ( *(_QWORD *)(a2 + 40) )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 24) + 3384LL))(a1, a2);
  v8 = *(_QWORD *)(a2 + 112);
  if ( v8 )
    sub_55620F0(a1, v8, *(int *)(a2 + 172), *(_BYTE *)(a2 + 1));
  return sub_5562204(a1, a2, 176LL, *(unsigned __int8 *)(a2 + 1), a3);
}


================================================================================
Function: sub_555D9A0 (0x555D9A0)
================================================================================

unsigned __int64 __fastcall sub_555D9A0(__int64 a1, char a2)
{
  __int64 v2; // x23
  __int64 v5; // x24
  __int64 v6; // x25
  __int64 v7; // x9
  void (__fastcall *v8)(__int64, _QWORD); // x8
  unsigned __int64 v9; // x20
  __int64 v10; // x22
  int v11; // w22
  double v12; // d0
  int v13; // w8
  double v14; // d0
  double v15; // d1
  double v16; // d0
  unsigned int v17; // w20
  double v18; // d8
  __int64 v19; // x22
  double v20; // d0
  __int64 v21; // x8
  __int64 v22; // x8
  __int64 v23; // x8
  _QWORD *v24; // x9
  int v25; // w11
  unsigned __int64 v26; // x21
  signed __int64 v27; // x8
  unsigned __int64 v28; // x10
  bool v29; // cf
  unsigned __int64 v30; // x8
  double v31; // d0
  double v32; // d1
  signed __int64 v33; // x9
  signed __int64 v34; // x10
  __int64 v35; // x10
  int v36; // w15
  unsigned __int64 v37; // x11
  unsigned __int64 v38; // x10
  double v39; // d2
  double v40; // d1
  double v41; // d2
  __int64 v42; // x12
  int v43; // w14
  int v44; // w14
  signed __int64 v45; // x13
  signed __int64 v46; // x15
  double v47; // d0
  __int64 v48; // x8
  __int128 v49; // q3
  __int128 v50; // q1
  __int128 v51; // q0
  __int64 v52; // x15
  __int128 v53; // q3
  __int128 v54; // q0
  __int128 v55; // q1
  __int128 v56; // q2
  __int128 v57; // q0
  __int128 v58; // q1
  __int128 v59; // q2
  __int64 v60; // x15
  __int128 v61; // q0
  __int128 v62; // q1
  __int64 v63; // x8
  void (__fastcall *v64)(__int64, _QWORD); // x8

  v2 = *(_QWORD *)(a1 + 24);
  v5 = *(_QWORD *)(v2 + 88);
  v6 = *(_QWORD *)(v2 + 72);
  v7 = 1374389535LL * *(_DWORD *)(v2 + 68) * *(_DWORD *)(v2 + 64);
  v8 = *(void (__fastcall **)(__int64, _QWORD))(v2 + 3296);
  v9 = (unsigned __int64)v7 >> 63;
  v10 = v7 >> 37;
  if ( v8 )
    v8(a1, 0LL);
  v11 = v10 + v9;
  if ( !*(_BYTE *)(v2 + 33) )
  {
    v12 = sub_5563B14();
    v13 = *(unsigned __int8 *)(v2 + 33);
    *(double *)(v2 + 6656) = v12;
    if ( !v13 )
    {
      v14 = sub_5563B14();
      v15 = *(double *)(v2 + 6736);
      *(double *)(v2 + 6944) = v14;
      *(double *)(v2 + 6936) = v14 - v15;
    }
  }
  v16 = sub_5563B14();
  v17 = *(unsigned __int8 *)(v2 + 33);
  v18 = v16;
  v19 = sub_555DDA0(a1, v11);
  v20 = sub_5563B14() - v18;
  switch ( v17 )
  {
    case 0u:
      if ( *(_BYTE *)(v2 + 33) != 1 )
        goto LABEL_13;
      *(double *)(v2 + 6960) = v20 + *(double *)(v2 + 6960);
      if ( (a2 & 1) == 0 )
        goto LABEL_19;
      goto LABEL_11;
    case 1u:
    case 2u:
      v21 = *(_QWORD *)(v2 + 6992) + v19;
      *(double *)(v2 + 6960) = v20 + *(double *)(v2 + 6960);
      *(_QWORD *)(v2 + 6992) = v21;
      if ( (a2 & 1) == 0 )
        goto LABEL_19;
LABEL_11:
      v22 = 6968LL;
      goto LABEL_17;
    case 3u:
      *(double *)(v2 + 7016) = v20 + *(double *)(v2 + 7016);
      goto LABEL_13;
    case 4u:
      v23 = *(_QWORD *)(v2 + 7088) + v19;
      *(double *)(v2 + 7056) = v20 + *(double *)(v2 + 7056);
      *(_QWORD *)(v2 + 7088) = v23;
      if ( (a2 & 1) == 0 )
        goto LABEL_19;
      v22 = 7064LL;
LABEL_17:
      *(double *)(v2 + v22) = v20 + *(double *)(v2 + v22);
      goto LABEL_18;
    default:
LABEL_13:
      if ( (a2 & 1) != 0 )
      {
LABEL_18:
        v24 = (_QWORD *)(v2 + 7096);
        *(double *)(v2 + 6688) = v20 + *(double *)(v2 + 6688);
      }
      else
      {
LABEL_19:
        v24 = (_QWORD *)(v2 + 7104);
        *(double *)(v2 + 6680) = v20 + *(double *)(v2 + 6680);
      }
      v25 = *(unsigned __int8 *)(v2 + 33);
      v26 = 100 * v19 / (unsigned __int64)*(int *)(v2 + 68);
      v27 = *(_QWORD *)(v2 + 88);
      *v24 += v19;
      if ( v25 )
      {
        v28 = v27 + v26;
        v29 = v27 + v26 >= v5 - v6;
        v30 = v27 + v26 - (v5 - v6);
        *(_QWORD *)(v2 + 72) = v28;
        if ( v29 )
          *(_QWORD *)(v2 + 72) = v30;
      }
      else
      {
        v31 = *(double *)(v2 + 6664);
        v32 = v31 - *(double *)(v2 + 6672);
        v33 = v27 / 0x64uLL * *(int *)(v2 + 80);
        v34 = v33;
        if ( v32 >= 0.001 )
        {
          v35 = *(_QWORD *)(v2 + 6632);
          v36 = *(_DWORD *)(v2 + 6628);
          v37 = v35 - *(_QWORD *)(v2 + 6640);
          v38 = (unsigned __int64)(v35 - *(_QWORD *)(v2 + 6648)) >> 10;
          v39 = (double)v37;
          LODWORD(v37) = *(_DWORD *)(v2 + 6624);
          v40 = v39 / v32;
          v41 = *(double *)(v2 + 6656);
          v42 = v2 + 4 * (v37 & 0x1F);
          *(_DWORD *)(v2 + 6624) = v37 + 1;
          v43 = *(_DWORD *)(v42 + 6496);
          *(_DWORD *)(v42 + 6496) = v38;
          v44 = v36 + v38 - v43;
          *(_DWORD *)(v2 + 6628) = v44;
          v45 = v33
              - ((__int64)((v31 - v41) * v40)
               + vcvtd_n_s64_f64((double)(int)v38 * 0.405 + (double)v44 * 0.243, 0xAuLL));
          if ( v45 <= v33 )
            v46 = v45;
          else
            v46 = v33;
          if ( v45 >= v27 )
            v34 = v46;
          else
            v34 = v27;
        }
        *(_QWORD *)(v2 + 72) = v34;
        *(_QWORD *)(v2 + 6648) = v33;
        v47 = sub_5563B14();
        v48 = *(_QWORD *)(v2 + 88);
        *(double *)(v2 + 6672) = v47;
        *(_QWORD *)(v2 + 6640) = v48;
        *(double *)(v2 + 6952) = sub_5563B14();
        v49 = *(_OWORD *)(v2 + 7016);
        v50 = *(_OWORD *)(v2 + 7096);
        *(_OWORD *)(v2 + 6864) = *(_OWORD *)(v2 + 7080);
        v51 = *(_OWORD *)(v2 + 7032);
        v52 = *(_QWORD *)(v2 + 6696);
        *(_OWORD *)(v2 + 6800) = v49;
        v53 = *(_OWORD *)(v2 + 6920);
        *(_OWORD *)(v2 + 6880) = v50;
        *(_OWORD *)(v2 + 6816) = v51;
        v54 = *(_OWORD *)(v2 + 7064);
        v55 = *(_OWORD *)(v2 + 7048);
        v56 = *(_OWORD *)(v2 + 7112);
        *(_OWORD *)(v2 + 6704) = v53;
        *(_OWORD *)(v2 + 6848) = v54;
        v57 = *(_OWORD *)(v2 + 7000);
        *(_OWORD *)(v2 + 6832) = v55;
        v58 = *(_OWORD *)(v2 + 6968);
        *(_OWORD *)(v2 + 6896) = v56;
        v59 = *(_OWORD *)(v2 + 6984);
        *(_QWORD *)(v2 + 6696) = v52 + 1;
        v60 = *(_QWORD *)(v2 + 88);
        *(_OWORD *)(v2 + 6784) = v57;
        v61 = *(_OWORD *)(v2 + 6952);
        *(_OWORD *)(v2 + 6752) = v58;
        v62 = *(_OWORD *)(v2 + 6936);
        *(_OWORD *)(v2 + 6768) = v59;
        *(_QWORD *)(v2 + 7128) = v60;
        *(_OWORD *)(v2 + 6736) = v61;
        *(_OWORD *)(v2 + 6720) = v62;
        *(_QWORD *)(v2 + 6912) = v60;
        *(_QWORD *)(v2 + 7128) = 0LL;
        *(_OWORD *)(v2 + 7080) = 0u;
        v63 = *(_QWORD *)(v2 + 72);
        *(_OWORD *)(v2 + 7112) = 0u;
        *(_OWORD *)(v2 + 7096) = 0u;
        *(_OWORD *)(v2 + 7064) = 0u;
        *(_OWORD *)(v2 + 7048) = 0u;
        *(_OWORD *)(v2 + 7032) = 0u;
        *(_OWORD *)(v2 + 7016) = 0u;
        *(_OWORD *)(v2 + 7000) = 0u;
        *(_OWORD *)(v2 + 6984) = 0u;
        *(_OWORD *)(v2 + 6968) = 0u;
        *(_OWORD *)(v2 + 6952) = 0u;
        *(_OWORD *)(v2 + 6936) = 0u;
        *(_QWORD *)(v2 + 6920) = v60;
        *(_QWORD *)(v2 + 6928) = v63;
      }
      v64 = *(void (__fastcall **)(__int64, _QWORD))(v2 + 3296);
      if ( v64 )
        v64(a1, v17);
      return v26;
  }
}


================================================================================
Function: sub_555DDA0 (0x555DDA0)
================================================================================

unsigned __int64 __fastcall sub_555DDA0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x20
  unsigned __int64 v5; // x21
  __int64 v6; // x9
  bool v7; // w8
  __int64 v8; // x0
  __int64 v9; // x9
  __int64 v10; // x8
  __int64 v11; // x9
  __int64 v12; // x10
  __int64 v13; // x9
  bool v14; // w8
  __int64 v15; // x0
  __int64 v16; // x9
  __int64 v17; // x8
  double v18; // d0
  __int64 v19; // x8
  double v20; // d0
  __int64 v21; // x8
  __int64 v22; // x20
  double v23; // d8
  __int64 v24; // x21
  __int64 v25; // x23
  __int64 v26; // x8
  __int64 v27; // x23
  __int64 v28; // x0
  __int64 v29; // x25
  unsigned __int8 *v30; // x24
  int v31; // w8
  int v32; // w26
  char v33; // w27
  int v34; // w8
  int v35; // w8
  int v36; // w8
  int v37; // w9
  _DWORD *v38; // x9
  int v39; // w8
  int v40; // w10
  __int64 v41; // x24
  double v42; // d9
  __int64 v43; // x8
  double v44; // d0
  __int64 v45; // x25
  double v46; // d10
  double v47; // d1
  __int64 v48; // x27
  __int64 v49; // x8
  double v50; // d8
  __int64 v51; // x28
  __int64 v52; // x21
  __int64 v53; // x10
  char v54; // w9
  __int64 v55; // x8
  char v56; // w11
  __int64 v57; // x11
  __int64 v58; // x12
  _BYTE *v59; // x13
  int v60; // w10
  int v61; // w22
  __int64 v62; // x8
  __int64 v63; // x9
  __int64 v64; // x11
  __int64 v65; // x10
  int v66; // w13
  int v67; // w12
  _BYTE *v68; // x14
  _BYTE *v69; // x11
  __int64 v70; // x0
  _DWORD *v71; // x0
  double v72; // d9
  __int64 v73; // x8
  __int64 v74; // x1
  __int64 v75; // x22
  __int64 v76; // x21
  __int64 v77; // x26
  double v78; // d0
  char v79; // w8
  int v81; // [xsp+0h] [xbp-40h] BYREF
  int v82; // [xsp+4h] [xbp-3Ch] BYREF
  unsigned __int8 *v83; // [xsp+8h] [xbp-38h] BYREF
  unsigned __int8 *v84; // [xsp+10h] [xbp-30h] BYREF

  v2 = *(_QWORD *)(a1 + 24);
  switch ( *(_BYTE *)(v2 + 33) )
  {
    case 0:
      sub_555E7F0(a1);
      return 0LL;
    case 1:
      v6 = *(_QWORD *)(v2 + 56);
      v5 = 0LL;
      v7 = v6 != 0;
      if ( v6 && a2 )
      {
        v5 = 0LL;
        do
        {
          v8 = sub_555EB68(v2);
          v9 = *(_QWORD *)(v2 + 56);
          v5 += v8;
          v7 = v9 != 0;
        }
        while ( v9 && v5 < a2 );
      }
      if ( !v7 )
      {
        v10 = *(_QWORD *)(v2 + 7104);
        v11 = *(_QWORD *)(v2 + 7096);
        v12 = *(_QWORD *)(v2 + 40);
        *(_QWORD *)(v2 + 40) = 0LL;
        *(_QWORD *)(v2 + 56) = v12;
        *(_QWORD *)(v2 + 7112) = v11 + v10;
        *(_BYTE *)(v2 + 33) = 2;
      }
      return v5;
    case 2:
      v13 = *(_QWORD *)(v2 + 56);
      v5 = 0LL;
      v14 = v13 != 0;
      if ( v13 && a2 )
      {
        v5 = 0LL;
        do
        {
          v15 = sub_555EB68(v2);
          v16 = *(_QWORD *)(v2 + 56);
          v5 += v15;
          v14 = v16 != 0;
        }
        while ( v16 && v5 < a2 );
      }
      if ( !v14 )
      {
        v17 = *(_QWORD *)(v2 + 7096) + *(_QWORD *)(v2 + 7104) - *(_QWORD *)(v2 + 7112);
        *(_BYTE *)(v2 + 33) = 3;
        *(_QWORD *)(v2 + 7120) = v17;
      }
      return v5;
    case 3:
      v18 = sub_5563B14();
      v19 = *(_QWORD *)(v2 + 88);
      *(double *)(v2 + 7000) = v18;
      *(_QWORD *)(v2 + 7008) = v19;
      v20 = sub_5563B14();
      v21 = *(_QWORD *)(v2 + 88);
      *(double *)(v2 + 6664) = v20;
      *(_QWORD *)(v2 + 6632) = v21;
      v22 = *(_QWORD *)(a1 + 24);
      v23 = sub_5563B14();
      v24 = *(_QWORD *)(v22 + 3184);
      if ( v24 == v22 + 3160 )
      {
        v25 = 0LL;
      }
      else
      {
        v25 = 0LL;
        do
        {
          if ( (*(_BYTE *)v24 & 7) == 0 )
          {
            v26 = *(_QWORD *)(v24 + 8);
            if ( *(int *)(v26 + 12) >= 5 && (**(_BYTE **)v26 & 3) != 0 )
              sub_555E8B8(v22);
          }
          v24 = *(_QWORD *)(v24 + 24);
          v25 += 40LL;
        }
        while ( v24 != v22 + 3160 );
      }
      if ( *(_QWORD *)(v22 + 56) )
      {
        v41 = 0LL;
        do
          v41 += sub_555EB68(v22);
        while ( *(_QWORD *)(v22 + 56) );
      }
      else
      {
        v41 = 0LL;
      }
      v42 = sub_5563B14();
      v43 = *(_QWORD *)(v22 + 48);
      v44 = *(double *)(v22 + 7024) + v42 - v23;
      *(_QWORD *)(v22 + 48) = 0LL;
      *(_QWORD *)(v22 + 56) = v43;
      *(double *)(v22 + 7024) = v44;
      if ( (*(_BYTE *)a1 & 3) != 0 )
        sub_555E8B8(v22);
      sub_555F2D0(v22);
      if ( *(_QWORD *)(v22 + 56) )
      {
        v45 = 0LL;
        do
          v45 += sub_555EB68(v22);
        while ( *(_QWORD *)(v22 + 56) );
      }
      else
      {
        v45 = 0LL;
      }
      v46 = sub_5563B14();
      v47 = *(double *)(v22 + 7032);
      v48 = 0LL;
      v49 = *(_QWORD *)(v22 + 40);
      *(_QWORD *)(v22 + 40) = 0LL;
      *(_QWORD *)(v22 + 56) = v49;
      for ( *(double *)(v22 + 7032) = v47 + v46 - v42; *(_QWORD *)(v22 + 56); v48 += sub_555EB68(v22) )
        ;
      v50 = sub_5563B14();
      v51 = 0LL;
      v52 = *(_QWORD *)(v22 + 48);
      *(double *)(v22 + 7040) = *(double *)(v22 + 7040) + v50 - v46;
      if ( !v52 )
        goto LABEL_97;
LABEL_66:
      v53 = *(int *)(v52 + 8);
      v54 = *(_BYTE *)(v52 + 4);
      v55 = 16 * v53;
      v56 = v54;
      if ( (_DWORD)v53 )
      {
        v57 = 16 * v53;
        do
        {
          v58 = *(_QWORD *)(v52 + 16) + v57;
          if ( *(int *)(v58 - 4) >= 5 )
          {
            v59 = *(_BYTE **)(v58 - 16);
            if ( v59[2] == 5 )
            {
              *v59 &= 0xFCu;
            }
            else if ( (*v59 & 3) != 0 )
            {
              *(_DWORD *)(v58 - 4) = 0;
            }
          }
          v57 -= 16LL;
          LODWORD(v53) = v53 - 1;
        }
        while ( (_DWORD)v53 );
        v56 = *(_BYTE *)(v52 + 4);
      }
      v60 = ~(-1 << v56);
      v61 = 0;
      v51 += v55 + 32LL * (1 << v54) + 48;
      v62 = 32LL * v60;
      v63 = v60 + 1LL;
      break;
    case 4:
      v27 = *(_QWORD *)(v2 + 752);
      v5 = 0LL;
      if ( !v27 || !a2 )
        goto LABEL_41;
      v5 = 0LL;
      while ( 1 )
      {
        v28 = sub_556266C(v27);
        v29 = *(_QWORD *)(v2 + 752);
        v27 = v28;
        sub_556262C(v29, &v84, &v83, &v82, &v81);
        v30 = v84;
        if ( v84 == v83 )
        {
          v34 = v81;
          v37 = (int)v84;
        }
        else
        {
          v31 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 32LL);
          v32 = v31 ^ 3;
          v33 = v31 & 3;
          do
          {
            if ( v30[2] )
            {
              v35 = *v30;
              if ( ((v35 ^ 3) & v32) != 0 )
              {
                *v30 = v35 & 0xF8 | v33;
              }
              else
              {
                sub_555EB1C(a1, v30, v29);
                if ( !--v82 )
                {
                  v36 = ((int)v30 - (int)v84) / v81 + 1;
                  goto LABEL_39;
                }
              }
            }
            v34 = v81;
            v30 += v81;
          }
          while ( v30 != v83 );
          v37 = (int)v84;
        }
        v36 = ((int)v30 - v37) / v34;
LABEL_39:
        *(_QWORD *)(v2 + 752) = v27;
        v5 += 16 * v36;
        if ( !v27 || v5 >= a2 )
        {
LABEL_41:
          if ( !v27 )
          {
            **(_BYTE **)(v2 + 3064) = **(_BYTE **)(v2 + 3064) & 0xF8 | *(_BYTE *)(v2 + 32) & 3;
            v38 = *(_DWORD **)(a1 + 24);
            v39 = v38[1];
            v40 = v39 + 3;
            if ( v39 >= 0 )
              v40 = v38[1];
            if ( v39 >= 65 && *v38 < (unsigned int)(v40 >> 2) )
              sub_55642D4(a1, (unsigned int)v39 >> 1);
            *(_BYTE *)(v2 + 33) = 0;
          }
          return v5;
        }
      }
    default:
      return 0LL;
  }
  do
  {
    v64 = *(_QWORD *)(v52 + 32);
    v65 = v64 + v62;
    v66 = *(_DWORD *)(v64 + v62 + 12);
    if ( !v66 )
      goto LABEL_78;
    v67 = *(_DWORD *)(v65 + 28);
    if ( (v67 & 0xFu) >= 5 )
    {
      v68 = *(_BYTE **)(v64 + v62 + 16);
      if ( v68[2] == 5 )
      {
        *v68 &= 0xFCu;
        v66 = *(_DWORD *)(v65 + 12);
      }
      else if ( (*v68 & 3) != 0 )
      {
        *(_DWORD *)(v65 + 12) = 0;
LABEL_89:
        *(_DWORD *)(v65 + 28) = v67 & 0xFFFFFFF0 | 0xD;
        goto LABEL_78;
      }
    }
    if ( v66 < 5 )
      goto LABEL_77;
    v69 = *(_BYTE **)(v64 + v62);
    if ( v69[2] == 5 )
    {
      *v69 &= 0xFCu;
LABEL_77:
      ++v61;
      goto LABEL_78;
    }
    if ( (*v69 & 3) == 0 )
      goto LABEL_77;
    v67 = *(_DWORD *)(v65 + 28);
    *(_DWORD *)(v65 + 12) = 0;
    if ( (v67 & 0xFu) >= 5 )
      goto LABEL_89;
LABEL_78:
    v62 -= 32LL;
    --v63;
  }
  while ( v63 );
  v70 = *(_QWORD *)(v52 + 40);
  if ( v70 )
  {
    if ( (*(_BYTE *)(v70 + 5) & 2) == 0 )
    {
      v71 = (_DWORD *)sub_556AD84();
      if ( v71 )
      {
        if ( v71[3] == 5 && strchr((const char *)(*(_QWORD *)v71 + 24LL), 115) && v61 < (3 << *(_BYTE *)(v52 + 4)) / 8 )
          sub_55683E4(a1, v52, (unsigned int)v61);
      }
    }
  }
  v52 = *(_QWORD *)(v52 + 24);
  if ( v52 )
    goto LABEL_66;
LABEL_97:
  *(_QWORD *)(v22 + 48) = 0LL;
  v72 = sub_5563B14();
  *(double *)(v22 + 7048) = *(double *)(v22 + 7048) + v72 - v50;
  v73 = *(_QWORD *)(a1 + 24);
  v74 = *(_QWORD *)(v73 + 3184);
  v75 = v73 + 3160;
  if ( v74 == v73 + 3160 )
  {
    v76 = 0LL;
  }
  else
  {
    v76 = 0LL;
    do
    {
      if ( *(_BYTE *)(v74 + 3) )
      {
        *(_BYTE *)(v74 + 3) = 0;
        v74 = *(_QWORD *)(v74 + 24);
      }
      else
      {
        v77 = *(_QWORD *)(v74 + 24);
        sub_555D75C(a1);
        v74 = v77;
      }
      v76 += 40LL;
    }
    while ( v74 != v75 );
  }
  v5 = v41 + v25 + v45 + v48 + v51 + v76;
  v78 = *(double *)(v22 + 7024) + sub_5563B14() - v72;
  v79 = *(_BYTE *)(v22 + 32) ^ 3;
  *(_QWORD *)(v22 + 752) = *(_QWORD *)(v22 + 744);
  *(_BYTE *)(v22 + 33) = 4;
  *(_BYTE *)(v22 + 32) = v79;
  *(double *)(v22 + 7024) = v78;
  return v5;
}


================================================================================
Function: sub_555E7F0 (0x555E7F0)
================================================================================

__int64 __fastcall sub_555E7F0(__int64 a1)
{
  __int64 v1; // x19
  __int64 v3; // x1
  __int64 v4; // x8
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 3064);
  *(_QWORD *)(v1 + 40) = 0LL;
  *(_QWORD *)(v1 + 48) = 0LL;
  *(_QWORD *)(v1 + 56) = 0LL;
  if ( (*(_BYTE *)v3 & 3) != 0 )
  {
    sub_555E8B8(v1);
    v3 = *(_QWORD *)(v1 + 3064);
  }
  if ( (**(_BYTE **)(v3 + 104) & 3) != 0 )
    sub_555E8B8(v1);
  v4 = *(_QWORD *)(a1 + 24);
  if ( *(int *)(v4 + 3228) >= 5 && (**(_BYTE **)(v4 + 3216) & 3) != 0 )
    sub_555E8B8(v1);
  result = sub_555F2D0(v1);
  *(_BYTE *)(v1 + 33) = 1;
  return result;
}


================================================================================
Function: sub_555E8B8 (0x555E8B8)
================================================================================

__int64 __fastcall sub_555E8B8(__int64 result, _BYTE *a2)
{
  int v3; // w9
  char v4; // w8
  _BYTE *v5; // x9
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  __int64 v9; // x8
  __int64 v10; // x8

  while ( 1 )
  {
    v3 = (unsigned __int8)a2[2];
    v4 = *a2 & 0xFC;
    *a2 = v4;
    if ( v3 != 9 )
      break;
    v5 = (_BYTE *)*((_QWORD *)a2 + 1);
    *a2 = v4 | 4;
    if ( !v5 || (*v5 & 3) == 0 )
      return result;
    a2 = v5;
  }
  switch ( v3 )
  {
    case 6:
      goto LABEL_15;
    case 7:
      v6 = *(_QWORD *)(result + 56);
      *(_QWORD *)(result + 56) = a2;
      *((_QWORD *)a2 + 12) = v6;
      break;
    case 8:
      v7 = *(_QWORD *)(result + 56);
      *(_QWORD *)(result + 56) = a2;
      *((_QWORD *)a2 + 3) = v7;
      break;
    case 10:
      v8 = *(_QWORD *)(result + 56);
      *(_QWORD *)(result + 56) = a2;
      *((_QWORD *)a2 + 1) = v8;
      break;
    case 11:
      v9 = *(_QWORD *)(result + 56);
      *(_QWORD *)(result + 56) = a2;
      *((_QWORD *)a2 + 16) = v9;
      break;
    case 12:
      v10 = *((_QWORD *)a2 + 1);
      if ( *(int *)(v10 + 12) >= 5 && (**(_BYTE **)v10 & 3) != 0 )
      {
        result = sub_555E8B8(result);
        v10 = *((_QWORD *)a2 + 1);
      }
      if ( (_BYTE *)v10 == a2 + 16 )
      {
        v4 = *a2;
LABEL_15:
        *a2 = v4 | 4;
      }
      break;
    default:
      return result;
  }
  return result;
}


================================================================================
Function: sub_555E9B4 (0x555E9B4)
================================================================================

__int64 __fastcall sub_555E9B4(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 result; // x0
  __int64 v4; // x8

  result = *(_QWORD *)(a1 + 24);
  if ( *(_BYTE *)(result + 33) == 2 )
    return sub_555E8B8(result, a3);
  *(_BYTE *)a2 &= ~4u;
  v4 = *(_QWORD *)(result + 40);
  *(_QWORD *)(result + 40) = a2;
  *(_QWORD *)(a2 + 24) = v4;
  return result;
}


================================================================================
Function: sub_555E9E8 (0x555E9E8)
================================================================================

__int64 __fastcall sub_555E9E8(__int64 result, _BYTE *a2, _QWORD *a3)
{
  __int64 v3; // x9

  v3 = *(_QWORD *)(result + 24);
  *a2 &= ~4u;
  *a3 = *(_QWORD *)(v3 + 40);
  *(_QWORD *)(v3 + 40) = a2;
  return result;
}


================================================================================
Function: sub_555EA08 (0x555EA08)
================================================================================

__int64 __fastcall sub_555EA08(__int64 result, char *a2)
{
  char v2; // w9
  __int64 v3; // x8
  __int64 v4; // x8
  char v5; // w8

  v2 = *a2;
  if ( (*a2 & 7) == 0 )
  {
    v3 = *(_QWORD *)(result + 24);
    if ( (unsigned int)*(unsigned __int8 *)(v3 + 33) - 1 > 2 )
    {
      v5 = *(_BYTE *)(v3 + 32);
    }
    else
    {
      v4 = *((_QWORD *)a2 + 1);
      *a2 = v2 | 4;
      if ( *(int *)(v4 + 12) < 5 || (**(_BYTE **)v4 & 3) == 0 )
        return result;
      result = *(_QWORD *)(result + 24);
      if ( (unsigned int)*(unsigned __int8 *)(result + 33) - 1 <= 2 )
        return sub_555E8B8(result);
      v5 = *(_BYTE *)(result + 32);
    }
    *a2 = v2 & 0xF8 | v5 & 3;
  }
  return result;
}


================================================================================
Function: sub_555EB1C (0x555EB1C)
================================================================================

__int64 __fastcall sub_555EB1C(__int64 result, unsigned __int8 *a2, __int64 a3)
{
  __int64 v3; // x4
  __int64 v4; // x3
  __int64 v5; // x2
  __int64 v6; // x8

  switch ( a2[2] )
  {
    case 5u:
      JUMPOUT(0x55647D8LL);
    case 6u:
      JUMPOUT(0x55564FCLL);
    case 7u:
      return sub_5563D94();
    case 8u:
      JUMPOUT(0x55685ACLL);
    case 9u:
      JUMPOUT(0x556AFA0LL);
    case 0xAu:
      v6 = 48LL;
      v3 = a3;
      v4 = a2[1];
      if ( !a2[3] )
        v6 = 32LL;
      v5 = v6 + 16LL * a2[4];
      goto LABEL_5;
    case 0xBu:
      return sub_555D78C();
    case 0xCu:
      v3 = a3;
      v4 = a2[1];
      v5 = 40LL;
LABEL_5:
      result = sub_5562204(result, a2, v5, v4, v3);
      break;
    default:
      return result;
  }
  return result;
}


================================================================================
Function: sub_555EB68 (0x555EB68)
================================================================================

__int64 __fastcall sub_555EB68(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x19
  int v4; // w8
  int v5; // w9
  __int64 v6; // x8
  char v7; // w9
  _BYTE *v8; // x1
  __int64 v9; // x0
  const char *v10; // x22
  char *v11; // x21
  char *v12; // x0
  _BOOL4 v13; // w22
  __int64 v14; // x8
  int v15; // w21
  _BYTE *v16; // x1
  unsigned __int8 v17; // w8
  unsigned __int64 v18; // x21
  __int64 v19; // x22
  _BYTE *v20; // x8
  _BYTE *v21; // x8
  int v22; // w8
  __int64 v23; // x21
  __int64 i; // x22
  __int64 v25; // x9
  __int64 v26; // x8
  _BYTE **v27; // x9
  int v28; // w8
  __int64 j; // x21
  _BYTE *v30; // x1
  int v31; // w9
  _BYTE **v32; // x10
  __int64 v33; // x11
  __int64 v34; // x23
  __int64 v35; // x8
  __int64 v36; // x9
  __int64 v37; // x23
  __int64 v38; // x24
  __int64 v39; // x27
  __int64 v40; // x26
  __int64 v41; // x21
  unsigned __int64 v42; // x12
  unsigned __int64 v43; // x8
  __int64 v44; // x9
  unsigned __int64 v45; // x10
  unsigned __int64 v46; // x9
  __int64 v47; // x10
  __int64 v48; // x13
  _DWORD *v49; // x12
  unsigned __int64 v50; // x8
  unsigned __int64 v51; // x9
  unsigned __int64 v52; // x20
  unsigned __int64 v53; // x10
  unsigned __int64 v54; // x11
  unsigned __int64 v55; // x10
  __int64 v56; // x21
  int v57; // w8
  unsigned __int8 v58; // w9
  unsigned __int64 v59; // x21
  __int64 v60; // x22
  __int64 v61; // x8

  result = 0LL;
  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(unsigned __int8 *)(v3 + 2) - 7;
  *(_BYTE *)v3 |= 4u;
  switch ( v4 )
  {
    case 0:
      v5 = *(unsigned __int8 *)(v3 + 5);
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(v3 + 96);
      if ( v5 )
      {
        sub_555F200(a1, v3);
      }
      else
      {
        v41 = *(_QWORD *)(*(_QWORD *)(v3 + 24) + 3064LL);
        sub_555F200(a1, v3);
        if ( v41 != v3 )
          goto LABEL_78;
      }
      v6 = *(_QWORD *)(a1 + 40);
      *(_QWORD *)(a1 + 40) = v3;
      v7 = *(_BYTE *)v3;
      *(_QWORD *)(v3 + 96) = v6;
      *(_BYTE *)v3 = v7 & 0xFB;
      if ( *(_BYTE *)(a1 + 33) != 3 )
        goto LABEL_86;
LABEL_78:
      v42 = *(_QWORD *)(v3 + 32);
      v43 = *(_QWORD *)(v3 + 48) + 16LL * *(int *)(v3 + 72);
      if ( v42 < v43 )
      {
        v44 = v42 + 16;
        if ( v43 > v42 + 16 )
          v44 = *(_QWORD *)(v3 + 48) + 16LL * *(int *)(v3 + 72);
        v45 = v44 + ~v42;
        v46 = *(_QWORD *)(v3 + 32);
        if ( v45 < 0x10 )
          goto LABEL_114;
        v47 = (v45 >> 4) + 1;
        v48 = v47 & 0x1FFFFFFFFFFFFFFELL;
        v46 = v42 + 16 * (v47 & 0x1FFFFFFFFFFFFFFELL);
        v49 = (_DWORD *)(v42 + 28);
        do
        {
          v48 -= 2LL;
          *(v49 - 4) = 0;
          *v49 = 0;
          v49 += 8;
        }
        while ( v48 );
        if ( v47 != (v47 & 0x1FFFFFFFFFFFFFFELL) )
        {
LABEL_114:
          do
          {
            *(_DWORD *)(v46 + 12) = 0;
            v46 += 16LL;
          }
          while ( v46 < v43 );
        }
      }
LABEL_86:
      if ( *(_BYTE *)(a1 + 33) == 1 )
      {
        v50 = *(_QWORD *)(v3 + 64);
        v51 = *(_QWORD *)(v3 + 16);
        v52 = *(_QWORD *)(v3 + 32);
        if ( v50 <= v51 )
        {
          v53 = *(_QWORD *)(v3 + 64);
          do
          {
            v54 = *(_QWORD *)(v53 + 16);
            v53 += 40LL;
            if ( v52 < v54 )
              v52 = v54;
          }
          while ( v53 <= v51 );
        }
        v55 = *(int *)(v3 + 76);
        if ( (int)v55 <= 20000 )
        {
          v56 = *(_QWORD *)(v3 + 48);
          if ( (int)v55 >= 17 && 3LL * (int)(-858993459 * ((v51 - v50) >> 3)) < v55 )
            sub_555C5CC(v3, (unsigned int)v55 >> 1);
          v57 = *(_DWORD *)(v3 + 72);
          if ( v57 >= 91 && (int)((__int64)(v52 - v56) >> 4) + 2LL * (int)((v52 - v56) >> 4) < (unsigned __int64)v57 )
            sub_555C430(v3, (unsigned int)v57 >> 1, 0);
        }
      }
      return 40LL * *(int *)(v3 + 76) + 16LL * *(int *)(v3 + 72) + 128;
    case 1:
      v8 = *(_BYTE **)(v3 + 40);
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(v3 + 24);
      if ( v8
        && ((*v8 & 3) == 0 || (sub_555E8B8(a1), (v8 = *(_BYTE **)(v3 + 40)) != 0LL))
        && (v8[5] & 2) == 0
        && (v9 = sub_556AD84((__int64)v8, 1, *(_QWORD *)(a1 + 2816))) != 0
        && *(_DWORD *)(v9 + 12) == 5 )
      {
        v10 = (const char *)(*(_QWORD *)v9 + 24LL);
        v11 = strchr(v10, 118);
        v12 = strchr(v10, 107);
        v13 = v12 != 0LL;
        if ( (unsigned __int64)v12 | (unsigned __int64)v11 )
        {
          v14 = *(_QWORD *)(a1 + 48);
          *(_QWORD *)(a1 + 48) = v3;
          *(_QWORD *)(v3 + 24) = v14;
        }
        if ( v12 && v11 )
        {
LABEL_75:
          *(_BYTE *)v3 &= ~4u;
          return 16LL * *(int *)(v3 + 8) + 32LL * (1 << *(_BYTE *)(v3 + 4)) + 48;
        }
        if ( v11 )
        {
          v15 = 1;
          goto LABEL_61;
        }
      }
      else
      {
        v13 = 0;
      }
      v15 = *(_DWORD *)(v3 + 8);
      if ( v15 )
      {
        v34 = 16LL * v15;
        do
        {
          v35 = *(_QWORD *)(v3 + 16) + v34;
          if ( *(int *)(v35 - 4) >= 5 && (**(_BYTE **)(v35 - 16) & 3) != 0 )
            sub_555E8B8(a1);
          v34 -= 16LL;
          --v15;
        }
        while ( v15 );
      }
LABEL_61:
      v36 = ~(-1 << *(_BYTE *)(v3 + 4));
      v37 = 32 * v36;
      v38 = v36 + 1;
      do
      {
        v39 = *(_QWORD *)(v3 + 32);
        v40 = v39 + v37;
        if ( *(_DWORD *)(v39 + v37 + 12) )
        {
          if ( !v13 && (*(_DWORD *)(v39 + v37 + 28) & 0xFu) >= 5 && (**(_BYTE **)(v39 + v37 + 16) & 3) != 0 )
            sub_555E8B8(a1);
          if ( (v15 & 1) == 0 && *(int *)(v40 + 12) >= 5 && (**(_BYTE **)(v39 + v37) & 3) != 0 )
            sub_555E8B8(a1);
        }
        else if ( (*(_DWORD *)(v40 + 28) & 0xFu) >= 5 )
        {
          *(_DWORD *)(v40 + 28) = *(_DWORD *)(v40 + 28) & 0xFFFFFFF0 | 0xD;
        }
        v37 -= 32LL;
        --v38;
      }
      while ( v38 );
      if ( (v13 | v15) != 1 )
        return 16LL * *(int *)(v3 + 8) + 32LL * (1 << *(_BYTE *)(v3 + 4)) + 48;
      goto LABEL_75;
    case 3:
      v16 = *(_BYTE **)(v3 + 16);
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(v3 + 8);
      if ( (*v16 & 3) != 0 )
        sub_555E8B8(a1);
      if ( *(_BYTE *)(v3 + 3) )
      {
        v17 = *(_BYTE *)(v3 + 4);
        if ( v17 )
        {
          v18 = 0LL;
          v19 = v3 + 48;
          do
          {
            if ( *(int *)(v19 + 12) >= 5 && (**(_BYTE **)v19 & 3) != 0 )
            {
              sub_555E8B8(a1);
              v17 = *(_BYTE *)(v3 + 4);
            }
            ++v18;
            v19 += 16LL;
          }
          while ( v18 < v17 );
        }
      }
      else
      {
        if ( (**(_BYTE **)(v3 + 24) & 3) != 0 )
          sub_555E8B8(a1);
        v58 = *(_BYTE *)(v3 + 4);
        if ( v58 )
        {
          v59 = 0LL;
          v60 = v3 + 32;
          do
          {
            if ( *(int *)(v60 + 12) >= 5 && (**(_BYTE **)v60 & 3) != 0 )
            {
              sub_555E8B8(a1);
              v58 = *(_BYTE *)(v3 + 4);
            }
            ++v59;
            v60 += 16LL;
            v17 = v58;
          }
          while ( v59 < v58 );
        }
        else
        {
          v17 = 0;
        }
      }
      v61 = 16LL * v17;
      if ( *(_BYTE *)(v3 + 3) )
        return v61 + 48;
      else
        return v61 + 32;
    case 4:
      v20 = *(_BYTE **)(v3 + 56);
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(v3 + 128);
      if ( v20 )
        *v20 &= 0xFCu;
      v21 = *(_BYTE **)(v3 + 96);
      if ( v21 )
        *v21 &= 0xFCu;
      v22 = *(_DWORD *)(v3 + 144);
      if ( v22 >= 1 )
      {
        v23 = 0LL;
        for ( i = 0LL; i < v22; ++i )
        {
          v25 = *(_QWORD *)(v3 + 32);
          if ( *(int *)(v25 + v23 + 12) >= 5 && (**(_BYTE **)(v25 + v23) & 3) != 0 )
          {
            sub_555E8B8(a1);
            v22 = *(_DWORD *)(v3 + 144);
          }
          v23 += 16LL;
        }
      }
      v26 = *(unsigned int *)(v3 + 164);
      if ( (int)v26 >= 1 )
      {
        v27 = *(_BYTE ***)(v3 + 64);
        do
        {
          if ( *v27 )
            **v27 &= 0xFCu;
          --v26;
          ++v27;
        }
        while ( v26 );
      }
      v28 = *(_DWORD *)(v3 + 160);
      if ( v28 >= 1 )
      {
        for ( j = 0LL; j < v28; ++j )
        {
          v30 = *(_BYTE **)(*(_QWORD *)(v3 + 24) + 8 * j);
          if ( v30 && (*v30 & 3) != 0 )
          {
            sub_555E8B8(a1);
            v28 = *(_DWORD *)(v3 + 160);
          }
        }
      }
      v31 = *(_DWORD *)(v3 + 148);
      if ( v31 >= 1 )
      {
        v32 = *(_BYTE ***)(v3 + 80);
        v33 = *(unsigned int *)(v3 + 148);
        do
        {
          if ( *v32 )
            **v32 &= 0xFCu;
          --v33;
          v32 += 3;
        }
        while ( v33 );
      }
      return 4LL * *(int *)(v3 + 168)
           + 16LL * *(int *)(v3 + 144)
           + *(int *)(v3 + 156)
           + 24LL * v31
           + *(int *)(v3 + 172)
           + 8 * (*(int *)(v3 + 164) + (__int64)v28)
           + 176;
    default:
      return result;
  }
}


================================================================================
Function: sub_555F200 (0x555F200)
================================================================================

__int64 __fastcall sub_555F200(__int64 result, _QWORD *a2)
{
  _BYTE *v3; // x1
  __int64 v4; // x19
  _BYTE *v5; // x8
  unsigned __int64 v6; // x21
  unsigned __int64 v7; // x8
  char *i; // x20
  char v9; // w8

  v3 = (_BYTE *)a2[13];
  v4 = result;
  if ( (*v3 & 3) != 0 )
    result = sub_555E8B8(result, v3);
  v5 = (_BYTE *)a2[14];
  if ( v5 )
    *v5 &= 0xFCu;
  v6 = a2[6];
  v7 = a2[4];
  while ( v6 < v7 )
  {
    if ( *(int *)(v6 + 12) >= 5 && (**(_BYTE **)v6 & 3) != 0 )
    {
      result = sub_555E8B8(v4, *(_BYTE **)v6);
      v7 = a2[4];
    }
    v6 += 16LL;
  }
  for ( i = (char *)a2[11]; i; i = (char *)*((_QWORD *)i + 4) )
  {
    v9 = *i;
    i[3] = 1;
    if ( (v9 & 3) != 0 )
      result = sub_555E8B8(v4, i);
  }
  return result;
}


================================================================================
Function: sub_555F2D0 (0x555F2D0)
================================================================================

__int64 __fastcall sub_555F2D0(__int64 result)
{
  _QWORD *v1; // x19
  _BYTE *v2; // x1
  _BYTE *v3; // x1
  _BYTE *v4; // x1
  _BYTE *v5; // x1
  _BYTE *v6; // x1
  _BYTE *v7; // x1
  _BYTE *v8; // x1
  _BYTE *v9; // x1
  _BYTE *v10; // x1
  _BYTE *v11; // x1
  _BYTE *v12; // x1

  v1 = (_QWORD *)result;
  v2 = *(_BYTE **)(result + 3072);
  if ( v2 && (*v2 & 3) != 0 )
    result = sub_555E8B8(result);
  v3 = (_BYTE *)v1[385];
  if ( v3 && (*v3 & 3) != 0 )
    result = sub_555E8B8(v1);
  v4 = (_BYTE *)v1[386];
  if ( v4 && (*v4 & 3) != 0 )
    result = sub_555E8B8(v1);
  v5 = (_BYTE *)v1[387];
  if ( v5 && (*v5 & 3) != 0 )
    result = sub_555E8B8(v1);
  v6 = (_BYTE *)v1[388];
  if ( v6 && (*v6 & 3) != 0 )
    result = sub_555E8B8(v1);
  v7 = (_BYTE *)v1[389];
  if ( v7 && (*v7 & 3) != 0 )
    result = sub_555E8B8(v1);
  v8 = (_BYTE *)v1[390];
  if ( v8 && (*v8 & 3) != 0 )
    result = sub_555E8B8(v1);
  v9 = (_BYTE *)v1[391];
  if ( v9 && (*v9 & 3) != 0 )
    result = sub_555E8B8(v1);
  v10 = (_BYTE *)v1[392];
  if ( v10 && (*v10 & 3) != 0 )
    result = sub_555E8B8(v1);
  v11 = (_BYTE *)v1[393];
  if ( v11 && (*v11 & 3) != 0 )
    result = sub_555E8B8(v1);
  v12 = (_BYTE *)v1[394];
  if ( v12 )
  {
    if ( (*v12 & 3) != 0 )
      return sub_555E8B8(v1);
  }
  return result;
}


================================================================================
Function: sub_5561DFC (0x5561DFC)
================================================================================

void __fastcall __noreturn sub_5561DFC(int a1)
{
  sub_555B7B0(a1, "memory allocation error: block too big");
}


================================================================================
Function: sub_5561E10 (0x5561E10)
================================================================================

_QWORD *__fastcall sub_5561E10(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v6; // x23
  __int64 v7; // x22
  __int64 v8; // x0
  _QWORD *v9; // x22
  __int64 v10; // t1
  __int64 v11; // x9
  __int64 v12; // x10
  __int64 *v13; // x8
  __int64 v14; // x0
  _QWORD *v15; // x22
  int v16; // w10
  __int64 v17; // x11
  _QWORD *v18; // x9
  __int64 v19; // x9
  void (__fastcall *v20)(__int64, _QWORD, __int64); // x8
  __int64 v21; // x10

  v6 = *(_QWORD *)(a1 + 24);
  if ( (unsigned __int64)(a2 - 1) <= 0x3FF && (byte_6F8CB50[a2 + 160] & 0x80000000) == 0 )
  {
    v7 = v6 + 8LL * (unsigned __int8)byte_6F8CB50[a2 + 160];
    v10 = *(_QWORD *)(v7 + 96);
    v9 = (_QWORD *)(v7 + 96);
    v8 = v10;
    if ( v10 )
    {
      v11 = *(unsigned int *)(v8 + 48);
      if ( (v11 & 0x80000000) == 0 )
      {
LABEL_5:
        v12 = v8 + v11;
        LODWORD(v11) = v11 - *(_DWORD *)(v8 + 36);
        v13 = (__int64 *)(v12 + 56);
        *(_DWORD *)(v8 + 48) = v11;
        goto LABEL_11;
      }
    }
    else
    {
      v8 = sub_5562748(a1, v6 + 96, 0LL);
      v11 = *(unsigned int *)(v8 + 48);
      if ( (v11 & 0x80000000) == 0 )
        goto LABEL_5;
    }
    v13 = *(__int64 **)(v8 + 40);
    *(_QWORD *)(v8 + 40) = *v13;
LABEL_11:
    v16 = *(_DWORD *)(v8 + 52);
    *v13 = v8;
    v17 = *(_QWORD *)(v8 + 40);
    *(_DWORD *)(v8 + 52) = v16 + 1;
    if ( !v17 && (v11 & 0x80000000) != 0 )
    {
      *v9 = *(_QWORD *)(v8 + 8);
      v18 = *(_QWORD **)(v8 + 8);
      if ( v18 )
        *v18 = 0LL;
      *(_QWORD *)(v8 + 8) = 0LL;
    }
    v15 = v13 + 1;
    goto LABEL_17;
  }
  v14 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64))(v6 + 16))(*(_QWORD *)(v6 + 24), 0LL, 0LL, a2);
  v15 = (_QWORD *)v14;
  if ( a2 && !v14 )
    sub_555C3F0(a1, 4LL);
LABEL_17:
  v19 = v6 + 8LL * a3;
  v20 = *(void (__fastcall **)(__int64, _QWORD, __int64))(v6 + 3360);
  v21 = *(_QWORD *)(v19 + 760) + a2;
  *(_QWORD *)(v6 + 88) += a2;
  *(_QWORD *)(v19 + 760) = v21;
  if ( v20 )
    v20(a1, 0LL, a2);
  return v15;
}


================================================================================
Function: sub_5561F60 (0x5561F60)
================================================================================

__int64 __fastcall sub_5561F60(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v6; // x23
  int v7; // w8
  __int64 v8; // x24
  __int64 v9; // x0
  __int64 v10; // x8
  __int64 v11; // x22
  __int64 v12; // x9
  int v13; // w10
  int v14; // w22
  __int64 v15; // x0
  __int64 v16; // x8
  __int64 v17; // x9
  void (__fastcall *v18)(__int64, _QWORD, __int64); // x8
  __int64 v19; // x10
  __int64 v21; // x9
  int v22; // w10
  _QWORD *v23; // x8

  v6 = *(_QWORD *)(a1 + 24);
  if ( (unsigned __int64)(a2 - 1) <= 0x3FF )
  {
    v7 = byte_6F8CB50[a2 + 160];
    if ( (v7 & 0x80000000) == 0 )
    {
      v8 = v6 + 8LL * (unsigned __int8)byte_6F8CB50[a2 + 160];
      v9 = *(_QWORD *)(v8 + 416);
      if ( v9 )
      {
        v10 = *(unsigned int *)(v9 + 48);
        if ( (v10 & 0x80000000) == 0 )
          goto LABEL_5;
      }
      else
      {
        v9 = sub_5562748(a1, v6 + 416, (__int64 *)(v6 + 744), v7, 0);
        v10 = *(unsigned int *)(v9 + 48);
        if ( (v10 & 0x80000000) == 0 )
        {
LABEL_5:
          v11 = v9 + v10 + 56;
          LODWORD(v10) = v10 - *(_DWORD *)(v9 + 36);
          v12 = *(_QWORD *)(v9 + 40);
          v13 = *(_DWORD *)(v9 + 52) + 1;
          *(_DWORD *)(v9 + 48) = v10;
          *(_DWORD *)(v9 + 52) = v13;
          if ( v12 )
            goto LABEL_11;
          goto LABEL_16;
        }
      }
      v11 = *(_QWORD *)(v9 + 40);
      v21 = *(_QWORD *)(v11 + 8);
      v22 = *(_DWORD *)(v9 + 52) + 1;
      *(_QWORD *)(v9 + 40) = v21;
      *(_DWORD *)(v9 + 52) = v22;
      if ( v21 )
        goto LABEL_11;
LABEL_16:
      if ( (v10 & 0x80000000) != 0 )
      {
        *(_QWORD *)(v8 + 416) = *(_QWORD *)(v9 + 8);
        v23 = *(_QWORD **)(v9 + 8);
        if ( v23 )
          *v23 = 0LL;
        *(_QWORD *)(v9 + 8) = 0LL;
      }
      goto LABEL_11;
    }
  }
  v14 = a2 + 56;
  v15 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(v6 + 16))(
          *(_QWORD *)(v6 + 24),
          0LL,
          0LL,
          (int)a2 + 56);
  if ( !v15 )
    sub_555C3F0(a1, 4);
  *(_QWORD *)(v15 + 40) = 0LL;
  *(_QWORD *)(v15 + 48) = 0LL;
  *(_DWORD *)(v15 + 32) = v14;
  *(_DWORD *)(v15 + 36) = a2;
  *(_OWORD *)v15 = 0u;
  *(_OWORD *)(v15 + 16) = 0u;
  v16 = *(_QWORD *)(v6 + 744);
  *(_QWORD *)(v15 + 24) = v16;
  if ( v16 )
    *(_QWORD *)(v16 + 16) = v15;
  v11 = v15 + 56;
  *(_QWORD *)(v6 + 744) = v15;
  *(_DWORD *)(v15 + 48) = -(int)a2;
  *(_DWORD *)(v15 + 52) = 1;
LABEL_11:
  v17 = v6 + 8LL * a3;
  v18 = *(void (__fastcall **)(__int64, _QWORD, __int64))(v6 + 3360);
  v19 = *(_QWORD *)(v17 + 760) + a2;
  *(_QWORD *)(v6 + 88) += a2;
  *(_QWORD *)(v17 + 760) = v19;
  if ( v18 )
    v18(a1, 0LL, a2);
  return v11;
}


================================================================================
Function: sub_55620F0 (0x55620F0)
================================================================================

__int64 __fastcall sub_55620F0(__int64 result, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v6; // x21
  unsigned int v7; // w9
  __int64 v8; // x1
  _QWORD *v9; // x8
  __int64 v10; // x10
  __int64 v11; // x8
  __int64 v12; // x10
  __int64 v13; // x10
  _QWORD *v14; // x10
  _QWORD *v15; // x11
  _QWORD *v16; // t1
  int v17; // w11
  _QWORD *v18; // x8
  _QWORD *v19; // x9
  __int64 v20; // x9
  __int64 v21; // t1

  v6 = *(_QWORD *)(result + 24);
  if ( (unsigned __int64)(a3 - 1) > 0x3FF || (v7 = byte_6F8CB50[a3 + 160], (v7 & 0x80000000) != 0) )
  {
    result = (*(__int64 (__fastcall **)(_QWORD))(v6 + 16))(*(_QWORD *)(v6 + 24));
  }
  else
  {
    v9 = (_QWORD *)(a2 - 8);
    v8 = *(_QWORD *)(a2 - 8);
    v10 = *(_QWORD *)(v8 + 40);
    if ( !v10 )
    {
      if ( (*(_DWORD *)(v8 + 48) & 0x80000000) != 0 )
      {
        v13 = v6 + 8LL * v7;
        v16 = *(_QWORD **)(v13 + 96);
        v14 = (_QWORD *)(v13 + 96);
        v15 = v16;
        *(_QWORD *)(v8 + 8) = v16;
        if ( v16 )
          *v15 = v8;
        *v14 = v8;
        v10 = *(_QWORD *)(v8 + 40);
      }
      else
      {
        v10 = 0LL;
      }
    }
    v17 = *(_DWORD *)(v8 + 52);
    *v9 = v10;
    *(_QWORD *)(v8 + 40) = v9;
    *(_DWORD *)(v8 + 52) = --v17;
    if ( !v17 )
    {
      v18 = *(_QWORD **)(v8 + 8);
      if ( v18 )
        *v18 = *(_QWORD *)v8;
      if ( *(_QWORD *)v8 )
      {
        v19 = (_QWORD *)(*(_QWORD *)v8 + 8LL);
      }
      else
      {
        v20 = v6 + 8LL * v7;
        v21 = *(_QWORD *)(v20 + 96);
        v19 = (_QWORD *)(v20 + 96);
        if ( v21 != v8 )
          goto LABEL_18;
      }
      *v19 = v18;
LABEL_18:
      result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(result + 24) + 16LL))(*(_QWORD *)(*(_QWORD *)(result + 24)
                                                                                               + 24LL));
    }
  }
  v11 = v6 + 8LL * a4;
  v12 = *(_QWORD *)(v11 + 760) - a3;
  *(_QWORD *)(v6 + 88) -= a3;
  *(_QWORD *)(v11 + 760) = v12;
  return result;
}


================================================================================
Function: sub_5562204 (0x5562204)
================================================================================

__int64 __fastcall sub_5562204(__int64 result, __int64 a2, __int64 a3, unsigned __int8 a4, __int64 a5)
{
  __int64 v7; // x21
  unsigned int v8; // w9
  __int64 v9; // x10
  __int64 v10; // x8
  __int64 v11; // x8
  __int64 v12; // x9
  _QWORD *v13; // x10
  __int64 v14; // x9
  __int64 v15; // x10
  _QWORD *v16; // x11
  _QWORD *v17; // x10
  int v18; // w11
  _QWORD *v19; // x10
  _QWORD *v20; // x9
  __int64 v21; // x9
  __int64 v22; // x10
  __int64 v23; // x11
  _QWORD *v24; // x8
  __int64 v25; // x8
  __int64 v26; // x10

  v7 = *(_QWORD *)(result + 24);
  if ( (unsigned __int64)(a3 - 1) > 0x3FF || (v8 = byte_6F8CB50[a3 + 160], (v8 & 0x80000000) != 0) )
  {
    v11 = *(_QWORD *)(a5 + 24);
    if ( v11 )
      *(_QWORD *)(v11 + 16) = *(_QWORD *)(a5 + 16);
    v12 = *(_QWORD *)(a5 + 16);
    if ( v12 )
    {
      v13 = (_QWORD *)(v12 + 24);
    }
    else
    {
      v13 = (_QWORD *)(v7 + 744);
      v14 = v7;
      if ( *(_QWORD *)(v7 + 744) != a5 )
        goto LABEL_29;
    }
    v14 = v7;
    *v13 = v11;
LABEL_29:
    result = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD))(v14 + 16))(
               *(_QWORD *)(v14 + 24),
               a5,
               *(int *)(a5 + 32),
               0LL);
    goto LABEL_30;
  }
  *(_BYTE *)(a2 + 2) = 0;
  v9 = *(_QWORD *)(a5 + 40);
  v10 = *(_QWORD *)(result + 24);
  if ( !v9 )
  {
    if ( (*(_DWORD *)(a5 + 48) & 0x80000000) != 0 )
    {
      v15 = v10 + 8LL * v8;
      v16 = *(_QWORD **)(v15 + 416);
      v17 = (_QWORD *)(v15 + 416);
      *(_QWORD *)(a5 + 8) = v16;
      if ( v16 )
        *v16 = a5;
      *v17 = a5;
      v9 = *(_QWORD *)(a5 + 40);
    }
    else
    {
      v9 = 0LL;
    }
  }
  v18 = *(_DWORD *)(a5 + 52);
  *(_QWORD *)(a2 + 8) = v9;
  *(_QWORD *)(a5 + 40) = a2;
  *(_DWORD *)(a5 + 52) = --v18;
  if ( !v18 )
  {
    v19 = *(_QWORD **)(a5 + 8);
    if ( v19 )
      *v19 = *(_QWORD *)a5;
    if ( *(_QWORD *)a5 )
    {
      v20 = (_QWORD *)(*(_QWORD *)a5 + 8LL);
    }
    else
    {
      v21 = v10 + 8LL * v8;
      if ( *(_QWORD *)(v21 + 416) != a5 )
        goto LABEL_23;
      v20 = (_QWORD *)(v21 + 416);
    }
    *v20 = v19;
LABEL_23:
    v22 = *(_QWORD *)(a5 + 24);
    v14 = *(_QWORD *)(result + 24);
    if ( v22 )
      *(_QWORD *)(v22 + 16) = *(_QWORD *)(a5 + 16);
    v23 = *(_QWORD *)(a5 + 16);
    if ( v23 )
    {
      v24 = (_QWORD *)(v23 + 24);
    }
    else
    {
      v24 = (_QWORD *)(v10 + 744);
      if ( *v24 != a5 )
        goto LABEL_29;
    }
    *v24 = v22;
    goto LABEL_29;
  }
LABEL_30:
  v25 = v7 + 8LL * a4;
  v26 = *(_QWORD *)(v25 + 760) - a3;
  *(_QWORD *)(v7 + 88) -= a3;
  *(_QWORD *)(v25 + 760) = v26;
  return result;
}


================================================================================
Function: sub_556238C (0x556238C)
================================================================================

void *__fastcall sub_556238C(__int64 a1, char *a2, size_t a3, size_t a4, unsigned __int8 a5)
{
  unsigned int v10; // w3
  __int64 v11; // x25
  unsigned int v12; // w26
  __int64 v13; // x0
  void *v14; // x24
  __int64 v15; // x24
  __int64 v16; // x0
  _QWORD *v17; // x24
  __int64 v18; // t1
  __int64 v19; // x9
  __int64 v20; // x10
  __int64 *v21; // x8
  __int64 v22; // x0
  _BOOL4 v23; // w8
  int v24; // w10
  __int64 v25; // x11
  _QWORD *v26; // x9
  size_t v27; // x2
  __int64 v28; // x1
  char *v29; // x23
  __int64 v30; // t1
  __int64 v31; // x8
  __int64 v32; // x9
  __int64 v33; // x9
  _QWORD *v34; // x9
  _QWORD *v35; // x10
  _QWORD *v36; // t1
  int v37; // w10
  _QWORD *v38; // x9
  _QWORD *v39; // x8
  __int64 v40; // x8
  __int64 v41; // t1
  __int64 v42; // x9
  void (__fastcall *v43)(__int64, size_t, size_t); // x8
  size_t v44; // x10

  if ( a4 - 1 > 0x3FF )
    v10 = -1;
  else
    v10 = byte_6F8CB50[a4 + 160];
  v11 = *(_QWORD *)(a1 + 24);
  if ( a3 - 1 > 0x3FF )
  {
    v12 = -1;
    if ( (v10 & 0x80000000) == 0 )
      goto LABEL_12;
  }
  else
  {
    v12 = byte_6F8CB50[a3 + 160];
    if ( (v10 & 0x80000000) == 0 )
      goto LABEL_12;
  }
  if ( (v12 & 0x80000000) != 0 )
  {
    v13 = (*(__int64 (__fastcall **)(_QWORD, char *, size_t, size_t))(v11 + 16))(*(_QWORD *)(v11 + 24), a2, a3, a4);
    v14 = (void *)v13;
    if ( !a4 || v13 )
      goto LABEL_49;
    goto LABEL_18;
  }
LABEL_12:
  if ( (v10 & 0x80000000) != 0 )
  {
    v22 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, size_t))(v11 + 16))(*(_QWORD *)(v11 + 24), 0LL, 0LL, a4);
    v14 = (void *)v22;
    v23 = a4 != 0;
    if ( !a4 || v22 )
      goto LABEL_27;
LABEL_18:
    sub_555C3F0(a1, 4);
  }
  v15 = v11 + 8LL * v10;
  v18 = *(_QWORD *)(v15 + 96);
  v17 = (_QWORD *)(v15 + 96);
  v16 = v18;
  if ( v18 )
  {
    v19 = *(unsigned int *)(v16 + 48);
    if ( (v19 & 0x80000000) == 0 )
    {
LABEL_15:
      v20 = v16 + v19;
      LODWORD(v19) = v19 - *(_DWORD *)(v16 + 36);
      v21 = (__int64 *)(v20 + 56);
      *(_DWORD *)(v16 + 48) = v19;
      goto LABEL_21;
    }
  }
  else
  {
    v16 = sub_5562748(a1, v11 + 96, 0LL, v10, 1);
    v19 = *(unsigned int *)(v16 + 48);
    if ( (v19 & 0x80000000) == 0 )
      goto LABEL_15;
  }
  v21 = *(__int64 **)(v16 + 40);
  *(_QWORD *)(v16 + 40) = *v21;
LABEL_21:
  v24 = *(_DWORD *)(v16 + 52);
  *v21 = v16;
  v25 = *(_QWORD *)(v16 + 40);
  *(_DWORD *)(v16 + 52) = v24 + 1;
  if ( !v25 && (v19 & 0x80000000) != 0 )
  {
    *v17 = *(_QWORD *)(v16 + 8);
    v26 = *(_QWORD **)(v16 + 8);
    if ( v26 )
      *v26 = 0LL;
    *(_QWORD *)(v16 + 8) = 0LL;
  }
  v14 = v21 + 1;
  v23 = a4 != 0;
LABEL_27:
  if ( a3 && v23 )
  {
    if ( a4 <= a3 )
      v27 = a4;
    else
      v27 = a3;
    memcpy(v14, a2, v27);
  }
  if ( (v12 & 0x80000000) != 0 )
  {
    (*(void (__fastcall **)(_QWORD, char *, size_t, _QWORD))(v11 + 16))(*(_QWORD *)(v11 + 24), a2, a3, 0LL);
    goto LABEL_49;
  }
  v30 = *((_QWORD *)a2 - 1);
  v29 = a2 - 8;
  v28 = v30;
  v31 = *(_QWORD *)(a1 + 24);
  v32 = *(_QWORD *)(v30 + 40);
  if ( !v32 )
  {
    if ( (*(_DWORD *)(v28 + 48) & 0x80000000) != 0 )
    {
      v33 = v31 + 8LL * v12;
      v36 = *(_QWORD **)(v33 + 96);
      v34 = (_QWORD *)(v33 + 96);
      v35 = v36;
      *(_QWORD *)(v28 + 8) = v36;
      if ( v36 )
        *v35 = v28;
      *v34 = v28;
      v32 = *(_QWORD *)(v28 + 40);
    }
    else
    {
      v32 = 0LL;
    }
  }
  v37 = *(_DWORD *)(v28 + 52);
  *(_QWORD *)v29 = v32;
  *(_QWORD *)(v28 + 40) = v29;
  *(_DWORD *)(v28 + 52) = --v37;
  if ( !v37 )
  {
    v38 = *(_QWORD **)(v28 + 8);
    if ( v38 )
      *v38 = *(_QWORD *)v28;
    if ( *(_QWORD *)v28 )
    {
      v39 = (_QWORD *)(*(_QWORD *)v28 + 8LL);
    }
    else
    {
      v40 = v31 + 8LL * v12;
      v41 = *(_QWORD *)(v40 + 96);
      v39 = (_QWORD *)(v40 + 96);
      if ( v41 != v28 )
        goto LABEL_48;
    }
    *v39 = v38;
LABEL_48:
    (*(void (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 24) + 16LL))(
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24LL),
      v28,
      *(int *)(v28 + 32),
      0LL);
  }
LABEL_49:
  v42 = v11 + 8LL * a5;
  v43 = *(void (__fastcall **)(__int64, size_t, size_t))(v11 + 3360);
  v44 = a4 - a3 + *(_QWORD *)(v42 + 760);
  *(_QWORD *)(v11 + 88) += a4 - a3;
  *(_QWORD *)(v42 + 760) = v44;
  if ( v43 )
    v43(a1, a3, a4);
  return v14;
}


================================================================================
Function: sub_556262C (0x556262C)
================================================================================

int *__fastcall sub_556262C(int *result, _QWORD *a2, __int64 *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int64 v5; // x10
  unsigned __int64 v6; // x9
  __int64 v7; // x11
  __int64 v8; // x8
  __int64 v9; // x9

  v5 = result[9];
  v6 = result[8] - 56LL;
  v7 = (__int64)result + result[12] + 56;
  *a4 = result[13];
  v8 = (__int64)result + v5 * (int)(v6 / v5) + 56;
  v9 = v7 + v5;
  LODWORD(v5) = result[9];
  *a2 = v9;
  *a3 = v8;
  *a5 = v5;
  return result;
}


================================================================================
Function: sub_556266C (0x556266C)
================================================================================

__int64 __fastcall sub_556266C(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}


================================================================================
Function: sub_5562748 (0x5562748)
================================================================================

__int64 __fastcall sub_5562748(__int64 a1, __int64 a2, __int64 *a3, unsigned __int8 a4, char a5)
{
  __int64 v5; // x23
  int v7; // w24
  __int64 v10; // x21
  int v11; // w25
  __int64 result; // x0
  __int64 v13; // x8

  v5 = a4;
  v7 = *(_DWORD *)&byte_6F8CB50[4 * a4];
  if ( v7 <= 512 )
    v10 = 16360LL;
  else
    v10 = 32744LL;
  if ( (a5 & 1) != 0 )
    v11 = 8;
  else
    v11 = 0;
  result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64))(*(_QWORD *)(a1 + 24) + 16LL))(
             *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24LL),
             0LL,
             0LL,
             v10);
  if ( !result )
    sub_555C3F0(a1, 4LL);
  *(_QWORD *)(result + 40) = 0LL;
  *(_DWORD *)(result + 32) = v10;
  *(_DWORD *)(result + 36) = v7 + v11;
  *(_OWORD *)result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_QWORD *)(result + 48) = ((unsigned int)((v10 - 56) / (unsigned __int64)(v7 + v11)) - 1) * (v7 + v11);
  if ( a3 )
  {
    v13 = *a3;
    *(_QWORD *)(result + 24) = *a3;
    if ( v13 )
      *(_QWORD *)(v13 + 16) = result;
    *a3 = result;
  }
  *(_QWORD *)(a2 + 8 * v5) = result;
  return result;
}


================================================================================
Function: sub_5562DA0 (0x5562DA0)
================================================================================

__int64 __fastcall sub_5562DA0(unsigned int a1)
{
  int v1; // w8
  unsigned int v2; // w9
  unsigned int v3; // w10

  v1 = -1;
  if ( a1 >= 0x100 )
  {
    v2 = a1;
    do
    {
      a1 = v2 >> 8;
      v3 = HIWORD(v2);
      v1 += 8;
      v2 >>= 8;
    }
    while ( v3 );
  }
  return v1 + (unsigned int)byte_10308B8[a1];
}


================================================================================
Function: sub_5562E98 (0x5562E98)
================================================================================

__int64 __fastcall sub_5562E98(__int64 a1, __int64 a2)
{
  int v2; // w9
  unsigned int v3; // w8
  float v4; // w8
  float v5; // w9
  bool v6; // zf
  __int64 result; // x0

  v2 = *(_DWORD *)(a1 + 12) & 0xF;
  if ( v2 != *(_DWORD *)(a2 + 12) )
    return 0LL;
  v3 = 1;
  switch ( v2 )
  {
    case 0:
      goto LABEL_16;
    case 1:
      v4 = *(float *)a1;
      v5 = *(float *)a2;
      goto LABEL_12;
    case 2:
      v6 = *(double *)a1 == *(double *)a2;
      goto LABEL_13;
    case 3:
      if ( *(float *)a1 != *(float *)a2 || *(float *)(a1 + 4) != *(float *)(a2 + 4) )
        return 0LL;
      v6 = *(float *)(a1 + 8) == *(float *)(a2 + 8);
      goto LABEL_13;
    case 4:
      if ( *(_QWORD *)a1 != *(_QWORD *)a2 )
        return 0LL;
      v4 = *(float *)(a1 + 8);
      v5 = *(float *)(a2 + 8);
LABEL_12:
      v6 = LODWORD(v4) == LODWORD(v5);
      goto LABEL_13;
    default:
      v6 = *(_QWORD *)a1 == *(_QWORD *)a2;
LABEL_13:
      v3 = v6;
LABEL_16:
      result = v3;
      break;
  }
  return result;
}


================================================================================
Function: sub_5563040 (0x5563040)
================================================================================

__int64 __fastcall sub_5563040(__int64 a1, char *format, _OWORD *a3)
{
  __int128 v4; // q1
  __int64 v5; // x21
  size_t v6; // x0
  _QWORD *v7; // x8
  _OWORD v9[2]; // [xsp+0h] [xbp-230h] BYREF
  int s[128]; // [xsp+28h] [xbp-208h] BYREF

  v4 = a3[1];
  v9[0] = *a3;
  v9[1] = v4;
  vsnprintf((char *)s, 0x200uLL, format, v9);
  v5 = *(_QWORD *)(a1 + 32);
  v6 = __strlen_chk((const char *)s, 0x200uLL);
  *(_QWORD *)v5 = sub_55645D8(a1, s, v6);
  *(_DWORD *)(v5 + 12) = 5;
  v7 = *(_QWORD **)(a1 + 32);
  if ( (__int64)(*(_QWORD *)(a1 + 40) - (_QWORD)v7) <= 16 )
  {
    sub_555C64C();
    v7 = *(_QWORD **)(a1 + 32);
  }
  *(_QWORD *)(a1 + 32) = v7 + 2;
  return *v7 + 24LL;
}


================================================================================
Function: sub_556310C (0x556310C)
================================================================================

__int64 sub_556310C(__int64 a1, char *format, ...)
{
  __int64 v3; // x21
  size_t v4; // x0
  _QWORD *v5; // x8
  gcc_va_list va; // [xsp+B0h] [xbp-250h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-230h] BYREF
  int s[128]; // [xsp+F8h] [xbp-208h] BYREF

  va_start(va, format);
  va_copy(arg, va);
  vsnprintf((char *)s, 0x200uLL, format, arg);
  v3 = *(_QWORD *)(a1 + 32);
  v4 = __strlen_chk((const char *)s, 0x200uLL);
  *(_QWORD *)v3 = sub_55645D8(a1, s, v4);
  *(_DWORD *)(v3 + 12) = 5;
  v5 = *(_QWORD **)(a1 + 32);
  if ( (__int64)(*(_QWORD *)(a1 + 40) - (_QWORD)v5) <= 16 )
  {
    sub_555C64C();
    v5 = *(_QWORD **)(a1 + 32);
  }
  *(_QWORD *)(a1 + 32) = v5 + 2;
  return *v5 + 24LL;
}


================================================================================
Function: sub_556321C (0x556321C)
================================================================================

char *__fastcall sub_556321C(char *dest, unsigned __int64 a2, char *s, unsigned __int64 a4)
{
  int v4; // w8
  char *v7; // x19
  size_t v8; // x0
  size_t v9; // x2
  char *v10; // x0

  v4 = (unsigned __int8)*s;
  v7 = dest;
  if ( v4 == 64 )
  {
    if ( a4 <= a2 )
    {
      return s + 1;
    }
    else
    {
      dest[2] = 46;
      *(_WORD *)dest = 11822;
      memcpy(dest + 3, &s[a4 - a2 + 4], a2 - 4);
      v7[a2 - 1] = 0;
    }
  }
  else if ( v4 == 61 )
  {
    if ( a4 <= a2 )
    {
      return s + 1;
    }
    else
    {
      memcpy(dest, s + 1, a2 - 1);
      v7[a2 - 1] = 0;
    }
  }
  else
  {
    v8 = strcspn(s, "\n\r");
    if ( v8 <= a2 - 15 )
      v9 = v8;
    else
      v9 = a2 - 15;
    strcpy(v7, "[string \"");
    if ( s[v9] )
    {
      v10 = strncat(v7, s, v9);
      *(_DWORD *)&v7[strlen(v10)] = 3026478;
    }
    else
    {
      strcat(v7, s);
    }
    strcpy(&v7[strlen(v7)], "\"]");
  }
  return v7;
}


================================================================================
Function: sub_5563B14 (0x5563B14)
================================================================================

double sub_5563B14()
{
  unsigned __int8 v0; // w8
  __int64 v2; // [xsp+8h] [xbp-18h] BYREF
  __int64 v3; // [xsp+10h] [xbp-10h]

  v0 = atomic_load(byte_6F8D000);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8(byte_6F8D000) )
  {
    qword_6F8CFF8 = 0x3E112E0BE826D695LL;
    sub_6862850(byte_6F8D000);
  }
  clock_gettime(1, (struct timespec *)&v2);
  return ((double)v2 * 1000000000.0 + (double)v3) * *(double *)&qword_6F8CFF8;
}


================================================================================
Function: sub_5563D94 (0x5563D94)
================================================================================

__int64 __fastcall sub_5563D94(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v6)(_QWORD, __int64); // x8

  v6 = *(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(a1 + 24) + 3312LL);
  if ( v6 )
    v6(0LL, a2);
  sub_55620F0(a1, *(_QWORD *)(a2 + 64), 40LL * *(int *)(a2 + 76), *(_BYTE *)(a2 + 1));
  sub_55620F0(a1, *(_QWORD *)(a2 + 48), 16LL * *(int *)(a2 + 72), *(_BYTE *)(a2 + 1));
  return sub_5562204(a1, a2, 128LL, *(unsigned __int8 *)(a2 + 1), a3);
}


================================================================================
Function: sub_55642D4 (0x55642D4)
================================================================================

__int64 __fastcall sub_55642D4(__int64 a1, unsigned int a2)
{
  __int64 v4; // x22
  _QWORD *v5; // x0
  _QWORD *v6; // x21
  __int64 v7; // x23
  __int64 v8; // x8
  __int64 i; // x9
  __int64 v10; // x11
  __int64 v11; // x14
  __int64 v12; // x12
  __int64 result; // x0

  if ( (a2 & 0x80000000) != 0 )
    sub_5561DFC(a1);
  v4 = 8LL * a2;
  v5 = sub_5561E10(a1, v4, 0);
  v6 = v5;
  v7 = *(_QWORD *)(a1 + 24);
  if ( a2 )
    memset(v5, 0, v4);
  v8 = *(unsigned int *)(v7 + 4);
  if ( (int)v8 >= 1 )
  {
    for ( i = 0LL; i != v8; ++i )
    {
      v10 = *(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * i);
      if ( v10 )
      {
        do
        {
          v11 = *(_QWORD *)(v10 + 8);
          v12 = (int)(*(_DWORD *)(v10 + 16) & (a2 - 1));
          *(_QWORD *)(v10 + 8) = v6[v12];
          v6[v12] = v10;
          v10 = v11;
        }
        while ( v11 );
      }
    }
  }
  result = sub_55620F0(a1, *(_QWORD *)(v7 + 8), 8LL * (int)v8, 0);
  *(_DWORD *)(v7 + 4) = a2;
  *(_QWORD *)(v7 + 8) = v6;
  return result;
}


================================================================================
Function: sub_55645D8 (0x55645D8)
================================================================================

__int64 __fastcall sub_55645D8(__int64 a1, int *s1, size_t n)
{
  int v6; // w10
  int v7; // w11
  unsigned int v8; // w24
  size_t v9; // x8
  int *v10; // x9
  int v11; // w12
  int v12; // w15
  int v13; // t1
  int v14; // w12
  unsigned __int64 v15; // t2
  char *v16; // x9
  int v17; // w10
  __int64 v18; // x23
  __int64 v19; // x22
  __int64 v20; // x0
  char v21; // w10
  __int64 v22; // x23
  char v23; // w8
  __int64 v24; // x10
  int v25; // w8
  __int64 v26; // x12
  unsigned int v27; // w9
  __int64 v28; // x11

  if ( n < 0x20 )
  {
    v8 = n;
    v9 = n;
    v10 = s1;
    if ( !n )
    {
      v8 = 0;
      goto LABEL_8;
    }
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = n;
    v9 = n;
    v10 = s1;
    do
    {
      v12 = v10[1];
      v11 = v10[2];
      v13 = *v10;
      v10 += 3;
      v9 -= 12LL;
      v14 = v11 + v8;
      HIDWORD(v15) = v14;
      LODWORD(v15) = v14;
      v7 = (v14 ^ (v13 + v7)) - (v15 >> 14);
      HIDWORD(v15) = v7;
      LODWORD(v15) = v7;
      v6 = (v7 ^ (v12 + v6)) - (v15 >> 11);
      HIDWORD(v15) = v6;
      LODWORD(v15) = v6;
      v8 = (v6 ^ v14) - (v15 >> 25);
    }
    while ( v9 > 0x1F );
  }
  v16 = (char *)v10 - 1;
  do
  {
    v17 = (unsigned __int8)v16[v9--];
    v8 ^= 32 * v8 + (v8 >> 2) + v17;
  }
  while ( v9 );
LABEL_8:
  v18 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(*(_QWORD *)(v18 + 8) + 8LL * (int)((*(_DWORD *)(v18 + 4) - 1) & v8));
  if ( v19 )
  {
    while ( *(_DWORD *)(v19 + 20) != n || memcmp(s1, (const void *)(v19 + 24), n) )
    {
      v19 = *(_QWORD *)(v19 + 8);
      if ( !v19 )
        goto LABEL_9;
    }
    if ( (*(_BYTE *)v19 & 0xB) == (~*(_BYTE *)(v18 + 32) & 3) )
      *(_BYTE *)v19 ^= 3u;
  }
  else
  {
LABEL_9:
    if ( n >= 0x40000001 )
      sub_5561DFC(a1);
    v20 = sub_5561F60(a1, n + 25, *(unsigned __int8 *)(a1 + 4));
    v21 = *(_BYTE *)(a1 + 4);
    v22 = v20 + 24;
    v19 = v20;
    v23 = *(_BYTE *)(*(_QWORD *)(a1 + 24) + 32LL);
    *(_BYTE *)(v20 + 2) = 5;
    *(_BYTE *)(v20 + 1) = v21;
    *(_DWORD *)(v20 + 4) = -32768;
    *(_DWORD *)(v20 + 16) = v8;
    *(_DWORD *)(v20 + 20) = n;
    *(_BYTE *)v20 = v23 & 3;
    memcpy((void *)(v20 + 24), s1, n);
    *(_BYTE *)(v22 + n) = 0;
    v24 = *(_QWORD *)(a1 + 24);
    v25 = *(_DWORD *)(v24 + 4);
    v26 = *(_QWORD *)(v24 + 8);
    v27 = *(_DWORD *)v24 + 1;
    v28 = 8LL * ((v25 - 1) & v8);
    *(_DWORD *)v24 = v27;
    *(_QWORD *)(v19 + 8) = *(_QWORD *)(v26 + v28);
    *(_QWORD *)(v26 + v28) = v19;
    if ( v25 <= 0x3FFFFFFF && v27 > v25 )
      sub_55642D4(a1, (unsigned int)(2 * v25));
  }
  return v19;
}


================================================================================
Function: sub_5567F64 (0x5567F64)
================================================================================

__int64 __fastcall sub_5567F64(__int64 a1, int a2, __int64 a3)
{
  void *v3; // x9
  _BOOL4 v4; // w11
  int v5; // w13
  __int64 v6; // x15
  char *v7; // x17
  __int64 v8; // x8
  double v9; // x17
  unsigned __int64 v10; // x1
  int v11; // w1
  int v12; // w2

  v3 = *(void **)(a1 + 32);
  if ( v3 == &unk_1030AB8 )
  {
    v4 = *(_DWORD *)(a1 + 8) > a2;
    if ( !a3 )
      goto LABEL_9;
  }
  else
  {
    v4 = 1;
    if ( !a3 )
      goto LABEL_9;
  }
  if ( *(_DWORD *)(a3 + 12) == 2 )
  {
    if ( *(double *)a3 == (double)(int)*(double *)a3 )
      v5 = (int)*(double *)a3;
    else
      v5 = -1;
    goto LABEL_10;
  }
LABEL_9:
  v5 = -1;
LABEL_10:
  v6 = a2;
  do
  {
    do
      v8 = v6++;
    while ( v5 == (_DWORD)v6 );
    if ( !v4 )
      break;
    if ( *(_DWORD *)(a1 + 8) > (unsigned int)v8 )
    {
      v7 = (char *)(*(_QWORD *)(a1 + 16) + 16 * v8);
    }
    else if ( v3 == &unk_1030AB8 )
    {
LABEL_22:
      v7 = (char *)&unk_10308A8;
    }
    else
    {
      v9 = (double)(int)v6;
      v10 = HIDWORD(COERCE_UNSIGNED_INT64((double)(int)v6)) & 0x7FFFFFFF;
      v11 = (1540483477
           * ((1540483477 * (v10 ^ ((1540483477 * (LODWORD(v9) ^ ((unsigned int)v10 >> 18))) >> 22))) ^ ((1540483477 * ((1540483477 * (LODWORD(v9) ^ ((unsigned int)v10 >> 18))) ^ ((1540483477 * ((unsigned int)v10 ^ ((1540483477 * (LODWORD(v9) ^ ((unsigned int)v10 >> 18))) >> 22))) >> 17))) >> 19))) & ~(-1 << *(_BYTE *)(a1 + 4));
      v7 = *(char **)(a1 + 32);
      while ( 1 )
      {
        v7 += 32 * v11;
        v12 = *((_DWORD *)v7 + 7);
        if ( (v12 & 0xF) == 2 && *((double *)v7 + 2) == (double)(int)v6 )
          break;
        v11 = v12 >> 4;
        if ( (unsigned int)v12 <= 0xF )
          goto LABEL_22;
      }
    }
  }
  while ( *((_DWORD *)v7 + 3) );
  return (unsigned int)v8;
}


================================================================================
Function: sub_5568098 (0x5568098)
================================================================================

__int64 __fastcall sub_5568098(__int64 result, __int64 a2, int a3, int a4, long double a5, long double a6)
{
  __int64 v6; // x19
  int v7; // w23
  __int64 v8; // x26
  int v11; // w25
  void *v12; // x21
  __int64 v13; // x11
  unsigned __int64 v14; // x9
  __int64 v15; // x8
  _DWORD *v16; // x11
  unsigned __int64 v17; // x12
  __int64 v18; // x9
  __int64 v19; // x8
  _DWORD *v20; // x9
  int v21; // w0
  int v22; // w28
  __int64 v23; // x9
  __int64 v24; // x8
  __int64 v25; // x9
  __int64 v26; // x10
  __int64 v27; // x27
  long double *v28; // x0
  __int64 v29; // x24
  int v30; // w22
  int v31; // w23
  __int64 v32; // x25
  double v33; // x8
  int v34; // w8
  int v35; // w8
  double v36; // [xsp+8h] [xbp-18h] BYREF
  int v37; // [xsp+10h] [xbp-10h]
  int v38; // [xsp+14h] [xbp-Ch]

  v6 = result;
  if ( a3 > 0x4000000 )
    goto LABEL_43;
  v7 = a4;
  if ( a4 >= 67108865 )
    goto LABEL_43;
  v8 = *(int *)(a2 + 8);
  v11 = *(unsigned __int8 *)(a2 + 4);
  v12 = *(void **)(a2 + 32);
  if ( (int)v8 < a3 )
  {
    if ( a3 < 0 )
      goto LABEL_44;
    result = (__int64)sub_556238C(result, *(char **)(a2 + 16), 16 * v8, 16LL * (unsigned int)a3, *(_BYTE *)(a2 + 1));
    v13 = *(int *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = result;
    if ( (int)v13 < a3 )
    {
      v14 = (unsigned int)a3 - v13;
      v15 = v13;
      if ( v14 < 2 )
        goto LABEL_10;
      v15 = (v14 & 0xFFFFFFFFFFFFFFFELL) + v13;
      v16 = (_DWORD *)(result + 16 * v13 + 28);
      v17 = v14 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v17 -= 2LL;
        *(v16 - 4) = 0;
        *v16 = 0;
        v16 += 8;
      }
      while ( v17 );
      if ( v14 != (v14 & 0xFFFFFFFFFFFFFFFELL) )
      {
LABEL_10:
        v18 = result + 16 * v15;
        v19 = (unsigned int)a3 - v15;
        v20 = (_DWORD *)(v18 + 12);
        do
        {
          --v19;
          *v20 = 0;
          v20 += 4;
        }
        while ( v19 );
      }
    }
    *(_DWORD *)(a2 + 8) = a3;
  }
  if ( !v7 )
  {
    v22 = 0;
    *(_QWORD *)(a2 + 32) = &unk_1030AB8;
    goto LABEL_23;
  }
  v21 = sub_5562DA0(v7 - 1);
  if ( v21 >= 26 )
LABEL_43:
    sub_555B7B0(v6, "table overflow");
  LOBYTE(v7) = v21 + 1;
  v22 = 1 << (v21 + 1);
  result = (__int64)sub_5561E10(v6, 32LL * v22, *(_BYTE *)(a2 + 1));
  *(_QWORD *)(a2 + 32) = result;
  if ( v22 <= 1 )
    v23 = 1LL;
  else
    v23 = (unsigned int)v22;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 12) = 0;
  if ( v22 >= 2 )
  {
    v24 = 0LL;
    v25 = 32 * v23 - 32;
    do
    {
      v26 = *(_QWORD *)(a2 + 32) + v24;
      v24 += 32LL;
      *(_DWORD *)(v26 + 60) = 0;
      *(_DWORD *)(v26 + 44) = 0;
    }
    while ( v25 != v24 );
  }
LABEL_23:
  *(_BYTE *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 12) = v22;
  *(_BYTE *)(a2 + 3) = ~(-1 << v7);
  if ( (int)v8 <= a3 )
    goto LABEL_30;
  v27 = a3;
  *(_DWORD *)(a2 + 8) = a3;
  do
  {
    while ( 1 )
    {
      v29 = *(_QWORD *)(a2 + 16);
      if ( !*(_DWORD *)(v29 + 16 * v27 + 12) )
        break;
      v38 = 2;
      *(double *)&a5 = (double)((int)v27 + 1);
      v36 = *(double *)&a5;
      v28 = (long double *)sub_5568B9C(v6, a2, (__int64)&v36, a5, a6);
      a5 = *(long double *)(v29 + 16 * v27++);
      *v28 = a5;
      if ( (_DWORD)v27 == (_DWORD)v8 )
        goto LABEL_28;
    }
    ++v27;
  }
  while ( (_DWORD)v27 != (_DWORD)v8 );
LABEL_28:
  if ( a3 < 0 )
LABEL_44:
    sub_5561DFC(v6);
  result = (__int64)sub_556238C(v6, *(char **)(a2 + 16), 16 * v8, 16LL * (unsigned int)a3, *(_BYTE *)(a2 + 1));
  *(_QWORD *)(a2 + 16) = result;
LABEL_30:
  v30 = 1 << v11;
  if ( v11 != 31 )
  {
    v31 = v30 + 1;
    v32 = (__int64)v12 + 32 * (unsigned int)(v30 - 1) + 16;
    do
    {
      if ( *(_DWORD *)(v32 - 4) )
      {
        v33 = *(double *)v32;
        v36 = *(double *)v32;
        v37 = *(_DWORD *)(v32 + 8);
        v38 = *(_DWORD *)(v32 + 12) & 0xF;
        if ( v38 == 2
          && (*(double *)&a5 = v33, v34 = (int)v33, *(double *)&a6 = (double)v34, *(double *)&a5 == (double)v34)
          && (v35 = v34 - 1, (unsigned int)v35 < *(_DWORD *)(a2 + 8)) )
        {
          result = *(_QWORD *)(a2 + 16) + 16LL * v35;
        }
        else
        {
          result = sub_5568B9C(v6, a2, (__int64)&v36, a5, a6);
        }
        a5 = *(long double *)(v32 - 16);
        *(long double *)result = a5;
      }
      --v31;
      v32 -= 32LL;
    }
    while ( v31 > 1 );
  }
  if ( v12 != &unk_1030AB8 )
    return sub_55620F0(v6, (__int64)v12, 32LL * v30, *(_BYTE *)(a2 + 1));
  return result;
}


================================================================================
Function: sub_55683E4 (0x55683E4)
================================================================================

__int64 __fastcall sub_55683E4(int a1)
{
  return sub_5568098(a1);
}


================================================================================
Function: sub_55683F0 (0x55683F0)
================================================================================

__int64 __fastcall sub_55683F0(__int64 a1, unsigned int a2, int a3)
{
  __int64 v6; // x19
  __int64 v7; // x4
  char v8; // w8
  __int64 v9; // x0
  __int64 v10; // x11
  unsigned __int64 v11; // x9
  __int64 v12; // x8
  _DWORD *v13; // x11
  unsigned __int64 v14; // x12
  __int64 v15; // x9
  __int64 v16; // x8
  _DWORD *v17; // x9
  int v18; // w0
  char v19; // w21
  int v20; // w22
  _QWORD *v21; // x0
  __int64 v22; // x9
  __int64 v23; // x8
  __int64 v24; // x9
  __int64 v25; // x10

  v6 = sub_5561F60(a1, 48LL, *(unsigned __int8 *)(a1 + 4));
  v7 = *(unsigned __int8 *)(a1 + 4);
  v8 = *(_BYTE *)(*(_QWORD *)(a1 + 24) + 32LL);
  *(_QWORD *)(v6 + 8) = 0LL;
  *(_QWORD *)(v6 + 16) = 0LL;
  *(_BYTE *)(v6 + 2) = 8;
  *(_BYTE *)(v6 + 5) = -1;
  *(_BYTE *)(v6 + 1) = v7;
  *(_WORD *)(v6 + 6) = 0;
  *(_WORD *)(v6 + 3) = 0;
  *(_BYTE *)v6 = v8 & 3;
  *(_QWORD *)(v6 + 32) = &unk_1030AB8;
  *(_QWORD *)(v6 + 40) = 0LL;
  if ( (int)a2 >= 1 )
  {
    if ( a2 >= 0x4000001 )
      goto LABEL_21;
    v9 = sub_556238C(a1, 0LL, 0LL, 16LL * a2, v7);
    v10 = *(int *)(v6 + 8);
    *(_QWORD *)(v6 + 16) = v9;
    if ( (int)v10 < (int)a2 )
    {
      v11 = a2 - v10;
      v12 = v10;
      if ( v11 < 2 )
        goto LABEL_8;
      v12 = (v11 & 0xFFFFFFFFFFFFFFFELL) + v10;
      v13 = (_DWORD *)(v9 + 16 * v10 + 28);
      v14 = v11 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v14 -= 2LL;
        *(v13 - 4) = 0;
        *v13 = 0;
        v13 += 8;
      }
      while ( v14 );
      if ( v11 != (v11 & 0xFFFFFFFFFFFFFFFELL) )
      {
LABEL_8:
        v15 = v9 + 16 * v12;
        v16 = a2 - v12;
        v17 = (_DWORD *)(v15 + 12);
        do
        {
          --v16;
          *v17 = 0;
          v17 += 4;
        }
        while ( v16 );
      }
    }
    *(_DWORD *)(v6 + 8) = a2;
  }
  if ( a3 < 1 )
    return v6;
  v18 = sub_5562DA0((unsigned int)(a3 - 1));
  if ( v18 >= 26 )
LABEL_21:
    sub_555B7B0(a1, "table overflow");
  v19 = v18 + 1;
  v20 = 1 << (v18 + 1);
  v21 = sub_5561E10(a1, 32LL * v20, *(_BYTE *)(v6 + 1));
  *(_QWORD *)(v6 + 32) = v21;
  if ( v20 <= 1 )
    v22 = 1LL;
  else
    v22 = (unsigned int)v20;
  *((_DWORD *)v21 + 7) = 0;
  *((_DWORD *)v21 + 3) = 0;
  if ( v20 >= 2 )
  {
    v23 = 0LL;
    v24 = 32 * v22 - 32;
    do
    {
      v25 = *(_QWORD *)(v6 + 32) + v23;
      v23 += 32LL;
      *(_DWORD *)(v25 + 60) = 0;
      *(_DWORD *)(v25 + 44) = 0;
    }
    while ( v24 != v23 );
  }
  *(_BYTE *)(v6 + 4) = v19;
  *(_DWORD *)(v6 + 12) = v20;
  *(_BYTE *)(v6 + 3) = ~(-1 << v19);
  return v6;
}


================================================================================
Function: sub_5568704 (0x5568704)
================================================================================

char *__fastcall sub_5568704(__int64 a1, __int64 a2)
{
  char v2; // w9
  char *result; // x0
  int v4; // w9
  int v5; // w10

  v2 = *(_BYTE *)(a1 + 4);
  result = *(char **)(a1 + 32);
  v4 = *(_DWORD *)(a2 + 16) & ~(-1 << v2);
  while ( 1 )
  {
    result += 32 * v4;
    v5 = *((_DWORD *)result + 7);
    if ( (v5 & 0xF) == 5 && *((_QWORD *)result + 2) == a2 )
      break;
    v4 = v5 >> 4;
    if ( (unsigned int)v5 <= 0xF )
      return (char *)&unk_10308A8;
  }
  return result;
}


================================================================================
Function: sub_5568764 (0x5568764)
================================================================================

void *__fastcall sub_5568764(__int64 a1, _DWORD *a2)
{
  int v2; // w8
  __int64 v4; // x19
  int v5; // w10
  int v6; // w11
  int v7; // w8
  double v8; // d0
  int v9; // w8
  unsigned int v10; // w8
  signed int v11; // w9
  int v12; // w10

  v2 = a2[3];
  if ( !v2 )
    return &unk_10308A8;
  if ( v2 != 2 )
  {
    if ( v2 == 5 )
    {
      v4 = *(_QWORD *)(a1 + 32);
      v5 = *(_DWORD *)(*(_QWORD *)a2 + 16LL) & ~(-1 << *(_BYTE *)(a1 + 4));
      while ( 1 )
      {
        v4 += 32LL * v5;
        v6 = *(_DWORD *)(v4 + 28);
        if ( (v6 & 0xF) == 5 && *(_QWORD *)(v4 + 16) == *(_QWORD *)a2 )
          break;
        v5 = v6 >> 4;
        if ( (unsigned int)v6 < 0x10 )
          return &unk_10308A8;
      }
      return (void *)v4;
    }
    goto LABEL_12;
  }
  v7 = (int)*(double *)a2;
  v8 = (double)v7;
  if ( *(double *)a2 != (double)v7 )
  {
LABEL_12:
    v4 = sub_5568930(a1, a2);
    if ( !(unsigned int)sub_5562E98(v4 + 16, a2) )
    {
      while ( 1 )
      {
        v10 = *(_DWORD *)(v4 + 28);
        if ( v10 < 0x10 )
          break;
        v4 += 32 * ((__int64)(int)v10 >> 4);
        if ( (unsigned int)sub_5562E98(v4 + 16, a2) )
          return (void *)v4;
      }
      return &unk_10308A8;
    }
    return (void *)v4;
  }
  v9 = v7 - 1;
  if ( (unsigned int)v9 < *(_DWORD *)(a1 + 8) )
    return (void *)(*(_QWORD *)(a1 + 16) + 16LL * v9);
  v4 = *(_QWORD *)(a1 + 32);
  if ( (_UNKNOWN *)v4 == &unk_1030AB8 )
    return &unk_10308A8;
  v11 = (1540483477
       * ((1540483477
         * (HIDWORD(v8) & 0x7FFFFFFF ^ ((1540483477 * (LODWORD(v8) ^ ((HIDWORD(v8) & 0x7FFFFFFFu) >> 18))) >> 22))) ^ ((1540483477 * ((1540483477 * (LODWORD(v8) ^ ((HIDWORD(v8) & 0x7FFFFFFFu) >> 18))) ^ ((1540483477 * (HIDWORD(v8) & 0x7FFFFFFF ^ ((1540483477 * (LODWORD(v8) ^ ((HIDWORD(v8) & 0x7FFFFFFFu) >> 18))) >> 22))) >> 17))) >> 19))) & ~(-1 << *(_BYTE *)(a1 + 4));
  while ( 1 )
  {
    v4 += 32LL * v11;
    v12 = *(_DWORD *)(v4 + 28);
    if ( (v12 & 0xF) == 2 && *(double *)(v4 + 16) == v8 )
      break;
    v11 = v12 >> 4;
    if ( (unsigned int)v12 < 0x10 )
      return &unk_10308A8;
  }
  return (void *)v4;
}


================================================================================
Function: sub_5568930 (0x5568930)
================================================================================

__int64 __fastcall sub_5568930(__int64 a1, __int64 a2)
{
  unsigned int v2; // w8
  unsigned int v3; // w8
  unsigned int v4; // w8
  int8x8_t v5; // d0
  int32x2_t v6; // d0
  unsigned int v7; // w8
  unsigned __int64 v8; // d0

  switch ( *(_DWORD *)(a2 + 12) )
  {
    case 1:
      v2 = *(_DWORD *)a2;
      break;
    case 2:
      v4 = *(_DWORD *)(a2 + 4) & 0x7FFFFFFF;
      v2 = 1540483477
         * ((1540483477 * (v4 ^ ((1540483477 * (*(_DWORD *)a2 ^ (v4 >> 18))) >> 22))) ^ ((1540483477
                                                                                        * ((1540483477
                                                                                          * (*(_DWORD *)a2 ^ (v4 >> 18))) ^ ((1540483477 * (v4 ^ ((1540483477 * (*(_DWORD *)a2 ^ (v4 >> 18))) >> 22))) >> 17))) >> 19));
      break;
    case 3:
      v5.n64_u64[0] = vbic_s8(*(int8x8_t *)(a2 + 4), vceq_s32(*(int32x2_t *)(a2 + 4), (int32x2_t)0x8000000080000000LL)).n64_u64[0];
      v6.n64_u64[0] = veor_s8(vshr_n_u32(v5, 0x11uLL), v5).n64_u64[0];
      if ( *(_DWORD *)a2 == 0x80000000 )
        v7 = 0;
      else
        v7 = *(_DWORD *)a2;
      v8 = vmul_s32(v6, (int32x2_t)0x4F9FFB70127409FLL).n64_u64[0];
      v2 = v8 ^ (73856093 * (v7 ^ (v7 >> 17))) ^ HIDWORD(v8);
      break;
    case 5:
      v2 = *(_DWORD *)(*(_QWORD *)a2 + 16LL);
      break;
    default:
      v3 = -2048144789 * (*(_DWORD *)a2 ^ HIWORD(*(_DWORD *)a2));
      v2 = (-1028477387 * (v3 ^ (v3 >> 13))) ^ ((-1028477387 * (v3 ^ (v3 >> 13))) >> 16);
      break;
  }
  return *(_QWORD *)(a1 + 32) + 32LL * (int)(v2 & ~(-1 << *(_BYTE *)(a1 + 4)));
}


================================================================================
Function: sub_5568A40 (0x5568A40)
================================================================================

void *__fastcall sub_5568A40(__int64 a1, __int64 a2, __int64 a3)
{
  void *result; // x0
  long double v7; // q0
  int v8; // w8

  result = (void *)sub_5568764(a2, a3);
  *(_BYTE *)(a2 + 5) = 0;
  if ( result == &unk_10308A8 )
  {
    v8 = *(_DWORD *)(a3 + 12);
    switch ( v8 )
    {
      case 2:
        *(_QWORD *)&v7 = *(_QWORD *)a3;
        break;
      case 3:
        LODWORD(v7) = *(_DWORD *)(a3 + 8);
        break;
      case 0:
        sub_555B7B0(a1, "table index is nil");
    }
    return (void *)sub_5568B9C(a1, a2, a3, v7);
  }
  return result;
}


================================================================================
Function: sub_5568B9C (0x5568B9C)
================================================================================

__int64 __fastcall sub_5568B9C(__int64 a1, __int64 a2, __int64 a3, long double a4, long double a5)
{
  int v8; // w8
  int v9; // w9
  int v10; // w9
  __int64 v11; // x0
  int v12; // w8
  __int64 v13; // x25
  _DWORD *v14; // x26
  int v15; // w9
  int v16; // w27
  int v17; // w24
  __int64 v18; // x0
  int v19; // w9
  __int64 v20; // x8
  __int128 v21; // q0
  int v22; // w9
  __int64 v24; // x22
  __int64 v25; // [xsp+8h] [xbp-18h] BYREF
  int v26; // [xsp+10h] [xbp-10h]
  int v27; // [xsp+14h] [xbp-Ch]

  v8 = *(_DWORD *)(a3 + 12);
  while ( v8 == 2 )
  {
    *(_QWORD *)&a5 = *(_QWORD *)a3;
    *(double *)&a4 = (double)(*(_DWORD *)(a2 + 8) + 1);
    if ( *(double *)a3 != *(double *)&a4 )
      break;
LABEL_4:
    sub_5569358(a1, a2, a3, a4, a5);
    v8 = *(_DWORD *)(a3 + 12);
    if ( v8 == 2 )
    {
      v9 = (int)*(double *)a3;
      if ( *(double *)a3 == (double)v9 )
      {
        v10 = v9 - 1;
        v8 = 2;
        if ( (unsigned int)v10 < *(_DWORD *)(a2 + 8) )
          return *(_QWORD *)(a2 + 16) + 16LL * v10;
      }
    }
  }
  v11 = sub_5568930(a2, a3);
  v24 = v11;
  if ( (_UNKNOWN *)v11 == &unk_1030AB8 || *(_DWORD *)(v11 + 12) )
  {
    v12 = *(_DWORD *)(a2 + 12);
    while ( v12 >= 1 )
    {
      v13 = *(_QWORD *)(a2 + 32) + 32LL * (unsigned int)--v12;
      *(_DWORD *)(a2 + 12) = v12;
      v14 = (_DWORD *)(v13 + 28);
      if ( (*(_BYTE *)(v13 + 28) & 0xF) == 0 )
      {
        v15 = *(_DWORD *)(v11 + 24);
        v16 = *(_DWORD *)(v11 + 28);
        v17 = v16 & 0xF;
        v25 = *(_QWORD *)(v11 + 16);
        v26 = v15;
        v27 = v17;
        v18 = sub_5568930(a2, &v25);
        if ( v18 == v24 )
        {
          if ( (unsigned int)v16 > 0xF )
          {
            *v14 = ((v24 + 32 * (unsigned __int64)(unsigned int)(v16 >> 4) - v13) >> 1) & 0xFFFFFFF0;
            v17 = *(_DWORD *)(v24 + 28) & 0xF;
          }
          *(_DWORD *)(v24 + 28) = ((unsigned __int64)(v13 - v24) >> 1) & 0xFFFFFFF0 | v17;
          v24 = v13;
        }
        else
        {
          do
          {
            v19 = *(_DWORD *)(v18 + 28);
            v20 = v18;
            v18 += 32 * ((__int64)v19 >> 4);
          }
          while ( v18 != v24 );
          *(_DWORD *)(v20 + 28) = ((unsigned __int64)(v13 - v20) >> 1) & 0xFFFFFFF0 | v19 & 0xF;
          v21 = *(_OWORD *)(v24 + 16);
          *(_OWORD *)v13 = *(_OWORD *)v24;
          *(_OWORD *)(v13 + 16) = v21;
          if ( *(_DWORD *)(v24 + 28) >= 0x10u )
          {
            *v14 += ((unsigned __int64)(v24 - v13) >> 1) & 0xFFFFFFF0;
            *(_DWORD *)(v24 + 28) &= 0xFu;
          }
          *(_DWORD *)(v24 + 12) = 0;
        }
        goto LABEL_21;
      }
    }
    goto LABEL_4;
  }
LABEL_21:
  v22 = *(_DWORD *)(v24 + 28);
  *(_QWORD *)(v24 + 16) = *(_QWORD *)a3;
  *(_DWORD *)(v24 + 24) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(v24 + 28) = v22 & 0xFFFFFFF0 | *(_DWORD *)(a3 + 12) & 0xF;
  if ( *(int *)(a3 + 12) >= 5 && (*(_BYTE *)a2 & 4) != 0 && (**(_BYTE **)a3 & 3) != 0 )
    sub_555E9B4(a1, a2);
  return v24;
}


================================================================================
Function: sub_5569358 (0x5569358)
================================================================================

__int64 __fastcall sub_5569358(int a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x8
  int v7; // w23
  int v8; // w14
  int v9; // w12
  int v10; // w9
  int v11; // w16
  __int64 v12; // x13
  int v13; // w13
  __int64 v14; // x17
  __int64 v15; // x16
  __int64 v16; // x14
  unsigned __int64 v17; // x16
  __int64 v18; // x0
  __int64 v19; // x2
  unsigned __int64 v20; // x16
  __int64 v21; // x0
  int32x4_t v22; // q0
  __int64 v23; // x16
  int32x4_t v24; // q1
  const float *v25; // x0
  const float *v26; // x1
  unsigned __int128 v27; // q16
  unsigned __int128 v28; // q2
  __int64 v29; // x15
  __int64 v30; // x17
  __int64 v31; // x14
  int *v32; // x15
  int v33; // t1
  int v34; // w25
  int v35; // w22
  __int64 v36; // x9
  __int64 v37; // x26
  __int64 v38; // x27
  int v39; // w0
  int v40; // w8
  __int64 v41; // x8
  double v42; // d0
  unsigned int v43; // w0
  int v44; // w26
  int v45; // w8
  double v46; // d1
  unsigned int v47; // w8
  unsigned int v48; // w0
  int v49; // w0
  int v50; // w8
  int v51; // w12
  unsigned int v52; // w22
  int v53; // w9
  int v54; // w11
  int *v55; // x10
  bool v56; // w12
  int v57; // w0
  _OWORD v59[7]; // [xsp+0h] [xbp-80h] BYREF

  v6 = 0LL;
  v7 = 0;
  v8 = 1;
  v9 = 1;
  v10 = *(_DWORD *)(a2 + 8);
  memset(v59, 0, 108);
  do
  {
    v13 = v9;
    if ( v9 > v10 )
    {
      v13 = v10;
      if ( v8 > v10 )
        break;
    }
    if ( v13 < v8 )
    {
      v11 = 0;
    }
    else
    {
      v14 = v8;
      v15 = v13 - (__int64)v8;
      v16 = *(_QWORD *)(a2 + 16);
      v17 = v15 + 1;
      if ( v17 >= 9 )
      {
        v18 = v17 & 7;
        if ( (v17 & 7) == 0 )
          v18 = 8LL;
        v19 = v16 + 16 * v14;
        v20 = v17 - v18;
        v21 = v18 + v14;
        v14 += v20;
        v22 = 0uLL;
        v23 = ~(__int64)v13 + v21;
        v24 = 0uLL;
        v25 = (const float *)(v19 + 60);
        do
        {
          v26 = v25 - 16;
          v27 = (unsigned __int128)vld4q_f32(v25);
          v23 += 8LL;
          v25 += 32;
          v28 = (unsigned __int128)vld4q_f32(v26);
          v22 = vsubq_s32(v22, vtstq_s32((int32x4_t)v28, (int32x4_t)v28));
          v24 = vsubq_s32(v24, vtstq_s32((int32x4_t)v27, (int32x4_t)v27));
        }
        while ( v23 );
        v11 = vaddvq_s32(vaddq_s32(v24, v22));
      }
      else
      {
        v11 = 0;
      }
      v29 = v13 - v14;
      v30 = v16 + 16 * v14;
      v31 = v29 + 1;
      v32 = (int *)(v30 - 4);
      do
      {
        v33 = *v32;
        v32 += 4;
        if ( v33 )
          ++v11;
        --v31;
      }
      while ( v31 );
      v8 = v13 + 1;
    }
    v12 = 4 * v6;
    v7 += v11;
    ++v6;
    v9 *= 2;
    *(_DWORD *)((char *)v59 + v12) += v11;
  }
  while ( v6 != 27 );
  v34 = 0;
  v35 = 0;
  v36 = ~(-1 << *(_BYTE *)(a2 + 4));
  v37 = 32 * v36;
  v38 = v36 + 1;
  do
  {
    v41 = *(_QWORD *)(a2 + 32);
    if ( *(_DWORD *)(v41 + v37 + 12) )
    {
      if ( (*(_DWORD *)(v41 + v37 + 28) & 0xF) == 2 )
      {
        v42 = *(double *)(v41 + v37 + 16);
        if ( v42 == (double)(int)v42 )
          v43 = (int)v42 - 1;
        else
          v43 = -2;
        if ( v43 >> 26 )
        {
          v40 = 0;
        }
        else
        {
          v39 = sub_5562DA0(v43);
          v40 = 1;
          ++*((_DWORD *)v59 + v39 + 1);
        }
        v35 += v40;
      }
      ++v34;
    }
    v37 -= 32LL;
    --v38;
  }
  while ( v38 );
  v44 = v35 + v7;
  if ( *(_DWORD *)(a3 + 12) == 2 )
  {
    v45 = (int)*(double *)a3;
    v46 = (double)v45;
    v47 = v45 - 1;
    if ( *(double *)a3 == v46 )
      v48 = v47;
    else
      v48 = -2;
    if ( v48 >> 26 )
    {
      v50 = 0;
    }
    else
    {
      v49 = sub_5562DA0(v48);
      v50 = 1;
      ++*((_DWORD *)v59 + v49 + 1);
    }
    v44 += v50;
  }
  if ( v44 < 1 )
  {
    v52 = 0;
  }
  else
  {
    v51 = 0;
    v52 = 0;
    v53 = 0;
    v54 = 1;
    v55 = (int *)v59;
    do
    {
      v56 = *v55 + v53 > v51;
      if ( *v55 > 0 )
        v53 += *v55;
      if ( *v55 > 0 && v56 )
        v52 = v54;
      if ( v53 == v44 )
        break;
      v51 = v54 & 0x7FFFFFFF;
      ++v55;
      v54 *= 2;
    }
    while ( v51 < v44 );
  }
  v57 = sub_5567F64(a2, v52, a3);
  if ( v57 != v52 )
    sub_5567F64(a2, v57 - v52 + v57, a3);
  return sub_5568098(a1);
}


================================================================================
Function: sub_556AD84 (0x556AD84)
================================================================================

__int64 __fastcall sub_556AD84(__int64 a1, char a2, __int64 a3)
{
  __int64 result; // x0

  result = sub_5568704(a1, a3);
  if ( !*(_DWORD *)(result + 12) )
  {
    result = 0LL;
    *(_BYTE *)(a1 + 5) |= 1 << a2;
  }
  return result;
}


================================================================================
Function: sub_55758C4 (0x55758C4)
================================================================================

__int64 __fastcall sub_55758C4(__int64 a1, char *a2, const char *a3, __int64 a4, unsigned int a5)
{
  unsigned int v10; // w26
  const char *v11; // x0
  const char *v12; // x0
  __int64 result; // x0
  __int64 v14; // x21
  unsigned __int64 v15; // x23
  __int64 *v16; // x0
  size_t v17; // x0
  const char *v18; // x0
  __int64 v19; // x27
  int v20; // w8
  __int64 v21; // x21
  unsigned __int8 v22; // w9
  int v23; // w10
  __int64 i; // x22
  int v25; // w8
  size_t v26; // x25
  __int64 v27; // x23
  unsigned __int8 v28; // w9
  int v29; // w10
  __int128 v30; // q0
  int v31; // w8
  int v32; // w10
  int v33; // w9
  unsigned __int8 v34; // w11
  int v35; // w12
  __int64 v36; // x9
  unsigned int v37; // w22
  __int64 (__fastcall *v38)(__int64, __int64, _QWORD); // x8
  int v39; // w8
  __int64 v40; // x23
  unsigned __int8 v41; // w9
  int v42; // w10
  __int64 v43; // x23
  __int64 v44; // x24
  __int64 v45; // x0
  __int64 v46; // x26
  __int64 v47; // x25
  unsigned __int8 v48; // w8
  int v49; // w8
  size_t v50; // x27
  unsigned __int8 v51; // w9
  int v52; // w10
  unsigned int v53; // w23
  _BYTE *v54; // x0
  __int64 v55; // x9
  __int64 v56; // x8
  int v57; // w8
  size_t v58; // x27
  unsigned __int8 v59; // w9
  int v60; // w10
  void *v61; // x0
  __int64 v62; // x9
  __int64 v63; // x8
  int v64; // w11
  __int64 v65; // x12
  _BYTE *v66; // x14
  __int64 v67; // x15
  char v68; // w16
  _BYTE *v69; // x10
  __int64 v70; // x13
  int v71; // w14
  int v72; // w14
  __int64 v73; // x11
  char v74; // w17
  _BYTE *v75; // x15
  __int64 v76; // x16
  int v77; // w10
  int v78; // w17
  int v79; // w10
  char v80; // w0
  _BYTE *v81; // x14
  __int64 v82; // x13
  int v83; // w15
  __int64 v84; // x16
  unsigned __int64 v85; // x15
  int v86; // w8
  __int64 v87; // x23
  unsigned __int8 v88; // w9
  int v89; // w10
  __int64 v90; // x0
  _BYTE *v91; // x27
  __int64 v92; // x8
  __int64 v93; // x9
  __int64 v94; // x11
  __int64 v95; // x11
  __int64 v96; // x8
  __int64 v97; // x0
  int v98; // w8
  __int64 v99; // x23
  unsigned __int8 v100; // w9
  int v101; // w10
  __int64 v102; // x0
  __int64 v103; // x8
  _DWORD *v104; // x9
  __int64 v105; // x10
  __int64 v106; // x9
  __int64 v107; // x8
  _DWORD *v108; // x9
  __int64 v109; // x24
  __int64 v110; // d0
  __int64 v111; // x23
  __int64 v112; // x8
  int v113; // w9
  _DWORD *v114; // x8
  int v115; // w9
  int v116; // w8
  int v117; // w27
  unsigned __int8 v118; // w9
  int v119; // w10
  __int64 v120; // x28
  int k; // w25
  int v122; // w9
  int v123; // w8
  unsigned __int8 v124; // w10
  int v125; // w11
  __int64 v126; // x0
  __int64 v127; // x8
  int v128; // w9
  int v129; // w8
  unsigned __int8 v130; // w10
  int v131; // w11
  __int64 v132; // x8
  int v133; // w8
  __int64 v134; // x10
  int v135; // w0
  __int64 v136; // x8
  int v137; // w9
  unsigned int v138; // w8
  unsigned __int8 v139; // w10
  int v140; // w11
  __int64 v141; // x0
  __int64 v142; // x8
  __int64 v143; // d0
  int v144; // s1
  __int64 v145; // x9
  __int64 v146; // x9
  int v147; // w8
  __int64 v148; // x24
  unsigned __int8 v149; // w9
  int v150; // w10
  unsigned __int8 *v151; // x25
  __int64 m; // x8
  int v153; // w10
  unsigned int v154; // w9
  unsigned __int8 v155; // w11
  int v156; // w12
  int v157; // w10
  int v158; // w8
  __int64 v159; // x11
  unsigned __int8 *v160; // x12
  unsigned __int8 v161; // w13
  __int64 v162; // x24
  unsigned __int8 *v163; // x9
  int v164; // w11
  int v165; // w11
  int v166; // w10
  const char *v167; // x8
  unsigned __int8 *v168; // x23
  int v169; // w9
  __int64 v170; // x8
  int v171; // w8
  __int64 v172; // x9
  __int64 v173; // x2
  int v174; // w25
  unsigned __int64 v175; // x27
  int v176; // w28
  unsigned __int8 *v177; // x0
  int v178; // w8
  unsigned __int8 *v179; // x8
  unsigned __int8 v180; // w8
  __int64 v181; // x9
  char v182; // t1
  int v183; // w8
  _DWORD *v184; // x9
  __int64 v185; // x10
  int v186; // w11
  int v187; // w8
  __int64 v188; // x23
  unsigned __int8 v189; // w9
  int v190; // w10
  __int64 v191; // x0
  __int64 n; // x8
  int v193; // w14
  int v194; // w13
  __int64 v195; // x15
  unsigned __int8 *v196; // x16
  __int64 v197; // x10
  unsigned __int8 v198; // w17
  __int64 v199; // x11
  unsigned __int8 *v200; // x12
  int v201; // w15
  __int64 v202; // x13
  int v203; // w15
  int v204; // w14
  unsigned __int8 v205; // w16
  char *v206; // x13
  int v207; // w11
  int v208; // w10
  int v209; // w11
  char v210; // t1
  int v211; // w14
  __int64 v212; // x10
  int v213; // w8
  __int64 v214; // x23
  unsigned __int8 v215; // w9
  int v216; // w10
  __int64 ii; // x8
  __int64 v218; // x9
  int v219; // w10
  int v220; // w9
  unsigned __int8 v221; // w11
  int v222; // w12
  unsigned __int64 v223; // x0
  unsigned int v224; // w2
  unsigned int v225; // w1
  __int64 v226; // x12
  _BYTE *v227; // x13
  __int64 v228; // x14
  unsigned int v229; // w16
  unsigned int v230; // w15
  int j; // w11
  unsigned int v232; // w12
  int v233; // w12
  int v234; // w12
  __int64 v235; // x13
  __int64 v236; // x12
  _BYTE *v237; // x13
  unsigned int v238; // w14
  _BYTE *v239; // x13
  __int64 v240; // x14
  unsigned int v241; // w15
  int v242; // w9
  int v243; // w8
  unsigned __int8 *v244; // x10
  char v245; // t1
  int v246; // w12
  __int64 v247; // x0
  __int64 v248; // x8
  __int64 v249; // x8
  unsigned __int64 v250; // [xsp+0h] [xbp-1A0h]
  __int64 v251; // [xsp+8h] [xbp-198h]
  int v252; // [xsp+14h] [xbp-18Ch]
  __int64 v253; // [xsp+18h] [xbp-188h]
  unsigned int v254; // [xsp+2Ch] [xbp-174h]
  __int64 v255; // [xsp+30h] [xbp-170h]
  __int64 v256; // [xsp+40h] [xbp-160h]
  __int64 v257; // [xsp+48h] [xbp-158h]
  __int64 v258; // [xsp+58h] [xbp-148h]
  __int64 v259; // [xsp+60h] [xbp-140h]
  __int64 v260; // [xsp+70h] [xbp-130h]
  __int64 v261; // [xsp+80h] [xbp-120h] BYREF
  int v262; // [xsp+88h] [xbp-118h]
  _OWORD dest[16]; // [xsp+90h] [xbp-110h] BYREF

  v10 = *(unsigned __int8 *)a3;
  sub_2AFF1BC();
  if ( !v10 )
  {
    strlen(a2);
    v12 = (const char *)sub_556321C(dest, 256, a2);
    sub_5551BC8(a1, "%s%.*s", v12, a4 - 1, a3 + 1);
    return 1LL;
  }
  if ( v10 - 7 <= 0xFFFFFFFB )
  {
    strlen(a2);
    v11 = (const char *)sub_556321C(dest, 256, a2);
    sub_5551BC8(a1, "%s: bytecode version mismatch (expected [%d..%d], got %d)", v11, 3, 6, v10);
    return 1LL;
  }
  if ( (_BYTE)word_6F8D020 )
    sub_5576BE8(a1, a2, a3, a4, a5);
  v14 = *(_QWORD *)(a1 + 24);
  v15 = *(_QWORD *)(v14 + 72);
  if ( *(_QWORD *)(v14 + 88) >= v15 )
  {
    sub_555D9A0(a1, 1LL);
    v14 = *(_QWORD *)(a1 + 24);
    v15 = *(_QWORD *)(v14 + 72);
  }
  *(_QWORD *)(v14 + 72) = -1LL;
  if ( a5 )
    v16 = (__int64 *)sub_5550364(a1, a5);
  else
    v16 = (__int64 *)(a1 + 104);
  v256 = *v16;
  v17 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
  v255 = sub_55645D8(a1, a2, v17);
  if ( v10 < 4 )
  {
    v19 = 1LL;
    v254 = v10;
    v250 = v15;
    v251 = v14;
    v252 = 0;
  }
  else
  {
    v252 = *((unsigned __int8 *)a3 + 1);
    if ( (unsigned int)(v252 - 4) <= 0xFFFFFFFC )
    {
      __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
      v18 = (const char *)sub_556321C(dest, 256, a2);
      sub_5551BC8(a1, "%s: bytecode type version mismatch (expected [%d..%d], got %d)", v18, 1, 3, v252);
      result = 1LL;
      *(_QWORD *)(v14 + 72) = v15;
      return result;
    }
    v254 = v10;
    v19 = 2LL;
    v250 = v15;
    v251 = v14;
  }
  v20 = 0;
  LODWORD(v21) = 0;
  do
  {
    v22 = a3[v19++];
    v23 = (v22 & 0x7F) << v20;
    v20 += 7;
    v21 = v23 | (unsigned int)v21;
  }
  while ( (v22 & 0x80) != 0 );
  v260 = sub_5561E10(a1, 8 * v21, 0LL);
  if ( (_DWORD)v21 )
  {
    for ( i = 0LL; i != v21; ++i )
    {
      v25 = 0;
      LODWORD(v26) = 0;
      v27 = v19;
      do
      {
        v28 = a3[v27++];
        v29 = (v28 & 0x7F) << v25;
        v25 += 7;
        v26 = v29 | (unsigned int)v26;
      }
      while ( (v28 & 0x80) != 0 );
      v19 = v26 + v27;
      *(_QWORD *)(v260 + 8 * i) = sub_55645D8(a1, (void *)&a3[v27], v26);
    }
    v19 = v27 + (unsigned int)v26;
  }
  if ( v252 == 3 )
  {
    *(_QWORD *)&v30 = 0x707070707070707LL;
    *((_QWORD *)&v30 + 1) = 0x707070707070707LL;
    v31 = (unsigned __int8)a3[v19++];
    dest[0] = v30;
    for ( dest[1] = v30; v31; ++v19 )
    {
      v32 = 0;
      v33 = 0;
      do
      {
        v34 = a3[v19++];
        v35 = (v34 & 0x7F) << v32;
        v32 += 7;
        v33 |= v35;
      }
      while ( (v34 & 0x80) != 0 );
      if ( v33 )
        v36 = *(_QWORD *)(v260 + 8LL * (unsigned int)(v33 - 1));
      else
        v36 = 0LL;
      v37 = v31 - 1;
      if ( (unsigned int)(v31 - 1) <= 0x1F )
      {
        v38 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)(a1 + 24) + 3416LL);
        if ( v38 )
          *((_BYTE *)dest + v37) = v38(a1, v36 + 24, *(unsigned int *)(v36 + 20));
      }
      v31 = (unsigned __int8)a3[v19];
    }
  }
  v39 = 0;
  LODWORD(v40) = 0;
  do
  {
    v41 = a3[v19++];
    v42 = (v41 & 0x7F) << v39;
    v39 += 7;
    v40 = v42 | (unsigned int)v40;
  }
  while ( (v41 & 0x80) != 0 );
  v258 = sub_5561E10(a1, 8 * v40, 0LL);
  v259 = v40;
  if ( (_DWORD)v40 )
  {
    v253 = v40;
    v43 = 0LL;
    while ( 1 )
    {
      v45 = sub_555D45C(a1);
      *(_DWORD *)(v45 + 136) = v43;
      v46 = v45;
      v47 = v19 + 4;
      v257 = v43;
      *(_QWORD *)(v45 + 56) = v255;
      *(_BYTE *)(v45 + 4) = a3[v19];
      *(_BYTE *)(v45 + 7) = a3[v19 + 1];
      *(_BYTE *)(v45 + 5) = a3[v19 + 2];
      *(_BYTE *)(v45 + 6) = a3[v19 + 3];
      if ( v254 < 4 )
        goto LABEL_72;
      v48 = a3[v47];
      v47 = v19 + 5;
      *(_BYTE *)(v45 + 3) = v48;
      if ( v252 == 1 )
      {
        v49 = 0;
        LODWORD(v50) = 0;
        do
        {
          v51 = a3[v47++];
          v52 = (v51 & 0x7F) << v49;
          v49 += 7;
          v50 = v52 | (unsigned int)v50;
        }
        while ( (v51 & 0x80) != 0 );
        if ( (_DWORD)v50 )
        {
          if ( (unsigned int)v50 <= 0x7F )
            v53 = 3;
          else
            v53 = 4;
          v54 = (_BYTE *)sub_5561E10(a1, v53 + (unsigned int)v50, *(unsigned __int8 *)(v45 + 1));
          *(_QWORD *)(v46 + 112) = v54;
          *(_DWORD *)(v46 + 172) = v53 + v50;
          if ( (unsigned int)v50 < 0x80 )
          {
            v56 = 1LL;
            v55 = 2LL;
            *v54 = v50;
          }
          else
          {
            v55 = 3LL;
            *v54 = v50 | 0x80;
            v56 = 2LL;
            *(_BYTE *)(*(_QWORD *)(v46 + 112) + 1LL) = (unsigned int)v50 >> 7;
          }
          *(_BYTE *)(*(_QWORD *)(v46 + 112) + v56) = 0;
          *(_BYTE *)(*(_QWORD *)(v46 + 112) + v55) = 0;
          memcpy((void *)(*(_QWORD *)(v46 + 112) + v53), &a3[v47], v50);
          v47 += v50;
        }
        goto LABEL_72;
      }
      if ( (v252 & 0xFE) != 2 )
        goto LABEL_72;
      v57 = 0;
      LODWORD(v58) = 0;
      do
      {
        v59 = a3[v47++];
        v60 = (v59 & 0x7F) << v57;
        v57 += 7;
        v58 = v60 | (unsigned int)v58;
      }
      while ( (v59 & 0x80) != 0 );
      if ( !(_DWORD)v58 )
        goto LABEL_72;
      v61 = (void *)sub_5561E10(a1, v58, *(unsigned __int8 *)(v45 + 1));
      *(_QWORD *)(v46 + 112) = v61;
      *(_DWORD *)(v46 + 172) = v58;
      memcpy(v61, &a3[v47], v58);
      v47 += v58;
      if ( v252 != 3 )
        goto LABEL_72;
      v62 = *(_QWORD *)(v46 + 112);
      v63 = 0LL;
      v64 = 0;
      LODWORD(v65) = 0;
      v66 = (_BYTE *)(v62 + 6);
      v67 = v62 + 3;
      do
      {
        v68 = *(_BYTE *)(v62 + v63);
        v69 = v66;
        v70 = v67;
        ++v63;
        ++v67;
        v71 = (v68 & 0x7F) << v64;
        v64 += 7;
        v65 = v71 | (unsigned int)v65;
        v66 = v69 + 1;
      }
      while ( v68 < 0 );
      v72 = 0;
      LODWORD(v73) = 0;
      do
      {
        v74 = *(_BYTE *)(v62 + v63);
        v75 = v69;
        v76 = v70;
        ++v63;
        ++v70;
        v77 = (v74 & 0x7F) << v72;
        v72 += 7;
        v73 = v77 | (unsigned int)v73;
        v69 = v75 + 1;
      }
      while ( v74 < 0 );
      v78 = 0;
      v79 = 0;
      do
      {
        v80 = *(_BYTE *)(v62 + v63);
        v81 = v75;
        v82 = v76;
        ++v63;
        ++v76;
        v83 = (v80 & 0x7F) << v78;
        v78 += 7;
        v79 |= v83;
        v75 = v81 + 1;
      }
      while ( v80 < 0 );
      if ( (_DWORD)v65 )
        break;
LABEL_183:
      if ( !(_DWORD)v73 )
        goto LABEL_194;
      if ( (_DWORD)v73 == 1 )
      {
        v226 = 0LL;
      }
      else
      {
        v226 = (unsigned int)v73 & 0xFFFFFFFE;
        v227 = (_BYTE *)(v62 + v63 + 1);
        v228 = v226;
        do
        {
          v229 = (unsigned __int8)*(v227 - 1) - 64;
          v230 = (unsigned __int8)*v227 - 64;
          if ( v229 <= 0x1F )
            *(v227 - 1) = *((_BYTE *)dest + v229);
          if ( v230 <= 0x1F )
            *v227 = *((_BYTE *)dest + v230);
          v227 += 2;
          v228 -= 2LL;
        }
        while ( v228 );
        if ( v226 == v73 )
          goto LABEL_193;
      }
      v235 = v226 + v63;
      v236 = v73 - v226;
      v237 = (_BYTE *)(v62 + v235);
      do
      {
        v238 = (unsigned __int8)*v237 - 64;
        if ( v238 <= 0x1F )
          *v237 = *((_BYTE *)dest + v238);
        --v236;
        ++v237;
      }
      while ( v236 );
LABEL_193:
      v63 += v73;
LABEL_194:
      if ( v79 )
      {
        for ( j = 0; j != v79; ++j )
        {
          v232 = *(char *)(v62 + v63) - 64;
          if ( v232 <= 0x1F )
            *(_BYTE *)(v62 + v63) = *((_BYTE *)dest + v232);
          v63 += 2LL;
          do
            v233 = *(char *)(v62 + v63++);
          while ( v233 < 0 );
          do
            v234 = *(char *)(v62 + v63++);
          while ( v234 < 0 );
        }
      }
LABEL_72:
      v86 = 0;
      LODWORD(v87) = 0;
      do
      {
        v88 = a3[v47++];
        v89 = (v88 & 0x7F) << v86;
        v86 += 7;
        v87 = v89 | (unsigned int)v87;
      }
      while ( (v88 & 0x80) != 0 );
      if ( (v87 & 0x80000000) != 0 )
        sub_5561DFC(a1);
      v90 = sub_5561E10(a1, 4 * v87, *(unsigned __int8 *)(v46 + 1));
      v91 = (_BYTE *)v90;
      *(_QWORD *)(v46 + 8) = v90;
      *(_DWORD *)(v46 + 168) = v87;
      if ( (_DWORD)v87 )
      {
        v92 = 0LL;
        v93 = 0LL;
        do
        {
          v94 = 4 * v93++;
          v92 += 4LL;
          *(_DWORD *)(v90 + v94) = *(_DWORD *)&a3[v47 + v94];
          v95 = *(int *)(v46 + 168);
        }
        while ( v93 < v95 );
        v47 += v92;
        if ( (int)v95 >= 1 )
        {
          do
          {
            v96 = byte_1030B1A[(unsigned __int8)*v91];
            v97 = byte_1030C1A[v96];
            *v91 = v96;
            v91 += 4 * (int)sub_5508348(v97);
          }
          while ( (unsigned __int64)v91 < *(_QWORD *)(v46 + 8) + 4LL * *(int *)(v46 + 168) );
          v91 = *(_BYTE **)(v46 + 8);
        }
      }
      v98 = 0;
      LODWORD(v99) = 0;
      *(_QWORD *)(v46 + 16) = v91;
      do
      {
        v100 = a3[v47++];
        v101 = (v100 & 0x7F) << v98;
        v98 += 7;
        v99 = v101 | (unsigned int)v99;
      }
      while ( (v100 & 0x80) != 0 );
      if ( (v99 & 0x80000000) != 0 )
        sub_5561DFC(a1);
      v102 = sub_5561E10(a1, 16 * v99, *(unsigned __int8 *)(v46 + 1));
      *(_QWORD *)(v46 + 32) = v102;
      *(_DWORD *)(v46 + 144) = v99;
      if ( !(_DWORD)v99 )
      {
        v111 = v47;
        goto LABEL_122;
      }
      if ( (_DWORD)v99 == 1 )
      {
        v103 = 0LL;
LABEL_90:
        v106 = v102 + 16 * v103;
        v107 = v99 - v103;
        v108 = (_DWORD *)(v106 + 12);
        do
        {
          --v107;
          *v108 = 0;
          v108 += 4;
        }
        while ( v107 );
        goto LABEL_92;
      }
      v103 = (unsigned int)v99 & 0xFFFFFFFE;
      v104 = (_DWORD *)(v102 + 28);
      v105 = v103;
      do
      {
        v105 -= 2LL;
        *(v104 - 4) = 0;
        *v104 = 0;
        v104 += 8;
      }
      while ( v105 );
      if ( v103 != v99 )
        goto LABEL_90;
LABEL_92:
      v109 = 0LL;
      do
      {
        v111 = v47 + 1;
        switch ( a3[v47] )
        {
          case 1:
            v113 = (unsigned __int8)a3[v111];
            v111 = v47 + 2;
            v114 = (_DWORD *)(*(_QWORD *)(v46 + 32) + 16 * v109);
            *v114 = v113;
            v115 = 1;
            goto LABEL_116;
          case 2:
            v110 = *(_QWORD *)&a3[v111];
            v111 = v47 + 9;
            v112 = *(_QWORD *)(v46 + 32) + 16 * v109;
            *(_QWORD *)v112 = v110;
            *(_DWORD *)(v112 + 12) = 2;
            break;
          case 3:
            v128 = 0;
            v129 = 0;
            do
            {
              v130 = a3[v111++];
              v131 = (v130 & 0x7F) << v128;
              v128 += 7;
              v129 |= v131;
            }
            while ( (v130 & 0x80) != 0 );
            if ( v129 )
              v132 = *(_QWORD *)(v260 + 8LL * (unsigned int)(v129 - 1));
            else
              v132 = 0LL;
            v145 = *(_QWORD *)(v46 + 32) + 16 * v109;
            *(_QWORD *)v145 = v132;
            *(_DWORD *)(v145 + 12) = 5;
            break;
          case 4:
            v133 = *(_DWORD *)&a3[v111];
            v134 = *(_QWORD *)(a1 + 104);
            v261 = *(_QWORD *)(v46 + 32);
            v262 = v133;
            if ( *(_BYTE *)(v134 + 6) )
            {
              sub_55506E0(a1);
              v135 = sub_555D090(a1, sub_5576A5C, &v261, *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 48), 0LL);
              v136 = *(_QWORD *)(a1 + 32);
              if ( v135 )
                *(_DWORD *)(v136 - 4) = 0;
            }
            else
            {
              v146 = *(_QWORD *)(a1 + 32);
              v136 = v146 + 16;
              *(_DWORD *)(v146 + 12) = 0;
              *(_QWORD *)(a1 + 32) = v146 + 16;
            }
            v111 = v47 + 5;
            *(_OWORD *)(*(_QWORD *)(v46 + 32) + 16 * v109) = *(_OWORD *)(v136 - 16);
            *(_QWORD *)(a1 + 32) -= 16LL;
            break;
          case 5:
            v116 = 0;
            v117 = 0;
            do
            {
              v118 = a3[v111++];
              v119 = (v118 & 0x7F) << v116;
              v116 += 7;
              v117 |= v119;
            }
            while ( (v118 & 0x80) != 0 );
            v120 = sub_55683F0(a1, 0LL, (unsigned int)v117);
            if ( v117 >= 1 )
            {
              for ( k = 0; k != v117; ++k )
              {
                v122 = 0;
                v123 = 0;
                do
                {
                  v124 = a3[v111++];
                  v125 = (v124 & 0x7F) << v122;
                  v122 += 7;
                  v123 |= v125;
                }
                while ( (v124 & 0x80) != 0 );
                v126 = sub_5568A40(a1, v120, *(_QWORD *)(v46 + 32) + 16LL * v123);
                *(_QWORD *)v126 = 0LL;
                *(_DWORD *)(v126 + 12) = 2;
              }
            }
            v127 = *(_QWORD *)(v46 + 32) + 16 * v109;
            *(_QWORD *)v127 = v120;
            *(_DWORD *)(v127 + 12) = 8;
            break;
          case 6:
            v137 = 0;
            v138 = 0;
            do
            {
              v139 = a3[v111++];
              v140 = (v139 & 0x7F) << v137;
              v137 += 7;
              v138 |= v140;
            }
            while ( (v139 & 0x80) != 0 );
            v141 = sub_555D4D4(a1, *(unsigned __int8 *)(*(_QWORD *)(v258 + 8LL * v138) + 5LL), v256);
            *(_BYTE *)(v141 + 6) = *(_BYTE *)(v141 + 4) != 0;
            v142 = *(_QWORD *)(v46 + 32) + 16 * v109;
            *(_QWORD *)v142 = v141;
            *(_DWORD *)(v142 + 12) = 10;
            break;
          case 7:
            v143 = *(_QWORD *)&a3[v111];
            v111 = v47 + 17;
            v114 = (_DWORD *)(*(_QWORD *)(v46 + 32) + 16 * v109);
            v144 = *(_DWORD *)&a3[v47 + 9];
            v115 = 3;
            *(_QWORD *)v114 = v143;
            v114[2] = v144;
LABEL_116:
            v114[3] = v115;
            break;
          default:
            break;
        }
        ++v109;
        v47 = v111;
      }
      while ( v109 < *(int *)(v46 + 144) );
LABEL_122:
      v147 = 0;
      LODWORD(v148) = 0;
      do
      {
        v149 = a3[v111++];
        v150 = (v149 & 0x7F) << v147;
        v147 += 7;
        v148 = v150 | (unsigned int)v148;
      }
      while ( (v149 & 0x80) != 0 );
      v151 = (unsigned __int8 *)(a3 + 2);
      if ( (v148 & 0x80000000) != 0 )
        sub_5561DFC(a1);
      *(_QWORD *)(v46 + 24) = sub_5561E10(a1, 8 * v148, *(unsigned __int8 *)(v46 + 1));
      *(_DWORD *)(v46 + 160) = v148;
      if ( (_DWORD)v148 )
      {
        for ( m = 0LL; m != v148; ++m )
        {
          v153 = 0;
          v154 = 0;
          do
          {
            v155 = a3[v111++];
            v156 = (v155 & 0x7F) << v153;
            v153 += 7;
            v154 |= v156;
          }
          while ( (v155 & 0x80) != 0 );
          *(_QWORD *)(*(_QWORD *)(v46 + 24) + 8 * m) = *(_QWORD *)(v258 + 8LL * v154);
        }
      }
      v157 = 0;
      v158 = 0;
      v159 = v111 + 2;
      v160 = (unsigned __int8 *)&a3[v111 + 5];
      do
      {
        v161 = a3[v111];
        v162 = v159;
        v163 = v160;
        ++v111;
        ++v160;
        v164 = (v161 & 0x7F) << v157;
        v157 += 7;
        v158 |= v164;
        v159 = v162 + 1;
      }
      while ( (v161 & 0x80) != 0 );
      v165 = 0;
      v166 = 0;
      *(_DWORD *)(v46 + 152) = v158;
      do
      {
        v167 = &a3[v162];
        v168 = v163;
        ++v162;
        LOBYTE(v167) = *(v167 - 1);
        v169 = ((unsigned __int8)v167 & 0x7F) << v165;
        v165 += 7;
        v166 |= v169;
        v163 = v168 + 1;
      }
      while ( ((unsigned __int8)v167 & 0x80) != 0 );
      if ( v166 )
        v170 = *(_QWORD *)(v260 + 8LL * (unsigned int)(v166 - 1));
      else
        v170 = 0LL;
      *(_QWORD *)(v46 + 96) = v170;
      if ( !a3[v162 - 1] )
        goto LABEL_148;
      v171 = (unsigned __int8)a3[v162];
      v172 = *(int *)(v46 + 168);
      v173 = *(unsigned __int8 *)(v46 + 1);
      v174 = ((int)v172 - 1) >> v171;
      v175 = (v172 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      *(_DWORD *)(v46 + 140) = v171;
      v176 = v175 + 4 * v174 + 4;
      v177 = (unsigned __int8 *)sub_5561E10(a1, v176, v173);
      v178 = *(_DWORD *)(v46 + 168);
      *(_QWORD *)(v46 + 72) = v177;
      *(_DWORD *)(v46 + 156) = v176;
      *(_QWORD *)(v46 + 88) = &v177[v175];
      if ( v178 < 1 )
      {
        ++v162;
        if ( (v174 & 0x80000000) == 0 )
          goto LABEL_143;
      }
      else
      {
        v179 = (unsigned __int8 *)&a3[v162];
        v162 += 2LL;
        v180 = v179[1];
        *v177 = v180;
        if ( *(int *)(v46 + 168) >= 2 )
        {
          v181 = 1LL;
          do
          {
            v182 = *v168++;
            ++v162;
            v180 += v182;
            *(_BYTE *)(*(_QWORD *)(v46 + 72) + v181++) = v180;
          }
          while ( v181 < *(int *)(v46 + 168) );
        }
        if ( (v174 & 0x80000000) == 0 )
        {
LABEL_143:
          v183 = 0;
          v184 = *(_DWORD **)(v46 + 88);
          v185 = (unsigned int)(v174 + 1);
          v151 = (unsigned __int8 *)(a3 + 2);
          do
          {
            v186 = *(_DWORD *)&a3[v162];
            v162 += 4LL;
            --v185;
            v183 += v186;
            *v184++ = v183;
          }
          while ( v185 );
          goto LABEL_148;
        }
      }
      v151 = (unsigned __int8 *)(a3 + 2);
LABEL_148:
      v19 = v162 + 1;
      if ( a3[v162] )
      {
        v187 = 0;
        LODWORD(v188) = 0;
        v44 = v253;
        do
        {
          v189 = a3[v19++];
          v190 = (v189 & 0x7F) << v187;
          v187 += 7;
          v188 = v190 | (unsigned int)v188;
        }
        while ( (v189 & 0x80) != 0 );
        if ( (v188 & 0x80000000) != 0 )
          sub_5561DFC(a1);
        v191 = sub_5561E10(a1, 8 * (v188 + 2LL * (unsigned int)v188), *(unsigned __int8 *)(v46 + 1));
        *(_QWORD *)(v46 + 80) = v191;
        *(_DWORD *)(v46 + 148) = v188;
        if ( (_DWORD)v188 )
        {
          for ( n = 0LL; n != v188; ++n )
          {
            v193 = 0;
            v194 = 0;
            v195 = v19 + 3;
            v196 = &v151[v19];
            v197 = v19;
            do
            {
              v198 = a3[v197];
              v199 = v195;
              v200 = v196;
              ++v197;
              ++v196;
              v201 = (v198 & 0x7F) << v193;
              v193 += 7;
              v194 |= v201;
              v195 = v199 + 1;
            }
            while ( (v198 & 0x80) != 0 );
            if ( v194 )
              v202 = *(_QWORD *)(v260 + 8LL * (unsigned int)(v194 - 1));
            else
              v202 = 0LL;
            v203 = 0;
            v204 = 0;
            *(_QWORD *)(v191 + 24 * n) = v202;
            do
            {
              v205 = a3[v197];
              v19 = v199;
              v206 = (char *)v200;
              ++v197;
              ++v200;
              v207 = (v205 & 0x7F) << v203;
              v203 += 7;
              v204 |= v207;
              v199 = v19 + 1;
            }
            while ( (v205 & 0x80) != 0 );
            v208 = 0;
            v209 = 0;
            *(_DWORD *)(v191 + 24 * n + 8) = v204;
            do
            {
              v210 = *v206++;
              ++v19;
              v211 = (v210 & 0x7F) << v208;
              v208 += 7;
              v209 |= v211;
            }
            while ( v210 < 0 );
            v212 = v191 + 24 * n;
            *(_DWORD *)(v212 + 12) = v209;
            *(_BYTE *)(v212 + 16) = *v206;
          }
        }
        v213 = 0;
        LODWORD(v214) = 0;
        do
        {
          v215 = a3[v19++];
          v216 = (v215 & 0x7F) << v213;
          v213 += 7;
          v214 = v216 | (unsigned int)v214;
        }
        while ( (v215 & 0x80) != 0 );
        if ( (v214 & 0x80000000) != 0 )
          sub_5561DFC(a1);
        *(_QWORD *)(v46 + 64) = sub_5561E10(a1, 8 * v214, *(unsigned __int8 *)(v46 + 1));
        *(_DWORD *)(v46 + 164) = v214;
        if ( (_DWORD)v214 )
        {
          for ( ii = 0LL; ii != v214; ++ii )
          {
            v219 = 0;
            v220 = 0;
            do
            {
              v221 = a3[v19++];
              v222 = (v221 & 0x7F) << v219;
              v219 += 7;
              v220 |= v222;
            }
            while ( (v221 & 0x80) != 0 );
            if ( v220 )
              v218 = *(_QWORD *)(v260 + 8LL * (unsigned int)(v220 - 1));
            else
              v218 = 0LL;
            *(_QWORD *)(*(_QWORD *)(v46 + 64) + 8 * ii) = v218;
          }
        }
      }
      else
      {
        v44 = v253;
      }
      *(_QWORD *)(v258 + 8 * v257) = v46;
      v43 = v257 + 1;
      if ( v257 + 1 == v44 )
        goto LABEL_211;
    }
    if ( (unsigned int)v65 >= 3 )
    {
      v84 = v65 - 2;
      if ( (unsigned __int64)(v65 - 2) >= 2 )
      {
        v85 = (v84 & 0xFFFFFFFFFFFFFFFELL) + 2;
        v223 = v84 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          v224 = (unsigned __int8)*(v81 - 1) - 64;
          v225 = (unsigned __int8)*v81 - 64;
          if ( v224 <= 0x1F )
            *(v81 - 1) = *((_BYTE *)dest + v224);
          if ( v225 <= 0x1F )
            *v81 = *((_BYTE *)dest + v225);
          v81 += 2;
          v223 -= 2LL;
        }
        while ( v223 );
        if ( v84 == (v84 & 0xFFFFFFFFFFFFFFFELL) )
          goto LABEL_182;
      }
      else
      {
        v85 = 2LL;
      }
      v239 = (_BYTE *)(v82 + v85);
      v240 = v65 - v85;
      do
      {
        v241 = (unsigned __int8)*v239 - 64;
        if ( v241 <= 0x1F )
          *v239 = *((_BYTE *)dest + v241);
        ++v239;
        --v240;
      }
      while ( v240 );
    }
LABEL_182:
    v63 += v65;
    goto LABEL_183;
  }
LABEL_211:
  v242 = 0;
  v243 = 0;
  v244 = (unsigned __int8 *)&a3[v19];
  do
  {
    v245 = *v244++;
    v246 = (v245 & 0x7F) << v242;
    v242 += 7;
    v243 |= v246;
  }
  while ( v245 < 0 );
  if ( (*(_BYTE *)a1 & 4) != 0 )
    sub_555E9E8(a1, a1, a1 + 96);
  v247 = sub_555D4D4(a1, 0LL, v256);
  v248 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)v248 = v247;
  *(_DWORD *)(v248 + 12) = 10;
  v249 = *(_QWORD *)(a1 + 32);
  if ( *(_QWORD *)(a1 + 40) - v249 <= 16 )
  {
    sub_555C64C(a1, 1LL);
    v249 = *(_QWORD *)(a1 + 32);
  }
  *(_QWORD *)(a1 + 32) = v249 + 16;
  sub_55620F0(a1, v258, 8 * v259, 0LL);
  sub_55620F0(a1, v260, 8 * v21, 0LL);
  result = 0LL;
  *(_QWORD *)(v251 + 72) = v250;
  return result;
}


================================================================================
Function: sub_5576BE8 (0x5576BE8)
================================================================================

__int64 __fastcall sub_5576BE8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // x0
  int v6; // w20
  __int64 result; // x0

  v5 = sub_5576C6C(a3, a4);
  v6 = v5;
  result = sub_557704C(v5, 1LL);
  if ( v6 && (v6 == 2 && byte_6F8D0A8 || v6 == 3 && byte_6F8D0C8 || v6 == 6 && byte_6F8D0E8) )
    *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3232LL) &= ~0x40000000u;
  return result;
}


================================================================================
Function: sub_5576C6C (0x5576C6C)
================================================================================

__int64 __fastcall sub_5576C6C(_BYTE *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x1
  unsigned __int8 *v3; // x8
  int v4; // w10
  unsigned __int8 *v5; // x19
  __int64 v6; // x8
  unsigned int v7; // w19
  int v9; // w15
  char v10; // w14
  unsigned int v11; // w13
  int v12; // w13
  int v13; // w14
  char v14; // w14
  char v15; // w14
  int v16; // w8
  unsigned __int64 v17; // x9
  __int64 v18; // x9
  unsigned __int8 v19; // w10
  char v20; // w13
  _BYTE *v21; // x10
  int v22; // w13
  char *v23; // x1
  _QWORD v24[3]; // [xsp+8h] [xbp-48h] BYREF
  _BYTE v25[32]; // [xsp+20h] [xbp-30h] BYREF

  if ( !a2 || !*a1 )
    return 0;
  if ( a2 < 0x65 )
    return 2;
  v2 = a2 - 100;
  v3 = &a1[v2];
  v5 = &a1[v2 + 36];
  v4 = *v5;
  if ( (v4 ^ 0x37) != (unsigned __int8)a1[v2]
    || (v3[37] ^ 0xB4) != v3[1]
    || (v3[38] ^ 0x59) != v3[2]
    || (v3[39] ^ 0xF6) != v3[3] )
  {
    return 2;
  }
  v6 = 0LL;
  v25[0] = a1[v2 + 4] ^ v4;
  *(int8x16_t *)&v25[1] = veorq_s8(*(int8x16_t *)&a1[v2 + 5], *(int8x16_t *)&a1[v2 + 37]);
  *(int8x8_t *)&v25[17] = veor_s8(*(int8x8_t *)&a1[v2 + 21], *(int8x8_t *)&a1[v2 + 53]);
  v25[25] = a1[v2 + 29] ^ a1[v2 + 61];
  v25[26] = a1[v2 + 30] ^ a1[v2 + 62];
  v25[27] = a1[v2 + 31] ^ a1[v2 + 63];
  v25[28] = a1[v2 + 32] ^ a1[v2 + 64];
  v25[29] = a1[v2 + 33] ^ a1[v2 + 65];
  v25[30] = a1[v2 + 34] ^ a1[v2 + 66];
  v25[31] = a1[v2 + 35] ^ a1[v2 + 67];
  do
  {
    v12 = (unsigned __int8)v25[v6];
    v13 = v6 & 3;
    if ( (v6 & 3) == 0 )
    {
      v14 = (v6 + 2) & 3;
      LOBYTE(v9) = -2 - v14;
      v10 = v14 + 2;
      goto LABEL_13;
    }
    if ( v13 == 1 )
    {
      v15 = (v6 + 2) & 3;
      LOBYTE(v9) = -3 - v15;
      v10 = v15 + 3;
      goto LABEL_13;
    }
    if ( v13 != 3 )
    {
      v9 = -((v6 + 2) | 4);
      v10 = (v6 + 2) & 3 | 4;
LABEL_13:
      v11 = ((v12 ^ 0x15) << v10) | ((v12 ^ 0x15u) >> (v9 & 7));
      goto LABEL_14;
    }
    v11 = ((v12 ^ 0x15) << (((v6 + 2) & 3) + 1)) | ((v12 ^ 0x15u) >> (~((v6 + 2) & 3) & 7));
LABEL_14:
    v25[v6++] = v11;
  }
  while ( v6 != 32 );
  if ( *(_QWORD *)v25 ^ 0x390D8E32C6488C76LL | *(_QWORD *)&v25[8] ^ 0x3AA01BE338C99DFFLL | *(_QWORD *)&v25[16] ^ 0xF7F49E91ECCEF467LL | *(_QWORD *)&v25[24] ^ 0x8EE743BEFB79F8B0LL )
  {
    return 3;
  }
  else
  {
    sub_65C4398(v24);
    v16 = v24[0] & 1;
    v17 = (unsigned __int64)LOBYTE(v24[0]) >> 1;
    if ( v16 )
      v17 = v24[1];
    if ( v17 == 32 )
    {
      v18 = 0LL;
      v19 = -15;
      *(_OWORD *)v25 = xmmword_1030D3A;
      *(_OWORD *)&v25[16] = unk_1030D4A;
LABEL_34:
      v20 = ((v18 + 2) & 3) + 2;
      while ( 1 )
      {
        v25[v18] = ((v19 >> (v20 & 7)) | (v19 << (-v20 & 7))) ^ 0x15;
        if ( v18 == 31 )
          break;
        v21 = &v25[v18++];
        v19 = v21[1];
        v22 = v18 & 3;
        if ( (v18 & 3) == 0 )
          goto LABEL_34;
        if ( v22 == 1 )
        {
          v20 = ((v18 + 2) & 3) + 3;
        }
        else if ( v22 == 3 )
        {
          v20 = ((v18 + 2) & 3) + 1;
        }
        else
        {
          v20 = (v18 + 2) | 4;
        }
      }
      if ( v16 )
        v23 = (char *)v24[2];
      else
        v23 = (char *)v24 + 1;
      if ( (unsigned int)sub_67F18D8(v5, v23, 32LL, v25) )
        v7 = 6;
      else
        v7 = 0;
      v16 = v24[0] & 1;
    }
    else
    {
      v7 = 4;
    }
    if ( v16 )
      sub_65ECAF4();
  }
  return v7;
}


================================================================================
Function: sub_557704C (0x557704C)
================================================================================

__int64 __fastcall sub_557704C(__int64 result, int a2)
{
  int v3; // w20
  __int64 (__fastcall **v4)(); // [xsp+8h] [xbp-228h] BYREF
  _BYTE v5[40]; // [xsp+10h] [xbp-220h] BYREF
  _BYTE v6[472]; // [xsp+50h] [xbp-1E0h] BYREF

  if ( (_DWORD)result )
  {
    v3 = result;
    sub_257C30C(&v4, &unk_6F8D070);
    sub_625AF58(v6, "source", 6LL, "client", 1LL);
    sub_625A4DC(v6, "action", 6LL, a2, 1LL);
    sub_625A4DC(v6, "code", 4LL, v3, 1LL);
    sub_624B304(&v4);
    sub_252A00C(v6, off_6C196B0);
    v4 = off_6C19748;
    if ( (v5[24] & 1) != 0 )
      sub_65ECAF4();
    return nullsub_255(v5);
  }
  return result;
}


================================================================================
Function: sub_6241D14 (0x6241D14)
================================================================================

__int64 sub_6241D14()
{
  int v0; // w19
  unsigned __int8 v1; // w8

  v0 = sub_65EBFB8(dword_6FF8118);
  v1 = atomic_load(byte_6FF08A0);
  if ( (v1 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6FF08A0) )
  {
    qword_6FF0860 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6FF0868);
    qword_6FF0890 = 0LL;
    unk_6FF0898 = 0LL;
    qword_6FF0860 = (__int64)off_6C18F48;
    qword_6FF08A8 = (__int64)&qword_6FF0860;
    sub_6862850(byte_6FF08A0);
  }
  sub_6243640((__int64)&qword_6FF0860);
  return sub_65EBFB8(v0);
}


================================================================================
Function: sub_6243640 (0x6243640)
================================================================================

__int64 __fastcall sub_6243640(__int64 a1)
{
  unsigned __int64 v2; // x20
  unsigned __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_6867450(1LL, a1 + 56);
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65EFD58(0LL, "Reference count overflow");
  if ( v2 >> 62 != 2 )
  {
    sub_65EF508(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7301220);
      v5 = sub_65FD0A0(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_627C8C4(v5);
      sub_6867600(0x8000000000000000LL, a1 + 56);
    }
    sub_6848B0C(a1 + 8);
  }
  return a1;
}


================================================================================
Function: sub_6247F88 (0x6247F88)
================================================================================

__int64 __fastcall sub_6247F88(_DWORD *a1)
{
  __int64 result; // x0

  result = sub_65EBFB8(dword_6FF11D8);
  *a1 = result;
  return result;
}


================================================================================
Function: nullsub_255 (0x6247FB8)
================================================================================

void nullsub_255()
{
  ;
}


================================================================================
Function: sub_6247FBC (0x6247FBC)
================================================================================

__int64 __fastcall sub_6247FBC(int *a1)
{
  int v1; // w8

  v1 = *a1;
  *a1 = 0;
  return sub_65EBFB8(v1);
}


================================================================================
Function: sub_624B304 (0x624B304)
================================================================================

_QWORD *__fastcall sub_624B304(__int64 a1)
{
  __int64 v1; // x19
  unsigned __int8 v2; // w8
  __int64 v3; // x20
  _QWORD **v4; // x0
  _QWORD *v5; // x8
  unsigned __int8 v6; // w8
  const char *v7; // x2
  unsigned int v8; // w20
  __int64 v9; // x1
  unsigned __int64 v10; // x8
  bool v11; // zf
  unsigned __int64 v12; // x8
  __int64 v13; // x9
  __int64 v14; // x10
  unsigned __int8 v15; // w8
  _QWORD **v16; // x22
  __int64 v17; // x0
  _QWORD *result; // x0
  __int64 v19; // [xsp+0h] [xbp-A0h] BYREF
  _QWORD *v20; // [xsp+8h] [xbp-98h]
  __int64 v21; // [xsp+10h] [xbp-90h]
  __int64 v22; // [xsp+18h] [xbp-88h]
  __int128 v23; // [xsp+20h] [xbp-80h]
  __int128 v24; // [xsp+30h] [xbp-70h]
  __int128 v25; // [xsp+40h] [xbp-60h]
  int v26; // [xsp+50h] [xbp-50h]
  __int64 v27; // [xsp+58h] [xbp-48h]
  __int64 v28; // [xsp+60h] [xbp-40h]
  char v29; // [xsp+68h] [xbp-38h]
  __int64 v30; // [xsp+70h] [xbp-30h]
  unsigned __int64 v31; // [xsp+78h] [xbp-28h]
  __int64 v32; // [xsp+80h] [xbp-20h]
  __int64 v33; // [xsp+88h] [xbp-18h]

  v1 = a1;
  v2 = atomic_load(byte_6FF0C70);
  if ( (v2 & 1) == 0 )
  {
    a1 = sub_68626F8((__int64)byte_6FF0C70);
    if ( (_DWORD)a1 )
    {
      qword_6FF0C68 = sub_6535D1C("Telemetry", "Counter::send", 0xFFFFFFFFLL);
      a1 = sub_6862850(byte_6FF0C70);
    }
  }
  v3 = qword_6FF0C68;
  v19 = 0LL;
  v20 = 0LL;
  v26 = 0;
  v27 = 0LL;
  v28 = 0LL;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v29 = 0;
  v21 = qword_6FF0C68;
  v22 = -1LL;
  v4 = (_QWORD **)sub_25706F4(a1);
  v5 = *v4;
  v20 = v5;
  if ( v5 )
    *v5 = &v19;
  *v4 = &v19;
  if ( byte_724A7A8 )
  {
    v29 = byte_6FF8648;
    if ( byte_6FF8648 )
      sub_652253C(v3);
  }
  else
  {
    v29 = 0;
  }
  v22 = sub_65368FC(v3, -1LL, 0LL);
  v6 = atomic_load(byte_6FF0C80);
  if ( (v6 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6FF0C80) )
  {
    qword_6FF0C78 = sub_65368B4("Telemetry");
    sub_6862850(byte_6FF0C80);
  }
  if ( (*(_BYTE *)(v1 + 32) & 1) != 0 )
    v7 = *(const char **)(v1 + 48);
  else
    v7 = (const char *)(v1 + 33);
  sub_6536AFC(qword_6FF0C78, "%s (Counter)", v7);
  v8 = sub_65EBFB8((unsigned int)dword_6FF0C60);
  if ( !byte_6FF0C40 )
  {
    v9 = qword_6FF0800;
    if ( byte_724A7A8 && byte_724A758 )
    {
      if ( (unsigned __int8)qword_6FF07F8 < 6u || (qword_6FF07F8 & 0xFC00) == 0 )
        goto LABEL_23;
    }
    else if ( !(_BYTE)qword_6FF07F8 )
    {
LABEL_23:
      v15 = atomic_load(byte_6FF08A0);
      if ( (v15 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6FF08A0) )
      {
        qword_6FF0860 = (__int64)off_686F7E8;
        sub_68489F4(&unk_6FF0868);
        qword_6FF0890 = 0LL;
        unk_6FF0898 = 0LL;
        qword_6FF0860 = (__int64)off_6C18F48;
        qword_6FF08A8 = (__int64)&qword_6FF0860;
        sub_6862850(byte_6FF08A0);
      }
      v16 = (_QWORD **)sub_6243640(&qword_6FF0860, v9);
      if ( !byte_724A7A8 || !byte_6FF1518 || (unsigned int)sub_6259DA8(v1 + 32) >= dword_6FF1548 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)(v1 + 72) + 312LL))(v1 + 72);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)(v1 + 72) + 304LL))(v1 + 72);
      (*(void (__fastcall **)(_QWORD *, __int64))(*v16[6] + 32LL))(v16[6], v1);
      ((void (__fastcall *)(_QWORD **))(*v16)[2])(v16);
      goto LABEL_29;
    }
    v10 = *(unsigned __int8 *)(v1 + 32);
    v11 = (v10 & 1) == 0;
    v12 = v10 >> 1;
    if ( v11 )
    {
      v13 = v1 + 33;
    }
    else
    {
      v12 = *(_QWORD *)(v1 + 40);
      v13 = *(_QWORD *)(v1 + 48);
    }
    v14 = *(_QWORD *)(v1 + 536);
    v30 = v13;
    v31 = v12;
    v32 = v14;
    v33 = 0LL;
    sub_65C5CFC(qword_6FF07F8);
    goto LABEL_23;
  }
LABEL_29:
  sub_65EBFB8(v8);
  v17 = sub_6536BEC(v21, v22, -1LL, 0LL, 0LL);
  result = (_QWORD *)sub_25706F4(v17);
  *result = v20;
  if ( v20 )
    *v20 = 0LL;
  if ( v29 )
    return (_QWORD *)sub_65225A4(v21);
  return result;
}


================================================================================
Function: sub_6259DA8 (0x6259DA8)
================================================================================

__int64 __fastcall sub_6259DA8(unsigned __int8 *a1)
{
  unsigned int v2; // w0
  unsigned __int8 *v3; // x9
  unsigned __int64 v4; // x10
  unsigned int v5; // w19
  unsigned __int64 v6; // x8
  bool v7; // zf
  unsigned __int64 v8; // x8
  unsigned __int8 *v9; // x0
  unsigned __int64 v10; // x1
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x20
  size_t v14[2]; // [xsp+0h] [xbp-150h] BYREF
  _QWORD v15[2]; // [xsp+18h] [xbp-138h] BYREF
  unsigned __int64 v16; // [xsp+30h] [xbp-120h] BYREF
  _QWORD v17[2]; // [xsp+38h] [xbp-118h] BYREF
  _QWORD v18[8]; // [xsp+48h] [xbp-108h] BYREF
  __int128 v19; // [xsp+88h] [xbp-C8h]
  __int128 v20; // [xsp+98h] [xbp-B8h]
  int v21; // [xsp+A8h] [xbp-A8h]
  _QWORD v22[18]; // [xsp+B0h] [xbp-A0h] BYREF
  int v23; // [xsp+140h] [xbp-10h]

  v2 = sub_65EBFB8((unsigned int)dword_6FF8118);
  v4 = *((_QWORD *)a1 + 1);
  v3 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  v5 = v2;
  v16 = 0LL;
  v6 = *a1;
  v7 = (v6 & 1) == 0;
  v8 = v6 >> 1;
  if ( v7 )
    v9 = a1 + 1;
  else
    v9 = v3;
  if ( v7 )
    v10 = v8;
  else
    v10 = v4;
  sub_65C416C(v15, v9, v10);
  if ( (v15[0] & 1) != 0 )
    v11 = v15[1];
  else
    v11 = (unsigned __int64)LOBYTE(v15[0]) >> 1;
  if ( v11 < 0x11 )
    sub_68497A0(v14, v15);
  else
    sub_6849CE0(v14, (unsigned __int8 *)v15, v11 - 16, 0xFFFFFFFFFFFFFFFFLL);
  v22[0] = off_6887558;
  v17[0] = off_6887530;
  v17[1] = 0LL;
  sub_681F548(v22, v18);
  v22[17] = 0LL;
  v23 = -1;
  v17[0] = off_68874C0;
  v22[0] = off_68874E8;
  sub_681C128(v18);
  v21 = 8;
  v19 = 0u;
  v20 = 0u;
  v18[0] = off_6874A98;
  sub_26D904C(v18, v14);
  *(_DWORD *)((char *)&v17[1] + *(_QWORD *)(v17[0] - 24LL)) = *(_DWORD *)((_BYTE *)&v17[1] + *(_QWORD *)(v17[0] - 24LL)) & 0xFFFFFFB5 | 8;
  sub_681CC68(v17, &v16);
  v22[0] = off_68874E8;
  v17[0] = off_68874C0;
  v18[0] = off_6874A98;
  if ( (v19 & 1) != 0 )
    sub_65ECAF4();
  sub_66013A0(v18);
  sub_681C568(v17, off_6887500);
  sub_681C034(v22);
  if ( (v14[0] & 1) != 0 )
    sub_65ECAF4();
  v12 = v16 % 0x64;
  v16 %= 0x64uLL;
  if ( (v15[0] & 1) != 0 )
    sub_65ECAF4();
  sub_65EBFB8(v5);
  return (unsigned int)v12;
}


================================================================================
Function: sub_625A4DC (0x625A4DC)
================================================================================

__int64 __fastcall sub_625A4DC(__int64 a1, const void *a2, size_t a3, __int64 a4)
{
  unsigned int v8; // w19
  __int64 v9; // x0
  char *v10; // x24
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x10
  __int128 v13; // q0
  char *v14; // x9
  __int128 v15; // q0
  __int128 v17; // [xsp+8h] [xbp-48h] BYREF
  char *v18; // [xsp+18h] [xbp-38h]
  __int128 v19; // [xsp+20h] [xbp-30h] BYREF
  char *v20; // [xsp+30h] [xbp-20h]
  __int64 v21; // [xsp+38h] [xbp-18h]

  v8 = sub_65EBFB8((unsigned int)dword_6FF11D8);
  v9 = sub_65EBFB8((unsigned int)dword_6FF11D8);
  sub_65EBFB8(v9);
  if ( !a2 )
  {
    v17 = 0uLL;
    v18 = 0LL;
    goto LABEL_10;
  }
  if ( a3 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630(&v17);
  if ( a3 >= 0x17 )
  {
    v10 = (char *)sub_65ECAAC();
    *((_QWORD *)&v17 + 1) = a3;
    v18 = v10;
    *(_QWORD *)&v17 = (a3 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v10 = (char *)&v17 + 1;
    LOBYTE(v17) = 2 * a3;
    if ( !a3 )
      goto LABEL_9;
  }
  memcpy(v10, a2, a3);
LABEL_9:
  v10[a3] = 0;
LABEL_10:
  v11 = *(_QWORD *)(a1 + 24);
  v12 = *(_QWORD *)(a1 + 32);
  v13 = v17;
  v17 = 0uLL;
  v14 = v18;
  v18 = 0LL;
  v19 = v13;
  v20 = v14;
  v21 = a4;
  if ( v11 >= v12 )
  {
    sub_6261338(a1 + 16, &v19);
    if ( (v19 & 1) != 0 )
      sub_65ECAF4();
  }
  else
  {
    v15 = v19;
    *(_QWORD *)(v11 + 16) = v20;
    *(_OWORD *)v11 = v15;
    v20 = 0LL;
    v19 = 0uLL;
    *(_QWORD *)(v11 + 24) = v21;
    *(_QWORD *)(a1 + 24) = v11 + 32;
  }
  if ( (v17 & 1) != 0 )
    sub_65ECAF4();
  return sub_65EBFB8(v8);
}


================================================================================
Function: sub_625AF58 (0x625AF58)
================================================================================

__int64 __fastcall sub_625AF58(__int64 a1, __int64 a2, __int64 a3, const char *a4, unsigned int a5)
{
  unsigned int v10; // w19
  size_t v11; // x4

  v10 = sub_65EBFB8((unsigned int)dword_6FF11D8);
  if ( a4 )
    v11 = strlen(a4);
  else
    v11 = 0LL;
  (*(void (__fastcall **)(__int64, __int64, __int64, const char *, size_t, _QWORD))(*(_QWORD *)a1 + 24LL))(
    a1,
    a2,
    a3,
    a4,
    v11,
    a5);
  return sub_65EBFB8(v10);
}


================================================================================
Function: sub_6261338 (0x6261338)
================================================================================

__int64 __fastcall sub_6261338(__int64 *a1, __int128 *a2)
{
  __int64 v3; // x22
  unsigned __int64 v4; // x8
  __int64 v5; // x9
  __int64 v6; // x21
  __int64 result; // x0
  __int128 v9; // q0
  __int64 v10; // x12
  __int64 v11; // x13
  __int64 v12; // x10
  __int64 v13; // x11
  __int64 v14; // x20
  __int64 v15; // x8
  __int64 v16; // x9
  __int64 v17; // x12
  __int128 v18; // q0
  bool v19; // zf
  __int64 v20; // x14
  __int64 v21; // x11
  __int64 v22; // x19
  char v23; // t1

  v3 = (a1[1] - *a1) >> 5;
  v4 = v3 + 1;
  if ( (unsigned __int64)(v3 + 1) >> 59 )
    sub_684DBEC(a1);
  v5 = a1[2] - *a1;
  if ( v5 >> 4 >= v4 )
    v4 = v5 >> 4;
  if ( (unsigned __int64)v5 >= 0x7FFFFFFFFFFFFFE0LL )
    v4 = 0x7FFFFFFFFFFFFFFLL;
  if ( v4 >> 59 )
    sub_24FD568("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v6 = 32 * v4;
  result = sub_65ECAAC();
  v9 = *a2;
  *(_QWORD *)a2 = 0LL;
  *((_QWORD *)a2 + 1) = 0LL;
  v10 = *((_QWORD *)a2 + 2);
  v11 = *((_QWORD *)a2 + 3);
  *((_QWORD *)a2 + 2) = 0LL;
  v12 = result + 32 * v3;
  v14 = *a1;
  v13 = a1[1];
  v15 = result + v6;
  v16 = v12 + 32;
  *(_OWORD *)v12 = v9;
  *(_QWORD *)(v12 + 16) = v10;
  *(_QWORD *)(v12 + 24) = v11;
  if ( v13 == v14 )
  {
    *a1 = v12;
    a1[1] = v16;
    a1[2] = v15;
  }
  else
  {
    do
    {
      v17 = v12;
      v18 = *(_OWORD *)(v13 - 32);
      v19 = v13 - 32 == v14;
      *(_QWORD *)(v12 - 16) = *(_QWORD *)(v13 - 16);
      v12 -= 32LL;
      *(_OWORD *)v12 = v18;
      *(_QWORD *)(v13 - 24) = 0LL;
      *(_QWORD *)(v13 - 16) = 0LL;
      v20 = *(_QWORD *)(v13 - 8);
      *(_QWORD *)(v13 - 32) = 0LL;
      v13 -= 32LL;
      *(_QWORD *)(v17 - 8) = v20;
    }
    while ( !v19 );
    v14 = *a1;
    v21 = a1[1];
    *a1 = v12;
    a1[1] = v16;
    a1[2] = v15;
    if ( v21 != v14 )
    {
      v22 = v21;
      do
      {
        v23 = *(_BYTE *)(v22 - 32);
        v22 -= 32LL;
        if ( (v23 & 1) != 0 )
          result = sub_65ECAF4();
      }
      while ( v22 != v14 );
    }
  }
  if ( v14 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_62615EC (0x62615EC)
================================================================================

__int64 __fastcall sub_62615EC(unsigned __int64 *a1, __int128 *a2, __int128 *a3)
{
  unsigned __int64 v4; // x22
  unsigned __int64 v5; // x10
  unsigned __int64 v8; // x23
  __int64 result; // x0
  __int64 v10; // x9
  __int128 v11; // q0
  unsigned __int64 v12; // x10
  __int64 v13; // x12
  unsigned __int64 v14; // x8
  __int128 v15; // q1
  unsigned __int64 v16; // x11
  unsigned __int64 v17; // x20
  unsigned __int64 v18; // x9
  __int128 v19; // q0
  __int64 v20; // x12
  __int128 v21; // q0
  bool v22; // zf
  unsigned __int64 v23; // x20
  unsigned __int64 v24; // x21
  unsigned __int64 v25; // x19

  v4 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if ( v4 + 1 > 0x555555555555555LL )
    sub_684DBEC();
  if ( 0x5555555555555556LL * ((__int64)(a1[2] - *a1) >> 4) >= v5 )
    v5 = 0x5555555555555556LL * ((__int64)(a1[2] - *a1) >> 4);
  if ( 0xAAAAAAAAAAAAAAABLL * ((__int64)(a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL )
    v8 = 0x555555555555555LL;
  else
    v8 = v5;
  if ( v8 )
  {
    if ( v8 > 0x555555555555555LL )
      sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    result = sub_65ECAAC();
  }
  else
  {
    result = 0LL;
  }
  v10 = *((_QWORD *)a2 + 2);
  v11 = *a2;
  *(_QWORD *)a2 = 0LL;
  *((_QWORD *)a2 + 1) = 0LL;
  *((_QWORD *)a2 + 2) = 0LL;
  v12 = result + 48 * v4;
  v13 = *((_QWORD *)a3 + 2);
  v14 = result + 48 * v8;
  v15 = *a3;
  *(_QWORD *)a3 = 0LL;
  *((_QWORD *)a3 + 1) = 0LL;
  *((_QWORD *)a3 + 2) = 0LL;
  v17 = *a1;
  v16 = a1[1];
  *(_QWORD *)(v12 + 16) = v10;
  v18 = v12 + 48;
  *(_OWORD *)v12 = v11;
  *(_OWORD *)(v12 + 24) = v15;
  *(_QWORD *)(v12 + 40) = v13;
  if ( v16 == v17 )
  {
    *a1 = v12;
    a1[1] = v18;
    a1[2] = v14;
    if ( v17 )
      return sub_65ECAF4();
  }
  else
  {
    do
    {
      v19 = *(_OWORD *)(v16 - 48);
      *(_QWORD *)(v12 - 32) = *(_QWORD *)(v16 - 32);
      *(_OWORD *)(v12 - 48) = v19;
      v20 = *(_QWORD *)(v16 - 8);
      *(_QWORD *)(v16 - 40) = 0LL;
      *(_QWORD *)(v16 - 32) = 0LL;
      v21 = *(_OWORD *)(v16 - 24);
      *(_QWORD *)(v16 - 48) = 0LL;
      *(_QWORD *)(v12 - 8) = v20;
      *(_OWORD *)(v12 - 24) = v21;
      v12 -= 48LL;
      *(_QWORD *)(v16 - 16) = 0LL;
      *(_QWORD *)(v16 - 8) = 0LL;
      v22 = v16 - 48 == v17;
      *(_QWORD *)(v16 - 24) = 0LL;
      v16 -= 48LL;
    }
    while ( !v22 );
    v23 = *a1;
    v24 = a1[1];
    *a1 = v12;
    a1[1] = v18;
    a1[2] = v14;
    if ( v24 != v23 )
    {
      do
      {
        if ( (*(_BYTE *)(v24 - 24) & 1) != 0 )
          result = sub_65ECAF4();
        v25 = v24 - 48;
        if ( (*(_BYTE *)(v24 - 48) & 1) != 0 )
          result = sub_65ECAF4();
        v24 -= 48LL;
      }
      while ( v25 != v23 );
    }
    if ( v23 )
      return sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_627C8C4 (0x627C8C4)
================================================================================

_QWORD *sub_627C8C4()
{
  _QWORD *v0; // x19
  unsigned __int8 v1; // w8
  __int64 v2; // x8
  _QWORD *result; // x0

  v0 = (_QWORD *)sub_65ECAAC();
  v0[1] = "RobloxTelemetryImpl";
  v0[2] = 19LL;
  *v0 = off_6C1C1D8;
  v1 = atomic_load(byte_6DE8798);
  if ( (v1 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6DE8798) )
  {
    qword_6DE8758 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6DE8760);
    qword_6DE8788 = 0LL;
    unk_6DE8790 = 0LL;
    qword_6DE8758 = (__int64)off_69609F8;
    qword_6DE87A0 = (__int64)&qword_6DE8758;
    sub_6862850(byte_6DE8798);
  }
  v2 = sub_3CD3B2C(&qword_6DE8758);
  result = v0;
  v0[3] = v2;
  return result;
}


================================================================================
Function: sub_6285D50 (0x6285D50)
================================================================================

__int64 __fastcall sub_6285D50(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_6867450(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65EFD58(0);
  if ( v2 >> 62 != 2 )
  {
    sub_65EF508(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7301220);
      v5 = sub_65FD0A0(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_6285FD4(v5);
      sub_6867600(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_6848B0C((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_6285FD4 (0x6285FD4)
================================================================================

__int64 sub_6285FD4()
{
  __int64 v0; // x19

  v0 = sub_65ED63C(0x58uLL);
  sub_6496200();
  return v0;
}


================================================================================
Function: sub_628BA50 (0x628BA50)
================================================================================

__int64 __fastcall sub_628BA50(__int64 a1, char *s, int a3, int a4)
{
  _BYTE *v5; // x20
  size_t v7; // x0
  size_t v8; // x22
  void *v9; // x23
  unsigned __int64 v10; // x24

  v5 = (_BYTE *)(a1 + 16);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = a4;
  v7 = strlen(s);
  if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v8 = v7;
  if ( v7 >= 0x17 )
  {
    v10 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v9 = (void *)sub_65ECAAC();
    *(_QWORD *)(a1 + 24) = v8;
    *(_QWORD *)(a1 + 32) = v9;
    *(_QWORD *)(a1 + 16) = v10 | 1;
  }
  else
  {
    *v5 = 2 * v7;
    v9 = v5 + 1;
    if ( !v7 )
      goto LABEL_7;
  }
  v7 = (size_t)memcpy(v9, s, v8);
LABEL_7:
  *((_BYTE *)v9 + v8) = 0;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_OWORD *)(a1 + 40) = 0u;
  return sub_628BB6C(v7);
}


================================================================================
Function: sub_628BB58 (0x628BB58)
================================================================================

__int64 __fastcall sub_628BB58(int a1, __int64 a2)
{
  char *v2; // x1

  if ( (*(_BYTE *)a2 & 1) != 0 )
    v2 = *(char **)(a2 + 16);
  else
    v2 = (char *)(a2 + 1);
  return sub_628BA50(a1, v2);
}


================================================================================
Function: sub_628BB6C (0x628BB6C)
================================================================================

__int64 sub_628BB6C()
{
  __int64 result; // x0
  unsigned __int64 v1; // x8
  __int128 *v2; // x0
  __int128 *v3; // x0
  __int128 *v4; // x0
  pthread_mutex_t *v5; // x19
  __int128 v6; // [xsp+38h] [xbp-98h] BYREF
  __int128 v7; // [xsp+50h] [xbp-80h] BYREF
  __int128 v8; // [xsp+68h] [xbp-68h] BYREF
  __int64 v9; // [xsp+78h] [xbp-58h]
  unsigned __int64 v10[2]; // [xsp+80h] [xbp-50h] BYREF
  pthread_mutex_t *v11; // [xsp+B8h] [xbp-18h] BYREF
  char v12; // [xsp+C0h] [xbp-10h]

  v11 = (pthread_mutex_t *)&unk_6FF2420;
  v12 = 0;
  result = sub_25C6ADC((__int64)&v11);
  if ( (xmmword_6FF23F0 & 1) != 0 )
    v1 = *((_QWORD *)&xmmword_6FF23F0 + 1);
  else
    v1 = (unsigned __int64)(unsigned __int8)xmmword_6FF23F0 >> 1;
  if ( !v1 )
  {
    sub_65AF224(&v6, 0LL, 3LL, 0LL);
    sub_68497A0((unsigned __int64 *)&v8, &v6);
    v2 = (__int128 *)sub_67DA998((int)&v8);
    sub_68497A0((unsigned __int64 *)&v7, v2);
    if ( (v8 & 1) != 0 )
      sub_65ECAF4();
    sub_68497A0((unsigned __int64 *)&v8, &v7);
    v3 = (__int128 *)sub_67DA998((int)&v8);
    sub_68497A0(v10, v3);
    if ( (v8 & 1) != 0 )
      sub_65ECAF4();
    if ( (v7 & 1) != 0 )
      sub_65ECAF4();
    if ( (v6 & 1) != 0 )
      sub_65ECAF4();
    if ( (sub_65D5F28(v10) & 1) == 0 )
    {
      sub_65AF224(&v6, 0LL, 3LL, 0LL);
      sub_68497A0((unsigned __int64 *)&v8, &v6);
      v4 = (__int128 *)sub_67DA998((int)&v8);
      sub_68497A0((unsigned __int64 *)&v7, v4);
      if ( (v8 & 1) != 0 )
        sub_65ECAF4();
      sub_684A438((unsigned __int8 *)v10, (unsigned __int8 *)&v7);
      if ( (v7 & 1) != 0 )
        sub_65ECAF4();
      if ( (v6 & 1) != 0 )
        sub_65ECAF4();
    }
    result = (__int64)sub_65FC630(&v8, v10);
    if ( (xmmword_6FF23F0 & 1) != 0 )
      result = sub_65ECAF4();
    xmmword_6FF23F0 = v8;
    qword_6FF2400 = v9;
    byte_6FF238C = 1;
    if ( (v10[0] & 1) != 0 )
      result = sub_65ECAF4();
  }
  if ( v12 )
  {
    v5 = v11;
    do
      result = pthread_mutex_unlock(v5);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25C5E54(v10, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24((__int64)v10);
    }
  }
  return result;
}


================================================================================
Function: sub_628C114 (0x628C114)
================================================================================

__int64 *sub_628C114()
{
  return &qword_6FF2370;
}


================================================================================
Function: sub_628C1E4 (0x628C1E4)
================================================================================

__int64 __fastcall sub_628C1E4(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        char a5,
        __int64 a6,
        char a7,
        char a8,
        char a9)
{
  unsigned int v17; // w0
  __int64 v18; // x19
  _QWORD *v19; // x0
  __int64 v20; // x8
  pthread_mutex_t *v21; // x19
  unsigned int v22; // w1
  unsigned __int64 *v23; // x19
  __int64 result; // x0
  __int64 v25; // x20
  _QWORD *v26; // x19
  _QWORD v27[2]; // [xsp+10h] [xbp-140h] BYREF
  __int64 v28; // [xsp+20h] [xbp-130h] BYREF
  _QWORD v29[2]; // [xsp+28h] [xbp-128h] BYREF
  __int64 v30; // [xsp+38h] [xbp-118h]
  char v31; // [xsp+44h] [xbp-10Ch] BYREF
  _QWORD v32[7]; // [xsp+48h] [xbp-108h] BYREF
  pthread_mutex_t *p_mutex; // [xsp+80h] [xbp-D0h] BYREF
  char v34; // [xsp+88h] [xbp-C8h]
  _BYTE v35[32]; // [xsp+90h] [xbp-C0h] BYREF
  _BYTE *v36; // [xsp+B0h] [xbp-A0h]
  pthread_mutex_t v37; // [xsp+C0h] [xbp-90h] BYREF
  pthread_cond_t v38; // [xsp+E8h] [xbp-68h] BYREF
  pthread_mutex_t mutex; // [xsp+118h] [xbp-38h] BYREF

  v17 = pthread_mutex_init(&mutex, 0LL);
  if ( v17 )
  {
    sub_25C1BEC(&v37, v17, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25C1ABC((__int64)&v37);
  }
  sub_25C1984((__int64)&v37);
  v31 = 0;
  v29[1] = a3;
  v18 = sub_65ECAAC();
  *(_QWORD *)(v18 + 16) = 0LL;
  *(_QWORD *)(v18 + 24) = a3;
  v30 = v18;
  *(_QWORD *)v18 = off_6C1C828;
  v27[0] = a3;
  v27[1] = v18;
  *(_QWORD *)(v18 + 8) = 0LL;
  v28 = 0LL;
  v29[0] = 0LL;
  sub_6867420(1uLL, (atomic_ullong *)(v18 + 8));
  v19 = (_QWORD *)sub_65ECAAC();
  v36 = v19;
  *v19 = off_6C1C878;
  v19[1] = a6;
  v19[2] = v29;
  v19[3] = &v28;
  v19[4] = &mutex;
  v19[5] = &v31;
  v19[6] = &v37;
  ((void (__fastcall *)(__int64, __int64, _QWORD *, __int64, _QWORD, _BYTE *, _QWORD, _QWORD, _BYTE))sub_628C5F0)(
    a1,
    a2,
    v27,
    a4,
    a5 & 1,
    v35,
    a7 & 1,
    a8 & 1,
    a9 & 1);
  if ( v35 == v36 )
  {
    v20 = 4LL;
  }
  else
  {
    if ( !v36 )
      goto LABEL_7;
    v20 = 5LL;
  }
  (*(void (**)(void))(*(_QWORD *)v36 + 8 * v20))();
LABEL_7:
  if ( !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v18 + 8)) )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 16LL))(v18);
    sub_68488BC((unsigned __int64 *)v18);
  }
  v34 = 0;
  p_mutex = &mutex;
  sub_25C6ADC(&p_mutex);
  while ( !v31 )
    sub_25C6934(&v37, &p_mutex);
  if ( v34 )
  {
    v21 = p_mutex;
    do
      v22 = pthread_mutex_unlock(v21);
    while ( v22 == 4 );
    if ( v22 )
    {
      sub_25C5E54(v32, v22, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24((__int64)v32);
    }
  }
  if ( v29[0] )
  {
    v25 = sub_6861FD0(40LL);
    sub_628CA80(v25, v29[0]);
    sub_6862048(v25, (__int64)&`typeinfo for'RBX::http_status_error, (__int64)sub_3C24D48);
  }
  if ( v28 )
  {
    v26 = (_QWORD *)sub_6861FD0(16LL);
    sub_68495F8(v26, v28);
    sub_6862048((__int64)v26, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_6865364);
  }
  v23 = (unsigned __int64 *)v30;
  if ( v30 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v30 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v23 + 16))(v23);
    sub_68488BC(v23);
  }
  while ( pthread_mutex_destroy(&v37) == 4 )
    ;
  while ( pthread_cond_destroy(&v38) == 4 )
    ;
  do
    result = pthread_mutex_destroy(&mutex);
  while ( (_DWORD)result == 4 );
  return result;
}


================================================================================
Function: sub_628C5F0 (0x628C5F0)
================================================================================

_BYTE *__fastcall sub_628C5F0(
        __int64 a1,
        __int128 *a2,
        __int64 *a3,
        __int128 *a4,
        char a5,
        __int64 a6,
        char a7,
        char a8,
        char a9)
{
  _QWORD *v17; // x0
  __int64 v18; // x8
  __int64 v19; // x0
  _QWORD *v20; // x0
  __int64 v21; // x9
  __int64 v22; // x10
  _QWORD *v23; // x20
  __int64 v24; // x8
  __int64 v25; // x9
  _BYTE *v26; // x0
  char v27; // w8
  __int64 v28; // x8
  _BYTE *result; // x0
  __int64 v30; // x8
  unsigned __int64 *v31; // x19
  unsigned __int64 *v32; // x19
  unsigned __int64 *v33; // x19
  __int64 v34; // [xsp+8h] [xbp-F8h]
  __int64 v35; // [xsp+10h] [xbp-F0h] BYREF
  __int64 v36; // [xsp+18h] [xbp-E8h]
  __int64 v37; // [xsp+20h] [xbp-E0h]
  __int64 v38; // [xsp+28h] [xbp-D8h]
  __int128 v39; // [xsp+30h] [xbp-D0h] BYREF
  __int64 v40; // [xsp+48h] [xbp-B8h]
  __int64 v41; // [xsp+50h] [xbp-B0h]
  __int128 v42; // [xsp+58h] [xbp-A8h] BYREF
  char v43; // [xsp+70h] [xbp-90h]
  _BYTE v44[32]; // [xsp+80h] [xbp-80h] BYREF
  _BYTE *v45; // [xsp+A0h] [xbp-60h]
  __int16 v46; // [xsp+B0h] [xbp-50h]
  char v47; // [xsp+B2h] [xbp-4Eh]
  _BYTE v48[32]; // [xsp+C0h] [xbp-40h] BYREF
  _BYTE *v49; // [xsp+E0h] [xbp-20h]

  v17 = sub_628D16C(&v35);
  if ( byte_724A7A8 && byte_7248960 && byte_6FF1DB0 && (a7 & 1) == 0 )
    v17 = (_QWORD *)sub_628D2C8(a1);
  v34 = sub_62EB28C(v17);
  v37 = v35;
  v38 = v36;
  if ( v36 )
    sub_6867420(1uLL, (atomic_ullong *)(v36 + 8));
  sub_68497A0((unsigned __int64 *)&v39, a2);
  v18 = a3[1];
  v40 = *a3;
  v41 = v18;
  if ( v18 )
    sub_6867420(1uLL, (atomic_ullong *)(v18 + 8));
  sub_68497A0((unsigned __int64 *)&v42, a4);
  v19 = *(_QWORD *)(a6 + 32);
  v43 = a5 & 1;
  if ( !v19 )
    goto LABEL_13;
  if ( a6 != v19 )
  {
    v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 16LL))(v19);
LABEL_13:
    v45 = (_BYTE *)v19;
    goto LABEL_15;
  }
  v45 = v44;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 24LL))(v19);
LABEL_15:
  v49 = 0LL;
  LOBYTE(v46) = a7 & 1;
  HIBYTE(v46) = a8 & 1;
  v47 = a9 & 1;
  v20 = (_QWORD *)sub_65ECAAC();
  v21 = v37;
  v22 = v38;
  v23 = v20;
  v37 = 0LL;
  v38 = 0LL;
  *v20 = off_6C1CA38;
  v20[2] = v21;
  v20[3] = v22;
  sub_68497A0(v20 + 4, &v39);
  v24 = v40;
  v25 = v41;
  v40 = 0LL;
  v41 = 0LL;
  v23[7] = v24;
  v23[8] = v25;
  sub_68497A0(v23 + 9, &v42);
  v26 = v45;
  *((_BYTE *)v23 + 96) = v43;
  if ( v26 )
  {
    if ( v44 == v26 )
    {
      v23[18] = v23 + 14;
      (*(void (__fastcall **)(_BYTE *))(*(_QWORD *)v26 + 24LL))(v26);
    }
    else
    {
      v23[18] = v26;
      v45 = 0LL;
    }
  }
  else
  {
    v23[18] = 0LL;
  }
  v49 = v23;
  v27 = v47;
  *((_WORD *)v23 + 80) = v46;
  *((_BYTE *)v23 + 162) = v27;
  sub_6594154(v34, v48);
  if ( v48 == v49 )
  {
    v28 = 4LL;
  }
  else
  {
    if ( !v49 )
      goto LABEL_25;
    v28 = 5LL;
  }
  (*(void (**)(void))(*(_QWORD *)v49 + 8 * v28))();
LABEL_25:
  result = v45;
  if ( v44 == v45 )
  {
    v30 = 4LL;
  }
  else
  {
    if ( !v45 )
      goto LABEL_30;
    v30 = 5LL;
  }
  result = (_BYTE *)(*(__int64 (**)(void))(*(_QWORD *)v45 + 8 * v30))();
LABEL_30:
  if ( (v42 & 1) != 0 )
    result = (_BYTE *)sub_65ECAF4();
  v31 = (unsigned __int64 *)v41;
  if ( v41 )
  {
    result = (_BYTE *)sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v41 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v31 + 16))(v31);
      result = (_BYTE *)sub_68488BC(v31);
      if ( (v39 & 1) == 0 )
        goto LABEL_36;
      goto LABEL_35;
    }
  }
  if ( (v39 & 1) != 0 )
LABEL_35:
    result = (_BYTE *)sub_65ECAF4();
LABEL_36:
  v32 = (unsigned __int64 *)v38;
  if ( v38 )
  {
    result = (_BYTE *)sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v38 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v32 + 16))(v32);
      result = (_BYTE *)sub_68488BC(v32);
    }
  }
  v33 = (unsigned __int64 *)v36;
  if ( v36 )
  {
    result = (_BYTE *)sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v36 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v33 + 16))(v33);
      return (_BYTE *)sub_68488BC(v33);
    }
  }
  return result;
}


================================================================================
Function: sub_628CA80 (0x628CA80)
================================================================================

unsigned __int64 __fastcall sub_628CA80(__int64 a1, __int64 a2)
{
  unsigned __int64 result; // x0
  __int64 v5; // x8
  __int64 v6; // x10

  result = sub_68495F8((_QWORD *)a1, a2);
  v6 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)a1 = off_69586C0;
  *(_QWORD *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 24) = v5;
  if ( v5 )
    result = sub_6867420(1uLL, (atomic_ullong *)(v5 + 8));
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  return result;
}


================================================================================
Function: sub_628D000 (0x628D000)
================================================================================

__int64 __usercall sub_628D000@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  _QWORD *v3; // x21
  __int64 v4; // x21
  _QWORD *v5; // x22
  __int64 result; // x0

  if ( byte_724A7A8 )
    v2 = byte_7301120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = (_QWORD *)sub_65ECAAC();
    v3[1] = 0LL;
    v3[2] = 0LL;
    *v3 = off_6C1C948;
    result = sub_6293228(v3 + 3);
    *a1 = v3 + 3;
    a1[1] = v3;
  }
  else
  {
    v4 = sub_680599C();
    v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 304LL, 8LL);
    v5[2] = 0LL;
    v5[3] = v4;
    *v5 = off_6C1C8F8;
    v5[1] = 0LL;
    result = sub_6293228(v5 + 4);
    *a1 = v5 + 4;
    a1[1] = v5;
  }
  return result;
}


================================================================================
Function: sub_628D16C (0x628D16C)
================================================================================

__int64 __usercall sub_628D16C@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  bool v4; // zf
  _QWORD *v5; // x21
  __int64 v6; // x21
  _QWORD *v7; // x22
  __int64 result; // x0

  if ( byte_724A7A8 )
    v4 = byte_7301120 == 0;
  else
    v4 = 1;
  if ( v4 )
  {
    v5 = (_QWORD *)sub_65ECAAC();
    v5[1] = 0LL;
    v5[2] = 0LL;
    *v5 = off_6C1C9E8;
    result = sub_465BAD0(v5 + 3, a1);
    *a2 = v5 + 3;
    a2[1] = v5;
  }
  else
  {
    v6 = sub_680599C();
    v7 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 16LL))(v6, 136LL, 8LL);
    v7[2] = 0LL;
    v7[3] = v6;
    *v7 = off_6C1C998;
    v7[1] = 0LL;
    result = sub_465BAD0(v7 + 4, a1);
    *a2 = v7 + 4;
    a2[1] = v7;
  }
  return result;
}


================================================================================
Function: sub_628D2C8 (0x628D2C8)
================================================================================

__int64 __fastcall sub_628D2C8(__int64 a1)
{
  __int64 v2; // x21
  unsigned __int64 v3; // x8
  unsigned int v4; // w20
  size_t v5; // x2
  unsigned __int64 v6; // x8
  unsigned __int8 *v7; // x8
  char *v8; // x0
  unsigned __int8 *v9; // x1
  unsigned __int64 v10; // x9
  int v11; // w10
  int v12; // t1
  int v13; // w11
  int v14; // t1
  __int64 v16; // x22
  __int128 v17; // q0
  char *v18; // x8
  unsigned __int64 v19; // x8
  size_t v20; // x2
  unsigned __int64 v21; // x8
  unsigned __int8 *v22; // x8
  char *v23; // x0
  unsigned __int8 *v24; // x1
  unsigned __int64 v25; // x9
  int v26; // w10
  int v27; // t1
  int v28; // w11
  int v29; // t1
  __int64 v31; // x22
  __int128 v32; // q0
  char *v33; // x8
  unsigned __int64 v34; // x8
  size_t v35; // x2
  unsigned __int64 v36; // x8
  unsigned __int8 *v37; // x8
  char *v38; // x0
  unsigned __int8 *v39; // x1
  unsigned __int64 v40; // x9
  int v41; // w10
  int v42; // t1
  int v43; // w11
  int v44; // t1
  __int64 v46; // x22
  __int128 v47; // q0
  char *v48; // x8
  __int64 result; // x0
  unsigned __int64 v50; // x8
  __int64 v51; // x19
  unsigned int v52; // t1
  bool v53; // zf
  unsigned __int64 v54; // x8
  size_t v55; // x1
  __int64 *v56; // x0
  unsigned __int64 v57; // x9
  unsigned __int64 *v58; // x0
  char *v59; // x0
  unsigned __int64 v60; // x1
  unsigned __int8 v61; // w0
  int v62; // w8
  __int64 v63; // x21
  __int128 v64; // q0
  char *v65; // x8
  unsigned __int64 v66[2]; // [xsp+0h] [xbp-100h] BYREF
  __int128 v67; // [xsp+18h] [xbp-E8h] BYREF
  char *v68; // [xsp+28h] [xbp-D8h]
  __int128 v69; // [xsp+30h] [xbp-D0h] BYREF
  char *v70; // [xsp+40h] [xbp-C0h]
  __int128 v71; // [xsp+48h] [xbp-B8h] BYREF
  char *v72; // [xsp+58h] [xbp-A8h]
  __int128 v73; // [xsp+60h] [xbp-A0h] BYREF
  char *v74; // [xsp+70h] [xbp-90h]
  __int64 v75[2]; // [xsp+78h] [xbp-88h] BYREF
  char v76; // [xsp+90h] [xbp-70h]
  char v77; // [xsp+A8h] [xbp-58h]
  char v78; // [xsp+C0h] [xbp-40h]
  char v79; // [xsp+D8h] [xbp-28h]

  v2 = a1 + 40;
  sub_65B6B3C(5u);
  if ( (v73 & 1) != 0 )
    v3 = *((_QWORD *)&v73 + 1);
  else
    v3 = (unsigned __int64)(unsigned __int8)v73 >> 1;
  if ( !v3 || sub_252D9E8(v2, &byte_6FF1E18) )
  {
    v4 = 0;
    goto LABEL_37;
  }
  if ( !byte_6FF1D90 )
    goto LABEL_33;
  if ( (v73 & 1) != 0 )
    v5 = *((_QWORD *)&v73 + 1);
  else
    v5 = (unsigned __int64)(unsigned __int8)v73 >> 1;
  v6 = (unsigned __int64)(unsigned __int8)xmmword_6FF22B0 >> 1;
  if ( (xmmword_6FF22B0 & 1) != 0 )
    v6 = *((_QWORD *)&xmmword_6FF22B0 + 1);
  if ( v5 == v6 )
  {
    v7 = (unsigned __int8 *)&v73 + 1;
    if ( (v73 & 1) != 0 )
      v8 = v74;
    else
      v8 = (char *)&v73 + 1;
    if ( (xmmword_6FF22B0 & 1) != 0 )
      v9 = (unsigned __int8 *)qword_6FF22C0;
    else
      v9 = (unsigned __int8 *)&xmmword_6FF22B0 + 1;
    if ( (v73 & 1) != 0 )
    {
      if ( !v5 || !memcmp(v8, v9, v5) )
      {
LABEL_33:
        v4 = 0;
        goto LABEL_34;
      }
    }
    else
    {
      if ( !v5 )
        goto LABEL_33;
      v10 = ((unsigned __int64)(unsigned __int8)v73 >> 1) - 1;
      do
      {
        v12 = *v7++;
        v11 = v12;
        v14 = *v9++;
        v13 = v14;
      }
      while ( v11 == v14 && v10-- != 0 );
      if ( v11 == v13 )
        goto LABEL_33;
    }
  }
  v4 = 128;
LABEL_34:
  v75[0] = (__int64)&byte_6FF1E18;
  v16 = sub_25B1368(v2, &byte_6FF1E18, &unk_16B5869, v75, &v71) + 40;
  if ( (*(_BYTE *)v16 & 1) != 0 )
    sub_65ECAF4();
  v17 = v73;
  LOWORD(v73) = 0;
  v18 = v74;
  *(_OWORD *)v16 = v17;
  *(_QWORD *)(v16 + 16) = v18;
LABEL_37:
  sub_65B6B3C(1u);
  if ( (v71 & 1) != 0 )
    v19 = *((_QWORD *)&v71 + 1);
  else
    v19 = (unsigned __int64)(unsigned __int8)v71 >> 1;
  if ( !v19 || sub_252D9E8(v2, &byte_6FF1E30) )
    goto LABEL_71;
  if ( byte_6FF1D90 )
  {
    if ( (v71 & 1) != 0 )
      v20 = *((_QWORD *)&v71 + 1);
    else
      v20 = (unsigned __int64)(unsigned __int8)v71 >> 1;
    v21 = (unsigned __int64)(unsigned __int8)xmmword_6FF22C8 >> 1;
    if ( (xmmword_6FF22C8 & 1) != 0 )
      v21 = *((_QWORD *)&xmmword_6FF22C8 + 1);
    if ( v20 == v21 )
    {
      v22 = (unsigned __int8 *)&v71 + 1;
      if ( (v71 & 1) != 0 )
        v23 = v72;
      else
        v23 = (char *)&v71 + 1;
      if ( (xmmword_6FF22C8 & 1) != 0 )
        v24 = (unsigned __int8 *)qword_6FF22D8;
      else
        v24 = (unsigned __int8 *)&xmmword_6FF22C8 + 1;
      if ( (v71 & 1) != 0 )
      {
        if ( !v20 || !memcmp(v23, v24, v20) )
          goto LABEL_68;
      }
      else
      {
        if ( !v20 )
          goto LABEL_68;
        v25 = ((unsigned __int64)(unsigned __int8)v71 >> 1) - 1;
        do
        {
          v27 = *v22++;
          v26 = v27;
          v29 = *v24++;
          v28 = v29;
        }
        while ( v26 == v29 && v25-- != 0 );
        if ( v26 == v28 )
          goto LABEL_68;
      }
    }
    v4 |= 1u;
  }
LABEL_68:
  v75[0] = (__int64)&byte_6FF1E30;
  v31 = sub_25B1368(v2, &byte_6FF1E30, &unk_16B5869, v75, &v69) + 40;
  if ( (*(_BYTE *)v31 & 1) != 0 )
    sub_65ECAF4();
  v32 = v71;
  LOWORD(v71) = 0;
  v33 = v72;
  *(_OWORD *)v31 = v32;
  *(_QWORD *)(v31 + 16) = v33;
LABEL_71:
  sub_65B6B3C(2u);
  if ( (v69 & 1) != 0 )
    v34 = *((_QWORD *)&v69 + 1);
  else
    v34 = (unsigned __int64)(unsigned __int8)v69 >> 1;
  if ( !v34 || sub_252D9E8(v2, &byte_6FF1E78) )
    goto LABEL_105;
  if ( byte_6FF1D90 )
  {
    if ( (v69 & 1) != 0 )
      v35 = *((_QWORD *)&v69 + 1);
    else
      v35 = (unsigned __int64)(unsigned __int8)v69 >> 1;
    v36 = (unsigned __int64)(unsigned __int8)xmmword_6FF22E0 >> 1;
    if ( (xmmword_6FF22E0 & 1) != 0 )
      v36 = *((_QWORD *)&xmmword_6FF22E0 + 1);
    if ( v35 == v36 )
    {
      v37 = (unsigned __int8 *)&v69 + 1;
      if ( (v69 & 1) != 0 )
        v38 = v70;
      else
        v38 = (char *)&v69 + 1;
      if ( (xmmword_6FF22E0 & 1) != 0 )
        v39 = (unsigned __int8 *)qword_6FF22F0;
      else
        v39 = (unsigned __int8 *)&xmmword_6FF22E0 + 1;
      if ( (v69 & 1) != 0 )
      {
        if ( !v35 || !memcmp(v38, v39, v35) )
          goto LABEL_102;
      }
      else
      {
        if ( !v35 )
          goto LABEL_102;
        v40 = ((unsigned __int64)(unsigned __int8)v69 >> 1) - 1;
        do
        {
          v42 = *v37++;
          v41 = v42;
          v44 = *v39++;
          v43 = v44;
        }
        while ( v41 == v44 && v40-- != 0 );
        if ( v41 == v43 )
          goto LABEL_102;
      }
    }
    v4 |= 2u;
  }
LABEL_102:
  v75[0] = (__int64)&byte_6FF1E78;
  v46 = sub_25B1368(v2, &byte_6FF1E78, &unk_16B5869, v75, &v67) + 40;
  if ( (*(_BYTE *)v46 & 1) != 0 )
    sub_65ECAF4();
  v47 = v69;
  LOWORD(v69) = 0;
  v48 = v70;
  *(_OWORD *)v46 = v47;
  *(_QWORD *)(v46 + 16) = v48;
LABEL_105:
  result = sub_65B6B3C(8u);
  if ( (v67 & 1) != 0 )
    v50 = *((_QWORD *)&v67 + 1);
  else
    v50 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  if ( !v50 || (result = sub_252D9E8(v2, &byte_6FF1F08)) != 0 )
  {
    if ( !byte_6FF1D90 )
      goto LABEL_152;
LABEL_111:
    v52 = *(unsigned __int8 *)(a1 + 16);
    v51 = a1 + 16;
    v53 = (v52 & 1) == 0;
    v54 = (unsigned __int64)v52 >> 1;
    if ( (v52 & 1) != 0 )
      v55 = *(_QWORD *)(v51 + 8);
    else
      v55 = v54;
    if ( v53 )
      v56 = (__int64 *)(v51 + 1);
    else
      v56 = *(__int64 **)(v51 + 16);
    sub_658F364(v75, v56, v55);
    sub_6291E98((unsigned __int8 *)v75, v66);
    if ( (v79 & 1) != 0 )
    {
      sub_65ECAF4();
      if ( (v78 & 1) == 0 )
      {
LABEL_119:
        if ( (v77 & 1) == 0 )
          goto LABEL_120;
        goto LABEL_134;
      }
    }
    else if ( (v78 & 1) == 0 )
    {
      goto LABEL_119;
    }
    sub_65ECAF4();
    if ( (v77 & 1) == 0 )
    {
LABEL_120:
      if ( (v76 & 1) == 0 )
        goto LABEL_121;
      goto LABEL_135;
    }
LABEL_134:
    sub_65ECAF4();
    if ( (v76 & 1) == 0 )
    {
LABEL_121:
      if ( (v75[0] & 1) == 0 )
      {
LABEL_123:
        BYTE5(v75[0]) = 0;
        v57 = v66[1];
        if ( (v66[0] & 1) == 0 )
          v57 = (unsigned __int64)LOBYTE(v66[0]) >> 1;
        if ( v57 )
          v58 = v66;
        else
          v58 = (unsigned __int64 *)v51;
        LOBYTE(v75[0]) = 8;
        *(_DWORD *)((char *)v75 + 1) = 1886680136;
        result = sub_6292830(v58, v4, v75);
        if ( (v75[0] & 1) != 0 )
          result = sub_65ECAF4();
        if ( (v66[0] & 1) != 0 )
          result = sub_65ECAF4();
        goto LABEL_152;
      }
LABEL_122:
      sub_65ECAF4();
      goto LABEL_123;
    }
LABEL_135:
    sub_65ECAF4();
    if ( (v75[0] & 1) == 0 )
      goto LABEL_123;
    goto LABEL_122;
  }
  if ( (v67 & 1) != 0 )
    v59 = v68;
  else
    v59 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v60 = *((_QWORD *)&v67 + 1);
  else
    v60 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  v61 = sub_65F71D0(v59, v60, 10LL, v75);
  if ( byte_6FF1D90 )
  {
    v62 = (v61 & (v75[0] == SLODWORD(v75[0]))) != 0 ? LODWORD(v75[0]) : 0;
    if ( (v61 & (v75[0] == SLODWORD(v75[0])) & (v62 == dword_6FF2388)) == 0 )
      v4 |= 0x100u;
  }
  v75[0] = (__int64)&byte_6FF1F08;
  result = sub_25B1368(v2, &byte_6FF1F08, &unk_16B5869, v75, v66);
  v63 = result + 40;
  if ( (*(_BYTE *)(result + 40) & 1) != 0 )
    result = sub_65ECAF4();
  v64 = v67;
  LOWORD(v67) = 0;
  v65 = v68;
  *(_OWORD *)v63 = v64;
  *(_QWORD *)(v63 + 16) = v65;
  if ( byte_6FF1D90 )
    goto LABEL_111;
LABEL_152:
  if ( (v67 & 1) != 0 )
  {
    result = sub_65ECAF4();
    if ( (v69 & 1) == 0 )
    {
LABEL_154:
      if ( (v71 & 1) == 0 )
        goto LABEL_155;
      goto LABEL_160;
    }
  }
  else if ( (v69 & 1) == 0 )
  {
    goto LABEL_154;
  }
  result = sub_65ECAF4();
  if ( (v71 & 1) == 0 )
  {
LABEL_155:
    if ( (v73 & 1) == 0 )
      return result;
    return sub_65ECAF4();
  }
LABEL_160:
  result = sub_65ECAF4();
  if ( (v73 & 1) == 0 )
    return result;
  return sub_65ECAF4();
}


================================================================================
Function: sub_628DEB4 (0x628DEB4)
================================================================================

__int64 __fastcall sub_628DEB4(int a1, int a2, int a3, int a4, char a5)
{
  __int64 result; // x0
  _QWORD v6[3]; // [xsp+8h] [xbp-38h] BYREF
  char v7; // [xsp+20h] [xbp-20h] BYREF
  int v8; // [xsp+21h] [xbp-1Fh]

  v7 = 6;
  v8 = 5522759;
  memset(v6, 0, sizeof(v6));
  result = sub_628C1E4(a1, (int)&v7, 0, (int)v6, 0, a2, a3, a4, a5);
  if ( (v6[0] & 1) != 0 )
    result = sub_65ECAF4();
  if ( (v7 & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_6291E98 (0x6291E98)
================================================================================

__int64 __usercall sub_6291E98@<X0>(unsigned __int8 *a1@<X0>, unsigned __int64 *a2@<X8>)
{
  __int64 result; // x0
  unsigned __int8 *v5; // x21
  unsigned __int8 *v6; // x26
  char v7; // w27
  char v8; // w24
  int v9; // w24
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x1
  unsigned __int8 *v12; // x23
  unsigned __int8 *j; // x26
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x8
  bool v16; // zf
  size_t v17; // x8
  void *v18; // x1
  size_t v19; // x2
  unsigned __int8 *v20; // x23
  char *v21; // x1
  size_t v22; // x2
  unsigned __int64 v23; // x8
  bool v24; // zf
  size_t v25; // x8
  unsigned __int64 v26; // x12
  size_t v27; // x1
  void *v28; // x0
  size_t v29; // x3
  void *v30; // x2
  char *v31; // x4
  size_t v32; // x5
  unsigned __int64 v33; // x10
  bool v34; // zf
  unsigned __int64 v35; // x12
  const void *v36; // x6
  size_t v37; // x9
  size_t v38; // x10
  size_t v39; // x7
  void *v40; // x9
  unsigned __int64 v41; // x8
  bool v42; // zf
  size_t v43; // x8
  unsigned __int64 v44; // x11
  size_t v45; // x1
  void *v46; // x0
  size_t v47; // x3
  void *v48; // x2
  unsigned __int64 v49; // x12
  char *v50; // x4
  size_t v51; // x5
  size_t v52; // x7
  char *v53; // x6
  void *v54; // x9
  size_t v55; // x10
  unsigned __int64 v56; // x8
  bool v57; // zf
  size_t v58; // x8
  unsigned __int64 v59; // x11
  unsigned __int64 v60; // x9
  bool v61; // zf
  size_t v62; // x9
  unsigned __int64 v63; // x12
  unsigned __int8 *v64; // x19
  unsigned __int8 *v65; // x20
  unsigned __int8 *v66; // x21
  unsigned __int8 *v67; // x21
  unsigned __int8 *v68; // x27
  char v69; // w26
  char v70; // w24
  unsigned __int8 *v71; // x21
  unsigned __int8 *v72; // x27
  char v73; // w24
  unsigned __int8 *v74; // x21
  unsigned __int8 *i; // x27
  char v76; // w24
  unsigned __int64 v77; // [xsp+10h] [xbp-D0h] BYREF
  unsigned __int64 v78; // [xsp+18h] [xbp-C8h]
  char *v79; // [xsp+20h] [xbp-C0h]
  unsigned __int8 *v80; // [xsp+28h] [xbp-B8h] BYREF
  unsigned __int8 *v81; // [xsp+30h] [xbp-B0h]
  __int64 v82; // [xsp+40h] [xbp-A0h] BYREF
  size_t v83; // [xsp+48h] [xbp-98h]
  char *v84; // [xsp+50h] [xbp-90h]
  __int64 v85[3]; // [xsp+58h] [xbp-88h] BYREF
  char v86; // [xsp+70h] [xbp-70h]
  char v87; // [xsp+88h] [xbp-58h]
  char v88; // [xsp+A0h] [xbp-40h]
  char v89; // [xsp+B8h] [xbp-28h]

  result = sub_65906C0(a1);
  if ( (result & 1) == 0 || (sub_6590C18((int)a1) & 1) == 0 && (result = sub_6590CCC((int)a1), (result & 1) == 0) )
  {
    *(_WORD *)a2 = 0;
    return result;
  }
  v82 = 0LL;
  v83 = 0LL;
  v84 = 0LL;
  sub_6591A70(&v80, a1);
  if ( (sub_6590DA0(a1, "rbxcdn.com") & 1) == 0
    && (sub_6590DA0(a1, "rbxcdn.qq.com") & 1) == 0
    && (!byte_724A7A8 || !byte_6FF1C38 || (sub_6590DA0(a1, "roblox.cn") & 1) == 0) )
  {
    result = sub_6590DA0(a1, "c.robloxdev.cn");
    if ( (result & 1) == 0 )
    {
      v67 = v80;
      v68 = v81;
      if ( v80 == v81 )
      {
        v77 = 0LL;
        v78 = 0LL;
        v79 = 0LL;
      }
      else
      {
        v69 = 0;
        do
        {
          sub_683B7A0(v85);
          v70 = sub_463F040(v67, &byte_6FF2450, v85);
          result = sub_683B844(v85);
          if ( (v70 & 1) != 0 )
          {
            result = sub_684A29C((int)v67 + 24, "<REDACTED>");
            v69 = 1;
          }
          v67 += 48;
        }
        while ( v67 != v68 );
        v71 = v80;
        v72 = v81;
        if ( v80 != v81 )
        {
          do
          {
            sub_683B7A0(v85);
            v73 = sub_463F040(v71, &byte_6FF2468, v85);
            result = sub_683B844(v85);
            if ( (v73 & 1) != 0 )
            {
              result = sub_684A29C((int)v71 + 24, "<REDACTED>");
              v69 = 1;
            }
            v71 += 48;
          }
          while ( v71 != v72 );
          v74 = v80;
          for ( i = v81; v74 != i; v74 += 48 )
          {
            sub_683B7A0(v85);
            v76 = sub_463F040(v74, &byte_6FF2480, v85);
            result = sub_683B844(v85);
            if ( (v76 & 1) != 0 )
            {
              result = sub_684A29C((int)v74 + 24, "<REDACTED>");
              v69 = 1;
            }
          }
        }
        v77 = 0LL;
        v78 = 0LL;
        v79 = 0LL;
        if ( (v69 & 1) != 0 )
        {
          v9 = 0;
          goto LABEL_18;
        }
      }
      *(_WORD *)a2 = 0;
      if ( (v77 & 1) != 0 )
        goto LABEL_146;
LABEL_133:
      v64 = v80;
      if ( v80 )
        goto LABEL_134;
LABEL_147:
      if ( (v82 & 1) == 0 )
        return result;
      return sub_65ECAF4();
    }
  }
  sub_684A29C((int)&v82, "<REDACTED>");
  v5 = v80;
  v6 = v81;
  if ( v80 == v81 )
  {
    v77 = 0LL;
    v78 = 0LL;
    v79 = 0LL;
LABEL_44:
    v23 = *a1;
    v24 = (v23 & 1) == 0;
    v25 = v23 >> 1;
    v26 = a1[24];
    if ( v24 )
      v27 = v25;
    else
      v27 = *((_QWORD *)a1 + 1);
    if ( v24 )
      v28 = a1 + 1;
    else
      v28 = (void *)*((_QWORD *)a1 + 2);
    if ( (v26 & 1) != 0 )
      v29 = *((_QWORD *)a1 + 4);
    else
      v29 = v26 >> 1;
    if ( (v26 & 1) != 0 )
      v30 = (void *)*((_QWORD *)a1 + 5);
    else
      v30 = a1 + 25;
    if ( (v82 & 1) != 0 )
      v31 = v84;
    else
      v31 = (char *)&v82 + 1;
    if ( (v82 & 1) != 0 )
      v32 = v83;
    else
      v32 = (unsigned __int64)(unsigned __int8)v82 >> 1;
    v33 = a1[72];
    v34 = (v33 & 1) == 0;
    v35 = a1[96];
    if ( (v33 & 1) != 0 )
      v36 = (const void *)*((_QWORD *)a1 + 11);
    else
      v36 = a1 + 73;
    v37 = v33 >> 1;
    v38 = *((_QWORD *)a1 + 13);
    if ( v34 )
      v39 = v37;
    else
      v39 = *((_QWORD *)a1 + 10);
    v40 = a1 + 97;
    if ( (v35 & 1) != 0 )
      v40 = (void *)*((_QWORD *)a1 + 14);
    else
      v38 = v35 >> 1;
    sub_658FEF4(v85, v28, v27, v30, v31, v29, v32, v36, v39, v40, v38);
    result = (__int64)sub_659046C((unsigned __int8 *)v85, a2);
    goto LABEL_127;
  }
  v7 = 0;
  do
  {
    sub_683B7A0(v85);
    v8 = sub_6292650(v5, "Expires", v85);
    sub_683B844(v85);
    if ( (v8 & 1) == 0 )
    {
      sub_684A29C((_DWORD)v5 + 24, "<REDACTED>");
      v7 = 1;
    }
    v5 += 48;
  }
  while ( v5 != v6 );
  v77 = 0LL;
  v78 = 0LL;
  v79 = 0LL;
  if ( (v7 & 1) == 0 )
    goto LABEL_44;
  v9 = 1;
LABEL_18:
  v10 = a1[72];
  if ( (v10 & 1) != 0 )
    v11 = *((_QWORD *)a1 + 10);
  else
    v11 = v10 >> 1;
  sub_6601820(&v77, v11);
  v12 = v80;
  for ( j = v81; v12 != j; v12 = v20 + 24 )
  {
    if ( (v77 & 1) != 0 )
      v14 = v78;
    else
      v14 = (unsigned __int64)(unsigned __int8)v77 >> 1;
    if ( v14 )
      sub_684A544(&v77, "&");
    v15 = *v12;
    v16 = (v15 & 1) == 0;
    v17 = v15 >> 1;
    if ( v16 )
      v18 = v12 + 1;
    else
      v18 = (void *)*((_QWORD *)v12 + 2);
    if ( v16 )
      v19 = v17;
    else
      v19 = *((_QWORD *)v12 + 1);
    sub_65FFB9C(&v77, v18, v19);
    v20 = v12 + 24;
    sub_684B0A8("=", v20);
    if ( (v85[0] & 1) != 0 )
      v21 = (char *)v85[2];
    else
      v21 = (char *)v85 + 1;
    if ( (v85[0] & 1) != 0 )
      v22 = v85[1];
    else
      v22 = (unsigned __int64)LOBYTE(v85[0]) >> 1;
    sub_65FFB9C(&v77, v21, v22);
    if ( (v85[0] & 1) != 0 )
      sub_65ECAF4();
  }
  if ( v9 )
  {
    v41 = *a1;
    v42 = (v41 & 1) == 0;
    v43 = v41 >> 1;
    v44 = a1[24];
    if ( v42 )
      v45 = v43;
    else
      v45 = *((_QWORD *)a1 + 1);
    if ( v42 )
      v46 = a1 + 1;
    else
      v46 = (void *)*((_QWORD *)a1 + 2);
    if ( (v44 & 1) != 0 )
      v47 = *((_QWORD *)a1 + 4);
    else
      v47 = v44 >> 1;
    if ( (v44 & 1) != 0 )
      v48 = (void *)*((_QWORD *)a1 + 5);
    else
      v48 = a1 + 25;
    v49 = a1[96];
    if ( (v82 & 1) != 0 )
      v50 = v84;
    else
      v50 = (char *)&v82 + 1;
    if ( (v82 & 1) != 0 )
      v51 = v83;
    else
      v51 = (unsigned __int64)(unsigned __int8)v82 >> 1;
    if ( (v77 & 1) != 0 )
      v52 = v78;
    else
      v52 = (unsigned __int64)(unsigned __int8)v77 >> 1;
    if ( (v77 & 1) != 0 )
      v53 = v79;
    else
      v53 = (char *)&v77 + 1;
    v55 = *((_QWORD *)a1 + 13);
    v54 = (void *)*((_QWORD *)a1 + 14);
    if ( (v49 & 1) == 0 )
    {
      v55 = v49 >> 1;
      v54 = a1 + 97;
    }
  }
  else
  {
    v56 = *a1;
    v57 = (v56 & 1) == 0;
    v58 = v56 >> 1;
    v59 = a1[24];
    if ( v57 )
      v45 = v58;
    else
      v45 = *((_QWORD *)a1 + 1);
    if ( v57 )
      v46 = a1 + 1;
    else
      v46 = (void *)*((_QWORD *)a1 + 2);
    v60 = a1[48];
    if ( (v59 & 1) != 0 )
      v47 = *((_QWORD *)a1 + 4);
    else
      v47 = v59 >> 1;
    if ( (v59 & 1) != 0 )
      v48 = (void *)*((_QWORD *)a1 + 5);
    else
      v48 = a1 + 25;
    v61 = (v60 & 1) == 0;
    v62 = v60 >> 1;
    v63 = a1[96];
    if ( v61 )
      v51 = v62;
    else
      v51 = *((_QWORD *)a1 + 7);
    if ( v61 )
      v50 = (char *)(a1 + 49);
    else
      v50 = (char *)*((_QWORD *)a1 + 8);
    if ( (v77 & 1) != 0 )
      v52 = v78;
    else
      v52 = (unsigned __int64)(unsigned __int8)v77 >> 1;
    if ( (v77 & 1) != 0 )
      v53 = v79;
    else
      v53 = (char *)&v77 + 1;
    v55 = *((_QWORD *)a1 + 13);
    v54 = (void *)*((_QWORD *)a1 + 14);
    if ( (v63 & 1) == 0 )
    {
      v55 = v63 >> 1;
      v54 = a1 + 97;
    }
  }
  sub_658FEF4(v85, v46, v45, v48, v50, v47, v51, v53, v52, v54, v55);
  result = (__int64)sub_659046C((unsigned __int8 *)v85, a2);
LABEL_127:
  if ( (v89 & 1) != 0 )
  {
    result = sub_65ECAF4();
    if ( (v88 & 1) == 0 )
    {
LABEL_129:
      if ( (v87 & 1) == 0 )
        goto LABEL_130;
      goto LABEL_143;
    }
  }
  else if ( (v88 & 1) == 0 )
  {
    goto LABEL_129;
  }
  result = sub_65ECAF4();
  if ( (v87 & 1) == 0 )
  {
LABEL_130:
    if ( (v86 & 1) == 0 )
      goto LABEL_131;
    goto LABEL_144;
  }
LABEL_143:
  result = sub_65ECAF4();
  if ( (v86 & 1) == 0 )
  {
LABEL_131:
    if ( (v85[0] & 1) == 0 )
      goto LABEL_132;
    goto LABEL_145;
  }
LABEL_144:
  result = sub_65ECAF4();
  if ( (v85[0] & 1) != 0 )
  {
LABEL_145:
    result = sub_65ECAF4();
    if ( (v77 & 1) != 0 )
      goto LABEL_146;
    goto LABEL_133;
  }
LABEL_132:
  if ( (v77 & 1) == 0 )
    goto LABEL_133;
LABEL_146:
  result = sub_65ECAF4();
  v64 = v80;
  if ( !v80 )
    goto LABEL_147;
LABEL_134:
  v65 = v81;
  if ( v81 != v64 )
  {
    do
    {
      if ( (*(v65 - 24) & 1) != 0 )
        sub_65ECAF4();
      v66 = v65 - 48;
      if ( (*(v65 - 48) & 1) != 0 )
        sub_65ECAF4();
      v65 -= 48;
    }
    while ( v66 != v64 );
  }
  v81 = v64;
  result = sub_65ECAF4();
  if ( (v82 & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_6292650 (0x6292650)
================================================================================

bool __fastcall sub_6292650(unsigned __int8 *a1, const char *a2, __int64 *a3)
{
  unsigned __int64 v5; // x8
  bool v6; // zf
  unsigned __int64 v7; // x8
  unsigned __int8 *v8; // x27
  unsigned __int64 v9; // x26
  size_t v10; // x0
  __int64 v11; // x2
  size_t v12; // x20
  size_t v13; // x25
  unsigned __int64 v14; // x24
  const char *v15; // x28
  unsigned int v16; // w22
  __int64 *v17; // x0
  unsigned int v18; // w23
  __int64 v19; // x2
  __int64 *v20; // x0
  size_t v21; // x9
  _BOOL4 v22; // w19
  unsigned __int8 *v24; // [xsp+8h] [xbp-18h]
  __int64 v25; // [xsp+10h] [xbp-10h] BYREF

  sub_683B82C(&v25, a3);
  v5 = *a1;
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
    v8 = a1 + 1;
  else
    v8 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( v6 )
    v9 = v7;
  else
    v9 = *((_QWORD *)a1 + 1);
  v10 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
  v12 = v10;
  v24 = v8;
  if ( v9 && v10 )
  {
    v13 = v10 - 1;
    v14 = v9 - 1;
    v15 = a2;
    while ( 1 )
    {
      v16 = *v8;
      v17 = sub_683BBD0(&v25, (__int64)&qword_79D7E58, v11);
      LOBYTE(v16) = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*v17 + 24))(v17, v16);
      v18 = *(unsigned __int8 *)v15;
      v20 = sub_683BBD0(&v25, (__int64)&qword_79D7E58, v19);
      if ( (unsigned __int8)v16 != (*(unsigned __int8 (__fastcall **)(__int64 *, _QWORD))(*v20 + 24))(v20, v18) )
        break;
      ++v8;
      ++v15;
      if ( v14 )
      {
        v21 = v13;
        --v14;
        --v13;
        if ( v21 )
          continue;
      }
      goto LABEL_15;
    }
    v22 = 0;
  }
  else
  {
    v15 = a2;
LABEL_15:
    v22 = v15 == &a2[v12] && v8 == &v24[v9];
  }
  sub_683B844(&v25);
  return v22;
}


================================================================================
Function: sub_6292830 (0x6292830)
================================================================================

__int64 __fastcall sub_6292830(__int64 result, int a2, __int64 a3)
{
  __int64 v5; // x21
  _QWORD v6[3]; // [xsp+8h] [xbp-1F8h] BYREF
  _BYTE v7[472]; // [xsp+20h] [xbp-1E0h] BYREF

  if ( a2 )
  {
    v5 = result;
    result = sub_65F1790();
    if ( (unsigned int)result % 0x2710 < dword_6FF1D78 )
    {
      sub_648BE34((__int64)v7, -1, 0);
      if ( (a2 & 1) != 0 )
      {
        sub_65B6B3C(1u);
        sub_6490538((__int64)v7, (__int64)"PlaceIdFromContextInfo", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_65ECAF4();
        sub_6490538((__int64)v7, (__int64)"PlaceIdFromHttp", (__int64)&xmmword_6FF22C8);
      }
      if ( (a2 & 2) != 0 )
      {
        sub_65B6B3C(2u);
        sub_6490538((__int64)v7, (__int64)"UniverseIdFromContextInfo", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_65ECAF4();
        sub_6490538((__int64)v7, (__int64)"UniverseIdFromHttp", (__int64)&xmmword_6FF22E0);
      }
      if ( (a2 & 0x80) != 0 )
      {
        sub_65B6B3C(5u);
        sub_6490538((__int64)v7, (__int64)"GameIdFromContextInfo", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_65ECAF4();
        sub_6490538((__int64)v7, (__int64)"GameIdFromHttp", (__int64)&xmmword_6FF22B0);
      }
      if ( (a2 & 0x100) != 0 )
      {
        sub_65B6B3C(8u);
        sub_6490538((__int64)v7, (__int64)"PlayerCountFromContextInfo", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_65ECAF4();
        sub_65F13AC("%d", v6);
        sub_6490538((__int64)v7, (__int64)"PlayerCountFromHttp", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_65ECAF4();
      }
      sub_65B6BB0(0);
      sub_6490538((__int64)v7, (__int64)"PrimaryContext", (__int64)v6);
      if ( (v6[0] & 1) != 0 )
        sub_65ECAF4();
      sub_65B6B3C(0);
      sub_6490538((__int64)v7, (__int64)"CurrentContext", (__int64)v6);
      if ( (v6[0] & 1) != 0 )
        sub_65ECAF4();
      sub_6490538((__int64)v7, (__int64)"RequestUrl", v5);
      sub_64909C4((__int64)v7, "MismatchedFields", a2);
      sub_6490538((__int64)v7, (__int64)"HttpType", a3);
      strcpy((char *)v6, "&ContextInfoMismatch");
      sub_6491634((__int64)v7, (__int64)v6, 10000, 0);
      if ( (v6[0] & 1) != 0 )
        sub_65ECAF4();
      return sub_256AE00((__int64)v7);
    }
  }
  return result;
}


================================================================================
Function: sub_6293228 (0x6293228)
================================================================================

unsigned __int8 *__fastcall sub_6293228(__int64 a1)
{
  __int64 v2; // x21

  v2 = a1 + 16;
  *(_QWORD *)(a1 + 120) = off_6887558;
  *(_QWORD *)a1 = off_6887530;
  *(_QWORD *)(a1 + 8) = 0LL;
  sub_681F548(a1 + 120, a1 + 16);
  *(_QWORD *)(a1 + 256) = 0LL;
  *(_DWORD *)(a1 + 264) = -1;
  *(_QWORD *)a1 = off_68874C0;
  *(_QWORD *)(a1 + 120) = off_68874E8;
  sub_681C128(v2);
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 8;
  *(_QWORD *)(a1 + 16) = off_6874A98;
  return sub_26D904C(v2);
}


================================================================================
Function: sub_6294738 (0x6294738)
================================================================================

_QWORD *__usercall sub_6294738@<X0>(
        __int64 a1@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        __int64 a4@<X3>,
        _QWORD *a5@<X8>)
{
  bool v10; // zf
  __int64 v11; // x24
  __int64 v12; // x0
  __int64 v13; // x25
  __int64 v14; // x24
  __int64 v15; // x8
  _QWORD *result; // x0
  __int64 v17; // x8
  __int64 v18; // x19
  __int64 v19; // x19
  unsigned __int64 *v20; // x19
  __int64 v21; // [xsp+0h] [xbp-70h] BYREF
  __int64 v22; // [xsp+8h] [xbp-68h]
  __int64 v23; // [xsp+10h] [xbp-60h]
  __int64 v24; // [xsp+18h] [xbp-58h]
  __int64 v25; // [xsp+20h] [xbp-50h]
  __int64 v26; // [xsp+28h] [xbp-48h]
  _QWORD v27[4]; // [xsp+30h] [xbp-40h] BYREF
  _QWORD *v28; // [xsp+50h] [xbp-20h]

  if ( byte_724A7A8 )
    v10 = byte_7301120 == 0;
  else
    v10 = 1;
  if ( v10 )
  {
    v12 = sub_65ECAAC();
    v13 = v12;
    *(_QWORD *)(v12 + 8) = 0LL;
    *(_QWORD *)(v12 + 16) = 0LL;
    *(_QWORD *)(v12 + 32) = 0LL;
    *(_QWORD *)v12 = off_69582E8;
    *(_BYTE *)(v12 + 40) = 0;
    *(_QWORD *)(v12 + 24) = 0LL;
    v14 = v12 + 24;
  }
  else
  {
    v11 = sub_680599C();
    v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v11 + 16LL))(v11, 56LL, 8LL);
    *(_QWORD *)(v12 + 16) = 0LL;
    *(_QWORD *)(v12 + 24) = v11;
    v13 = v12;
    *(_QWORD *)(v12 + 40) = 0LL;
    *(_BYTE *)(v12 + 48) = 0;
    *(_QWORD *)v12 = off_6958198;
    *(_QWORD *)(v12 + 8) = 0LL;
    *(_QWORD *)(v12 + 32) = 0LL;
    v14 = v12 + 32;
  }
  v25 = v14;
  v26 = v12;
  sub_6867420(1uLL, (atomic_ullong *)(v13 + 8));
  v23 = 0LL;
  v24 = 0LL;
  v27[2] = v13;
  v28 = v27;
  v27[0] = off_6C1CB88;
  v27[1] = v14;
  sub_6294A00(a1, a2, a3, v27, a4);
  if ( v27 == v28 )
  {
    v15 = 4LL;
    goto LABEL_11;
  }
  if ( v28 )
  {
    v15 = 5LL;
LABEL_11:
    (*(void (**)(void))(*v28 + 8 * v15))();
  }
  result = sub_3C21D84(&v21, v14);
  v17 = v22;
  *a5 = v21;
  a5[1] = v17;
  if ( v17 )
  {
    result = (_QWORD *)sub_6867390(1u, (atomic_uint *)(v17 + 8));
    v18 = v22;
    v21 = 0LL;
    v22 = 0LL;
    if ( v18 )
    {
      result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v18 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 16LL))(v18);
        result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v18 + 12));
        if ( (_DWORD)result == 1 )
          result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 24LL))(v18);
      }
      v19 = v22;
      if ( v22 )
      {
        result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v22 + 8));
        if ( (_DWORD)result == 1 )
        {
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16LL))(v19);
          result = (_QWORD *)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v19 + 12));
          if ( (_DWORD)result == 1 )
            result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 24LL))(v19);
        }
      }
    }
  }
  v20 = (unsigned __int64 *)v26;
  if ( v26 )
  {
    result = (_QWORD *)sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v26 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v20 + 16))(v20);
      return (_QWORD *)sub_68488BC(v20);
    }
  }
  return result;
}


================================================================================
Function: sub_6294A00 (0x6294A00)
================================================================================

__int64 __fastcall sub_6294A00(__int64 a1, __int64 a2, __int128 *a3, __int64 a4, __int64 a5)
{
  __int64 v9; // x1
  int v10; // w8
  __int64 v11; // x25
  __int64 v12; // x26
  __int64 v13; // x0
  __int64 v14; // x8
  unsigned __int64 *v15; // x19
  unsigned __int64 *v16; // x19
  __int64 **v17; // x19
  __int64 result; // x0
  __int64 *v19; // x20
  unsigned __int64 v20[3]; // [xsp+10h] [xbp-E0h] BYREF
  __int64 v21; // [xsp+28h] [xbp-C8h] BYREF
  __int64 v22; // [xsp+30h] [xbp-C0h]
  __int64 v23; // [xsp+38h] [xbp-B8h]
  __int64 v24; // [xsp+40h] [xbp-B0h]
  _DWORD v25[4]; // [xsp+48h] [xbp-A8h] BYREF
  char v26; // [xsp+58h] [xbp-98h]
  _QWORD v27[2]; // [xsp+70h] [xbp-80h] BYREF
  __int64 **v28; // [xsp+80h] [xbp-70h]
  int v29; // [xsp+90h] [xbp-60h]
  char v30; // [xsp+98h] [xbp-58h]
  _BYTE v31[32]; // [xsp+B0h] [xbp-40h] BYREF
  _BYTE *v32; // [xsp+D0h] [xbp-20h]

  sub_628BB58((int)v25, a2);
  if ( v27 != (_QWORD *)a5 )
  {
    v9 = *(_QWORD *)(a5 + 16);
    v29 = *(_DWORD *)(a5 + 32);
    sub_3C12CF0(v27, v9, 0LL);
  }
  v10 = *(_DWORD *)(a5 + 40);
  v23 = 0LL;
  v24 = 0LL;
  v25[0] = v10;
  if ( a3 )
  {
    v12 = *(_QWORD *)a3;
    v11 = *((_QWORD *)a3 + 1);
    if ( v11 )
    {
      sub_6867420(1uLL, (atomic_ullong *)(v11 + 8));
      v23 = v12;
      v24 = v11;
    }
    else
    {
      v23 = *(_QWORD *)a3;
      v24 = 0LL;
    }
  }
  v21 = v23;
  v22 = v24;
  if ( v24 )
    sub_6867420(1uLL, (atomic_ullong *)(v24 + 8));
  if ( a3 )
  {
    sub_68497A0(v20, a3 + 1);
    LODWORD(a3) = *((_BYTE *)a3 + 40) != 0;
    v13 = *(_QWORD *)(a4 + 32);
    if ( !v13 )
      goto LABEL_15;
  }
  else
  {
    memset(v20, 0, sizeof(v20));
    v13 = *(_QWORD *)(a4 + 32);
    if ( !v13 )
    {
LABEL_15:
      v32 = (_BYTE *)v13;
      goto LABEL_17;
    }
  }
  if ( a4 != v13 )
  {
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 16LL))(v13);
    goto LABEL_15;
  }
  v32 = v31;
  (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v13 + 24LL))(v13, v31);
LABEL_17:
  sub_628C5F0(v25, a1, &v21, v20, (unsigned int)a3, v31, *(unsigned __int8 *)(a5 + 48), 0LL, 1);
  if ( v31 == v32 )
  {
    v14 = 4LL;
  }
  else
  {
    if ( !v32 )
      goto LABEL_22;
    v14 = 5LL;
  }
  (*(void (**)(void))(*(_QWORD *)v32 + 8 * v14))();
LABEL_22:
  if ( (v20[0] & 1) != 0 )
    sub_65ECAF4();
  v15 = (unsigned __int64 *)v22;
  if ( v22 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v22 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v15 + 16))(v15);
    sub_68488BC(v15);
  }
  v16 = (unsigned __int64 *)v24;
  if ( !v24 || sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8)) )
  {
    if ( (v30 & 1) == 0 )
      goto LABEL_31;
    goto LABEL_30;
  }
  (*(void (__fastcall **)(unsigned __int64 *))(*v16 + 16))(v16);
  sub_68488BC(v16);
  if ( (v30 & 1) != 0 )
LABEL_30:
    sub_65ECAF4();
LABEL_31:
  v17 = v28;
  if ( v28 )
  {
    do
    {
      v19 = *v17;
      if ( ((_BYTE)v17[5] & 1) != 0 )
        sub_65ECAF4();
      if ( ((_BYTE)v17[2] & 1) != 0 )
        sub_65ECAF4();
      sub_65ECAF4();
      v17 = (__int64 **)v19;
    }
    while ( v19 );
  }
  result = v27[0];
  v27[0] = 0LL;
  if ( result )
    result = sub_65ECAF4();
  if ( (v26 & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_6294D48 (0x6294D48)
================================================================================

__int64 __fastcall sub_6294D48(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // x0
  char v4; // [xsp+0h] [xbp-20h] BYREF
  char v5[15]; // [xsp+1h] [xbp-1Fh] BYREF

  v4 = 8;
  strcpy(v5, "POST");
  result = sub_6294738(&v4, a1, a2, a3);
  if ( (v4 & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_6295C34 (0x6295C34)
================================================================================

__int64 __fastcall sub_6295C34(__int64 a1, __int64 a2)
{
  unsigned int v4; // w0
  char v5; // w8
  __int64 result; // x0
  __int128 v7; // [xsp+8h] [xbp-58h] BYREF
  unsigned __int64 v8[2]; // [xsp+20h] [xbp-40h] BYREF

  v4 = pthread_mutex_init((pthread_mutex_t *)a1, 0LL);
  if ( v4 )
  {
    sub_25C1BEC(v8, v4, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25C1ABC((__int64)v8);
  }
  LOWORD(v7) = 0;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 40) = a1 + 48;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = a2;
  *(_DWORD *)(a1 + 80) = 0;
  sub_68497A0(v8, &v7);
  v5 = v8[0];
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  if ( (v5 & 1) != 0 )
    sub_65ECAF4();
  *(_QWORD *)(a1 + 112) = 0LL;
  sub_68497A0((unsigned __int64 *)(a1 + 120), &v7);
  if ( (v7 & 1) != 0 )
    sub_65ECAF4();
  result = pthread_mutex_init((pthread_mutex_t *)(a1 + 152), 0LL);
  if ( (_DWORD)result )
  {
    sub_25C1BEC(v8, result, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25C1ABC((__int64)v8);
  }
  return result;
}


================================================================================
Function: sub_6298A44 (0x6298A44)
================================================================================

__int64 __fastcall sub_6298A44(__int64 a1, char a2)
{
  __int64 result; // x0
  __int64 v4; // x8
  __int64 v5; // x10
  __int64 v6; // x19
  __int128 v7; // q0
  __int128 v8; // q1
  int v9; // s2
  int v10; // s3
  pthread_mutex_t *v11; // x19
  __int64 v12; // x22
  __int64 v13; // x20
  pthread_mutex_t *v14[7]; // [xsp+0h] [xbp-80h] BYREF
  pthread_mutex_t *mutex; // [xsp+38h] [xbp-48h] BYREF
  unsigned __int8 v16; // [xsp+40h] [xbp-40h]
  _BYTE v17[8]; // [xsp+48h] [xbp-38h] BYREF
  __int128 v18; // [xsp+50h] [xbp-30h]
  int v19; // [xsp+60h] [xbp-20h]
  __int64 v20; // [xsp+68h] [xbp-18h]
  __int64 v21; // [xsp+70h] [xbp-10h]

  v17[0] = 0;
  v18 = xmmword_AFE5E0;
  v19 = 1065353216;
  v20 = 0LL;
  v21 = 0LL;
  if ( (a2 & 1) != 0 )
    sub_6298BE8(v17, 512LL);
  v16 = 0;
  mutex = (pthread_mutex_t *)(a1 + 64);
  result = sub_25C6ADC((__int64)&mutex);
  v4 = v21;
  v5 = *(_QWORD *)(a1 + 48);
  v6 = *(_QWORD *)(a1 + 56);
  v7 = v18;
  v8 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 48) = v20;
  *(_QWORD *)(a1 + 56) = v4;
  v9 = *(_DWORD *)(a1 + 40);
  v10 = v19;
  *(_OWORD *)(a1 + 24) = v7;
  LODWORD(v4) = v16;
  v18 = v8;
  v19 = v9;
  *(_DWORD *)(a1 + 40) = v10;
  v20 = v5;
  v21 = v6;
  if ( (_DWORD)v4 )
  {
    v11 = mutex;
    do
      result = pthread_mutex_unlock(v11);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25C5E54(v14, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24((__int64)v14);
    }
    v6 = v21;
  }
  if ( v6 )
  {
    if ( *((_QWORD *)&v18 + 1) )
    {
      v12 = v18;
      v13 = *(_QWORD *)(v6 + 8 * v18);
      do
      {
        *(_QWORD *)(v6 + 8 * v12) = *(_QWORD *)v13;
        if ( (*(_BYTE *)(v13 + 40) & 1) != 0 )
          sub_65ECAF4();
        if ( (*(_BYTE *)(v13 + 16) & 1) != 0 )
          sub_65ECAF4();
        sub_65ECAF4();
        --*((_QWORD *)&v18 + 1);
        v13 = *(_QWORD *)(v6 + 8 * v12);
      }
      while ( v13 );
    }
    return sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_6298BE8 (0x6298BE8)
================================================================================

__int64 __fastcall sub_6298BE8(__int64 result, unsigned __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 v3; // x8
  double v4; // d0
  unsigned __int64 v5; // x20
  double v6; // d0
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x8
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x8

  v2 = result;
  v3 = *(_QWORD *)(result + 16);
  v4 = *(float *)(result + 24);
  v5 = vcvtpd_u64_f64((double)a2 / v4);
  if ( v3 )
  {
    v6 = (double)v3 / v4;
    v7 = vcvtmd_u64_f64(v6);
    if ( floor(v6) < 1.84467441e19 )
      v8 = v7 + 1;
    else
      v8 = 0LL;
    if ( v8 <= v5 )
      v8 = v5;
    if ( v8 >= 5 )
    {
      v11 = (v8 - 1) | ((v8 - 1) >> 1) | (((v8 - 1) | ((v8 - 1) >> 1)) >> 2);
      v12 = v11 | (v11 >> 4) | ((v11 | (v11 >> 4)) >> 8);
      v9 = (v12 | (v12 >> 16) | ((v12 | (v12 >> 16)) >> 32)) + 1;
    }
    else
    {
      v9 = 4LL;
    }
    if ( v9 != *(_QWORD *)(result + 8) )
      return sub_629DC50(result);
  }
  else
  {
    result = sub_629DBB8(result);
    if ( v5 >= 5 )
    {
      v13 = (v5 - 1) | ((v5 - 1) >> 1) | (((v5 - 1) | ((v5 - 1) >> 1)) >> 2);
      v14 = v13 | (v13 >> 4) | ((v13 | (v13 >> 4)) >> 8);
      v10 = (v14 | (v14 >> 16) | ((v14 | (v14 >> 16)) >> 32)) + 1;
    }
    else
    {
      v10 = 4LL;
    }
    *(_QWORD *)(v2 + 8) = v10;
  }
  return result;
}


================================================================================
Function: sub_629A1A4 (0x629A1A4)
================================================================================

__int64 __fastcall sub_629A1A4(__int64 a1)
{
  unsigned int v2; // w1
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  *(_QWORD *)a1 = "HttpRedirectCache";
  *(_QWORD *)(a1 + 8) = 17LL;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = xmmword_AFE5E0;
  *(_DWORD *)(a1 + 40) = 1065353216;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 64), 0LL);
  if ( v2 )
  {
    sub_25C1BEC(v4, v2, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25C1ABC((__int64)v4);
  }
  return sub_6298A44(a1, 1LL);
}


================================================================================
Function: sub_629DBB8 (0x629DBB8)
================================================================================

_QWORD *__fastcall sub_629DBB8(_QWORD *result)
{
  __int64 v1; // x20
  _QWORD *v2; // x19
  __int64 v3; // x22
  __int64 v4; // x21

  v1 = result[5];
  if ( v1 )
  {
    v2 = result;
    if ( result[2] )
    {
      v3 = result[1];
      v4 = *(_QWORD *)(v1 + 8 * v3);
      do
      {
        *(_QWORD *)(v1 + 8 * v3) = *(_QWORD *)v4;
        if ( (*(_BYTE *)(v4 + 40) & 1) != 0 )
          sub_65ECAF4();
        if ( (*(_BYTE *)(v4 + 16) & 1) != 0 )
          sub_65ECAF4();
        sub_65ECAF4();
        v4 = *(_QWORD *)(v1 + 8 * v3);
        --v2[2];
      }
      while ( v4 );
    }
    result = (_QWORD *)sub_65ECAF4();
    v2[4] = 0LL;
    v2[5] = 0LL;
  }
  return result;
}


================================================================================
Function: sub_629DC50 (0x629DC50)
================================================================================

__int64 __fastcall sub_629DC50(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x22
  _QWORD *v5; // x0
  _QWORD *v6; // x19
  __int64 result; // x0
  float v8; // s0
  _QWORD *v9; // x8
  double v10; // d0
  _QWORD *v11; // x10
  unsigned __int64 v12; // x9
  __int64 v13; // x11
  __int64 v14; // x11

  if ( (a2 + 1) >> 61 )
    sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v2 = 8 * (a2 + 1);
  v5 = (_QWORD *)sub_65ECAAC();
  v6 = v5;
  if ( v2 )
    memset(v5, 0, 8 * a2 + 8);
  result = *(_QWORD *)(a1 + 40);
  if ( result )
  {
    v6[a2] = *(_QWORD *)(result + 8LL * *(_QWORD *)(a1 + 8));
    result = sub_65ECAF4();
  }
  v8 = *(float *)(a1 + 24);
  *(_QWORD *)(a1 + 8) = a2;
  v9 = &v6[a2];
  v10 = (double)a2 * v8;
  v11 = (_QWORD *)*v9;
  v12 = vcvtpd_u64_f64(v10);
  if ( ceil(v10) >= 1.84467441e19 )
    v12 = -1LL;
  *(_QWORD *)(a1 + 32) = v12;
  for ( *(_QWORD *)(a1 + 40) = v6; v11; v11 = (_QWORD *)*v11 )
  {
    while ( 1 )
    {
      v14 = v11[1] & (a2 - 1);
      if ( !v6[v14] )
        break;
      v13 = v14;
      *v9 = *v11;
      *v11 = *(_QWORD *)v6[v13];
      *(_QWORD *)v6[v13] = v11;
      v11 = (_QWORD *)*v9;
      if ( !*v9 )
        return result;
    }
    v6[v14] = v9;
    v9 = v11;
  }
  return result;
}


================================================================================
Function: sub_629F290 (0x629F290)
================================================================================

long double __fastcall sub_629F290(__int64 a1)
{
  __int64 v2; // x20
  unsigned __int8 v3; // w8
  __int64 v4; // x20
  unsigned __int8 v5; // w8
  __int64 v6; // x20
  long double result; // q0
  _BYTE v8[56]; // [xsp+88h] [xbp-48h] BYREF

  *(_QWORD *)a1 = "HttpClient";
  *(_QWORD *)(a1 + 8) = 10LL;
  *(_BYTE *)(a1 + 16) = 0;
  v2 = sub_65ECAAC();
  sub_62BC67C(v2, a1);
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 24) = v2;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 64) = 0LL;
  v3 = atomic_load(byte_6FF34A0);
  if ( (v3 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6FF34A0) )
  {
    qword_6FF3460 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6FF3468);
    qword_6FF3490 = 0LL;
    unk_6FF3498 = 0LL;
    qword_6FF3460 = (__int64)off_6C1CE78;
    qword_6FF34A8 = (__int64)&qword_6FF3460;
    sub_6862850(byte_6FF34A0);
  }
  *(_QWORD *)(a1 + 72) = sub_62B3AD4(&qword_6FF3460);
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_BYTE *)(a1 + 88) = 0;
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 92), 0LL) )
  {
    sub_25C1BEC(v8);
    sub_25C1ABC(v8);
  }
  sub_62F04E0();
  v4 = sub_65ECAAC();
  sub_62EDABC(v4, a1);
  *(_QWORD *)(a1 + 168) = 0LL;
  *(_QWORD *)(a1 + 160) = a1 + 168;
  *(_QWORD *)(a1 + 152) = v4;
  *(_QWORD *)(a1 + 176) = 0LL;
  *(_QWORD *)(a1 + 192) = 0LL;
  *(_QWORD *)(a1 + 184) = a1 + 192;
  *(_QWORD *)(a1 + 200) = 0LL;
  *(_QWORD *)(a1 + 208) = 0LL;
  *(_QWORD *)(a1 + 240) = 0LL;
  *(_QWORD *)(a1 + 232) = a1 + 240;
  *(_QWORD *)(a1 + 216) = 0LL;
  *(_QWORD *)(a1 + 224) = 0LL;
  *(_QWORD *)(a1 + 560) = 0LL;
  *(_QWORD *)(a1 + 568) = 0LL;
  *(_QWORD *)(a1 + 544) = 0LL;
  *(_QWORD *)(a1 + 552) = a1 + 560;
  *(_BYTE *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 248) = 0LL;
  *(_QWORD *)(a1 + 256) = 0LL;
  *(_QWORD *)(a1 + 584) = a1 + 592;
  *(_QWORD *)(a1 + 592) = 0LL;
  *(_QWORD *)(a1 + 264) = 0LL;
  *(_QWORD *)(a1 + 272) = 0LL;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_QWORD *)(a1 + 600) = 0LL;
  *(_QWORD *)(a1 + 608) = a1 + 616;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_QWORD *)(a1 + 632) = a1 + 640;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_DWORD *)(a1 + 576) = 0;
  *(_QWORD *)(a1 + 616) = 0LL;
  *(_QWORD *)(a1 + 624) = 0LL;
  *(_QWORD *)(a1 + 640) = 0LL;
  *(_QWORD *)(a1 + 648) = 0LL;
  *(_BYTE *)(a1 + 760) = 0;
  *(_DWORD *)(a1 + 764) = 0;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_DWORD *)(a1 + 752) = 0;
  v5 = atomic_load(byte_6DE6FF8);
  if ( (v5 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6DE6FF8) )
  {
    qword_6DE6FB8 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6DE6FC0);
    qword_6DE6FE8 = 0LL;
    unk_6DE6FF0 = 0LL;
    qword_6DE6FB8 = (__int64)off_695A468;
    qword_6DE7000 = (__int64)&qword_6DE6FB8;
    sub_6862850(byte_6DE6FF8);
  }
  *(_QWORD *)(a1 + 768) = sub_3C5188C(&qword_6DE6FB8);
  *(_OWORD *)(a1 + 776) = 0u;
  v6 = sub_65ECAAC();
  sub_62D73C0();
  *(_QWORD *)(a1 + 792) = v6;
  *(_BYTE *)(a1 + 800) = 0;
  sub_629F994(a1);
  *(_DWORD *)(a1 + 824) = 0;
  sub_629FAB0(a1 + 832);
  *(_BYTE *)(a1 + 2416) = 0;
  *(_BYTE *)(a1 + 2464) = 0;
  *(_OWORD *)(a1 + 2368) = 0u;
  *(_OWORD *)(a1 + 2384) = 0u;
  *(_OWORD *)(a1 + 2396) = 0u;
  sub_25C1984(a1 + 2480);
  sub_67DE848(a1 + 2568);
  *(_QWORD *)(a1 + 2696) = a1 + 2704;
  *(_QWORD *)(a1 + 2584) = 0LL;
  *(_BYTE *)(a1 + 2592) = 0;
  *(_QWORD *)(a1 + 2712) = 0LL;
  *(_OWORD *)(a1 + 2680) = 0u;
  *(_QWORD *)(a1 + 2704) = 0LL;
  *(_OWORD *)(a1 + 2600) = 0u;
  *(_OWORD *)(a1 + 2616) = 0u;
  *(_OWORD *)(a1 + 2632) = 0u;
  *(_OWORD *)(a1 + 2648) = 0u;
  *(_QWORD *)(a1 + 2664) = 0LL;
  *(_OWORD *)(a1 + 2720) = 0u;
  *(_OWORD *)(a1 + 2736) = 0u;
  *(_OWORD *)(a1 + 2752) = 0u;
  *(_OWORD *)(a1 + 2768) = 0u;
  *(_OWORD *)(a1 + 2784) = 0u;
  *(_OWORD *)(a1 + 2800) = 0u;
  *(_OWORD *)(a1 + 2816) = 0u;
  *(_OWORD *)(a1 + 2832) = 0u;
  *(_OWORD *)(a1 + 2848) = 0u;
  *(_OWORD *)(a1 + 2864) = 0u;
  sub_67DE848(a1 + 2880);
  *(_QWORD *)(a1 + 2928) = 0LL;
  *(_OWORD *)(a1 + 2912) = 0u;
  *(_OWORD *)(a1 + 2896) = 0u;
  sub_62E35C8(a1 + 2936);
  *(_OWORD *)&result = 0uLL;
  *(_BYTE *)(a1 + 3536) = 0;
  *(_WORD *)(a1 + 3584) = 0;
  *(_OWORD *)(a1 + 3432) = 0u;
  *(_OWORD *)(a1 + 3448) = 0u;
  *(_OWORD *)(a1 + 3464) = 0u;
  *(_OWORD *)(a1 + 3473) = 0u;
  *(_OWORD *)(a1 + 3552) = 0u;
  *(_OWORD *)(a1 + 3568) = 0u;
  *(_OWORD *)(a1 + 3592) = 0u;
  *(_OWORD *)(a1 + 3608) = 0u;
  *(_OWORD *)(a1 + 3624) = 0u;
  return result;
}


================================================================================
Function: sub_629F994 (0x629F994)
================================================================================

__int64 __usercall sub_629F994@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  bool v4; // zf
  _QWORD *v5; // x21
  __int64 v6; // x21
  _QWORD *v7; // x22
  __int64 result; // x0

  if ( byte_724A7A8 )
    v4 = byte_7301120 == 0;
  else
    v4 = 1;
  if ( v4 )
  {
    v5 = (_QWORD *)sub_65ECAAC();
    v5[1] = 0LL;
    v5[2] = 0LL;
    *v5 = off_6C1CF18;
    result = sub_6295C34(v5 + 3, a1);
    *a2 = v5 + 3;
    a2[1] = v5;
  }
  else
  {
    v6 = sub_680599C();
    v7 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 16LL))(v6, 224LL, 8LL);
    v7[2] = 0LL;
    v7[3] = v6;
    *v7 = off_6C1CEC8;
    v7[1] = 0LL;
    result = sub_6295C34(v7 + 4, a1);
    *a2 = v7 + 4;
    a2[1] = v7;
  }
  return result;
}


================================================================================
Function: sub_629FAB0 (0x629FAB0)
================================================================================

long double __fastcall sub_629FAB0(__int64 a1)
{
  int v2; // w0
  long double result; // q0
  unsigned int v4; // w20
  __int64 v5; // x19
  _QWORD v6[7]; // [xsp+0h] [xbp-40h] BYREF

  v2 = pthread_mutex_init((pthread_mutex_t *)a1, 0LL);
  if ( v2 )
  {
    v4 = v2;
    v5 = sub_67DDA30();
    sub_684956C((int)v6, "boost:: mutex constructor failed in pthread_mutex_init");
    v6[3] = v5;
    memset(&v6[4], 0, 24);
    v6[2] = v4;
    v6[0] = off_6877FA8;
    sub_25C1ABC((__int64)v6);
  }
  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_DWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = a1 + 48;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_QWORD *)(a1 + 56) = a1 + 48;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 760) = 0u;
  *(_DWORD *)(a1 + 104) = 1065353216;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_DWORD *)(a1 + 152) = 1065353216;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_QWORD *)(a1 + 192) = 0LL;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_DWORD *)(a1 + 200) = 1065353216;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 1112) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 1128) = 0u;
  *(_DWORD *)(a1 + 240) = 1065353216;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 1356) = 0u;
  *(_DWORD *)(a1 + 280) = 1065353216;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_DWORD *)(a1 + 320) = 1065353216;
  *(_DWORD *)(a1 + 360) = 1065353216;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_DWORD *)(a1 + 400) = 1065353216;
  *(_DWORD *)(a1 + 440) = 1065353216;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 480) = 1065353216;
  *(_DWORD *)(a1 + 520) = 1065353216;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_DWORD *)(a1 + 560) = 1065353216;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_DWORD *)(a1 + 792) = 0;
  *(_DWORD *)(a1 + 832) = 1065353216;
  *(_DWORD *)(a1 + 840) = 0;
  *(_WORD *)(a1 + 872) = 0;
  *(_QWORD *)(a1 + 864) = 0LL;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_QWORD *)(a1 + 1056) = 0LL;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(_OWORD *)(a1 + 1008) = 0u;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(_OWORD *)(a1 + 944) = 0u;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 928) = 0u;
  *(_OWORD *)(a1 + 880) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_DWORD *)(a1 + 1064) = 1065353216;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_DWORD *)(a1 + 1104) = 1065353216;
  *(_DWORD *)(a1 + 1144) = 1065353216;
  *(_OWORD *)(a1 + 1392) = 0u;
  *(_OWORD *)(a1 + 1376) = 0u;
  *(_OWORD *)(a1 + 1344) = 0u;
  *(_OWORD *)(a1 + 1328) = 0u;
  *(_OWORD *)(a1 + 1312) = 0u;
  *(_OWORD *)(a1 + 1296) = 0u;
  *(_OWORD *)(a1 + 1280) = 0u;
  *(_OWORD *)(a1 + 1264) = 0u;
  *(_OWORD *)(a1 + 1248) = 0u;
  *(_OWORD *)(a1 + 1232) = 0u;
  *(_OWORD *)(a1 + 1216) = 0u;
  *(_OWORD *)(a1 + 1200) = 0u;
  *(_OWORD *)(a1 + 1184) = 0u;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(_OWORD *)(a1 + 1152) = 0u;
  *(_DWORD *)(a1 + 1408) = 1065353216;
  *(_DWORD *)(a1 + 1416) = 0;
  *(_OWORD *)(a1 + 1464) = 0u;
  *(_OWORD *)(a1 + 1480) = 0u;
  *(_DWORD *)(a1 + 1456) = 0;
  *(_OWORD *)(a1 + 1440) = 0u;
  *(_OWORD *)(a1 + 1424) = 0u;
  *(_DWORD *)(a1 + 1496) = 1065353216;
  *(_BYTE *)(a1 + 1504) = 0;
  *(_QWORD *)(a1 + 1528) = 0LL;
  *(_OWORD *)(a1 + 1512) = 0u;
  return result;
}


================================================================================
Function: sub_62A21C0 (0x62A21C0)
================================================================================

__int64 sub_62A21C0()
{
  unsigned __int8 v0; // w8
  _QWORD *v1; // x0
  __int64 v2; // x19

  v0 = atomic_load(byte_6CB1570);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6CB1570) )
  {
    qword_6CB1530 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6CB1538);
    qword_6CB1560 = 0LL;
    unk_6CB1568 = 0LL;
    qword_6CB1530 = (__int64)off_6871A40;
    qword_6CB1578 = (__int64)&qword_6CB1530;
    sub_6862850(byte_6CB1570);
  }
  v1 = (_QWORD *)sub_2533228((__int64)&qword_6CB1530);
  if ( !v1 )
    return 688LL;
  v2 = v1[6];
  (*(void (__fastcall **)(_QWORD *))(*v1 + 16LL))(v1);
  return v2 + 688;
}


================================================================================
Function: sub_62AD454 (0x62AD454)
================================================================================

__int64 __fastcall sub_62AD454(__int64 a1, __int64 a2, float a3)
{
  __int64 result; // x0
  float v7; // s9
  bool v8; // nf
  bool v9; // cc
  long double v10; // q0
  pthread_mutex_t *v11; // x19
  int v12; // w8
  int v13; // w21
  __int64 v14; // x5
  __int64 v15; // x6
  __int64 v16; // x7
  long double v17; // q0
  long double v18; // q1
  long double v19; // q2
  long double v20; // q3
  int v21; // w8
  __int64 v22; // x5
  __int64 v23; // x6
  __int64 v24; // x7
  long double v25; // q0
  long double v26; // q1
  long double v27; // q2
  long double v28; // q3
  _QWORD *v29; // x21
  _QWORD *v30; // x21
  int v31; // w8
  _BOOL4 v32; // w8
  bool v33; // zf
  const char *v34; // x10
  const char *v35; // x4
  __int64 v36; // x22
  _QWORD *v37; // x9
  _QWORD *v38; // x8
  __int64 v39; // x9
  __int64 v40; // x10
  _QWORD *v41; // t1
  __int64 v42; // x0
  __int64 v43; // x21
  char *v44; // x4
  __int64 v45; // x22
  _QWORD *v46; // x9
  _QWORD *v47; // x8
  __int64 v48; // x9
  __int64 v49; // x10
  _QWORD *v50; // t1
  __int64 v51; // x0
  char v52; // w8
  __int64 v53[2]; // [xsp+0h] [xbp-90h] BYREF
  _QWORD v54[3]; // [xsp+10h] [xbp-80h] BYREF
  _BYTE v55[8]; // [xsp+28h] [xbp-68h] BYREF
  pthread_mutex_t *mutex; // [xsp+30h] [xbp-60h] BYREF
  char v57; // [xsp+38h] [xbp-58h]
  _QWORD v58[3]; // [xsp+40h] [xbp-50h] BYREF
  int v59; // [xsp+58h] [xbp-38h]

  mutex = (pthread_mutex_t *)(a1 + 92);
  v57 = 0;
  result = sub_25C6ADC(&mutex);
  *(float *)&v10 = fabsf(a3);
  v7 = *(float *)(a2 + 80);
  v8 = *(float *)&v10 < INFINITY;
  v9 = *(float *)&v10 <= INFINITY;
  LODWORD(v10) = 2139095039;
  if ( v8 )
    *(float *)&v10 = a3;
  if ( v9 )
    a3 = *(float *)&v10;
  if ( v7 != a3 )
  {
    v12 = *(_DWORD *)(a2 + 464);
    *(float *)(a2 + 80) = a3;
    if ( (v12 | 2) == 3 )
    {
      sub_62CBED4(v54, a2, &mutex, v10);
      v13 = *(_DWORD *)(a2 + 452);
      memset(v58, 0, sizeof(v58));
      sub_684A438((unsigned __int8 *)v58, (unsigned __int8 *)v54);
      v59 = v13;
      if ( (v54[0] & 1) != 0 )
        sub_65ECAF4();
      if ( byte_724A7A8 && byte_6FF3298 )
      {
        v21 = *(_DWORD *)(a2 + 464);
        LOWORD(v54[0]) = 0;
        if ( v21 == 1 )
        {
          if ( *(_BYTE *)(a2 + 710) )
          {
            sub_684A29C((int)v54, "queuedRequestsCacheChecks");
            v29 = (_QWORD *)(a1 + 232);
          }
          else
          {
            v53[0] = (__int64)v58;
            v43 = sub_62B614C(a1 + 584, v58, &unk_16B6404, v53, v55);
            sub_684A29C((int)v54, "queuedRequests");
            v29 = (_QWORD *)(v43 + 64);
          }
        }
        else if ( *(_BYTE *)(a2 + 793) )
        {
          sub_684A29C((int)v54, "pausedRequests");
          v29 = (_QWORD *)(a1 + 632);
        }
        else
        {
          sub_684A29C((int)v54, "completedRequests");
          v29 = (_QWORD *)(a1 + 608);
        }
        if ( *(_DWORD *)(a2 + 464) == 1 && v7 == 0.0 )
          --*(_DWORD *)(a1 + 668);
        if ( byte_724A7A8 && byte_724A758 )
        {
          if ( (unsigned __int8)qword_6FF2A70 < 6u || BYTE1(qword_6FF2A70) < 3u )
            goto LABEL_66;
        }
        else if ( !(_BYTE)qword_6FF2A70 )
        {
LABEL_66:
          v45 = *(_QWORD *)(a2 + 472);
          v46 = *(_QWORD **)(v45 + 8);
          if ( v46 )
          {
            do
            {
              v47 = v46;
              v46 = (_QWORD *)*v46;
            }
            while ( v46 );
          }
          else
          {
            v48 = v45 + 16;
            v47 = *(_QWORD **)(v45 + 16);
            if ( *v47 != v45 )
            {
              do
              {
                v49 = *(_QWORD *)v48;
                v50 = *(_QWORD **)(*(_QWORD *)v48 + 16LL);
                v48 = *(_QWORD *)v48 + 16LL;
                v47 = v50;
              }
              while ( *v50 != v49 );
            }
          }
          if ( *v29 == v45 )
            *v29 = v47;
          v51 = v29[1];
          --v29[2];
          sub_2563FCC(v51, v45);
          sub_65ECAF4();
          v53[0] = __PAIR64__(*(_DWORD *)(a2 + 704), LODWORD(a3));
          v53[1] = a2;
          result = sub_62B65A8(v29, v53, v53);
          v52 = v54[0];
          *(_QWORD *)(a2 + 472) = result;
          if ( (v52 & 1) != 0 )
            result = sub_65ECAF4();
LABEL_75:
          if ( a3 == 0.0 && *(_DWORD *)(a2 + 464) == 1 )
            ++*(_DWORD *)(a1 + 668);
          if ( (v58[0] & 1) != 0 )
            result = sub_65ECAF4();
          goto LABEL_7;
        }
        if ( (v54[0] & 1) != 0 )
          v44 = (char *)v54[2];
        else
          v44 = (char *)v54 + 1;
        *(double *)&v25 = v7;
        *(double *)&v26 = a3;
        sub_65C5C5C(
          qword_6FF2A70,
          qword_6FF2A78,
          (__int64)"[DFLog::TrackHttpRequest] [httptrack] new priority (%f => %f) req:%p from %s",
          a2,
          (__int64)v44,
          v22,
          v23,
          v24,
          v25,
          v26,
          v27,
          v28,
          v53[0]);
        goto LABEL_66;
      }
      if ( *(_DWORD *)(a2 + 464) == 1 )
      {
        if ( *(_BYTE *)(a2 + 710) )
        {
          v30 = (_QWORD *)(a1 + 232);
          v31 = 1;
        }
        else
        {
          v54[0] = v58;
          v30 = (_QWORD *)(sub_62B614C(a1 + 584, v58, &unk_16B6404, v54, v53) + 64);
          v31 = *(_DWORD *)(a2 + 464);
        }
        v33 = v31 == 1;
        v32 = v31 == 1;
        if ( v33 && v7 == 0.0 )
          --*(_DWORD *)(a1 + 668);
      }
      else
      {
        v32 = 0;
        v30 = (_QWORD *)(a1 + 608);
      }
      if ( byte_724A7A8 && byte_724A758 )
      {
        if ( (unsigned __int8)qword_6FF2A70 < 6u || BYTE1(qword_6FF2A70) < 3u )
          goto LABEL_43;
      }
      else if ( !(_BYTE)qword_6FF2A70 )
      {
LABEL_43:
        v36 = *(_QWORD *)(a2 + 472);
        v37 = *(_QWORD **)(v36 + 8);
        if ( v37 )
        {
          do
          {
            v38 = v37;
            v37 = (_QWORD *)*v37;
          }
          while ( v37 );
        }
        else
        {
          v39 = v36 + 16;
          v38 = *(_QWORD **)(v36 + 16);
          if ( *v38 != v36 )
          {
            do
            {
              v40 = *(_QWORD *)v39;
              v41 = *(_QWORD **)(*(_QWORD *)v39 + 16LL);
              v39 = *(_QWORD *)v39 + 16LL;
              v38 = v41;
            }
            while ( *v41 != v40 );
          }
        }
        if ( *v30 == v36 )
          *v30 = v38;
        v42 = v30[1];
        --v30[2];
        sub_2563FCC(v42, v36);
        sub_65ECAF4();
        v54[0] = __PAIR64__(*(_DWORD *)(a2 + 704), LODWORD(a3));
        v54[1] = a2;
        result = sub_62B65A8(v30, v54, v54);
        *(_QWORD *)(a2 + 472) = result;
        goto LABEL_75;
      }
      v34 = "queuedRequestsCacheChecks";
      if ( !*(_BYTE *)(a2 + 710) )
        v34 = "queuedRequests";
      if ( v32 )
        v35 = v34;
      else
        v35 = "completedRequests";
      *(double *)&v17 = v7;
      *(double *)&v18 = a3;
      sub_65C5C5C(
        qword_6FF2A70,
        qword_6FF2A78,
        (__int64)"[DFLog::TrackHttpRequest] [httptrack] new priority (%f => %f) req:%p from %s",
        a2,
        (__int64)v35,
        v14,
        v15,
        v16,
        v17,
        v18,
        v19,
        v20,
        v53[0]);
      goto LABEL_43;
    }
  }
LABEL_7:
  if ( v57 )
  {
    v11 = mutex;
    do
      result = pthread_mutex_unlock(v11);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25C5E54(v58, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24((__int64)v58);
    }
  }
  return result;
}


================================================================================
Function: sub_62AD9E8 (0x62AD9E8)
================================================================================

bool __fastcall sub_62AD9E8(__int64 a1, __int64 a2, int a3)
{
  int v6; // w19
  __int64 v7; // x0
  int v8; // w8
  _BOOL4 v9; // w22
  pthread_mutex_t *v10; // x20
  unsigned int v11; // w1
  __int64 v13; // x23
  __int64 v14; // x22
  __int64 v15; // x22
  __int64 v16; // x23
  __int64 v17; // x21
  __int64 v18; // x8
  __int64 v19; // x0
  _QWORD v20[7]; // [xsp+0h] [xbp-50h] BYREF
  pthread_mutex_t *v21; // [xsp+38h] [xbp-18h] BYREF
  char v22; // [xsp+40h] [xbp-10h]

  v6 = sub_65EBFB8(dword_6FF29D8);
  v22 = 0;
  v21 = (pthread_mutex_t *)(a1 + 92);
  v7 = sub_25C6ADC(&v21);
  v8 = *(_DWORD *)(a2 + 464);
  if ( v8 == 6 )
  {
LABEL_2:
    v9 = 1;
    goto LABEL_3;
  }
  v9 = 0;
  if ( a3 && v8 )
  {
    if ( !*(_QWORD *)(a2 + 712) )
    {
      v13 = sub_65ECAAC();
      v7 = sub_25C1984(v13);
      v14 = *(_QWORD *)(a2 + 712);
      *(_QWORD *)(a2 + 712) = v13;
      if ( v14 )
      {
        while ( pthread_mutex_destroy((pthread_mutex_t *)v14) == 4 )
          ;
        while ( pthread_cond_destroy((pthread_cond_t *)(v14 + 40)) == 4 )
          ;
        v7 = sub_65ECAF4();
      }
    }
    v15 = *(_QWORD *)(a2 + 712);
    if ( a3 < 1 )
    {
      while ( *(_DWORD *)(a2 + 464) != 6 )
        sub_25C6934(v15, &v21);
    }
    else
    {
      v16 = sub_67D71F4(v7) + 1000000LL * (unsigned int)a3;
      while ( *(_DWORD *)(a2 + 464) != 6 )
      {
        v17 = sub_67D718C();
        v18 = v16 - sub_67D71F4(v17) + v17;
        v20[0] = v18 / 1000000000;
        v20[1] = v18 % 1000000000;
        v19 = sub_2CE06A0(v15, &v21, v20);
        if ( sub_67D71F4(v19) >= v16 )
        {
          v9 = *(_DWORD *)(a2 + 464) == 6;
          goto LABEL_3;
        }
      }
    }
    goto LABEL_2;
  }
LABEL_3:
  if ( v22 )
  {
    v10 = v21;
    do
      v11 = pthread_mutex_unlock(v10);
    while ( v11 == 4 );
    if ( v11 )
    {
      sub_25C5E54(v20, v11, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24((__int64)v20);
    }
  }
  sub_65EBFB8(v6);
  return v9;
}


================================================================================
Function: sub_62ADC40 (0x62ADC40)
================================================================================

__int64 __fastcall sub_62ADC40(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x20
  __int64 v4; // x0
  pthread_mutex_t *v5; // x20
  unsigned int v6; // w1
  _QWORD v7[7]; // [xsp+0h] [xbp-50h] BYREF
  pthread_mutex_t *v8; // [xsp+38h] [xbp-18h] BYREF
  char v9; // [xsp+40h] [xbp-10h]

  result = *(_QWORD *)(a1 + 784);
  if ( !result )
  {
    v9 = 0;
    v8 = (pthread_mutex_t *)(a1 + 92);
    sub_25C6ADC((__int64)&v8);
    if ( !*(_QWORD *)(a1 + 784) )
    {
      v3 = sub_65ECAAC();
      sub_659409C(v3, "HttpThreadPool", 1LL, 3LL, 0LL);
      v4 = *(_QWORD *)(a1 + 784);
      *(_QWORD *)(a1 + 784) = v3;
      if ( v4 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
    }
    if ( v9 )
    {
      v5 = v8;
      do
        v6 = pthread_mutex_unlock(v5);
      while ( v6 == 4 );
      if ( v6 )
      {
        sub_25C5E54(v7, v6, "boost: mutex unlock failed in pthread_mutex_unlock");
        sub_25C5D24((__int64)v7);
      }
    }
    return *(_QWORD *)(a1 + 784);
  }
  return result;
}


================================================================================
Function: sub_62B191C (0x62B191C)
================================================================================

__int64 __fastcall sub_62B191C(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 *v4; // x21
  __int64 *v5; // x20
  __int64 *v6; // x22
  char v7; // t1

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = v2[6];
      v5 = *v2;
      if ( v4 )
      {
        if ( v2[7] != v4 )
        {
          v6 = v2[7];
          do
          {
            v7 = *((_BYTE *)v6 - 24);
            v6 -= 3;
            if ( (v7 & 1) != 0 )
              sub_65ECAF4();
          }
          while ( v6 != v4 );
        }
        v2[7] = v4;
        sub_65ECAF4();
      }
      if ( ((_BYTE)v2[3] & 1) != 0 )
        sub_65ECAF4();
      result = sub_65ECAF4();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_62B19C0 (0x62B19C0)
================================================================================

__int64 __fastcall sub_62B19C0(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_65ECAF4();
          sub_65ECAF4();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_65ECAF4();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_65ECAF4();
      result = sub_65ECAF4();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_62B3AD4 (0x62B3AD4)
================================================================================

__int64 __fastcall sub_62B3AD4(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_6867450(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65EFD58(0);
  if ( v2 >> 62 != 2 )
  {
    sub_65EF508(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7301220);
      v5 = sub_65FD0A0(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_62B3D1C(v5);
      sub_6867600(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_6848B0C((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_62B3D1C (0x62B3D1C)
================================================================================

__int64 sub_62B3D1C()
{
  __int64 v0; // x19

  v0 = sub_65ED63C(0xC8uLL);
  sub_63A1F90();
  return v0;
}


================================================================================
Function: sub_62B614C (0x62B614C)
================================================================================

__int64 __fastcall sub_62B614C(__int64 a1, __int64 a2, __int64 a3, __int128 **a4)
{
  __int64 *v6; // x23
  __int64 *v7; // x24
  __int64 v9; // x21
  __int64 v10; // x0
  __int128 *v11; // x8
  __int128 v12; // q0
  int v13; // w10
  __int64 *v14; // x8
  __int64 v15; // x8
  __int64 v16; // x1

  v6 = (__int64 *)(a1 + 8);
  v7 = *(__int64 **)(a1 + 8);
  if ( v7 )
  {
    v6 = (__int64 *)(a1 + 8);
    while ( 1 )
    {
      while ( (sub_62B6280(a2, v7 + 4) & 1) == 0 )
      {
        if ( (sub_62B6280(v7 + 4, a2) & 1) == 0 )
          goto LABEL_10;
        v6 = v7 + 1;
        if ( !v7[1] )
          goto LABEL_10;
        v7 = (__int64 *)v7[1];
      }
      if ( !*v7 )
        break;
      v6 = v7;
      v7 = (__int64 *)*v7;
    }
    v6 = v7;
    goto LABEL_13;
  }
  v7 = (__int64 *)(a1 + 8);
LABEL_10:
  v9 = *v6;
  if ( !*v6 )
  {
LABEL_13:
    v10 = sub_65ECAAC();
    v11 = *a4;
    v9 = v10;
    v12 = **a4;
    *(_QWORD *)(v10 + 48) = *((_QWORD *)*a4 + 2);
    *(_OWORD *)(v10 + 32) = v12;
    *((_QWORD *)v11 + 1) = 0LL;
    *((_QWORD *)v11 + 2) = 0LL;
    v13 = *((_DWORD *)v11 + 6);
    *(_QWORD *)v11 = 0LL;
    *(_QWORD *)(v10 + 80) = 0LL;
    *(_QWORD *)(v10 + 72) = 0LL;
    *(_QWORD *)(v10 + 64) = v10 + 72;
    *(_QWORD *)v10 = 0LL;
    *(_QWORD *)(v10 + 8) = 0LL;
    *(_QWORD *)(v10 + 16) = v7;
    *v6 = v10;
    v14 = *(__int64 **)a1;
    *(_DWORD *)(v10 + 56) = v13;
    v15 = *v14;
    if ( v15 )
    {
      *(_QWORD *)a1 = v15;
      v16 = *v6;
    }
    else
    {
      v16 = v10;
    }
    sub_2527820(*(_QWORD *)(a1 + 8), v16);
    ++*(_QWORD *)(a1 + 16);
  }
  return v9;
}


================================================================================
Function: sub_62B6280 (0x62B6280)
================================================================================

__int64 __fastcall sub_62B6280(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x23
  unsigned __int64 v5; // x24
  size_t v6; // x21
  unsigned __int64 v7; // x22
  size_t v8; // x25
  size_t v9; // x2
  unsigned __int8 *v10; // x1
  unsigned __int8 *v11; // x0
  int v12; // w0
  const void *v13; // x0
  unsigned __int8 *v14; // x1
  unsigned __int8 *i; // x8

  v2 = *a2;
  v5 = *a1;
  if ( (v2 & 1) != 0 )
    v6 = *((_QWORD *)a2 + 1);
  else
    v6 = v2 >> 1;
  v7 = v5 >> 1;
  if ( (v5 & 1) != 0 )
    v8 = *((_QWORD *)a1 + 1);
  else
    v8 = v5 >> 1;
  if ( v6 >= v8 )
    v9 = v8;
  else
    v9 = v6;
  if ( v9 )
  {
    v10 = (v2 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a2 + 2) : a2 + 1;
    v11 = (v5 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a1 + 2) : a1 + 1;
    v12 = memcmp(v11, v10, v9);
    if ( v12 )
    {
      if ( (v12 & 0x80000000) == 0 )
        goto LABEL_19;
      return 1LL;
    }
  }
  if ( v8 < v6 )
    return 1LL;
LABEL_19:
  if ( v8 != v6 )
    return 0LL;
  if ( (v5 & 1) != 0 )
    v13 = (const void *)*((_QWORD *)a1 + 2);
  else
    v13 = a1 + 1;
  if ( (v2 & 1) != 0 )
    v14 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v14 = a2 + 1;
  if ( (v5 & 1) != 0 )
  {
    if ( !v6 || !memcmp(v13, v14, v6) )
      return *((_DWORD *)a1 + 6) < *((_DWORD *)a2 + 6);
    return 0LL;
  }
  if ( v6 )
  {
    for ( i = a1 + 1; *i == *v14; ++i )
    {
      --v7;
      ++v14;
      if ( !v7 )
        return *((_DWORD *)a1 + 6) < *((_DWORD *)a2 + 6);
    }
    return 0LL;
  }
  return *((_DWORD *)a1 + 6) < *((_DWORD *)a2 + 6);
}


================================================================================
Function: sub_62B65A8 (0x62B65A8)
================================================================================

__int64 __fastcall sub_62B65A8(__int64 **a1, __int64 a2, __int128 *a3)
{
  __int64 *v5; // x22
  __int64 v6; // x23
  float v7; // s0
  unsigned int v8; // w8
  float v9; // s1
  unsigned int v10; // w9
  __int64 v11; // x21
  __int64 v12; // x0
  __int128 v13; // q0
  __int64 *v14; // x8
  __int64 v15; // x1

  v5 = (__int64 *)(a1 + 1);
  v6 = (__int64)a1[1];
  if ( v6 )
  {
    v7 = *(float *)a2;
    v5 = (__int64 *)(a1 + 1);
    v8 = *(_DWORD *)(a2 + 4);
    while ( 1 )
    {
      v9 = *(float *)(v6 + 32);
      if ( v7 < v9 )
        goto LABEL_6;
      if ( v7 != v9 )
        break;
      v10 = *(_DWORD *)(v6 + 36);
      if ( v8 >= v10 )
      {
        if ( v9 >= v7 && v10 >= v8 )
          goto LABEL_15;
LABEL_12:
        v5 = (__int64 *)(v6 + 8);
        if ( !*(_QWORD *)(v6 + 8) )
          goto LABEL_15;
        v6 = *(_QWORD *)(v6 + 8);
      }
      else
      {
LABEL_6:
        if ( !*(_QWORD *)v6 )
        {
          v5 = (__int64 *)v6;
          goto LABEL_18;
        }
        v5 = (__int64 *)v6;
        v6 = *(_QWORD *)v6;
      }
    }
    if ( v9 >= v7 )
      goto LABEL_15;
    goto LABEL_12;
  }
  v6 = (__int64)(a1 + 1);
LABEL_15:
  v11 = *v5;
  if ( !*v5 )
  {
LABEL_18:
    v12 = sub_65ECAAC();
    v13 = *a3;
    *(_QWORD *)v12 = 0LL;
    *(_QWORD *)(v12 + 8) = 0LL;
    *(_QWORD *)(v12 + 16) = v6;
    v11 = v12;
    *(_OWORD *)(v12 + 32) = v13;
    *v5 = v12;
    v14 = (__int64 *)**a1;
    if ( v14 )
    {
      *a1 = v14;
      v15 = *v5;
    }
    else
    {
      v15 = v12;
    }
    sub_2527820((__int64)a1[1], v15);
    a1[2] = (__int64 *)((char *)a1[2] + 1);
  }
  return v11;
}


================================================================================
Function: sub_62BC67C (0x62BC67C)
================================================================================

long double __fastcall sub_62BC67C(__int64 a1, __int64 a2)
{
  unsigned __int8 v3; // w8
  __int64 v4; // x0
  long double result; // q0

  *(_QWORD *)a1 = a2;
  v3 = atomic_load(byte_6DE6FF8);
  if ( (v3 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6DE6FF8) )
  {
    qword_6DE6FB8 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6DE6FC0);
    qword_6DE6FE8 = 0LL;
    unk_6DE6FF0 = 0LL;
    qword_6DE6FB8 = (__int64)off_695A468;
    qword_6DE7000 = (__int64)&qword_6DE6FB8;
    sub_6862850(byte_6DE6FF8);
  }
  v4 = sub_3C5188C((__int64)&qword_6DE6FB8);
  *(_OWORD *)&result = 0uLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_QWORD *)(a1 + 8) = v4;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  return result;
}


================================================================================
Function: sub_62C9268 (0x62C9268)
================================================================================

__int64 __fastcall sub_62C9268(__int64 result, int a2)
{
  *(_DWORD *)(result + 44) = a2;
  return result;
}


================================================================================
Function: sub_62C92C4 (0x62C92C4)
================================================================================

__int64 __fastcall sub_62C92C4(char *a1, __int64 a2, char *a3, __int64 a4)
{
  __int64 v4; // x9
  int v5; // w8
  int v6; // t1
  int v7; // w10
  int v8; // t1
  unsigned int v9; // w11
  bool v10; // zf
  _BOOL4 v11; // w8

  if ( a2 != a4 )
    return 0LL;
  if ( !a2 )
    return 1LL;
  v4 = a2 - 1;
  do
  {
    v6 = *a1++;
    v5 = v6;
    v8 = *a3++;
    v7 = v8;
    v9 = v8 - 65;
    if ( (unsigned int)(v5 - 65) < 0x1A )
      v5 |= 0x20u;
    if ( v9 < 0x1A )
      v7 |= 0x20u;
    v10 = v5 == v7;
    v11 = v5 == v7;
    if ( !v10 )
      break;
  }
  while ( v4-- );
  return v11;
}


================================================================================
Function: sub_62CA0B8 (0x62CA0B8)
================================================================================

unsigned __int64 *__fastcall sub_62CA0B8(__int64 a1, __int64 a2, __int128 *a3, char a4)
{
  __int64 v7; // x9
  unsigned __int64 *result; // x0
  _QWORD v9[2]; // [xsp+8h] [xbp-18h] BYREF

  sub_628D000(v9, a2);
  v7 = v9[1];
  *(_QWORD *)a1 = v9[0];
  *(_QWORD *)(a1 + 8) = v7;
  result = sub_68497A0((unsigned __int64 *)(a1 + 16), a3);
  *(_BYTE *)(a1 + 40) = a4 & 1;
  return result;
}


================================================================================
Function: sub_62CA3FC (0x62CA3FC)
================================================================================

__int64 __usercall sub_62CA3FC@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  __int64 v3; // x5
  __int64 v4; // x6
  __int64 v5; // x7
  int v6; // w19
  long double v7; // q0
  long double v8; // q1
  long double v9; // q2
  long double v10; // q3
  unsigned __int64 v11; // x8
  __int64 v12; // x8
  int v13; // w9
  unsigned __int64 v14; // x10
  unsigned __int64 v15; // x11
  char *v16; // x3
  __int64 v17; // x9
  __int64 v19[2]; // [xsp+0h] [xbp-20h] BYREF
  int v20; // [xsp+14h] [xbp-Ch] BYREF

  v20 = a1;
  v6 = sub_65EBFB8(dword_6FF3A48);
  if ( (word_6FF3A88 & 1) != 0 )
    v11 = qword_6FF3A90;
  else
    v11 = (unsigned __int64)(unsigned __int8)word_6FF3A88 >> 1;
  if ( v11 == 5 && !(unsigned int)sub_684A118((int)&word_6FF3A88, 0, -1, "msxml") && (sub_62D2728() & 1) != 0 )
  {
    if ( (byte_6FF3BC8 & 1) != 0 )
      goto LABEL_37;
    byte_6FF3BC8 = 1;
    if ( byte_724A7A8 && byte_724A758 )
    {
      if ( (unsigned __int8)qword_6FF2A50 < 6u || BYTE1(qword_6FF2A50) < 3u )
LABEL_37:
        sub_62CA70C(v19, &v20);
    }
    else if ( !(_BYTE)qword_6FF2A50 )
    {
      goto LABEL_37;
    }
    sub_65C5C5C(
      qword_6FF2A50,
      qword_6FF2A58,
      (__int64)"[DFLog::HttpTraceError] Warning: will use \"%s\" for HttpRequest, while default is \"%s\"",
      (__int64)"msxml",
      (__int64)"curl",
      v3,
      v4,
      v5,
      v7,
      v8,
      v9,
      v10,
      v19[0]);
    goto LABEL_37;
  }
  v12 = qword_6FF3A90;
  v13 = word_6FF3A88 & 1;
  v14 = (unsigned __int64)(unsigned __int8)word_6FF3A88 >> 1;
  if ( v13 )
    v15 = qword_6FF3A90;
  else
    v15 = (unsigned __int64)(unsigned __int8)word_6FF3A88 >> 1;
  if ( !v15 )
  {
    if ( !(unsigned int)sub_684A118((int)&word_6FF3A88, 0, -1, &byte_CC4FFC) )
      goto LABEL_34;
    v12 = qword_6FF3A90;
    v13 = word_6FF3A88 & 1;
    v14 = (unsigned __int64)(unsigned __int8)word_6FF3A88 >> 1;
  }
  if ( !v13 )
    v12 = v14;
  if ( (v12 != 4 || (unsigned int)sub_684A118((int)&word_6FF3A88, 0, -1, "curl")) && (byte_6FF3BC9 & 1) == 0 )
  {
    byte_6FF3BC9 = 1;
    if ( byte_724A7A8 && byte_724A758 )
    {
      if ( (unsigned __int8)qword_6FF2A50 < 6u || BYTE1(qword_6FF2A50) < 3u )
        goto LABEL_34;
    }
    else if ( !(_BYTE)qword_6FF2A50 )
    {
      goto LABEL_34;
    }
    if ( (word_6FF3A88 & 1) != 0 )
      v16 = (char *)qword_6FF3A98;
    else
      v16 = (char *)&word_6FF3A88 + 1;
    sub_65C5C5C(
      qword_6FF2A50,
      qword_6FF2A58,
      (__int64)"[DFLog::HttpTraceError] Warning: cannot use \"%s\" for HttpRequest, will use default \"%s\"",
      (__int64)v16,
      (__int64)"curl",
      v3,
      v4,
      v5,
      v7,
      v8,
      v9,
      v10,
      v19[0]);
  }
LABEL_34:
  sub_62CA8A0(v19, &v20);
  v17 = v19[1];
  *a2 = v19[0];
  a2[1] = v17;
  return sub_65EBFB8(v6);
}


================================================================================
Function: sub_62CA70C (0x62CA70C)
================================================================================

void __fastcall __noreturn sub_62CA70C(unsigned int *a1)
{
  bool v2; // zf
  _QWORD *v3; // x0
  __int64 v4; // x1
  __int64 v5; // [xsp+0h] [xbp-10h] BYREF

  if ( byte_724A7A8 )
    v2 = byte_7301120 == 0;
  else
    v2 = 1;
  if ( !v2 )
  {
    v5 = sub_680599C();
    sub_62D09F0(&v5, a1);
  }
  v3 = (_QWORD *)sub_65ECAAC();
  v4 = *a1;
  v3[2] = 0LL;
  v3[1] = 0LL;
  *v3 = off_6C1DC68;
  sub_62D2730(v3 + 4, v4);
}


================================================================================
Function: sub_62CA8A0 (0x62CA8A0)
================================================================================

unsigned __int64 __usercall sub_62CA8A0@<X0>(unsigned int *a1@<X0>, _QWORD *a2@<X8>)
{
  bool v4; // zf
  unsigned __int64 *v5; // x19
  __int64 v6; // x1
  unsigned __int64 *v7; // x21
  unsigned __int64 *v8; // x23
  unsigned __int64 result; // x0
  __int64 v10; // [xsp+0h] [xbp-10h] BYREF

  if ( byte_724A7A8 )
    v4 = byte_7301120 == 0;
  else
    v4 = 1;
  if ( !v4 )
  {
    v10 = sub_680599C();
    return sub_62D0CE0(&v10, a1);
  }
  v5 = (unsigned __int64 *)sub_65ECAAC();
  v6 = *a1;
  v7 = v5 + 4;
  v5[2] = 0LL;
  v5[1] = 0LL;
  *v5 = (unsigned __int64)off_6C1DD08;
  result = sub_62F2420(v5 + 4, v6);
  v8 = (unsigned __int64 *)v5[6];
  *a2 = v5 + 4;
  a2[1] = v5;
  if ( v8 )
  {
    if ( v8[1] != -1LL )
      return result;
    sub_6867420(1uLL, (atomic_ullong *)(v5 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v5 + 2));
    v5[5] = (unsigned __int64)v7;
    v5[6] = (unsigned __int64)v5;
    sub_68488BC(v8);
  }
  else
  {
    sub_6867420(1uLL, (atomic_ullong *)(v5 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v5 + 2));
    v5[5] = (unsigned __int64)v7;
    v5[6] = (unsigned __int64)v5;
  }
  result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v5 + 1));
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v5 + 16))(v5);
    return sub_68488BC(v5);
  }
  return result;
}


================================================================================
Function: sub_62CAC2C (0x62CAC2C)
================================================================================

__int64 __fastcall sub_62CAC2C(__int64 a1)
{
  __int64 v6; // x9
  __int64 v7; // x10
  unsigned __int8 v8; // w8
  __int64 v9; // x0
  unsigned __int8 *v10; // x0
  unsigned __int64 v11; // x8
  size_t v13; // x8
  void *v14; // x3
  size_t v15; // x4

  *(_DWORD *)(a1 + 80) = 2139095039;
  *(_QWORD *)a1 = off_6C1D9D8;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_BYTE *)(a1 + 280) = 6;
  *(_DWORD *)(a1 + 281) = 5522759;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_QWORD *)(a1 + 368) = 0LL;
  *(_QWORD *)(a1 + 432) = 0LL;
  *(_QWORD *)(a1 + 440) = 0LL;
  *(_QWORD *)(a1 + 424) = 0LL;
  *(_QWORD *)(a1 + 320) = 0LL;
  *(_DWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 452) = 0xFFFFFFFF00000000LL;
  *(_QWORD *)(a1 + 304) = 0LL;
  *(_QWORD *)(a1 + 312) = 0LL;
  __asm { FMOV            V1.2D, #-1.0 }
  *(_BYTE *)(a1 + 416) = 0;
  v6 = dword_6CA6098;
  *(_DWORD *)(a1 + 464) = 0;
  v7 = dword_6CA6094;
  *(_DWORD *)(a1 + 820) = 0;
  *(_QWORD *)(a1 + 552) = 0LL;
  *(_QWORD *)(a1 + 384) = v6;
  *(_QWORD *)(a1 + 392) = 0LL;
  *(_QWORD *)(a1 + 400) = v7;
  *(_QWORD *)(a1 + 408) = 0LL;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 560) = _Q1;
  *(_OWORD *)(a1 + 576) = _Q1;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 592) = _Q1;
  *(_OWORD *)(a1 + 608) = _Q1;
  *(_QWORD *)(a1 + 624) = 0xBFF0000000000000LL;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 661) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_QWORD *)(a1 + 680) = 0LL;
  *(_QWORD *)(a1 + 688) = 0LL;
  *(_DWORD *)(a1 + 696) = -1;
  *(_QWORD *)(a1 + 808) = 0LL;
  *(_QWORD *)(a1 + 800) = 0LL;
  *(_OWORD *)(a1 + 780) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_WORD *)(a1 + 816) = 1;
  *(_BYTE *)(a1 + 818) = 0;
  *(_DWORD *)(a1 + 824) = 0;
  *(_QWORD *)(a1 + 840) = 0LL;
  *(_QWORD *)(a1 + 832) = 0LL;
  v8 = atomic_load(byte_6CB1570);
  if ( (v8 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6CB1570) )
  {
    qword_6CB1530 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6CB1538);
    qword_6CB1560 = 0LL;
    unk_6CB1568 = 0LL;
    qword_6CB1530 = (__int64)off_6871A40;
    qword_6CB1578 = (__int64)&qword_6CB1530;
    sub_6862850(byte_6CB1570);
  }
  *(_QWORD *)(a1 + 848) = sub_2533228((__int64)&qword_6CB1530);
  *(_DWORD *)(a1 + 856) = 0;
  *(_QWORD *)(a1 + 864) = 0LL;
  sub_62CAF24(a1, "Accept-Encoding", 0xFuLL, "gzip, deflate", 0xDuLL);
  sub_62CAF24(a1, "Cache-Control", 0xDuLL, "no-cache", 8uLL);
  v9 = sub_62CAF24(a1, "Connection", 0xAuLL, "keep-alive", 0xAuLL);
  v10 = (unsigned __int8 *)sub_628C114(v9);
  v11 = *v10;
  _ZF = (v11 & 1) == 0;
  v13 = v11 >> 1;
  if ( _ZF )
    v14 = v10 + 1;
  else
    v14 = (void *)*((_QWORD *)v10 + 2);
  if ( _ZF )
    v15 = v13;
  else
    v15 = *((_QWORD *)v10 + 1);
  return sub_62CAF24(a1, "User-Agent", 0xAuLL, v14, v15);
}


================================================================================
Function: sub_62CAF24 (0x62CAF24)
================================================================================

__int64 __fastcall sub_62CAF24(__int64 result, void *src, size_t n, void *a4, size_t a5)
{
  __int64 v7; // x19
  __int64 v10; // x8
  __int64 v11; // x20
  __int64 v12; // x26
  __int64 v13; // x25
  __int64 v14; // x28
  unsigned __int64 v15; // x8
  bool v16; // zf
  unsigned __int64 v17; // x8
  __int64 v18; // x2
  __int64 v19; // x3
  char *v20; // x25
  char *v21; // x23
  char *v22; // x8
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x9
  __int128 v25; // q0
  __int128 v26; // q0
  char *v27; // x9
  __int128 v28; // [xsp+0h] [xbp-70h] BYREF
  char *v29; // [xsp+10h] [xbp-60h]
  __int128 v30; // [xsp+18h] [xbp-58h] BYREF
  char *v31; // [xsp+28h] [xbp-48h]
  __int128 v32; // [xsp+30h] [xbp-40h] BYREF
  char *v33; // [xsp+40h] [xbp-30h]
  __int128 v34; // [xsp+48h] [xbp-28h]
  char *v35; // [xsp+58h] [xbp-18h]

  v7 = result;
  v10 = *(_QWORD *)(result + 32);
  v12 = *(_QWORD *)(result + 40);
  v11 = result + 32;
  if ( v10 == v12 )
  {
LABEL_11:
    if ( !src )
    {
      v30 = 0uLL;
      v31 = 0LL;
      if ( a4 )
        goto LABEL_22;
      goto LABEL_18;
    }
    if ( n >= 0xFFFFFFFFFFFFFFF0LL )
      sub_6849630();
    if ( n >= 0x17 )
    {
      v20 = (char *)sub_65ECAAC();
      *((_QWORD *)&v30 + 1) = n;
      v31 = v20;
      *(_QWORD *)&v30 = (n + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v20 = (char *)&v30 + 1;
      LOBYTE(v30) = 2 * n;
      if ( !n )
      {
LABEL_21:
        v20[n] = 0;
        if ( a4 )
        {
LABEL_22:
          if ( a5 >= 0xFFFFFFFFFFFFFFF0LL )
            sub_6849630();
          if ( a5 >= 0x17 )
          {
            v21 = (char *)sub_65ECAAC();
            *((_QWORD *)&v28 + 1) = a5;
            v29 = v21;
            *(_QWORD *)&v28 = (a5 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            v21 = (char *)&v28 + 1;
            LOBYTE(v28) = 2 * a5;
            if ( !a5 )
              goto LABEL_28;
          }
          result = (__int64)memcpy(v21, a4, a5);
LABEL_28:
          v21[a5] = 0;
LABEL_29:
          v22 = v31;
          v31 = 0LL;
          v33 = v22;
          v35 = v29;
          v23 = *(_QWORD *)(v7 + 40);
          v24 = *(_QWORD *)(v7 + 48);
          v32 = v30;
          v25 = v28;
          v29 = 0LL;
          v30 = 0uLL;
          v28 = 0uLL;
          v34 = v25;
          if ( v23 >= v24 )
          {
            result = sub_25884CC(v11, &v32);
            if ( (v34 & 1) != 0 )
            {
              result = sub_65ECAF4();
              if ( (v32 & 1) != 0 )
                goto LABEL_39;
            }
            else if ( (v32 & 1) != 0 )
            {
              goto LABEL_39;
            }
          }
          else
          {
            v26 = v32;
            *(_QWORD *)(v23 + 16) = v33;
            *(_OWORD *)v23 = v26;
            v27 = v35;
            v33 = 0LL;
            v32 = 0uLL;
            *(_OWORD *)(v23 + 24) = v34;
            *(_QWORD *)(v23 + 40) = v27;
            v35 = 0LL;
            v34 = 0uLL;
            *(_QWORD *)(v7 + 40) = v23 + 48;
            if ( (v32 & 1) != 0 )
            {
LABEL_39:
              result = sub_65ECAF4();
              if ( (v28 & 1) != 0 )
              {
LABEL_40:
                result = sub_65ECAF4();
                if ( (v30 & 1) == 0 )
                  return result;
                return sub_65ECAF4();
              }
LABEL_35:
              if ( (v30 & 1) == 0 )
                return result;
              return sub_65ECAF4();
            }
          }
          if ( (v28 & 1) != 0 )
            goto LABEL_40;
          goto LABEL_35;
        }
LABEL_18:
        v28 = 0uLL;
        v29 = 0LL;
        goto LABEL_29;
      }
    }
    result = (__int64)memcpy(v20, src, n);
    goto LABEL_21;
  }
  v13 = v10 + 24;
  while ( 1 )
  {
    v14 = v13 - 23;
    v15 = *(unsigned __int8 *)(v13 - 24);
    v16 = (v15 & 1) == 0;
    v17 = v15 >> 1;
    v18 = v16 ? v13 - 23 : *(_QWORD *)(v13 - 8);
    v19 = v16 ? v17 : *(_QWORD *)(v13 - 16);
    result = sub_62C92C4(src, n, v18, v19);
    if ( (result & 1) != 0 )
      return sub_65FF9FC(v13, a4, a5);
    v13 += 48LL;
    if ( v14 + 47 == v12 )
      goto LABEL_11;
  }
}


================================================================================
Function: sub_62CB67C (0x62CB67C)
================================================================================

__int64 __fastcall sub_62CB67C(__int64 a1, void *a2, size_t a3)
{
  int v6; // w19
  void *v7; // x0
  char v8; // w0
  __int64 v10; // x8
  __int128 v11; // [xsp+0h] [xbp-A0h] BYREF
  __int64 v12; // [xsp+10h] [xbp-90h]
  __int64 v13[2]; // [xsp+18h] [xbp-88h] BYREF
  unsigned __int8 v14[16]; // [xsp+30h] [xbp-70h] BYREF
  char v15; // [xsp+48h] [xbp-58h]
  char v16; // [xsp+60h] [xbp-40h]
  char v17; // [xsp+78h] [xbp-28h]

  v6 = sub_65EBFB8(dword_6FF3A48);
  sub_65FF9FC(a1 + 88, a2, a3);
  sub_62CB884(a1 + 88, a1 + 112);
  if ( (*(_BYTE *)(a1 + 112) & 1) != 0 )
    v7 = *(void **)(a1 + 128);
  else
    v7 = (void *)(a1 + 113);
  sub_658F364(v13, v7);
  if ( (sub_6590C18((int)v13) & 1) != 0 )
    v8 = sub_65906C0(v13);
  else
    v8 = 0;
  *(_BYTE *)(a1 + 411) = v8 & 1;
  sub_684A438((unsigned __int8 *)(a1 + 136), v14);
  if ( !byte_724A7A8 || !byte_6FF3AC0 )
  {
LABEL_11:
    if ( (v17 & 1) == 0 )
      goto LABEL_12;
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 412) )
  {
    sub_684A438((unsigned __int8 *)(a1 + 160), (unsigned __int8 *)(a1 + 136));
    goto LABEL_11;
  }
  sub_6291E98(&v11, v13);
  if ( (*(_BYTE *)(a1 + 160) & 1) != 0 )
    sub_65ECAF4();
  v10 = v12;
  *(_OWORD *)(a1 + 160) = v11;
  *(_QWORD *)(a1 + 176) = v10;
  if ( (v17 & 1) == 0 )
  {
LABEL_12:
    if ( (v16 & 1) == 0 )
      goto LABEL_13;
    goto LABEL_22;
  }
LABEL_21:
  sub_65ECAF4();
  if ( (v16 & 1) == 0 )
  {
LABEL_13:
    if ( (v15 & 1) == 0 )
      goto LABEL_14;
    goto LABEL_23;
  }
LABEL_22:
  sub_65ECAF4();
  if ( (v15 & 1) == 0 )
  {
LABEL_14:
    if ( (v14[0] & 1) == 0 )
      goto LABEL_15;
LABEL_24:
    sub_65ECAF4();
    if ( (v13[0] & 1) == 0 )
      return sub_65EBFB8(v6);
    goto LABEL_16;
  }
LABEL_23:
  sub_65ECAF4();
  if ( (v14[0] & 1) != 0 )
    goto LABEL_24;
LABEL_15:
  if ( (v13[0] & 1) != 0 )
LABEL_16:
    sub_65ECAF4();
  return sub_65EBFB8(v6);
}


================================================================================
Function: sub_62CB884 (0x62CB884)
================================================================================

__int64 __fastcall sub_62CB884(unsigned __int8 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v4; // x8
  bool v5; // zf
  unsigned __int64 v6; // x8
  unsigned __int8 *v7; // x21
  unsigned __int64 v8; // x23
  int v9; // w9
  unsigned __int64 v11; // x22
  int v12; // w10
  unsigned __int8 *v14; // x0
  unsigned __int16 *v15; // x24
  __int64 v16; // x8
  unsigned __int16 *v17; // x0
  unsigned __int64 v18; // x2
  __int64 result; // x0
  __int64 v20; // x21
  unsigned int v21; // w8
  unsigned __int8 *v22; // x25
  unsigned __int8 *v23; // x21
  unsigned __int8 *v24; // x24
  unsigned __int64 v25; // x20
  unsigned __int64 v26; // x1
  unsigned __int64 v27; // x3
  char v28; // w8
  unsigned int v29; // w8
  unsigned __int8 *v30; // x28
  unsigned __int8 *v31; // x26
  unsigned __int8 *v32; // x27
  unsigned __int64 v33; // x25
  unsigned __int64 v34; // x1
  unsigned __int64 v35; // x3
  char v36; // w8
  unsigned __int8 *v37; // x10
  unsigned __int64 v38; // x9
  char *v39; // x8
  unsigned __int8 *v40; // x12
  _OWORD *v41; // x10
  unsigned __int64 v42; // x13
  __int128 v43; // q0
  __int128 v44; // q1
  char v45; // t1
  unsigned __int8 *v46; // x8
  unsigned __int8 *v47; // x10
  unsigned __int64 v48; // x9
  char *v49; // x8
  unsigned __int8 *v50; // x12
  _OWORD *v51; // x10
  unsigned __int64 v52; // x13
  __int128 v53; // q0
  __int128 v54; // q1
  char v55; // t1

  v4 = *a1;
  v5 = (v4 & 1) == 0;
  if ( (v4 & 1) != 0 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v4 >> 1;
  if ( v5 )
    v7 = a1 + 1;
  else
    v7 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( !v6 )
  {
    v11 = 0LL;
    v8 = 0LL;
    goto LABEL_29;
  }
  v8 = 0LL;
  while ( 1 )
  {
    v9 = v7[v8];
    if ( v9 != 32 && v9 != 9 )
      break;
    if ( v6 == ++v8 )
    {
      v11 = v6;
      v8 = v6;
      goto LABEL_29;
    }
  }
  if ( v6 <= v8 )
  {
    v11 = v6;
    if ( v6 < v8 )
      goto LABEL_37;
    goto LABEL_29;
  }
  v11 = v6;
  while ( 1 )
  {
    v12 = v7[v11 - 1];
    if ( v12 != 32 && v12 != 9 )
      break;
    if ( --v11 <= v8 )
    {
      v11 = v8;
      break;
    }
  }
  if ( v6 >= v8 )
  {
LABEL_29:
    v14 = &v7[v8];
    v15 = (unsigned __int16 *)&v7[v6];
    v16 = v6 - v8;
    if ( v16 >= 3 )
    {
      do
      {
        v17 = (unsigned __int16 *)memchr(v14, 58, v16 - 2);
        if ( !v17 )
          break;
        if ( !(*v17 ^ 0x2F3A | *((unsigned __int8 *)v17 + 2) ^ 0x2F) )
        {
          if ( v17 != v15 && (char *)v17 - (char *)v7 != -1 )
          {
            v18 = (char *)v17 - (char *)v7 + 3;
            goto LABEL_38;
          }
          break;
        }
        v14 = (unsigned __int8 *)v17 + 1;
        v16 = (char *)v15 - (char *)v14;
      }
      while ( (char *)v15 - (char *)v14 >= 3 );
    }
  }
LABEL_37:
  v18 = v8;
LABEL_38:
  result = sub_6849DAC(a1, 0x2Fu, v18);
  if ( result == -1 )
  {
    v21 = *(unsigned __int8 *)a2;
    if ( (*a1 & 1) != 0 )
      v22 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    else
      v22 = a1 + 1;
    v23 = &v22[v8];
    v24 = &v22[v11];
    v25 = v11 - v8;
    if ( (v21 & 1) != 0 )
      v26 = (*a2 & 0xFFFFFFFFFFFFFFFELL) - 1;
    else
      v26 = 22LL;
    if ( v25 <= v26 )
    {
      v28 = *a2;
    }
    else
    {
      if ( (v21 & 1) != 0 )
        v27 = a2[1];
      else
        v27 = v21 >> 1;
      result = sub_68499C0(a2, v26, v25 - v26, v27, 0LL, v27, 0LL);
      v28 = *(_BYTE *)a2;
    }
    if ( (v28 & 1) != 0 )
      v47 = (unsigned __int8 *)a2[2];
    else
      v47 = (unsigned __int8 *)a2 + 1;
    v48 = v11 - v8;
    if ( v11 == v8 )
    {
      v49 = (char *)v47;
    }
    else
    {
      if ( v48 < 0x20 || v47 < v24 && v23 < &v47[v48] )
        goto LABEL_97;
      v49 = (char *)&v47[v48 & 0xFFFFFFFFFFFFFFE0LL];
      v23 += v48 & 0xFFFFFFFFFFFFFFE0LL;
      v50 = &v22[v8 + 16];
      v51 = v47 + 16;
      v52 = v48 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v53 = *((_OWORD *)v50 - 1);
        v54 = *(_OWORD *)v50;
        v50 += 32;
        v52 -= 32LL;
        *(v51 - 1) = v53;
        *v51 = v54;
        v51 += 2;
      }
      while ( v52 );
      v47 = (unsigned __int8 *)v49;
      if ( v48 != (v48 & 0xFFFFFFFFFFFFFFE0LL) )
      {
LABEL_97:
        v49 = (char *)v47;
        do
        {
          v55 = *v23++;
          *v49++ = v55;
        }
        while ( v23 != v24 );
      }
    }
    *v49 = 0;
    if ( (*(_BYTE *)a2 & 1) != 0 )
      a2[1] = v25;
    else
      *(_BYTE *)a2 = 2 * v25;
  }
  else
  {
    v20 = result;
    if ( (*(_BYTE *)a2 & 1) != 0 )
    {
      *(_BYTE *)a2[2] = 0;
      a2[1] = 0LL;
    }
    else
    {
      *(_WORD *)a2 = 0;
    }
    sub_6601820(a2, v11 - v8 + 48);
    v29 = *(unsigned __int8 *)a2;
    if ( (*a1 & 1) != 0 )
      v30 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    else
      v30 = a1 + 1;
    v31 = &v30[v8];
    v32 = &v30[v20];
    v33 = v20 - v8;
    if ( (v29 & 1) != 0 )
      v34 = (*a2 & 0xFFFFFFFFFFFFFFFELL) - 1;
    else
      v34 = 22LL;
    if ( v33 <= v34 )
    {
      v36 = *a2;
    }
    else
    {
      if ( (v29 & 1) != 0 )
        v35 = a2[1];
      else
        v35 = v29 >> 1;
      sub_68499C0(a2, v34, v33 - v34, v35, 0LL, v35, 0LL);
      v36 = *(_BYTE *)a2;
    }
    if ( (v36 & 1) != 0 )
      v37 = (unsigned __int8 *)a2[2];
    else
      v37 = (unsigned __int8 *)a2 + 1;
    v38 = v20 - v8;
    if ( v20 == v8 )
    {
      v39 = (char *)v37;
    }
    else
    {
      if ( v38 < 0x20 || v37 < v32 && v31 < &v37[v38] )
        goto LABEL_76;
      v39 = (char *)&v37[v38 & 0xFFFFFFFFFFFFFFE0LL];
      v31 += v38 & 0xFFFFFFFFFFFFFFE0LL;
      v40 = &v30[v8 + 16];
      v41 = v37 + 16;
      v42 = v38 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v43 = *((_OWORD *)v40 - 1);
        v44 = *(_OWORD *)v40;
        v40 += 32;
        v42 -= 32LL;
        *(v41 - 1) = v43;
        *v41 = v44;
        v41 += 2;
      }
      while ( v42 );
      v37 = (unsigned __int8 *)v39;
      if ( v38 != (v38 & 0xFFFFFFFFFFFFFFE0LL) )
      {
LABEL_76:
        v39 = (char *)v37;
        do
        {
          v45 = *v31++;
          *v39++ = v45;
        }
        while ( v31 != v32 );
      }
    }
    *v39 = 0;
    if ( (*(_BYTE *)a2 & 1) != 0 )
      a2[1] = v33;
    else
      *(_BYTE *)a2 = 2 * v33;
    if ( (*a1 & 1) != 0 )
      v46 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    else
      v46 = a1 + 1;
    return sub_62CF70C(a2, &v46[v20], v11 - v20);
  }
  return result;
}


================================================================================
Function: sub_62CBED4 (0x62CBED4)
================================================================================

unsigned __int64 *__usercall sub_62CBED4@<X0>(__int64 a1@<X0>, unsigned __int64 *a2@<X8>)
{
  return sub_68497A0(a2, (__int128 *)(a1 + 232));
}


================================================================================
Function: sub_62CBF28 (0x62CBF28)
================================================================================

__int64 __fastcall sub_62CBF28(int a1)
{
  return sub_65FF9FC(a1 + 280, "POST", 4uLL);
}


================================================================================
Function: sub_62CC248 (0x62CC248)
================================================================================

__int64 __fastcall sub_62CC248(__int64 a1)
{
  return sub_62AD454(*(_QWORD *)(*(_QWORD *)(a1 + 848) + 48LL), a1, 0.0);
}


================================================================================
Function: sub_62CC324 (0x62CC324)
================================================================================

__int64 __fastcall sub_62CC324(__int64 a1, unsigned int a2)
{
  if ( *(_DWORD *)(a1 + 464) == 6 )
    return 1LL;
  else
    return sub_62AD9E8(*(_QWORD *)(*(_QWORD *)(a1 + 848) + 48LL), a1, a2);
}


================================================================================
Function: sub_62CC38C (0x62CC38C)
================================================================================

__int64 __fastcall sub_62CC38C(__int64 a1, unsigned __int64 a2, unsigned __int8 *a3)
{
  __int64 result; // x0
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x10
  bool v10; // zf
  __int64 v11; // x8
  unsigned __int64 v12; // x23
  unsigned int v13; // w9
  unsigned __int8 *v14; // x10
  unsigned int v15; // w9
  unsigned __int64 v16; // x8
  unsigned int v17; // w0
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x8
  unsigned int v20; // w20
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x9
  unsigned __int8 *v23; // x8
  __int128 v24; // [xsp+0h] [xbp-80h] BYREF
  __int128 v25; // [xsp+10h] [xbp-70h]
  __int128 v26; // [xsp+20h] [xbp-60h]
  __int128 v27; // [xsp+30h] [xbp-50h]
  __int128 v28; // [xsp+40h] [xbp-40h]
  __int128 v29; // [xsp+50h] [xbp-30h]
  __int128 v30; // [xsp+60h] [xbp-20h]

  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v24 = 0u;
  result = ((__int64 (__fastcall *)(__int128 *, __int64, __int64, __int64, __int64, _QWORD, const char *, __int64))sub_67E09E4)(
             &v24,
             0xFFFFFFFFLL,
             8LL,
             31LL,
             8LL,
             0LL,
             "1.2.11",
             112LL);
  if ( !(_DWORD)result )
  {
    v7 = *a3;
    v8 = *((_QWORD *)a3 + 1);
    *(_QWORD *)&v24 = a1;
    v9 = v7 >> 1;
    v10 = (v7 & 1) == 0;
    v11 = a2 + 32;
    if ( v10 )
      v12 = v9;
    else
      v12 = v8;
    if ( a2 > 0x8000 )
      v11 = 0x8000LL;
    DWORD2(v24) = a2;
    sub_684A708(a3, v12 + v11, 0);
    while ( 1 )
    {
      v13 = *a3;
      v14 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
      v10 = (v13 & 1) == 0;
      v15 = v13 >> 1;
      v16 = *((_QWORD *)&v26 + 1) + v12;
      if ( v10 )
        v14 = a3 + 1;
      else
        v15 = *((_DWORD *)a3 + 2);
      *((_QWORD *)&v25 + 1) = &v14[v16];
      LODWORD(v26) = v15 - v16;
      v17 = sub_67E132C(&v24, 4LL);
      if ( v17 )
        break;
      v18 = *a3;
      if ( (v18 & 1) != 0 )
        v19 = *((_QWORD *)a3 + 1);
      else
        v19 = v18 >> 1;
      sub_684A708(a3, v19 + 0x8000, 0);
    }
    v20 = v17;
    if ( v17 == 1 )
    {
      sub_684A708(a3, *((_QWORD *)&v26 + 1) + v12, 0);
      v20 = 0;
    }
    LODWORD(result) = sub_67E0C84(&v24);
    if ( v20 | (unsigned int)result )
    {
      if ( v20 )
        return v20;
      else
        return (unsigned int)result;
    }
    else
    {
      v21 = *a3;
      v22 = *((_QWORD *)a3 + 1);
      if ( (v21 & 1) == 0 )
        v22 = v21 >> 1;
      if ( v22 >= v12 + 10 )
      {
        result = 0LL;
        if ( (v21 & 1) != 0 )
          v23 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
        else
          v23 = a3 + 1;
        v23[v12 + 9] = -1;
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62CC678 (0x62CC678)
================================================================================

__int64 __fastcall sub_62CC678(__int64 a1, unsigned __int8 *a2, char a3)
{
  size_t v3; // x10
  unsigned __int64 v5; // x8
  bool v6; // zf
  size_t v7; // x8
  void *v8; // x1
  size_t v9; // x2
  unsigned __int64 v11; // x8
  size_t v12; // x8
  __int64 result; // x0
  void *src; // [xsp+0h] [xbp-40h] BYREF
  size_t n; // [xsp+8h] [xbp-38h]
  _QWORD v16[5]; // [xsp+10h] [xbp-30h] BYREF

  v3 = *((_QWORD *)a2 + 1);
  v5 = *a2;
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
    v8 = a2 + 1;
  else
    v8 = (void *)*((_QWORD *)a2 + 2);
  if ( v6 )
    v9 = v7;
  else
    v9 = v3;
  src = v8;
  n = v9;
  if ( (a3 & 1) == 0 )
    goto LABEL_21;
  if ( !byte_724A7A8 || !byte_724A758 )
  {
    if ( !(_BYTE)qword_6FF3A50 )
      goto LABEL_15;
    goto LABEL_14;
  }
  if ( (unsigned __int8)qword_6FF3A50 >= 6u && (qword_6FF3A50 & 0xFC00) != 0 )
  {
LABEL_14:
    v16[0] = a1;
    v16[1] = 0LL;
    v16[2] = &src;
    v16[3] = sub_256CCD4;
    sub_65C5CFC(
      qword_6FF3A50,
      qword_6FF3A58,
      4u,
      "[DFLog::DebugHttpTrace] HttpRequestCurl({}): Uncompressed post data: {}",
      71LL,
      254LL,
      (__int64)v16,
      1);
    v8 = src;
    v9 = n;
  }
LABEL_15:
  if ( (unsigned int)sub_62CC38C(v8, v9, a1 + 304) )
  {
    v9 = n;
  }
  else
  {
    v11 = *(unsigned __int8 *)(a1 + 304);
    v9 = n;
    if ( (v11 & 1) != 0 )
      v12 = *(_QWORD *)(a1 + 312);
    else
      v12 = v11 >> 1;
    if ( v12 <= n )
    {
      result = sub_62CAF24(a1, "Content-Encoding", 0x10uLL, "gzip", 4uLL);
      *(_BYTE *)(a1 + 410) = 1;
      goto LABEL_22;
    }
  }
LABEL_21:
  result = sub_65FF9FC((int)a1 + 304, src, v9);
LABEL_22:
  *(_BYTE *)(a1 + 409) = 1;
  return result;
}


================================================================================
Function: sub_62CEFD0 (0x62CEFD0)
================================================================================

__int64 __fastcall sub_62CEFD0(__int64 a1)
{
  __int64 v2; // x0

  v2 = sub_62A21C0();
  return sub_25BD18C(v2, a1);
}


================================================================================
Function: sub_62CF70C (0x62CF70C)
================================================================================

unsigned __int64 *__fastcall sub_62CF70C(unsigned __int64 *result, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v4; // x19
  unsigned __int64 *v5; // x20
  unsigned __int64 v6; // x23
  unsigned __int64 v7; // x8
  unsigned __int8 *v8; // x9
  int v9; // t1
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x1
  char v13; // w9
  char s[4]; // [xsp+4h] [xbp-Ch] BYREF

  v4 = a2;
  v5 = result;
  v6 = (unsigned __int64)&a2[a3];
  v7 = a3;
  strcpy(s, "%00");
  if ( a3 > 4096 )
  {
    v8 = a2;
    v7 = a3;
    do
    {
      v9 = *v8++;
      if ( (unsigned int)(v9 - 127) < 0xFFFFFFA2 )
        v7 += 2LL;
    }
    while ( (unsigned __int64)v8 < v6 );
  }
  v10 = *(unsigned __int8 *)result;
  if ( (v10 & 1) != 0 )
    v11 = result[1];
  else
    v11 = v10 >> 1;
  if ( v7 < ~v11 )
  {
    result = sub_6601820(result, v11 + v7);
    if ( a3 >= 1 )
    {
      do
      {
        v12 = *v4;
        if ( (unsigned __int8)(v12 - 127) > 0xA1u )
        {
          result = sub_6601588(v5, v12);
        }
        else
        {
          v13 = a0123456789abcd[v12 & 0xF];
          s[1] = a0123456789abcd[v12 >> 4];
          s[2] = v13;
          result = sub_684A544(v5, s);
        }
        ++v4;
      }
      while ( (unsigned __int64)v4 < v6 );
    }
  }
  return result;
}


================================================================================
Function: sub_62D09F0 (0x62D09F0)
================================================================================

void __fastcall __noreturn sub_62D09F0(_QWORD *a1, unsigned int *a2)
{
  __int64 v4; // x8
  _QWORD *v5; // [xsp+8h] [xbp-28h]

  v5 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)*a1 + 16LL))(*a1, 944LL, 16LL);
  v4 = *a1;
  v5[1] = 0LL;
  v5[2] = 0LL;
  v5[4] = v4;
  *v5 = off_6C1DC18;
  sub_62D2730(v5 + 6, *a2);
}


================================================================================
Function: sub_62D0CE0 (0x62D0CE0)
================================================================================

unsigned __int64 __usercall sub_62D0CE0@<X0>(unsigned __int64 *a1@<X0>, unsigned int *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int64 *v6; // x19
  unsigned __int64 v7; // x8
  unsigned __int64 *v8; // x20
  unsigned __int64 result; // x0
  unsigned __int64 *v10; // x22

  v6 = (unsigned __int64 *)(*(__int64 (__fastcall **)(unsigned __int64, __int64, __int64))(*(_QWORD *)*a1 + 16LL))(
                             *a1,
                             1280LL,
                             16LL);
  v7 = *a1;
  v6[1] = 0LL;
  v6[2] = 0LL;
  v8 = v6 + 6;
  v6[4] = v7;
  *v6 = (unsigned __int64)off_6C1DCB8;
  result = sub_62F2420(v6 + 6, *a2);
  v10 = (unsigned __int64 *)v6[8];
  *a3 = v6 + 6;
  a3[1] = v6;
  if ( v10 )
  {
    if ( v10[1] != -1LL )
      return result;
    sub_6867420(1uLL, (atomic_ullong *)(v6 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v6 + 2));
    v6[7] = (unsigned __int64)v8;
    v6[8] = (unsigned __int64)v6;
    sub_68488BC(v10);
  }
  else
  {
    sub_6867420(1uLL, (atomic_ullong *)(v6 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v6 + 2));
    v6[7] = (unsigned __int64)v8;
    v6[8] = (unsigned __int64)v6;
  }
  result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v6 + 1));
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v6 + 16))(v6);
    return sub_68488BC(v6);
  }
  return result;
}


================================================================================
Function: sub_62D2728 (0x62D2728)
================================================================================

__int64 sub_62D2728()
{
  return 0LL;
}


================================================================================
Function: sub_62D2730 (0x62D2730)
================================================================================

void __fastcall __noreturn sub_62D2730(_QWORD *a1)
{
  sub_62CAC2C();
  a1[109] = 0LL;
  *a1 = off_6C1DFC0;
  sub_65F12C8("IXMLHTTPRequest2 is not available");
}


================================================================================
Function: sub_62D4E7C (0x62D4E7C)
================================================================================

__int64 __fastcall sub_62D4E7C(__int64 a1)
{
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 40) = a1 + 48;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  sub_25BABCC(a1 + 88);
  *(_BYTE *)(a1 + 400) = 0;
  return sub_62D4F2C(a1);
}


================================================================================
Function: sub_62D4F2C (0x62D4F2C)
================================================================================

_QWORD *__fastcall sub_62D4F2C(__int64 a1)
{
  __int64 **v2; // x22
  __int64 v3; // x24
  __int64 *v4; // x20
  int v5; // w8
  __int64 v6; // x1
  __int64 v7; // x9
  __int64 v8; // x10
  __int64 v9; // x8
  unsigned __int64 *v10; // x20
  _QWORD *result; // x0
  __int64 *v12; // x8
  __int64 *v13; // x20
  int v14; // w9
  __int64 *v15; // x9
  __int64 v16; // x1
  __int64 v17; // x9
  __int64 v18; // x10
  __int64 v19; // x8
  unsigned __int64 *v20; // x19
  const char *v21; // [xsp+8h] [xbp-28h] BYREF
  __int64 v22; // [xsp+10h] [xbp-20h]
  __int64 v23; // [xsp+18h] [xbp-18h] BYREF
  __int64 v24; // [xsp+20h] [xbp-10h]

  v21 = "exponential";
  v22 = 11LL;
  sub_62DC15C(&v23, &v21, 0xFFFFFFFFLL, -1.0);
  v2 = (__int64 **)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 48);
  if ( v3 )
  {
    v4 = (__int64 *)(a1 + 48);
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(v3 + 32);
        if ( v5 >= 430 )
          break;
        if ( v5 == 429 )
          goto LABEL_10;
        v4 = (__int64 *)(v3 + 8);
        if ( !*(_QWORD *)(v3 + 8) )
          goto LABEL_10;
        v3 = *(_QWORD *)(v3 + 8);
      }
      if ( !*(_QWORD *)v3 )
        break;
      v4 = (__int64 *)v3;
      v3 = *(_QWORD *)v3;
    }
    v4 = (__int64 *)v3;
    goto LABEL_11;
  }
  v3 = a1 + 48;
  v4 = (__int64 *)(a1 + 48);
LABEL_10:
  if ( !*v4 )
  {
LABEL_11:
    v6 = sub_65ECAAC();
    v7 = v23;
    v8 = v24;
    v23 = 0LL;
    v24 = 0LL;
    *(_QWORD *)v6 = 0LL;
    *(_QWORD *)(v6 + 8) = 0LL;
    *(_QWORD *)(v6 + 16) = v3;
    *(_DWORD *)(v6 + 32) = 429;
    *(_QWORD *)(v6 + 40) = v7;
    *(_QWORD *)(v6 + 48) = v8;
    *v4 = v6;
    v9 = **(_QWORD **)(a1 + 40);
    if ( v9 )
    {
      *(_QWORD *)(a1 + 40) = v9;
      v6 = *v4;
    }
    sub_2527820(*(_QWORD *)(a1 + 48), v6);
    ++*(_QWORD *)(a1 + 56);
  }
  v10 = (unsigned __int64 *)v24;
  if ( v24 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v10 + 16))(v10);
    sub_68488BC(v10);
  }
  v21 = "exponential";
  v22 = 11LL;
  result = sub_62DC15C(&v23, &v21, 0xFFFFFFFFLL, -1.0);
  v12 = *v2;
  if ( *v2 )
  {
    v13 = (__int64 *)(a1 + 48);
    while ( 1 )
    {
      v14 = *((_DWORD *)v12 + 8);
      if ( v14 < 504 )
      {
        if ( v14 == 503 || (v13 = v12 + 1, (v15 = (__int64 *)v12[1]) == 0LL) )
        {
          v2 = (__int64 **)v12;
          if ( *v13 )
            goto LABEL_33;
          goto LABEL_30;
        }
      }
      else
      {
        v15 = (__int64 *)*v12;
        if ( !*v12 )
        {
          v2 = (__int64 **)v12;
          v13 = v12;
          goto LABEL_30;
        }
        v13 = v12;
      }
      v12 = v15;
    }
  }
  v13 = (__int64 *)(a1 + 48);
LABEL_30:
  v16 = sub_65ECAAC();
  v17 = v23;
  v18 = v24;
  v23 = 0LL;
  v24 = 0LL;
  *(_QWORD *)v16 = 0LL;
  *(_QWORD *)(v16 + 8) = 0LL;
  *(_QWORD *)(v16 + 16) = v2;
  *(_DWORD *)(v16 + 32) = 503;
  *(_QWORD *)(v16 + 40) = v17;
  *(_QWORD *)(v16 + 48) = v18;
  *v13 = v16;
  v19 = **(_QWORD **)(a1 + 40);
  if ( v19 )
  {
    *(_QWORD *)(a1 + 40) = v19;
    v16 = *v13;
  }
  result = (_QWORD *)sub_2527820(*(_QWORD *)(a1 + 48), v16);
  ++*(_QWORD *)(a1 + 56);
LABEL_33:
  v20 = (unsigned __int64 *)v24;
  if ( v24 )
  {
    result = (_QWORD *)sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v20 + 16))(v20);
      return (_QWORD *)sub_68488BC(v20);
    }
  }
  return result;
}


================================================================================
Function: sub_62D73C0 (0x62D73C0)
================================================================================

_QWORD *__fastcall sub_62D73C0(__int64 a1)
{
  _BYTE v3[56]; // [xsp+0h] [xbp-40h] BYREF

  *(_QWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  sub_62D4E7C(a1 + 32);
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 440), 0LL) )
  {
    sub_25C1BEC(v3);
    sub_25C1ABC((__int64)v3);
  }
  return sub_649F0D0((_QWORD *)(a1 + 480));
}


================================================================================
Function: sub_62DC15C (0x62DC15C)
================================================================================

_QWORD *__usercall sub_62DC15C@<X0>(__int64 a1@<X0>, int a2@<W1>, unsigned __int64 *a3@<X8>, double a4@<D0>)
{
  _QWORD *v6; // x0
  __int64 v7; // x2
  _QWORD *result; // x0
  size_t v10; // x9
  size_t v11; // x21
  __int64 v12; // x22
  __int64 v13; // x23
  _QWORD *v14; // x20
  char *v15; // x24
  size_t v16; // x9
  unsigned __int64 v17; // [xsp+0h] [xbp-30h] BYREF
  size_t v18; // [xsp+8h] [xbp-28h]
  char *v19; // [xsp+10h] [xbp-20h]
  int v20; // [xsp+1Ch] [xbp-14h] BYREF
  double v21; // [xsp+20h] [xbp-10h] BYREF

  v6 = *(_QWORD **)a1;
  v7 = *(_QWORD *)(a1 + 8);
  v21 = a4;
  v20 = a2;
  *a3 = 0LL;
  a3[1] = 0LL;
  if ( v7 == 6 )
  {
    if ( !memcmp(v6, "linear", 6uLL) )
    {
      result = sub_62DC584(&v17, &v21, &v20);
      goto LABEL_21;
    }
  }
  else if ( v7 == 11 && !(*v6 ^ 0x746E656E6F707865LL | *(_QWORD *)((char *)v6 + 3) ^ 0x6C6169746E656E6FLL) )
  {
    result = sub_62DC3B4(&v17, &v21, &v20);
LABEL_21:
    v16 = v18;
    *a3 = v17;
    a3[1] = v16;
    return result;
  }
  result = sub_62DC754(&v17);
  v10 = v18;
  v11 = *(_QWORD *)(a1 + 8);
  *a3 = v17;
  a3[1] = v10;
  if ( v11 != 4 || **(_DWORD **)a1 != 1701736302 )
  {
    v12 = qword_724A658;
    v13 = qword_724A660;
    if ( byte_724A7A8 && byte_724A758 )
    {
      if ( (unsigned __int8)qword_724A658 < 6u || BYTE1(qword_724A658) < 3u )
        return result;
    }
    else if ( !(_BYTE)qword_724A658 )
    {
      return result;
    }
    v14 = *(_QWORD **)a1;
    if ( !v14 )
    {
      v17 = 0LL;
      v18 = 0LL;
      v19 = 0LL;
      goto LABEL_25;
    }
    if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_6849630();
    if ( v11 >= 0x17 )
    {
      v15 = (char *)sub_65ECAAC();
      v18 = v11;
      v19 = v15;
      v17 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v15 = (char *)&v17 + 1;
      LOBYTE(v17) = 2 * v11;
      if ( !v11 )
        goto LABEL_24;
    }
    memcpy(v15, v14, v11);
LABEL_24:
    v15[v11] = 0;
LABEL_25:
    result = (_QWORD *)sub_65C61C8(
                         v12,
                         v13,
                         "[FLog::Error] RetryPolicyOverrides: Unknown retry strategy '%s'",
                         (const char *)&v17);
    if ( (v17 & 1) != 0 )
      return (_QWORD *)sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_62DC3B4 (0x62DC3B4)
================================================================================

unsigned __int64 __usercall sub_62DC3B4@<X0>(__int64 *a1@<X0>, _DWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  bool v6; // zf
  __int64 v7; // x0
  __int64 v8; // d0
  unsigned __int64 *v9; // x19
  atomic_ullong *v10; // x20
  __int64 v11; // x8
  __int64 v12; // x0
  unsigned __int64 result; // x0
  unsigned __int64 *v14; // x24
  unsigned __int64 *v15; // x22
  _QWORD v16[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v17; // [xsp+20h] [xbp-20h]

  if ( byte_724A7A8 )
    v6 = byte_7301120 == 0;
  else
    v6 = 1;
  if ( !v6 )
  {
    v12 = sub_680599C();
    return sub_62DCC40(v12, a1, a2);
  }
  v7 = sub_65ECAAC();
  v8 = *a1;
  v9 = (unsigned __int64 *)v7;
  *(_DWORD *)(v7 + 56) = *a2;
  *(_QWORD *)(v7 + 16) = 0LL;
  *(_QWORD *)v7 = off_6C1E330;
  *(_QWORD *)(v7 + 40) = 0LL;
  *(_QWORD *)(v7 + 48) = v8;
  *(_QWORD *)(v7 + 96) = 0LL;
  *(_QWORD *)(v7 + 8) = 0LL;
  v10 = (atomic_ullong *)(v7 + 8);
  *(_QWORD *)(v7 + 32) = 0LL;
  v16[0] = off_6C1E1E0;
  v16[1] = v7 + 32;
  v17 = v16;
  sub_62DC994(v16, v7 + 64);
  result = (unsigned __int64)v17;
  if ( v16 == v17 )
  {
    v11 = 4LL;
  }
  else
  {
    if ( !v17 )
      goto LABEL_11;
    v11 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v17 + 8 * v11))();
LABEL_11:
  v14 = v9 + 4;
  v15 = (unsigned __int64 *)v9[5];
  *a3 = v9 + 4;
  a3[1] = v9;
  if ( v15 )
  {
    if ( v15[1] != -1LL )
      return result;
    sub_6867420(1uLL, (atomic_ullong *)(v9 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v9 + 2));
    v9[4] = (unsigned __int64)v14;
    v9[5] = (unsigned __int64)v9;
    sub_68488BC(v15);
  }
  else
  {
    sub_6867420(1uLL, (atomic_ullong *)(v9 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v9 + 2));
    v9[4] = (unsigned __int64)v14;
    v9[5] = (unsigned __int64)v9;
  }
  result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, v10);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v9 + 16))(v9);
    return sub_68488BC(v9);
  }
  return result;
}


================================================================================
Function: sub_62DC584 (0x62DC584)
================================================================================

unsigned __int64 __usercall sub_62DC584@<X0>(__int64 *a1@<X0>, _DWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  bool v6; // zf
  __int64 v7; // x0
  __int64 v8; // d0
  unsigned __int64 *v9; // x19
  atomic_ullong *v10; // x20
  __int64 v11; // x8
  __int64 v12; // x0
  unsigned __int64 result; // x0
  unsigned __int64 *v14; // x24
  unsigned __int64 *v15; // x22
  _QWORD v16[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v17; // [xsp+20h] [xbp-20h]

  if ( byte_724A7A8 )
    v6 = byte_7301120 == 0;
  else
    v6 = 1;
  if ( !v6 )
  {
    v12 = sub_680599C();
    return sub_62DD058(v12, a1, a2);
  }
  v7 = sub_65ECAAC();
  v8 = *a1;
  v9 = (unsigned __int64 *)v7;
  *(_DWORD *)(v7 + 56) = *a2;
  *(_QWORD *)(v7 + 16) = 0LL;
  *(_QWORD *)v7 = off_6C1E3D0;
  *(_QWORD *)(v7 + 40) = 0LL;
  *(_QWORD *)(v7 + 48) = v8;
  *(_QWORD *)(v7 + 96) = 0LL;
  *(_QWORD *)(v7 + 8) = 0LL;
  v10 = (atomic_ullong *)(v7 + 8);
  *(_QWORD *)(v7 + 32) = 0LL;
  v16[0] = off_6C1E150;
  v16[1] = v7 + 32;
  v17 = v16;
  sub_62DC994(v16, v7 + 64);
  result = (unsigned __int64)v17;
  if ( v16 == v17 )
  {
    v11 = 4LL;
  }
  else
  {
    if ( !v17 )
      goto LABEL_11;
    v11 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v17 + 8 * v11))();
LABEL_11:
  v14 = v9 + 4;
  v15 = (unsigned __int64 *)v9[5];
  *a3 = v9 + 4;
  a3[1] = v9;
  if ( v15 )
  {
    if ( v15[1] != -1LL )
      return result;
    sub_6867420(1uLL, (atomic_ullong *)(v9 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v9 + 2));
    v9[4] = (unsigned __int64)v14;
    v9[5] = (unsigned __int64)v9;
    sub_68488BC(v15);
  }
  else
  {
    sub_6867420(1uLL, (atomic_ullong *)(v9 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v9 + 2));
    v9[4] = (unsigned __int64)v14;
    v9[5] = (unsigned __int64)v9;
  }
  result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, v10);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v9 + 16))(v9);
    return sub_68488BC(v9);
  }
  return result;
}


================================================================================
Function: sub_62DC754 (0x62DC754)
================================================================================

unsigned __int64 __usercall sub_62DC754@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  unsigned __int64 *v3; // x19
  __int64 v4; // x8
  unsigned __int64 result; // x0
  unsigned __int64 *v6; // x24
  unsigned __int64 *v7; // x22
  _QWORD v8[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v9; // [xsp+20h] [xbp-20h]

  if ( byte_724A7A8 )
    v2 = byte_7301120 == 0;
  else
    v2 = 1;
  if ( !v2 )
  {
    v8[0] = sub_680599C();
    return sub_62DD470(v8);
  }
  v3 = (unsigned __int64 *)sub_65ECAAC();
  v3[2] = 0LL;
  v3[6] = 0xBFF0000000000000LL;
  *v3 = (unsigned __int64)off_6C1E470;
  v3[4] = 0LL;
  v3[5] = 0LL;
  *((_DWORD *)v3 + 14) = 0;
  v3[12] = 0LL;
  v3[1] = 0LL;
  v8[0] = off_6C1E260;
  v9 = v8;
  sub_62DC994(v8, v3 + 8);
  result = (unsigned __int64)v9;
  if ( v8 == v9 )
  {
    v4 = 4LL;
  }
  else
  {
    if ( !v9 )
      goto LABEL_11;
    v4 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v9 + 8 * v4))();
LABEL_11:
  v6 = v3 + 4;
  v7 = (unsigned __int64 *)v3[5];
  *a1 = v3 + 4;
  a1[1] = v3;
  if ( v7 )
  {
    if ( v7[1] != -1LL )
      return result;
    sub_6867420(1uLL, (atomic_ullong *)(v3 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v3 + 2));
    v3[4] = (unsigned __int64)v6;
    v3[5] = (unsigned __int64)v3;
    sub_68488BC(v7);
  }
  else
  {
    sub_6867420(1uLL, (atomic_ullong *)(v3 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v3 + 2));
    v3[4] = (unsigned __int64)v6;
    v3[5] = (unsigned __int64)v3;
  }
  result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v3 + 1));
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v3 + 16))(v3);
    return sub_68488BC(v3);
  }
  return result;
}


================================================================================
Function: sub_62DC994 (0x62DC994)
================================================================================

_QWORD *__fastcall sub_62DC994(_QWORD *result, __int64 a2)
{
  _QWORD *v2; // x20
  __int64 v4; // x8
  __int64 v5; // x8
  _QWORD v6[5]; // [xsp+0h] [xbp-30h] BYREF

  if ( (_QWORD *)a2 != result )
  {
    v2 = result;
    result = (_QWORD *)result[4];
    if ( result == v2 )
    {
      if ( *(_QWORD *)(a2 + 32) == a2 )
      {
        (*(void (__fastcall **)(_QWORD *, _QWORD *))(*result + 24LL))(result, v6);
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v2[4] + 32LL))(v2[4]);
        v2[4] = 0LL;
        (*(void (__fastcall **)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 32) + 24LL))(*(_QWORD *)(a2 + 32), v2);
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 32) + 32LL))(*(_QWORD *)(a2 + 32));
        v5 = v6[0];
        *(_QWORD *)(a2 + 32) = 0LL;
        v2[4] = v2;
        (*(void (__fastcall **)(_QWORD *, __int64))(v5 + 24))(v6, a2);
        result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD *))(v6[0] + 32LL))(v6);
      }
      else
      {
        (*(void (__fastcall **)(_QWORD *, __int64))(*result + 24LL))(result, a2);
        result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v2[4] + 32LL))(v2[4]);
        v2[4] = *(_QWORD *)(a2 + 32);
      }
      *(_QWORD *)(a2 + 32) = a2;
    }
    else
    {
      v4 = *(_QWORD *)(a2 + 32);
      if ( a2 == v4 )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)v4 + 24LL))(*(_QWORD *)(a2 + 32), v2);
        result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 32) + 32LL))(*(_QWORD *)(a2 + 32));
        *(_QWORD *)(a2 + 32) = v2[4];
        v2[4] = v2;
      }
      else
      {
        v2[4] = v4;
        *(_QWORD *)(a2 + 32) = result;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62DCC40 (0x62DCC40)
================================================================================

unsigned __int64 __usercall sub_62DCC40@<X0>(__int64 a1@<X0>, __int64 *a2@<X1>, int *a3@<X2>, __int64 *a4@<X8>)
{
  __int64 v8; // x0
  atomic_ullong *v9; // x20
  unsigned __int64 *v10; // x19
  __int64 v11; // d0
  int v12; // w8
  __int64 v13; // x24
  unsigned __int64 result; // x0
  __int64 v15; // x8
  unsigned __int64 *v16; // x22
  _QWORD v17[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v18; // [xsp+20h] [xbp-20h]

  v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 16LL))(a1, 128LL, 16LL);
  *(_QWORD *)(v8 + 16) = 0LL;
  *(_QWORD *)(v8 + 32) = a1;
  *(_QWORD *)(v8 + 8) = 0LL;
  v9 = (atomic_ullong *)(v8 + 8);
  *(_QWORD *)v8 = off_6C1E2E0;
  v10 = (unsigned __int64 *)v8;
  v11 = *a2;
  v12 = *a3;
  *(_QWORD *)(v8 + 56) = 0LL;
  *(_QWORD *)(v8 + 112) = 0LL;
  *(_QWORD *)(v8 + 64) = v11;
  *(_DWORD *)(v8 + 72) = v12;
  *(_QWORD *)(v8 + 48) = 0LL;
  v13 = v8 + 48;
  v17[0] = off_6C1E1E0;
  v17[1] = v8 + 48;
  v18 = v17;
  sub_62DC994(v17, v8 + 80);
  result = (unsigned __int64)v18;
  if ( v17 == v18 )
  {
    v15 = 4LL;
  }
  else
  {
    if ( !v18 )
      goto LABEL_6;
    v15 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v18 + 8 * v15))();
LABEL_6:
  v16 = (unsigned __int64 *)v10[7];
  *a4 = v13;
  a4[1] = (__int64)v10;
  if ( v16 )
  {
    if ( v16[1] != -1LL )
      return result;
    sub_6867420(1uLL, (atomic_ullong *)(v10 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v10 + 2));
    v10[6] = v13;
    v10[7] = (unsigned __int64)v10;
    sub_68488BC(v16);
  }
  else
  {
    sub_6867420(1uLL, (atomic_ullong *)(v10 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v10 + 2));
    v10[6] = v13;
    v10[7] = (unsigned __int64)v10;
  }
  result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, v9);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v10 + 16))(v10);
    return sub_68488BC(v10);
  }
  return result;
}


================================================================================
Function: sub_62DD058 (0x62DD058)
================================================================================

unsigned __int64 __usercall sub_62DD058@<X0>(__int64 a1@<X0>, __int64 *a2@<X1>, int *a3@<X2>, __int64 *a4@<X8>)
{
  __int64 v8; // x0
  atomic_ullong *v9; // x20
  unsigned __int64 *v10; // x19
  __int64 v11; // d0
  int v12; // w8
  __int64 v13; // x24
  unsigned __int64 result; // x0
  __int64 v15; // x8
  unsigned __int64 *v16; // x22
  _QWORD v17[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v18; // [xsp+20h] [xbp-20h]

  v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 16LL))(a1, 128LL, 16LL);
  *(_QWORD *)(v8 + 16) = 0LL;
  *(_QWORD *)(v8 + 32) = a1;
  *(_QWORD *)(v8 + 8) = 0LL;
  v9 = (atomic_ullong *)(v8 + 8);
  *(_QWORD *)v8 = off_6C1E380;
  v10 = (unsigned __int64 *)v8;
  v11 = *a2;
  v12 = *a3;
  *(_QWORD *)(v8 + 56) = 0LL;
  *(_QWORD *)(v8 + 112) = 0LL;
  *(_QWORD *)(v8 + 64) = v11;
  *(_DWORD *)(v8 + 72) = v12;
  *(_QWORD *)(v8 + 48) = 0LL;
  v13 = v8 + 48;
  v17[0] = off_6C1E150;
  v17[1] = v8 + 48;
  v18 = v17;
  sub_62DC994(v17, v8 + 80);
  result = (unsigned __int64)v18;
  if ( v17 == v18 )
  {
    v15 = 4LL;
  }
  else
  {
    if ( !v18 )
      goto LABEL_6;
    v15 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v18 + 8 * v15))();
LABEL_6:
  v16 = (unsigned __int64 *)v10[7];
  *a4 = v13;
  a4[1] = (__int64)v10;
  if ( v16 )
  {
    if ( v16[1] != -1LL )
      return result;
    sub_6867420(1uLL, (atomic_ullong *)(v10 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v10 + 2));
    v10[6] = v13;
    v10[7] = (unsigned __int64)v10;
    sub_68488BC(v16);
  }
  else
  {
    sub_6867420(1uLL, (atomic_ullong *)(v10 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v10 + 2));
    v10[6] = v13;
    v10[7] = (unsigned __int64)v10;
  }
  result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, v9);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v10 + 16))(v10);
    return sub_68488BC(v10);
  }
  return result;
}


================================================================================
Function: sub_62DD470 (0x62DD470)
================================================================================

unsigned __int64 __usercall sub_62DD470@<X0>(_QWORD *a1@<X0>, __int64 *a2@<X8>)
{
  __int64 v4; // x0
  __int64 v5; // x8
  unsigned __int64 *v6; // x19
  atomic_ullong *v7; // x20
  __int64 v8; // x24
  unsigned __int64 result; // x0
  __int64 v10; // x8
  unsigned __int64 *v11; // x22
  _QWORD v12[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v13; // [xsp+20h] [xbp-20h]

  v4 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)*a1 + 16LL))(*a1, 128LL, 16LL);
  v5 = *a1;
  v6 = (unsigned __int64 *)v4;
  *(_QWORD *)(v4 + 16) = 0LL;
  *(_QWORD *)(v4 + 32) = v5;
  *(_QWORD *)v4 = off_6C1E420;
  *(_DWORD *)(v4 + 72) = 0;
  *(_QWORD *)(v4 + 56) = 0LL;
  *(_QWORD *)(v4 + 64) = 0xBFF0000000000000LL;
  *(_QWORD *)(v4 + 112) = 0LL;
  *(_QWORD *)(v4 + 8) = 0LL;
  v7 = (atomic_ullong *)(v4 + 8);
  *(_QWORD *)(v4 + 48) = 0LL;
  v8 = v4 + 48;
  v12[0] = off_6C1E260;
  v13 = v12;
  sub_62DC994(v12, v4 + 80);
  result = (unsigned __int64)v13;
  if ( v12 == v13 )
  {
    v10 = 4LL;
  }
  else
  {
    if ( !v13 )
      goto LABEL_6;
    v10 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v13 + 8 * v10))();
LABEL_6:
  v11 = (unsigned __int64 *)v6[7];
  *a2 = v8;
  a2[1] = (__int64)v6;
  if ( v11 )
  {
    if ( v11[1] != -1LL )
      return result;
    sub_6867420(1uLL, (atomic_ullong *)(v6 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v6 + 2));
    v6[6] = v8;
    v6[7] = (unsigned __int64)v6;
    sub_68488BC(v11);
  }
  else
  {
    sub_6867420(1uLL, (atomic_ullong *)(v6 + 1));
    sub_6867420(1uLL, (atomic_ullong *)(v6 + 2));
    v6[6] = v8;
    v6[7] = (unsigned __int64)v6;
  }
  result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, v7);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v6 + 16))(v6);
    return sub_68488BC(v6);
  }
  return result;
}


================================================================================
Function: sub_62E35C8 (0x62E35C8)
================================================================================

__int64 __fastcall sub_62E35C8(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x19
  __int64 v4; // x20
  char v5; // t1
  __int64 v6; // x19
  __int64 v7; // x20
  char v8; // t1
  __int64 v9; // x19
  __int64 v10; // x20
  char v11; // t1
  unsigned __int64 *v12; // x19
  unsigned __int64 *v13; // x20
  char v14; // t1
  unsigned __int64 *v15; // x19
  unsigned __int64 *v16; // x20
  char v17; // t1
  unsigned __int64 *v18; // x19
  unsigned __int64 *v19; // x20
  char v20; // t1
  unsigned __int64 *v21; // [xsp+8h] [xbp-2A8h] BYREF
  unsigned __int64 *v22; // [xsp+10h] [xbp-2A0h]
  unsigned __int64 *v23; // [xsp+18h] [xbp-298h]
  int v24; // [xsp+20h] [xbp-290h]
  __int128 v25; // [xsp+28h] [xbp-288h] BYREF
  unsigned __int64 *v26; // [xsp+40h] [xbp-270h] BYREF
  unsigned __int64 *v27; // [xsp+48h] [xbp-268h]
  unsigned __int64 *v28; // [xsp+50h] [xbp-260h]
  int v29; // [xsp+58h] [xbp-258h]
  __int128 v30; // [xsp+60h] [xbp-250h] BYREF
  unsigned __int64 *v31; // [xsp+78h] [xbp-238h] BYREF
  unsigned __int64 *v32; // [xsp+80h] [xbp-230h]
  unsigned __int64 *v33; // [xsp+88h] [xbp-228h]
  int v34; // [xsp+90h] [xbp-220h]
  _BYTE v35[17]; // [xsp+98h] [xbp-218h] BYREF
  __int128 v36; // [xsp+B0h] [xbp-200h] BYREF
  char *v37; // [xsp+C0h] [xbp-1F0h]
  char v38; // [xsp+C8h] [xbp-1E8h] BYREF
  __int128 v39; // [xsp+C9h] [xbp-1E7h]
  int v40; // [xsp+D9h] [xbp-1D7h]
  char v41; // [xsp+DDh] [xbp-1D3h]
  __int128 v42; // [xsp+E0h] [xbp-1D0h] BYREF
  char *v43; // [xsp+F0h] [xbp-1C0h]
  __int128 v44; // [xsp+F8h] [xbp-1B8h] BYREF
  __int128 v45; // [xsp+110h] [xbp-1A0h] BYREF
  char *v46; // [xsp+120h] [xbp-190h]
  __int128 v47; // [xsp+128h] [xbp-188h] BYREF
  char *v48; // [xsp+138h] [xbp-178h]
  __int128 v49; // [xsp+140h] [xbp-170h] BYREF
  _BYTE v50[24]; // [xsp+160h] [xbp-150h] BYREF
  _BYTE v51[24]; // [xsp+178h] [xbp-138h] BYREF
  char v52[24]; // [xsp+190h] [xbp-120h] BYREF
  _BYTE v53[24]; // [xsp+1A8h] [xbp-108h] BYREF
  __int128 v54; // [xsp+1C0h] [xbp-F0h] BYREF
  char *v55; // [xsp+1D0h] [xbp-E0h]
  __int128 v56; // [xsp+1D8h] [xbp-D8h] BYREF
  _OWORD v57[2]; // [xsp+1F0h] [xbp-C0h] BYREF
  __int128 v58; // [xsp+210h] [xbp-A0h] BYREF
  __int128 v59; // [xsp+220h] [xbp-90h]
  unsigned __int64 v60; // [xsp+230h] [xbp-80h] BYREF
  __int64 v61; // [xsp+238h] [xbp-78h] BYREF
  __int64 v62; // [xsp+248h] [xbp-68h] BYREF
  __int64 v63; // [xsp+250h] [xbp-60h]
  int v64; // [xsp+260h] [xbp-50h]
  unsigned __int64 v65; // [xsp+268h] [xbp-48h] BYREF
  __int64 v66; // [xsp+280h] [xbp-30h] BYREF
  __int64 v67; // [xsp+288h] [xbp-28h]
  _QWORD v68[3]; // [xsp+298h] [xbp-18h] BYREF

  *(_QWORD *)(a1 + 32) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_25BABCC(a1 + 40);
  *(_WORD *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_DWORD *)(a1 + 408) = 1065353216;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_DWORD *)(a1 + 448) = 1065353216;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_DWORD *)(a1 + 488) = 1065353216;
  sub_62E701C(a1 + 416, 0LL, 0LL);
  v58 = xmmword_6C1ED30;
  v59 = *(_OWORD *)&off_6C1ED40;
  v60 = (unsigned __int64)&dword_0 + 2;
  v57[0] = off_6C1ED10;
  v57[1] = unk_6C1ED20;
  sub_62E88FC(a1 + 376, v57, &v61);
  v34 = 429;
  v35[0] = 30;
  strcpy(&v35[1], "gamepersistence");
  strcpy(v50, " /persistence/set");
  strcpy(v51, "$/persistence/getV2");
  strcpy(v52, ",/persistence/increment");
  strcpy(v53, "&/persistence/remove");
  v55 = (char *)sub_65ECAAC();
  LOWORD(v56) = 12034;
  BYTE2(v56) = 0;
  strcpy(v55, "/persistence/getSortedValues");
  v54 = xmmword_B042D0;
  v31 = (unsigned __int64 *)sub_65ECAAC();
  v33 = v31 + 18;
  sub_68497A0(v31, (__int128 *)v50);
  sub_68497A0(v31 + 3, (__int128 *)v51);
  sub_68497A0(v31 + 6, (__int128 *)v52);
  sub_68497A0(v31 + 9, (__int128 *)v53);
  sub_68497A0(v31 + 12, &v54);
  sub_68497A0(v31 + 15, &v56);
  v32 = v31 + 18;
  LODWORD(v57[0]) = 429;
  sub_68497A0((unsigned __int64 *)v57 + 1, (__int128 *)v35);
  sub_2532D50(&v58, &v31);
  v29 = 429;
  LOBYTE(v30) = 12;
  strcpy((char *)&v30 + 1, "points");
  v46 = (char *)sub_65ECAAC();
  v45 = xmmword_AFC4C0;
  strcpy(v46, "/v1/universes/{universeId}/users/{userId}/all-time");
  v48 = (char *)sub_65ECAAC();
  BYTE2(v49) = 0;
  strcpy(v48, "/v1/universes/{universeId}/users/{userId}");
  v47 = xmmword_B022A0;
  LOWORD(v49) = 12034;
  v26 = (unsigned __int64 *)sub_65ECAAC();
  v28 = v26 + 9;
  sub_68497A0(v26, &v45);
  sub_68497A0(v26 + 3, &v47);
  sub_68497A0(v26 + 6, &v49);
  v27 = v26 + 9;
  DWORD2(v59) = 429;
  sub_68497A0(&v60, &v30);
  sub_2532D50(&v62, &v26);
  v24 = 429;
  LOBYTE(v25) = 12;
  strcpy((char *)&v25 + 1, "badges");
  v37 = (char *)sub_65ECAAC();
  v38 = 40;
  v41 = 0;
  strcpy(v37, "/v1/users/{userId}/badges/awarded-dates");
  v36 = xmmword_B010C0;
  v40 = 2103724389;
  v39 = *(_OWORD *)"/v1/badges/{badgeId}";
  v43 = (char *)sub_65ECAAC();
  BYTE2(v44) = 0;
  strcpy(v43, "/v1/users/{userId}/badges/{badgeId}/award-badge");
  v42 = xmmword_B01940;
  LOWORD(v44) = 12034;
  v21 = (unsigned __int64 *)sub_65ECAAC();
  v23 = v21 + 12;
  sub_68497A0(v21, &v36);
  sub_68497A0(v21 + 3, (__int128 *)&v38);
  sub_68497A0(v21 + 6, &v42);
  sub_68497A0(v21 + 9, &v44);
  v22 = v21 + 12;
  v64 = 429;
  sub_68497A0(&v65, &v25);
  sub_2532D50(&v66, &v21);
  result = sub_62E91F4(a1 + 456, v57, v68);
  v3 = v66;
  if ( v66 )
  {
    if ( v67 != v66 )
    {
      v4 = v67;
      do
      {
        v5 = *(_BYTE *)(v4 - 24);
        v4 -= 24LL;
        if ( (v5 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v4 != v3 );
    }
    v67 = v3;
    result = sub_65ECAF4();
  }
  if ( (v65 & 1) != 0 )
    result = sub_65ECAF4();
  v6 = v62;
  if ( v62 )
  {
    if ( v63 != v62 )
    {
      v7 = v63;
      do
      {
        v8 = *(_BYTE *)(v7 - 24);
        v7 -= 24LL;
        if ( (v8 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v7 != v6 );
    }
    v63 = v6;
    result = sub_65ECAF4();
  }
  if ( (v60 & 1) != 0 )
    result = sub_65ECAF4();
  v9 = v58;
  if ( (_QWORD)v58 )
  {
    if ( *((_QWORD *)&v58 + 1) != (_QWORD)v58 )
    {
      v10 = *((_QWORD *)&v58 + 1);
      do
      {
        v11 = *(_BYTE *)(v10 - 24);
        v10 -= 24LL;
        if ( (v11 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v10 != v9 );
    }
    *((_QWORD *)&v58 + 1) = v9;
    result = sub_65ECAF4();
  }
  if ( (BYTE8(v57[0]) & 1) != 0 )
    result = sub_65ECAF4();
  v12 = v21;
  if ( v21 )
  {
    if ( v22 != v21 )
    {
      v13 = v22;
      do
      {
        v14 = *((_BYTE *)v13 - 24);
        v13 -= 3;
        if ( (v14 & 1) != 0 )
          sub_65ECAF4();
      }
      while ( v13 != v12 );
    }
    v22 = v12;
    result = sub_65ECAF4();
  }
  if ( (v44 & 1) != 0 )
  {
    result = sub_65ECAF4();
    if ( (v42 & 1) == 0 )
    {
LABEL_37:
      if ( (v38 & 1) == 0 )
        goto LABEL_38;
      goto LABEL_48;
    }
  }
  else if ( (v42 & 1) == 0 )
  {
    goto LABEL_37;
  }
  result = sub_65ECAF4();
  if ( (v38 & 1) == 0 )
  {
LABEL_38:
    if ( (v36 & 1) == 0 )
      goto LABEL_39;
    goto LABEL_49;
  }
LABEL_48:
  result = sub_65ECAF4();
  if ( (v36 & 1) == 0 )
  {
LABEL_39:
    if ( (v25 & 1) == 0 )
      goto LABEL_40;
    goto LABEL_50;
  }
LABEL_49:
  result = sub_65ECAF4();
  if ( (v25 & 1) == 0 )
  {
LABEL_40:
    v15 = v26;
    if ( v26 )
      goto LABEL_41;
LABEL_51:
    if ( (v49 & 1) != 0 )
      goto LABEL_64;
LABEL_52:
    if ( (v47 & 1) != 0 )
      goto LABEL_65;
LABEL_53:
    if ( (v45 & 1) != 0 )
      goto LABEL_66;
LABEL_54:
    if ( (v30 & 1) != 0 )
      goto LABEL_67;
LABEL_55:
    v18 = v31;
    if ( !v31 )
      goto LABEL_68;
    goto LABEL_56;
  }
LABEL_50:
  result = sub_65ECAF4();
  v15 = v26;
  if ( !v26 )
    goto LABEL_51;
LABEL_41:
  if ( v27 != v15 )
  {
    v16 = v27;
    do
    {
      v17 = *((_BYTE *)v16 - 24);
      v16 -= 3;
      if ( (v17 & 1) != 0 )
        sub_65ECAF4();
    }
    while ( v16 != v15 );
  }
  v27 = v15;
  result = sub_65ECAF4();
  if ( (v49 & 1) == 0 )
    goto LABEL_52;
LABEL_64:
  result = sub_65ECAF4();
  if ( (v47 & 1) == 0 )
    goto LABEL_53;
LABEL_65:
  result = sub_65ECAF4();
  if ( (v45 & 1) == 0 )
    goto LABEL_54;
LABEL_66:
  result = sub_65ECAF4();
  if ( (v30 & 1) == 0 )
    goto LABEL_55;
LABEL_67:
  result = sub_65ECAF4();
  v18 = v31;
  if ( !v31 )
  {
LABEL_68:
    if ( (v56 & 1) == 0 )
      goto LABEL_69;
    goto LABEL_78;
  }
LABEL_56:
  if ( v32 != v18 )
  {
    v19 = v32;
    do
    {
      v20 = *((_BYTE *)v19 - 24);
      v19 -= 3;
      if ( (v20 & 1) != 0 )
        sub_65ECAF4();
    }
    while ( v19 != v18 );
  }
  v32 = v18;
  result = sub_65ECAF4();
  if ( (v56 & 1) == 0 )
  {
LABEL_69:
    if ( (v54 & 1) == 0 )
      goto LABEL_70;
    goto LABEL_79;
  }
LABEL_78:
  result = sub_65ECAF4();
  if ( (v54 & 1) == 0 )
  {
LABEL_70:
    if ( (v53[0] & 1) == 0 )
      goto LABEL_71;
    goto LABEL_80;
  }
LABEL_79:
  result = sub_65ECAF4();
  if ( (v53[0] & 1) == 0 )
  {
LABEL_71:
    if ( (v52[0] & 1) == 0 )
      goto LABEL_72;
    goto LABEL_81;
  }
LABEL_80:
  result = sub_65ECAF4();
  if ( (v52[0] & 1) == 0 )
  {
LABEL_72:
    if ( (v51[0] & 1) == 0 )
      goto LABEL_73;
    goto LABEL_82;
  }
LABEL_81:
  result = sub_65ECAF4();
  if ( (v51[0] & 1) == 0 )
  {
LABEL_73:
    if ( (v50[0] & 1) == 0 )
      goto LABEL_74;
    goto LABEL_83;
  }
LABEL_82:
  result = sub_65ECAF4();
  if ( (v50[0] & 1) == 0 )
  {
LABEL_74:
    if ( (v35[0] & 1) == 0 )
      return result;
    return sub_65ECAF4();
  }
LABEL_83:
  result = sub_65ECAF4();
  if ( (v35[0] & 1) == 0 )
    return result;
  return sub_65ECAF4();
}


================================================================================
Function: sub_62E701C (0x62E701C)
================================================================================

_QWORD *__fastcall sub_62E701C(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x19
  __int64 v5; // x8
  __int64 v6; // x21
  __int64 i; // x9
  unsigned __int8 *v8; // x22
  __int64 v9; // x24
  unsigned __int8 *v10; // x23
  __int64 v11; // x25

  v4 = result;
  v5 = result[1];
  v6 = a2;
  if ( v5 )
  {
    for ( i = 0LL; i != v5; ++i )
      *(_QWORD *)(*result + 8 * i) = 0LL;
    v8 = (unsigned __int8 *)result[2];
    result[2] = 0LL;
    result[3] = 0LL;
    if ( !v8 || a2 == a3 )
    {
      v10 = v8;
      v11 = a2;
    }
    else
    {
      do
      {
        sub_684A438(v8 + 16, (unsigned __int8 *)v6);
        v9 = v6 + 24;
        if ( (unsigned __int8 *)(v6 + 24) != v8 + 40 )
        {
          *((_DWORD *)v8 + 18) = *(_DWORD *)(v6 + 56);
          sub_62E72A8();
        }
        v10 = *(unsigned __int8 **)v8;
        sub_62E714C(v4, v8);
        v11 = v6 + 64;
        if ( !v10 )
          break;
        v6 += 64LL;
        v8 = v10;
      }
      while ( v9 + 40 != a3 );
    }
    result = (_QWORD *)sub_62B19C0(v4, v10);
    v6 = v11;
  }
  while ( v6 != a3 )
  {
    result = (_QWORD *)sub_62E8138(v4, v6, v6);
    v6 += 64LL;
  }
  return result;
}


================================================================================
Function: sub_62E714C (0x62E714C)
================================================================================

_QWORD *__fastcall sub_62E714C(__int64 *a1, __int64 a2)
{
  _QWORD *v2; // x19
  unsigned __int64 v4; // x8
  bool v5; // zf
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x2
  __int64 *v8; // x1
  __int64 v9; // x0
  int8x8_t v10; // x8
  unsigned __int64 v11; // x10
  uint8x8_t v12; // d0
  _QWORD *v13; // x11
  __int64 v14; // x12
  unsigned __int64 v15; // x10
  __int64 v17; // [xsp+0h] [xbp-10h] BYREF

  v2 = (_QWORD *)a2;
  v4 = *(unsigned __int8 *)(a2 + 16);
  v5 = (v4 & 1) == 0;
  v6 = v4 >> 1;
  if ( v5 )
    v7 = v6;
  else
    v7 = *(_QWORD *)(a2 + 24);
  if ( v5 )
    v8 = (__int64 *)(a2 + 17);
  else
    v8 = *(__int64 **)(a2 + 32);
  v2[1] = sub_24FE128((__int64)&v17, v8, v7);
  v9 = sub_62E7C40(a1);
  if ( !v9 )
  {
    v10.n64_u64[0] = a1[1];
    v11 = v2[1];
    v12.n64_u64[0] = vcnt_s8(v10).n64_u64[0];
    v12.n64_u16[0] = vaddlv_u8(v12);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v11 >= v10.n64_u64[0] )
        v11 %= v10.n64_u64[0];
    }
    else
    {
      v11 &= v10.n64_u64[0] - 1;
    }
    v13 = *(_QWORD **)(*a1 + 8 * v11);
    if ( v13 )
    {
      *v2 = *v13;
    }
    else
    {
      *v2 = a1[2];
      v14 = *a1;
      a1[2] = (__int64)v2;
      *(_QWORD *)(v14 + 8 * v11) = a1 + 2;
      if ( !*v2 )
      {
LABEL_22:
        ++a1[3];
        return v2;
      }
      v15 = *(_QWORD *)(*v2 + 8LL);
      if ( v12.n64_u32[0] > 1uLL )
      {
        if ( v15 >= v10.n64_u64[0] )
          v15 %= v10.n64_u64[0];
      }
      else
      {
        v15 &= v10.n64_u64[0] - 1;
      }
      v13 = (_QWORD *)(*a1 + 8 * v15);
    }
    *v13 = v2;
    goto LABEL_22;
  }
  return (_QWORD *)v9;
}


================================================================================
Function: sub_62E72A8 (0x62E72A8)
================================================================================

_QWORD *__fastcall sub_62E72A8(_QWORD *result, __int64 *a2, __int64 *a3)
{
  _QWORD *v4; // x19
  __int64 v6; // x8
  __int64 i; // x9
  __int64 *v8; // x22
  __int64 *v9; // x24
  __int128 v10; // q0
  __int128 v11; // q1
  __int128 v12; // q2
  __int64 *v13; // x19
  _QWORD v14[3]; // [xsp+0h] [xbp-20h] BYREF

  v4 = result;
  v6 = result[1];
  if ( !v6 )
    goto LABEL_9;
  for ( i = 0LL; i != v6; *(_QWORD *)(*result + 8 * i++) = 0LL )
    ;
  v8 = (__int64 *)result[2];
  result[2] = 0LL;
  result[3] = 0LL;
  if ( v8 )
  {
    while ( a2 != a3 )
    {
      sub_684A438((unsigned __int8 *)v8 + 16, (unsigned __int8 *)a2 + 16);
      v9 = (__int64 *)*v8;
      *(_OWORD *)(v8 + 5) = *(_OWORD *)(a2 + 5);
      v10 = *(_OWORD *)(a2 + 11);
      v11 = *(_OWORD *)(a2 + 9);
      v12 = *(_OWORD *)(a2 + 7);
      *((_DWORD *)v8 + 26) = *((_DWORD *)a2 + 26);
      *(_OWORD *)(v8 + 11) = v10;
      *(_OWORD *)(v8 + 9) = v11;
      *(_OWORD *)(v8 + 7) = v12;
      result = (_QWORD *)sub_62E7448(v4, v8);
      a2 = (__int64 *)*a2;
      v8 = v9;
      if ( !v9 )
        goto LABEL_9;
    }
    do
    {
      v13 = (__int64 *)*v8;
      if ( (v8[2] & 1) != 0 )
        sub_65ECAF4();
      result = (_QWORD *)sub_65ECAF4();
      v8 = v13;
    }
    while ( v13 );
  }
  else
  {
LABEL_9:
    while ( a2 != a3 )
    {
      sub_62E7B04(v14, v4, a2 + 2);
      result = (_QWORD *)sub_62E7448(v4, v14[0]);
      a2 = (__int64 *)*a2;
    }
  }
  return result;
}


================================================================================
Function: sub_62E7448 (0x62E7448)
================================================================================

__int64 __fastcall sub_62E7448(__int64 *a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  bool v5; // zf
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x2
  __int64 *v8; // x1
  _QWORD *v9; // x0
  int8x8_t v10; // x8
  unsigned __int64 v11; // x9
  uint8x8_t v12; // d0
  unsigned __int64 v13; // x10
  __int64 v14; // x12
  __int64 v16; // [xsp+0h] [xbp-10h] BYREF

  v4 = *(unsigned __int8 *)(a2 + 16);
  v5 = (v4 & 1) == 0;
  v6 = v4 >> 1;
  if ( v5 )
    v7 = v6;
  else
    v7 = *(_QWORD *)(a2 + 24);
  if ( v5 )
    v8 = (__int64 *)(a2 + 17);
  else
    v8 = *(__int64 **)(a2 + 32);
  *(_QWORD *)(a2 + 8) = sub_24FE128((__int64)&v16, v8, v7);
  v9 = (_QWORD *)sub_62E75C0(a1);
  v10.n64_u64[0] = a1[1];
  v11 = *(_QWORD *)(a2 + 8);
  v12.n64_u64[0] = vcnt_s8(v10).n64_u64[0];
  v12.n64_u16[0] = vaddlv_u8(v12);
  if ( v12.n64_u32[0] > 1uLL )
  {
    if ( v11 >= v10.n64_u64[0] )
      v11 %= v10.n64_u64[0];
  }
  else
  {
    v11 &= v10.n64_u64[0] - 1;
  }
  if ( !v9 )
  {
    *(_QWORD *)a2 = a1[2];
    v14 = *a1;
    a1[2] = a2;
    *(_QWORD *)(v14 + 8 * v11) = a1 + 2;
    if ( !*(_QWORD *)a2 )
      goto LABEL_25;
    v13 = *(_QWORD *)(*(_QWORD *)a2 + 8LL);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v10.n64_u64[0] )
        v13 %= v10.n64_u64[0];
    }
    else
    {
      v13 &= v10.n64_u64[0] - 1;
    }
LABEL_24:
    *(_QWORD *)(*a1 + 8 * v13) = a2;
    goto LABEL_25;
  }
  *(_QWORD *)a2 = *v9;
  *v9 = a2;
  if ( *(_QWORD *)a2 )
  {
    v13 = *(_QWORD *)(*(_QWORD *)a2 + 8LL);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v10.n64_u64[0] )
        v13 %= v10.n64_u64[0];
    }
    else
    {
      v13 &= v10.n64_u64[0] - 1;
    }
    if ( v13 != v11 )
      goto LABEL_24;
  }
LABEL_25:
  ++a1[3];
  return a2;
}


================================================================================
Function: sub_62E75C0 (0x62E75C0)
================================================================================

__int64 *__fastcall sub_62E75C0(unsigned __int64 a1, unsigned __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // x23
  float v7; // s1
  float v8; // s0
  _BOOL8 v9; // x9
  unsigned __int64 v10; // x10
  unsigned __int64 v11; // x1
  uint8x8_t v12; // d0
  unsigned __int64 v13; // x24
  unsigned __int64 v14; // x25
  __int64 *v15; // x26
  int v16; // w27
  unsigned __int64 v17; // x8
  size_t v18; // x21
  unsigned __int8 *v19; // x22
  _BOOL4 v20; // w8
  int v21; // w9
  __int64 *v22; // x20
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x9
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x11
  unsigned __int64 v27; // x10
  const void *v28; // x0
  unsigned __int8 *v29; // x9
  unsigned __int64 v30; // x10
  unsigned __int8 *v31; // x11
  int v32; // w8
  int v33; // t1
  int v34; // t1
  bool v35; // zf

  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(float *)(a1 + 32);
  v8 = (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL);
  if ( !v6 || (float)(v7 * (float)v6) < v8 )
  {
    v9 = v6 < 3 || (v6 & (v6 - 1)) != 0;
    v10 = vcvtps_u32_f32(v8 / v7);
    if ( (v9 | (2 * v6)) >= v10 )
      v11 = v9 | (2 * v6);
    else
      v11 = v10;
    sub_62E77C0(a1, v11);
    v6 = *(_QWORD *)(a1 + 8);
  }
  v12.n64_u64[0] = vcnt_s8((int8x8_t)v6).n64_u64[0];
  v12.n64_u16[0] = vaddlv_u8(v12);
  v13 = v12.n64_u32[0];
  if ( v12.n64_u32[0] > 1uLL )
  {
    v14 = a2;
    if ( v6 <= a2 )
      v14 = a2 % v6;
  }
  else
  {
    v14 = (v6 - 1) & a2;
  }
  v15 = *(__int64 **)(*(_QWORD *)a1 + 8 * v14);
  if ( v15 )
  {
    v16 = 0;
    v17 = *a3;
    if ( (v17 & 1) != 0 )
      v18 = *((_QWORD *)a3 + 1);
    else
      v18 = v17 >> 1;
    if ( (v17 & 1) != 0 )
      v19 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
    else
      v19 = a3 + 1;
    while ( 1 )
    {
      v22 = v15;
      v15 = (__int64 *)*v15;
      if ( !v15 )
        return v22;
      v23 = v15[1];
      if ( v13 > 1 )
      {
        v24 = v15[1];
        if ( v23 >= v6 )
          v24 = v23 % v6;
      }
      else
      {
        v24 = v23 & (v6 - 1);
      }
      if ( v24 != v14 )
        return v22;
      if ( v23 != a2 )
        goto LABEL_21;
      v25 = *((unsigned __int8 *)v15 + 16);
      v26 = v15[3];
      v27 = v25 >> 1;
      if ( (v25 & 1) == 0 )
        v26 = v25 >> 1;
      if ( v26 == v18 )
      {
        if ( (v25 & 1) != 0 )
          v28 = (const void *)v15[4];
        else
          v28 = (char *)v15 + 17;
        if ( (v25 & 1) == 0 )
        {
          if ( v18 )
          {
            v29 = (unsigned __int8 *)v15 + 17;
            v30 = v27 - 1;
            v31 = v19;
            do
            {
              v33 = *v29++;
              v32 = v33;
              v34 = *v31++;
              v35 = v32 == v34;
              v20 = v32 == v34;
              v35 = !v35 || v30-- == 0;
            }
            while ( !v35 );
            goto LABEL_22;
          }
LABEL_47:
          v20 = 1;
          goto LABEL_22;
        }
        if ( !v18 )
          goto LABEL_47;
        v20 = memcmp(v28, v19, v18) == 0;
      }
      else
      {
LABEL_21:
        v20 = 0;
      }
LABEL_22:
      v21 = v16 & !v20;
      v16 |= v20;
      if ( v21 == 1 )
        return v22;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_62E77C0 (0x62E77C0)
================================================================================

unsigned __int64 __fastcall sub_62E77C0(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x13
  unsigned __int64 v10; // x11
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  __int64 *v13; // x26
  unsigned __int64 v14; // x12
  unsigned __int64 v15; // x27
  __int64 v16; // x8
  unsigned __int64 v17; // x24
  _QWORD *v18; // x28
  size_t v19; // x21
  _QWORD *v20; // x23
  __int64 v21; // x8
  char v22; // w9
  unsigned int v23; // t1
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x11
  unsigned __int8 *v26; // x1
  unsigned __int8 *v27; // x8
  unsigned __int64 v28; // x9
  unsigned __int64 v29; // [xsp+8h] [xbp-48h]
  _QWORD *v30; // [xsp+10h] [xbp-40h]
  unsigned __int64 v31; // [xsp+18h] [xbp-38h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_681B888(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_681B888(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_65ECAAC();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_65ECAF4();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = (__int64 *)*v9;
          if ( *v9 )
          {
            v14 = v3.n64_u64[0] - 1;
            v29 = v11.n64_u32[0];
            do
            {
              v15 = v13[1];
              if ( v12 > 1 )
              {
                if ( v15 >= v3.n64_u64[0] )
                  v15 %= v3.n64_u64[0];
              }
              else
              {
                v15 &= v14;
              }
              if ( v15 == v10 )
              {
                v9 = v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v15) )
              {
                v16 = *v13;
                if ( *v13 )
                {
                  v17 = *((unsigned __int8 *)v13 + 16);
                  v18 = v13;
                  v30 = v9;
                  v31 = v10;
                  if ( (v17 & 1) != 0 )
                    v19 = v13[3];
                  else
                    v19 = v17 >> 1;
                  while ( 1 )
                  {
                    v20 = v18;
                    v18 = (_QWORD *)v16;
                    v23 = *(unsigned __int8 *)(v16 + 16);
                    v21 = v16 + 16;
                    v22 = v23;
                    v24 = *(_QWORD *)(v21 + 8);
                    v25 = (unsigned __int64)v23 >> 1;
                    if ( (v23 & 1) == 0 )
                      v24 = v25;
                    if ( v19 != v24 )
                      break;
                    if ( (v17 & 1) != 0 )
                      result = v13[4];
                    else
                      result = (unsigned __int64)v13 + 17;
                    if ( (v22 & 1) != 0 )
                      v26 = (unsigned __int8 *)v18[4];
                    else
                      v26 = (unsigned __int8 *)(v21 + 1);
                    if ( (v17 & 1) != 0 )
                    {
                      if ( v19 )
                      {
                        result = memcmp((const void *)result, v26, v19);
                        if ( (_DWORD)result )
                          break;
                      }
                    }
                    else
                    {
                      v27 = (unsigned __int8 *)v13 + 17;
                      v28 = v17 >> 1;
                      if ( v19 )
                      {
                        while ( *v27 == *v26 )
                        {
                          --v28;
                          ++v27;
                          ++v26;
                          if ( !v28 )
                            goto LABEL_46;
                        }
                        break;
                      }
                    }
LABEL_46:
                    v16 = *v18;
                    if ( !*v18 )
                    {
                      v20 = v18;
                      v18 = 0LL;
                      break;
                    }
                  }
                  v14 = v3.n64_u64[0] - 1;
                  v12 = v29;
                  v10 = v31;
                  v9 = v30;
                }
                else
                {
                  v18 = 0LL;
                  v20 = v13;
                }
                *v9 = v18;
                *v20 = **(_QWORD **)(v2->n64_u64[0] + 8 * v15);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v15) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v15) = v9;
                v9 = v13;
                v10 = v15;
              }
              v13 = (__int64 *)*v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_65ECAF4();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62E7B04 (0x62E7B04)
================================================================================

unsigned __int64 __usercall sub_62E7B04@<X0>(__int64 a1@<X0>, __int64 a2@<X1>, __int64 a3@<X8>)
{
  __int64 v4; // x23
  __int64 v6; // x19
  unsigned __int64 v7; // x9
  __int128 v8; // q0
  __int128 v9; // q1
  bool v10; // zf
  unsigned __int64 v11; // x8
  __int64 *v12; // x10
  unsigned __int64 v13; // x9
  __int128 v14; // q2
  __int128 v15; // q0
  __int64 v16; // x12
  unsigned __int64 v17; // x2
  __int64 *v18; // x1
  unsigned __int64 result; // x0
  __int64 v20; // [xsp+0h] [xbp-10h] BYREF

  v4 = a1 + 16;
  v6 = sub_65ECAAC();
  *(_BYTE *)(a3 + 16) = 0;
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v4;
  sub_68497A0((unsigned __int64 *)(v6 + 16), (__int128 *)a2);
  v7 = *(unsigned __int8 *)(v6 + 16);
  v8 = *(_OWORD *)(a2 + 40);
  v9 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a3 + 16) = 1;
  v10 = (v7 & 1) == 0;
  v11 = *(_QWORD *)(v6 + 24);
  v12 = *(__int64 **)(v6 + 32);
  *(_OWORD *)(v6 + 56) = v8;
  v13 = v7 >> 1;
  v14 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v6 + 72) = v9;
  v15 = *(_OWORD *)(a2 + 24);
  v16 = *(_QWORD *)(a2 + 88);
  if ( v10 )
    v17 = v13;
  else
    v17 = v11;
  if ( v10 )
    v18 = (__int64 *)(v6 + 17);
  else
    v18 = v12;
  *(_OWORD *)(v6 + 88) = v14;
  *(_OWORD *)(v6 + 40) = v15;
  *(_QWORD *)(v6 + 104) = v16;
  result = sub_24FE128((__int64)&v20, v18, v17);
  *(_QWORD *)v6 = 0LL;
  *(_QWORD *)(v6 + 8) = result;
  return result;
}


================================================================================
Function: sub_62E7C40 (0x62E7C40)
================================================================================

__int64 **__fastcall sub_62E7C40(unsigned __int64 a1, unsigned __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v4; // x24
  unsigned __int64 v5; // x20
  uint8x8_t v6; // d0
  unsigned __int64 v7; // x25
  __int64 ***v8; // x8
  unsigned __int64 v9; // x9
  __int64 **v10; // x21
  size_t v11; // x22
  unsigned __int8 *i; // x23
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x10
  unsigned __int64 v15; // x11
  __int64 *v16; // x0
  __int64 v17; // x9
  float v18; // s1
  float v19; // s0
  float v20; // s0
  _BOOL8 v21; // x8
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x10
  unsigned __int64 v24; // x1

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    v5 = a2;
    v6.n64_u64[0] = vcnt_s8((int8x8_t)v4).n64_u64[0];
    v6.n64_u16[0] = vaddlv_u8(v6);
    v7 = v6.n64_u32[0];
    if ( v6.n64_u32[0] > 1uLL )
    {
      if ( v4 <= a2 )
        v5 = a2 % v4;
    }
    else
    {
      v5 = (v4 - 1) & a2;
    }
    v8 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v5);
    if ( v8 )
    {
      v9 = *a3;
      v10 = *v8;
      v11 = (v9 & 1) != 0 ? *((_QWORD *)a3 + 1) : v9 >> 1;
      for ( i = (v9 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a3 + 2) : a3 + 1; v10; v10 = (__int64 **)*v10 )
      {
        v13 = (unsigned __int64)v10[1];
        if ( v7 > 1 )
        {
          if ( v13 >= v4 )
            v13 %= v4;
        }
        else
        {
          v13 &= v4 - 1;
        }
        if ( v13 != v5 )
          break;
        v14 = *((unsigned __int8 *)v10 + 16);
        v15 = (unsigned __int64)v10[3];
        if ( (v14 & 1) == 0 )
          v15 = v14 >> 1;
        if ( v15 == v11 )
        {
          if ( (v14 & 1) != 0 )
            v16 = v10[4];
          else
            v16 = (__int64 *)((char *)v10 + 17);
          if ( (v14 & 1) != 0 )
          {
            if ( !v11 || !memcmp(v16, i, v11) )
              return v10;
          }
          else
          {
            if ( !v11 )
              return v10;
            v17 = 0LL;
            while ( *((unsigned __int8 *)v10 + v17 + 17) == i[v17] )
            {
              if ( v14 >> 1 == ++v17 )
                return v10;
            }
          }
        }
      }
    }
  }
  v18 = *(float *)(a1 + 32);
  v19 = (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL);
  if ( !v4 || (float)(v18 * (float)v4) < v19 )
  {
    v20 = v19 / v18;
    v21 = 1LL;
    if ( v4 >= 3 )
      v21 = (v4 & (v4 - 1)) != 0;
    v22 = v21 | (2 * v4);
    v23 = vcvtps_u32_f32(v20);
    if ( v22 >= v23 )
      v24 = v22;
    else
      v24 = v23;
    sub_62E7DF4(a1, v24);
  }
  return 0LL;
}


================================================================================
Function: sub_62E7DF4 (0x62E7DF4)
================================================================================

unsigned __int64 __fastcall sub_62E7DF4(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x13
  unsigned __int64 v10; // x11
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  __int64 *v13; // x26
  unsigned __int64 v14; // x12
  unsigned __int64 v15; // x27
  __int64 v16; // x8
  unsigned __int64 v17; // x24
  _QWORD *v18; // x28
  size_t v19; // x21
  _QWORD *v20; // x23
  __int64 v21; // x8
  char v22; // w9
  unsigned int v23; // t1
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x11
  unsigned __int8 *v26; // x1
  unsigned __int8 *v27; // x8
  unsigned __int64 v28; // x9
  unsigned __int64 v29; // [xsp+8h] [xbp-48h]
  _QWORD *v30; // [xsp+10h] [xbp-40h]
  unsigned __int64 v31; // [xsp+18h] [xbp-38h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_681B888(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_681B888(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_65ECAAC();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_65ECAF4();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = (__int64 *)*v9;
          if ( *v9 )
          {
            v14 = v3.n64_u64[0] - 1;
            v29 = v11.n64_u32[0];
            do
            {
              v15 = v13[1];
              if ( v12 > 1 )
              {
                if ( v15 >= v3.n64_u64[0] )
                  v15 %= v3.n64_u64[0];
              }
              else
              {
                v15 &= v14;
              }
              if ( v15 == v10 )
              {
                v9 = v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v15) )
              {
                v16 = *v13;
                if ( *v13 )
                {
                  v17 = *((unsigned __int8 *)v13 + 16);
                  v18 = v13;
                  v30 = v9;
                  v31 = v10;
                  if ( (v17 & 1) != 0 )
                    v19 = v13[3];
                  else
                    v19 = v17 >> 1;
                  while ( 1 )
                  {
                    v20 = v18;
                    v18 = (_QWORD *)v16;
                    v23 = *(unsigned __int8 *)(v16 + 16);
                    v21 = v16 + 16;
                    v22 = v23;
                    v24 = *(_QWORD *)(v21 + 8);
                    v25 = (unsigned __int64)v23 >> 1;
                    if ( (v23 & 1) == 0 )
                      v24 = v25;
                    if ( v19 != v24 )
                      break;
                    if ( (v17 & 1) != 0 )
                      result = v13[4];
                    else
                      result = (unsigned __int64)v13 + 17;
                    if ( (v22 & 1) != 0 )
                      v26 = (unsigned __int8 *)v18[4];
                    else
                      v26 = (unsigned __int8 *)(v21 + 1);
                    if ( (v17 & 1) != 0 )
                    {
                      if ( v19 )
                      {
                        result = memcmp((const void *)result, v26, v19);
                        if ( (_DWORD)result )
                          break;
                      }
                    }
                    else
                    {
                      v27 = (unsigned __int8 *)v13 + 17;
                      v28 = v17 >> 1;
                      if ( v19 )
                      {
                        while ( *v27 == *v26 )
                        {
                          --v28;
                          ++v27;
                          ++v26;
                          if ( !v28 )
                            goto LABEL_46;
                        }
                        break;
                      }
                    }
LABEL_46:
                    v16 = *v18;
                    if ( !*v18 )
                    {
                      v20 = v18;
                      v18 = 0LL;
                      break;
                    }
                  }
                  v14 = v3.n64_u64[0] - 1;
                  v12 = v29;
                  v10 = v31;
                  v9 = v30;
                }
                else
                {
                  v18 = 0LL;
                  v20 = v13;
                }
                *v9 = v18;
                *v20 = **(_QWORD **)(v2->n64_u64[0] + 8 * v15);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v15) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v15) = v9;
                v9 = v13;
                v10 = v15;
              }
              v13 = (__int64 *)*v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_65ECAF4();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62E8138 (0x62E8138)
================================================================================

__int64 **__fastcall sub_62E8138(__int64 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int64 v3; // x27
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  __int64 *v11; // x1
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x26
  uint8x8_t v16; // d0
  unsigned __int64 v17; // x28
  __int64 ***v18; // x8
  unsigned __int64 v19; // x10
  unsigned __int8 *v20; // x11
  unsigned __int8 *v21; // x12
  unsigned __int64 v22; // x9
  __int64 **v23; // x22
  size_t v24; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  __int64 *v29; // x0
  __int64 v30; // x9
  __int64 *v31; // x23
  _QWORD *v32; // x22
  __int64 v33; // x8
  float v34; // s1
  float v35; // s0
  _BOOL8 v36; // x9
  unsigned __int64 v37; // x10
  __int64 v38; // x1
  __int64 v39; // x8
  _QWORD *v40; // x9
  __int64 v41; // x9
  unsigned __int64 v42; // x9
  _QWORD v44[2]; // [xsp+0h] [xbp-20h] BYREF
  char v45; // [xsp+10h] [xbp-10h]

  v7 = *((_QWORD *)a2 + 1);
  v8 = *a2;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v11 = (__int64 *)(a2 + 1);
  else
    v11 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v9 )
    v12 = v10;
  else
    v12 = v7;
  v13 = sub_24FE128((__int64)v44, v11, v12);
  v14 = v13;
  v15 = a1[1];
  if ( v15 )
  {
    v16.n64_u64[0] = vcnt_s8((int8x8_t)v15).n64_u64[0];
    v16.n64_u16[0] = vaddlv_u8(v16);
    v17 = v16.n64_u32[0];
    if ( v16.n64_u32[0] > 1uLL )
    {
      v3 = v13;
      if ( v13 >= v15 )
        v3 = v13 % v15;
    }
    else
    {
      v3 = (v15 - 1) & v13;
    }
    v18 = *(__int64 ****)(*a1 + 8 * v3);
    if ( v18 )
    {
      v19 = *((_QWORD *)a2 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v21 = a2 + 1;
      v22 = *a2;
      v23 = *v18;
      v24 = (v22 & 1) != 0 ? v19 : v22 >> 1;
      for ( i = (v22 & 1) != 0 ? v20 : v21; v23; v23 = (__int64 **)*v23 )
      {
        v26 = (unsigned __int64)v23[1];
        if ( v26 != v14 )
        {
          if ( v17 > 1 )
          {
            if ( v26 >= v15 )
              v26 %= v15;
          }
          else
          {
            v26 &= v15 - 1;
          }
          if ( v26 != v3 )
            break;
        }
        v27 = *((unsigned __int8 *)v23 + 16);
        v28 = (unsigned __int64)v23[3];
        if ( (v27 & 1) == 0 )
          v28 = v27 >> 1;
        if ( v28 == v24 )
        {
          if ( (v27 & 1) != 0 )
            v29 = v23[4];
          else
            v29 = (__int64 *)((char *)v23 + 17);
          if ( (v27 & 1) != 0 )
          {
            if ( !v24 || !memcmp(v29, i, v24) )
              return v23;
          }
          else
          {
            if ( !v24 )
              return v23;
            v30 = 0LL;
            while ( *((unsigned __int8 *)v23 + v30 + 17) == i[v30] )
            {
              if ( v27 >> 1 == ++v30 )
                return v23;
            }
          }
        }
      }
    }
  }
  v31 = a1 + 2;
  v32 = (_QWORD *)sub_65ECAAC();
  v45 = 0;
  v44[0] = v32;
  v44[1] = a1 + 2;
  sub_62E8474(v32 + 2, a3);
  v33 = a1[3];
  v34 = *((float *)a1 + 8);
  *v32 = 0LL;
  v32[1] = v14;
  v45 = 1;
  v35 = (float)(unsigned __int64)(v33 + 1);
  if ( !v15 || (float)(v34 * (float)v15) < v35 )
  {
    v36 = v15 < 3 || (v15 & (v15 - 1)) != 0;
    v37 = vcvtps_u32_f32(v35 / v34);
    if ( (v36 | (2 * v15)) >= v37 )
      v38 = v36 | (2 * v15);
    else
      v38 = v37;
    sub_62E7DF4(a1, v38);
    v15 = a1[1];
    if ( (v15 & (v15 - 1)) != 0 )
    {
      if ( v14 >= v15 )
        v3 = v14 % v15;
      else
        v3 = v14;
    }
    else
    {
      v3 = (v15 - 1) & v14;
    }
  }
  v39 = *a1;
  v40 = *(_QWORD **)(*a1 + 8 * v3);
  if ( v40 )
  {
    *v32 = *v40;
    *v40 = v32;
  }
  else
  {
    v41 = *v31;
    *v31 = (__int64)v32;
    *v32 = v41;
    *(_QWORD *)(v39 + 8 * v3) = v31;
    if ( *(_QWORD *)v44[0] )
    {
      v42 = *(_QWORD *)(*(_QWORD *)v44[0] + 8LL);
      if ( (v15 & (v15 - 1)) != 0 )
      {
        if ( v42 >= v15 )
          v42 %= v15;
      }
      else
      {
        v42 &= v15 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v42) = v44[0];
    }
  }
  v23 = (__int64 **)v44[0];
  ++a1[3];
  return v23;
}


================================================================================
Function: sub_62E8474 (0x62E8474)
================================================================================

__int64 __fastcall sub_62E8474(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  _QWORD *i; // x21

  sub_68497A0((unsigned __int64 *)a1, (__int128 *)a2);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  result = sub_62E77C0(a1 + 24, *(_QWORD *)(a2 + 32));
  for ( i = *(_QWORD **)(a2 + 40); i; i = (_QWORD *)*i )
    result = sub_62E850C(a1 + 24, i + 2, i + 2);
  return result;
}


================================================================================
Function: sub_62E850C (0x62E850C)
================================================================================

__int64 **__fastcall sub_62E850C(__int64 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int64 v3; // x27
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  __int64 *v11; // x1
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x26
  uint8x8_t v16; // d0
  unsigned __int64 v17; // x28
  __int64 ***v18; // x8
  unsigned __int64 v19; // x10
  unsigned __int8 *v20; // x11
  unsigned __int8 *v21; // x12
  unsigned __int64 v22; // x9
  __int64 **v23; // x22
  size_t v24; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  __int64 *v29; // x0
  __int64 v30; // x9
  __int64 *v31; // x23
  __int64 v32; // x22
  __int128 v33; // q0
  __int64 v34; // x8
  __int128 v35; // q1
  __int128 v36; // q0
  __int64 v37; // x9
  __int128 v38; // q1
  float v39; // s0
  float v40; // s1
  _BOOL8 v41; // x9
  unsigned __int64 v42; // x10
  __int64 v43; // x1
  __int64 v44; // x8
  __int64 *v45; // x9
  __int64 v46; // x9
  unsigned __int64 v47; // x9
  _QWORD v49[2]; // [xsp+0h] [xbp-20h] BYREF
  char v50; // [xsp+10h] [xbp-10h]

  v7 = *((_QWORD *)a2 + 1);
  v8 = *a2;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v11 = (__int64 *)(a2 + 1);
  else
    v11 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v9 )
    v12 = v10;
  else
    v12 = v7;
  v13 = sub_24FE128((__int64)v49, v11, v12);
  v14 = v13;
  v15 = a1[1];
  if ( v15 )
  {
    v16.n64_u64[0] = vcnt_s8((int8x8_t)v15).n64_u64[0];
    v16.n64_u16[0] = vaddlv_u8(v16);
    v17 = v16.n64_u32[0];
    if ( v16.n64_u32[0] > 1uLL )
    {
      v3 = v13;
      if ( v13 >= v15 )
        v3 = v13 % v15;
    }
    else
    {
      v3 = (v15 - 1) & v13;
    }
    v18 = *(__int64 ****)(*a1 + 8 * v3);
    if ( v18 )
    {
      v19 = *((_QWORD *)a2 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v21 = a2 + 1;
      v22 = *a2;
      v23 = *v18;
      v24 = (v22 & 1) != 0 ? v19 : v22 >> 1;
      for ( i = (v22 & 1) != 0 ? v20 : v21; v23; v23 = (__int64 **)*v23 )
      {
        v26 = (unsigned __int64)v23[1];
        if ( v26 != v14 )
        {
          if ( v17 > 1 )
          {
            if ( v26 >= v15 )
              v26 %= v15;
          }
          else
          {
            v26 &= v15 - 1;
          }
          if ( v26 != v3 )
            break;
        }
        v27 = *((unsigned __int8 *)v23 + 16);
        v28 = (unsigned __int64)v23[3];
        if ( (v27 & 1) == 0 )
          v28 = v27 >> 1;
        if ( v28 == v24 )
        {
          if ( (v27 & 1) != 0 )
            v29 = v23[4];
          else
            v29 = (__int64 *)((char *)v23 + 17);
          if ( (v27 & 1) != 0 )
          {
            if ( !v24 || !memcmp(v29, i, v24) )
              return v23;
          }
          else
          {
            if ( !v24 )
              return v23;
            v30 = 0LL;
            while ( *((unsigned __int8 *)v23 + v30 + 17) == i[v30] )
            {
              if ( v27 >> 1 == ++v30 )
                return v23;
            }
          }
        }
      }
    }
  }
  v31 = a1 + 2;
  v32 = sub_65ECAAC();
  v50 = 0;
  v49[0] = v32;
  v49[1] = a1 + 2;
  sub_68497A0((unsigned __int64 *)(v32 + 16), (__int128 *)a3);
  v33 = *(_OWORD *)(a3 + 40);
  *(_QWORD *)v32 = 0LL;
  *(_QWORD *)(v32 + 8) = v14;
  v34 = a1[3];
  v35 = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(v32 + 56) = v33;
  v36 = *(_OWORD *)(a3 + 72);
  v37 = *(_QWORD *)(a3 + 88);
  *(_OWORD *)(v32 + 72) = v35;
  v38 = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(v32 + 88) = v36;
  v39 = (float)(unsigned __int64)(v34 + 1);
  *(_QWORD *)(v32 + 104) = v37;
  *(_OWORD *)(v32 + 40) = v38;
  v40 = *((float *)a1 + 8);
  v50 = 1;
  if ( !v15 || (float)(v40 * (float)v15) < v39 )
  {
    v41 = v15 < 3 || (v15 & (v15 - 1)) != 0;
    v42 = vcvtps_u32_f32(v39 / v40);
    if ( (v41 | (2 * v15)) >= v42 )
      v43 = v41 | (2 * v15);
    else
      v43 = v42;
    sub_62E77C0(a1, v43);
    v15 = a1[1];
    if ( (v15 & (v15 - 1)) != 0 )
    {
      if ( v14 >= v15 )
        v3 = v14 % v15;
      else
        v3 = v14;
    }
    else
    {
      v3 = (v15 - 1) & v14;
    }
  }
  v44 = *a1;
  v45 = *(__int64 **)(*a1 + 8 * v3);
  if ( v45 )
  {
    *(_QWORD *)v32 = *v45;
    *v45 = v32;
  }
  else
  {
    v46 = *v31;
    *v31 = v32;
    *(_QWORD *)v32 = v46;
    *(_QWORD *)(v44 + 8 * v3) = v31;
    if ( *(_QWORD *)v49[0] )
    {
      v47 = *(_QWORD *)(*(_QWORD *)v49[0] + 8LL);
      if ( (v15 & (v15 - 1)) != 0 )
      {
        if ( v47 >= v15 )
          v47 %= v15;
      }
      else
      {
        v47 &= v15 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v47) = v49[0];
    }
  }
  v23 = (__int64 **)v49[0];
  ++a1[3];
  return v23;
}


================================================================================
Function: sub_62E88FC (0x62E88FC)
================================================================================

_QWORD *__fastcall sub_62E88FC(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x20
  __int64 v5; // x8
  __int64 v6; // x21
  __int64 i; // x9
  _QWORD *v8; // x22
  _QWORD *v9; // x23
  _QWORD *v10; // x22

  v4 = result;
  v5 = result[1];
  v6 = a2;
  if ( v5 )
  {
    for ( i = 0LL; i != v5; ++i )
      *(_QWORD *)(*result + 8 * i) = 0LL;
    v8 = (_QWORD *)result[2];
    result[2] = 0LL;
    result[3] = 0LL;
    if ( v8 )
    {
      if ( a2 == a3 )
      {
        v9 = v8;
      }
      else
      {
        do
        {
          v9 = (_QWORD *)*v8;
          *((_OWORD *)v8 + 1) = *(_OWORD *)v6;
          *((_DWORD *)v8 + 8) = *(_DWORD *)(v6 + 16);
          result = (_QWORD *)sub_62E8A14(v4, v8);
          v6 += 24LL;
          if ( !v9 )
            break;
          v8 = v9;
        }
        while ( v6 != a3 );
      }
      if ( v9 )
      {
        do
        {
          v10 = (_QWORD *)*v9;
          result = (_QWORD *)sub_65ECAF4();
          v9 = v10;
        }
        while ( v10 );
      }
    }
  }
  while ( v6 != a3 )
  {
    result = (_QWORD *)sub_62E8F74(v4, v6, v6);
    v6 += 24LL;
  }
  return result;
}


================================================================================
Function: sub_62E8A14 (0x62E8A14)
================================================================================

_QWORD *__fastcall sub_62E8A14(__int64 *a1, _QWORD *a2)
{
  _QWORD *v3; // x19
  unsigned __int64 v5; // x1
  char *v6; // x8
  __int64 i; // x9
  __int64 v8; // t1
  __int64 v9; // x0
  int8x8_t v10; // x8
  unsigned __int64 v11; // x10
  uint8x8_t v12; // d0
  _QWORD *v13; // x11
  __int64 v14; // x12
  unsigned __int64 v15; // x10

  v3 = a2;
  v5 = 0LL;
  v6 = (char *)a2[2];
  for ( i = a2[3]; i; v5 ^= (v5 << 6) + (v5 >> 2) + v8 + 2654435769u )
  {
    v8 = *v6++;
    --i;
  }
  v3[1] = v5;
  v9 = sub_62E8B44(a1);
  if ( !v9 )
  {
    v10.n64_u64[0] = a1[1];
    v11 = v3[1];
    v12.n64_u64[0] = vcnt_s8(v10).n64_u64[0];
    v12.n64_u16[0] = vaddlv_u8(v12);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v11 >= v10.n64_u64[0] )
        v11 %= v10.n64_u64[0];
    }
    else
    {
      v11 &= v10.n64_u64[0] - 1;
    }
    v13 = *(_QWORD **)(*a1 + 8 * v11);
    if ( v13 )
    {
      *v3 = *v13;
    }
    else
    {
      *v3 = a1[2];
      v14 = *a1;
      a1[2] = (__int64)v3;
      *(_QWORD *)(v14 + 8 * v11) = a1 + 2;
      if ( !*v3 )
      {
LABEL_18:
        ++a1[3];
        return v3;
      }
      v15 = *(_QWORD *)(*v3 + 8LL);
      if ( v12.n64_u32[0] > 1uLL )
      {
        if ( v15 >= v10.n64_u64[0] )
          v15 %= v10.n64_u64[0];
      }
      else
      {
        v15 &= v10.n64_u64[0] - 1;
      }
      v13 = (_QWORD *)(*a1 + 8 * v15);
    }
    *v13 = v3;
    goto LABEL_18;
  }
  return (_QWORD *)v9;
}


================================================================================
Function: sub_62E8B44 (0x62E8B44)
================================================================================

__int64 **__fastcall sub_62E8B44(unsigned __int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // x24
  unsigned __int64 v5; // x20
  uint8x8_t v6; // d0
  unsigned __int64 v7; // x25
  __int64 ***v8; // x8
  __int64 **v9; // x21
  const void *v10; // x22
  size_t v11; // x23
  unsigned __int64 v12; // x8
  float v13; // s1
  float v14; // s0
  float v15; // s0
  _BOOL8 v16; // x8
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x1

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    v5 = a2;
    v6.n64_u64[0] = vcnt_s8((int8x8_t)v4).n64_u64[0];
    v6.n64_u16[0] = vaddlv_u8(v6);
    v7 = v6.n64_u32[0];
    if ( v6.n64_u32[0] > 1uLL )
    {
      if ( v4 <= a2 )
        v5 = a2 % v4;
    }
    else
    {
      v5 = (v4 - 1) & a2;
    }
    v8 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v5);
    if ( v8 )
    {
      v9 = *v8;
      if ( *v8 )
      {
        v10 = *(const void **)a3;
        v11 = *(_QWORD *)(a3 + 8);
        do
        {
          v12 = (unsigned __int64)v9[1];
          if ( v7 > 1 )
          {
            if ( v12 >= v4 )
              v12 %= v4;
          }
          else
          {
            v12 &= v4 - 1;
          }
          if ( v12 != v5 )
            break;
          if ( v9[3] == (__int64 *)v11 && (!v11 || !memcmp(v9[2], v10, v11)) )
            return v9;
          v9 = (__int64 **)*v9;
        }
        while ( v9 );
      }
    }
  }
  v13 = *(float *)(a1 + 32);
  v14 = (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL);
  if ( !v4 || (float)(v13 * (float)v4) < v14 )
  {
    v15 = v14 / v13;
    v16 = 1LL;
    if ( v4 >= 3 )
      v16 = (v4 & (v4 - 1)) != 0;
    v17 = v16 | (2 * v4);
    v18 = vcvtps_u32_f32(v15);
    if ( v17 >= v18 )
      v19 = v17;
    else
      v19 = v18;
    sub_62E8C98(a1, v19);
  }
  return 0LL;
}


================================================================================
Function: sub_62E8C98 (0x62E8C98)
================================================================================

unsigned __int64 __fastcall sub_62E8C98(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x24
  unsigned __int64 v10; // x25
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  _QWORD *v13; // x26
  unsigned __int64 v14; // x28
  _QWORD *v15; // x8
  size_t v16; // x21
  const void *v17; // x22
  _QWORD *v18; // x23
  _QWORD *v19; // x27
  unsigned __int64 v20; // [xsp+0h] [xbp-40h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_681B888(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_681B888(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_65ECAAC();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_65ECAF4();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = (_QWORD *)*v9;
          if ( *v9 )
          {
            v20 = v11.n64_u32[0];
            do
            {
              v14 = v13[1];
              if ( v12 > 1 )
              {
                if ( v14 >= v3.n64_u64[0] )
                  v14 %= v3.n64_u64[0];
              }
              else
              {
                v14 &= v3.n64_u64[0] - 1;
              }
              if ( v14 == v10 )
              {
                v9 = v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v14) )
              {
                v15 = (_QWORD *)*v13;
                if ( *v13 && (v16 = v13[3], v16 == v15[3]) )
                {
                  v17 = (const void *)v13[2];
                  v18 = v13;
                  while ( 1 )
                  {
                    v19 = v15;
                    if ( v16 )
                    {
                      result = memcmp(v17, (const void *)v15[2], v16);
                      if ( (_DWORD)result )
                        break;
                    }
                    v15 = (_QWORD *)*v19;
                    if ( !*v19 )
                    {
                      v18 = v19;
                      goto LABEL_51;
                    }
                    v18 = v19;
                    if ( v16 != v15[3] )
                      goto LABEL_51;
                  }
                  v15 = v19;
                }
                else
                {
                  v18 = v13;
                }
LABEL_51:
                *v9 = v15;
                v12 = v20;
                *v18 = **(_QWORD **)(v2->n64_u64[0] + 8 * v14);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v14) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v14) = v9;
                v9 = v13;
                v10 = v14;
              }
              v13 = (_QWORD *)*v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_65ECAF4();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62E8F74 (0x62E8F74)
================================================================================

__int64 __fastcall sub_62E8F74(float *a1, const void **a2, __int128 *a3)
{
  unsigned __int64 v3; // x26
  size_t v4; // x22
  const void *v5; // x23
  unsigned __int64 v8; // x25
  char *v9; // x9
  char *v10; // x10
  __int64 v11; // t1
  unsigned __int64 v12; // x24
  uint8x8_t v13; // d0
  unsigned __int64 v14; // x27
  __int64 *v15; // x8
  __int64 i; // x20
  unsigned __int64 v17; // x8
  __int64 v18; // x0
  __int64 v19; // x8
  __int128 v20; // q0
  __int64 v21; // x9
  float v22; // s1
  float v23; // s0
  float v24; // s0
  _BOOL8 v25; // x8
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x1
  __int64 v29; // x8
  __int64 *v30; // x9
  __int64 v31; // x10
  unsigned __int64 v32; // x8

  v5 = *a2;
  v4 = (size_t)a2[1];
  v8 = 0LL;
  if ( v4 )
  {
    v9 = (char *)a2[1];
    v10 = (char *)*a2;
    do
    {
      v11 = *v10++;
      --v9;
      v8 ^= (v8 << 6) + (v8 >> 2) + v11 + 2654435769u;
    }
    while ( v9 );
  }
  v12 = *((_QWORD *)a1 + 1);
  if ( v12 )
  {
    v13.n64_u64[0] = vcnt_s8((int8x8_t)v12).n64_u64[0];
    v13.n64_u16[0] = vaddlv_u8(v13);
    v14 = v13.n64_u32[0];
    if ( v13.n64_u32[0] > 1uLL )
    {
      v3 = v8;
      if ( v8 >= v12 )
        v3 = v8 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v8;
    }
    v15 = *(__int64 **)(*(_QWORD *)a1 + 8 * v3);
    if ( v15 )
    {
      for ( i = *v15; i; i = *(_QWORD *)i )
      {
        v17 = *(_QWORD *)(i + 8);
        if ( v17 != v8 )
        {
          if ( v14 > 1 )
          {
            if ( v17 >= v12 )
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if ( v17 != v3 )
            break;
        }
        if ( *(_QWORD *)(i + 24) == v4 && (!v4 || !memcmp(*(const void **)(i + 16), v5, v4)) )
          return i;
      }
    }
  }
  v18 = sub_65ECAAC();
  v19 = *((_QWORD *)a1 + 3);
  i = v18;
  v20 = *a3;
  *(_QWORD *)v18 = 0LL;
  *(_QWORD *)(v18 + 8) = v8;
  v21 = *((_QWORD *)a3 + 2);
  v22 = a1[8];
  *(_OWORD *)(v18 + 16) = v20;
  *(_QWORD *)(v18 + 32) = v21;
  v23 = (float)(unsigned __int64)(v19 + 1);
  if ( !v12 || (float)(v22 * (float)v12) < v23 )
  {
    v24 = v23 / v22;
    v25 = 1LL;
    if ( v12 >= 3 )
      v25 = (v12 & (v12 - 1)) != 0;
    v26 = v25 | (2 * v12);
    v27 = vcvtps_u32_f32(v24);
    if ( v26 >= v27 )
      v28 = v26;
    else
      v28 = v27;
    sub_62E8C98(a1, v28);
    v12 = *((_QWORD *)a1 + 1);
    if ( (v12 & (v12 - 1)) != 0 )
    {
      if ( v8 >= v12 )
        v3 = v8 % v12;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v12 - 1) & v8;
    }
  }
  v29 = *(_QWORD *)a1;
  v30 = *(__int64 **)(*(_QWORD *)a1 + 8 * v3);
  if ( v30 )
  {
    *(_QWORD *)i = *v30;
    *v30 = i;
  }
  else
  {
    v31 = *((_QWORD *)a1 + 2);
    *((_QWORD *)a1 + 2) = i;
    *(_QWORD *)i = v31;
    *(_QWORD *)(v29 + 8 * v3) = a1 + 4;
    if ( *(_QWORD *)i )
    {
      v32 = *(_QWORD *)(*(_QWORD *)i + 8LL);
      if ( (v12 & (v12 - 1)) != 0 )
      {
        if ( v32 >= v12 )
          v32 %= v12;
      }
      else
      {
        v32 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v32) = i;
    }
  }
  ++*((_QWORD *)a1 + 3);
  return i;
}


================================================================================
Function: sub_62E91F4 (0x62E91F4)
================================================================================

_QWORD *__fastcall sub_62E91F4(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x19
  __int64 v5; // x8
  __int64 v6; // x21
  __int64 i; // x9
  __int64 *v8; // x22
  __int64 v9; // x24
  __int64 *v10; // x23
  __int64 v11; // x25

  v4 = result;
  v5 = result[1];
  v6 = a2;
  if ( v5 )
  {
    for ( i = 0LL; i != v5; ++i )
      *(_QWORD *)(*result + 8 * i) = 0LL;
    v8 = (__int64 *)result[2];
    result[2] = 0LL;
    result[3] = 0LL;
    if ( !v8 || a2 == a3 )
    {
      v10 = v8;
      v11 = a2;
    }
    else
    {
      do
      {
        *((_DWORD *)v8 + 4) = *(_DWORD *)v6;
        sub_684A438((unsigned __int8 *)v8 + 24, (unsigned __int8 *)(v6 + 8));
        v9 = v6 + 32;
        if ( (__int64 *)(v6 + 32) != v8 + 6 )
          sub_25750D0();
        v10 = (__int64 *)*v8;
        sub_62E9324(v4, v8);
        v11 = v6 + 56;
        if ( !v10 )
          break;
        v6 += 56LL;
        v8 = v10;
      }
      while ( v9 + 24 != a3 );
    }
    result = (_QWORD *)sub_62B191C(v4, v10);
    v6 = v11;
  }
  while ( v6 != a3 )
  {
    result = (_QWORD *)sub_62E9994(v4, v6, v6);
    v6 += 56LL;
  }
  return result;
}


================================================================================
Function: sub_62E9324 (0x62E9324)
================================================================================

_QWORD *__fastcall sub_62E9324(__int64 *a1, __int64 a2)
{
  __int64 v2; // x8
  _QWORD *v3; // x19
  unsigned __int64 v5; // x10
  bool v6; // zf
  unsigned __int64 v7; // x10
  char *v8; // x11
  unsigned __int64 v9; // x12
  __int64 v10; // t1
  __int64 v11; // x0
  int8x8_t v12; // x8
  unsigned __int64 v13; // x10
  uint8x8_t v14; // d0
  _QWORD *v15; // x11
  __int64 v16; // x12
  unsigned __int64 v17; // x10

  v2 = 2654435769LL;
  v3 = (_QWORD *)a2;
  v5 = *(unsigned __int8 *)(a2 + 24);
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
  {
    v8 = (char *)(a2 + 25);
  }
  else
  {
    v7 = *(_QWORD *)(a2 + 32);
    v8 = *(char **)(a2 + 40);
  }
  if ( v7 )
  {
    v9 = 0LL;
    do
    {
      v10 = *v8++;
      --v7;
      v9 ^= (v9 << 6) + 2654435769u + (v9 >> 2) + v10;
    }
    while ( v7 );
    v2 = v9 + 2654435769u;
  }
  *(_QWORD *)(a2 + 8) = (((unsigned __int64)(*(int *)(a2 + 16) + 2654435769LL) >> 2)
                       + ((*(int *)(a2 + 16) + 2654435769LL) << 6)
                       + v2) ^ (*(int *)(a2 + 16) + 2654435769LL);
  v11 = sub_62E9484(a1);
  if ( !v11 )
  {
    v12.n64_u64[0] = a1[1];
    v13 = v3[1];
    v14.n64_u64[0] = vcnt_s8(v12).n64_u64[0];
    v14.n64_u16[0] = vaddlv_u8(v14);
    if ( v14.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v12.n64_u64[0] )
        v13 %= v12.n64_u64[0];
    }
    else
    {
      v13 &= v12.n64_u64[0] - 1;
    }
    v15 = *(_QWORD **)(*a1 + 8 * v13);
    if ( v15 )
    {
      *v3 = *v15;
    }
    else
    {
      *v3 = a1[2];
      v16 = *a1;
      a1[2] = (__int64)v3;
      *(_QWORD *)(v16 + 8 * v13) = a1 + 2;
      if ( !*v3 )
      {
LABEL_23:
        ++a1[3];
        return v3;
      }
      v17 = *(_QWORD *)(*v3 + 8LL);
      if ( v14.n64_u32[0] > 1uLL )
      {
        if ( v17 >= v12.n64_u64[0] )
          v17 %= v12.n64_u64[0];
      }
      else
      {
        v17 &= v12.n64_u64[0] - 1;
      }
      v15 = (_QWORD *)(*a1 + 8 * v17);
    }
    *v15 = v3;
    goto LABEL_23;
  }
  return (_QWORD *)v11;
}


================================================================================
Function: sub_62E9484 (0x62E9484)
================================================================================

__int64 *__fastcall sub_62E9484(__int64 a1, unsigned __int64 a2, int *a3)
{
  unsigned __int64 v4; // x24
  unsigned __int64 v5; // x20
  uint8x8_t v6; // d0
  unsigned __int64 v7; // x25
  __int64 **v8; // x8
  unsigned __int64 v9; // x9
  __int64 *v10; // x21
  size_t v11; // x22
  unsigned __int8 *v12; // x23
  int v13; // w27
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x11
  const void *v17; // x0
  __int64 v18; // x9
  float v19; // s1
  float v20; // s0
  float v21; // s0
  _BOOL8 v22; // x8
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x1

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    v5 = a2;
    v6.n64_u64[0] = vcnt_s8((int8x8_t)v4).n64_u64[0];
    v6.n64_u16[0] = vaddlv_u8(v6);
    v7 = v6.n64_u32[0];
    if ( v6.n64_u32[0] > 1uLL )
    {
      if ( v4 <= a2 )
        v5 = a2 % v4;
    }
    else
    {
      v5 = (v4 - 1) & a2;
    }
    v8 = *(__int64 ***)(*(_QWORD *)a1 + 8 * v5);
    if ( v8 )
    {
      v9 = *((unsigned __int8 *)a3 + 8);
      v10 = *v8;
      v11 = (v9 & 1) != 0 ? *((_QWORD *)a3 + 2) : v9 >> 1;
      v12 = (v9 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a3 + 3) : (unsigned __int8 *)a3 + 9;
      if ( v10 )
      {
        v13 = *a3;
        do
        {
          v14 = v10[1];
          if ( v7 > 1 )
          {
            if ( v14 >= v4 )
              v14 %= v4;
          }
          else
          {
            v14 &= v4 - 1;
          }
          if ( v14 != v5 )
            break;
          if ( *((_DWORD *)v10 + 4) == v13 )
          {
            v15 = *((unsigned __int8 *)v10 + 24);
            v16 = v10[4];
            if ( (v15 & 1) == 0 )
              v16 = v15 >> 1;
            if ( v16 == v11 )
            {
              if ( (v15 & 1) != 0 )
                v17 = (const void *)v10[5];
              else
                v17 = (char *)v10 + 25;
              if ( (v15 & 1) != 0 )
              {
                if ( !v11 || !memcmp(v17, v12, v11) )
                  return v10;
              }
              else
              {
                if ( !v11 )
                  return v10;
                v18 = 0LL;
                while ( *((unsigned __int8 *)v10 + v18 + 25) == v12[v18] )
                {
                  if ( v15 >> 1 == ++v18 )
                    return v10;
                }
              }
            }
          }
          v10 = (__int64 *)*v10;
        }
        while ( v10 );
      }
    }
  }
  v19 = *(float *)(a1 + 32);
  v20 = (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL);
  if ( !v4 || (float)(v19 * (float)v4) < v20 )
  {
    v21 = v20 / v19;
    v22 = 1LL;
    if ( v4 >= 3 )
      v22 = (v4 & (v4 - 1)) != 0;
    v23 = v22 | (2 * v4);
    v24 = vcvtps_u32_f32(v21);
    if ( v23 >= v24 )
      v25 = v23;
    else
      v25 = v24;
    sub_62E9654(a1, v25);
  }
  return 0LL;
}


================================================================================
Function: sub_62E9654 (0x62E9654)
================================================================================

unsigned __int64 __fastcall sub_62E9654(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  __int64 **v9; // x21
  unsigned __int64 v10; // x23
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  __int64 *v13; // x25
  unsigned __int64 v14; // x11
  unsigned __int64 v15; // x26
  __int64 *v16; // x8
  int v17; // w22
  __int64 *v18; // x27
  __int64 *v19; // x28
  unsigned __int64 v20; // x10
  unsigned __int64 v21; // x11
  unsigned __int64 v22; // x8
  size_t v23; // x2
  unsigned __int64 v24; // x12
  unsigned __int8 *v25; // x1
  unsigned __int8 *v26; // x9
  unsigned __int64 v27; // [xsp+8h] [xbp-38h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_681B888(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_681B888(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_65ECAAC();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_65ECAF4();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (__int64 **)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = (unsigned __int64)v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = *v9;
          if ( *v9 )
          {
            v14 = v3.n64_u64[0] - 1;
            v27 = v11.n64_u32[0];
            do
            {
              v15 = v13[1];
              if ( v12 > 1 )
              {
                if ( v15 >= v3.n64_u64[0] )
                  v15 %= v3.n64_u64[0];
              }
              else
              {
                v15 &= v14;
              }
              if ( v15 == v10 )
              {
                v9 = (__int64 **)v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v15) )
              {
                v16 = (__int64 *)*v13;
                if ( *v13 )
                {
                  v17 = *((_DWORD *)v13 + 4);
                  v18 = v13;
                  while ( 1 )
                  {
                    v19 = v18;
                    v18 = v16;
                    if ( v17 != *((_DWORD *)v16 + 4) )
                      break;
                    v20 = *((unsigned __int8 *)v13 + 24);
                    v21 = *((unsigned __int8 *)v16 + 24);
                    v22 = v20 >> 1;
                    if ( (v20 & 1) != 0 )
                      v23 = v13[4];
                    else
                      v23 = v20 >> 1;
                    v24 = v21 >> 1;
                    if ( (v21 & 1) != 0 )
                      v24 = v18[4];
                    if ( v23 != v24 )
                      break;
                    if ( (v20 & 1) != 0 )
                      result = v13[5];
                    else
                      result = (unsigned __int64)v13 + 25;
                    if ( (v21 & 1) != 0 )
                      v25 = (unsigned __int8 *)v18[5];
                    else
                      v25 = (unsigned __int8 *)v18 + 25;
                    if ( (v20 & 1) != 0 )
                    {
                      if ( v23 )
                      {
                        result = memcmp((const void *)result, v25, v23);
                        if ( (_DWORD)result )
                          break;
                      }
                    }
                    else
                    {
                      v26 = (unsigned __int8 *)v13 + 25;
                      if ( v23 )
                      {
                        while ( *v26 == *v25 )
                        {
                          --v22;
                          ++v26;
                          ++v25;
                          if ( !v22 )
                            goto LABEL_44;
                        }
                        break;
                      }
                    }
LABEL_44:
                    v16 = (__int64 *)*v18;
                    if ( !*v18 )
                    {
                      v19 = v18;
                      v18 = 0LL;
                      break;
                    }
                  }
                  v14 = v3.n64_u64[0] - 1;
                  v12 = v27;
                }
                else
                {
                  v18 = 0LL;
                  v19 = v13;
                }
                *v9 = v18;
                *v19 = **(_QWORD **)(v2->n64_u64[0] + 8 * v15);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v15) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v15) = v9;
                v9 = (__int64 **)v13;
                v10 = v15;
              }
              v13 = *v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_65ECAF4();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62E9994 (0x62E9994)
================================================================================

__int64 __fastcall sub_62E9994(__int64 *a1, int *a2, __int64 a3)
{
  unsigned __int64 v3; // x27
  __int64 v4; // x8
  unsigned __int64 v7; // x9
  __int64 v8; // x28
  bool v9; // zf
  size_t v10; // x9
  size_t v11; // x21
  unsigned __int64 v12; // x9
  char *v13; // x22
  unsigned __int64 v14; // x10
  size_t v15; // x11
  char *v16; // x12
  __int64 v17; // t1
  unsigned __int64 v18; // x25
  __int64 v19; // x8
  unsigned __int64 v20; // x26
  uint8x8_t v21; // d0
  unsigned __int64 v22; // x13
  __int64 *v23; // x8
  __int64 v24; // x23
  unsigned __int64 v25; // x12
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  const void *v29; // x0
  __int64 v30; // x9
  __int64 v31; // x24
  unsigned __int64 v32; // x20
  unsigned __int64 v33; // x27
  int v34; // w0
  __int64 *v35; // x23
  __int64 v36; // x21
  __int64 v37; // x8
  float v38; // s1
  float v39; // s0
  _BOOL8 v40; // x9
  unsigned __int64 v41; // x10
  __int64 v42; // x1
  __int64 v43; // x8
  __int64 *v44; // x9
  __int64 v45; // x9
  unsigned __int64 v46; // x9
  unsigned __int64 v48; // [xsp+8h] [xbp-28h]

  v4 = 2654435769LL;
  v7 = *((unsigned __int8 *)a2 + 8);
  v8 = *a2;
  v9 = (v7 & 1) == 0;
  v10 = v7 >> 1;
  if ( v9 )
    v11 = v10;
  else
    v11 = *((_QWORD *)a2 + 2);
  v12 = v8 + 2654435769LL;
  if ( v9 )
    v13 = (char *)a2 + 9;
  else
    v13 = (char *)*((_QWORD *)a2 + 3);
  if ( v11 )
  {
    v14 = 0LL;
    v15 = v11;
    v16 = v13;
    do
    {
      v17 = *v16++;
      --v15;
      v14 ^= (v14 << 6) + 2654435769u + (v14 >> 2) + v17;
    }
    while ( v15 );
    v4 = v14 + 2654435769u;
  }
  v18 = a1[1];
  v19 = (v12 >> 2) + (v12 << 6) + v4;
  v20 = v19 ^ v12;
  if ( v18 )
  {
    v21.n64_u64[0] = vcnt_s8((int8x8_t)v18).n64_u64[0];
    v21.n64_u16[0] = vaddlv_u8(v21);
    v22 = v21.n64_u32[0];
    if ( v21.n64_u32[0] > 1uLL )
    {
      v3 = v19 ^ v12;
      if ( v20 >= v18 )
        v3 = v20 % v18;
    }
    else
    {
      v3 = (v18 - 1) & v20;
    }
    v23 = *(__int64 **)(*a1 + 8 * v3);
    if ( v23 )
    {
      v24 = *v23;
      if ( *v23 )
      {
        v25 = v18 - 1;
        v48 = v3;
        do
        {
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 != v20 )
          {
            if ( v22 > 1 )
            {
              if ( v26 >= v18 )
                v26 %= v18;
            }
            else
            {
              v26 &= v25;
            }
            if ( v26 != v3 )
              break;
          }
          if ( *(_DWORD *)(v24 + 16) == (_DWORD)v8 )
          {
            v27 = *(unsigned __int8 *)(v24 + 24);
            v28 = *(_QWORD *)(v24 + 32);
            if ( (v27 & 1) == 0 )
              v28 = v27 >> 1;
            if ( v28 == v11 )
            {
              if ( (v27 & 1) != 0 )
                v29 = *(const void **)(v24 + 40);
              else
                v29 = (const void *)(v24 + 25);
              if ( (v27 & 1) != 0 )
              {
                if ( !v11 )
                  return v24;
                v31 = a3;
                v32 = v25;
                v33 = v22;
                v34 = memcmp(v29, v13, v11);
                v22 = v33;
                v3 = v48;
                v25 = v32;
                a3 = v31;
                if ( !v34 )
                  return v24;
              }
              else
              {
                if ( !v11 )
                  return v24;
                v30 = 0LL;
                while ( *(unsigned __int8 *)(v24 + v30 + 25) == (unsigned __int8)v13[v30] )
                {
                  if ( v27 >> 1 == ++v30 )
                    return v24;
                }
              }
            }
          }
          v24 = *(_QWORD *)v24;
        }
        while ( v24 );
      }
    }
  }
  v35 = a1 + 2;
  v36 = sub_65ECAAC();
  *(_DWORD *)(v36 + 16) = *(_DWORD *)a3;
  sub_68497A0((unsigned __int64 *)(v36 + 24), (__int128 *)(a3 + 8));
  sub_2532D50((__int64 *)(v36 + 48), (__int128 **)(a3 + 32));
  v37 = a1[3];
  v38 = *((float *)a1 + 8);
  *(_QWORD *)v36 = 0LL;
  *(_QWORD *)(v36 + 8) = v20;
  v39 = (float)(unsigned __int64)(v37 + 1);
  if ( !v18 || (float)(v38 * (float)v18) < v39 )
  {
    v40 = v18 < 3 || (v18 & (v18 - 1)) != 0;
    v41 = vcvtps_u32_f32(v39 / v38);
    if ( (v40 | (2 * v18)) >= v41 )
      v42 = v40 | (2 * v18);
    else
      v42 = v41;
    sub_62E9654(a1, v42);
    v18 = a1[1];
    if ( (v18 & (v18 - 1)) != 0 )
    {
      if ( v20 >= v18 )
        v3 = v20 % v18;
      else
        v3 = v20;
    }
    else
    {
      v3 = (v18 - 1) & v20;
    }
  }
  v43 = *a1;
  v44 = *(__int64 **)(*a1 + 8 * v3);
  if ( v44 )
  {
    *(_QWORD *)v36 = *v44;
    *v44 = v36;
  }
  else
  {
    v45 = *v35;
    *v35 = v36;
    *(_QWORD *)v36 = v45;
    *(_QWORD *)(v43 + 8 * v3) = v35;
    if ( *(_QWORD *)v36 )
    {
      v46 = *(_QWORD *)(*(_QWORD *)v36 + 8LL);
      if ( (v18 & (v18 - 1)) != 0 )
      {
        if ( v46 >= v18 )
          v46 %= v18;
      }
      else
      {
        v46 &= v18 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v46) = v36;
    }
  }
  v24 = v36;
  ++a1[3];
  return v24;
}


================================================================================
Function: sub_62EB28C (0x62EB28C)
================================================================================

__int64 sub_62EB28C()
{
  unsigned __int8 v0; // w8
  _QWORD *v1; // x19
  __int64 v2; // x20

  v0 = atomic_load(byte_6CB1570);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6CB1570) )
  {
    qword_6CB1530 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6CB1538);
    qword_6CB1560 = 0LL;
    unk_6CB1568 = 0LL;
    qword_6CB1530 = (__int64)off_6871A40;
    qword_6CB1578 = (__int64)&qword_6CB1530;
    sub_6862850(byte_6CB1570);
  }
  v1 = (_QWORD *)sub_2533228((__int64)&qword_6CB1530);
  v2 = sub_62ADC40(v1[6]);
  (*(void (__fastcall **)(_QWORD *))(*v1 + 16LL))(v1);
  return v2;
}


================================================================================
Function: sub_62EDABC (0x62EDABC)
================================================================================

__int64 __fastcall sub_62EDABC(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  _BYTE v4[56]; // [xsp+0h] [xbp-40h] BYREF

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 80) = a2;
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 88), 0LL) )
  {
    sub_25C1BEC(v4);
    sub_25C1ABC((__int64)v4);
  }
  sub_25C1984(a1 + 128);
  result = sub_67DE848(a1 + 216);
  *(_QWORD *)(a1 + 237) = 0LL;
  *(_QWORD *)(a1 + 232) = 0LL;
  return result;
}


================================================================================
Function: sub_62F04E0 (0x62F04E0)
================================================================================

__int64 __usercall sub_62F04E0@<X0>(__int64 a1@<X8>)
{
  __int64 v2; // x20

  v2 = sub_65ECAAC();
  sub_62F4F5C();
  return sub_62F5250(a1, v2);
}


================================================================================
Function: sub_62F2420 (0x62F2420)
================================================================================

__int64 __fastcall sub_62F2420(__int64 a1, int a2)
{
  __int64 v4; // x6
  __int64 v5; // x7
  long double v6; // q1
  long double v7; // q2
  long double v8; // q3
  unsigned __int8 v9; // w8
  __int64 result; // x0
  __int64 v11; // x1
  char v12; // w11
  int v13; // w10
  unsigned int v14; // w8
  __int64 vars0; // [xsp+0h] [xbp+0h]

  sub_62CAC2C();
  *(_BYTE *)(a1 + 888) = 0;
  *(_QWORD *)a1 = off_6C1EFA8;
  *(_OWORD *)(a1 + 872) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 928) = 0u;
  *(_OWORD *)(a1 + 944) = 0u;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(_OWORD *)(a1 + 1008) = 0u;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_OWORD *)(a1 + 1104) = 0u;
  *(_OWORD *)(a1 + 1120) = 0u;
  *(_OWORD *)(a1 + 1136) = 0u;
  *(_OWORD *)(a1 + 1152) = 0u;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(_OWORD *)(a1 + 1184) = 0u;
  *(_OWORD *)(a1 + 1200) = 0u;
  *(_DWORD *)(a1 + 1216) = 0;
  v9 = atomic_load(byte_6FF33D8);
  *(_DWORD *)(a1 + 448) = a2;
  result = qword_6FF2A10;
  v11 = qword_6FF2A18;
  v12 = v9 & 1;
  v13 = (unsigned __int8)byte_724A7A8;
  v14 = (unsigned __int8)qword_6FF2A10;
  *(_BYTE *)(a1 + 1220) = v12;
  if ( !v13 || !byte_724A758 )
  {
    if ( !v14 )
      return result;
    return sub_65C5C5C(
             result,
             v11,
             (__int64)"[DFLog::HttpTrace] HttpRequestCurl(%p, %d, %d)",
             a1,
             *(unsigned __int8 *)(a1 + 709),
             *(unsigned int *)(a1 + 328),
             v4,
             v5,
             COERCE_LONG_DOUBLE((unsigned __int128)0LL),
             v6,
             v7,
             v8,
             vars0);
  }
  if ( v14 >= 6 && BYTE1(result) >= 3u )
    return sub_65C5C5C(
             result,
             v11,
             (__int64)"[DFLog::HttpTrace] HttpRequestCurl(%p, %d, %d)",
             a1,
             *(unsigned __int8 *)(a1 + 709),
             *(unsigned int *)(a1 + 328),
             v4,
             v5,
             COERCE_LONG_DOUBLE((unsigned __int128)0LL),
             v6,
             v7,
             v8,
             vars0);
  return result;
}


================================================================================
Function: sub_62F4F5C (0x62F4F5C)
================================================================================

__int64 __fastcall sub_62F4F5C(__int64 a1)
{
  unsigned int v2; // w1
  unsigned int v3; // w1
  unsigned int v4; // w1
  _QWORD v6[7]; // [xsp+10h] [xbp-40h] BYREF

  v2 = pthread_mutex_init((pthread_mutex_t *)a1, 0LL);
  if ( v2
    || (v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 40), 0LL)) != 0
    || (v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 80), 0LL)) != 0
    || (v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 120), 0LL)) != 0 )
  {
    sub_25C1BEC(v6, v2, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25C1ABC((__int64)v6);
  }
  v3 = pthread_mutex_init((pthread_mutex_t *)(a1 + 160), 0LL);
  if ( v3 )
  {
    sub_25C1BEC(v6, v3, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25C1ABC((__int64)v6);
  }
  *(_QWORD *)(a1 + 208) = 0LL;
  *(_QWORD *)(a1 + 200) = a1 + 208;
  *(_QWORD *)(a1 + 216) = 0LL;
  *(_QWORD *)(a1 + 240) = 0LL;
  *(_QWORD *)(a1 + 232) = a1 + 240;
  *(_QWORD *)(a1 + 264) = 0LL;
  *(_QWORD *)(a1 + 256) = a1 + 264;
  *(_QWORD *)(a1 + 248) = 0LL;
  *(_QWORD *)(a1 + 272) = 0LL;
  *(_DWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 296) = a1 + 296;
  *(_QWORD *)(a1 + 304) = a1 + 296;
  *(_BYTE *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 312) = 0LL;
  v4 = pthread_mutex_init((pthread_mutex_t *)(a1 + 320), 0LL);
  if ( v4 )
  {
    sub_25C1BEC(v6, v4, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25C1ABC((__int64)v6);
  }
  *(_QWORD *)(a1 + 368) = 0LL;
  *(_QWORD *)(a1 + 376) = 0LL;
  *(_QWORD *)(a1 + 360) = a1 + 368;
  sub_676897C(sub_62F52C0, sub_62F5320, sub_62F5390);
  sub_62FA884(7LL, sub_62F5394, sub_62F55F0, sub_62F5630, sub_62F5714, sub_62F5764);
  sub_62F57D0(a1);
  sub_62F58A0(a1, 0LL);
  return sub_62F5A24(a1);
}


================================================================================
Function: sub_62F5250 (0x62F5250)
================================================================================

_QWORD *__fastcall sub_62F5250(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // x0

  *a1 = a2;
  result = (_QWORD *)sub_65ECAAC();
  result[2] = 0LL;
  result[3] = a2;
  a1[1] = result;
  *result = off_6C1F038;
  result[1] = 0LL;
  return result;
}


================================================================================
Function: sub_62F57D0 (0x62F57D0)
================================================================================

__int64 __fastcall sub_62F57D0(pthread_mutex_t *a1)
{
  __int64 result; // x0
  pthread_mutex_t *v2; // x19
  _QWORD v3[7]; // [xsp+0h] [xbp-50h] BYREF
  pthread_mutex_t *v4; // [xsp+38h] [xbp-18h] BYREF
  char v5; // [xsp+40h] [xbp-10h]

  v4 = a1 + 4;
  v5 = 0;
  sub_25C6ADC(&v4);
  result = sub_675B13C(sub_62F5F04);
  if ( v5 )
  {
    v2 = v4;
    do
      result = pthread_mutex_unlock(v2);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25C5E54(v3, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24((__int64)v3);
    }
  }
  return result;
}


================================================================================
Function: sub_62F58A0 (0x62F58A0)
================================================================================

__int64 __fastcall sub_62F58A0(_QWORD *a1, int a2)
{
  __int64 v4; // x19
  unsigned int v5; // w0
  unsigned int v6; // w0
  unsigned int v7; // w0
  unsigned int v8; // w0
  __int64 result; // x0
  __int64 *v10; // x23
  _QWORD *v11; // x24
  int v12; // w8
  __int64 v13; // x22
  __int64 v14; // x0
  __int64 *v15; // x8
  __int64 v16; // x8
  __int64 v17; // x1

  v4 = sub_632EBEC();
  v5 = sub_632EC48(v4, 5LL, a1);
  sub_62F5FD8("CURLSHOPT_USERDATA", v5, 1LL);
  v6 = sub_632EC48(v4, 3LL, sub_62F60EC);
  sub_62F5FD8("CURLSHOPT_LOCKFUNC", v6, 1LL);
  v7 = sub_632EC48(v4, 4LL, sub_62F6250);
  sub_62F5FD8("CURLSHOPT_UNLOCKFUNC", v7, 1LL);
  v8 = sub_632EC48(v4, 1LL, 2LL);
  result = sub_62F5FD8("CURLSHOPT_SHARE", v8, 1LL);
  v10 = a1 + 26;
  v11 = (_QWORD *)a1[26];
  if ( v11 )
  {
    v10 = a1 + 26;
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = *((_DWORD *)v11 + 8);
        if ( v12 > a2 )
          break;
        if ( v12 >= a2 )
          goto LABEL_10;
        v10 = v11 + 1;
        if ( !v11[1] )
          goto LABEL_10;
        v11 = (_QWORD *)v11[1];
      }
      if ( !*v11 )
        break;
      v10 = v11;
      v11 = (_QWORD *)*v11;
    }
    v10 = v11;
    goto LABEL_11;
  }
  v11 = a1 + 26;
LABEL_10:
  v13 = *v10;
  if ( !*v10 )
  {
LABEL_11:
    v14 = sub_65ECAAC();
    *(_QWORD *)(v14 + 40) = 0LL;
    v13 = v14;
    *(_QWORD *)v14 = 0LL;
    *(_QWORD *)(v14 + 8) = 0LL;
    *(_QWORD *)(v14 + 16) = v11;
    *v10 = v14;
    v15 = (__int64 *)a1[25];
    *(_DWORD *)(v14 + 32) = a2;
    v16 = *v15;
    if ( v16 )
    {
      a1[25] = v16;
      v17 = *v10;
    }
    else
    {
      v17 = v14;
    }
    result = sub_2527820(a1[26], v17);
    ++a1[27];
  }
  *(_QWORD *)(v13 + 40) = v4;
  return result;
}


================================================================================
Function: sub_62F5A24 (0x62F5A24)
================================================================================

__int64 __fastcall sub_62F5A24(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x19
  _QWORD *v4; // x22
  _QWORD *v5; // x23
  _QWORD *v6; // x21
  _QWORD *v7; // x0
  __int64 v8; // x8
  _QWORD *v9; // x1

  result = sub_632105C();
  v3 = result;
  v4 = (_QWORD *)(a1 + 240);
  v5 = *(_QWORD **)(a1 + 240);
  *(_QWORD *)(a1 + 224) = result;
  if ( v5 )
  {
    if ( !v5[4] )
    {
      v4 = (_QWORD *)(a1 + 240);
      v6 = *(_QWORD **)(a1 + 240);
      if ( v6 )
        goto LABEL_14;
      goto LABEL_8;
    }
    while ( 1 )
    {
      v4 = v5;
      v5 = (_QWORD *)*v5;
      if ( !v5 )
        break;
      if ( !v5[4] )
        goto LABEL_7;
    }
  }
  v5 = v4;
LABEL_7:
  v6 = (_QWORD *)*v4;
  if ( !*v4 )
  {
LABEL_8:
    v7 = (_QWORD *)sub_65ECAAC();
    *v7 = 0LL;
    v7[1] = 0LL;
    v6 = v7;
    v7[4] = 0LL;
    v7[5] = 0LL;
    v7[2] = v5;
    *v4 = v7;
    v8 = **(_QWORD **)(a1 + 232);
    if ( v8 )
    {
      *(_QWORD *)(a1 + 232) = v8;
      v9 = (_QWORD *)*v4;
    }
    else
    {
      v9 = v7;
    }
    result = sub_2527820(*(_QWORD *)(a1 + 240), v9);
    ++*(_QWORD *)(a1 + 248);
  }
LABEL_14:
  v6[5] = v3;
  return result;
}


================================================================================
Function: sub_62F5FD8 (0x62F5FD8)
================================================================================

bool __fastcall sub_62F5FD8(
        __int64 a1,
        unsigned int a2,
        char a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  __int64 v15; // [xsp+0h] [xbp+0h]

  if ( !a2 )
  {
    if ( byte_724A7A8 && byte_724A758 )
    {
      if ( (unsigned __int8)qword_6FF2A10 < 6u || BYTE1(qword_6FF2A10) < 3u )
        return a2 != 0;
    }
    else if ( !(_BYTE)qword_6FF2A10 )
    {
      return a2 != 0;
    }
    sub_65C5C5C(
      qword_6FF2A10,
      qword_6FF2A18,
      (__int64)"[DFLog::HttpTrace] HttpRequestCurl curl op:%s",
      a1,
      a9,
      a10,
      a11,
      a12,
      a4,
      a5,
      a6,
      a7,
      v15);
    return a2 != 0;
  }
  if ( !byte_724A7A8 || !byte_724A758 )
  {
    if ( !(_BYTE)qword_6FF2A50 )
      goto LABEL_14;
    goto LABEL_13;
  }
  if ( (unsigned __int8)qword_6FF2A50 >= 6u && BYTE1(qword_6FF2A50) >= 3u )
LABEL_13:
    sub_65C5C5C(
      qword_6FF2A50,
      qword_6FF2A58,
      (__int64)"[DFLog::HttpTraceError] HttpRequestCurl curl error:%d op:%s",
      a2,
      a1,
      a10,
      a11,
      a12,
      a4,
      a5,
      a6,
      a7,
      v15);
LABEL_14:
  if ( (a3 & 1) != 0 )
    sub_65F12C8("HttpRequestCurl curl error:%d op:%s");
  return a2 != 0;
}


================================================================================
Function: sub_62FA884 (0x62FA884)
================================================================================

__int64 __fastcall sub_62FA884(
        __int64 a1,
        __int64 (__fastcall *a2)(),
        __int64 (__fastcall *a3)(),
        __int64 (__fastcall *a4)(),
        void *a5,
        __int64 (__fastcall *a6)())
{
  __int64 result; // x0
  int v12; // w8

  result = 2LL;
  if ( a2 && a3 && a4 && a5 && a6 )
  {
    while ( (unsigned int)sub_68671B0(1LL, &dword_6FF4498) )
    {
      while ( dword_6FF4498 )
        __yield();
    }
    if ( dword_6FF449C )
    {
      result = 0LL;
      v12 = dword_6FF449C + 1;
    }
    else
    {
      off_6CA6300[0] = a2;
      off_6CA6308[0] = a3;
      off_6CA6318 = a5;
      off_6CA6310 = a4;
      off_6CA6320 = a6;
      dword_6FF449C = 1;
      if ( !(unsigned int)sub_62FB850() )
      {
        if ( (unsigned int)sub_633DF18() )
        {
          result = sub_630384C();
          if ( !(_DWORD)result )
            goto LABEL_16;
        }
      }
      result = 2LL;
      v12 = dword_6FF449C - 1;
    }
    dword_6FF449C = v12;
LABEL_16:
    atomic_store(0, (unsigned int *)&dword_6FF4498);
  }
  return result;
}


================================================================================
Function: sub_62FAA24 (0x62FAA24)
================================================================================

__int64 sub_62FAA24()
{
  __int64 result; // x0
  __int64 v1; // [xsp+0h] [xbp-10h] BYREF

  while ( (unsigned int)sub_68671B0(1u, (atomic_uint *)&dword_6FF4498) )
  {
    while ( dword_6FF4498 )
      __yield();
  }
  if ( !dword_6FF449C
    && ((off_6CA6300[0] = (__int64 (__fastcall *)())sub_67F3A24,
         off_6CA6308[0] = (__int64 (__fastcall *)())sub_67F3C08,
         off_6CA6310 = (__int64 (__fastcall *)())sub_67F3BA8,
         off_6CA6318 = (char *(*)(const char *))&strdup,
         dword_6FF449C = 1,
         off_6CA6320 = (__int64 (__fastcall *)(_QWORD, _QWORD))sub_67F3AC4,
         (unsigned int)sub_62FB850())
     || !(unsigned int)sub_633DF18()
     || (unsigned int)sub_630384C()) )
  {
    result = 0LL;
    --dword_6FF449C;
    atomic_store(0, (unsigned int *)&dword_6FF4498);
  }
  else
  {
    atomic_store(0, (unsigned int *)&dword_6FF4498);
    if ( (unsigned int)sub_6333390(&v1) )
      return 0LL;
    else
      return v1;
  }
  return result;
}


================================================================================
Function: sub_62FAFF4 (0x62FAFF4)
================================================================================

size_t __fastcall sub_62FAFF4(size_t result, unsigned int a2, const void *a3, size_t a4)
{
  size_t v6; // x19
  char v8; // w23

  if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
  {
    v6 = result;
    if ( *(_QWORD *)(result + 616) )
    {
      v8 = sub_632425C(result);
      sub_6324230(v6, 1LL);
      (*(void (__fastcall **)(size_t, _QWORD, const void *, size_t, _QWORD))(v6 + 616))(
        v6,
        a2,
        a3,
        a4,
        *(_QWORD *)(v6 + 464));
      return sub_6324230(v6, v8 & 1);
    }
    else if ( a2 <= 2 )
    {
      fwrite(&asc_16B8EC8[3 * a2], 2uLL, 1uLL, *(FILE **)(result + 456));
      return fwrite(a3, a4, 1uLL, *(FILE **)(v6 + 456));
    }
  }
  return result;
}


================================================================================
Function: sub_62FB0E8 (0x62FB0E8)
================================================================================

size_t sub_62FB0E8(size_t result, __int64 a2, ...)
{
  size_t v2; // x19
  int v3; // w20
  gcc_va_list va1; // [xsp+B0h] [xbp-150h] BYREF
  gcc_va_list va; // [xsp+D0h] [xbp-130h] BYREF
  char src[260]; // [xsp+F4h] [xbp-10Ch] BYREF

  v2 = result;
  if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 || *(_QWORD *)(result + 472) )
  {
    va_start(va, a2);
    va_copy(va1, va);
    v3 = sub_631F65C(src, 256LL, a2, (__int128 *)va1);
    if ( *(_QWORD *)(v2 + 472) )
    {
      if ( (*(_BYTE *)(v2 + 4692) & 8) == 0 )
      {
        strcpy(*(char **)(v2 + 472), src);
        *(_DWORD *)(v2 + 4692) |= 8u;
      }
    }
    *(_WORD *)&src[v3] = 10;
    return sub_62FAFF4(v2, 0, src, v3 + 1LL);
  }
  return result;
}


================================================================================
Function: sub_62FB210 (0x62FB210)
================================================================================

__int64 __fastcall sub_62FB210(
        __int64 result,
        const char *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x19
  __int64 v11; // x8
  const char **v12; // x8
  int v13; // w21
  int v14; // w8
  int v15; // w9
  _BYTE *v16; // x11
  _QWORD v17[6]; // [xsp+80h] [xbp-8A0h] BYREF
  __int128 v18; // [xsp+B0h] [xbp-870h] BYREF
  __int128 v19; // [xsp+C0h] [xbp-860h]
  __int128 v20; // [xsp+D0h] [xbp-850h]
  __int128 v21; // [xsp+E0h] [xbp-840h]
  _OWORD v22[2]; // [xsp+F0h] [xbp-830h] BYREF
  _BYTE v23[2056]; // [xsp+110h] [xbp-810h] BYREF

  v17[3] = a6;
  v17[4] = a7;
  v17[1] = a4;
  v17[2] = a5;
  v17[0] = a3;
  v17[5] = a8;
  if ( result )
  {
    v9 = result;
    if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
    {
      v11 = *(_QWORD *)(result + 4576);
      if ( !v11 || *(int *)(v11 + 8) >= 1 )
      {
        *(_QWORD *)&v20 = &a9;
        *((_QWORD *)&v20 + 1) = &v18;
        v12 = *(const char ***)(result + 4576);
        *(_QWORD *)&v21 = v17;
        *((_QWORD *)&v21 + 1) = 0xFFFFFF80FFFFFFD0LL;
        v18 = v20;
        v19 = v21;
        if ( v12 )
          v13 = sub_63209BC(v23, 2049LL, "[%s] ", *v12);
        else
          v13 = 0;
        v22[0] = v18;
        v22[1] = v19;
        v14 = sub_631F65C(&v23[v13], 2049 - v13, a2, v22) + v13;
        if ( v14 >= 2048 )
        {
          v15 = v14 - 1;
          v16 = &v23[v14];
          v14 += 2;
          v23[v15] = 46;
          *v16 = 46;
          v16[1] = 46;
        }
        *(_WORD *)&v23[v14] = 10;
        return sub_62FAFF4(v9, 0LL, v23, v14 + 1LL);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62FB380 (0x62FB380)
================================================================================

size_t __fastcall sub_62FB380(
        size_t result,
        const char ***a2,
        const char *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  size_t v9; // x19
  __int64 v12; // x8
  int v13; // w0
  __int64 v14; // x23
  int v15; // w4
  __int64 v16; // x1
  const char *v17; // x3
  int v18; // w0
  __int64 v19; // x9
  _QWORD v20[6]; // [xsp+80h] [xbp-880h] BYREF
  __int128 v21[2]; // [xsp+B0h] [xbp-850h] BYREF
  __int128 v22; // [xsp+D0h] [xbp-830h]
  __int128 v23; // [xsp+E0h] [xbp-820h]
  _BYTE v24[2052]; // [xsp+F4h] [xbp-80Ch] BYREF

  v20[3] = a6;
  v20[4] = a7;
  v20[1] = a4;
  v20[2] = a5;
  v20[5] = a8;
  if ( result )
  {
    v9 = result;
    if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
    {
      v12 = *(_QWORD *)(result + 4576);
      if ( v12 )
      {
        if ( !a2 || *(int *)(v12 + 8) <= 0 || *((int *)*a2 + 3) <= 0 )
          return result;
        v13 = sub_63209BC(v24, 2048LL, "[%s] ", *(const char **)v12);
      }
      else
      {
        if ( !a2 || *((int *)*a2 + 3) <= 0 )
          return result;
        v13 = 0;
      }
      v14 = v13;
      v15 = *((_DWORD *)a2 + 8);
      v16 = 2048 - v13;
      v17 = **a2;
      if ( v15 )
        v18 = sub_63209BC(&v24[v13], v16, "[%s-%d] ", v17, v15);
      else
        v18 = sub_63209BC(&v24[v13], v16, "[%s] ", v17);
      *(_QWORD *)&v23 = v20;
      *((_QWORD *)&v23 + 1) = 0xFFFFFF80FFFFFFD8LL;
      *(_QWORD *)&v22 = &a9;
      *((_QWORD *)&v22 + 1) = v21;
      v21[0] = v22;
      v21[1] = v23;
      v19 = (int)sub_631F65C(&v24[v14 + v18], 2048 - ((int)v14 + v18), (__int64)a3, v21) + (__int64)((int)v14 + v18);
      *(_WORD *)&v24[v19] = 10;
      return sub_62FAFF4(v9, 0, v24, v19 + 1);
    }
  }
  return result;
}


================================================================================
Function: sub_62FB530 (0x62FB530)
================================================================================

size_t __fastcall sub_62FB530(
        size_t result,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  size_t v9; // x19
  __int64 v11; // x8
  int v12; // w21
  int v13; // w8
  int v14; // w9
  _BYTE *v15; // x11
  _QWORD v16[6]; // [xsp+80h] [xbp-8A0h] BYREF
  __int128 v17; // [xsp+B0h] [xbp-870h] BYREF
  __int128 v18; // [xsp+C0h] [xbp-860h]
  __int128 v19; // [xsp+D0h] [xbp-850h]
  __int128 v20; // [xsp+E0h] [xbp-840h]
  __int128 v21[2]; // [xsp+F0h] [xbp-830h] BYREF
  _BYTE v22[2056]; // [xsp+110h] [xbp-810h] BYREF

  v16[3] = a6;
  v16[4] = a7;
  v16[1] = a4;
  v16[2] = a5;
  v16[0] = a3;
  v16[5] = a8;
  if ( result )
  {
    v9 = result;
    if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
    {
      v11 = *(_QWORD *)(result + 4576);
      if ( v11 )
      {
        if ( *(int *)(v11 + 8) < 1 || dword_6CA6330 <= 0 )
          return result;
      }
      else if ( dword_6CA6330 < 1 )
      {
        return result;
      }
      *(_QWORD *)&v19 = &a9;
      *((_QWORD *)&v19 + 1) = &v17;
      *(_QWORD *)&v20 = v16;
      *((_QWORD *)&v20 + 1) = 0xFFFFFF80FFFFFFD0LL;
      v17 = v19;
      v18 = v20;
      v12 = sub_63209BC(v22, 2049LL, "[%s] ", off_6CA6328);
      v21[0] = v17;
      v21[1] = v18;
      v13 = sub_631F65C(&v22[v12], 2049 - v12, a2, v21) + v12;
      if ( v13 >= 2048 )
      {
        v14 = v13 - 1;
        v15 = &v22[v13];
        v13 += 2;
        v22[v14] = 46;
        *v15 = 46;
        v15[1] = 46;
      }
      *(_WORD *)&v22[v13] = 10;
      return sub_62FAFF4(v9, 0, v22, v13 + 1LL);
    }
  }
  return result;
}


================================================================================
Function: sub_62FB6C0 (0x62FB6C0)
================================================================================

size_t __fastcall sub_62FB6C0(
        size_t result,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  size_t v9; // x19
  __int64 v11; // x8
  int v12; // w21
  int v13; // w8
  int v14; // w9
  _BYTE *v15; // x11
  _QWORD v16[6]; // [xsp+80h] [xbp-8A0h] BYREF
  __int128 v17; // [xsp+B0h] [xbp-870h] BYREF
  __int128 v18; // [xsp+C0h] [xbp-860h]
  __int128 v19; // [xsp+D0h] [xbp-850h]
  __int128 v20; // [xsp+E0h] [xbp-840h]
  __int128 v21[2]; // [xsp+F0h] [xbp-830h] BYREF
  _BYTE v22[2056]; // [xsp+110h] [xbp-810h] BYREF

  v16[3] = a6;
  v16[4] = a7;
  v16[1] = a4;
  v16[2] = a5;
  v16[0] = a3;
  v16[5] = a8;
  if ( result )
  {
    v9 = result;
    if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
    {
      v11 = *(_QWORD *)(result + 4576);
      if ( v11 )
      {
        if ( *(int *)(v11 + 8) < 1 || dword_6CA6340 <= 0 )
          return result;
      }
      else if ( dword_6CA6340 < 1 )
      {
        return result;
      }
      *(_QWORD *)&v19 = &a9;
      *((_QWORD *)&v19 + 1) = &v17;
      *(_QWORD *)&v20 = v16;
      *((_QWORD *)&v20 + 1) = 0xFFFFFF80FFFFFFD0LL;
      v17 = v19;
      v18 = v20;
      v12 = sub_63209BC(v22, 2049LL, "[%s] ", off_6CA6338);
      v21[0] = v17;
      v21[1] = v18;
      v13 = sub_631F65C(&v22[v12], 2049 - v12, a2, v21) + v12;
      if ( v13 >= 2048 )
      {
        v14 = v13 - 1;
        v15 = &v22[v13];
        v13 += 2;
        v22[v14] = 46;
        *v15 = 46;
        v15[1] = 46;
      }
      *(_WORD *)&v22[v13] = 10;
      return sub_62FAFF4(v9, 0, v22, v13 + 1LL);
    }
  }
  return result;
}


================================================================================
Function: sub_62FB850 (0x62FB850)
================================================================================

__int64 sub_62FB850()
{
  return 0LL;
}


================================================================================
Function: sub_62FDE20 (0x62FDE20)
================================================================================

unsigned __int64 __fastcall sub_62FDE20(unsigned __int64 result, __int64 a2, int a3)
{
  __int64 v3; // x8
  __int64 *v4; // x20
  unsigned __int64 v5; // x19
  __int64 v6; // x8
  __int64 *v7; // x22

  v3 = a2 + 8LL * a3;
  v4 = *(__int64 **)(v3 + 608);
  if ( v4 )
  {
    v5 = result;
    *(_QWORD *)(v3 + 608) = 0LL;
    do
    {
      v6 = *v4;
      v7 = (__int64 *)v4[1];
      v4[1] = 0LL;
      (*(void (__fastcall **)(__int64 *, unsigned __int64))(v6 + 16))(v4, v5);
      result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v4);
      v4 = v7;
    }
    while ( v7 );
  }
  return result;
}


================================================================================
Function: sub_62FDE8C (0x62FDE8C)
================================================================================

__int64 __fastcall sub_62FDE8C(__int64 a1, int a2)
{
  __int64 v4; // x0
  __int64 result; // x0
  __int64 v6; // x8

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL * a2 + 608);
  if ( v4 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 32LL))(v4, a1);
  result = a1;
  v6 = *(_QWORD *)(a1 + 24) + 16LL * a2;
  *(_QWORD *)(v6 + 632) = 0LL;
  *(_QWORD *)(v6 + 624) = 0LL;
  return result;
}


================================================================================
Function: sub_62FDED4 (0x62FDED4)
================================================================================

__int64 __fastcall sub_62FDED4(__int64 a1, unsigned int a2, _BYTE *a3)
{
  __int64 *v4; // x20
  unsigned int v7; // w22
  __int64 v9; // x1
  _DWORD *v10; // x25
  __int64 v11; // x8
  __int64 v12; // x8
  __int64 v13; // x8
  __int64 v14; // x8
  _BYTE v15[4]; // [xsp+4h] [xbp-1Ch] BYREF
  _QWORD v16[2]; // [xsp+8h] [xbp-18h] BYREF

  v4 = *(__int64 **)(*(_QWORD *)(a1 + 24) + 8LL * (int)a2 + 608);
  if ( !v4 )
  {
LABEL_4:
    v7 = 0;
    *a3 = 1;
    return v7;
  }
  while ( (*((_BYTE *)v4 + 36) & 3) != 1 )
  {
    v4 = (__int64 *)v4[1];
    if ( !v4 )
      goto LABEL_4;
  }
  *a3 = 0;
  v16[0] = sub_63315AC();
  v16[1] = v9;
  if ( (sub_62FF88C(a1, a2) & 1) != 0 )
  {
    if ( sub_62FF6E4(*(_QWORD *)(a1 + 24), a2, v16) < 0 )
    {
      sub_62FB0E8(a1, "SSL shutdown timeout");
      return 28;
    }
  }
  else
  {
    sub_62FF658(a1, a2, v16);
  }
  v10 = (_DWORD *)(a1 + 2458);
  while ( 1 )
  {
    if ( (*((_BYTE *)v4 + 36) & 2) != 0 )
      goto LABEL_12;
    v11 = *v4;
    v15[0] = 0;
    v7 = (*(__int64 (__fastcall **)(__int64 *, __int64, _BYTE *))(v11 + 40))(v4, a1, v15);
    if ( v7 )
      break;
    if ( !v15[0] )
    {
      if ( a1 )
      {
        if ( (*v10 & 0x100000) != 0 )
        {
          v14 = *(_QWORD *)(a1 + 4576);
          if ( (!v14 || *(int *)(v14 + 8) >= 1) && *(int *)(*v4 + 12) >= 1 )
            sub_62FB380(a1, v4, "shut down not done yet");
        }
      }
      return v7;
    }
    if ( a1 )
    {
      if ( (*v10 & 0x100000) != 0 )
      {
        v12 = *(_QWORD *)(a1 + 4576);
        if ( (!v12 || *(int *)(v12 + 8) >= 1) && *(int *)(*v4 + 12) >= 1 )
          sub_62FB380(a1, v4, "shut down successfully");
      }
    }
    *((_BYTE *)v4 + 36) |= 2u;
LABEL_12:
    v4 = (__int64 *)v4[1];
    if ( !v4 )
      goto LABEL_4;
  }
  if ( a1 )
  {
    if ( (*v10 & 0x100000) != 0 )
    {
      v13 = *(_QWORD *)(a1 + 4576);
      if ( (!v13 || *(int *)(v13 + 8) >= 1) && *(int *)(*v4 + 12) >= 1 )
        sub_62FB380(a1, v4, "shut down failed with %d", v7);
    }
  }
  return v7;
}


================================================================================
Function: sub_62FE638 (0x62FE638)
================================================================================

__int64 __fastcall sub_62FE638(__int64 a1, int a2)
{
  __int64 v3; // x9
  __int64 result; // x0
  int v5; // w0
  int v6; // [xsp+4h] [xbp-Ch] BYREF

  v3 = *(_QWORD *)(a1 + 24);
  v6 = 0;
  result = *(_QWORD *)(v3 + 8LL * a2 + 608);
  if ( result )
  {
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, int *, _QWORD))(*(_QWORD *)result + 112LL))(
           result,
           a1,
           7LL,
           &v6,
           0LL);
    return (v5 == 0) & (unsigned __int8)(v6 != 0);
  }
  return result;
}


================================================================================
Function: sub_62FE6C8 (0x62FE6C8)
================================================================================

__int64 __fastcall sub_62FE6C8(__int64 a1, int a2)
{
  _QWORD *v2; // x20
  __int64 (__fastcall *v4)(); // x8
  __int64 result; // x0

  v2 = *(_QWORD **)(*(_QWORD *)(a1 + 24) + 8LL * a2 + 608);
  if ( !v2 )
    return 0LL;
  while ( 1 )
  {
    v4 = *(__int64 (__fastcall **)())(*v2 + 88LL);
    if ( v4 != sub_62FEB38 )
    {
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v4)(v2, a1, 258LL, 0LL, 0LL);
      if ( (_DWORD)result )
        break;
    }
    v2 = (_QWORD *)v2[1];
    if ( !v2 )
      return 0LL;
  }
  return result;
}


================================================================================
Function: sub_62FE824 (0x62FE824)
================================================================================

__int64 __fastcall sub_62FE824(__int64 a1, int a2)
{
  __int64 v2; // x8

  v2 = *(_QWORD *)(a1 + 8LL * a2 + 608);
  if ( v2 )
    return *(_BYTE *)(v2 + 36) & 1;
  else
    return 0LL;
}


================================================================================
Function: sub_62FE844 (0x62FE844)
================================================================================

__int64 __fastcall sub_62FE844(__int64 a1, int a2)
{
  __int64 v2; // x8

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL * a2 + 608);
  if ( !v2 )
    return 0LL;
  while ( (*(_BYTE *)(v2 + 36) & 1) == 0 )
  {
    if ( (*(_BYTE *)(*(_QWORD *)v2 + 8LL) & 1) == 0 )
    {
      v2 = *(_QWORD *)(v2 + 8);
      if ( v2 )
        continue;
    }
    return 0LL;
  }
  return 1LL;
}


================================================================================
Function: sub_62FE8E8 (0x62FE8E8)
================================================================================

__int64 __fastcall sub_62FE8E8(__int64 result, int a2)
{
  _QWORD *v2; // x8
  int v3; // w9

  if ( result )
  {
    v2 = *(_QWORD **)(result + 8LL * a2 + 608);
    if ( v2 )
    {
      while ( 1 )
      {
        v3 = *(_DWORD *)(*v2 + 8LL);
        if ( (v3 & 4) != 0 )
          break;
        if ( (v3 & 3) == 0 )
        {
          v2 = (_QWORD *)v2[1];
          if ( v2 )
            continue;
        }
        return 0LL;
      }
      return 1LL;
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}


================================================================================
Function: sub_62FEA58 (0x62FEA58)
================================================================================

__int64 __fastcall sub_62FEA58(__int64 result, __int64 a2)
{
  __int64 v2; // x8
  __int64 v4; // x20
  __int64 v5; // x10
  __int64 v6; // x21
  char v7; // w9
  __int64 v8; // x9
  __int64 v9; // x21
  char v10; // w8

  v2 = *(_QWORD *)(result + 24);
  v4 = result;
  v5 = *(_QWORD *)(v2 + 608);
  while ( v5 )
  {
    v6 = v5;
    v7 = *(_BYTE *)(v5 + 36);
    if ( (v7 & 1) == 0 )
    {
      v5 = *(_QWORD *)(v5 + 8);
      if ( v5 )
      {
        if ( (*(_BYTE *)(v5 + 36) & 1) == 0 )
          continue;
      }
    }
    if ( (v7 & 2) != 0 )
    {
      while ( 1 )
      {
        v6 = *(_QWORD *)(v6 + 8);
        if ( !v6 )
          break;
        if ( (*(_BYTE *)(v6 + 36) & 2) == 0 )
          goto LABEL_9;
      }
    }
    else
    {
      do
      {
LABEL_9:
        result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 56LL))(v6, v4, a2);
        v6 = *(_QWORD *)(v6 + 8);
      }
      while ( v6 );
      v2 = *(_QWORD *)(v4 + 24);
    }
    break;
  }
  v8 = *(_QWORD *)(v2 + 616);
  while ( v8 )
  {
    v9 = v8;
    v10 = *(_BYTE *)(v8 + 36);
    if ( (v10 & 1) == 0 )
    {
      v8 = *(_QWORD *)(v8 + 8);
      if ( v8 )
      {
        if ( (*(_BYTE *)(v8 + 36) & 1) == 0 )
          continue;
      }
    }
    if ( (v10 & 2) != 0 )
    {
      while ( 1 )
      {
        v9 = *(_QWORD *)(v9 + 8);
        if ( !v9 )
          break;
        if ( (*(_BYTE *)(v9 + 36) & 2) == 0 )
          goto LABEL_19;
      }
    }
    else
    {
      do
      {
LABEL_19:
        result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v9 + 56LL))(v9, v4, a2);
        v9 = *(_QWORD *)(v9 + 8);
      }
      while ( v9 );
    }
    return result;
  }
  return result;
}


================================================================================
Function: sub_62FED18 (0x62FED18)
================================================================================

__int64 __fastcall sub_62FED18(__int64 result, __int64 a2)
{
  __int64 v2; // x20
  _QWORD *i; // x21
  _QWORD *j; // x20
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8

  v2 = result;
  for ( i = *(_QWORD **)(result + 608); i; i = (_QWORD *)i[1] )
  {
    v6 = *(__int64 (__fastcall **)())(*i + 88LL);
    if ( v6 != sub_62FEB38 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v6)(i, a2, 1LL, 0LL, 0LL);
  }
  for ( j = *(_QWORD **)(v2 + 616); j; j = (_QWORD *)j[1] )
  {
    v7 = *(__int64 (__fastcall **)())(*j + 88LL);
    if ( v7 != sub_62FEB38 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v7)(j, a2, 1LL, 0LL, 0LL);
  }
  return result;
}


================================================================================
Function: sub_62FEDC0 (0x62FEDC0)
================================================================================

__int64 __fastcall sub_62FEDC0(__int64 result, __int64 a2)
{
  __int64 v2; // x20
  _QWORD *i; // x21
  _QWORD *j; // x20
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8

  v2 = result;
  for ( i = *(_QWORD **)(result + 608); i; i = (_QWORD *)i[1] )
  {
    v6 = *(__int64 (__fastcall **)())(*i + 88LL);
    if ( v6 != sub_62FEB38 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v6)(i, a2, 2LL, 0LL, 0LL);
  }
  for ( j = *(_QWORD **)(v2 + 616); j; j = (_QWORD *)j[1] )
  {
    v7 = *(__int64 (__fastcall **)())(*j + 88LL);
    if ( v7 != sub_62FEB38 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v7)(j, a2, 2LL, 0LL, 0LL);
  }
  return result;
}


================================================================================
Function: sub_62FEFD0 (0x62FEFD0)
================================================================================

__int64 __fastcall sub_62FEFD0(__int64 result)
{
  __int64 v1; // x22
  __int64 v2; // x19
  _QWORD *i; // x20
  _QWORD *j; // x20
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8

  v1 = *(_QWORD *)(result + 24);
  v2 = result;
  for ( i = *(_QWORD **)(v1 + 608); i; i = (_QWORD *)i[1] )
  {
    v5 = *(__int64 (__fastcall **)())(*i + 88LL);
    if ( v5 != sub_62FEB38 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v5)(i, v2, 8LL, 0LL, 0LL);
  }
  for ( j = *(_QWORD **)(v1 + 616); j; j = (_QWORD *)j[1] )
  {
    v6 = *(__int64 (__fastcall **)())(*j + 88LL);
    if ( v6 != sub_62FEB38 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v6)(j, v2, 8LL, 0LL, 0LL);
  }
  return result;
}


================================================================================
Function: sub_62FF078 (0x62FF078)
================================================================================

__int64 __fastcall sub_62FF078(__int64 result, char a2)
{
  __int64 v2; // x23
  __int64 v3; // x19
  unsigned int v4; // w20
  _QWORD *i; // x21
  _QWORD *j; // x21
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8

  v2 = *(_QWORD *)(result + 24);
  v3 = result;
  v4 = a2 & 1;
  for ( i = *(_QWORD **)(v2 + 608); i; i = (_QWORD *)i[1] )
  {
    v7 = *(__int64 (__fastcall **)())(*i + 88LL);
    if ( v7 != sub_62FEB38 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v7)(i, v3, 7LL, v4, 0LL);
  }
  for ( j = *(_QWORD **)(v2 + 616); j; j = (_QWORD *)j[1] )
  {
    v8 = *(__int64 (__fastcall **)())(*j + 88LL);
    if ( v8 != sub_62FEB38 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v8)(j, v3, 7LL, v4, 0LL);
  }
  return result;
}


================================================================================
Function: sub_62FF26C (0x62FF26C)
================================================================================

__int64 __fastcall sub_62FF26C(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 *a6)
{
  __int64 v7; // x8
  __int64 v8; // x8
  __int64 result; // x0
  unsigned int v10; // [xsp+4h] [xbp-Ch]

  v7 = *(_QWORD *)(a1 + 24);
  v10 = 0;
  v8 = (*(__int64 (**)(void))(v7 + 8LL * a2 + 592))();
  result = v10;
  *a6 = v8 & ~(v8 >> 63);
  return result;
}


================================================================================
Function: sub_62FF2DC (0x62FF2DC)
================================================================================

long double __fastcall sub_62FF2DC(__int64 a1, __int64 a2)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)a2 = -1LL;
  *(_QWORD *)(a2 + 8) = -1LL;
  *(_DWORD *)(a2 + 16) = -1;
  return result;
}


================================================================================
Function: sub_62FF3C8 (0x62FF3C8)
================================================================================

__int64 __fastcall sub_62FF3C8(__int64 a1, __int64 a2, __int64 (__fastcall *a3)(__int64, _DWORD *))
{
  __int64 result; // x0
  __int64 i; // x8
  int v6; // w14
  int v7; // w13
  __int64 v8; // x14
  __int64 v9; // x15
  __int64 v10; // x14
  __int64 j; // x15
  __int64 v12; // x15
  __int64 v13; // x15
  _DWORD v14[5]; // [xsp+4h] [xbp-1Ch] BYREF

  result = a3(a1, v14);
  if ( (_DWORD)result )
  {
    for ( i = 0LL; i != 5; ++i )
    {
      if ( (((unsigned int)result >> i) & 0x10001) == 0 )
        return result;
      v7 = v14[i];
      if ( v7 < 0 )
        return result;
      if ( ((1 << i) & (unsigned int)result) != 0 )
      {
        v8 = *(unsigned int *)(a2 + 20);
        if ( ((0x10000 << i) & (unsigned int)result) != 0 )
        {
          v9 = 0LL;
          if ( (_DWORD)v8 )
          {
            do
            {
              if ( *(_DWORD *)(a2 + 4 * v9) == v7 )
              {
                *(_BYTE *)(a2 + v9 + 24) |= 3u;
                goto LABEL_5;
              }
              ++v9;
            }
            while ( v8 != v9 );
            v9 = *(unsigned int *)(a2 + 20);
            if ( (unsigned int)v8 <= 4 )
              goto LABEL_3;
            continue;
          }
LABEL_3:
          v6 = v8 + 1;
          *(_DWORD *)(a2 + 4 * v9) = v7;
          *(_BYTE *)(a2 + v9 + 24) = 3;
        }
        else
        {
          v13 = 0LL;
          if ( (_DWORD)v8 )
          {
            do
            {
              if ( *(_DWORD *)(a2 + 4 * v13) == v7 )
              {
                *(_BYTE *)(a2 + v13 + 24) |= 1u;
                goto LABEL_5;
              }
              ++v13;
            }
            while ( v8 != v13 );
            v13 = *(unsigned int *)(a2 + 20);
            if ( (unsigned int)v8 > 4 )
              continue;
          }
          v6 = v8 + 1;
          *(_DWORD *)(a2 + 4 * v13) = v7;
          *(_BYTE *)(a2 + v13 + 24) = 1;
        }
      }
      else
      {
        v10 = *(unsigned int *)(a2 + 20);
        if ( (_DWORD)v10 )
        {
          for ( j = 0LL; j != v10; ++j )
          {
            if ( *(_DWORD *)(a2 + 4 * j) == v7 )
            {
              *(_BYTE *)(a2 + j + 24) |= 2u;
              goto LABEL_5;
            }
          }
          v12 = *(unsigned int *)(a2 + 20);
          if ( (unsigned int)v10 > 4 )
            continue;
        }
        else
        {
          v12 = 0LL;
        }
        v6 = v10 + 1;
        *(_DWORD *)(a2 + 4 * v12) = v7;
        *(_BYTE *)(a2 + v12 + 24) = 2;
      }
      *(_DWORD *)(a2 + 20) = v6;
LABEL_5:
      ;
    }
  }
  return result;
}


================================================================================
Function: sub_62FF658 (0x62FF658)
================================================================================

__time_t __fastcall sub_62FF658(__time_t result, int a2, _OWORD *a3)
{
  __time_t v4; // x19
  __int64 v5; // x1
  int v6; // w8
  _QWORD v7[2]; // [xsp+8h] [xbp-18h] BYREF

  v4 = result;
  if ( !a3 )
  {
    result = sub_63315AC();
    a3 = v7;
    v7[0] = result;
    v7[1] = v5;
  }
  *(_OWORD *)(*(_QWORD *)(v4 + 24) + 16LL * a2 + 624) = *a3;
  v6 = *(_DWORD *)(v4 + 768);
  if ( !v6 )
    v6 = 2000;
  *(_DWORD *)(*(_QWORD *)(v4 + 24) + 656LL) = v6;
  return result;
}


================================================================================
Function: sub_62FF6E4 (0x62FF6E4)
================================================================================

__int64 __fastcall sub_62FF6E4(__int64 a1, int a2, __time_t *a3)
{
  __int64 v3; // x10
  __int64 v4; // x8
  unsigned int v6; // w9
  __int64 v7; // x20
  __time_t v8; // x0
  __time_t v9; // x1
  __int64 *v11; // x21
  __int64 v12; // x10
  __int64 v13; // x19
  __int64 v14; // x0

  v3 = a1 + 16LL * a2;
  v4 = *(_QWORD *)(v3 + 624);
  if ( !v4 )
    return 0LL;
  v6 = *(_DWORD *)(a1 + 656);
  if ( !v6 )
    return 0LL;
  v7 = a2;
  if ( a3 )
  {
    v8 = *a3;
    v9 = a3[1];
  }
  else
  {
    v11 = (__int64 *)(v3 + 624);
    v8 = sub_63315AC();
    v6 = *(_DWORD *)(a1 + 656);
    v4 = *v11;
  }
  v12 = a1 + 16 * v7;
  v13 = v6;
  v14 = sub_633164C(v8, v9, v4, *(_QWORD *)(v12 + 632));
  if ( v13 == v14 )
    return -1LL;
  else
    return v13 - v14;
}


================================================================================
Function: sub_62FF760 (0x62FF760)
================================================================================

__int64 __fastcall sub_62FF760(__int64 a1, __int64 *a2)
{
  __int64 *v3; // x21
  __int64 v4; // x2
  __time_t v5; // x0
  __int64 v6; // x1
  __int64 v7; // x20
  __int64 v8; // x0
  __int64 v9; // x20
  __int64 v10; // x2
  __int64 v11; // x23
  __time_t v12; // x0
  __int64 v13; // x1
  __int64 v14; // x0
  __int64 v15; // x8
  __time_t v18; // [xsp+8h] [xbp-18h] BYREF
  __int64 v19; // [xsp+10h] [xbp-10h]

  if ( !*(_DWORD *)(a1 + 656) )
    return 0LL;
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 624);
  if ( v4
    && (a2 || (v5 = sub_63315AC(), v4 = *(_QWORD *)(a1 + 624), v3 = &v18, v18 = v5, v19 = v6, v4))
    && (v7 = *(unsigned int *)(a1 + 656), (_DWORD)v7) )
  {
    v8 = sub_633164C(*v3, v3[1], v4, *(_QWORD *)(a1 + 632));
    if ( v7 == v8 )
      v9 = -1LL;
    else
      v9 = v7 - v8;
    if ( !*(_DWORD *)(a1 + 656) )
      return v9;
  }
  else
  {
    v9 = 0LL;
    if ( !*(_DWORD *)(a1 + 656) )
      return v9;
  }
  v10 = *(_QWORD *)(a1 + 640);
  if ( !v10 )
    return v9;
  if ( v3 )
  {
    v11 = *(unsigned int *)(a1 + 656);
    if ( !(_DWORD)v11 )
      return v9;
  }
  else
  {
    v12 = sub_63315AC();
    v10 = *(_QWORD *)(a1 + 640);
    v18 = v12;
    v19 = v13;
    if ( !v10 )
      return v9;
    v3 = &v18;
    v11 = *(unsigned int *)(a1 + 656);
    if ( !(_DWORD)v11 )
      return v9;
  }
  v14 = sub_633164C(*v3, v3[1], v10, *(_QWORD *)(a1 + 648));
  v15 = v11 - v14;
  if ( v11 == v14 )
    v15 = -1LL;
  if ( v15 < v9 || v9 == 0 )
    return v15;
  return v9;
}


================================================================================
Function: sub_62FF88C (0x62FF88C)
================================================================================

bool __fastcall sub_62FF88C(__int64 a1, int a2)
{
  __int64 v2; // x8

  v2 = *(_QWORD *)(a1 + 24);
  return *(__int64 *)(v2 + 16LL * a2 + 624) > 0 || *(_DWORD *)(v2 + 16LL * a2 + 632) > 0;
}


================================================================================
Function: sub_62FF994 (0x62FF994)
================================================================================

__int64 __fastcall sub_62FF994(__int64 a1, __int64 *a2)
{
  __int64 v4; // x0
  __int64 result; // x0

  if ( *(_QWORD *)(a1 + 2912) == -1LL )
    return 0xFFFFFFFFLL;
  v4 = sub_6303468();
  if ( v4 )
  {
    if ( a2 )
      *a2 = v4;
    return *(unsigned int *)(v4 + 568);
  }
  else
  {
    result = 0xFFFFFFFFLL;
    *(_QWORD *)(a1 + 2912) = -1LL;
  }
  return result;
}


================================================================================
Function: sub_62FF9F0 (0x62FF9F0)
================================================================================

__int64 __fastcall sub_62FF9F0(__int64 a1, int a2)
{
  __int64 result; // x0
  int v5; // w8

  result = sub_62FE8E8(a1, 0LL);
  if ( (a2 != 2 || (result & 1) == 0)
    && ((a2 == 1) | (a2 == 2) & ((unsigned int)result ^ 1)) == ((*(_DWORD *)(a1 + 920) & 0x20) == 0) )
  {
    if ( (a2 == 1) | (a2 == 2) & ((unsigned int)result ^ 1) )
      v5 = 32;
    else
      v5 = 0;
    *(_DWORD *)(a1 + 920) = *(_DWORD *)(a1 + 920) & 0xFFFFFFDF | v5;
  }
  return result;
}


================================================================================
Function: sub_6301A50 (0x6301A50)
================================================================================

__int64 __fastcall sub_6301A50(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x8
  __int64 result; // x0
  __int64 v13; // x8

  sub_630D8F8(a1, a5, sub_630DE74, sub_630DEAC, sub_6301AF0);
  v9 = sub_631CC00(a1 + 11, 0LL);
  if ( !a2 )
    return 1LL;
  v10 = sub_62FAA24(v9);
  a1[15] = v10;
  if ( !v10 )
    return 1LL;
  v11 = v10;
  result = 0LL;
  *(_DWORD *)(v11 + 4692) |= 0x20000u;
  v13 = a1[15];
  a1[17] = a4;
  a1[18] = a2;
  a1[16] = a3;
  *(_QWORD *)(v13 + 208) = a3;
  *(_QWORD *)(v13 + 224) = a4;
  return result;
}


================================================================================
Function: sub_6301B00 (0x6301B00)
================================================================================

__int64 __fastcall sub_6301B00(__int64 result)
{
  __int64 v1; // x19
  _QWORD *v2; // x20
  __int64 v3; // x8
  __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // x21
  unsigned int *v7; // x23
  unsigned __int64 v8; // x8
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x8
  unsigned int *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x9
  __int64 v15; // x23
  __int64 v16; // x0
  __int64 v17; // x1
  __int64 v18; // x21
  __int64 v19; // x22
  __int64 v20; // x0
  __int64 v21; // x0
  __int64 v22; // x0
  __int64 v23; // x24
  __int64 v24; // x0
  __int64 v25; // x0
  __int64 v26; // x0
  __int64 v27; // x0
  __int64 v28; // x1
  __int64 v29; // x0
  int v30; // w24
  int v31; // w8
  __int64 v32; // x0
  __int64 v33; // x21
  __int64 v34; // x22
  __int64 v35; // x0
  __int64 v36; // x22
  __int64 v37; // x23
  __int64 v38; // x8
  __int64 v39; // [xsp+8h] [xbp-A8h] BYREF
  unsigned int v40; // [xsp+10h] [xbp-A0h]
  struct sigaction act; // [xsp+20h] [xbp-90h] BYREF

  if ( result )
  {
    v1 = result;
    v2 = (_QWORD *)(result + 120);
    if ( *(_QWORD *)(result + 120) )
    {
      v3 = *(_QWORD *)(result + 136);
      act.sa_mask.__val[3] = 1LL;
      memset(&act, 0, 32);
      if ( v3 && (*(_BYTE *)(v3 + 4) & 0x20) != 0 )
        sub_632F114();
      *(_BYTE *)(v1 + 152) |= 1u;
      sub_630DEE4(v1, &act.sa_mask.__val[5]);
      while ( 1 )
      {
        v4 = sub_630DEF0(&act.sa_mask.__val[5]);
        if ( !v4 )
          break;
        v5 = sub_631CEA4(*(_QWORD *)(v4 + 32));
        if ( v5 )
        {
          v4 = sub_631CEB4(v5);
          if ( v4 )
          {
            v6 = v4;
LABEL_11:
            sub_63029F8(v1, v6);
            v7 = (unsigned int *)(*(_QWORD *)(v1 + 120) + 2458LL);
            if ( ((*v7 >> 23) & 1) != LOBYTE(act.sa_mask.__val[3]) )
            {
              if ( LOBYTE(act.sa_mask.__val[3]) )
              {
                v8 = *v7 | ((unsigned __int64)*(unsigned __int16 *)(*(_QWORD *)(v1 + 120) + 2462LL) << 32);
                v9 = (v8 >> 23) & 0x1FFFFFF;
              }
              else
              {
                sigaction(13, &act, 0LL);
                v8 = *v7 | ((unsigned __int64)*((unsigned __int16 *)v7 + 2) << 32);
                v9 = v8 >> 23;
              }
              LOBYTE(act.sa_mask.__val[3]) = v9 & 1;
              if ( (v8 & 0x800000) == 0 )
              {
                sigaction(13, 0LL, &act);
                act.sa_mask.__val[5] = (unsigned __int64)act.sa_handler;
                *(_OWORD *)&act.sa_mask.__val[7] = *(_OWORD *)&act.sa_mask.__val[1];
                act.sa_mask.__val[6] = 1LL;
                sigaction(13, (const struct sigaction *)&act.sa_mask.__val[5], 0LL);
              }
            }
            sub_62FF9F0(v6, 1LL);
            sub_6302AF4(v1, *(_QWORD *)(v1 + 120), v6, 0LL);
            sub_630DEE4(v1, &act.sa_mask.__val[5]);
            while ( 1 )
            {
              v4 = sub_630DEF0(&act.sa_mask.__val[5]);
              if ( !v4 )
                break;
              v10 = sub_631CEA4(*(_QWORD *)(v4 + 32));
              if ( v10 )
              {
                v4 = sub_631CEB4(v10);
                v6 = v4;
                if ( v4 )
                  goto LABEL_11;
                goto LABEL_21;
              }
            }
          }
          break;
        }
      }
LABEL_21:
      v11 = *(_QWORD *)(v1 + 136);
      *(_BYTE *)(v1 + 152) &= ~1u;
      if ( v11 && (*(_BYTE *)(v11 + 4) & 0x20) != 0 )
        v4 = sub_632F158(*v2, 5LL);
      v12 = (unsigned int *)(*v2 + 2458LL);
      if ( ((*v12 >> 23) & 1) != LOBYTE(act.sa_mask.__val[3]) )
      {
        if ( LOBYTE(act.sa_mask.__val[3]) )
        {
          v13 = *v12 | ((unsigned __int64)*(unsigned __int16 *)(*v2 + 2462LL) << 32);
          v14 = (v13 >> 23) & 0x1FFFFFF;
        }
        else
        {
          v4 = sigaction(13, &act, 0LL);
          v13 = *v12 | ((unsigned __int64)*((unsigned __int16 *)v12 + 2) << 32);
          v14 = v13 >> 23;
        }
        LOBYTE(act.sa_mask.__val[3]) = v14 & 1;
        if ( (v13 & 0x800000) == 0 )
        {
          sigaction(13, 0LL, &act);
          act.sa_mask.__val[5] = (unsigned __int64)act.sa_handler;
          *(_OWORD *)&act.sa_mask.__val[7] = *(_OWORD *)&act.sa_mask.__val[1];
          act.sa_mask.__val[6] = 1LL;
          v4 = sigaction(13, (const struct sigaction *)&act.sa_mask.__val[5], 0LL);
        }
      }
      v15 = *v2;
      v16 = sub_63315AC(v4);
      if ( v15 )
      {
        v18 = v16;
        v19 = v17;
        sub_630DEE4(v1, &act.sa_mask.__val[5]);
        while ( 1 )
        {
          v20 = sub_630DEF0(&act.sa_mask.__val[5]);
          if ( !v20 )
            break;
          v21 = sub_631CEA4(*(_QWORD *)(v20 + 32));
          if ( v21 )
          {
            v22 = sub_631CEB4(v21);
            if ( v22 )
            {
              v23 = v22;
LABEL_36:
              sub_63029F8(v1, v23);
              sub_6302AF4(v1, v15, v23, 0LL);
              sub_630DEE4(v1, &act.sa_mask.__val[5]);
              while ( 1 )
              {
                v24 = sub_630DEF0(&act.sa_mask.__val[5]);
                if ( !v24 )
                  break;
                v25 = sub_631CEA4(*(_QWORD *)(v24 + 32));
                if ( v25 )
                {
                  v23 = sub_631CEB4(v25);
                  if ( v23 )
                    goto LABEL_36;
                  goto LABEL_40;
                }
              }
            }
            break;
          }
        }
LABEL_40:
        while ( sub_631CEA4(v1 + 88) )
        {
          sub_6302FF0(v1);
          v26 = sub_631CEA4(v1 + 88);
          if ( !v26 )
            break;
          v27 = sub_63315AC(v26);
          v29 = sub_633164C(v27, v28, v18, v19);
          if ( (v29 & 0x8000000000000000LL) == 0 )
            break;
          v30 = v29;
          sub_6327394(&v39, &act.sa_mask.__val[5], 10LL);
          if ( (unsigned int)sub_6302E88(v1, &v39) )
          {
            sub_63273B0(&v39);
            break;
          }
          v31 = -v30;
          if ( -v30 >= 1000 )
            v31 = 1000;
          sub_6327054(v39, v40, v31);
          sub_63273B0(&v39);
        }
        v32 = sub_631CEA4(v1 + 88);
        if ( v32 )
        {
          v33 = v32;
          do
          {
            v34 = sub_631CEB4(v33);
            sub_631CD70(v33);
            sub_6302D84(v1, v34, 0LL, 0LL);
            v33 = sub_631CEA4(v1 + 88);
          }
          while ( v33 );
        }
      }
      v35 = sub_631CEA4(v1 + 88);
      if ( v35 )
      {
        v36 = v35;
        do
        {
          v37 = sub_631CEB4(v36);
          sub_631CD70(v36);
          sub_6302D84(v1, v37, 0LL, 0LL);
          v36 = sub_631CEA4(v1 + 88);
        }
        while ( v36 );
      }
      sub_630F994(*v2, *(_QWORD *)(*v2 + 192LL));
      if ( !LOBYTE(act.sa_mask.__val[3]) )
        sigaction(13, &act, 0LL);
      v38 = *v2;
      *(_QWORD *)(v38 + 208) = 0LL;
      *(_QWORD *)(v38 + 224) = 0LL;
      sub_6332E9C(v2);
    }
    result = sub_630DC74(v1);
    *(_QWORD *)(v1 + 128) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_63022C0 (0x63022C0)
================================================================================

_QWORD *__fastcall sub_63022C0(_QWORD *result, __int64 a2, char a3)
{
  __int64 v4; // x20
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x19
  char v9; // w23
  __int64 v10; // x9
  char v11; // w8
  __int64 v12; // x3
  __int64 v13; // x4
  __int64 v14; // x5
  __int64 v15; // x6
  __int64 v16; // x7
  char v17; // w22
  __int64 v18; // x8
  int v19; // w9
  __int64 v20; // x9
  const char *v21; // x2
  __int64 v22; // x8
  __int64 v23; // x8
  __int64 v24; // [xsp+0h] [xbp+0h]

  if ( !result )
    return result;
  v4 = (__int64)result;
  v6 = result[28];
  if ( v6 && (*(_BYTE *)(v6 + 4) & 0x20) != 0 )
  {
    v8 = v6 + 40;
  }
  else
  {
    v7 = result[27];
    if ( !v7 )
    {
      v7 = result[26];
      if ( !v7 )
        return result;
    }
    v8 = v7 + 368;
  }
  result = (_QWORD *)sub_631CEAC(a2 + 968);
  if ( result && (a3 & 1) == 0 )
    return result;
  v9 = *(_BYTE *)(v8 + 152);
  if ( (v9 & 1) == 0 )
  {
    v10 = *(_QWORD *)(v8 + 136);
    v11 = *(_BYTE *)(v8 + 152);
    if ( v10 )
    {
      v11 = *(_BYTE *)(v8 + 152);
      if ( (*(_BYTE *)(v10 + 4) & 0x20) != 0 )
      {
        sub_632F114(*(_QWORD *)(v8 + 120), 5);
        v11 = *(_BYTE *)(v8 + 152);
      }
    }
    *(_BYTE *)(v8 + 152) = v11 | 1;
  }
  if ( (*(_BYTE *)(a2 + 923) & 0x20) != 0 )
    sub_63029F8(v8, a2);
  v17 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v8 + 144))(v4, a2, a3 & 1);
  v18 = *(_QWORD *)(v4 + 208);
  v19 = *(_DWORD *)(v4 + 2458);
  if ( v18 )
  {
    if ( (v19 & 0x100000) != 0 )
    {
      v20 = *(_QWORD *)(v4 + 4576);
      if ( !v20 || *(int *)(v20 + 8) >= 1 )
      {
        if ( (v17 & 1) != 0 )
          v21 = "closing";
        else
          v21 = "shutting down";
        sub_62FB210(v4, "%s connection #%ld", (__int64)v21, *(_QWORD *)(a2 + 48), v13, v14, v15, v16, v24);
        v18 = *(_QWORD *)(v4 + 208);
      }
    }
    result = (_QWORD *)sub_6302AF4(v18 + 368, v4, a2, v17 & 1);
    if ( (v9 & 1) != 0 )
      return result;
LABEL_32:
    v23 = *(_QWORD *)(v8 + 136);
    *(_BYTE *)(v8 + 152) &= ~1u;
    if ( v23 )
    {
      if ( (*(_BYTE *)(v23 + 4) & 0x20) != 0 )
        return (_QWORD *)sub_632F158(*(_QWORD *)(v8 + 120), 5);
    }
    return result;
  }
  if ( (v19 & 0x100000) != 0 )
  {
    v22 = *(_QWORD *)(v4 + 4576);
    if ( !v22 || *(int *)(v22 + 8) >= 1 )
      sub_62FB210(v4, "closing connection #%ld", *(_QWORD *)(a2 + 48), v12, v13, v14, v15, v16, v24);
  }
  result = (_QWORD *)sub_6302D84(0LL, a2, v4, (v17 & 1) == 0);
  if ( (v9 & 1) == 0 )
    goto LABEL_32;
  return result;
}


================================================================================
Function: sub_63029F8 (0x63029F8)
================================================================================

__int64 __fastcall sub_63029F8(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  __int64 v5; // x22
  __int64 v6; // x21
  _QWORD v7[3]; // [xsp+0h] [xbp-20h] BYREF

  result = sub_631CEC4(a2);
  if ( result )
  {
    v5 = result;
    result = sub_630DBCC(a1, *(_QWORD *)(a2 + 56), *(_QWORD *)(a2 + 64));
    if ( result )
    {
      v6 = result;
      if ( v5 == result )
      {
        sub_631CD70(a2);
        *(_DWORD *)(a2 + 920) &= ~0x20000000u;
        result = sub_631CEAC(v5);
        if ( !result && a1 )
        {
          sub_630DEE4(a1, v7);
          while ( 1 )
          {
            result = sub_630DEF0((__int64)v7);
            if ( !result )
              break;
            if ( *(_QWORD *)(result + 32) == v6 )
            {
              result = sub_630DB18(a1, result + 56, *(_QWORD *)(result + 48));
              break;
            }
          }
        }
        *(_DWORD *)(a2 + 920) &= ~0x20000000u;
        --*(_QWORD *)(a1 + 48);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6302AF4 (0x6302AF4)
================================================================================

__int64 __fastcall sub_6302AF4(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 result; // x0
  char v9; // w8
  int v10; // w10
  __int64 v11; // x8
  __int64 v12; // x23
  __int64 v13; // x0
  __int64 v14; // x23
  __int64 v15; // x22
  _DWORD *v16; // x8
  __int64 v17; // x8
  __int64 v18; // x24
  __int64 v19; // x23
  __int128 v20; // q1
  char v21[4]; // [xsp+Ch] [xbp-64h] BYREF
  struct sigaction oact; // [xsp+10h] [xbp-60h] BYREF

  v21[0] = 0;
  result = sub_631CEAC(a3 + 968);
  if ( !result || (a4 & 1) != 0 )
  {
    v9 = (*(_BYTE *)(a3 + 1109) != 0) | a4;
    if ( (*(_BYTE *)(a3 + 1109) != 0) | a4 & 1 )
      v10 = 0x4000000;
    else
      v10 = 0;
    *(_DWORD *)(a3 + 920) = v10 | *(_DWORD *)(a3 + 920) & 0xFBFFFFFF;
    if ( (v9 & 1) != 0 )
    {
      v21[0] = 1;
      return sub_6302D84(a1, a3, a2, 0);
    }
    sub_6321B34(a2, a3);
    sub_630311C(a2, a3, v21);
    sub_6321A20(a2);
    if ( v21[0] )
      return sub_6302D84(a1, a3, a2, 0);
    v11 = *(_QWORD *)(a2 + 208);
    if ( v11 )
    {
      v12 = *(_QWORD *)(v11 + 544);
      if ( v12 >= 1 && v12 >= sub_631CEAC(a1 + 88) )
      {
        v13 = sub_631CEA4(a1 + 88);
        if ( v13 )
        {
          v14 = v13;
          v15 = sub_631CEB4(v13);
          sub_631CD70(v14);
          v16 = (_DWORD *)(*(_QWORD *)(a1 + 120) + 2458LL);
          oact.sa_mask.__val[3] = 1LL;
          memset(&oact, 0, 32);
          if ( (*v16 & 0x800000) == 0 )
          {
            LOBYTE(oact.sa_mask.__val[3]) = 0;
            sigaction(13, 0LL, &oact);
            oact.sa_mask.__val[5] = (unsigned __int64)oact.sa_handler;
            *(_OWORD *)&oact.sa_mask.__val[7] = *(_OWORD *)&oact.sa_mask.__val[1];
            oact.sa_mask.__val[6] = 1LL;
            sigaction(13, (const struct sigaction *)&oact.sa_mask.__val[5], 0LL);
          }
          sub_6302D84(a1, v15, 0LL, 0);
          if ( !LOBYTE(oact.sa_mask.__val[3]) )
            sigaction(13, &oact, 0LL);
        }
      }
      v17 = *(_QWORD *)(a2 + 208);
      if ( v17 )
      {
        if ( *(_QWORD *)(v17 + 152) )
        {
          *(_OWORD *)(a3 + 664) = 0u;
          *(_OWORD *)(a3 + 680) = 0u;
          v18 = *(_QWORD *)(a1 + 120);
          memset(&oact, 0, 32);
          v19 = *(_QWORD *)(a2 + 208);
          sub_6321B34(v18, a3);
          sub_62FEA58(v18, &oact);
          sub_6321A20(v18);
          if ( (unsigned int)sub_632347C(v19, v18, &oact, a3 + 664) )
            return sub_6302D84(a1, a3, a2, 0);
          v20 = *(_OWORD *)&oact.sa_mask.__val[1];
          *(_OWORD *)(a3 + 664) = *(_OWORD *)&oact.sa_handler;
          *(_OWORD *)(a3 + 680) = v20;
        }
      }
    }
    return sub_631CC7C(a1 + 88, a3, a3);
  }
  return result;
}


================================================================================
Function: sub_6302D84 (0x6302D84)
================================================================================

__int64 __fastcall sub_6302D84(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v5; // x20
  __int64 v7; // x1
  __int64 v8; // x8
  void (__fastcall *v9)(__int64, __int64, _QWORD); // x8
  _BYTE v11[4]; // [xsp+4h] [xbp-Ch] BYREF

  v5 = a3;
  if ( !a3 )
    v5 = *(_QWORD *)(a1 + 120);
  sub_6321B34(v5, a2);
  if ( (*(_BYTE *)(a2 + 923) & 8) == 0 )
  {
    v7 = a2 + 72;
    if ( *(_QWORD *)(a2 + 72) )
      sub_630F860(v5, v7);
    sub_631BE18(a2, v7);
    v8 = *(_QWORD *)(a2 + 928);
    if ( v8 )
    {
      v9 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v8 + 96);
      if ( v9 )
        v9(v5, a2, (*(_DWORD *)(a2 + 920) >> 26) & 1);
    }
    sub_63038B0(v5);
    *(_DWORD *)(a2 + 920) |= 0x8000000u;
  }
  if ( (a4 & 1) != 0 )
    sub_630311C(v5, a2, v11);
  sub_62FDE8C(v5, 1LL);
  sub_62FDE8C(v5, 0LL);
  sub_6321A20(v5);
  return sub_6333488(v5, a2);
}


================================================================================
Function: sub_6302E88 (0x6302E88)
================================================================================

__int64 __fastcall sub_6302E88(__int64 a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 v5; // x0
  __int64 v6; // x21
  __int64 v7; // x1
  __int64 v8; // x0
  unsigned int v9; // w0
  unsigned int v10; // w22
  _OWORD v12[2]; // [xsp+0h] [xbp-30h] BYREF

  v2 = a1 + 88;
  if ( sub_631CEA4(a1 + 88) && (v5 = sub_631CEA4(v2)) != 0 )
  {
    v6 = v5;
    while ( 1 )
    {
      v7 = sub_631CEB4(v6);
      v8 = *(_QWORD *)(a1 + 120);
      memset(v12, 0, sizeof(v12));
      sub_6321B34(v8, v7);
      sub_62FEA58(*(_QWORD *)(a1 + 120), v12);
      sub_6321A20(*(_QWORD *)(a1 + 120));
      v9 = sub_63273F0(a2, v12);
      if ( v9 )
        break;
      v6 = sub_631CEBC(v6);
      if ( !v6 )
        return 0;
    }
    v10 = v9;
    sub_63273B0(a2);
  }
  else
  {
    return 0;
  }
  return v10;
}


================================================================================
Function: sub_6302FF0 (0x6302FF0)
================================================================================

__int64 __fastcall sub_6302FF0(__int64 a1)
{
  __int64 v2; // x19
  __int64 result; // x0
  __int64 v4; // x24
  _QWORD *v5; // x22
  __int64 v6; // x21
  __int64 v7; // x23
  __int64 v8; // x25
  __int64 v9; // x1
  _BYTE v11[4]; // [xsp+4h] [xbp-1Ch] BYREF
  _QWORD v12[2]; // [xsp+8h] [xbp-18h] BYREF

  v2 = *(_QWORD *)(a1 + 120);
  result = sub_631CEA4(a1 + 88);
  if ( result )
  {
    v4 = result;
    v5 = 0LL;
    v6 = 0LL;
    do
    {
      while ( 1 )
      {
        v7 = sub_631CEBC(v4);
        v8 = sub_631CEB4(v4);
        sub_6321B34(v2, v8);
        sub_630311C(v2, v8, v11);
        sub_6321A20(v2);
        if ( !v11[0] )
          break;
        sub_631CD70(v4);
        result = sub_6302D84(a1, v8, 0LL, 0);
        v4 = v7;
        if ( !v7 )
          goto LABEL_13;
      }
      if ( !v5 )
      {
        v5 = v12;
        v12[0] = sub_63315AC();
        v12[1] = v9;
      }
      result = sub_62FF760(v8, v5);
      if ( result < v6 && result != 0 )
        v6 = result;
      v4 = v7;
    }
    while ( v7 );
LABEL_13:
    if ( v6 )
      return sub_63213F4(v2, v6, 8LL);
  }
  return result;
}


================================================================================
Function: sub_630311C (0x630311C)
================================================================================

unsigned __int64 __fastcall sub_630311C(unsigned __int64 result, __int64 a2, _BYTE *a3)
{
  __int64 v5; // x21
  int v6; // w8
  _QWORD *v7; // x1
  __int64 v8; // x8
  void (__fastcall *v9)(__int64, __int64, _QWORD); // x8
  int v10; // w22
  _BOOL4 v11; // w8
  int v12; // w8
  char v13[4]; // [xsp+0h] [xbp-10h] BYREF
  char v14[4]; // [xsp+4h] [xbp-Ch] BYREF

  v5 = result;
  v6 = *(_DWORD *)(a2 + 920);
  if ( (v6 & 0x8000000) == 0 )
  {
    v7 = (_QWORD *)(a2 + 72);
    if ( *(_QWORD *)(a2 + 72) )
      sub_630F860(result, v7);
    sub_631BE18(a2);
    v8 = *(_QWORD *)(a2 + 928);
    if ( v8 )
    {
      v9 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v8 + 96);
      if ( v9 )
        v9(v5, a2, (*(_DWORD *)(a2 + 920) >> 26) & 1);
    }
    result = sub_63038B0(v5);
    v6 = *(_DWORD *)(a2 + 920) | 0x8000000;
    *(_DWORD *)(a2 + 920) = v6;
  }
  if ( (v6 & 0x10000000) != 0 )
  {
    *a3 = 1;
    return result;
  }
  if ( *(_BYTE *)(a2 + 1109) || (result = sub_62FE824(a2, 0LL), (result & 1) == 0) )
  {
    v10 = 0;
    v14[0] = 1;
    if ( *(_BYTE *)(a2 + 1109) )
      goto LABEL_18;
  }
  else
  {
    result = sub_62FDED4(v5, 0LL, v14);
    v10 = result;
    if ( *(_BYTE *)(a2 + 1109) )
      goto LABEL_18;
  }
  result = sub_62FE824(a2, 1LL);
  if ( (result & 1) != 0 )
  {
    result = sub_62FDED4(v5, 1LL, v13);
    v11 = result != 0;
    if ( v10 )
      goto LABEL_22;
    goto LABEL_19;
  }
LABEL_18:
  v11 = 0;
  v13[0] = 1;
  if ( v10 )
  {
LABEL_22:
    *a3 = 1;
    goto LABEL_23;
  }
LABEL_19:
  if ( v11 )
    goto LABEL_22;
  v12 = (v14[0] != 0) & v13[0];
  *a3 = v12;
  if ( v12 == 1 )
LABEL_23:
    *(_DWORD *)(a2 + 920) |= 0x10000000u;
  return result;
}


================================================================================
Function: sub_6303468 (0x6303468)
================================================================================

__int64 __fastcall sub_6303468(_QWORD *a1, __int64 a2)
{
  __int64 v3; // x8
  __int64 v4; // x8
  __int64 v5; // x19
  __int64 v6; // x8
  __int64 v7; // x21
  __int64 v8; // x0
  __int64 v9; // x22
  __int64 v10; // x21
  __int64 v11; // x23
  __int64 v12; // x8
  _QWORD v14[3]; // [xsp+0h] [xbp-20h] BYREF

  if ( !a1 )
    return 0LL;
  v3 = a1[28];
  if ( !v3 || (*(_BYTE *)(v3 + 4) & 0x20) == 0 )
  {
    v4 = a1[27];
    if ( v4 || (v4 = a1[26]) != 0 )
    {
      v5 = v4 + 368;
      v6 = *(_QWORD *)(v4 + 504);
      if ( !v6 )
        goto LABEL_12;
LABEL_10:
      if ( (*(_BYTE *)(v6 + 4) & 0x20) != 0 )
        sub_632F114(*(_QWORD *)(v5 + 120), 5);
      goto LABEL_12;
    }
    return 0LL;
  }
  v5 = v3 + 40;
  v6 = *(_QWORD *)(v3 + 176);
  if ( v6 )
    goto LABEL_10;
LABEL_12:
  *(_BYTE *)(v5 + 152) |= 1u;
  sub_630DEE4(v5, v14);
  v8 = sub_630DEF0((__int64)v14);
  if ( v8 )
  {
    v9 = v8;
    do
    {
      v10 = *(_QWORD *)(v9 + 32);
      v9 = sub_630DEF0((__int64)v14);
      v11 = sub_631CEA4(v10);
      while ( v11 )
      {
        v7 = sub_631CEB4(v11);
        v11 = sub_631CEBC(v11);
        if ( *(_QWORD *)(v7 + 48) == a2 )
          goto LABEL_20;
      }
    }
    while ( v9 );
  }
  v7 = 0LL;
LABEL_20:
  v12 = *(_QWORD *)(v5 + 136);
  *(_BYTE *)(v5 + 152) &= ~1u;
  if ( v12 && (*(_BYTE *)(v12 + 4) & 0x20) != 0 )
    sub_632F158(*(_QWORD *)(v5 + 120), 5);
  return v7;
}


================================================================================
Function: sub_63035C4 (0x63035C4)
================================================================================

_QWORD *__fastcall sub_63035C4(
        _QWORD *result,
        __int64 a2,
        __int64 (__fastcall *a3)(__int64, _QWORD *, __int64),
        __int64 a4)
{
  _QWORD *v6; // x21
  __int64 v8; // x8
  __int64 v9; // x8
  __int64 v10; // x23
  __int64 v11; // x8
  __int64 v12; // x24
  __int64 v13; // x25
  __int64 v14; // x25
  __int64 v15; // x26
  __int64 v16; // x8
  _QWORD v17[3]; // [xsp+0h] [xbp-20h] BYREF

  if ( !result )
    return result;
  v6 = result;
  v8 = result[28];
  if ( !v8 || (*(_BYTE *)(v8 + 4) & 0x20) == 0 )
  {
    v9 = result[27];
    if ( !v9 )
    {
      v9 = result[26];
      if ( !v9 )
        return result;
    }
    v10 = v9 + 368;
    v11 = *(_QWORD *)(v9 + 504);
    if ( !v11 )
      goto LABEL_11;
    goto LABEL_9;
  }
  v10 = v8 + 40;
  v11 = *(_QWORD *)(v8 + 176);
  if ( v11 )
  {
LABEL_9:
    if ( (*(_BYTE *)(v11 + 4) & 0x20) != 0 )
      sub_632F114(*(_QWORD *)(v10 + 120), 5);
  }
LABEL_11:
  *(_BYTE *)(v10 + 152) |= 1u;
  sub_630DEE4(v10, v17);
  result = (_QWORD *)sub_630DEF0((__int64)v17);
  if ( result )
  {
    v12 = (__int64)result;
    do
    {
      v13 = *(_QWORD *)(v12 + 32);
      v12 = sub_630DEF0((__int64)v17);
      result = (_QWORD *)sub_631CEA4(v13);
      v14 = (__int64)result;
      while ( v14 )
      {
        v15 = sub_631CEB4(v14);
        result = (_QWORD *)sub_631CEBC(v14);
        v14 = (__int64)result;
        if ( *(_QWORD *)(v15 + 48) == a2 )
        {
          result = (_QWORD *)a3(v15, v6, a4);
          goto LABEL_18;
        }
      }
    }
    while ( v12 );
  }
LABEL_18:
  v16 = *(_QWORD *)(v10 + 136);
  *(_BYTE *)(v10 + 152) &= ~1u;
  if ( v16 )
  {
    if ( (*(_BYTE *)(v16 + 4) & 0x20) != 0 )
      return (_QWORD *)sub_632F158(*(_QWORD *)(v10 + 120), 5);
  }
  return result;
}


================================================================================
Function: sub_6303740 (0x6303740)
================================================================================

__int64 __fastcall sub_6303740(
        _QWORD *a1,
        __int64 a2,
        __int64 (__fastcall *a3)(__int64, _QWORD *, __int64),
        __int64 a4)
{
  __int64 (__fastcall *v5)(__int64, _QWORD *, __int64); // x3
  __int64 v8; // x8
  __int64 v9; // x8
  __int64 v10; // x22
  __int64 v11; // x8
  __int64 result; // x0
  __int64 v13; // x8

  v5 = a3;
  if ( !a1 )
    return a3(a2, a1, a4);
  v8 = a1[28];
  if ( v8 && (*(_BYTE *)(v8 + 4) & 0x20) != 0 )
  {
    v10 = v8 + 40;
    v11 = *(_QWORD *)(v8 + 176);
    if ( !v11 )
      goto LABEL_12;
LABEL_10:
    if ( (*(_BYTE *)(v11 + 4) & 0x20) != 0 )
    {
      sub_632F114(*(_QWORD *)(v10 + 120), 5);
      v5 = a3;
    }
    goto LABEL_12;
  }
  v9 = a1[27];
  if ( !v9 )
  {
    v9 = a1[26];
    if ( !v9 )
      return a3(a2, a1, a4);
  }
  v10 = v9 + 368;
  v11 = *(_QWORD *)(v9 + 504);
  if ( v11 )
    goto LABEL_10;
LABEL_12:
  *(_BYTE *)(v10 + 152) |= 1u;
  result = v5(a2, a1, a4);
  v13 = *(_QWORD *)(v10 + 136);
  *(_BYTE *)(v10 + 152) &= ~1u;
  if ( v13 )
  {
    if ( (*(_BYTE *)(v13 + 4) & 0x20) != 0 )
      return sub_632F158(*(_QWORD *)(v10 + 120), 5);
  }
  return result;
}


================================================================================
Function: sub_630384C (0x630384C)
================================================================================

__int64 sub_630384C()
{
  return 0LL;
}


================================================================================
Function: sub_6303858 (0x6303858)
================================================================================

__int64 __fastcall sub_6303858(__int64 a1, __int64 *a2)
{
  __int64 v3; // x8
  __int64 result; // x0

  v3 = off_6CA6320(1LL, 16LL);
  if ( v3 )
    result = 0LL;
  else
    result = 27LL;
  *a2 = v3;
  return result;
}


================================================================================
Function: sub_63038A0 (0x63038A0)
================================================================================

unsigned __int64 __fastcall sub_63038A0(unsigned __int64 a1)
{
  return ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(a1);
}


================================================================================
Function: sub_63038B0 (0x63038B0)
================================================================================

__int64 __fastcall sub_63038B0(__int64 a1)
{
  _QWORD *v1; // x19
  __int64 *v2; // x22
  unsigned int v3; // w20
  __int64 v4; // x21
  pthread_mutex_t **v5; // x24
  pthread_mutex_t *v6; // x0
  int v7; // w25
  __int64 v8; // x0
  __int64 v9; // x0
  int v10; // w0
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 result; // x0

  v1 = (_QWORD *)(a1 + 3224);
  v2 = *(__int64 **)(a1 + 3240);
  if ( v2 )
  {
    v3 = *((_DWORD *)v2 + 14);
    v4 = v2[6];
    v5 = (pthread_mutex_t **)(v2 + 3);
    pthread_mutex_lock((pthread_mutex_t *)v2[3]);
    v6 = (pthread_mutex_t *)v2[3];
    v7 = *((_DWORD *)v2 + 8);
    *((_DWORD *)v2 + 8) = 1;
    pthread_mutex_unlock(v6);
    v8 = *v2;
    if ( v7 )
    {
      if ( v8 )
        sub_630418C(v2);
      if ( *v5 )
      {
        pthread_mutex_destroy(*v5);
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)*v5);
      }
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v2[5]);
      v9 = v2[9];
      if ( v9 )
        sub_63041E0(v9);
      v10 = *((_DWORD *)v2 + 15);
      if ( v10 != -1 )
        close(v10);
      v11 = off_6CA6308[0];
      *(_OWORD *)(v2 + 13) = 0u;
      *(_OWORD *)(v2 + 15) = 0u;
      *(_OWORD *)(v2 + 9) = 0u;
      *(_OWORD *)(v2 + 11) = 0u;
      *(_OWORD *)(v2 + 5) = 0u;
      *(_OWORD *)(v2 + 7) = 0u;
      *(_OWORD *)v5 = 0u;
      ((void (__fastcall *)(_QWORD))v11)(v1[2]);
    }
    else
    {
      sub_6304150(v8);
    }
    sub_63238EC(v4, v3);
    close(v3);
  }
  v12 = off_6CA6308[0];
  v1[2] = 0LL;
  result = ((__int64 (__fastcall *)(_QWORD))v12)(*v1);
  *v1 = 0LL;
  return result;
}


================================================================================
Function: sub_63039C8 (0x63039C8)
================================================================================

void __fastcall sub_63039C8(__int64 a1)
{
  pthread_t **v2; // x0

  v2 = *(pthread_t ***)(a1 + 3240);
  if ( v2 && *v2 && (*(_DWORD *)(a1 + 2458) & 0x20) == 0 )
  {
    sub_630418C(v2);
    *(_BYTE *)(a1 + 3264) |= 1u;
  }
  JUMPOUT(0x63038B8LL);
}


================================================================================
Function: sub_6304150 (0x6304150)
================================================================================

pthread_t *__fastcall sub_6304150(pthread_t *result)
{
  unsigned __int64 v1; // x19

  if ( result )
  {
    v1 = (unsigned __int64)result;
    pthread_detach(*result);
    return (pthread_t *)((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1);
  }
  return result;
}


================================================================================
Function: sub_630418C (0x630418C)
================================================================================

bool __fastcall sub_630418C(pthread_t **a1)
{
  _BOOL4 v2; // w20
  _BOOL8 result; // x0

  v2 = pthread_join(**a1, 0LL) == 0;
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)*a1);
  result = v2;
  *a1 = 0LL;
  return result;
}


================================================================================
Function: sub_63041E0 (0x63041E0)
================================================================================

unsigned __int64 __fastcall sub_63041E0(unsigned __int64 result)
{
  unsigned __int64 v1; // x20

  if ( result )
  {
    do
    {
      v1 = *(_QWORD *)(result + 40);
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(result);
      result = v1;
    }
    while ( v1 );
  }
  return result;
}


================================================================================
Function: sub_6304D94 (0x6304D94)
================================================================================

_QWORD *__fastcall sub_6304D94(_QWORD *result, __int64 a2)
{
  *result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = a2;
  return result;
}


================================================================================
Function: sub_6304DA0 (0x6304DA0)
================================================================================

unsigned __int64 __fastcall sub_6304DA0(unsigned __int64 *a1)
{
  unsigned __int64 result; // x0

  result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(*a1);
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  return result;
}


================================================================================
Function: sub_6304DD8 (0x6304DD8)
================================================================================

__int64 __fastcall sub_6304DD8(__int64 result)
{
  if ( *(_QWORD *)(result + 8) )
    **(_BYTE **)result = 0;
  *(_QWORD *)(result + 8) = 0LL;
  return result;
}


================================================================================
Function: sub_6304DF0 (0x6304DF0)
================================================================================

__int64 __fastcall sub_6304DF0(__int64 a1, size_t n)
{
  size_t v2; // x8
  __int64 result; // x0
  _BYTE *v6; // x8

  v2 = *(_QWORD *)(a1 + 8);
  if ( v2 < n )
    return 43LL;
  if ( v2 == n )
    return 0LL;
  if ( n )
  {
    memmove(*(void **)a1, (const void *)(*(_QWORD *)a1 + v2 - n), n);
    result = 0LL;
    v6 = *(_BYTE **)a1;
    *(_QWORD *)(a1 + 8) = n;
    v6[n] = 0;
  }
  else
  {
    if ( v2 )
      **(_BYTE **)a1 = 0;
    result = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_6304E6C (0x6304E6C)
================================================================================

__int64 __fastcall sub_6304E6C(unsigned __int64 *a1, void *src, size_t n)
{
  unsigned __int64 v3; // x24
  unsigned __int64 v5; // x22
  unsigned __int64 v6; // x23
  size_t v7; // x9
  __int64 result; // x0
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x11
  size_t v13; // x10
  __int64 v14; // x0
  __int64 v15; // x8

  v3 = a1[1];
  v5 = a1[3];
  v6 = v3 + n;
  v7 = v3 + n + 1;
  if ( v7 > v5 )
  {
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*a1);
    result = 100LL;
LABEL_3:
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
    return result;
  }
  v11 = a1[2];
  if ( v11 )
  {
    v12 = a1[2];
    do
    {
      v13 = v12;
      v12 *= 2LL;
    }
    while ( v13 < v7 );
    if ( v13 <= v5 )
      v5 = v13;
  }
  else if ( v5 >= 0x20 )
  {
    if ( v7 <= 0x20 )
      v5 = 32LL;
    else
      v5 = v3 + n + 1;
  }
  if ( v5 != v11 )
  {
    v14 = off_6CA6310(*a1, v5);
    if ( !v14 )
    {
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*a1);
      result = 27LL;
      goto LABEL_3;
    }
    *a1 = v14;
    a1[2] = v5;
  }
  if ( n )
    memcpy((void *)(*a1 + v3), src, n);
  result = 0LL;
  v15 = *a1;
  a1[1] = v6;
  *(_BYTE *)(v15 + v6) = 0;
  return result;
}


================================================================================
Function: sub_6305070 (0x6305070)
================================================================================

__int64 __fastcall sub_6305070(__int64 a1)
{
  return *(_QWORD *)a1;
}


================================================================================
Function: sub_6305080 (0x6305080)
================================================================================

__int64 __fastcall sub_6305080(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}


================================================================================
Function: sub_6306C24 (0x6306C24)
================================================================================

unsigned __int64 __fastcall sub_6306C24(unsigned __int64 result)
{
  unsigned __int64 *v1; // x20
  unsigned __int64 v2; // x19
  _QWORD *v3; // x0

  v1 = *(unsigned __int64 **)(result + 440);
  if ( v1 )
  {
    v2 = result;
    sub_6307508();
    sub_632F298(*v1);
    v3 = *(_QWORD **)(v2 + 440);
    *v3 = 0LL;
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v3);
    *(_QWORD *)(v2 + 440) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_6307508 (0x6307508)
================================================================================

__int64 __fastcall sub_6307508(__int64 result)
{
  __int64 v1; // x21
  __int64 v2; // x19
  __int64 v3; // [xsp+0h] [xbp-10h] BYREF

  v1 = *(_QWORD *)(result + 440);
  if ( v1 )
  {
    v2 = result;
    result = *(_QWORD *)(result + 208);
    if ( result )
    {
      if ( (*(_QWORD *)(v1 + 8) & 0x8000000000000000LL) == 0 )
      {
        *(_QWORD *)(v1 + 8) = -1LL;
        result = ((__int64 (*)(void))sub_63243B4)();
        v3 = result;
        if ( result )
        {
          sub_6321560(*(_QWORD *)(v2 + 208), result);
          result = sub_6332E9C((unsigned __int64 *)&v3);
        }
      }
      if ( (*(_QWORD *)(v1 + 576) & 0x8000000000000000LL) == 0 )
      {
        *(_QWORD *)(v1 + 576) = -1LL;
        result = *(_QWORD *)(v2 + 208);
        if ( result )
        {
          result = sub_63243B4(result);
          v3 = result;
          if ( result )
          {
            sub_6321560(*(_QWORD *)(v2 + 208), result);
            return sub_6332E9C((unsigned __int64 *)&v3);
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_63097D8 (0x63097D8)
================================================================================

unsigned __int64 **__fastcall sub_63097D8(unsigned __int64 **result)
{
  unsigned __int64 *v1; // x20
  unsigned __int64 **v2; // x19
  __int64 v3; // x0
  __int64 v4; // x21
  unsigned __int64 *v5; // x22

  v1 = *result;
  if ( *result )
  {
    v2 = result;
    v3 = sub_631CEA4((__int64)(v1 + 1));
    if ( v3 )
    {
      v4 = v3;
      do
      {
        v5 = (unsigned __int64 *)sub_631CEB4(v4);
        v4 = sub_631CEBC(v4);
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*v5);
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v5[2]);
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v5);
      }
      while ( v4 );
    }
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*v1);
    result = (unsigned __int64 **)((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v1);
    *v2 = 0LL;
  }
  return result;
}


================================================================================
Function: sub_6309880 (0x6309880)
================================================================================

__int64 __fastcall sub_6309880(int a1, __int64 a2, char *a3)
{
  char *v3; // x19
  unsigned int v5; // w24
  __int64 v6; // x0
  __int64 v7; // x20
  const char *v8; // x7
  const char **v9; // x23
  unsigned int v10; // w0
  int v11; // w0
  const char *v12; // x24
  const char *v13; // x21
  int v14; // w0
  int v15; // w8
  const char *v16; // x3
  const char *v17; // x5
  const char *v18; // x2
  int v19; // w8
  FILE *v21; // [xsp+70h] [xbp-60h]
  _DWORD v22[14]; // [xsp+78h] [xbp-58h] BYREF
  _BYTE buf[16]; // [xsp+B0h] [xbp-20h] BYREF

  if ( !a2 )
    return 0;
  v3 = a3;
  if ( !a3 )
    v3 = *(char **)a2;
  v5 = 0;
  if ( (*(_BYTE *)(a2 + 40) & 4) != 0 || !v3 )
    return v5;
  if ( !*v3 )
    return 0;
  v5 = sub_630CEC0(a1, v3);
  if ( !v5 )
  {
    fwrite(
      "# Your alt-svc cache. https://curl.se/docs/alt-svc.html\n"
      "# This file was generated by libcurl! Edit at your own risk.\n",
      0x75uLL,
      1uLL,
      v21);
    v6 = sub_631CEA4(a2 + 8);
    if ( v6 )
    {
      v7 = v6;
      while ( 1 )
      {
        v9 = (const char **)sub_631CEB4(v7);
        v7 = sub_631CEBC(v7);
        v10 = sub_6325370(v9[4], v22);
        if ( v10 )
          break;
        v11 = inet_pton(10, v9[2], buf);
        if ( v11 == 1 )
          v12 = "[";
        else
          v12 = &byte_CC4FFC;
        if ( v11 == 1 )
          v13 = "]";
        else
          v13 = &byte_CC4FFC;
        v14 = inet_pton(10, *v9, buf);
        v15 = *((_DWORD *)v9 + 3);
        if ( v14 == 1 )
          v16 = "[";
        else
          v16 = &byte_CC4FFC;
        if ( v14 == 1 )
          v17 = "]";
        else
          v17 = &byte_CC4FFC;
        switch ( v15 )
        {
          case 8:
            v18 = "h1";
            break;
          case 32:
            v18 = "h3";
            break;
          case 16:
            v18 = "h2";
            break;
          default:
            v18 = &byte_CC4FFC;
            break;
        }
        v19 = *((_DWORD *)v9 + 7);
        switch ( v19 )
        {
          case 8:
            v8 = "h1";
            break;
          case 32:
            v8 = "h3";
            break;
          case 16:
            v8 = "h2";
            break;
          default:
            v8 = &byte_CC4FFC;
            break;
        }
        sub_6320D2C(
          v21,
          "%s %s%s%s %u %s %s%s%s %u \"%d%02d%02d %02d:%02d:%02d\" %u %u\n",
          v18,
          v16,
          *v9,
          v17,
          *((unsigned __int16 *)v9 + 4),
          v8,
          v12,
          v9[2],
          v13,
          *((unsigned __int16 *)v9 + 12),
          v22[5] + 1900,
          v22[4] + 1,
          v22[3],
          v22[2],
          v22[1],
          v22[0],
          *((unsigned __int8 *)v9 + 40),
          *((_DWORD *)v9 + 11));
        if ( !v7 )
          goto LABEL_39;
      }
      v5 = v10;
    }
    else
    {
LABEL_39:
      v5 = 0;
    }
    fclose(v21);
  }
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(0LL);
  return v5;
}


================================================================================
Function: sub_630A790 (0x630A790)
================================================================================

const char *__fastcall sub_630A790(int a1, FILE *a2)
{
  const char *result; // x0
  char *v5; // x21
  const char *v6; // x22
  char s[128]; // [xsp+8h] [xbp-88h] BYREF

  sub_6304DD8();
  while ( 1 )
  {
    result = fgets(s, 128, a2);
    if ( !result )
      break;
    v5 = (char *)result;
    result = (const char *)strlen(result);
    if ( !result )
      break;
    v6 = result;
    if ( (unsigned int)sub_6304E6C(a1, v5, (size_t)result) )
      return 0LL;
    if ( v5[(_QWORD)v6 - 1] == 10 )
      return (_BYTE *)(&dword_0 + 1);
    if ( feof(a2) )
      return (const char *)((unsigned int)sub_6304E6C(a1, "\n", 1uLL) == 0);
  }
  return result;
}


================================================================================
Function: sub_630A930 (0x630A930)
================================================================================

__int64 __fastcall sub_630A930(__int64 a1, char *s1, __int64 a3, char a4)
{
  __int64 v5; // x19
  __int64 v8; // x0
  FILE *v9; // x0
  struct _IO_FILE *v10; // x21
  FILE *v11; // x22
  unsigned __int8 *v12; // x24
  int v13; // w0
  int v14; // w8
  __int64 v16; // x8
  _BYTE v18[32]; // [xsp+8h] [xbp-28h] BYREF

  v5 = a3;
  if ( a3 )
  {
LABEL_4:
    *(_BYTE *)(v5 + 521) = a4 & 1;
    if ( !a1 )
    {
LABEL_31:
      *(_BYTE *)(v5 + 520) = 1;
      return v5;
    }
    if ( s1 && *s1 )
    {
      if ( !strcmp(s1, "-") )
      {
        *(_BYTE *)(v5 + 520) = 0;
        v10 = stdin;
        if ( stdin )
        {
          v11 = 0LL;
          goto LABEL_12;
        }
LABEL_30:
        *(_DWORD *)(a1 + 4692) |= 0x800u;
        goto LABEL_31;
      }
      v9 = fopen(s1, "rb");
      if ( v9 )
      {
        v10 = v9;
        v11 = v9;
        *(_BYTE *)(v5 + 520) = 0;
LABEL_12:
        sub_6304D94(v18, 5000LL);
        while ( (unsigned int)sub_630A790(v18, v10) )
        {
          v12 = (unsigned __int8 *)sub_6305070(v18);
          v13 = sub_633109C(v12, "Set-Cookie:", 11LL);
          if ( v13 )
          {
            for ( v12 += 11; ; ++v12 )
            {
              v14 = *v12;
              if ( v14 != 32 && v14 != 9 )
                break;
            }
          }
          sub_630AB40(a1, v5, v13 != 0, 1LL, v12, 0LL, 0LL, 1LL);
        }
        sub_6304DA0(v18);
        sub_630BE0C(v5);
        if ( v11 )
          fclose(v11);
        goto LABEL_30;
      }
      if ( (*(_DWORD *)(a1 + 2458) & 0x100000) != 0 )
      {
        v16 = *(_QWORD *)(a1 + 4576);
        if ( !v16 || *(int *)(v16 + 8) >= 1 )
          sub_62FB210(a1, "WARNING: failed to open cookie file \"%s\"", s1);
      }
    }
    *(_BYTE *)(v5 + 520) = 0;
    goto LABEL_30;
  }
  v8 = off_6CA6320(1LL, 528LL);
  v5 = v8;
  if ( v8 )
  {
    *(_QWORD *)(v8 + 504) = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_4;
  }
  return v5;
}


================================================================================
Function: sub_630AB40 (0x630AB40)
================================================================================

unsigned __int64 __fastcall sub_630AB40(
        __int64 a1,
        __int64 a2,
        char a3,
        char a4,
        char *a5,
        const char *a6,
        const char *a7,
        int a8)
{
  time_t v14; // x0
  unsigned __int64 v15; // x27
  time_t v16; // x26
  __int64 v17; // x0
  unsigned __int64 v18; // x20
  char *v19; // x19
  char *i; // x28
  int v21; // w8
  bool v22; // zf
  size_t v23; // x0
  size_t v24; // x27
  unsigned __int64 v25; // x23
  int v26; // w8
  int v28; // w25
  int v29; // w24
  const char *v30; // x22
  size_t v31; // x0
  size_t v32; // x21
  const char *v33; // x8
  int v34; // w9
  size_t v36; // x27
  char v37; // w8
  __int64 j; // x9
  int v39; // w11
  __int64 v41; // x0
  __int64 v42; // x0
  __int64 v43; // x0
  unsigned __int64 v44; // x8
  const char *v45; // x0
  const char *v46; // x22
  _BOOL8 v47; // x9
  size_t v48; // x23
  _BYTE *v49; // x0
  char *v50; // x19
  char *v51; // x0
  char v52; // w27
  __int64 *v53; // x19
  const char *v54; // x0
  int v55; // w0
  char *v56; // x8
  __int64 v57; // x0
  __int64 v58; // x8
  __int64 v59; // x0
  __int64 v60; // x8
  int v61; // w8
  __int64 v62; // x8
  int v63; // w8
  char *v65; // x0
  char *v66; // x0
  char *v67; // x0
  const char *v68; // x28
  int v69; // w24
  int v70; // w22
  const char *v71; // x0
  char *v72; // x0
  char *v73; // x0
  __int64 v74; // x0
  char *v75; // x0
  char v76; // w8
  char *v77; // x0
  char *v78; // x0
  char *(*v79)(const char *); // x8
  _BOOL4 v80; // w19
  __int64 v81; // x0
  char *v82; // x0
  char *v83; // x0
  char v84; // w8
  int v85; // w8
  unsigned __int64 *v86; // x22
  unsigned __int64 v87; // x8
  char v88; // w19
  unsigned __int64 v89; // x21
  int v90; // w24
  unsigned __int64 v91; // x23
  __int64 v92; // x0
  __int64 v93; // x1
  __int64 v94; // x8
  char *v95; // x8
  const char *v96; // x0
  size_t v97; // x2
  __int64 v98; // x0
  __int64 v99; // x1
  bool v100; // zf
  int v101; // w8
  __int64 v102; // x0
  __int64 v103; // x1
  __int64 v104; // x8
  const char *v105; // x0
  char *v107; // x0
  char *v108; // x0
  _BYTE *v109; // x0
  __int128 v110; // q0
  __int64 v111; // x8
  __int128 v112; // q2
  __int64 v113; // x8
  __int64 v114; // x8
  unsigned __int64 *v115; // x8
  __int64 v116; // x8
  __int64 v117; // x8
  __int64 v118; // x8
  const char *v119; // x2
  __int64 v120; // x0
  __int64 v121; // x0
  __int64 *v122; // [xsp+10h] [xbp-D0h]
  _DWORD *v123; // [xsp+18h] [xbp-C8h]
  char v124; // [xsp+24h] [xbp-BCh]
  __int64 v125; // [xsp+28h] [xbp-B8h]
  __int64 v126; // [xsp+30h] [xbp-B0h]
  char v127; // [xsp+3Ch] [xbp-A4h]
  char *v129; // [xsp+48h] [xbp-98h]
  char *save_ptr[16]; // [xsp+50h] [xbp-90h] BYREF

  v129 = (char *)a6;
  v14 = time(0LL);
  v15 = 0LL;
  if ( *(unsigned __int8 *)(a1 + 448) > 0x31u )
    return v15;
  v125 = a1;
  v126 = a2;
  v16 = v14;
  v17 = off_6CA6320(1LL, 72LL);
  if ( !v17 )
    return 0LL;
  v18 = v17;
  v127 = a4;
  if ( (a3 & 1) == 0 )
  {
    save_ptr[0] = 0LL;
    if ( !strncmp(a5, "#HttpOnly_", 0xAuLL) )
    {
      a5 += 10;
      *(_BYTE *)(v18 + 59) = 1;
    }
    if ( *a5 == 35 )
      goto LABEL_141;
    v65 = strchr(a5, 13);
    if ( v65 )
      *v65 = 0;
    v66 = strchr(a5, 10);
    if ( v66 )
      *v66 = 0;
    LODWORD(v129) = a8;
    v67 = strtok_r(a5, "\t", save_ptr);
    if ( !v67 )
    {
      v70 = 0;
      v69 = 0;
      goto LABEL_187;
    }
    v68 = v67;
    v69 = 0;
    v70 = 0;
    while ( 1 )
    {
      switch ( v69 )
      {
        case 0:
          if ( *v68 == 46 )
            v71 = v68 + 1;
          else
            v71 = v68;
          v72 = off_6CA6318(v71);
          v69 = 0;
          *(_QWORD *)(v18 + 40) = v72;
          v70 |= v72 == 0LL;
          goto LABEL_176;
        case 1:
          v69 = 1;
          *(_BYTE *)(v18 + 56) = (unsigned int)sub_6331024(v68, "TRUE") != 0;
          goto LABEL_176;
        case 2:
          if ( !strcmp("TRUE", v68) || !strcmp("FALSE", v68) )
          {
            v78 = off_6CA6318("/");
            v79 = off_6CA6318;
            *(_QWORD *)(v18 + 24) = v78;
            v80 = v78 == 0LL;
            v81 = (__int64)v79("/");
            *(_QWORD *)(v18 + 32) = v81;
            v70 |= v81 == 0 || v80;
            goto LABEL_164;
          }
          v73 = off_6CA6318(v68);
          *(_QWORD *)(v18 + 24) = v73;
          if ( v73 )
          {
            v74 = ((__int64 (*)(void))sub_630BCB0)();
            v69 = 2;
            *(_QWORD *)(v18 + 32) = v74;
            v70 |= v74 == 0;
          }
          else
          {
            v69 = 2;
            v70 = 1;
          }
          goto LABEL_176;
        case 3:
LABEL_164:
          *(_BYTE *)(v18 + 57) = 0;
          if ( (unsigned int)sub_6331024(v68, "TRUE") )
          {
            if ( ((unsigned __int8)v129 & 1) != 0 || *(_BYTE *)(v126 + 520) )
            {
              v69 = 3;
              *(_BYTE *)(v18 + 57) = 1;
            }
            else
            {
              v69 = 3;
              v70 = 1;
            }
          }
          else
          {
            v69 = 3;
          }
          goto LABEL_176;
        case 4:
          v69 = 4;
          v70 |= (unsigned int)sub_6331454(v68, 0LL, 10LL, v18 + 48) != 0;
          goto LABEL_176;
        case 5:
          v75 = off_6CA6318(v68);
          *(_QWORD *)(v18 + 8) = v75;
          if ( !v75 )
          {
            v69 = 5;
            v70 = 1;
            goto LABEL_176;
          }
          if ( (unsigned int)sub_633109C("__Secure-", v75, 9LL) )
          {
            v76 = *(_BYTE *)(v18 + 64) | 1;
LABEL_172:
            v69 = 5;
            *(_BYTE *)(v18 + 64) = v76;
            goto LABEL_176;
          }
          if ( (unsigned int)sub_633109C("__Host-", *(_QWORD *)(v18 + 8), 7LL) )
          {
            v76 = *(_BYTE *)(v18 + 64) | 2;
            goto LABEL_172;
          }
          v69 = 5;
LABEL_176:
          v82 = strtok_r(0LL, "\t", save_ptr);
          ++v69;
          if ( !v82 || (v68 = v82, (v70 & 1) != 0) )
          {
            if ( v69 == 6 )
            {
              v83 = off_6CA6318(&byte_CC4FFC);
              if ( v83 )
                v69 = 7;
              else
                v69 = 6;
              v70 |= v83 == 0LL;
              *(_QWORD *)(v18 + 16) = v83;
            }
LABEL_187:
            if ( (v70 & 1) != 0 || ((v69 != 7) & ~v70) != 0 )
              goto LABEL_246;
            LOBYTE(a8) = (_BYTE)v129;
            v84 = *(_BYTE *)(v18 + 64);
            if ( (v84 & 1) != 0 )
              goto LABEL_190;
LABEL_191:
            if ( (v84 & 2) != 0
              && (!*(_BYTE *)(v18 + 57)
               || (v105 = *(const char **)(v18 + 24)) == 0LL
               || strcmp(v105, "/")
               || *(_BYTE *)(v18 + 56)) )
            {
LABEL_246:
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 40));
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 24));
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 32));
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 8));
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 16));
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v18);
              return 0LL;
            }
            if ( !*(_BYTE *)(v126 + 520) && *(_BYTE *)(v126 + 521) && !*(_QWORD *)(v18 + 48) )
            {
LABEL_264:
              sub_630BC48(v18);
              return 0LL;
            }
            *(_BYTE *)(v18 + 58) = *(_BYTE *)(v126 + 520);
            v85 = *(_DWORD *)(v126 + 516) + 1;
            *(_DWORD *)(v126 + 516) = v85;
            *(_DWORD *)(v18 + 60) = v85;
            if ( (a4 & 1) == 0 )
              sub_630BE0C(v126);
            v86 = (unsigned __int64 *)(v126 + 8 * sub_630BF3C(*(_QWORD *)(v18 + 40)));
            v87 = *v86;
            if ( *v86 )
            {
              v88 = a8;
              v89 = 0LL;
              v15 = 0LL;
              v90 = 0;
              while ( 1 )
              {
                v91 = v87;
                if ( !(unsigned int)sub_6331024(*(_QWORD *)(v87 + 8), *(_QWORD *)(v18 + 8)) )
                  goto LABEL_198;
                v92 = *(_QWORD *)(v91 + 40);
                v93 = *(_QWORD *)(v18 + 40);
                if ( v92 )
                {
                  if ( !v93 || !(unsigned int)sub_6331024(v92, v93) )
                    goto LABEL_198;
                }
                else if ( v93 )
                {
                  goto LABEL_198;
                }
                v94 = *(_QWORD *)(v91 + 32);
                if ( v94 && *(_QWORD *)(v18 + 32) && *(_BYTE *)(v91 + 57) && !*(_BYTE *)(v18 + 57) && (v88 & 1) == 0 )
                {
                  v95 = strchr((const char *)(v94 + 1), 47);
                  v96 = *(const char **)(v91 + 32);
                  if ( v95 )
                  {
                    v97 = v95 - v96;
                  }
                  else
                  {
                    v97 = strlen(v96);
                    v96 = *(const char **)(v91 + 32);
                  }
                  if ( (unsigned int)sub_633109C(v96, *(_QWORD *)(v18 + 32), v97) )
                  {
                    if ( v125 )
                    {
                      if ( (*(_DWORD *)(v125 + 2458) & 0x100000) != 0 )
                      {
                        v104 = *(_QWORD *)(v125 + 4576);
                        if ( !v104 || *(int *)(v104 + 8) >= 1 )
                          sub_62FB210(
                            v125,
                            "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
                            *(const char **)(v18 + 8),
                            *(const char **)(v18 + 40));
                      }
                    }
                    goto LABEL_264;
                  }
                }
LABEL_198:
                if ( !v89 )
                {
                  if ( (unsigned int)sub_6331024(*(_QWORD *)(v91 + 8), *(_QWORD *)(v18 + 8)) )
                  {
                    v98 = *(_QWORD *)(v91 + 40);
                    v99 = *(_QWORD *)(v18 + 40);
                    if ( v98 )
                    {
                      if ( v99 && (unsigned int)sub_6331024(v98, v99) )
                      {
                        v100 = *(unsigned __int8 *)(v91 + 56) == *(unsigned __int8 *)(v18 + 56);
                        goto LABEL_219;
                      }
                      if ( (v90 & 1) == 0 )
                      {
LABEL_229:
                        v90 = 0;
                        goto LABEL_230;
                      }
                    }
                    else
                    {
                      v100 = v99 == 0;
LABEL_219:
                      v101 = v100;
                      if ( ((v101 | v90) & 1) == 0 )
                        goto LABEL_229;
                    }
                    v102 = *(_QWORD *)(v91 + 32);
                    v103 = *(_QWORD *)(v18 + 32);
                    if ( v102 )
                    {
                      if ( v103 )
                      {
                        if ( (unsigned int)sub_6331024(v102, v103)
                          && (*(_QWORD *)(v91 + 32) != 0LL) != (*(_QWORD *)(v18 + 32) == 0LL) )
                        {
LABEL_232:
                          if ( !*(_BYTE *)(v18 + 58) && *(_BYTE *)(v91 + 58) )
                            goto LABEL_264;
                          v90 = 1;
                          v15 = v91;
                          v89 = v18;
                          goto LABEL_199;
                        }
                      }
                      else if ( *(_QWORD *)(v18 + 32) )
                      {
                        goto LABEL_232;
                      }
                    }
                    else if ( !v103 )
                    {
                      goto LABEL_232;
                    }
                    goto LABEL_229;
                  }
LABEL_230:
                  v89 = 0LL;
                }
LABEL_199:
                v87 = *(_QWORD *)v91;
                if ( !*(_QWORD *)v91 )
                {
                  if ( !v89 )
                    goto LABEL_270;
                  *(_QWORD *)v89 = *(_QWORD *)v15;
                  *(_DWORD *)(v89 + 60) = *(_DWORD *)(v15 + 60);
                  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v15 + 8));
                  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v15 + 16));
                  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v15 + 40));
                  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v15 + 24));
                  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v15 + 32));
                  *(_OWORD *)v15 = *(_OWORD *)v89;
                  v110 = *(_OWORD *)(v89 + 48);
                  v111 = *(_QWORD *)(v89 + 64);
                  v112 = *(_OWORD *)(v89 + 16);
                  *(_OWORD *)(v15 + 32) = *(_OWORD *)(v89 + 32);
                  *(_OWORD *)(v15 + 48) = v110;
                  *(_QWORD *)(v15 + 64) = v111;
                  *(_OWORD *)(v15 + 16) = v112;
                  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v89);
                  goto LABEL_271;
                }
              }
            }
            v91 = 0LL;
            LOBYTE(v90) = 0;
LABEL_270:
            v15 = v18;
LABEL_271:
            if ( v125
              && *(_BYTE *)(v126 + 520)
              && (*(_DWORD *)(v125 + 2458) & 0x100000) != 0
              && ((v118 = *(_QWORD *)(v125 + 4576)) == 0 || *(int *)(v118 + 8) >= 1) )
            {
              if ( (v90 & 1) != 0 )
                v119 = "Replaced";
              else
                v119 = "Added";
              sub_62FB210(
                v125,
                "%s cookie %s=\"%s\" for domain %s, path %s, expire %ld",
                v119,
                *(const char **)(v15 + 8),
                *(const char **)(v15 + 16),
                *(const char **)(v15 + 40),
                *(const char **)(v15 + 24),
                *(_QWORD *)(v15 + 48));
              if ( (v90 & 1) != 0 )
              {
LABEL_279:
                v116 = *(_QWORD *)(v15 + 48);
                if ( v116 && v116 < *(_QWORD *)(v126 + 504) )
                  *(_QWORD *)(v126 + 504) = v116;
                return v15;
              }
            }
            else if ( (v90 & 1) != 0 )
            {
              goto LABEL_279;
            }
            if ( v91 )
              v115 = (unsigned __int64 *)v91;
            else
              v115 = v86;
            *v115 = v15;
            ++*(_DWORD *)(v126 + 512);
            goto LABEL_279;
          }
          break;
        case 6:
          v77 = off_6CA6318(v68);
          v69 = 6;
          *(_QWORD *)(v18 + 16) = v77;
          v70 |= v77 == 0LL;
          goto LABEL_176;
        default:
          goto LABEL_176;
      }
    }
  }
  if ( strlen(a5) > 0x1388 )
  {
LABEL_141:
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v18);
    return 0LL;
  }
  v124 = 0;
  v122 = (__int64 *)(v18 + 48);
  v123 = (_DWORD *)(a1 + 2458);
  while ( 1 )
  {
    v19 = a5 + 1;
    for ( i = a5; ; ++i )
    {
      v21 = (unsigned __int8)*i;
      v22 = v21 == 32 || v21 == 9;
      if ( !v22 )
        break;
      ++v19;
    }
    v23 = strcspn(i, ";\t\r\n=");
    if ( !v23 )
    {
      a5 = i;
      goto LABEL_129;
    }
    v24 = v23;
    a5 = &i[v23];
    v25 = v23;
    do
    {
      v26 = (unsigned __int8)i[v25 - 1];
      if ( v26 != 32 && v26 != 9 )
        break;
      --v25;
    }
    while ( v25 );
    v28 = a8;
    v29 = (unsigned __int8)*a5;
    if ( v29 == 61 )
    {
      v30 = &i[v23 + 1];
      v31 = strcspn(v30, ";\r\n");
      v32 = v24 + v31;
      if ( v31 )
      {
        v33 = &v19[v32];
        while ( 1 )
        {
          v34 = *((unsigned __int8 *)v33 - 1);
          if ( v34 != 32 && v34 != 9 )
            break;
          --v31;
          --v33;
          if ( !v31 )
            goto LABEL_30;
        }
        for ( j = 0LL; j != v31; ++j )
        {
          v39 = (unsigned __int8)v19[v24 + j];
          if ( v39 != 32 && v39 != 9 )
          {
            v56 = &v19[v24];
            v36 = v31 - j;
            v30 = &v56[j];
            goto LABEL_31;
          }
        }
        v36 = 0LL;
        v30 = v33;
      }
      else
      {
LABEL_30:
        v36 = 0LL;
      }
LABEL_31:
      if ( memchr(v30, 9, v36) )
      {
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 40));
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 24));
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 32));
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 8));
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 16));
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v18);
        if ( (*v123 & 0x100000) == 0 )
          return 0LL;
        v117 = *(_QWORD *)(v125 + 4576);
        if ( !v117 || *(int *)(v117 + 8) >= 1 )
          sub_62FB210(v125, "cookie contains TAB, dropping");
        return 0LL;
      }
      a5 = &i[v32 + 1];
    }
    else
    {
      v36 = 0LL;
      v30 = 0LL;
    }
    if ( v25 > 0xFFE || v36 > 0xFFE || v36 + v25 > 0x1000 )
    {
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 40));
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 24));
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 32));
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 8));
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 16));
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v18);
      if ( (*v123 & 0x100000) == 0 )
        return 0LL;
      v113 = *(_QWORD *)(v125 + 4576);
      if ( !v113 || *(int *)(v113 + 8) >= 1 )
        sub_62FB210(v125, "oversized cookie dropped, name/val %zu + %zu bytes", v25, v36);
      return 0LL;
    }
    if ( v25 >= 7 && *i == 95 && i[1] == 95 )
    {
      if ( (unsigned int)sub_633109C("__Secure-", i, 9LL) )
      {
        v37 = 1;
      }
      else
      {
        if ( !(unsigned int)sub_633109C("__Host-", i, 7LL) )
          goto LABEL_53;
        v37 = 2;
      }
      *(_BYTE *)(v18 + 64) |= v37;
    }
LABEL_53:
    if ( !*(_QWORD *)(v18 + 8) )
      break;
    if ( !v36 )
    {
      if ( v25 == 8 )
      {
        if ( (unsigned int)sub_633109C("httponly", i, 8LL) )
        {
          *(_BYTE *)(v18 + 59) = 1;
LABEL_95:
          a8 = v28;
          a4 = v127;
          goto LABEL_129;
        }
      }
      else if ( v25 == 6 && (unsigned int)sub_633109C("secure", i, 6LL) )
      {
        a8 = v28;
        a4 = v127;
        if ( (a8 & 1) == 0 && *(_BYTE *)(v126 + 520) )
          goto LABEL_184;
        *(_BYTE *)(v18 + 57) = 1;
        goto LABEL_129;
      }
      if ( v29 != 61 )
        goto LABEL_95;
    }
    if ( v25 == 7 )
    {
      a8 = v28;
      if ( (unsigned int)sub_633109C("version", i, 7LL) )
      {
        a4 = v127;
      }
      else if ( (unsigned int)sub_633109C("max-age", i, 7LL) )
      {
        v53 = (__int64 *)(v18 + 48);
        if ( *v30 == 34 )
          v54 = v30 + 1;
        else
          v54 = v30;
        v55 = sub_6331454(v54, 0LL, 10LL, v122);
        if ( !v55 )
        {
          v62 = *v122;
          a4 = v127;
          if ( *v122 )
          {
            if ( 0x7FFFFFFFFFFFFFFFLL - v16 >= v62 )
              v60 = v62 + v16;
            else
LABEL_126:
              v60 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else
          {
LABEL_127:
            v60 = 1LL;
          }
LABEL_128:
          *v53 = v60;
          goto LABEL_129;
        }
        a4 = v127;
        if ( v55 == 2 )
          goto LABEL_127;
        if ( v55 == 1 )
          goto LABEL_126;
      }
      else
      {
        a4 = v127;
        if ( (unsigned int)sub_633109C("expires", i, 7LL) )
        {
          v53 = (__int64 *)(v18 + 48);
          if ( !*v122 && v36 <= 0x7F )
          {
            __memcpy_chk();
            *((_BYTE *)save_ptr + v36) = 0;
            v59 = sub_63252F8(save_ptr);
            *v122 = v59;
            if ( !v59 )
              goto LABEL_127;
            if ( v59 < 0 )
            {
              v60 = 0LL;
              goto LABEL_128;
            }
          }
        }
      }
    }
    else
    {
      a8 = v28;
      if ( v25 != 6 )
      {
        a4 = v127;
        if ( v25 == 4 )
        {
          if ( (unsigned int)sub_633109C("path", i, 4LL) )
          {
            ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 24));
            v41 = sub_6331274(v30, v36);
            *(_QWORD *)(v18 + 24) = v41;
            if ( !v41 )
              goto LABEL_184;
            ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 32));
            v42 = sub_630BCB0(*(_QWORD *)(v18 + 24));
            *(_QWORD *)(v18 + 32) = v42;
            if ( !v42 )
              goto LABEL_184;
          }
        }
        goto LABEL_129;
      }
      a4 = v127;
      if ( (unsigned int)sub_633109C("domain", i, 6LL) && v36 )
      {
        v47 = *(unsigned __int8 *)v30 == 46;
        if ( *v30 == 46 )
          ++v30;
        v48 = v36 - v47;
        if ( v36 - v47 == 9 && (unsigned int)sub_633109C(v30, "localhost", 9LL)
          || (v49 = memchr(v30, 46, v48)) != 0LL && (unsigned __int64)(&v30[v48] - v49) > 1 )
        {
          v50 = v129;
          if ( v129 )
            v51 = v129;
          else
            v51 = (char *)v30;
          v52 = sub_630EF54(v51);
          if ( v50 )
          {
            if ( (v52 & 1) == 0 )
              goto LABEL_90;
LABEL_105:
            if ( strncmp(v30, v50, v48) || v48 != strlen(v50) )
            {
LABEL_111:
              v129 = v50;
              if ( (*v123 & 0x100000) != 0 )
              {
                v58 = *(_QWORD *)(v125 + 4576);
                if ( !v58 || *(int *)(v58 + 8) >= 1 )
                  sub_62FB210(v125, "skipped cookie with bad tailmatch domain: %s", v30);
              }
              v124 = 1;
              goto LABEL_129;
            }
            v52 = 1;
          }
        }
        else
        {
          v50 = ":";
          if ( (sub_630EF54(":") & 1) != 0 )
            goto LABEL_105;
LABEL_90:
          if ( (sub_630BD8C((int)v30, v48, v50) & 1) == 0 )
            goto LABEL_111;
          v52 = 0;
        }
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 40));
        v57 = sub_6331274(v30, v48);
        *(_QWORD *)(v18 + 40) = v57;
        v129 = v50;
        if ( !v57 || (v52 & 1) != 0 )
        {
          if ( !v57 )
          {
            v61 = 6;
            v124 = 1;
            goto LABEL_135;
          }
        }
        else
        {
          *(_BYTE *)(v18 + 56) = 1;
        }
        goto LABEL_129;
      }
    }
    do
LABEL_129:
      v63 = (unsigned __int8)*a5++;
    while ( v63 == 32 || v63 == 9 );
    if ( v63 != 59 )
    {
LABEL_183:
      if ( (v124 & 1) != 0 )
        goto LABEL_184;
      if ( !*(_QWORD *)(v18 + 40) )
      {
        if ( v129 )
        {
          v107 = off_6CA6318(v129);
          *(_QWORD *)(v18 + 40) = v107;
          if ( !v107 )
            goto LABEL_184;
        }
      }
      if ( a7 && !*(_QWORD *)(v18 + 24) )
      {
        v108 = strchr(a7, 63);
        v109 = v108 ? memrchr(a7, 47, v108 - a7) : strrchr(a7, 47);
        if ( v109 )
        {
          v120 = sub_6331274(a7, v109 - a7 + 1);
          *(_QWORD *)(v18 + 24) = v120;
          if ( !v120 )
            goto LABEL_184;
          v121 = sub_630BCB0(v120);
          *(_QWORD *)(v18 + 32) = v121;
          if ( !v121 )
            goto LABEL_184;
        }
      }
      if ( !*(_QWORD *)(v18 + 8) )
        goto LABEL_184;
      ++*(_BYTE *)(v125 + 448);
      v84 = *(_BYTE *)(v18 + 64);
      if ( (v84 & 1) == 0 )
        goto LABEL_191;
LABEL_190:
      if ( *(_BYTE *)(v18 + 57) )
        goto LABEL_191;
      goto LABEL_264;
    }
    v61 = 0;
LABEL_135:
    if ( v61 )
      goto LABEL_183;
  }
  v22 = v29 == 61;
  a8 = v28;
  a4 = v127;
  if ( !v22 )
    goto LABEL_184;
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(0LL);
  v43 = sub_6331274(i, v25);
  v44 = *(_QWORD *)(v18 + 16);
  *(_QWORD *)(v18 + 8) = v43;
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v44);
  v45 = (const char *)sub_6331274(v30, v36);
  v46 = *(const char **)(v18 + 8);
  *(_QWORD *)(v18 + 16) = v45;
  if ( !v46 || !v45 )
    goto LABEL_184;
  if ( !v45[strcspn(v45, byte_16B8F6C)] && !v46[strcspn(v46, byte_16B8F6C)] )
    goto LABEL_129;
  if ( (*v123 & 0x100000) != 0 )
  {
    v114 = *(_QWORD *)(v125 + 4576);
    if ( !v114 || *(int *)(v114 + 8) >= 1 )
      sub_62FB210(v125, "invalid octets in name/value, cookie dropped");
  }
LABEL_184:
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 40));
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 24));
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 32));
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 8));
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v18 + 16));
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v18);
  return 0LL;
}


================================================================================
Function: sub_630BC48 (0x630BC48)
================================================================================

unsigned __int64 __fastcall sub_630BC48(_QWORD *a1)
{
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(a1[5]);
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(a1[3]);
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(a1[4]);
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(a1[1]);
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(a1[2]);
  return ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)a1);
}


================================================================================
Function: sub_630BCB0 (0x630BCB0)
================================================================================

__int64 __fastcall sub_630BCB0(const char *a1)
{
  const char *v1; // x0
  char *v2; // x19
  size_t v3; // x20
  size_t v4; // x8

  v1 = off_6CA6318(a1);
  v2 = (char *)v1;
  if ( !v1 )
    return (__int64)v2;
  v3 = strlen(v1);
  if ( *v2 == 34 )
    memmove(v2, v2 + 1, v3--);
  if ( !v3 )
  {
    if ( *v2 != 47 )
      goto LABEL_13;
    return (__int64)v2;
  }
  v4 = v3 - 1;
  if ( v2[v3 - 1] == 34 )
  {
    --v3;
    v2[v4] = 0;
  }
  if ( *v2 == 47 )
  {
    if ( v3 )
    {
      if ( v2[v3 - 1] == 47 )
        v2[v3 - 1] = 0;
    }
    return (__int64)v2;
  }
LABEL_13:
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v2);
  return sub_6331274("/", 1LL);
}


================================================================================
Function: sub_630BD8C (0x630BD8C)
================================================================================

bool __fastcall sub_630BD8C(unsigned __int64 a1, unsigned __int64 a2, char *s)
{
  size_t v6; // x0
  _BOOL8 result; // x0
  size_t v8; // x20
  char *v9; // x21

  v6 = strlen(s);
  if ( v6 < a2 )
    return 0LL;
  v8 = v6;
  v9 = &s[v6 - a2];
  result = sub_633109C(a1, (unsigned __int64)v9, a2);
  if ( result )
    return v8 == a2 || *(v9 - 1) == 46;
  return result;
}


================================================================================
Function: sub_630BE0C (0x630BE0C)
================================================================================

time_t __fastcall sub_630BE0C(__int64 a1)
{
  time_t result; // x0
  time_t v3; // x8
  time_t v4; // x20
  __int64 v5; // x22
  _QWORD *v6; // x25
  _QWORD *v7; // x26
  int v8; // w9
  _QWORD *v9; // x8
  int v10; // w8
  __int64 (__fastcall *v11)(); // x9
  __int64 v12; // x0
  _QWORD *v13; // x21
  time_t v14; // x8

  result = time(0LL);
  v3 = *(_QWORD *)(a1 + 504);
  v4 = result;
  if ( result >= v3 || v3 == 0x7FFFFFFFFFFFFFFFLL )
  {
    v5 = 0LL;
    *(_QWORD *)(a1 + 504) = 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      v6 = *(_QWORD **)(a1 + 8 * v5);
      if ( v6 )
      {
        v7 = 0LL;
        do
        {
          v13 = v6;
          v14 = v6[6];
          v6 = (_QWORD *)*v6;
          if ( v14 && v14 < v4 )
          {
            v8 = *(_DWORD *)(a1 + 512);
            if ( v7 )
              v9 = v7;
            else
              v9 = (_QWORD *)(a1 + 8 * v5);
            *v9 = v6;
            v10 = v8 - 1;
            v11 = off_6CA6308[0];
            v12 = v13[5];
            *(_DWORD *)(a1 + 512) = v10;
            ((void (__fastcall *)(__int64))v11)(v12);
            ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v13[3]);
            ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v13[4]);
            ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v13[1]);
            ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v13[2]);
            result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v13);
          }
          else if ( v14 )
          {
            v7 = v13;
            if ( v14 < *(_QWORD *)(a1 + 504) )
              *(_QWORD *)(a1 + 504) = v14;
          }
          else
          {
            v7 = v13;
          }
        }
        while ( v6 );
      }
      ++v5;
    }
    while ( v5 != 63 );
  }
  return result;
}


================================================================================
Function: sub_630BF3C (0x630BF3C)
================================================================================

char *__fastcall sub_630BF3C(char *result)
{
  const char *v1; // x19
  __int64 v2; // x20
  _BYTE *v3; // x0
  _BYTE *v4; // x0
  const char *v5; // x8
  const char *v6; // x21
  unsigned __int64 v7; // x20
  unsigned int v8; // t1

  if ( result )
  {
    v1 = result;
    if ( (sub_630EF54(result) & 1) != 0 )
    {
      return 0LL;
    }
    else
    {
      v2 = strlen(v1);
      v3 = memrchr(v1, 46, v2);
      if ( v3 && (v4 = memrchr(v1, 46, v3 - v1)) != 0LL )
      {
        v5 = v4 + 1;
        v2 = &v1[v2] - (v4 + 1);
      }
      else
      {
        v5 = 0LL;
      }
      if ( v5 )
        v1 = v5;
      if ( v2 < 1 )
      {
        return (_BYTE *)(&qword_18 + 2);
      }
      else
      {
        v6 = &v1[v2];
        v7 = 5381LL;
        do
        {
          v8 = *(unsigned __int8 *)v1++;
          v7 = (33 * v7) ^ (char)sub_6330FFC(v8);
        }
        while ( v1 < v6 );
        return (char *)(v7 % 0x3F);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_630C7FC (0x630C7FC)
================================================================================

unsigned __int64 __fastcall sub_630C7FC(unsigned __int64 result)
{
  unsigned __int64 v1; // x19
  __int64 i; // x21
  _QWORD *v3; // x20
  _QWORD *v4; // x23

  if ( result )
  {
    v1 = result;
    for ( i = 0LL; i != 63; ++i )
    {
      v3 = *(_QWORD **)(v1 + 8 * i);
      if ( v3 )
      {
        do
        {
          v4 = (_QWORD *)*v3;
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v3[5]);
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v3[3]);
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v3[4]);
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v3[1]);
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v3[2]);
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v3);
          v3 = v4;
        }
        while ( v4 );
      }
    }
    return ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1);
  }
  return result;
}


================================================================================
Function: sub_630CA48 (0x630CA48)
================================================================================

__int64 __fastcall sub_630CA48(__int64 a1, char a2)
{
  __int64 v4; // x21
  __int64 v5; // x25
  char *v6; // x22
  int v7; // w21
  unsigned int v8; // w23
  FILE *v9; // x3
  __int64 v10; // x8
  _QWORD *v11; // x0
  unsigned __int64 v12; // x23
  __int64 v13; // x8
  size_t v14; // x24
  _QWORD *i; // x9
  size_t j; // x28
  __int64 v17; // x8
  _BYTE *v18; // x9
  const char *v19; // x4
  const char *v20; // x2
  const char *v21; // x3
  const char *v22; // x5
  const char *v23; // x10
  const char *v24; // x6
  const char *v25; // x1
  const char *v26; // x0
  unsigned __int64 v27; // x27
  FILE *v28; // x0
  __int64 v29; // x8
  __int64 v30; // x21
  __int64 v31; // x0
  __int64 v32; // x4
  __int64 v33; // x5
  __int64 v34; // x6
  __int64 v35; // x7
  __int64 v36; // x8
  unsigned __int64 v37; // x20
  __int64 k; // x22
  _QWORD *v39; // x21
  _QWORD *v40; // x24
  __int64 v42; // [xsp+0h] [xbp-30h]
  FILE *v43; // [xsp+20h] [xbp-10h]

  v4 = *(_QWORD *)(a1 + 2000);
  sub_632F114(a1, 2);
  if ( !v4 )
    goto LABEL_56;
  v5 = *(_QWORD *)(a1 + 2464);
  v43 = 0LL;
  v6 = *(char **)(a1 + 2000);
  if ( !v5 )
    goto LABEL_56;
  sub_630BE0C(v5);
  v7 = strcmp("-", v6);
  if ( v7 )
  {
    v8 = sub_630CEC0(a1, v6);
    if ( v8 )
      goto LABEL_48;
    v9 = 0LL;
  }
  else
  {
    v9 = stdout;
    v43 = stdout;
  }
  fwrite(
    "# Netscape HTTP Cookie File\n"
    "# https://curl.se/docs/http-cookies.html\n"
    "# This file was generated by libcurl! Edit at your own risk.\n"
    "\n",
    0x83uLL,
    1uLL,
    v9);
  v10 = *(int *)(v5 + 512);
  if ( !(_DWORD)v10 )
  {
LABEL_44:
    if ( v7 )
      fclose(v43);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(0LL);
    goto LABEL_56;
  }
  v11 = (_QWORD *)off_6CA6320(1LL, 8 * v10);
  if ( v11 )
  {
    v12 = (unsigned __int64)v11;
    v13 = 0LL;
    v14 = 0LL;
    do
    {
      for ( i = *(_QWORD **)(v5 + 8 * v13); i; i = (_QWORD *)*i )
      {
        if ( i[5] )
          v11[v14++] = i;
      }
      ++v13;
    }
    while ( v13 != 63 );
    qsort(v11, v14, 8uLL, (__compar_fn_t)sub_630CEA0);
    if ( v14 )
    {
      for ( j = 0LL; j < v14; j = (unsigned int)(j + 1) )
      {
        v17 = *(_QWORD *)(v12 + 8 * j);
        v18 = *(_BYTE **)(v17 + 40);
        if ( *(_BYTE *)(v17 + 56) )
        {
          if ( v18 )
          {
            v19 = "TRUE";
            if ( *v18 == 46 )
              v20 = &byte_CC4FFC;
            else
              v20 = ".";
            goto LABEL_26;
          }
          v19 = "TRUE";
        }
        else
        {
          v19 = "FALSE";
        }
        v20 = &byte_CC4FFC;
LABEL_26:
        if ( v18 )
          v21 = *(const char **)(v17 + 40);
        else
          v21 = "unknown";
        if ( *(_QWORD *)(v17 + 24) )
          v22 = *(const char **)(v17 + 24);
        else
          v22 = "/";
        if ( *(_QWORD *)(v17 + 16) )
          v23 = *(const char **)(v17 + 16);
        else
          v23 = &byte_CC4FFC;
        if ( *(_BYTE *)(v17 + 57) )
          v24 = "TRUE";
        else
          v24 = "FALSE";
        if ( *(_BYTE *)(v17 + 59) )
          v25 = "#HttpOnly_";
        else
          v25 = &byte_CC4FFC;
        v26 = (const char *)sub_6320C70(
                              "%s%s%s\t%s\t%s\t%s\t%ld\t%s\t%s",
                              v25,
                              v20,
                              v21,
                              v19,
                              v22,
                              v24,
                              *(_QWORD *)(v17 + 48),
                              *(const char **)(v17 + 8),
                              v23);
        if ( !v26 )
        {
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v12);
          v8 = 27;
          v28 = v43;
          if ( !v43 )
            goto LABEL_51;
          goto LABEL_49;
        }
        v27 = (unsigned __int64)v26;
        sub_6320D2C(v43, "%s\n", v26);
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v27);
      }
    }
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v12);
    goto LABEL_44;
  }
  v8 = 27;
LABEL_48:
  v28 = v43;
  if ( !v43 )
    goto LABEL_51;
LABEL_49:
  if ( v7 )
    fclose(v28);
LABEL_51:
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(0LL);
  if ( a1 )
  {
    if ( (*(_DWORD *)(a1 + 2458) & 0x100000) != 0 )
    {
      v29 = *(_QWORD *)(a1 + 4576);
      if ( !v29 || *(int *)(v29 + 8) >= 1 )
      {
        v30 = *(_QWORD *)(a1 + 2000);
        v31 = sub_633132C(v8);
        sub_62FB210(a1, "WARNING: failed to save cookies in %s: %s", v30, v31, v32, v33, v34, v35, v42);
      }
    }
  }
LABEL_56:
  if ( (a2 & 1) != 0 )
  {
    v36 = *(_QWORD *)(a1 + 224);
    v37 = *(_QWORD *)(a1 + 2464);
    if ( !v36 || v37 != *(_QWORD *)(v36 + 248) )
    {
      if ( v37 )
      {
        for ( k = 0LL; k != 63; ++k )
        {
          v39 = *(_QWORD **)(v37 + 8 * k);
          if ( v39 )
          {
            do
            {
              v40 = (_QWORD *)*v39;
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v39[5]);
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v39[3]);
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v39[4]);
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v39[1]);
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v39[2]);
              ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v39);
              v39 = v40;
            }
            while ( v40 );
          }
        }
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v37);
      }
      *(_QWORD *)(a1 + 2464) = 0LL;
    }
  }
  return sub_632F158(a1, 2);
}


================================================================================
Function: sub_630CEC0 (0x630CEC0)
================================================================================

__int64 __fastcall sub_630CEC0(__int64 a1, char *filename, FILE **a3, const char **a4)
{
  FILE *v8; // x0
  int v9; // w0
  int v10; // w24
  unsigned int v11; // w0
  unsigned int v12; // w22
  const char *v13; // x21
  size_t v15; // x0
  char *v16; // x8
  size_t v17; // x9
  int v18; // w10
  int v19; // w11
  size_t v20; // x10
  size_t v21; // x22
  const char *v22; // x0
  unsigned __int64 v23; // x22
  int v24; // w0
  int v25; // w22
  FILE *v26; // x0
  char v27[16]; // [xsp+8h] [xbp-D8h] BYREF
  int v28; // [xsp+18h] [xbp-C8h]
  unsigned __int64 v29[4]; // [xsp+88h] [xbp-58h] BYREF
  char v30[44]; // [xsp+ACh] [xbp-34h] BYREF

  *a4 = 0LL;
  v8 = fopen(filename, "w");
  *a3 = v8;
  if ( !v8 )
  {
    v13 = 0LL;
    goto LABEL_8;
  }
  v9 = fileno(v8);
  if ( fstat(v9, (struct stat *)v27) != -1 )
  {
    v10 = v28;
    if ( (v28 & 0xF000) == 0x8000 )
    {
      fclose(*a3);
      *a3 = 0LL;
      v11 = sub_6326218(a1, v30, 41LL);
      if ( v11 )
      {
        v12 = v11;
        v13 = 0LL;
LABEL_9:
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v13);
        return v12;
      }
      sub_6304D94(v29, 8000000LL);
      v15 = strlen(filename);
      if ( v15 )
      {
        v16 = filename - 1;
        do
        {
          v17 = v15;
          if ( !v15 )
            break;
          v18 = (unsigned __int8)v16[v15--];
        }
        while ( v18 != 47 );
        while ( v17 )
        {
          v19 = (unsigned __int8)v16[v17];
          v20 = --v17;
          if ( v19 != 47 )
          {
            v21 = v20 + 1;
            goto LABEL_20;
          }
        }
      }
      v21 = 0LL;
LABEL_20:
      if ( (unsigned int)sub_6304E6C(v29, filename, v21)
        || v21 && (unsigned int)sub_6304E6C(v29, "/", 1uLL)
        || (v22 = (const char *)sub_6305070((__int64)v29)) == 0LL )
      {
        v13 = 0LL;
        v12 = 27;
        goto LABEL_9;
      }
      v23 = (unsigned __int64)v22;
      v13 = (const char *)sub_6320C70("%s%s.tmp", v22, v30);
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v23);
      if ( !v13 )
      {
        v12 = 27;
        goto LABEL_9;
      }
      v24 = open(v13, 193, v10 | 0x180u);
      if ( v24 != -1 )
      {
        v25 = v24;
        v26 = fdopen(v24, "w");
        *a3 = v26;
        if ( v26 )
        {
          v12 = 0;
          *a4 = v13;
          return v12;
        }
        close(v25);
        unlink(v13);
      }
LABEL_8:
      v12 = 23;
      goto LABEL_9;
    }
  }
  return 0;
}


================================================================================
Function: sub_630D0F4 (0x630D0F4)
================================================================================

__int64 __fastcall sub_630D0F4(__int64 a1)
{
  __int64 v1; // x21
  char v3; // w8
  char v4; // w9
  __int64 (__fastcall *v5)(); // x8
  __int64 v6; // x0
  __int64 (__fastcall *v7)(); // x8

  v1 = a1 + 4696;
  v3 = *(_BYTE *)(a1 + 2892) & 0xFD;
  v4 = *(_BYTE *)(a1 + 4924);
  *(_QWORD *)(a1 + 2608) = 0LL;
  *(_BYTE *)(a1 + 2892) = v3;
  *(_QWORD *)(a1 + 2672) = 0LL;
  *(_DWORD *)(a1 + 4704) = 0;
  *(_OWORD *)(a1 + 2624) = 0u;
  *(_OWORD *)(a1 + 2640) = 0u;
  *(_OWORD *)(a1 + 2656) = 0u;
  *(_QWORD *)(a1 + 4696) = 0LL;
  *(_QWORD *)(a1 + 4712) = -1LL;
  v5 = off_6CA6308[0];
  *(_DWORD *)(a1 + 4776) = 0;
  v6 = *(_QWORD *)(a1 + 4752);
  *(_BYTE *)(v1 + 228) = v4 & 0xFE;
  *(_OWORD *)(a1 + 4720) = 0u;
  *(_OWORD *)(a1 + 4736) = 0u;
  ((void (__fastcall *)(__int64))v5)(v6);
  v7 = off_6CA6308[0];
  *(_QWORD *)(a1 + 4752) = 0LL;
  ((void (__fastcall *)(_QWORD))v7)(*(_QWORD *)(a1 + 4760));
  *(_QWORD *)(a1 + 4768) = 0LL;
  *(_QWORD *)(a1 + 4760) = 0LL;
  *(_DWORD *)(v1 + 180) = 0;
  *(_OWORD *)(v1 + 164) = 0u;
  *(_OWORD *)(v1 + 84) = 0u;
  *(_OWORD *)(v1 + 100) = 0u;
  *(_OWORD *)(v1 + 116) = 0u;
  *(_OWORD *)(v1 + 132) = 0u;
  *(_OWORD *)(v1 + 148) = 0u;
  *(_QWORD *)(a1 + 4872) = -1LL;
  *(_QWORD *)(a1 + 4888) = 0LL;
  *(_DWORD *)(a1 + 4896) = 0;
  sub_633EACC(a1);
  return 0LL;
}


================================================================================
Function: sub_630D8F8 (0x630D8F8)
================================================================================

_QWORD *__fastcall sub_630D8F8(_QWORD *result, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  *result = 0LL;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  result[4] = a2;
  result[5] = 0LL;
  return result;
}


================================================================================
Function: sub_630D908 (0x630D908)
================================================================================

__int64 __fastcall sub_630D908(__int64 a1, const void *a2, size_t a3, __int64 a4, __int64 a5)
{
  __int64 v10; // x24
  unsigned __int64 v11; // x2
  _QWORD *v12; // x0
  unsigned __int64 v13; // x25
  __int64 v14; // x27
  __int64 *v15; // x24
  __int64 v16; // x0
  __int64 v17; // x25
  __int64 v18; // x0
  __int64 v19; // x0
  __int64 *v20; // x25

  v10 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    v11 = *(_QWORD *)(a1 + 32);
  }
  else
  {
    v12 = (_QWORD *)((__int64 (__fastcall *)(unsigned __int64))off_6CA6300[0])(32LL * *(_QWORD *)(a1 + 32));
    *(_QWORD *)a1 = v12;
    if ( !v12 )
      return 0LL;
    if ( *(_QWORD *)(a1 + 32) )
    {
      sub_631CC00(v12, (__int64)sub_630DAB0);
      v11 = *(_QWORD *)(a1 + 32);
      if ( v11 >= 2 )
      {
        v13 = 1LL;
        v14 = 32LL;
        do
        {
          sub_631CC00((_QWORD *)(*(_QWORD *)a1 + v14), (__int64)sub_630DAB0);
          v11 = *(_QWORD *)(a1 + 32);
          ++v13;
          v14 += 32LL;
        }
        while ( v13 < v11 );
      }
    }
    else
    {
      v11 = 0LL;
    }
    v10 = *(_QWORD *)a1;
  }
  v15 = (__int64 *)(v10 + 32 * (*(__int64 (__fastcall **)(const void *, size_t, unsigned __int64))(a1 + 8))(a2, a3, v11));
  v16 = sub_631CEA4((__int64)v15);
  if ( v16 )
  {
    v17 = v16;
    while ( 1 )
    {
      v18 = sub_631CEB4(v17);
      if ( (*(__int64 (__fastcall **)(__int64, _QWORD, const void *, size_t))(a1 + 16))(
             v18 + 56,
             *(_QWORD *)(v18 + 48),
             a2,
             a3) )
      {
        break;
      }
      v17 = sub_631CEBC(v17);
      if ( !v17 )
        goto LABEL_17;
    }
    sub_631CCF0(v17, a1);
    --*(_QWORD *)(a1 + 40);
  }
LABEL_17:
  v19 = ((__int64 (__fastcall *)(unsigned __int64))off_6CA6300[0])(a3 + 64);
  if ( !v19 )
    return 0LL;
  v20 = (__int64 *)v19;
  memcpy((void *)(v19 + 56), a2, a3);
  v20[5] = a5;
  v20[6] = a3;
  v20[4] = a4;
  sub_631CC7C(v15, v20, (__int64 **)v20);
  ++*(_QWORD *)(a1 + 40);
  return a4;
}


================================================================================
Function: sub_630DB10 (0x630DB10)
================================================================================

__int64 __fastcall sub_630DB10(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_630D908(a1, a2, a3, a4, 0LL);
}


================================================================================
Function: sub_630DB18 (0x630DB18)
================================================================================

__int64 __fastcall sub_630DB18(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x22
  __int64 v7; // x0
  __int64 v8; // x0
  __int64 v9; // x22
  __int64 v10; // x0
  __int64 result; // x0

  v3 = *a1;
  if ( !*a1 )
    return 1LL;
  v7 = ((__int64 (__fastcall *)(__int64, __int64, __int64))a1[1])(a2, a3, a1[4]);
  v8 = sub_631CEA4(v3 + 32 * v7);
  if ( !v8 )
    return 1LL;
  v9 = v8;
  while ( 1 )
  {
    v10 = sub_631CEB4(v9);
    if ( ((__int64 (__fastcall *)(__int64, _QWORD, __int64, __int64))a1[2])(v10 + 56, *(_QWORD *)(v10 + 48), a2, a3) )
      break;
    v9 = sub_631CEBC(v9);
    if ( !v9 )
      return 1LL;
  }
  sub_631CCF0(v9, a1);
  result = 0LL;
  --a1[5];
  return result;
}


================================================================================
Function: sub_630DBCC (0x630DBCC)
================================================================================

__int64 __fastcall sub_630DBCC(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x22
  __int64 v7; // x0
  __int64 result; // x0
  __int64 v9; // x22
  __int64 v10; // x23

  v3 = *a1;
  if ( !*a1 )
    return 0LL;
  v7 = ((__int64 (__fastcall *)(__int64, __int64, __int64))a1[1])(a2, a3, a1[4]);
  result = sub_631CEA4(v3 + 32 * v7);
  if ( result )
  {
    v9 = result;
    while ( 1 )
    {
      v10 = sub_631CEB4(v9);
      if ( ((__int64 (__fastcall *)(__int64, _QWORD, __int64, __int64))a1[2])(v10 + 56, *(_QWORD *)(v10 + 48), a2, a3) )
        break;
      result = sub_631CEBC(v9);
      v9 = result;
      if ( !result )
        return result;
    }
    return *(_QWORD *)(v10 + 32);
  }
  return result;
}


================================================================================
Function: sub_630DC74 (0x630DC74)
================================================================================

unsigned __int64 __fastcall sub_630DC74(unsigned __int64 *a1)
{
  unsigned __int64 result; // x0
  unsigned __int64 v3; // x20
  __int64 v4; // x21

  result = *a1;
  if ( result )
  {
    if ( a1[4] )
    {
      ((void (*)(void))sub_631CDEC)();
      if ( a1[4] >= 2 )
      {
        v3 = 1LL;
        v4 = 32LL;
        do
        {
          sub_631CDEC(*a1 + v4, a1);
          ++v3;
          v4 += 32LL;
        }
        while ( v3 < a1[4] );
      }
      result = *a1;
    }
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(result);
    *a1 = 0LL;
  }
  a1[4] = 0LL;
  a1[5] = 0LL;
  return result;
}


================================================================================
Function: sub_630DD04 (0x630DD04)
================================================================================

__int64 *__fastcall sub_630DD04(__int64 *result)
{
  __int64 *v1; // x19
  __int64 v2; // x8
  __int64 v3; // x22
  __int64 v4; // x20
  __int64 v5; // x21

  if ( result )
  {
    v1 = result;
    v2 = *result;
    if ( *result )
    {
      if ( result[4] )
      {
        v3 = 0LL;
        while ( 1 )
        {
          result = (__int64 *)sub_631CEA4(v2 + 32 * v3);
          if ( result )
          {
            v4 = (__int64)result;
            do
            {
              sub_631CEB4(v4);
              v5 = sub_631CEBC(v4);
              result = (__int64 *)sub_631CCF0(v4, v1);
              v4 = v5;
              --v1[5];
            }
            while ( v5 );
          }
          if ( ++v3 >= (unsigned __int64)v1[4] )
            break;
          v2 = *v1;
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_630DEE4 (0x630DEE4)
================================================================================

__int64 __fastcall sub_630DEE4(__int64 result, _QWORD *a2)
{
  a2[1] = 0LL;
  a2[2] = 0LL;
  *a2 = result;
  return result;
}


================================================================================
Function: sub_630DEF0 (0x630DEF0)
================================================================================

__int64 __fastcall sub_630DEF0(__int64 a1)
{
  _QWORD *v1; // x20
  __int64 v3; // x0
  __int64 v4; // x0
  unsigned __int64 v5; // x21
  __int64 i; // x22

  v1 = *(_QWORD **)a1;
  if ( **(_QWORD **)a1 )
  {
    v3 = *(_QWORD *)(a1 + 16);
    if ( v3 )
    {
      v4 = sub_631CEBC(v3);
      *(_QWORD *)(a1 + 16) = v4;
      if ( v4 )
        return sub_631CEB4(v4);
    }
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 < v1[4] )
    {
      for ( i = 32 * v5; !sub_631CEA4(*v1 + i); i += 32LL )
      {
        if ( ++v5 >= v1[4] )
        {
          v4 = *(_QWORD *)(a1 + 16);
          if ( !v4 )
            return 0LL;
          return sub_631CEB4(v4);
        }
      }
      v4 = sub_631CEA4(*v1 + i);
      *(_QWORD *)(a1 + 8) = v5 + 1;
      *(_QWORD *)(a1 + 16) = v4;
      if ( v4 )
        return sub_631CEB4(v4);
    }
  }
  return 0LL;
}


================================================================================
Function: sub_630E550 (0x630E550)
================================================================================

__int64 __fastcall sub_630E550(__int64 a1)
{
  _QWORD *v2; // x20
  __int64 v3; // x0
  __int64 v4; // x21
  __int64 v5; // x22

  v2 = (_QWORD *)(a1 + 4424);
  v3 = sub_631CEA4(a1 + 4424);
  if ( v3 )
  {
    v4 = v3;
    do
    {
      v5 = sub_631CEB4(v4);
      v4 = sub_631CEBC(v4);
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v5);
    }
    while ( v4 );
  }
  sub_631CC00(v2, 0LL);
  *(_QWORD *)(a1 + 4552) = 0LL;
  return 0LL;
}


================================================================================
Function: sub_630EF54 (0x630EF54)
================================================================================

bool __fastcall sub_630EF54(char *cp)
{
  __int64 v3; // [xsp+0h] [xbp-20h] BYREF
  _BYTE buf[16]; // [xsp+8h] [xbp-18h] BYREF

  return inet_pton(2, cp, &v3) > 0 || inet_pton(10, cp, buf) > 0;
}


================================================================================
Function: sub_630F860 (0x630F860)
================================================================================

unsigned __int64 __fastcall sub_630F860(unsigned __int64 result, _QWORD *a2)
{
  _QWORD *v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  __int64 v5; // x8

  v2 = (_QWORD *)*a2;
  *a2 = 0LL;
  if ( result )
  {
    v3 = result;
    if ( *(_QWORD *)(result + 224) )
      result = sub_632F114(result, 3);
    v4 = v2[2] - 1LL;
    v2[2] = v4;
    if ( v4 )
    {
      if ( !*(_QWORD *)(v3 + 224) )
        return result;
    }
    else
    {
      sub_63041E0(*v2);
      result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v2);
      if ( !*(_QWORD *)(v3 + 224) )
        return result;
    }
    return sub_632F158(v3, 3);
  }
  v5 = v2[2] - 1LL;
  v2[2] = v5;
  if ( !v5 )
  {
    sub_63041E0(*v2);
    return ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v2);
  }
  return result;
}


================================================================================
Function: sub_630F978 (0x630F978)
================================================================================

__int64 __fastcall sub_630F978(__int64 a1, __int64 a2)
{
  return sub_630D8F8(a1, a2, sub_630DE74, sub_630DEAC, sub_630F928);
}


================================================================================
Function: sub_630F994 (0x630F994)
================================================================================

__int64 __fastcall sub_630F994(__int64 a1, __int64 a2)
{
  __int64 result; // x0

  if ( !a1 )
    return sub_630DD04(a2);
  if ( *(_QWORD *)(a1 + 224) )
    sub_632F114(a1, 3);
  result = sub_630DD04(a2);
  if ( *(_QWORD *)(a1 + 224) )
    return sub_632F158(a1, 3LL);
  return result;
}


================================================================================
Function: sub_6310090 (0x6310090)
================================================================================

__int64 sub_6310090()
{
  __int64 v0; // x0
  __int64 v1; // x19

  v0 = off_6CA6320(1LL, 48LL);
  v1 = v0;
  if ( v0 )
    sub_631CC00(v0, 0LL);
  return v1;
}


================================================================================
Function: sub_63100D8 (0x63100D8)
================================================================================

unsigned __int64 *__fastcall sub_63100D8(unsigned __int64 *result)
{
  unsigned __int64 v1; // x20
  unsigned __int64 *v2; // x19
  __int64 v3; // x0
  __int64 v4; // x21
  __int64 v5; // x22

  v1 = *result;
  if ( *result )
  {
    v2 = result;
    v3 = sub_631CEA4(*result);
    if ( v3 )
    {
      v4 = v3;
      do
      {
        v5 = sub_631CEB4(v4);
        v4 = sub_631CEBC(v4);
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v5 + 32));
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v5);
      }
      while ( v4 );
    }
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v1 + 32));
    result = (unsigned __int64 *)((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1);
    *v2 = 0LL;
  }
  return result;
}


================================================================================
Function: sub_63105D0 (0x63105D0)
================================================================================

__int64 __fastcall sub_63105D0(__int64 a1, __int64 a2, char *filename)
{
  char *v3; // x21
  unsigned int v6; // w22
  __int64 v7; // x0
  __int64 v8; // x23
  char *v9; // x2
  __int64 v10; // x28
  __int64 v11; // x0
  unsigned int v12; // w0
  const char *v13; // x2
  __int64 v14; // x0
  __int64 v15; // x20
  __int64 v16; // x22
  const char *v17; // x8
  __int64 v18; // x0
  char v19; // w9
  unsigned int v20; // w0
  int v21; // w0
  _QWORD v23[2]; // [xsp+18h] [xbp-88h] BYREF
  char *name; // [xsp+28h] [xbp-78h]
  FILE *s; // [xsp+30h] [xbp-70h]
  int v26; // [xsp+38h] [xbp-68h] BYREF
  int v27; // [xsp+3Ch] [xbp-64h]
  int v28; // [xsp+40h] [xbp-60h]
  int v29; // [xsp+44h] [xbp-5Ch]
  int v30; // [xsp+48h] [xbp-58h]
  int v31; // [xsp+4Ch] [xbp-54h]
  const char *v32[2]; // [xsp+70h] [xbp-30h] BYREF
  char v33; // [xsp+80h] [xbp-20h]
  char v34[23]; // [xsp+81h] [xbp-1Fh] BYREF

  name = 0LL;
  if ( a2 )
  {
    v3 = filename;
    if ( !filename )
      v3 = *(char **)(a2 + 32);
    v6 = 0;
    if ( (*(_BYTE *)(a2 + 40) & 2) == 0 && v3 )
    {
      if ( *v3 )
      {
        v6 = sub_630CEC0(a1, v3);
        if ( !v6 )
        {
          fwrite(
            "# Your HSTS cache. https://curl.se/docs/hsts.html\n"
            "# This file was generated by libcurl! Edit at your own risk.\n",
            0x6FuLL,
            1uLL,
            s);
          v7 = sub_631CEA4(a2);
          if ( v7 )
          {
            v8 = v7;
            while ( 1 )
            {
              while ( 1 )
              {
                v10 = sub_631CEB4(v8);
                v8 = sub_631CEBC(v8);
                v11 = *(_QWORD *)(v10 + 48);
                if ( v11 != 0x7FFFFFFFFFFFFFFFLL )
                  break;
                if ( *(_BYTE *)(v10 + 40) )
                  v9 = ".";
                else
                  v9 = &byte_CC4FFC;
                sub_6320D2C(s, "%s%s \"%s\"\n", v9, *(_QWORD *)(v10 + 32), "unlimited");
                if ( !v8 )
                {
LABEL_20:
                  v6 = 0;
                  goto LABEL_24;
                }
              }
              v12 = sub_6325370(v11, &v26);
              if ( v12 )
                break;
              if ( *(_BYTE *)(v10 + 40) )
                v13 = ".";
              else
                v13 = &byte_CC4FFC;
              sub_6320D2C(
                s,
                "%s%s \"%d%02d%02d %02d:%02d:%02d\"\n",
                v13,
                *(const char **)(v10 + 32),
                v31 + 1900,
                v30 + 1,
                v29,
                v28,
                v27,
                v26);
              if ( !v8 )
                goto LABEL_20;
            }
            v6 = v12;
          }
          else
          {
            v6 = 0;
          }
LABEL_24:
          fclose(s);
        }
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)name);
      }
      else
      {
        v6 = 0;
      }
    }
    if ( *(_QWORD *)(a1 + 720) )
    {
      v23[0] = 0LL;
      v23[1] = sub_631CEAC(a2);
      v14 = sub_631CEA4(a2);
      if ( v14 )
      {
        v15 = v14;
        while ( 1 )
        {
          v16 = sub_631CEB4(v15);
          v15 = sub_631CEBC(v15);
          v32[0] = *(const char **)(v16 + 32);
          v17 = (const char *)strlen(v32[0]);
          v18 = *(_QWORD *)(v16 + 48);
          v19 = *(_BYTE *)(v16 + 40);
          v32[1] = v17;
          v33 = v19;
          if ( v18 == 0x7FFFFFFFFFFFFFFFLL )
          {
            strcpy(v34, "unlimited");
          }
          else
          {
            v20 = sub_6325370(v18, &v26);
            if ( v20 )
              return v20;
            sub_63209BC(v34, 18LL, "%d%02d%02d %02d:%02d:%02d", v31 + 1900, v30 + 1, v29, v28, v27, v26);
          }
          v21 = (*(__int64 (__fastcall **)(__int64, const char **, _QWORD *, _QWORD))(a1 + 720))(
                  a1,
                  v32,
                  v23,
                  *(_QWORD *)(a1 + 728));
          if ( v21 )
            break;
          ++v23[0];
          if ( !v15 )
            return 0;
        }
        if ( v21 == 2 )
          return 43;
        else
          return 0;
      }
    }
  }
  else
  {
    return 0;
  }
  return v6;
}


================================================================================
Function: sub_631B174 (0x631B174)
================================================================================

_QWORD *__fastcall sub_631B174(__int64 a1)
{
  _QWORD *v2; // x0
  void (*v3)(void); // x9
  _QWORD *result; // x0

  v2 = *(_QWORD **)a1;
  if ( v2 )
  {
    do
    {
      *(_QWORD *)a1 = *v2;
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v2);
      v2 = *(_QWORD **)a1;
    }
    while ( *(_QWORD *)a1 );
  }
  while ( 1 )
  {
    result = *(_QWORD **)(a1 + 16);
    if ( !result )
      break;
    v3 = (void (*)(void))off_6CA6308[0];
    *(_QWORD *)(a1 + 16) = *result;
    v3();
  }
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  return result;
}


================================================================================
Function: sub_631B1DC (0x631B1DC)
================================================================================

__int64 __fastcall sub_631B1DC(__int64 result)
{
  _QWORD *v1; // x8
  _QWORD *v2; // x9
  _QWORD *v3; // x10

  v1 = *(_QWORD **)result;
  if ( *(_QWORD *)result )
  {
    v2 = *(_QWORD **)(result + 16);
    do
    {
      v3 = v1;
      v1 = (_QWORD *)*v1;
      *v3 = v2;
      v2 = v3;
    }
    while ( v1 );
    *(_QWORD *)result = 0LL;
    *(_QWORD *)(result + 16) = v3;
  }
  *(_QWORD *)(result + 8) = 0LL;
  return result;
}


================================================================================
Function: sub_631B20C (0x631B20C)
================================================================================

__int64 __fastcall sub_631B20C(_QWORD *a1)
{
  _QWORD *v1; // x8
  __int64 result; // x0
  __int64 v3; // x9
  __int64 v4; // x10

  v1 = (_QWORD *)*a1;
  if ( !*a1 )
    return 0LL;
  result = 0LL;
  do
  {
    v4 = v1[2];
    v3 = v1[3];
    v1 = (_QWORD *)*v1;
    result = v3 + result - v4;
  }
  while ( v1 );
  return result;
}


================================================================================
Function: sub_631B238 (0x631B238)
================================================================================

bool __fastcall sub_631B238(__int64 a1)
{
  return !*(_QWORD *)a1 || *(_QWORD *)(*(_QWORD *)a1 + 16LL) >= *(_QWORD *)(*(_QWORD *)a1 + 24LL);
}


================================================================================
Function: sub_631B5A0 (0x631B5A0)
================================================================================

__int64 *__fastcall sub_631B5A0(__int64 a1)
{
  __int64 *result; // x0
  __int64 *v3; // x10
  __int64 v4; // x9
  __int64 *v5; // x9
  __int64 v6; // x8
  __int64 v7; // x10
  __int64 v8; // x8

  result = *(__int64 **)a1;
  if ( result )
  {
    while ( 1 )
    {
      if ( result[2] < (unsigned __int64)result[3] )
        return result;
      v3 = *(__int64 **)(a1 + 8);
      v4 = *result;
      *(_QWORD *)a1 = *result;
      if ( v3 == result )
      {
        *(_QWORD *)(a1 + 8) = v4;
        v5 = *(__int64 **)(a1 + 24);
        if ( !v5 )
          goto LABEL_8;
LABEL_5:
        if ( v5[2] >= (unsigned __int64)v5[3] )
          goto LABEL_12;
        result[2] = 0LL;
        result[3] = 0LL;
        v6 = v5[2];
        v7 = *v5;
        *v5 = (__int64)result;
        *result = v7;
        v5[2] = v6 + 1;
LABEL_13:
        --*(_QWORD *)(a1 + 32);
        result = *(__int64 **)a1;
        if ( !*(_QWORD *)a1 )
          return result;
      }
      else
      {
        v5 = *(__int64 **)(a1 + 24);
        if ( v5 )
          goto LABEL_5;
LABEL_8:
        if ( *(_QWORD *)(a1 + 32) > *(_QWORD *)(a1 + 40) || (*(_BYTE *)(a1 + 56) & 2) != 0 )
        {
LABEL_12:
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)result);
          goto LABEL_13;
        }
        v8 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = result;
        *result = v8;
        result = *(__int64 **)a1;
        if ( !*(_QWORD *)a1 )
          return result;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_631B758 (0x631B758)
================================================================================

__int64 __fastcall sub_631B758(__int64 *a1, _QWORD *a2, unsigned __int64 *a3)
{
  __int64 v4; // x8
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x10
  bool v9; // cc
  unsigned __int64 v10; // x9
  __int64 result; // x0

  v4 = *a1;
  if ( *a1
    && (*(_QWORD *)(v4 + 16) < *(_QWORD *)(v4 + 24) || (sub_631B5A0(), (v4 = *a1) != 0))
    && (v8 = *(_QWORD *)(v4 + 16), v7 = *(_QWORD *)(v4 + 24), v9 = v7 > v8, v10 = v7 - v8, v9) )
  {
    result = 1LL;
    *a2 = v4 + v8 + 32;
  }
  else
  {
    v10 = 0LL;
    result = 0LL;
    *a2 = 0LL;
  }
  *a3 = v10;
  return result;
}


================================================================================
Function: sub_631BBA8 (0x631BBA8)
================================================================================

__int64 __fastcall sub_631BBA8(__int64 a1)
{
  sub_633B648(a1 + 3048);
  return sub_633B648(a1 + 3104);
}


================================================================================
Function: sub_631BE18 (0x631BE18)
================================================================================

__int64 __fastcall sub_631BE18(__int64 a1)
{
  sub_633C38C(a1 + 1008);
  return sub_633C38C(a1 + 1032);
}


================================================================================
Function: sub_631CC00 (0x631CC00)
================================================================================

_QWORD *__fastcall sub_631CC00(_QWORD *result, __int64 a2)
{
  result[2] = a2;
  result[3] = 0LL;
  *result = 0LL;
  result[1] = 0LL;
  return result;
}


================================================================================
Function: sub_631CC0C (0x631CC0C)
================================================================================

__int64 *__fastcall sub_631CC0C(__int64 *result, __int64 *a2, __int64 *a3, __int64 **a4)
{
  __int64 v4; // x8
  __int64 *v5; // x9
  __int64 *v6; // x10
  __int64 *v7; // x10
  __int64 ***v8; // x10

  v4 = result[3];
  a4[1] = a3;
  *a4 = result;
  if ( v4 )
  {
    v5 = a2 + 3;
    if ( a2 )
      v6 = a2 + 3;
    else
      v6 = result;
    v7 = (__int64 *)*v6;
    a4[2] = a2;
    a4[3] = v7;
    if ( a2 )
    {
      if ( *v5 )
        v8 = (__int64 ***)(*v5 + 16);
      else
        v8 = (__int64 ***)(result + 1);
      *v8 = a4;
    }
    else
    {
      v5 = result;
      *(_QWORD *)(*result + 16) = a4;
    }
  }
  else
  {
    *result = (__int64)a4;
    v5 = result + 1;
    a4[2] = 0LL;
    a4[3] = 0LL;
  }
  *v5 = (__int64)a4;
  result[3] = v4 + 1;
  return result;
}


================================================================================
Function: sub_631CC7C (0x631CC7C)
================================================================================

__int64 *__fastcall sub_631CC7C(__int64 *result, __int64 *a2, __int64 **a3)
{
  __int64 v3; // x8
  __int64 *v4; // x9
  __int64 *v5; // x11
  __int64 *v6; // x10
  __int64 *v7; // x12
  __int64 *v8; // x12
  __int64 ***v9; // x11

  v3 = result[3];
  a3[1] = a2;
  *a3 = result;
  v4 = result + 1;
  v5 = (__int64 *)result[1];
  if ( v3 )
  {
    v6 = v5 + 3;
    if ( v5 )
      v7 = v5 + 3;
    else
      v7 = result;
    v8 = (__int64 *)*v7;
    a3[2] = v5;
    a3[3] = v8;
    if ( v5 )
    {
      if ( *v6 )
        v9 = (__int64 ***)(*v6 + 16);
      else
        v9 = (__int64 ***)(result + 1);
      v4 = v6;
      *v9 = a3;
    }
    else
    {
      v4 = result;
      *(_QWORD *)(*result + 16) = a3;
    }
  }
  else
  {
    *result = (__int64)a3;
    a3[2] = 0LL;
    a3[3] = 0LL;
  }
  *v4 = (__int64)a3;
  result[3] = v3 + 1;
  return result;
}


================================================================================
Function: sub_631CCF0 (0x631CCF0)
================================================================================

__int64 __fastcall sub_631CCF0(__int64 result, __int64 a2)
{
  _QWORD *v2; // x9
  __int64 v3; // x8
  __int64 v4; // x10
  __int64 v5; // x8
  __int64 v6; // x8
  __int64 (__fastcall *v7)(__int64, __int64); // x2

  if ( result )
  {
    v2 = *(_QWORD **)result;
    if ( **(_QWORD **)result == result )
    {
      v5 = *(_QWORD *)(result + 24);
      *v2 = v5;
      if ( v5 )
        *(_QWORD *)(v5 + 16) = 0LL;
      else
        v2[1] = 0LL;
    }
    else
    {
      v3 = *(_QWORD *)(result + 16);
      if ( v3 )
        *(_QWORD *)(v3 + 24) = *(_QWORD *)(result + 24);
      v4 = *(_QWORD *)(result + 24);
      if ( v4 )
        *(_QWORD *)(v4 + 16) = v3;
      else
        v2[1] = v3;
    }
    v6 = *(_QWORD *)(result + 8);
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    v7 = (__int64 (__fastcall *)(__int64, __int64))v2[2];
    --v2[3];
    if ( v7 )
      return v7(a2, v6);
  }
  return result;
}


================================================================================
Function: sub_631CD70 (0x631CD70)
================================================================================

__int64 __fastcall sub_631CD70(__int64 result)
{
  _QWORD *v1; // x8
  __int64 v2; // x9
  __int64 v3; // x10
  __int64 v4; // x9
  __int64 v5; // x1
  __int64 (__fastcall *v6)(_QWORD, __int64); // x2

  if ( result )
  {
    v1 = *(_QWORD **)result;
    if ( **(_QWORD **)result == result )
    {
      v4 = *(_QWORD *)(result + 24);
      *v1 = v4;
      if ( v4 )
        *(_QWORD *)(v4 + 16) = 0LL;
      else
        v1[1] = 0LL;
    }
    else
    {
      v2 = *(_QWORD *)(result + 16);
      if ( v2 )
        *(_QWORD *)(v2 + 24) = *(_QWORD *)(result + 24);
      v3 = *(_QWORD *)(result + 24);
      if ( v3 )
        *(_QWORD *)(v3 + 16) = v2;
      else
        v1[1] = v2;
    }
    v5 = *(_QWORD *)(result + 8);
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    v6 = (__int64 (__fastcall *)(_QWORD, __int64))v1[2];
    --v1[3];
    if ( v6 )
      return v6(0LL, v5);
  }
  return result;
}


================================================================================
Function: sub_631CDEC (0x631CDEC)
================================================================================

__int64 __fastcall sub_631CDEC(__int64 result, __int64 a2)
{
  __int64 v2; // x19
  __int64 v4; // x8
  _QWORD *v5; // x9
  __int64 v6; // x10
  __int64 v7; // x11
  __int64 v8; // x10
  __int64 v9; // x1
  __int64 (__fastcall *v10)(__int64, __int64); // x8

  if ( result )
  {
    v2 = result;
    while ( *(_QWORD *)(v2 + 24) )
    {
      v4 = *(_QWORD *)(v2 + 8);
      if ( v4 )
      {
        v5 = *(_QWORD **)v4;
        if ( **(_QWORD **)v4 == v4 )
        {
          v8 = *(_QWORD *)(v4 + 24);
          *v5 = v8;
          if ( v8 )
            *(_QWORD *)(v8 + 16) = 0LL;
          else
            v5[1] = 0LL;
        }
        else
        {
          v6 = *(_QWORD *)(v4 + 16);
          if ( v6 )
            *(_QWORD *)(v6 + 24) = *(_QWORD *)(v4 + 24);
          v7 = *(_QWORD *)(v4 + 24);
          if ( v7 )
            *(_QWORD *)(v7 + 16) = v6;
          else
            v5[1] = v6;
        }
        v9 = *(_QWORD *)(v4 + 8);
        *(_OWORD *)v4 = 0u;
        *(_OWORD *)(v4 + 16) = 0u;
        v10 = (__int64 (__fastcall *)(__int64, __int64))v5[2];
        --v5[3];
        if ( v10 )
          result = v10(a2, v9);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_631CEA4 (0x631CEA4)
================================================================================

__int64 __fastcall sub_631CEA4(__int64 a1)
{
  return *(_QWORD *)a1;
}


================================================================================
Function: sub_631CEAC (0x631CEAC)
================================================================================

__int64 __fastcall sub_631CEAC(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}


================================================================================
Function: sub_631CEB4 (0x631CEB4)
================================================================================

__int64 __fastcall sub_631CEB4(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}


================================================================================
Function: sub_631CEBC (0x631CEBC)
================================================================================

__int64 __fastcall sub_631CEBC(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}


================================================================================
Function: sub_631CEC4 (0x631CEC4)
================================================================================

__int64 __fastcall sub_631CEC4(__int64 a1)
{
  return *(_QWORD *)a1;
}


================================================================================
Function: sub_631CECC (0x631CECC)
================================================================================

long double __fastcall sub_631CECC(__int64 a1)
{
  void (__fastcall *v2)(_QWORD); // x8
  int v3; // w8
  unsigned __int64 v4; // x0
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  long double result; // q0

  if ( a1 )
  {
    v2 = *(void (__fastcall **)(_QWORD))(a1 + 48);
    if ( v2 )
      v2(*(_QWORD *)(a1 + 56));
    v3 = *(_DWORD *)(a1 + 20);
    *(_QWORD *)(a1 + 40) = 0LL;
    *(_QWORD *)(a1 + 48) = 0LL;
    v4 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
    *(_QWORD *)(a1 + 56) = a1;
    *(_QWORD *)(a1 + 64) = 0LL;
    *(_QWORD *)(a1 + 112) = 0LL;
    *(_QWORD *)(a1 + 160) = 0LL;
    *(_QWORD *)(a1 + 168) = 0LL;
    *(_QWORD *)(a1 + 152) = 0LL;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = v3 & 0xFFFFFFFB;
    *(_DWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 432) = 1LL;
    sub_632F298(v4);
    if ( (*(_BYTE *)(a1 + 20) & 1) != 0 )
      sub_632F298(*(_QWORD *)(a1 + 80));
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 88));
    v5 = off_6CA6308[0];
    *(_QWORD *)(a1 + 88) = 0LL;
    ((void (__fastcall *)(_QWORD))v5)(*(_QWORD *)(a1 + 104));
    v6 = off_6CA6308[0];
    *(_QWORD *)(a1 + 104) = 0LL;
    ((void (__fastcall *)(_QWORD))v6)(*(_QWORD *)(a1 + 96));
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(a1 + 432) = 0LL;
    *(_QWORD *)(a1 + 432) = 1LL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    *(_OWORD *)(a1 + 240) = 0u;
    *(_OWORD *)(a1 + 256) = 0u;
    *(_OWORD *)(a1 + 272) = 0u;
    *(_OWORD *)(a1 + 288) = 0u;
    *(_OWORD *)(a1 + 304) = 0u;
    *(_OWORD *)(a1 + 320) = 0u;
    *(_OWORD *)(a1 + 336) = 0u;
    *(_OWORD *)(a1 + 352) = 0u;
    *(_OWORD *)(a1 + 368) = 0u;
    *(_OWORD *)(a1 + 384) = 0u;
    *(_OWORD *)(a1 + 400) = 0u;
    *(_OWORD *)(a1 + 416) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_DWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0LL;
    *(_QWORD *)(a1 + 136) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_631CFC8 (0x631CFC8)
================================================================================

long double __fastcall sub_631CFC8(__int64 a1)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)(a1 + 432) = 0LL;
  *(_QWORD *)(a1 + 432) = 1LL;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0LL;
  *(_QWORD *)(a1 + 136) = 0LL;
  return result;
}


================================================================================
Function: sub_631F65C (0x631F65C)
================================================================================

__int64 __fastcall sub_631F65C(_BYTE *a1, __int64 a2, __int64 a3, __int128 *a4)
{
  __int128 v4; // q0
  __int128 v5; // q1
  __int64 result; // x0
  _OWORD v7[2]; // [xsp+0h] [xbp-40h] BYREF
  _BYTE *v8; // [xsp+20h] [xbp-20h] BYREF
  __int64 v9; // [xsp+28h] [xbp-18h]
  __int64 v10; // [xsp+30h] [xbp-10h]

  v4 = *a4;
  v5 = a4[1];
  v10 = a2;
  v8 = a1;
  v9 = 0LL;
  v7[0] = v4;
  v7[1] = v5;
  result = sub_631F6E8(&v8, sub_6320984, a3, v7);
  if ( v10 )
  {
    if ( v10 == v9 )
    {
      result = (unsigned int)(result - 1);
      *(v8 - 1) = 0;
    }
    else
    {
      *v8 = 0;
    }
  }
  return result;
}


================================================================================
Function: sub_631F6E8 (0x631F6E8)
================================================================================

__int64 __fastcall sub_631F6E8(
        __int64 a1,
        unsigned int (__fastcall *a2)(long double),
        char *a3,
        int **a4,
        long double a5)
{
  int v5; // w8
  int v6; // w17
  int v7; // w16
  int v8; // w14
  int *v9; // x9
  int *v10; // x12
  int *v11; // x10
  unsigned int v12; // w11
  unsigned int v13; // w13
  char *v14; // x4
  unsigned __int8 *i; // x24
  int v16; // w6
  char *v17; // x22
  int v18; // w23
  int v19; // w5
  int v20; // w5
  int v21; // w7
  int v22; // t1
  int v23; // w7
  char *v24; // x7
  unsigned int v25; // w6
  int v26; // w21
  int v27; // w7
  char v28; // w25
  int v29; // t1
  char v30; // w2
  int v31; // w7
  int v32; // t1
  int v33; // w7
  int v34; // w25
  int v35; // w24
  int v36; // t1
  int v37; // w24
  int v38; // w21
  int v39; // w25
  int v40; // w21
  int v41; // w24
  int v42; // t1
  int v43; // w24
  __int64 v44; // x25
  int v45; // w25
  char *v46; // x24
  int v47; // w24
  int v48; // w24
  int v49; // t1
  __int64 v50; // x5
  _QWORD *v51; // x5
  char *v52; // x22
  int v53; // w23
  unsigned __int64 v54; // x23
  int v55; // w24
  unsigned __int64 v56; // x23
  unsigned __int64 v57; // x23
  int v58; // w24
  __int64 v59; // x24
  char v60; // w28
  int v61; // w19
  __int64 v62; // x19
  char v63; // w25
  int v64; // w24
  int v65; // w19
  __int64 v66; // x19
  char v67; // w26
  __int64 v68; // x19
  _BYTE *v69; // x19
  __int64 v70; // x16
  _QWORD *v71; // x16
  __int64 v72; // x15
  __int64 v73; // x14
  _QWORD *v74; // x16
  unsigned int v75; // w1
  int *v76; // x2
  __int64 v77; // x3
  unsigned int v78; // w1
  int *v79; // x2
  __int64 v80; // x1
  unsigned int (__fastcall *v81)(long double); // x16
  __int64 v82; // x28
  unsigned int v83; // w21
  const char *v84; // x22
  _BYTE *v85; // x22
  __int64 v86; // x24
  unsigned int v87; // w23
  _BYTE *v88; // x25
  unsigned int v89; // w26
  int v90; // w24
  unsigned __int64 v91; // x26
  __int64 v92; // x25
  int v93; // w12
  const char *v94; // x19
  __int64 v95; // x25
  _BOOL4 v96; // w2
  unsigned __int64 v97; // x9
  _BOOL4 v98; // w8
  int v99; // w11
  _BYTE *v100; // x10
  unsigned __int64 v101; // x26
  bool v102; // cf
  int v103; // w13
  unsigned int v104; // w22
  int v105; // w9
  int v106; // w11
  unsigned __int64 v107; // x10
  char *v108; // x25
  _BYTE *v109; // x8
  size_t v110; // x0
  int v111; // w2
  char *v112; // x22
  __int64 v113; // x1
  __int64 v114; // x19
  int v115; // w0
  bool v116; // cc
  double v117; // d0
  int v118; // w8
  int v119; // w8
  char v120; // w8
  _BYTE *v121; // x13
  int v122; // w12
  unsigned __int64 v123; // x15
  unsigned int v124; // w13
  unsigned int v125; // w10
  int v126; // w12
  unsigned int v127; // w22
  int v128; // w23
  __int64 v129; // x9
  bool v130; // zf
  char v131; // w9
  int v132; // w22
  unsigned int v133; // w24
  unsigned int v134; // w12
  char v135; // w25
  unsigned int v136; // w9
  int v137; // w24
  __int64 v138; // x0
  bool v139; // w19
  __int64 v140; // x0
  unsigned int v141; // w22
  unsigned __int8 *v142; // x22
  unsigned int v143; // w25
  _BYTE *v144; // x26
  int v145; // w23
  unsigned __int8 *v146; // x22
  size_t v148; // x0
  int v149; // w22
  __int64 v150; // x20
  unsigned int (__fastcall *v151)(long double); // x19
  unsigned int v152; // w23
  int v153; // w22
  int v154; // w19
  int v155; // w22
  unsigned int v156; // w24
  unsigned int v157; // w24
  unsigned int v158; // w23
  int v159; // w22
  unsigned int v161; // [xsp+4h] [xbp-19DCh]
  __int64 v162; // [xsp+28h] [xbp-19B8h]
  const char *v163; // [xsp+30h] [xbp-19B0h]
  char format[16]; // [xsp+50h] [xbp-1990h] BYREF
  __int128 v167; // [xsp+60h] [xbp-1980h]
  char v168; // [xsp+78h] [xbp-1968h] BYREF
  _BYTE v169[7]; // [xsp+79h] [xbp-1967h] BYREF
  _BYTE v170[12]; // [xsp+1BCh] [xbp-1824h] BYREF
  _BYTE v171[6136]; // [xsp+1C8h] [xbp-1818h] BYREF

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = -1;
  *(_QWORD *)&a5 = 0x100000LL;
  v10 = *a4;
  v9 = a4[1];
  v11 = a4[2];
  memset(format, 0, sizeof(format));
  v13 = *((_DWORD *)a4 + 6);
  v12 = *((_DWORD *)a4 + 7);
LABEL_2:
  v14 = a3;
  for ( i = (unsigned __int8 *)a3; ; ++i )
  {
LABEL_3:
    while ( *i == 37 )
    {
      v17 = (char *)(i + 1);
      v16 = i[1];
      if ( v16 != 37 )
      {
        if ( v6 == 1 )
        {
          v18 = 0;
          v19 = -1;
          a3 = (char *)(i + 1);
LABEL_20:
          v25 = 0;
          v26 = 0;
          v27 = 0;
          while ( 1 )
          {
            i = (unsigned __int8 *)a3;
            v29 = *a3++;
            v28 = v29;
            switch ( v29 )
            {
              case ' ':
                v25 |= 1u;
                continue;
              case '#':
                v25 |= 8u;
                continue;
              case '*':
                v25 |= 0x4000u;
                v27 = -1;
                if ( v18 )
                {
                  v33 = (unsigned __int8)*a3;
                  if ( (unsigned int)(v33 - 48) > 9 )
                    return 0;
                  v34 = 0;
                  a3 = (char *)(i + 2);
                  do
                  {
                    v35 = v33 + 10 * v34;
                    v36 = (unsigned __int8)*a3++;
                    v33 = v36;
                    v37 = v35 - 48;
                    if ( v34 < 128 )
                      v34 = v37;
                  }
                  while ( (unsigned int)(v33 - 48) < 0xA );
                  if ( !v34 )
                    return 0;
                  if ( v34 > 128 )
                    return 0;
                  if ( v33 != 36 )
                    return 0;
                  v27 = v34 - 1;
                  if ( v34 < 1 )
                    return 0;
                }
                continue;
              case '+':
                v25 |= 2u;
                continue;
              case '-':
                v25 = v25 & 0xFFFFFEFB | 4;
                continue;
              case '.':
                v38 = (unsigned __int8)*a3;
                if ( v38 == 42 )
                {
                  v25 |= 0x10000u;
                  a3 = (char *)(i + 2);
                  if ( v18 )
                  {
                    v39 = (unsigned __int8)*a3;
                    if ( (unsigned int)(v39 - 48) > 9 )
                      return 0;
                    v40 = 0;
                    a3 = (char *)(i + 3);
                    do
                    {
                      v41 = v39 + 10 * v40;
                      v42 = (unsigned __int8)*a3++;
                      v39 = v42;
                      v43 = v41 - 48;
                      if ( v40 < 128 )
                        v40 = v43;
                    }
                    while ( (unsigned int)(v39 - 48) < 0xA );
                    if ( !v40 || v40 > 128 || v39 != 36 || v40 < 1 )
                      return 0;
                    v26 = v40 - 1;
                  }
                  else
                  {
                    v26 = -1;
                  }
                }
                else
                {
                  v44 = 1LL;
                  if ( v38 == 45 )
                    v44 = 2LL;
                  v45 = i[v44];
                  v46 = (char *)(i + 2);
                  if ( v38 == 45 )
                    a3 = v46;
                  if ( (unsigned int)(v45 - 48) <= 9 )
                  {
                    v47 = 0;
                    while ( v47 <= 214748364 )
                    {
                      v48 = v45 + 10 * v47;
                      v49 = (unsigned __int8)*++a3;
                      v45 = v49;
                      v47 = v48 - 48;
                      if ( (unsigned int)(v49 - 48) >= 0xA )
                        goto LABEL_72;
                    }
                    return 0;
                  }
                  v47 = 0;
LABEL_72:
                  v25 |= 0x8000u;
                  if ( v38 == 45 )
                    v26 = -v47;
                  else
                    v26 = v47;
                }
                if ( (~v25 & 0x18000) == 0 )
                  return 0;
                break;
              case '0':
                v25 |= ~(v25 << 6) & 0x100;
                goto LABEL_22;
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
LABEL_22:
                v27 = 0;
                v30 = v28;
                v25 |= 0x2000u;
                do
                {
                  if ( v27 > 214748364 )
                    return 0;
                  v31 = 10 * v27 + v30;
                  v32 = *++i;
                  v30 = v32;
                  v27 = v31 - 48;
                }
                while ( (unsigned int)(v32 - 48) < 0xA );
                a3 = (char *)i;
                continue;
              case 'E':
                v52 = &v17[~(unsigned __int64)v14];
                v25 |= 0x41000u;
                v53 = 9;
                goto LABEL_111;
              case 'G':
                v52 = &v17[~(unsigned __int64)v14];
                v25 |= 0x81000u;
                v53 = 9;
                goto LABEL_111;
              case 'L':
                v25 |= 0x80u;
                continue;
              case 'O':
              case 'z':
                v25 |= 0x20u;
                continue;
              case 'S':
                v53 = 0;
                v52 = &v17[~(unsigned __int64)v14];
                v25 |= 8u;
                goto LABEL_111;
              case 'X':
                v54 = ~(unsigned __int64)v14;
                v55 = 6656;
                goto LABEL_109;
              case 'c':
                v56 = ~(unsigned __int64)v14;
                v25 |= 0x20000u;
                goto LABEL_100;
              case 'd':
              case 'i':
                v52 = &v17[~(unsigned __int64)v14];
                if ( (v25 & 0x40) != 0 )
                {
                  v53 = 5;
                }
                else if ( (v25 & 0x20) != 0 )
                {
                  v53 = 4;
                }
                else
                {
                  v53 = 3;
                }
                goto LABEL_111;
              case 'e':
                v57 = ~(unsigned __int64)v14;
                v25 |= 0x40000u;
                goto LABEL_97;
              case 'f':
                v57 = ~(unsigned __int64)v14;
                goto LABEL_97;
              case 'g':
                v57 = ~(unsigned __int64)v14;
                v25 |= 0x80000u;
LABEL_97:
                v52 = &v17[v57];
                v53 = 9;
                goto LABEL_111;
              case 'h':
                v25 |= 0x10u;
                continue;
              case 'l':
                if ( (v25 & 0x20) != 0 )
                  v25 |= 0x40u;
                else
                  v25 |= 0x20u;
                continue;
              case 'n':
                v52 = &v17[~(unsigned __int64)v14];
                v53 = 2;
                goto LABEL_111;
              case 'o':
                v56 = ~(unsigned __int64)v14;
                v25 |= 0x400u;
LABEL_100:
                v52 = &v17[v56];
                v53 = 3;
                goto LABEL_111;
              case 'p':
                v52 = &v17[~(unsigned __int64)v14];
                v53 = 1;
                goto LABEL_111;
              case 'q':
                v25 |= 0x40u;
                continue;
              case 's':
                v53 = 0;
                v52 = &v17[~(unsigned __int64)v14];
                goto LABEL_111;
              case 'u':
                v52 = &v17[~(unsigned __int64)v14];
                if ( (v25 & 0x20) != 0 )
                  v53 = 7;
                else
                  v53 = 6;
                v130 = (v25 & 0x40) == 0;
                v25 |= 0x200u;
                if ( !v130 )
                  v53 = 8;
                goto LABEL_111;
              case 'x':
                v54 = ~(unsigned __int64)v14;
                v55 = 2560;
LABEL_109:
                v52 = &v17[v54];
                v25 |= v55;
                v53 = 6;
LABEL_111:
                if ( (v25 & 0x4000) == 0 )
                  goto LABEL_122;
                if ( v27 < 0 )
                {
                  v27 = v7++;
                }
                else if ( (((unsigned __int8)format[(unsigned __int64)(unsigned int)v27 >> 3] >> (v27 & 7)) & 1) != 0 )
                {
                  return 0;
                }
                if ( v27 > 127 )
                  return 0;
                v58 = v27 + 7;
                if ( v27 >= v8 )
                  v8 = v27;
                if ( v27 >= 0 )
                  v58 = v27;
                v59 = (__int64)v58 >> 3;
                v60 = format[v59];
                *(_DWORD *)&v170[16 * v27 + 4] = 11;
                format[v59] = v60 | (1 << (v27 & 7));
LABEL_122:
                if ( (v25 & 0x10000) == 0 )
                  goto LABEL_133;
                if ( v26 < 0 )
                {
                  v26 = v7++;
                }
                else if ( (((unsigned __int8)format[(unsigned __int64)(unsigned int)v26 >> 3] >> (v26 & 7)) & 1) != 0 )
                {
                  return 0;
                }
                if ( v26 > 127 )
                  return 0;
                v61 = v26 + 7;
                if ( v26 >= v8 )
                  v8 = v26;
                if ( v26 >= 0 )
                  v61 = v26;
                v62 = (__int64)v61 >> 3;
                v63 = format[v62];
                *(_DWORD *)&v170[16 * v26 + 4] = 12;
                format[v62] = v63 | (1 << (v26 & 7));
LABEL_133:
                if ( v19 >= 0 )
                  v64 = v19;
                else
                  v64 = v7;
                if ( v64 > 127 )
                  return 0;
                v65 = v64 + 7;
                if ( v64 >= 0 )
                  v65 = v64;
                v66 = (__int64)v65 >> 3;
                v67 = format[v66];
                *(_DWORD *)&v170[16 * v64 + 4] = v53;
                format[v66] = v67 | (1 << (v64 & 7));
                if ( v5 > 127 )
                  return 0;
                v68 = v5;
                v7 += (unsigned int)v19 >> 31;
                ++v5;
                v69 = &v171[32 * v68 + 2040];
                if ( v64 >= v8 )
                  v8 = v64;
                *((_DWORD *)v69 + 2) = v25;
                *((_DWORD *)v69 + 3) = v64;
                *(_DWORD *)v69 = v27;
                *((_DWORD *)v69 + 1) = v26;
                *((_QWORD *)v69 + 2) = v14;
                *((_QWORD *)v69 + 3) = v52;
                goto LABEL_2;
              default:
                goto LABEL_3;
            }
          }
        }
        if ( (unsigned int)(v16 - 48) > 9 )
        {
          v24 = (char *)(i + 1);
        }
        else
        {
          v20 = 0;
          a3 = (char *)(i + 2);
          do
          {
            v21 = v16 + 10 * v20;
            v22 = (unsigned __int8)*a3++;
            v16 = v22;
            v23 = v21 - 48;
            if ( v20 < 128 )
              v20 = v23;
          }
          while ( (unsigned int)(v16 - 48) < 0xA );
          v24 = (char *)(i + 1);
          if ( v20 && v20 <= 128 && v16 == 36 )
          {
            if ( v20 > 0 )
            {
              v19 = v20 - 1;
              v6 = 2;
              v18 = 1;
              goto LABEL_20;
            }
            v24 = a3;
            if ( v6 == 2 )
              return 0;
LABEL_19:
            v18 = 0;
            v6 = 1;
            v19 = -1;
            a3 = v24;
            goto LABEL_20;
          }
        }
        if ( v6 == 2 )
          return 0;
        goto LABEL_19;
      }
      if ( &v17[~(unsigned __int64)v14] )
      {
        if ( v5 > 127 )
          return 0;
        v50 = v5++;
        v51 = &v171[32 * v50 + 2040];
        v51[1] = 0x100000LL;
        v51[2] = v14;
        v51[3] = &v17[~(unsigned __int64)v14];
      }
      i += 2;
      v14 = v17;
    }
    if ( !*i )
      break;
  }
  if ( i != (unsigned __int8 *)v14 )
  {
    if ( v5 > 127 )
      return 0;
    v70 = v5++;
    v71 = &v171[32 * v70 + 2040];
    v71[1] = 0x100000LL;
    v71[2] = v14;
    v71[3] = i - (unsigned __int8 *)v14;
  }
  if ( (v8 & 0x80000000) == 0 )
  {
    v72 = 0LL;
    v73 = (unsigned int)(v8 + 1);
    v74 = v171;
    while ( 2 )
    {
      if ( (((unsigned __int8)format[(unsigned int)v72 >> 3] >> (v72 & 7)) & 1) == 0 )
        return 0;
      switch ( *((_DWORD *)v74 - 2) )
      {
        case 0:
        case 1:
        case 2:
        case 4:
        case 5:
        case 7:
        case 8:
          if ( (v13 & 0x80000000) != 0 )
          {
            v75 = v13 + 8;
            if ( v13 <= 0xFFFFFFF8 )
            {
              v76 = v10;
              v10 = (int *)((char *)v9 + (int)v13);
              goto LABEL_150;
            }
          }
          else
          {
            v75 = v13;
          }
          v76 = v10 + 2;
LABEL_150:
          v77 = *(_QWORD *)v10;
          goto LABEL_151;
        case 3:
        case 0xB:
        case 0xC:
          if ( (v13 & 0x80000000) != 0 )
          {
            v75 = v13 + 8;
            if ( v13 <= 0xFFFFFFF8 )
            {
              v76 = v10;
              v77 = *(int *)((char *)v9 + (int)v13);
              goto LABEL_151;
            }
          }
          else
          {
            v75 = v13;
          }
          v77 = *v10;
          v76 = v10 + 2;
          goto LABEL_151;
        case 6:
          if ( (v13 & 0x80000000) != 0 )
          {
            v75 = v13 + 8;
            if ( v13 <= 0xFFFFFFF8 )
            {
              v76 = v10;
              v77 = *(unsigned int *)((char *)v9 + (int)v13);
              goto LABEL_151;
            }
          }
          else
          {
            v75 = v13;
          }
          v77 = (unsigned int)*v10;
          v76 = v10 + 2;
LABEL_151:
          v13 = v75;
          v10 = v76;
          *v74 = v77;
          goto LABEL_152;
        case 9:
          if ( (v12 & 0x80000000) != 0 )
          {
            v78 = v12 + 16;
            if ( v12 <= 0xFFFFFFF0 )
            {
              v79 = v10;
              v10 = (int *)((char *)v11 + (int)v12);
              goto LABEL_173;
            }
          }
          else
          {
            v78 = v12;
          }
          v79 = v10 + 2;
LABEL_173:
          *(_QWORD *)&a5 = *(_QWORD *)v10;
          v12 = v78;
          v10 = v79;
          *v74 = *(_QWORD *)&a5;
LABEL_152:
          ++v72;
          v74 += 2;
          if ( v73 != v72 )
            continue;
          goto LABEL_174;
        default:
          goto LABEL_152;
      }
    }
  }
LABEL_174:
  if ( v5 < 1 )
    return 0;
  v80 = a1;
  v81 = a2;
  v82 = 0LL;
  v83 = 0;
  v84 = "0123456789abcdefghijklmnopqrstuvwxyz";
  v162 = (unsigned int)v5;
  while ( 2 )
  {
    v163 = v84;
    v85 = &v171[32 * v82 + 2040];
    v86 = *((_QWORD *)v85 + 3);
    v87 = *((_DWORD *)v85 + 2);
    if ( v86 )
    {
      v88 = (_BYTE *)*((_QWORD *)v85 + 2);
      v89 = v83 + v86;
      while ( *v88 )
      {
        if ( v81(a5) )
          return v83;
        v80 = a1;
        v81 = a2;
        ++v88;
        ++v83;
        if ( !--v86 )
        {
          v83 = v89;
          break;
        }
      }
      if ( (v87 & 0x100000) != 0 )
      {
        v84 = v163;
LABEL_415:
        if ( ++v82 == v162 )
          return v83;
        continue;
      }
    }
    break;
  }
  v90 = *(_DWORD *)v85;
  if ( (v87 & 0x4000) != 0 )
  {
    v90 = *(_DWORD *)&v170[16 * v90 + 12];
    if ( v90 < 0 )
    {
      if ( v90 == 0x80000000 )
        v90 = 0x7FFFFFFF;
      else
        v90 = -v90;
      v87 = v87 & 0xFFFFFEFB | 4;
    }
  }
  if ( (v87 & 0x10000) != 0 )
  {
    if ( *(int *)&v170[16 * *(int *)&v171[32 * v82 + 2044] + 12] < 0 )
      LODWORD(v91) = -1;
    else
      LODWORD(v91) = *(_DWORD *)&v170[16 * *(int *)&v171[32 * v82 + 2044] + 12];
  }
  else if ( (v87 & 0x8000) != 0 )
  {
    LODWORD(v91) = *(_DWORD *)&v171[32 * v82 + 2044];
  }
  else
  {
    LODWORD(v91) = -1;
  }
  v92 = *(unsigned int *)&v171[32 * v82 + 2052];
  v93 = v87 & 8;
  switch ( *(_DWORD *)&v170[16 * v92 + 4] )
  {
    case 0:
      v108 = *(char **)&v170[16 * v92 + 12];
      if ( v108 )
      {
        if ( (_DWORD)v91 == -1 )
        {
          if ( !*v108 )
          {
            v91 = 0LL;
            goto LABEL_384;
          }
          v148 = strlen(v108);
          v80 = a1;
          v81 = a2;
          v91 = v148;
          v93 = v87 & 8;
        }
        else
        {
          v91 = (int)v91;
        }
        if ( v91 > 0x7FFFFFFE )
        {
          v149 = 0x7FFFFFFF;
          goto LABEL_385;
        }
      }
      else if ( (_DWORD)v91 == -1 || (int)v91 >= 5 )
      {
        v93 = 0;
        LOBYTE(v87) = v87 & 0xF7;
        v91 = 5LL;
        v108 = "(nil)";
      }
      else
      {
        v91 = 0LL;
        v108 = &byte_CC4FFC;
      }
LABEL_384:
      v149 = v91;
LABEL_385:
      v154 = v93;
      if ( !v93 )
        goto LABEL_388;
      if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(34LL, v80, a5) )
        return v83;
      ++v83;
      v93 = v154;
LABEL_388:
      v155 = v90 - v149;
      if ( (v87 & 4) != 0 )
      {
        v80 = a1;
        v81 = a2;
      }
      else
      {
        v80 = a1;
        v81 = a2;
        if ( v155 < 1 )
        {
          --v155;
        }
        else
        {
          v156 = v155 + v83;
          do
          {
            if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(32LL, v80, a5) )
              return v83;
            v80 = a1;
            v81 = a2;
            ++v83;
            --v155;
          }
          while ( v155 > 0 );
          v155 = -1;
          v83 = v156;
          v93 = v154;
        }
      }
      if ( !v91 )
        goto LABEL_403;
      v157 = v83 + v91;
      while ( *v108 )
      {
        if ( ((unsigned int (*)(void))v81)() )
          return v83;
        v80 = a1;
        v81 = a2;
        ++v108;
        ++v83;
        if ( !--v91 )
        {
          v83 = v157;
          break;
        }
      }
      v93 = v154;
LABEL_403:
      if ( (v87 & 4) != 0 && v155 >= 1 )
      {
        v158 = v83 + v155;
        v159 = v155 + 1;
        do
        {
          if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(32LL, v80) )
            return v83;
          v80 = a1;
          v81 = a2;
          ++v83;
          --v159;
        }
        while ( v159 > 1 );
        v83 = v158;
        v93 = v154;
      }
      v84 = v163;
      if ( !v93 )
        goto LABEL_415;
      if ( !((unsigned int (__fastcall *)(__int64, __int64))v81)(34LL, v80) )
      {
        v80 = a1;
        v81 = a2;
        ++v83;
        goto LABEL_415;
      }
      return v83;
    case 1:
      v95 = *(_QWORD *)&v170[16 * v92 + 12];
      if ( v95 )
      {
        v106 = 0;
        v105 = 1;
        if ( (v87 & 0x1000) != 0 )
          v94 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        else
          v94 = "0123456789abcdefghijklmnopqrstuvwxyz";
        v107 = 16LL;
        v98 = 1;
LABEL_264:
        v121 = v170;
        if ( (_DWORD)v91 == -1 )
          v122 = 1;
        else
          v122 = v91;
        v101 = (unsigned __int64)v170;
        if ( v95 )
        {
          do
          {
            LODWORD(v121) = (_DWORD)v121 - 1;
            v116 = v107 > v95;
            v123 = v95 % v107;
            v95 /= v107;
            *(_BYTE *)v101-- = v94[v123];
          }
          while ( !v116 );
        }
        else
        {
          LODWORD(v121) = (unsigned int)v170;
          v101 = (unsigned __int64)v170;
        }
        v124 = (unsigned int)v170 - (_DWORD)v121;
        v96 = 0;
        v125 = v90 - v124;
        v126 = v122 - v124;
        if ( (v106 & v98) == 1 && v126 <= 0 )
        {
          v96 = 0;
          --v125;
          v98 = 1;
          v163 = v94;
          *(_BYTE *)v101-- = 48;
        }
        else
        {
LABEL_304:
          v163 = v94;
          if ( v126 >= 1 )
          {
            v125 -= v126;
            while ( v101 >= (unsigned __int64)&v168 )
            {
              *(_BYTE *)v101-- = 48;
              if ( (unsigned int)v126 < 2 )
                break;
              --v126;
            }
          }
        }
        v135 = v98 & v105;
        if ( (v98 & v105) != 0 )
          v136 = v125 - 2;
        else
          v136 = v125;
        v137 = v136 - ((v96 | (v87 >> 1) | v87) & 1);
        if ( (v87 & 0x104) == 0 )
        {
          if ( v137 < 1 )
          {
            --v137;
          }
          else
          {
            v139 = v96;
            v161 = v137 + v83;
            do
            {
              if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(32LL, v80, a5) )
                return v83;
              v80 = a1;
              v81 = a2;
              ++v83;
              --v137;
            }
            while ( v137 > 0 );
            v137 = -1;
            v83 = v161;
            LOBYTE(v96) = v139;
          }
        }
        if ( v96 )
        {
          v138 = 45LL;
        }
        else if ( (v87 & 2) != 0 )
        {
          v138 = 43LL;
        }
        else
        {
          if ( (v87 & 1) == 0 )
            goto LABEL_326;
          v138 = 32LL;
        }
        if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(v138, v80) )
          return v83;
        v80 = a1;
        v81 = a2;
        ++v83;
LABEL_326:
        if ( (v135 & 1) != 0 )
        {
          if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(48LL, v80) )
            return v83;
          if ( (v87 & 0x1000) != 0 )
            v140 = 88LL;
          else
            v140 = 120LL;
          if ( ((unsigned int (__fastcall *)(__int64, __int64))a2)(v140, a1) )
            return ++v83;
          v80 = a1;
          v81 = a2;
          v83 += 2;
        }
        if ( (v87 & 0x104) == 0x100 )
        {
          if ( v137 < 1 )
          {
            --v137;
          }
          else
          {
            v141 = v83 + v137;
            do
            {
              if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(48LL, v80) )
                return v83;
              v80 = a1;
              v81 = a2;
              ++v83;
              --v137;
            }
            while ( v137 > 0 );
            v137 = -1;
            v83 = v141;
          }
        }
        v142 = (unsigned __int8 *)(v101 + 1);
        if ( v101 + 1 <= (unsigned __int64)v170 )
        {
          v143 = (unsigned int)v170 - v101 + v83;
          v144 = &v170[-v101];
          do
          {
            if ( ((unsigned int (__fastcall *)(_QWORD, __int64))v81)(*v142, v80) )
              return v83;
            v80 = a1;
            v81 = a2;
            ++v83;
            ++v142;
            --v144;
          }
          while ( v144 );
          v83 = v143;
        }
        v84 = v163;
        if ( (v87 & 4) != 0 && v137 >= 1 )
        {
          v127 = v83 + v137;
          v145 = v137 + 1;
          do
          {
            if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(32LL, v80) )
              return v83;
            v80 = a1;
            v81 = a2;
            ++v83;
            --v145;
          }
          while ( v145 > 1 );
LABEL_351:
          v83 = v127;
LABEL_364:
          v84 = v163;
        }
        goto LABEL_415;
      }
      v132 = v90 - 5;
      if ( (v87 & 4) != 0 )
      {
        if ( v90 < 6 )
        {
          v132 = v90 - 6;
        }
        else
        {
          v133 = v132 + v83;
          do
          {
            if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(32LL, v80, a5) )
              return v83;
            v80 = a1;
            v81 = a2;
            ++v83;
            --v132;
          }
          while ( v132 > 0 );
          v132 = -1;
          v83 = v133;
        }
      }
      v150 = v80;
      v151 = v81;
      if ( !((unsigned int (__fastcall *)(__int64, long double))v81)(40LL, a5) )
      {
        if ( ((unsigned int (__fastcall *)(__int64, __int64))v151)(110LL, v150) )
          return ++v83;
        if ( ((unsigned int (__fastcall *)(__int64, __int64))v151)(105LL, v150) )
        {
          v83 += 2;
        }
        else if ( ((unsigned int (__fastcall *)(__int64, __int64))v151)(108LL, v150) )
        {
          v83 += 3;
        }
        else if ( ((unsigned int (__fastcall *)(__int64, __int64))v151)(41LL, v150) )
        {
          v83 += 4;
        }
        else
        {
          v83 += 5;
          if ( (v87 & 4) != 0 )
          {
            v80 = a1;
            v81 = a2;
            goto LABEL_414;
          }
          v80 = a1;
          v81 = a2;
          if ( v132 < 1 )
            goto LABEL_414;
          v152 = v83 + v132;
          v153 = v132 + 1;
          while ( !((unsigned int (__fastcall *)(__int64, __int64))v81)(32LL, v80) )
          {
            v80 = a1;
            v81 = a2;
            ++v83;
            if ( --v153 <= 1 )
            {
              v83 = v152;
              goto LABEL_414;
            }
          }
        }
      }
      return v83;
    case 2:
      v84 = v163;
      v109 = &v170[16 * v92 + 4];
      if ( (v87 & 0x40) != 0 )
      {
        v129 = (int)v83;
LABEL_354:
        **((_QWORD **)v109 + 1) = v129;
        goto LABEL_415;
      }
      if ( (v87 & 0x20) != 0 )
      {
        v129 = (int)v83;
        goto LABEL_354;
      }
      if ( (v87 & 0x10) != 0 )
        **((_WORD **)v109 + 1) = v83;
      else
        **((_DWORD **)v109 + 1) = v83;
      goto LABEL_415;
    case 3:
    case 4:
    case 5:
      goto LABEL_199;
    case 6:
    case 7:
    case 8:
      v87 |= 0x200u;
LABEL_199:
      v94 = v163;
      v95 = *(_QWORD *)&v170[16 * v92 + 12];
      if ( (v87 & 0x20000) != 0 )
      {
        if ( (v87 & 4) == 0 )
        {
          if ( v90 >= 2 )
          {
            v104 = v90 - 1 + v83;
            do
            {
              if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(32LL, v80, a5) )
                return v83;
              v80 = a1;
              v81 = a2;
              ++v83;
              --v90;
            }
            while ( v90 > 1 );
            v90 = 0;
            goto LABEL_277;
          }
          --v90;
        }
        v104 = v83;
LABEL_277:
        if ( ((unsigned int (__fastcall *)(_QWORD, __int64))v81)((unsigned int)v95, v80) )
          return v104;
        v83 = v104 + 1;
        if ( (v87 & 4) == 0 )
        {
          v80 = a1;
          v81 = a2;
          goto LABEL_364;
        }
        v80 = a1;
        v81 = a2;
        if ( v90 < 2 )
          goto LABEL_364;
        v127 = v104 + v90;
        v128 = v90 + 1;
        do
        {
          if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(32LL, v80) )
            return v83;
          v80 = a1;
          v81 = a2;
          ++v83;
          --v128;
        }
        while ( v128 > 2 );
        goto LABEL_351;
      }
      if ( (v87 & 0x400) != 0 )
      {
        v105 = 0;
        v98 = v93 != 0;
        v106 = 1;
        v107 = 8LL;
        goto LABEL_264;
      }
      if ( (v87 & 0x800) == 0 )
      {
        v96 = (v87 & 0x200) == 0 && v95 < 0;
        if ( (v87 & 0x200) == 0 && v95 < 0 )
          v97 = -v95;
        else
          v97 = v95;
        v98 = v93 != 0;
        if ( (_DWORD)v91 == -1 )
          v99 = 1;
        else
          v99 = v91;
        if ( v97 )
        {
          v100 = v170;
          v101 = (unsigned __int64)v170;
          do
          {
            LODWORD(v100) = (_DWORD)v100 - 1;
            v102 = v97 >= 0xA;
            v103 = v97 % 0xA;
            v97 /= 0xAuLL;
            *(_BYTE *)v101-- = v103 | 0x30;
          }
          while ( v102 );
        }
        else
        {
          LODWORD(v100) = (unsigned int)v170;
          v101 = (unsigned __int64)v170;
        }
        v134 = (unsigned int)v170 - (_DWORD)v100;
        v105 = 0;
        v125 = v90 - v134;
        v126 = v99 - v134;
        goto LABEL_304;
      }
      v106 = 0;
      if ( (v87 & 0x1000) != 0 )
        v94 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      else
        v94 = "0123456789abcdefghijklmnopqrstuvwxyz";
      v98 = v93 != 0;
      v105 = 1;
      v107 = 16LL;
      goto LABEL_264;
    case 9:
      *(_OWORD *)format = xmmword_D1C2B0;
      v167 = unk_D1C2C0;
      v110 = __strlen_chk(format, 0x20uLL);
      if ( (v87 & 0x2000) != 0 )
        v90 = *(_DWORD *)v85;
      if ( (v87 & 0x8000) != 0 )
        LODWORD(v91) = *(_DWORD *)&v171[32 * v82 + 2044];
      v112 = &format[1];
      if ( (v87 & 4) != 0 )
      {
        v112 = &format[2];
        format[1] = 45;
        if ( (v87 & 2) == 0 )
        {
LABEL_237:
          if ( (v87 & 1) == 0 )
            goto LABEL_238;
          goto LABEL_289;
        }
      }
      else if ( (v87 & 2) == 0 )
      {
        goto LABEL_237;
      }
      *v112++ = 43;
      if ( (v87 & 1) == 0 )
      {
LABEL_238:
        v113 = 32 - v110;
        if ( (v87 & 8) == 0 )
          goto LABEL_239;
        goto LABEL_290;
      }
LABEL_289:
      *v112++ = 32;
      v113 = 32 - v110;
      if ( (v87 & 8) == 0 )
      {
LABEL_239:
        *v112 = 0;
        if ( v90 < 0 )
          goto LABEL_243;
        goto LABEL_240;
      }
LABEL_290:
      *v112++ = 35;
      *v112 = 0;
      if ( v90 < 0 )
        goto LABEL_243;
LABEL_240:
      if ( (unsigned int)v90 >= 0x145 )
        v90 = 325;
      v114 = v113;
      v115 = sub_63209BC(v112, v113, "%d", v90);
      v112 += v115;
      v113 = v114 - v115;
LABEL_243:
      if ( (v91 & 0x80000000) == 0 )
      {
        v116 = (int)v91 > v90 || v90 < 1;
        v117 = *(double *)&v170[16 * v92 + 12];
        v118 = 324 - v90;
        if ( v116 )
          v118 = 324;
        for ( ; v117 >= 10.0; --v118 )
          v117 = v117 / 10.0;
        if ( (int)v91 <= v118 )
          v119 = v91;
        else
          v119 = v118 - 1;
        v112 += (int)sub_63209BC(v112, v113, ".%d", v119 & (unsigned int)~(v119 >> 31));
      }
      if ( (v87 & 0x20) != 0 )
        *v112++ = 108;
      if ( (v87 & 0x40000) != 0 )
      {
        v130 = (v87 & 0x1000) == 0;
        v120 = 69;
        v131 = 101;
      }
      else
      {
        if ( (v87 & 0x80000) == 0 )
        {
          v120 = 102;
          goto LABEL_358;
        }
        v120 = 71;
        v131 = 103;
        v130 = (v87 & 0x1000) == 0;
      }
      if ( v130 )
        v120 = v131;
LABEL_358:
      *v112 = v120;
      v112[1] = 0;
      sub_6320DD8((int)&v168, v113, v111, format);
      if ( v168 )
      {
        v81 = a2;
        v146 = v169;
        do
        {
          if ( ((unsigned int (*)(void))v81)() )
            return v83;
          v80 = a1;
          v81 = a2;
          ++v83;
        }
        while ( *v146++ );
      }
      else
      {
        v80 = a1;
        v81 = a2;
      }
      goto LABEL_364;
    default:
LABEL_414:
      v84 = v163;
      goto LABEL_415;
  }
}


================================================================================
Function: sub_63209BC (0x63209BC)
================================================================================

__int64 sub_63209BC(_BYTE *a1, __int64 a2, const char *a3, ...)
{
  __int64 result; // x0
  gcc_va_list va; // [xsp+B0h] [xbp-60h] BYREF
  gcc_va_list va1; // [xsp+D0h] [xbp-40h] BYREF
  _BYTE *v6; // [xsp+F0h] [xbp-20h] BYREF
  __int64 v7; // [xsp+F8h] [xbp-18h]
  __int64 v8; // [xsp+100h] [xbp-10h]

  va_start(va, a3);
  v8 = a2;
  v6 = a1;
  v7 = 0LL;
  va_copy(va1, va);
  result = sub_631F6E8(&v6, sub_6320984, a3, va1);
  if ( v8 )
  {
    if ( v8 == v7 )
    {
      result = (unsigned int)(result - 1);
      *(v6 - 1) = 0;
    }
    else
    {
      *v6 = 0;
    }
  }
  return result;
}


================================================================================
Function: sub_6320B9C (0x6320B9C)
================================================================================

char *__fastcall sub_6320B9C(char *a1, long double *a2)
{
  long double v4; // q0
  __int128 v5; // q1
  _OWORD v7[2]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD v8[4]; // [xsp+28h] [xbp-38h] BYREF
  unsigned __int64 *v9; // [xsp+48h] [xbp-18h] BYREF
  char v10; // [xsp+50h] [xbp-10h]

  v9 = v8;
  sub_6304D94(v8, 8000000LL);
  v4 = *a2;
  v5 = *((_OWORD *)a2 + 1);
  v10 = 0;
  *(long double *)v7 = v4;
  v7[1] = v5;
  sub_631F6E8((__int64)&v9, (unsigned int (__fastcall *)(long double))sub_6320B14, a1, (int **)v7, v4);
  if ( v10 )
  {
    sub_6304DA0(v9);
    return 0LL;
  }
  else if ( sub_6305080(v9) )
  {
    return (char *)sub_6305070((__int64)v9);
  }
  else
  {
    return off_6CA6318(&byte_CC4FFC);
  }
}


================================================================================
Function: sub_6320C70 (0x6320C70)
================================================================================

__int64 sub_6320C70(const char *a1, ...)
{
  gcc_va_list va1; // [xsp+C0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-28h] BYREF

  va_start(va, a1);
  va_copy(va1, va);
  return sub_6320B9C(a1, va1);
}


================================================================================
Function: sub_6320D2C (0x6320D2C)
================================================================================

__int64 sub_6320D2C(__int64 a1, char *a2, ...)
{
  gcc_va_list va1; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-28h] BYREF

  va_start(va, a2);
  va_copy(va1, va);
  return sub_631F6E8(
           a1,
           (unsigned int (__fastcall *)(long double))sub_6320D0C,
           a2,
           (int **)va1,
           *(long double *)&va[0].__stack);
}


================================================================================
Function: sub_6320DD8 (0x6320DD8)
================================================================================

__int64 sub_6320DD8(char *a1, __int64 a2, __int64 a3, char *format, ...)
{
  gcc_va_list arg; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, format);
  va_copy(arg, va);
  return vsnprintf(a1, 0x146uLL, format, arg);
}


================================================================================
Function: sub_6320E78 (0x6320E78)
================================================================================

__int64 __fastcall sub_6320E78(__int64 a1, __int64 a2, __int64 a3)
{
  _DWORD *v6; // x0
  __int64 v7; // x19
  __int64 v8; // x0
  char v9; // w8
  _BYTE v11[24]; // [xsp+0h] [xbp-20h] BYREF

  v6 = (_DWORD *)off_6CA6320(1LL, 616LL);
  v7 = (__int64)v6;
  if ( v6 )
  {
    *v6 = 764702;
    sub_630F978((__int64)(v6 + 46), a3);
    sub_630D8F8(v7 + 272, a1, sub_6324484, sub_6324498, sub_63244AC);
    sub_630D8F8(v7 + 320, 23LL, sub_630DE74, sub_630DEAC, nullsub_265);
    if ( (unsigned int)sub_6301A50((_QWORD *)(v7 + 368), (__int64)sub_63335F8, v7, 0LL, a2) )
    {
      sub_630DEE4(v7 + 272, v11);
      while ( 1 )
      {
        v8 = sub_630DEF0(v11);
        if ( !v8 )
          break;
        sub_630DC74(*(_QWORD *)(v8 + 32));
      }
      sub_630DC74(v7 + 272);
      sub_630DC74(v7 + 320);
      sub_630DC74(v7 + 184);
      sub_6301B00(v7 + 368);
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v7);
      return 0LL;
    }
    else
    {
      sub_631CC00(v7 + 16, 0LL);
      sub_631CC00(v7 + 48, 0LL);
      sub_631CC00(v7 + 80, 0LL);
      sub_631CC00(v7 + 112, 0LL);
      v9 = *(_BYTE *)(v7 + 609) | 1;
      *(_DWORD *)(v7 + 600) = 100;
      *(_QWORD *)(v7 + 568) = -1LL;
      *(_BYTE *)(v7 + 609) = v9;
      if ( (sub_632F2EC(v7 + 592, 1LL) & 0x80000000) != 0 )
        *(_QWORD *)(v7 + 592) = -1LL;
    }
  }
  return v7;
}


================================================================================
Function: sub_632105C (0x632105C)
================================================================================

__int64 sub_632105C()
{
  return sub_6320E78(911LL, 97LL, 71LL);
}


================================================================================
Function: sub_63211CC (0x63211CC)
================================================================================

__int64 __fastcall sub_63211CC(__int64 a1)
{
  __int64 v2; // x0
  __int64 v3; // x21
  __int64 v4; // x0
  __int64 v5; // x23
  __int64 v6; // x22
  __int64 v8; // x0
  __int64 v9; // x20
  _DWORD *v10; // x0
  __int64 v11; // x21
  __int64 v12; // x0
  char v13; // w8
  __int64 (__fastcall *v14)(); // x9
  __int64 v15; // x0
  char v16; // w8
  __int64 (__fastcall *v17)(); // x9
  _QWORD v18[3]; // [xsp+0h] [xbp-20h] BYREF

  if ( !a1 || *(_DWORD *)a1 != 764702 )
    return 1LL;
  if ( (*(_BYTE *)(a1 + 609) & 4) != 0 )
    return 8LL;
  *(_DWORD *)a1 = 0;
  v2 = sub_631CEA4(a1 + 112);
  if ( v2 )
  {
    v3 = v2;
    do
    {
      v4 = sub_631CEB4(v3);
      if ( v4 )
      {
        v5 = v4 + 32;
        v6 = v4;
        sub_631CD70(v4 + 32);
        sub_631CC7C(a1 + 48, v6, v5);
      }
      v3 = sub_631CEBC(v3);
    }
    while ( v3 );
  }
  sub_6321A6C(a1);
  v8 = sub_631CEA4(a1 + 48);
  if ( v8 )
  {
    v9 = v8;
    do
    {
      v10 = (_DWORD *)sub_631CEB4(v9);
      if ( !v10 )
        return 1LL;
      v11 = (__int64)v10;
      if ( *v10 != -1059136595 )
        return 1LL;
      v9 = sub_631CEBC(v9);
      if ( (*(_BYTE *)(v11 + 4693) & 4) == 0 && *(_QWORD *)(v11 + 24) )
        sub_6321780(v11, 0LL, 1LL);
      if ( *(_DWORD *)(v11 + 200) == 1 )
      {
        sub_630F994(v11, *(_QWORD *)(v11 + 192));
        *(_QWORD *)(v11 + 192) = 0LL;
        *(_DWORD *)(v11 + 200) = 0;
      }
      *(_QWORD *)(v11 + 208) = 0LL;
    }
    while ( v9 );
  }
  sub_6301B00(a1 + 368);
  sub_630DEE4(a1 + 272, v18);
  while ( 1 )
  {
    v12 = sub_630DEF0((__int64)v18);
    if ( !v12 )
      break;
    sub_630DC74(*(unsigned __int64 **)(v12 + 32));
  }
  sub_630DC74((unsigned __int64 *)(a1 + 272));
  sub_630DC74((unsigned __int64 *)(a1 + 320));
  sub_630DC74((unsigned __int64 *)(a1 + 184));
  close(*(_DWORD *)(a1 + 592));
  close(*(_DWORD *)(a1 + 596));
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 240));
  v13 = *(_BYTE *)(a1 + 609);
  *(_QWORD *)(a1 + 240) = 0LL;
  *(_QWORD *)(a1 + 248) = 0LL;
  v14 = off_6CA6308[0];
  v15 = *(_QWORD *)(a1 + 256);
  *(_BYTE *)(a1 + 609) = v13 & 0xDF;
  ((void (__fastcall *)(__int64))v14)(v15);
  v16 = *(_BYTE *)(a1 + 609);
  v17 = off_6CA6308[0];
  *(_QWORD *)(a1 + 256) = 0LL;
  *(_QWORD *)(a1 + 264) = 0LL;
  *(_BYTE *)(a1 + 609) = v16 & 0xBF;
  ((void (__fastcall *)(__int64))v17)(a1);
  return 0LL;
}


================================================================================
Function: sub_63213F4 (0x63213F4)
================================================================================

__int64 __fastcall sub_63213F4(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v6; // x1
  _QWORD v8[2]; // [xsp+8h] [xbp-18h] BYREF

  v8[0] = sub_63315AC();
  v8[1] = v6;
  return sub_6323F4C(a1, v8, a2, a3);
}


================================================================================
Function: sub_6321468 (0x6321468)
================================================================================

__int64 __fastcall sub_6321468(__int64 a1)
{
  __int64 v2; // x20
  __int64 v3; // x8
  __int64 result; // x0
  char v5; // w8
  __int128 v6; // q0
  __int64 (__fastcall *v7)(__int64, __int64, __int64); // x9
  __int64 v8; // x2
  int v9; // w0
  char v10; // w8
  __int64 v11; // [xsp+0h] [xbp-20h] BYREF
  __int128 v12; // [xsp+8h] [xbp-18h] BYREF

  if ( !*(_QWORD *)(a1 + 552) || (*(_BYTE *)(a1 + 609) & 0x10) != 0 )
    return 0LL;
  sub_6323E80(a1, &v12, &v11);
  v2 = v11;
  v3 = *(_QWORD *)(a1 + 568);
  if ( v11 < 0 )
  {
    if ( v3 < 0 )
      return 0LL;
    v2 = -1LL;
    v11 = -1LL;
LABEL_9:
    v5 = *(_BYTE *)(a1 + 609);
    v6 = v12;
    v7 = *(__int64 (__fastcall **)(__int64, __int64, __int64))(a1 + 552);
    *(_QWORD *)(a1 + 568) = v2;
    v8 = *(_QWORD *)(a1 + 560);
    *(_OWORD *)(a1 + 576) = v6;
    *(_BYTE *)(a1 + 609) = v5 | 4;
    v9 = v7(a1, v2, v8);
    v10 = *(_BYTE *)(a1 + 609) & 0xFB;
    *(_BYTE *)(a1 + 609) = v10;
    if ( v9 == -1 )
    {
      result = 11LL;
      *(_BYTE *)(a1 + 609) = v10 | 0x10;
      return result;
    }
    return 0LL;
  }
  if ( v3 < 0 )
    goto LABEL_9;
  result = sub_6331730(*(_QWORD *)(a1 + 576), *(_QWORD *)(a1 + 584), v12, *((_QWORD *)&v12 + 1));
  if ( result )
    goto LABEL_9;
  return result;
}


================================================================================
Function: sub_6321560 (0x6321560)
================================================================================

__int64 __fastcall sub_6321560(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  __int64 result; // x0
  unsigned int v6; // w21
  __int64 v7; // x0
  char v8; // w21
  __int64 v9; // x1
  __int64 v10; // x0
  __int64 v11; // x22
  __int64 v12; // [xsp+0h] [xbp-10h] BYREF

  if ( !a1 || *(_DWORD *)a1 != 764702 )
    return 1LL;
  if ( !a2 || *(_DWORD *)a2 != -1059136595 || !*(_DWORD *)(a1 + 4) )
    return 2LL;
  v4 = *(_QWORD *)(a2 + 208);
  if ( !v4 )
    return 0LL;
  if ( v4 != a1 )
    return 2LL;
  if ( (*(_BYTE *)(a1 + 609) & 4) != 0 )
    return 8LL;
  v6 = *(_DWORD *)(a2 + 96);
  if ( v6 <= 0xF )
    --*(_DWORD *)(a1 + 8);
  v7 = *(_QWORD *)(a2 + 24);
  if ( v7 )
  {
    if ( v6 - 10 > 5 || (sub_62FF9F0(v7, 2), *(_QWORD *)(a2 + 24)) )
      sub_6321780(a2, *(unsigned int *)(a2 + 100), v6 < 0x10);
  }
  v8 = sub_63218F4(a2);
  sub_631CD70(a2 + 32);
  if ( *(_DWORD *)(a2 + 200) == 1 )
  {
    *(_QWORD *)(a2 + 192) = 0LL;
    *(_DWORD *)(a2 + 200) = 0;
  }
  *(_DWORD *)(a2 + 96) = 16;
  sub_6321998(a1, a2);
  sub_6321A20(a2);
  if ( *(_BYTE *)(a2 + 2457) && !*(_QWORD *)(a2 + 216) && (unsigned int)sub_62FF994(a2, &v12) != -1 && v12 )
    sub_63022C0(a2, v12, 1LL);
  v9 = *(_QWORD *)(a2 + 2912);
  if ( v9 != -1 )
    sub_63035C4(a2, v9, sub_6321A58, 0LL);
  v10 = sub_631CEA4(a1 + 16);
  if ( v10 )
  {
    v11 = v10;
    while ( *(_QWORD *)(sub_631CEB4(v11) + 40) != a2 )
    {
      v11 = sub_631CEBC(v11);
      if ( !v11 )
        goto LABEL_34;
    }
    sub_631CD70(v11);
  }
LABEL_34:
  *(_QWORD *)(a2 + 208) = 0LL;
  *(_QWORD *)(a2 + 16) = -1LL;
  --*(_DWORD *)(a1 + 4);
  sub_6321A6C(a1);
  if ( (v8 & 1) == 0 )
    return 0LL;
  result = sub_6321468(a1);
  if ( !(_DWORD)result )
    return 0LL;
  return result;
}


================================================================================
Function: sub_6321780 (0x6321780)
================================================================================

__int64 __fastcall sub_6321780(__int64 a1, unsigned int a2, char a3)
{
  unsigned int v3; // w22
  char v4; // w8
  __int64 v5; // x24
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(__int64, _QWORD, _QWORD); // x8
  bool v11; // zf
  unsigned int v12; // w20
  unsigned int v13; // w0
  bool v14; // zf
  __int64 v15; // x1
  int v17; // [xsp+4h] [xbp-Ch] BYREF

  v3 = 0;
  v4 = *(_BYTE *)(a1 + 4693);
  v17 = 0;
  v5 = *(_QWORD *)(a1 + 24);
  if ( (v4 & 4) == 0 )
  {
    sub_63039C8();
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 424));
    v9 = off_6CA6308[0];
    *(_QWORD *)(a1 + 424) = 0LL;
    ((void (__fastcall *)(_QWORD))v9)(*(_QWORD *)(a1 + 416));
    *(_QWORD *)(a1 + 416) = 0LL;
    if ( a2 <= 0x2A && ((1LL << a2) & 0x40004800000LL) != 0 )
      a3 = 1;
    v10 = *(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(v5 + 928) + 24LL);
    if ( v10 )
      a2 = v10(a1, a2, a3 & 1);
    v3 = 42;
    if ( a2 != 42 )
    {
      if ( (unsigned int)sub_63253CC(a1) )
        v11 = a2 == 0;
      else
        v11 = 0;
      if ( v11 )
        v3 = 42;
      else
        v3 = a2;
    }
    v12 = a3 & 1;
    v13 = sub_6332C04(a1, v12);
    if ( v3 )
      v14 = 1;
    else
      v14 = v13 == 0;
    if ( !v14 )
      v3 = v13;
    sub_62FF078(a1, v12);
    sub_6321A6C(*(_QWORD *)(a1 + 208));
    if ( !v3 )
      v3 = sub_6326418(a1 + 232, a1, v12);
    v15 = *(_QWORD *)(a1 + 24);
    LOBYTE(v17) = v12;
    sub_6303740(a1, v15, sub_6324588, &v17);
  }
  return v3;
}


================================================================================
Function: sub_63218F4 (0x63218F4)
================================================================================

__int64 __fastcall sub_63218F4(__int64 a1)
{
  __int64 v1; // x2
  unsigned int v3; // w0
  __int64 v4; // x3
  __int64 v5; // x4
  __int64 v6; // x5
  __int64 v7; // x6
  __int64 v8; // x7
  __int64 v9; // x8
  __int64 result; // x0
  __int64 vars0; // [xsp+0h] [xbp+0h]

  v1 = *(_QWORD *)(a1 + 208);
  if ( !v1 || !*(_QWORD *)(a1 + 3280) && !*(_DWORD *)(a1 + 3288) )
    return 0LL;
  v3 = sub_6330EFC(*(_QWORD *)(v1 + 232), a1 + 3296, v1 + 232);
  if ( v3 )
  {
    if ( (*(_DWORD *)(a1 + 2458) & 0x100000) != 0 )
    {
      v9 = *(_QWORD *)(a1 + 4576);
      if ( !v9 || *(int *)(v9 + 8) >= 1 )
        sub_62FB210(a1, "Internal error clearing splay node = %d", v3, v4, v5, v6, v7, v8, vars0);
    }
  }
  sub_631CDEC(a1 + 3352, 0LL);
  result = 1LL;
  *(_QWORD *)(a1 + 3280) = 0LL;
  *(_DWORD *)(a1 + 3288) = 0;
  return result;
}


================================================================================
Function: sub_6321998 (0x6321998)
================================================================================

long double __fastcall sub_6321998(__int64 a1, __int64 a2)
{
  long double result; // q0
  __int128 v5; // q1
  _OWORD v6[2]; // [xsp+8h] [xbp-28h] BYREF

  sub_6321B8C(a2, v6);
  if ( !(unsigned int)sub_632347C(a1, a2, v6, (unsigned int *)(a2 + 160)) )
  {
    result = *(long double *)v6;
    v5 = v6[1];
    *(_OWORD *)(a2 + 160) = v6[0];
    *(_OWORD *)(a2 + 176) = v5;
  }
  return result;
}


================================================================================
Function: sub_6321A20 (0x6321A20)
================================================================================

__int64 __fastcall sub_6321A20(__int64 a1)
{
  __int64 result; // x0

  result = *(_QWORD *)(a1 + 24);
  if ( result )
  {
    sub_62FEDC0(result, a1);
    result = sub_631CD70(a1 + 64);
  }
  *(_QWORD *)(a1 + 24) = 0LL;
  return result;
}


================================================================================
Function: sub_6321A6C (0x6321A6C)
================================================================================

__int64 __fastcall sub_6321A6C(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x0
  __int64 **v4; // x21
  __int64 v5; // x19
  __int64 v6; // x1
  _QWORD v7[2]; // [xsp+8h] [xbp-18h] BYREF

  result = sub_631CEA4(a1 + 80);
  if ( result )
  {
    v3 = sub_631CEB4(result);
    v4 = (__int64 **)(v3 + 32);
    v5 = v3;
    sub_631CD70(v3 + 32);
    sub_631CC7C((__int64 *)(a1 + 48), (__int64 *)v5, v4);
    if ( *(_DWORD *)(v5 + 96) != 3 )
    {
      *(_DWORD *)(v5 + 96) = 3;
      sub_6331E5C(v5);
    }
    v7[0] = sub_63315AC();
    v7[1] = v6;
    return sub_6323F4C(v5, v7, 0LL, 8LL);
  }
  return result;
}


================================================================================
Function: sub_6321B34 (0x6321B34)
================================================================================

__int64 __fastcall sub_6321B34(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  void (__fastcall *v5)(__int64, __int64); // x8

  *(_QWORD *)(a1 + 24) = a2;
  sub_631CC7C(a2 + 968, a1, a1 + 64);
  v4 = *(_QWORD *)(a2 + 928);
  if ( v4 )
  {
    v5 = *(void (__fastcall **)(__int64, __int64))(v4 + 128);
    if ( v5 )
      v5(a1, a2);
  }
  return sub_62FED18(a2, a1);
}


================================================================================
Function: sub_6321B8C (0x6321B8C)
================================================================================

__int64 __fastcall sub_6321B8C(
        size_t a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 result; // x0
  __int64 (__fastcall *v12)(); // x2
  __int64 v13; // x2
  __int64 v14; // x3
  __int64 v15; // x4
  __int64 v16; // x5
  __int64 v17; // x6
  __int64 v18; // x7
  __int64 v19; // x8

  result = sub_62FF2DC();
  if ( *(_QWORD *)(a1 + 24) )
  {
    v12 = sub_632471C;
    switch ( *(_DWORD *)(a1 + 96) )
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
        return result;
      case 4:
        return sub_62FF3C8(a1, a2, sub_630FF60);
      case 5:
      case 6:
        goto LABEL_9;
      case 7:
      case 8:
        v12 = sub_6324764;
        goto LABEL_9;
      case 9:
      case 0xA:
        v12 = sub_63247CC;
        goto LABEL_9;
      case 0xB:
        v12 = sub_632480C;
        goto LABEL_9;
      case 0xC:
      case 0xD:
        v12 = sub_632484C;
LABEL_9:
        sub_62FF3C8(a1, a2, v12);
        result = sub_62FEA58(a1, a2);
        if ( !*(_DWORD *)(a2 + 20) && (*(_BYTE *)(a1 + 312) & 0x30) == 0 )
        {
          result = sub_62FE844(a1, 0LL);
          if ( (result & 1) != 0 && (*(_DWORD *)(a1 + 2458) & 0x100000) != 0 )
          {
            v19 = *(_QWORD *)(a1 + 4576);
            if ( !v19 || *(int *)(v19 + 8) >= 1 )
              result = sub_62FB210(
                         a1,
                         "WARNING: no socket in pollset, transfer may stall!",
                         v13,
                         v14,
                         v15,
                         v16,
                         v17,
                         v18,
                         a9);
          }
        }
        break;
      default:
        result = sub_62FB0E8(a1, (__int64)"multi_getsock: unexpected multi state %d", (unsigned int)sub_632471C);
        break;
    }
  }
  return result;
}


================================================================================
Function: sub_632347C (0x632347C)
================================================================================

__int64 __fastcall sub_632347C(__int64 a1, __int64 a2, _DWORD *a3, unsigned int *a4)
{
  __int64 v7; // x22
  unsigned __int64 v8; // x8
  __int64 v9; // x23
  unsigned int v10; // w26
  int v11; // w28
  __int64 v12; // x0
  __int64 v13; // x27
  __int64 v14; // x8
  __int64 v15; // x9
  _QWORD *v16; // x0
  int v17; // w8
  char v18; // w8
  unsigned int v19; // w28
  __int64 (__fastcall *v20)(__int64, _QWORD, _QWORD, __int64, _QWORD); // x8
  __int64 v21; // x0
  __int64 v22; // x3
  int v23; // w0
  char v24; // w8
  __int64 v25; // x26
  unsigned int v26; // w23
  _DWORD *v27; // x9
  __int64 v28; // x0
  unsigned __int64 *v29; // x24
  char v30; // w9
  int v31; // w8
  unsigned int *v32; // x1
  __int64 v33; // x2
  __int64 (__fastcall *v34)(__int64, _QWORD, __int64, __int64, unsigned __int64); // x8
  __int64 v35; // x0
  __int64 v36; // x3
  int v37; // w0
  char v38; // w8
  int v39; // w25
  __int64 result; // x0
  __int64 v41; // [xsp+8h] [xbp-18h] BYREF
  int v42; // [xsp+10h] [xbp-10h] BYREF
  unsigned int v43; // [xsp+14h] [xbp-Ch] BYREF

  v7 = a1 + 272;
  LODWORD(v8) = a3[5];
  v41 = a2;
  if ( !(_DWORD)v8 )
  {
LABEL_41:
    if ( a4[5] )
    {
      v25 = 0LL;
      v26 = *a4;
      if ( (_DWORD)v8 )
        goto LABEL_43;
LABEL_46:
      v43 = v26;
      if ( v26 != -1 )
      {
        v28 = sub_630DBCC(v7, &v43, 4LL);
        if ( v28 )
        {
          v29 = (unsigned __int64 *)v28;
          v30 = *((_BYTE *)a4 + v25 + 24);
          v31 = *(_DWORD *)(v28 + 52) - 1;
          *(_DWORD *)(v28 + 52) = v31;
          if ( (v30 & 2) != 0 )
          {
            --*(_DWORD *)(v28 + 68);
            if ( (v30 & 1) == 0 )
            {
LABEL_50:
              if ( v31 )
              {
LABEL_51:
                v32 = (unsigned int *)&v41;
                v33 = 8LL;
                goto LABEL_52;
              }
LABEL_55:
              v34 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, unsigned __int64))(a1 + 152);
              if ( v34 )
              {
                v35 = v41;
                v36 = *(_QWORD *)(a1 + 160);
                *(_BYTE *)(a1 + 609) |= 4u;
                v37 = v34(v35, v26, 4LL, v36, v29[7]);
                v38 = *(_BYTE *)(a1 + 609);
                v39 = v37;
                v43 = v26;
                *(_BYTE *)(a1 + 609) = v38 & 0xFB;
                sub_630DC74(v29);
                sub_630DB18(v7, &v43, 4LL);
                if ( v39 != -1 )
                  goto LABEL_57;
                result = 11LL;
                *(_BYTE *)(a1 + 609) |= 0x10u;
                return result;
              }
              v43 = v26;
              sub_630DC74((unsigned __int64 *)v28);
              v32 = &v43;
              v28 = v7;
              v33 = 4LL;
LABEL_52:
              sub_630DB18(v28, v32, v33);
              goto LABEL_57;
            }
          }
          else if ( (v30 & 1) == 0 )
          {
            goto LABEL_50;
          }
          --*(_DWORD *)(v28 + 64);
          if ( v31 )
            goto LABEL_51;
          goto LABEL_55;
        }
      }
LABEL_57:
      while ( ++v25 < (unsigned __int64)a4[5] )
      {
        LODWORD(v8) = a3[5];
        v26 = a4[v25];
        if ( !(_DWORD)v8 )
          goto LABEL_46;
LABEL_43:
        v8 = (unsigned int)v8;
        v27 = a3;
        while ( v26 != *v27 )
        {
          ++v27;
          if ( !--v8 )
            goto LABEL_46;
        }
      }
    }
    return 0LL;
  }
  v9 = 0LL;
  while ( 1 )
  {
    v11 = *((unsigned __int8 *)a3 + v9 + 24);
    v43 = a3[v9];
    v10 = v43;
    if ( v43 == -1 )
    {
      v42 = -1;
      goto LABEL_13;
    }
    v12 = sub_630DBCC(v7, &v43, 4LL);
    if ( !v12 )
      break;
    v13 = v12;
    v14 = a4[5];
    if ( !(_DWORD)v14 )
      goto LABEL_25;
    v15 = 0LL;
    while ( v10 != a4[v15] )
    {
      if ( v14 == ++v15 )
        goto LABEL_25;
    }
    v17 = *((unsigned __int8 *)a4 + v15 + 24);
    if ( !*((_BYTE *)a4 + v15 + 24) )
      goto LABEL_25;
    if ( v17 != v11 )
    {
      if ( (v17 & 1) != 0 )
      {
        --*(_DWORD *)(v12 + 64);
        if ( (v17 & 2) == 0 )
          goto LABEL_22;
      }
      else if ( (v17 & 2) == 0 )
      {
LABEL_22:
        if ( (v11 & 1) != 0 )
          goto LABEL_39;
LABEL_23:
        if ( (v11 & 2) != 0 )
          goto LABEL_40;
        goto LABEL_24;
      }
      --*(_DWORD *)(v12 + 68);
      if ( (v11 & 1) != 0 )
      {
LABEL_39:
        ++*(_DWORD *)(v12 + 64);
        if ( (v11 & 2) != 0 )
        {
LABEL_40:
          v18 = 0;
          ++*(_DWORD *)(v12 + 68);
          goto LABEL_32;
        }
        goto LABEL_24;
      }
      goto LABEL_23;
    }
LABEL_24:
    v18 = 0;
LABEL_32:
    v19 = (*(_DWORD *)(v13 + 64) != 0) | (2 * (*(_DWORD *)(v13 + 68) != 0));
    if ( (v18 & 1) != 0 || *(_DWORD *)(v13 + 48) != v19 )
    {
      v20 = *(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, __int64, _QWORD))(a1 + 152);
      if ( v20 )
      {
        v21 = v41;
        v22 = *(_QWORD *)(a1 + 160);
        *(_BYTE *)(a1 + 609) |= 4u;
        v23 = v20(v21, v10, v19, v22, *(_QWORD *)(v13 + 56));
        v24 = *(_BYTE *)(a1 + 609) & 0xFB;
        *(_BYTE *)(a1 + 609) = v24;
        if ( v23 == -1 )
        {
          result = 11LL;
          *(_BYTE *)(a1 + 609) = v24 | 0x10;
          return result;
        }
      }
      *(_DWORD *)(v13 + 48) = v19;
    }
    v8 = (unsigned int)a3[5];
    if ( ++v9 >= v8 )
      goto LABEL_41;
  }
  v42 = v10;
  v43 = v10;
  v13 = sub_630DBCC(v7, &v43, 4LL);
  if ( v13 )
    goto LABEL_25;
LABEL_13:
  v16 = (_QWORD *)off_6CA6320(1LL, 72LL);
  if ( !v16 )
    return 3LL;
  v13 = (__int64)v16;
  sub_630D8F8(v16, 13LL, (__int64)sub_632491C, (__int64)sub_632492C, (__int64)nullsub_1367);
  if ( !sub_630DB10(v7, &v42, 4LL, v13) )
  {
    sub_630DC74((unsigned __int64 *)v13);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v13);
    return 3LL;
  }
LABEL_25:
  if ( sub_630DBCC(v13, &v41, 8LL) )
    goto LABEL_31;
  ++*(_DWORD *)(v13 + 52);
  if ( (v11 & 1) != 0 )
    ++*(_DWORD *)(v13 + 64);
  if ( (v11 & 2) != 0 )
    ++*(_DWORD *)(v13 + 68);
  if ( sub_630DB10(v13, &v41, 8LL, v41) )
  {
LABEL_31:
    v18 = 1;
    goto LABEL_32;
  }
  sub_630DC74((unsigned __int64 *)v13);
  return 3LL;
}


================================================================================
Function: sub_63238EC (0x63238EC)
================================================================================

unsigned __int64 *__fastcall sub_63238EC(unsigned __int64 *result, unsigned int a2)
{
  unsigned __int64 *v2; // x21
  unsigned __int64 v3; // x24
  unsigned __int64 *v5; // x22
  __int64 (__fastcall *v6)(unsigned __int64 *, _QWORD, __int64, __int64, unsigned __int64); // x8
  __int64 v7; // x3
  int v8; // w0
  char v9; // w8
  int v10; // w21
  unsigned int v11; // [xsp+4h] [xbp-Ch] BYREF

  if ( result )
  {
    v2 = result;
    v3 = result[26];
    if ( v3 )
    {
      v11 = a2;
      if ( a2 != -1 )
      {
        result = (unsigned __int64 *)sub_630DBCC((__int64 *)(v3 + 272), (__int64)&v11, 4LL);
        if ( result )
        {
          v5 = result;
          v6 = *(__int64 (__fastcall **)(unsigned __int64 *, _QWORD, __int64, __int64, unsigned __int64))(v3 + 152);
          if ( v6 )
          {
            v7 = *(_QWORD *)(v3 + 160);
            *(_BYTE *)(v3 + 609) |= 4u;
            v8 = v6(v2, a2, 4LL, v7, result[7]);
            v9 = *(_BYTE *)(v3 + 609);
            v10 = v8;
            v11 = a2;
            *(_BYTE *)(v3 + 609) = v9 & 0xFB;
            sub_630DC74(v5);
            result = (unsigned __int64 *)sub_630DB18((__int64 *)(v3 + 272), (__int64)&v11, 4LL);
            if ( v10 == -1 )
              *(_BYTE *)(v3 + 609) |= 0x10u;
          }
          else
          {
            v11 = a2;
            sub_630DC74(result);
            return (unsigned __int64 *)sub_630DB18((__int64 *)(v3 + 272), (__int64)&v11, 4LL);
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6323E80 (0x6323E80)
================================================================================

__int64 __fastcall sub_6323E80(__int64 a1, __int64 a2, __int64 *a3)
{
  __time_t v6; // x21
  __int64 v7; // x1
  __int64 v8; // x22
  __int64 v9; // x0
  __int64 v10; // x8
  __int64 result; // x0

  if ( (*(_BYTE *)(a1 + 609) & 0x10) != 0 )
    goto LABEL_10;
  if ( *(_QWORD *)(a1 + 232) )
  {
    v6 = sub_63315AC();
    v8 = v7;
    v9 = sub_6330C24(0LL, 0LL, *(_QWORD *)(a1 + 232));
    *(_QWORD *)(a1 + 232) = v9;
    if ( v9 )
    {
      *(_OWORD *)a2 = *(_OWORD *)(v9 + 32);
      v10 = *(_QWORD *)(a1 + 232);
      if ( !v10 )
        goto LABEL_10;
    }
    else
    {
      *(_QWORD *)a2 = 0LL;
      *(_QWORD *)(a2 + 8) = 0LL;
      v10 = *(_QWORD *)(a1 + 232);
      if ( !v10 )
        goto LABEL_10;
    }
    if ( sub_6331730(*(_QWORD *)(v10 + 32), *(_QWORD *)(v10 + 40), v6, v8) >= 1 )
    {
      result = sub_63316BC(*(_QWORD *)(*(_QWORD *)(a1 + 232) + 32LL), *(_QWORD *)(*(_QWORD *)(a1 + 232) + 40LL), v6, v8);
      goto LABEL_11;
    }
LABEL_10:
    result = 0LL;
    goto LABEL_11;
  }
  result = -1LL;
  *(_QWORD *)a2 = 0LL;
  *(_QWORD *)(a2 + 8) = 0LL;
LABEL_11:
  *a3 = result;
  return result;
}


================================================================================
Function: sub_6323F4C (0x6323F4C)
================================================================================

__int64 __fastcall sub_6323F4C(__int64 result, __int128 *a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // x26
  __int64 v6; // x19
  __int64 v7; // x20
  int v8; // w8
  __int64 v9; // x0
  __int64 v10; // x23
  __int64 *v11; // x27
  __int64 v12; // x8
  __int64 *v13; // x28
  __int64 v14; // x23
  __int64 v15; // x0
  __int64 v16; // x24
  _QWORD *v17; // x25
  __int64 v18; // x0
  __int64 v19; // x22
  unsigned int v20; // w0
  __int64 v21; // x3
  __int64 v22; // x4
  __int64 v23; // x5
  __int64 v24; // x6
  __int64 v25; // x7
  __int64 v26; // x8
  __int64 v27; // x0
  __int64 v28; // x0
  __int128 v29; // [xsp+0h] [xbp-20h]

  v4 = *(_QWORD *)(result + 208);
  if ( v4 )
  {
    v6 = result;
    v29 = *a2;
    v7 = *(_QWORD *)a2 + a3 / 1000;
    *(_QWORD *)&v29 = v7;
    v8 = *((_QWORD *)a2 + 1) + 1000 * (a3 % 1000);
    DWORD2(v29) = v8;
    if ( v8 >= 1000000 )
    {
      *(_QWORD *)&v29 = ++v7;
      DWORD2(v29) = v8 - 1000000;
    }
    v9 = sub_631CEA4(result + 3352);
    if ( v9 )
    {
      v10 = v9;
      while ( *(_DWORD *)(sub_631CEB4(v10) + 48) != a4 )
      {
        v10 = sub_631CEBC(v10);
        if ( !v10 )
          goto LABEL_10;
      }
      sub_631CD70(v10);
    }
LABEL_10:
    v11 = (__int64 *)(v6 + 3280);
    v12 = v6 + 56LL * a4;
    v13 = (__int64 *)(v12 + 3416);
    v14 = v12 + 3384;
    *(_DWORD *)(v12 + 3432) = a4;
    *(_OWORD *)(v12 + 3416) = v29;
    if ( sub_631CEAC(v6 + 3352)
      && (v15 = sub_631CEA4(v6 + 3352)) != 0
      && (v16 = v15,
          v17 = (_QWORD *)(v6 + 56LL * a4 + 3424),
          v18 = sub_631CEB4(v15),
          sub_633164C(*(_QWORD *)(v18 + 32), *(_QWORD *)(v18 + 40), *v13, *v17) <= 0) )
    {
      do
      {
        v19 = v16;
        v28 = sub_631CEBC(v16);
        if ( !v28 )
          break;
        v16 = v28;
        v27 = sub_631CEB4(v28);
      }
      while ( sub_633164C(*(_QWORD *)(v27 + 32), *(_QWORD *)(v27 + 40), *v13, *v17) <= 0 );
    }
    else
    {
      v19 = 0LL;
    }
    sub_631CC0C(v6 + 3352, v19, v14, v14);
    if ( *v11 || *(_DWORD *)(v6 + 3288) )
    {
      result = sub_633164C(v7, SDWORD2(v29), *v11, *(_QWORD *)(v6 + 3288));
      if ( result > 0 )
        return result;
      v20 = sub_6330EFC(*(_QWORD *)(v4 + 232), (_QWORD *)(v6 + 3296), (__int64 *)(v4 + 232));
      if ( v20 )
      {
        if ( (*(_DWORD *)(v6 + 2458) & 0x100000) != 0 )
        {
          v26 = *(_QWORD *)(v6 + 4576);
          if ( !v26 || *(int *)(v26 + 8) >= 1 )
            sub_62FB210(v6, "Internal error removing splay node = %d", v20, v21, v22, v23, v24, v25, v29);
        }
      }
    }
    *(_OWORD *)v11 = v29;
    sub_6330FEC(v6 + 3296, v6);
    result = sub_6330D78(*(_QWORD *)(v6 + 3280), *(_QWORD *)(v6 + 3288), *(_QWORD *)(v4 + 232), v6 + 3296);
    *(_QWORD *)(v4 + 232) = result;
  }
  return result;
}


================================================================================
Function: sub_6324230 (0x6324230)
================================================================================

__int64 __fastcall sub_6324230(__int64 result, char a2)
{
  __int64 v2; // x8
  char v3; // w10

  if ( result )
  {
    v2 = *(_QWORD *)(result + 208);
    if ( v2 )
    {
      if ( (a2 & 1) != 0 )
        v3 = 4;
      else
        v3 = 0;
      *(_BYTE *)(v2 + 609) = *(_BYTE *)(v2 + 609) & 0xFB | v3;
    }
  }
  return result;
}


================================================================================
Function: sub_632425C (0x632425C)
================================================================================

__int64 __fastcall sub_632425C(__int64 result)
{
  __int64 v1; // x8

  if ( result )
  {
    v1 = *(_QWORD *)(result + 208);
    if ( v1 )
      return (*(unsigned __int8 *)(v1 + 609) >> 2) & 1;
    else
      return 0LL;
  }
  return result;
}


================================================================================
Function: sub_63243B4 (0x63243B4)
================================================================================

__int64 __fastcall sub_63243B4(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 v5; // x21
  __int64 result; // x0
  __int64 v7; // x0
  __int64 v8; // x21
  __int64 v9; // x20

  if ( a2 < 0 )
    return 0LL;
  v4 = sub_631CEA4(a1 + 48);
  if ( v4 )
  {
    v5 = v4;
    while ( 1 )
    {
      result = sub_631CEB4(v5);
      if ( *(_QWORD *)(result + 16) == a2 )
        break;
      v5 = sub_631CEBC(v5);
      if ( !v5 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v7 = sub_631CEA4(a1 + 112);
    if ( v7 )
    {
      v8 = v7;
      while ( 1 )
      {
        result = sub_631CEB4(v8);
        if ( *(_QWORD *)(result + 16) == a2 )
          break;
        v8 = sub_631CEBC(v8);
        if ( !v8 )
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      result = sub_631CEA4(a1 + 80);
      if ( result )
      {
        v9 = result;
        do
        {
          result = sub_631CEB4(v9);
          if ( *(_QWORD *)(result + 16) == a2 )
            break;
          result = sub_631CEBC(v9);
          v9 = result;
        }
        while ( result );
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6324958 (0x6324958)
================================================================================

__int64 __fastcall sub_6324958(int a1, int a2)
{
  int v4; // w0

  v4 = fcntl(a1, 3, 0LL);
  if ( v4 < 0 )
    return 0xFFFFFFFFLL;
  if ( (a2 != 0) != ((v4 & 0x800) == 0) )
    return 0LL;
  return fcntl(a1, 4, v4 & 0xFFFFF7FF | ((a2 != 0) << 11));
}


================================================================================
Function: sub_63249D0 (0x63249D0)
================================================================================

__int64 __fastcall sub_63249D0(__int64 a1, _QWORD *a2)
{
  unsigned int v2; // w8
  unsigned int v3; // w21
  int v4; // w28
  signed int v5; // w23
  int v6; // w24
  int v7; // w22
  unsigned __int64 v8; // x20
  unsigned int v9; // t1
  unsigned int v10; // w9
  bool v12; // cf
  unsigned __int64 v14; // x26
  unsigned __int64 v15; // x8
  int v16; // w19
  unsigned int v17; // w8
  unsigned int v18; // w10
  _BYTE *v19; // x11
  int v20; // w9
  unsigned int v21; // w10
  char *v22; // x8
  int v23; // w12
  unsigned int v24; // w11
  int v25; // w13
  int *v26; // x26
  int v27; // w25
  __int64 v28; // x0
  int v29; // w8
  int v30; // w9
  int v31; // w14
  int v32; // w13
  int v33; // w10
  int v34; // w9
  char **v35; // x28
  const char *v36; // x25
  const char *v37; // x25
  int v38; // w9
  int v39; // w9
  const char *v40; // x25
  const char *v41; // x25
  const char *v42; // x25
  const char *v43; // x25
  const char *v44; // x25
  __int64 result; // x0
  __int64 v46; // x28
  int v47; // w8
  int v48; // w10
  int v49; // w9
  __int64 v50; // x9
  int v51; // w10
  unsigned __int64 v52; // [xsp+8h] [xbp-38h]
  int v54; // [xsp+1Ch] [xbp-24h]
  int v55; // [xsp+20h] [xbp-20h]
  _BOOL4 v56; // [xsp+24h] [xbp-1Ch]
  int v57; // [xsp+28h] [xbp-18h]
  int v58; // [xsp+2Ch] [xbp-14h]
  char *endptr; // [xsp+30h] [xbp-10h] BYREF

  v2 = *(unsigned __int8 *)a1;
  if ( !*(_BYTE *)a1 )
  {
    v7 = -1;
    v6 = -1;
    v5 = -1;
    v54 = -1;
    v55 = -1;
    v57 = -1;
    v58 = -1;
LABEL_151:
    v47 = v57;
    result = 0xFFFFFFFFLL;
    if ( v57 == -1 )
      v48 = 0;
    else
      v48 = v55;
    v49 = v54;
    if ( v57 == -1 )
    {
      v47 = 0;
      v49 = 0;
    }
    if ( v6 != -1 && v5 != -1 && v7 > 1582 )
    {
      result = 0xFFFFFFFFLL;
      if ( v6 <= 31 && v5 <= 11 )
      {
        result = 0LL;
        v50 = 60
            * (24
             * (v6
              + 365LL * (v7 - 1970)
              + (int)(((v7 - (unsigned int)(v5 < 2)) >> 2)
                    - (v7 - (unsigned int)(v5 < 2)) / 0x64
                    + (v7 - (unsigned int)(v5 < 2)) / 0x190
                    - 477)
              + dword_16B96E0[v5])
             + v48)
            + v49;
        if ( v58 == -1 )
          v51 = 0;
        else
          v51 = v58;
        *a2 = v51 + (__int64)v47 + 60 * (v50 - 1440);
      }
    }
    return result;
  }
  v3 = 0;
  v4 = -1;
  v5 = -1;
  v58 = -1;
  v6 = -1;
  v7 = -1;
  v8 = a1;
  v56 = 0;
  v57 = -1;
  v52 = a1;
  v54 = -1;
  v55 = -1;
  while ( 2 )
  {
    if ( v2 - 97 >= 0x1A && v2 - 48 >= 0xA && v2 - 65 >= 0x1A )
    {
      do
      {
        v9 = *(unsigned __int8 *)++v8;
        v2 = v9;
        v10 = v9 - 48;
        v12 = v9 - 97 >= 0x1A && v2 != 0 && v10 >= 0xA;
      }
      while ( v12 && v2 - 65 > 0x19 );
    }
    if ( (v2 & 0xDF) - 65 > 0x19 )
    {
      v17 = v2 - 48;
      if ( v17 > 9 )
        goto LABEL_144;
      if ( v57 != -1 )
        goto LABEL_49;
      v18 = *(unsigned __int8 *)(v8 + 1) - 48;
      v19 = (_BYTE *)(v18 >= 0xA ? v8 + 1 : v8 + 2);
      v20 = v18 >= 0xA ? v17 : v18 + 10 * v17;
      if ( v20 > 23 )
        goto LABEL_49;
      if ( *v19 != 58 )
        goto LABEL_49;
      v21 = (unsigned __int8)v19[1] - 48;
      if ( v21 > 9 )
        goto LABEL_49;
      v22 = v19 + 2;
      v23 = (unsigned __int8)v19[2];
      if ( (unsigned int)(v23 - 48) <= 9 )
      {
        v21 = v23 + 10 * v21 - 48;
        if ( v21 > 0x3B )
          goto LABEL_49;
        v22 = v19 + 3;
        v23 = (unsigned __int8)v19[3];
      }
      if ( v23 != 58 || (v24 = (unsigned __int8)v22[1] - 48, v24 > 9) )
      {
        v57 = 0;
        v54 = v21;
        v55 = v20;
        goto LABEL_103;
      }
      v25 = (unsigned __int8)v22[2];
      if ( (unsigned int)(v25 - 48) > 9 )
      {
        v22 += 2;
        goto LABEL_122;
      }
      v24 = v25 + 10 * v24 - 48;
      if ( v24 < 0x3D )
      {
        v22 += 3;
LABEL_122:
        v54 = v21;
        v55 = v20;
        v57 = v24;
        goto LABEL_103;
      }
LABEL_49:
      v26 = (int *)__errno(a1);
      v27 = *v26;
      *v26 = 0;
      v28 = strtol((const char *)v8, &endptr, 10);
      v29 = *v26;
      if ( *v26 != v27 )
        *v26 = v27;
      if ( v29 || (unsigned __int64)(v28 - 0x80000000LL) < 0xFFFFFFFF00000000LL )
        return 0xFFFFFFFFLL;
      a1 = sub_633B058();
      v22 = endptr;
      if ( v58 == -1 )
      {
        v30 = 0;
        v58 = -1;
        if ( v8 > v52 && &endptr[-v8] == &byte_4 && (int)a1 <= 1400 )
        {
          v38 = *(unsigned __int8 *)(v8 - 1);
          if ( v38 == 45 || v38 == 43 )
          {
            if ( v38 == 43 )
              v39 = -60 * ((int)a1 % 100 + 60 * ((int)a1 / 100));
            else
              v39 = 60 * ((int)a1 % 100 + 60 * ((int)a1 / 100));
            v58 = v39;
            v30 = 1;
          }
          else
          {
            v30 = 0;
            v58 = -1;
          }
        }
      }
      else
      {
        v30 = 0;
      }
      if ( &endptr[-v8] == &byte_8 )
      {
        v31 = v56;
        if ( v7 == -1 && v5 == -1 && v6 == -1 )
        {
          v7 = (int)a1 / 10000;
          v5 = ((5243 * ((int)a1 % 10000)) >> 19) + ((unsigned int)(5243 * ((int)a1 % 10000)) >> 31) - 1;
          v30 = 1;
          v6 = (int)a1 % 100;
        }
      }
      else
      {
        v31 = v56;
      }
      if ( (unsigned int)(a1 - 1) >= 0x1F )
        v32 = -1;
      else
        v32 = a1;
      v33 = (v31 == 0) & (unsigned __int8)~(_BYTE)v30 & (v6 == -1) & ((unsigned int)(a1 - 1) < 0x1F);
      if ( ((v31 == 0) & (unsigned __int8)~(_BYTE)v30 & (v6 == -1)) != 0 )
      {
        v31 = 1;
        v6 = v32;
      }
      v34 = v30 | v33;
      if ( v34 != 1 && v31 == 1 && v7 == -1 )
      {
        if ( (int)a1 <= 99 )
        {
          if ( (int)a1 < 71 )
            a1 = (unsigned int)(a1 + 2000);
          else
            a1 = (unsigned int)(a1 + 1900);
        }
        v7 = a1;
        v56 = v6 != -1;
        goto LABEL_103;
      }
      v56 = v31;
      if ( !v34 )
        return 0xFFFFFFFFLL;
LABEL_103:
      v8 = (unsigned __int64)v22;
      goto LABEL_144;
    }
    v14 = 0LL;
    while ( v2 - 97 < 0x1A )
    {
      if ( v14 > 0xB )
        goto LABEL_24;
LABEL_19:
      v15 = v8 + v14++;
      v2 = *(unsigned __int8 *)(v15 + 1);
    }
    if ( (char)v2 >= 65 && v2 <= 0x5A && v14 < 0xC )
      goto LABEL_19;
LABEL_24:
    if ( v14 == 12 )
      return 0xFFFFFFFFLL;
    v16 = v4;
    if ( v4 == -1 )
    {
      v35 = off_6C1F8D8;
      if ( v14 > 3 || (v35 = off_6C1F840, v14 == 3) )
      {
        v36 = *v35;
        if ( strlen(*v35) == v14 )
        {
          a1 = sub_633109C(v8, (unsigned __int64)v36, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 0;
            goto LABEL_143;
          }
        }
        v37 = v35[1];
        if ( strlen(v37) == v14 )
        {
          a1 = sub_633109C(v8, (unsigned __int64)v37, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 1;
            goto LABEL_143;
          }
        }
        v40 = v35[2];
        if ( strlen(v40) == v14 )
        {
          a1 = sub_633109C(v8, (unsigned __int64)v40, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 2;
            goto LABEL_143;
          }
        }
        v41 = v35[3];
        if ( strlen(v41) == v14 )
        {
          a1 = sub_633109C(v8, (unsigned __int64)v41, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 3;
            goto LABEL_143;
          }
        }
        v42 = v35[4];
        if ( strlen(v42) == v14 )
        {
          a1 = sub_633109C(v8, (unsigned __int64)v42, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 4;
            goto LABEL_143;
          }
        }
        v43 = v35[5];
        if ( strlen(v43) == v14 )
        {
          a1 = sub_633109C(v8, (unsigned __int64)v43, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 5;
            goto LABEL_143;
          }
        }
        v44 = v35[6];
        if ( strlen(v44) == v14 )
        {
          a1 = sub_633109C(v8, (unsigned __int64)v44, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 6;
            goto LABEL_143;
          }
        }
      }
    }
    if ( v5 != -1 || v14 != 3 )
      goto LABEL_135;
    a1 = sub_633109C(v8, (unsigned __int64)"Jan", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 0;
      goto LABEL_142;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"Feb", 3LL);
    v4 = v16;
    if ( (_DWORD)a1 )
    {
      v5 = 1;
      goto LABEL_143;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"Mar", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 2;
      goto LABEL_143;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"Apr", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 3;
      goto LABEL_143;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"May", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 4;
      goto LABEL_143;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"Jun", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 5;
      goto LABEL_143;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"Jul", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 6;
      goto LABEL_143;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"Aug", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 7;
      goto LABEL_143;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"Sep", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 8;
      goto LABEL_143;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"Oct", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 9;
      goto LABEL_143;
    }
    a1 = sub_633109C(v8, (unsigned __int64)"Nov", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 10;
LABEL_142:
      v4 = v16;
LABEL_143:
      v8 += v14;
LABEL_144:
      v2 = *(unsigned __int8 *)v8;
      if ( !*(_BYTE *)v8 )
        goto LABEL_151;
      v12 = v3++ >= 5;
      if ( v12 )
        goto LABEL_151;
      continue;
    }
    break;
  }
  a1 = sub_633109C(v8, (unsigned __int64)"Dec", 3LL);
  if ( (_DWORD)a1 )
  {
    v5 = 11;
    goto LABEL_142;
  }
LABEL_135:
  result = 0xFFFFFFFFLL;
  if ( v58 == -1 && v14 <= 4 )
  {
    v46 = 0LL;
    while ( 1 )
    {
      if ( strlen(&byte_16B93A4[v46]) == v14 )
      {
        a1 = sub_633109C(v8, (unsigned __int64)&byte_16B93A4[v46], v14);
        if ( (_DWORD)a1 )
          break;
      }
      v46 += 12LL;
      if ( (_DWORD)v46 == 828 )
        return 0xFFFFFFFFLL;
    }
    v58 = 60 * *(_DWORD *)&byte_16B93A4[v46 + 8];
    goto LABEL_142;
  }
  return result;
}


================================================================================
Function: sub_63252F8 (0x63252F8)
================================================================================

__int64 __fastcall sub_63252F8(__int64 a1)
{
  __int64 v1; // x19
  int v2; // w0
  __int64 v4; // [xsp+0h] [xbp-10h] BYREF

  v1 = -1LL;
  v4 = -1LL;
  v2 = sub_63249D0(a1, &v4);
  if ( v2 == 1 )
    return v4;
  if ( !v2 )
  {
    if ( v4 == -1 )
      return 0LL;
    else
      return v4;
  }
  return v1;
}


================================================================================
Function: sub_6325370 (0x6325370)
================================================================================

__int64 __fastcall sub_6325370(time_t a1, struct tm *a2)
{
  time_t v3; // [xsp+0h] [xbp-10h] BYREF

  v3 = a1;
  if ( gmtime_r(&v3, a2) )
    return 0LL;
  else
    return 43LL;
}


================================================================================
Function: sub_63253CC (0x63253CC)
================================================================================

__int64 __fastcall sub_63253CC(__int64 a1)
{
  unsigned int v2; // w20

  *(_QWORD *)(a1 + 2488) = 0LL;
  v2 = sub_6325420();
  if ( !v2 )
  {
    if ( (*(_BYTE *)(a1 + 2604) & 0x10) == 0 && (*(_BYTE *)(a1 + 2892) & 1) == 0 )
      sub_6320D2C(*(_QWORD *)(a1 + 456), "\n");
    *(_DWORD *)(a1 + 2888) = 0;
  }
  return v2;
}


================================================================================
Function: sub_6325420 (0x6325420)
================================================================================

__int64 __fastcall sub_6325420(size_t a1)
{
  __time_t v2; // x0
  __int64 v3; // x1
  char v4; // w0
  char v5; // w20
  unsigned int v6; // w0
  unsigned int v7; // w21
  __int64 v8; // x20
  int v9; // w9
  __int64 v10; // x2
  __int64 v11; // x8
  __int64 v12; // x10
  __int64 v13; // x11
  __int64 v14; // x8
  __int64 v15; // x9
  __int64 v16; // x10
  __int64 v17; // x11
  __int64 v18; // x9
  __int64 v19; // x21
  __int64 v20; // x23
  unsigned __int64 v21; // x1
  int v22; // w8
  __int64 v23; // x9
  __int64 v24; // x8
  __int64 v25; // x0
  __int64 v26; // x8
  __int64 v27; // x20
  __int64 v28; // x24
  __int64 v30; // [xsp+30h] [xbp-70h]
  char v31[12]; // [xsp+38h] [xbp-68h] BYREF
  char v32[12]; // [xsp+44h] [xbp-5Ch] BYREF
  char v33[12]; // [xsp+50h] [xbp-50h] BYREF
  char v34[10]; // [xsp+5Ch] [xbp-44h] BYREF
  char v35[10]; // [xsp+66h] [xbp-3Ah] BYREF
  char v36[10]; // [xsp+70h] [xbp-30h] BYREF
  char v37[10]; // [xsp+7Ah] [xbp-26h] BYREF
  char v38[10]; // [xsp+84h] [xbp-1Ch] BYREF
  char v39[10]; // [xsp+8Eh] [xbp-12h] BYREF

  v2 = sub_63315AC();
  v4 = sub_6325C10(a1, v2, v3);
  if ( (*(_BYTE *)(a1 + 2604) & 0x10) != 0 )
    return 0;
  v5 = v4;
  if ( *(_QWORD *)(a1 + 608) )
  {
    sub_6324230(a1, 1);
    v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 608))(
           *(_QWORD *)(a1 + 736),
           *(_QWORD *)(a1 + 2544),
           *(_QWORD *)(a1 + 2552),
           *(_QWORD *)(a1 + 2496),
           *(_QWORD *)(a1 + 2504));
  }
  else
  {
    if ( !*(_QWORD *)(a1 + 600) )
      goto LABEL_8;
    sub_6324230(a1, 1);
    v6 = (*(__int64 (__fastcall **)(_QWORD, double, double, double, double))(a1 + 600))(
           *(_QWORD *)(a1 + 736),
           (double)*(__int64 *)(a1 + 2544),
           (double)*(__int64 *)(a1 + 2552),
           (double)*(__int64 *)(a1 + 2496),
           (double)*(__int64 *)(a1 + 2504));
  }
  v7 = v6;
  sub_6324230(a1, 0);
  if ( v7 )
  {
    if ( v7 == 268435457 )
    {
LABEL_8:
      if ( (v5 & 1) != 0 )
      {
        v8 = (unsigned __int128)(*(__int64 *)(a1 + 2608) * (__int128)0x431BDE82D7B634DBLL) >> 64;
        v9 = *(_DWORD *)(a1 + 2604);
        if ( (v9 & 0x80) == 0 )
        {
          v10 = *(_QWORD *)(a1 + 4240);
          if ( v10 )
            sub_6320D2C(*(_QWORD *)(a1 + 456), "** Resuming transfer from byte position %ld\n", v10);
          sub_6320D2C(
            *(_QWORD *)(a1 + 456),
            "  %% Total    %% Received %% Xferd  Average Speed   Time    Time     Time  Current\n"
            "                                 Dload  Upload   Total   Spent    Left  Speed\n");
          v9 = *(_DWORD *)(a1 + 2604) | 0x80;
          *(_DWORD *)(a1 + 2604) = v9;
        }
        if ( (v9 & 0x20) != 0 && (v11 = *(_QWORD *)(a1 + 2512), v11 >= 1) )
        {
          v12 = *(_QWORD *)(a1 + 2496);
          v13 = *(_QWORD *)(a1 + 2504);
          v14 = v12 / v11;
          if ( v12 >= 10001 )
          {
            v12 /= 0x64uLL;
            goto LABEL_22;
          }
          if ( v12 >= 1 )
          {
            v13 *= 100LL;
LABEL_22:
            v30 = v13 / v12;
            if ( (v9 & 0x40) == 0 )
              goto LABEL_30;
            goto LABEL_23;
          }
          v30 = 0LL;
          if ( (v9 & 0x40) == 0 )
            goto LABEL_30;
        }
        else
        {
          v14 = 0LL;
          v30 = 0LL;
          if ( (v9 & 0x40) == 0 )
            goto LABEL_30;
        }
LABEL_23:
        v15 = *(_QWORD *)(a1 + 2560);
        if ( v15 >= 1 )
        {
          v16 = *(_QWORD *)(a1 + 2544);
          v17 = *(_QWORD *)(a1 + 2552);
          v18 = v16 / v15;
          if ( v16 >= 10001 )
          {
            v16 /= 0x64uLL;
LABEL_28:
            v19 = v17 / v16;
LABEL_32:
            if ( v14 <= v18 )
              v20 = v18;
            else
              v20 = v14;
            if ( v20 <= 0 )
              v21 = 0LL;
            else
              v21 = v20 - ((v8 >> 18) + ((unsigned __int64)v8 >> 63));
            sub_6325E30(v33, v21);
            sub_6325E30(v32, v20);
            sub_6325E30(v31, (v8 >> 18) + ((unsigned __int64)v8 >> 63));
            v22 = *(_DWORD *)(a1 + 2604);
            v23 = 2496LL;
            if ( (v22 & 0x20) == 0 )
              v23 = 2504LL;
            if ( (v22 & 0x40) != 0 )
              v24 = 2544LL;
            else
              v24 = 2552LL;
            v25 = *(_QWORD *)(a1 + v24) + *(_QWORD *)(a1 + v23);
            v26 = *(_QWORD *)(a1 + 2504) + *(_QWORD *)(a1 + 2552);
            if ( v25 < 10001 )
            {
              if ( v25 < 1 )
                v27 = 0LL;
              else
                v27 = 100 * v26 / v25;
            }
            else
            {
              v27 = v26 / (__int64)(v25 / 0x64uLL);
            }
            v28 = *(_QWORD *)(a1 + 456);
            ((void (*)(void))sub_6325F24)();
            sub_6325F24(*(_QWORD *)(a1 + 2552), v34);
            sub_6325F24(*(_QWORD *)(a1 + 2504), v35);
            sub_6325F24(*(_QWORD *)(a1 + 2560), v37);
            sub_6325F24(*(_QWORD *)(a1 + 2512), v38);
            sub_6325F24(*(_QWORD *)(a1 + 2592), v39);
            sub_6320D2C(
              v28,
              "\r%3ld %s  %3ld %s  %3ld %s  %s  %s %s %s %s %s",
              v27,
              v36,
              v19,
              v34,
              v30,
              v35,
              v37,
              v38,
              v32,
              v31,
              v33,
              v39);
            fflush(*(FILE **)(a1 + 456));
            return 0;
          }
          if ( v16 >= 1 )
          {
            v17 *= 100LL;
            goto LABEL_28;
          }
LABEL_31:
          v19 = 0LL;
          goto LABEL_32;
        }
LABEL_30:
        v18 = 0LL;
        goto LABEL_31;
      }
      return 0;
    }
    sub_62FB0E8(a1, (__int64)"Callback aborted");
  }
  return v7;
}


================================================================================
Function: sub_6325878 (0x6325878)
================================================================================

__int64 __fastcall sub_6325878(__int64 result, int a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  _QWORD *v5; // x20
  char v6; // w8
  __int64 v7; // x9

  v4 = result;
  switch ( a2 )
  {
    case 1:
      *(_QWORD *)(result + 2712) = a3;
      *(_QWORD *)(result + 2720) = a4;
      return result;
    case 2:
      v6 = *(_BYTE *)(result + 2892);
      *(_QWORD *)(result + 2696) = a3;
      *(_QWORD *)(result + 2704) = a4;
      *(_BYTE *)(result + 2892) = v6 & 0xFD;
      return result;
    case 3:
      result = sub_6331730(a3, a4, *(_QWORD *)(result + 2712), *(_QWORD *)(result + 2720));
      *(_QWORD *)(v4 + 2616) = result;
      return result;
    case 4:
      v5 = (_QWORD *)(result + 2624);
      goto LABEL_13;
    case 5:
      v5 = (_QWORD *)(result + 2632);
      goto LABEL_13;
    case 6:
      v5 = (_QWORD *)(result + 2640);
      goto LABEL_13;
    case 7:
      v5 = (_QWORD *)(result + 2648);
      goto LABEL_13;
    case 8:
      if ( (*(_BYTE *)(result + 2892) & 2) != 0 )
        return result;
      v5 = (_QWORD *)(result + 2664);
      *(_BYTE *)(result + 2892) |= 2u;
LABEL_13:
      result = sub_6331730(a3, a4, *(_QWORD *)(result + 2696), *(_QWORD *)(result + 2704));
      if ( result <= 1 )
        v7 = 1LL;
      else
        v7 = result;
      *v5 += v7;
      return result;
    case 9:
      v5 = (_QWORD *)(result + 2656);
      goto LABEL_13;
    case 10:
      *(_QWORD *)(result + 2728) = a3;
      *(_QWORD *)(result + 2736) = a4;
      return result;
    case 11:
      result = sub_6331730(a3, a4, *(_QWORD *)(result + 2680), *(_QWORD *)(result + 2688));
      *(_QWORD *)(v4 + 2672) = result;
      return result;
    default:
      return result;
  }
}


================================================================================
Function: sub_632599C (0x632599C)
================================================================================

__time_t __fastcall sub_632599C(__int64 a1, unsigned int a2)
{
  __time_t v4; // x21
  __int64 v5; // x1

  v4 = sub_63315AC();
  sub_6325878(a1, a2, v4, v5);
  return v4;
}


================================================================================
Function: sub_6325C08 (0x6325C08)
================================================================================

__int64 __fastcall sub_6325C08(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 2504) = a2;
  return result;
}


================================================================================
Function: sub_6325C10 (0x6325C10)
================================================================================

bool __fastcall sub_6325C10(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x0
  __int64 v7; // x8
  __int64 v8; // x9
  __int64 v9; // x10
  __int64 v10; // x11
  __int64 v11; // x22
  int v12; // w12
  __int64 v13; // x23
  __int64 v14; // x10
  __int64 v15; // x8
  __int64 v16; // x15
  _QWORD *v17; // x25
  unsigned int v18; // w24
  __int64 v19; // x0
  __int64 v20; // x9
  __int64 v21; // x8
  __int64 v22; // x8

  v6 = sub_6331730(a2, a3, *(_QWORD *)(a1 + 2680), *(_QWORD *)(a1 + 2688));
  v7 = *(_QWORD *)(a1 + 2552);
  *(_QWORD *)(a1 + 2608) = v6;
  if ( v6 < 1 )
  {
    v8 = 1000000 * v7;
    v9 = *(_QWORD *)(a1 + 2504);
    v10 = 1000000 * v9;
    *(_QWORD *)(a1 + 2560) = 1000000 * v7;
  }
  else
  {
    if ( v7 >= 0x8637BD05AF6LL )
    {
      if ( (unsigned __int64)v6 <= 0xF423F )
        v8 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v8 = v7 / (v6 / 0xF4240uLL);
    }
    else
    {
      v8 = 1000000 * v7 / v6;
    }
    v9 = *(_QWORD *)(a1 + 2504);
    *(_QWORD *)(a1 + 2560) = v8;
    if ( v9 >= 0x8637BD05AF6LL )
    {
      if ( (unsigned __int64)v6 <= 0xF423F )
        v10 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v10 = v9 / (v6 / 0xF4240uLL);
    }
    else
    {
      v10 = 1000000 * v9 / v6;
    }
  }
  v11 = *(_QWORD *)(a1 + 2488);
  *(_QWORD *)(a1 + 2512) = v10;
  if ( v11 != a2 )
  {
    v12 = *(_DWORD *)(a1 + 2888);
    v13 = a1 + 2488;
    v14 = v9 + v7;
    *(_QWORD *)(a1 + 2488) = a2;
    v15 = a1 + 2488 + 8LL * (v12 % 6);
    v16 = a1 + 2488 + 16LL * (v12 % 6);
    *(_QWORD *)(v15 + 256) = v14;
    *(_QWORD *)(v16 + 304) = a2;
    *(_QWORD *)(v16 + 312) = a3;
    *(_DWORD *)(a1 + 2888) = v12 + 1;
    if ( v12 )
    {
      v17 = (_QWORD *)(v15 + 256);
      if ( v12 <= 4 )
        v18 = 0;
      else
        v18 = (v12 + 1) % 6;
      v19 = sub_633164C(a2, a3, *(_QWORD *)(v13 + 16LL * v18 + 304), *(_QWORD *)(v13 + 16LL * v18 + 312));
      if ( v19 )
        v20 = v19;
      else
        v20 = 1LL;
      v21 = *v17 - *(_QWORD *)(v13 + 8LL * v18 + 256);
      if ( v21 < 4294968 )
        v22 = 1000 * v21 / v20;
      else
        v22 = (__int64)((double)v21 / ((double)v20 / 1000.0));
    }
    else
    {
      v22 = v10 + v8;
    }
    *(_QWORD *)(a1 + 2592) = v22;
  }
  return v11 != a2;
}


================================================================================
Function: sub_6325E30 (0x6325E30)
================================================================================

char *__fastcall sub_6325E30(char *result, unsigned __int64 a2)
{
  unsigned __int64 v2; // x3

  if ( (__int64)a2 <= 0 )
  {
    strcpy(result, "--:--:--");
  }
  else if ( a2 > 0x57E3F )
  {
    v2 = a2 / 0x15180;
    if ( a2 > 0x5265BFF )
      return (char *)sub_63209BC(result, 9LL, "%7ldd", v2);
    else
      return (char *)sub_63209BC(result, 9LL, "%3ldd %02ldh", v2, (__int64)(a2 % 0x15180) / 3600);
  }
  else
  {
    return (char *)sub_63209BC(
                     result,
                     9LL,
                     "%2ld:%02ld:%02ld",
                     a2 / 0xE10,
                     (__int64)(a2 % 0xE10) / 60,
                     (__int64)(a2 % 0xE10) % 60);
  }
  return result;
}


================================================================================
Function: sub_6325F24 (0x6325F24)
================================================================================

_BYTE *__fastcall sub_6325F24(unsigned __int64 a1, _BYTE *a2)
{
  if ( (__int64)a1 > 99999 )
  {
    if ( a1 >> 14 > 0x270 )
    {
      if ( a1 >> 22 > 0x18 )
      {
        if ( a1 >> 24 > 0x270 )
        {
          if ( HIDWORD(a1) > 0x18 )
          {
            if ( a1 >> 34 > 0x270 )
            {
              if ( a1 >> 44 > 0x270 )
                sub_63209BC(a2, 6LL, "%4ldP", a1 >> 50);
              else
                sub_63209BC(a2, 6LL, "%4ldT", a1 >> 40);
            }
            else
            {
              sub_63209BC(a2, 6LL, "%4ldG", a1 >> 30);
            }
          }
          else
          {
            sub_63209BC(
              a2,
              6LL,
              "%2ld.%0ldG",
              a1 >> 30,
              (2684354571u * (unsigned __int64)(((unsigned int)a1 >> 1) & 0x1FFFFFFF)) >> 57);
          }
        }
        else
        {
          sub_63209BC(a2, 6LL, "%4ldM", a1 >> 20);
        }
      }
      else
      {
        sub_63209BC(a2, 6LL, "%2ld.%0ldM", a1 >> 20, (a1 & 0xFFFFF) / 0x19999);
      }
    }
    else
    {
      sub_63209BC(a2, 6LL, "%4ldk", a1 >> 10);
    }
  }
  else
  {
    sub_63209BC(a2, 6LL, "%5ld", a1);
  }
  return a2;
}


================================================================================
Function: sub_6326218 (0x6326218)
================================================================================

__int64 __fastcall sub_6326218(__int64 a1, _BYTE *a2, __int64 a3)
{
  __int64 v4; // x22
  __int64 result; // x0
  unsigned int v7; // [xsp+4h] [xbp-Ch] BYREF

  v4 = a3 - 1;
  if ( a3 == 1 )
  {
LABEL_5:
    result = 0LL;
    *a2 = 0;
  }
  else
  {
    while ( 1 )
    {
      result = sub_633ED08(a1, &v7, 4LL);
      if ( (_DWORD)result )
        break;
      if ( v7 <= 0xFFFFFFFB )
      {
        --v4;
        *a2++ = aAbcdefghijklmn_1[v7 % 0x3E];
        if ( !v4 )
          goto LABEL_5;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_63262FC (0x63262FC)
================================================================================

long double __fastcall sub_63262FC(_OWORD *a1)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}


================================================================================
Function: sub_6326418 (0x6326418)
================================================================================

__int64 __fastcall sub_6326418(__int64 a1, __int64 a2, char a3)
{
  if ( (a3 & 1) == 0 )
    sub_6326454(a2);
  sub_6327910(a2);
  sub_6307508(a2);
  return 0LL;
}


================================================================================
Function: sub_6326454 (0x6326454)
================================================================================

__int64 __fastcall sub_6326454(__int64 a1)
{
  unsigned __int64 v2; // x21
  unsigned __int64 v3; // x10
  int v4; // w8
  int v5; // w8
  int v6; // w10
  __int64 result; // x0
  unsigned __int64 v8; // [xsp+0h] [xbp-20h]
  unsigned __int64 v9; // [xsp+8h] [xbp-18h] BYREF
  __int64 v10; // [xsp+10h] [xbp-10h] BYREF

  if ( !a1 || !*(_QWORD *)(a1 + 24) )
    return 2LL;
  if ( (sub_631B238(a1 + 336) & 1) != 0 )
  {
    if ( (sub_6332C08(a1) & 1) != 0 )
      return sub_62FE6C8();
  }
  else
  {
    do
    {
      if ( (sub_631B758(a1 + 336, &v10, &v9) & 1) == 0 )
        break;
      if ( *(_QWORD *)(a1 + 400) >= v9 )
        v2 = v9;
      else
        v2 = *(_QWORD *)(a1 + 400);
      result = sub_6326A24(a1, v10);
      if ( (_DWORD)result )
        return result;
      ((void (__fastcall *)(__int64))sub_631B7D4)(a1 + 336);
      if ( v2 )
      {
        if ( v2 >= v8 )
          v3 = v8;
        else
          v3 = v2;
        *(_QWORD *)(a1 + 400) -= v3;
      }
    }
    while ( v8 >= v9 );
    if ( (sub_631B238(a1 + 336) & 1) == 0 )
      return 81LL;
  }
  v4 = *(_DWORD *)(a1 + 449);
  if ( (v4 & 0x60) == 0x20 )
  {
    result = sub_6326A24(a1, &v9);
    if ( (_DWORD)result )
      return result;
    v4 = *(_DWORD *)(a1 + 449);
  }
  if ( (v4 & 0x160) != 0x60 )
    return 0LL;
  if ( (v4 & 0x100000) == 0 )
    return sub_6326748(a1);
  LODWORD(result) = sub_63318AC(a1, &v10);
  v5 = result;
  v6 = (_BYTE)v10 ? 0 : 81;
  result = (_DWORD)result ? (unsigned int)result : (unsigned int)v6;
  if ( !v5 && (_BYTE)v10 )
    return sub_6326748(a1);
  return result;
}


================================================================================
Function: sub_63266DC (0x63266DC)
================================================================================

__int64 __fastcall sub_63266DC(__int64 a1, __int64 a2)
{
  __int64 (__fastcall *v4)(); // x8
  char v5; // w8

  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 200));
  v4 = off_6CA6308[0];
  *(_QWORD *)(a1 + 200) = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(*(_QWORD *)(a1 + 192));
  v5 = *(_BYTE *)(a1 + 219);
  *(_QWORD *)(a1 + 192) = 0LL;
  if ( (v5 & 8) != 0 )
    sub_631B174(a1 + 104);
  sub_6327878(a2);
  return sub_6306C24(a2);
}


================================================================================
Function: sub_6326748 (0x6326748)
================================================================================

__int64 __fastcall sub_6326748(__int64 a1)
{
  _DWORD *v1; // x21
  int *v3; // x20
  int v4; // w9
  __int64 v5; // x3
  __int64 v6; // x4
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  __int64 v10; // x2
  __int64 v11; // x8
  const char *v12; // x1
  int v13; // w8
  __int64 v14; // x8
  __int64 v15; // x8
  __int64 v16; // x8
  __int64 v18; // [xsp+0h] [xbp+0h]

  v1 = (_DWORD *)(a1 + 449);
  v3 = (int *)(a1 + 2458);
  v4 = *(_DWORD *)(a1 + 449) | 0x100;
  *(_DWORD *)(a1 + 312) &= 0xFFFFFFBD;
  *(_DWORD *)(a1 + 449) = v4;
  sub_632599C();
  sub_6328778(a1, (*v1 >> 9) & 1);
  if ( (*v1 & 0x200) != 0 )
  {
    sub_631B1DC(a1 + 336);
    v10 = *(_QWORD *)(a1 + 256);
    v13 = *v3;
    if ( v10 )
    {
      if ( (v13 & 0x100000) != 0 )
      {
        v14 = *(_QWORD *)(a1 + 4576);
        if ( !v14 || *(int *)(v14 + 8) >= 1 )
        {
          v12 = "abort upload after having sent %ld bytes";
          goto LABEL_23;
        }
      }
    }
    else if ( (v13 & 0x100000) != 0 )
    {
      v16 = *(_QWORD *)(a1 + 4576);
      if ( !v16 || *(int *)(v16 + 8) >= 1 )
      {
        v12 = "abort upload";
        goto LABEL_23;
      }
    }
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 256);
    if ( v10 )
    {
      if ( (*v3 & 0x100000) != 0 )
      {
        v11 = *(_QWORD *)(a1 + 4576);
        if ( !v11 || *(int *)(v11 + 8) >= 1 )
        {
          v12 = "upload completely sent off: %ld bytes";
LABEL_23:
          sub_62FB210(a1, v12, v10, v5, v6, v7, v8, v9, v18);
        }
      }
    }
    else if ( (*v1 & 8) == 0 && (*v3 & 0x100000) != 0 )
    {
      v15 = *(_QWORD *)(a1 + 4576);
      if ( !v15 || *(int *)(v15 + 8) >= 1 )
      {
        if ( sub_63286A4(a1) )
          v12 = "We are completely uploaded and fine";
        else
          v12 = "Request completely sent off";
        goto LABEL_23;
      }
    }
  }
  return sub_6332CF0(a1);
}


================================================================================
Function: sub_6326A24 (0x6326A24)
================================================================================

__int64 __fastcall sub_6326A24(size_t a1, char *a2, size_t a3, size_t a4, size_t *a5)
{
  signed __int64 v5; // x9
  size_t v10; // x8
  size_t v11; // x23
  __int64 result; // x0
  size_t v13; // x8
  size_t v14; // x3
  size_t v15; // x22

  *a5 = 0LL;
  v5 = *(_QWORD *)(a1 + 816);
  if ( (__int64)(a3 - a4) <= v5 )
    v10 = a3;
  else
    v10 = v5 + a4;
  if ( v5 )
    v11 = v10;
  else
    v11 = a3;
  if ( (*(_BYTE *)(a1 + 449) & 0x20) != 0 && ((sub_631B238(a1 + 336) & 1) != 0 || sub_631B20C(a1 + 336) == v11) )
  {
    result = sub_6332C58(a1, a2, v11, 1LL, a5);
    if ( (_DWORD)result )
      return result;
    v13 = *a5;
    if ( v11 != *a5 )
      goto LABEL_15;
    *(_DWORD *)(a1 + 449) |= 0x40u;
  }
  else
  {
    result = sub_6332C58(a1, a2, v11, 0LL, a5);
    if ( (_DWORD)result )
      return result;
  }
  v13 = *a5;
LABEL_15:
  if ( v13 )
  {
    if ( a4 )
    {
      if ( v13 <= a4 )
        v14 = v13;
      else
        v14 = a4;
      sub_62FAFF4(a1, 2u, a2, v14);
      v13 = *a5;
    }
    v15 = v13 - a4;
    if ( v13 > a4 )
    {
      sub_62FAFF4(a1, 4u, &a2[a4], v13 - a4);
      *(_QWORD *)(a1 + 256) += v15;
      sub_6325C08(a1);
    }
  }
  return 0LL;
}


================================================================================
Function: sub_6327054 (0x6327054)
================================================================================

__int64 __fastcall sub_6327054(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // x21
  __int64 v4; // x20
  __int64 v5; // x23
  __int64 v7; // x8
  _DWORD *v8; // x9
  struct timeval *v9; // x0
  __int64 v10; // x0
  __int16 *v11; // x25
  int v12; // w24
  __int64 v13; // x0
  __int16 v14; // w8
  struct timeval *v15; // x0
  __int64 v16; // x0
  _WORD *v17; // x19
  __int64 v18; // x0
  __int16 v19; // w8
  __int16 v20; // w8
  __int16 v21; // w8
  __int64 v23; // [xsp+0h] [xbp-1A0h] BYREF
  fd_set exceptfds; // [xsp+10h] [xbp-190h] BYREF
  fd_set writefds; // [xsp+90h] [xbp-110h] BYREF
  fd_set readfds; // [xsp+110h] [xbp-90h] BYREF

  v3 = a3;
  if ( a1 && (LODWORD(v4) = a2) != 0 )
  {
    v5 = a2;
    v7 = a2;
    v8 = (_DWORD *)a1;
    while ( *v8 == -1 )
    {
      v8 += 2;
      if ( !--v7 )
        goto LABEL_6;
    }
    v11 = (__int16 *)(a1 + 4);
    v12 = -1;
    memset(&readfds, 0, sizeof(readfds));
    memset(&writefds, 0, sizeof(writefds));
    memset(&exceptfds, 0, sizeof(exceptfds));
    do
    {
      v13 = *((unsigned int *)v11 - 1);
      v11[1] = 0;
      if ( (_DWORD)v13 != -1 )
      {
        if ( (unsigned int)v13 >= 0x400 )
        {
          LODWORD(v3) = -1;
          *(_DWORD *)__errno(v13) = 22;
          return (unsigned int)v3;
        }
        v14 = *v11;
        if ( (*v11 & 0x1C7) != 0 )
        {
          if ( (int)v13 > v12 )
            v12 = v13;
          if ( (v14 & 0x41) != 0 )
          {
            ((void (*)(void))__FD_SET_chk)();
            v14 = *v11;
          }
          if ( (v14 & 0x104) != 0 )
          {
            __FD_SET_chk(*((unsigned int *)v11 - 1), &writefds, 128LL);
            v14 = *v11;
          }
          if ( (v14 & 0x82) != 0 )
            __FD_SET_chk(*((unsigned int *)v11 - 1), &exceptfds, 128LL);
        }
      }
      v11 += 4;
      --v5;
    }
    while ( v5 );
    v15 = (struct timeval *)sub_633155C(&v23, v3);
    v16 = select(v12 + 1, &readfds, &writefds, &exceptfds, v15);
    if ( (int)v16 < 1 )
    {
      LODWORD(v3) = v16;
      if ( (_DWORD)v16 == -1 )
      {
        if ( *(_DWORD *)__errno(v16) == 4 )
          LODWORD(v3) = 0;
        else
          LODWORD(v3) = -1;
      }
    }
    else
    {
      LODWORD(v3) = 0;
      if ( (unsigned int)v4 <= 1 )
        v4 = 1LL;
      else
        v4 = (unsigned int)v4;
      v17 = (_WORD *)(a1 + 6);
      do
      {
        v18 = *(unsigned int *)(v17 - 3);
        *v17 = 0;
        if ( (_DWORD)v18 != -1 )
        {
          if ( (unsigned int)__FD_ISSET_chk(v18, &readfds, 128LL) )
          {
            v19 = *(v17 - 1);
            if ( (v19 & 0x40) != 0 )
              *v17 |= 0x40u;
            if ( (v19 & 1) != 0 )
              *v17 |= 1u;
          }
          if ( (unsigned int)__FD_ISSET_chk(*(unsigned int *)(v17 - 3), &writefds, 128LL) )
          {
            v20 = *(v17 - 1);
            if ( (v20 & 0x100) != 0 )
              *v17 |= 0x100u;
            if ( (v20 & 4) != 0 )
              *v17 |= 4u;
          }
          if ( (unsigned int)__FD_ISSET_chk(*(unsigned int *)(v17 - 3), &exceptfds, 128LL) )
          {
            v21 = *(v17 - 1);
            if ( (v21 & 0x80) != 0 )
              *v17 |= 0x80u;
            if ( (v21 & 2) != 0 )
              *v17 |= 2u;
          }
          if ( *v17 )
            LODWORD(v3) = v3 + 1;
        }
        v17 += 4;
        --v4;
      }
      while ( v4 );
    }
  }
  else
  {
LABEL_6:
    if ( a3 )
    {
      if ( a3 < 0 )
      {
        LODWORD(v3) = -1;
        *(_DWORD *)__errno(a1) = 22;
      }
      else
      {
        v9 = (struct timeval *)sub_633155C(&readfds, a3);
        v10 = select(0, 0LL, 0LL, 0LL, v9);
        LODWORD(v3) = v10;
        if ( (_DWORD)v10 )
        {
          if ( (_DWORD)v10 == -1 && *(_DWORD *)__errno(v10) == 4 )
            LODWORD(v3) = 0;
          else
            LODWORD(v3) = -1;
        }
      }
    }
  }
  return (unsigned int)v3;
}


================================================================================
Function: sub_6327394 (0x6327394)
================================================================================

__int64 __fastcall sub_6327394(__int64 result, __int64 a2, int a3)
{
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = 0LL;
  *(_QWORD *)(result + 16) = 0LL;
  if ( a2 )
  {
    if ( a3 )
    {
      *(_QWORD *)result = a2;
      *(_DWORD *)(result + 12) = a3;
    }
  }
  return result;
}


================================================================================
Function: sub_63273B0 (0x63273B0)
================================================================================

unsigned __int64 __fastcall sub_63273B0(unsigned __int64 result)
{
  _QWORD *v1; // x19

  v1 = (_QWORD *)result;
  if ( (*(_BYTE *)(result + 16) & 1) != 0 )
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)result);
  *v1 = 0LL;
  v1[1] = 0LL;
  v1[2] = 0LL;
  return result;
}


================================================================================
Function: sub_63273F0 (0x63273F0)
================================================================================

__int64 __fastcall sub_63273F0(unsigned __int64 *a1, __int64 a2)
{
  unsigned int v2; // w8
  unsigned __int64 i; // x23
  char *v6; // x21
  char *v7; // x10
  int v8; // w26
  int v9; // w27
  unsigned int v10; // w9
  __int64 v11; // x10
  unsigned int v13; // w10
  unsigned int v14; // w22
  char *v15; // x0
  char v16; // w8

  v2 = *(_DWORD *)(a2 + 20);
  if ( v2 )
  {
    for ( i = 0LL; i < v2; ++i )
    {
      v8 = *(_BYTE *)(a2 + i + 24) & 1 | (4 * ((*(unsigned __int8 *)(a2 + i + 24) >> 1) & 1));
      if ( v8 )
      {
        v9 = *(_DWORD *)(a2 + 4 * i);
        v10 = *((_DWORD *)a1 + 2);
        if ( (v10 & 0x80000000) == 0 )
        {
          v11 = *((unsigned int *)a1 + 2);
          while ( v11-- >= 1 )
          {
            if ( *(_DWORD *)(*a1 + 8LL * (unsigned int)v11) == v9 )
            {
              *(_WORD *)(*a1 + 8LL * (unsigned int)v11 + 4) |= v8;
              goto LABEL_5;
            }
          }
        }
        v13 = *((_DWORD *)a1 + 3);
        if ( v10 < v13 )
        {
          v6 = (char *)*a1;
        }
        else
        {
          v14 = v13 + 100;
          v15 = (char *)off_6CA6320(v13 + 100, 8LL);
          if ( !v15 )
            return 27LL;
          v6 = v15;
          memcpy(v15, (const void *)*a1, 8LL * *((unsigned int *)a1 + 3));
          v16 = *((_BYTE *)a1 + 16);
          if ( (v16 & 1) != 0 )
          {
            ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*a1);
            v16 = *((_BYTE *)a1 + 16);
          }
          v10 = *((_DWORD *)a1 + 2);
          *a1 = (unsigned __int64)v6;
          *((_DWORD *)a1 + 3) = v14;
          *((_BYTE *)a1 + 16) = v16 | 1;
          v2 = *(_DWORD *)(a2 + 20);
        }
        v7 = &v6[8 * v10];
        *(_DWORD *)v7 = v9;
        *((_WORD *)v7 + 2) = v8;
        *((_DWORD *)a1 + 2) = v10 + 1;
      }
LABEL_5:
      ;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_6327878 (0x6327878)
================================================================================

unsigned __int64 __fastcall sub_6327878(unsigned __int64 result)
{
  unsigned __int64 v1; // x19
  _QWORD *i; // x20
  void (__fastcall *v3)(unsigned __int64, _QWORD *); // x8
  __int64 v4; // x1
  void (__fastcall *v5)(unsigned __int64, __int64); // x8
  _QWORD *v6; // x20

  v1 = result;
  for ( i = *(_QWORD **)(result + 328); i; i = *(_QWORD **)(v1 + 328) )
  {
    v3 = *(void (__fastcall **)(unsigned __int64, _QWORD *))(*i + 24LL);
    *(_QWORD *)(v1 + 328) = i[1];
    v3(v1, i);
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)i);
  }
  while ( 1 )
  {
    v6 = *(_QWORD **)(v1 + 320);
    if ( !v6 )
      break;
    v4 = *(_QWORD *)(v1 + 320);
    v5 = *(void (__fastcall **)(unsigned __int64, __int64))(*v6 + 32LL);
    *(_QWORD *)(v1 + 320) = v6[1];
    v5(v1, v4);
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v6);
  }
  *(_QWORD *)(v1 + 248) = 0LL;
  *(_DWORD *)(v1 + 292) = 0;
  return result;
}


================================================================================
Function: sub_6327910 (0x6327910)
================================================================================

__int64 __fastcall sub_6327910(__int64 result)
{
  __int64 v1; // x19
  int v2; // w8
  __int64 v3; // x8
  _QWORD *i; // x20
  void (__fastcall *v5)(__int64, _QWORD *); // x8
  __int64 v6; // x8
  _QWORD *j; // x20
  void (__fastcall *v8)(__int64, _QWORD *); // x8

  v1 = result;
  v2 = *(_DWORD *)(result + 2458);
  if ( (*(_BYTE *)(result + 449) & 0x80) != 0 )
  {
    if ( (v2 & 0x100000) == 0 )
      goto LABEL_15;
    v6 = *(_QWORD *)(result + 4576);
    if ( v6 )
    {
      if ( *(int *)(v6 + 8) < 1 || dword_6CA6330 <= 0 )
        goto LABEL_15;
    }
    else if ( dword_6CA6330 < 1 )
    {
      goto LABEL_15;
    }
    result = sub_62FB530(result, "client_reset, will rewind reader");
    goto LABEL_15;
  }
  if ( (v2 & 0x100000) != 0 )
  {
    v3 = *(_QWORD *)(result + 4576);
    if ( v3 )
    {
      if ( *(int *)(v3 + 8) >= 1 && dword_6CA6330 > 0 )
        goto LABEL_6;
    }
    else if ( dword_6CA6330 >= 1 )
    {
LABEL_6:
      result = sub_62FB530(result, "client_reset, clear readers");
    }
  }
  for ( i = *(_QWORD **)(v1 + 328); i; i = *(_QWORD **)(v1 + 328) )
  {
    v5 = *(void (__fastcall **)(__int64, _QWORD *))(*i + 24LL);
    *(_QWORD *)(v1 + 328) = i[1];
    v5(v1, i);
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)i);
  }
LABEL_15:
  for ( j = *(_QWORD **)(v1 + 320); j; j = *(_QWORD **)(v1 + 320) )
  {
    v8 = *(void (__fastcall **)(__int64, _QWORD *))(*j + 32LL);
    *(_QWORD *)(v1 + 320) = j[1];
    v8(v1, j);
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)j);
  }
  *(_QWORD *)(v1 + 248) = 0LL;
  *(_DWORD *)(v1 + 292) = 0;
  return result;
}


================================================================================
Function: sub_6327DD4 (0x6327DD4)
================================================================================

_QWORD *__fastcall sub_6327DD4(__int64 a1, __int64 a2)
{
  _QWORD *result; // x0

  for ( result = *(_QWORD **)(a1 + 320); result; result = (_QWORD *)result[1] )
  {
    if ( *result == a2 )
      break;
  }
  return result;
}


================================================================================
Function: sub_63286A4 (0x63286A4)
================================================================================

__int64 __fastcall sub_63286A4(__int64 a1)
{
  __int64 v1; // x1

  v1 = *(_QWORD *)(a1 + 328);
  if ( v1 )
    return (*(__int64 (**)(void))(*(_QWORD *)v1 + 40LL))();
  else
    return -1LL;
}


================================================================================
Function: sub_6328778 (0x6328778)
================================================================================

__int64 __fastcall sub_6328778(__int64 result, unsigned int a2)
{
  _QWORD *v2; // x20
  __int64 v3; // x19

  v2 = *(_QWORD **)(result + 328);
  if ( v2 )
  {
    v3 = result;
    do
    {
      result = (*(__int64 (__fastcall **)(__int64, _QWORD *, _QWORD))(*v2 + 80LL))(v3, v2, a2);
      v2 = (_QWORD *)v2[1];
    }
    while ( v2 );
  }
  return result;
}


================================================================================
Function: sub_6329BA4 (0x6329BA4)
================================================================================

__int64 __fastcall sub_6329BA4(__int64 a1)
{
  __int64 v2; // x8
  __int64 v3; // x0
  __int64 v4; // x21
  _QWORD *v5; // x20
  unsigned int v6; // w19
  _QWORD *v7; // x22
  _QWORD *v8; // x23

  if ( !a1 || (*(_DWORD *)(a1 + 2458) & 0x100000) == 0 )
    goto LABEL_7;
  v2 = *(_QWORD *)(a1 + 4576);
  if ( v2 )
  {
    if ( *(int *)(v2 + 8) < 1 || dword_6CA6340 <= 0 )
      goto LABEL_7;
  }
  else if ( dword_6CA6340 < 1 )
  {
    goto LABEL_7;
  }
  sub_62FB6C0(a1, "cw-out done");
LABEL_7:
  v3 = sub_6327DD4(a1, &off_6CA6718);
  if ( !v3 )
    return 0;
  v4 = v3;
  if ( (*(_BYTE *)(v3 + 40) & 2) != 0 )
    return 23;
  if ( (*(_BYTE *)(v3 + 40) & 1) != 0 )
  {
    return 0;
  }
  else
  {
    v5 = (_QWORD *)(v3 + 32);
    v6 = sub_6329F90(v3, a1, v3 + 32, 1LL);
    if ( v6 )
    {
      v7 = *(_QWORD **)(v4 + 32);
      *(_BYTE *)(v4 + 40) |= 2u;
      if ( v7 )
      {
        do
        {
          v8 = (_QWORD *)*v7;
          sub_6304DA0(v7 + 1);
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v7);
          v7 = v8;
          *v5 = v8;
        }
        while ( v8 );
      }
    }
  }
  return v6;
}


================================================================================
Function: sub_6329F90 (0x6329F90)
================================================================================

__int64 __fastcall sub_6329F90(__int64 a1, __int64 a2, unsigned __int64 *a3, char a4)
{
  unsigned __int64 v4; // x20
  _QWORD *v9; // x8
  _QWORD *v10; // x9
  _QWORD *v11; // x21
  __int64 result; // x0
  unsigned int v13; // w25
  __int64 v14; // x26
  __int64 v15; // x0
  __int64 v16; // x22
  __int64 v17; // x0
  __int64 v18; // [xsp+0h] [xbp-10h] BYREF

  v4 = *a3;
  if ( *a3 && (*(_BYTE *)(a1 + 40) & 1) == 0 )
  {
    while ( 1 )
    {
      v9 = *(_QWORD **)v4;
      if ( !*(_QWORD *)v4 )
        break;
      v10 = (_QWORD *)v4;
      do
      {
        v11 = v10;
        v10 = v9;
        v9 = (_QWORD *)*v9;
      }
      while ( v9 );
      result = sub_6329F90(a1, a2, v11, a4 & 1);
      if ( (_DWORD)result )
        return result;
      if ( *v11 )
        return 0LL;
    }
    if ( sub_6305080(v4 + 8) )
    {
      v13 = *(_DWORD *)(v4 + 40);
      v14 = sub_6305070(v4 + 8);
      v15 = sub_6305080(v4 + 8);
      result = sub_632A114(a1, a2, v13, a4 & 1, v14, v15, &v18);
      if ( (_DWORD)result )
        return result;
      v16 = v18;
      if ( v18 )
      {
        if ( v16 == sub_6305080(v4 + 8) )
        {
          sub_6304DA0((unsigned __int64 *)(v4 + 8));
        }
        else
        {
          v17 = sub_6305080(v4 + 8);
          result = sub_6304DF0((int)v4 + 8, v17 - v16);
          if ( (_DWORD)result )
            return result;
        }
      }
    }
    if ( !sub_6305080(v4 + 8) )
    {
      sub_6304DA0((unsigned __int64 *)(v4 + 8));
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v4);
      result = 0LL;
      *a3 = 0LL;
      return result;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_632A114 (0x632A114)
================================================================================

__int64 __fastcall sub_632A114(
        __int64 a1,
        size_t a2,
        int a3,
        __int64 a4,
        __int64 a5,
        unsigned __int64 a6,
        unsigned __int64 *a7)
{
  unsigned __int64 v8; // x22
  __int64 (__fastcall *v12)(__int64, __int64, __int64, __int64); // x26
  __int64 *v13; // x8
  unsigned __int64 v14; // x25
  __int64 v15; // x11
  const char *v16; // x8
  _DWORD *v17; // x24
  __int64 v18; // x27
  __int64 v19; // x28
  __int64 v20; // x2
  __int64 v21; // x3
  __int64 v22; // x4
  __int64 v23; // x5
  __int64 v24; // x6
  __int64 v25; // x7
  __int64 v26; // x8
  __int64 result; // x0
  __int64 v28; // x8
  __int64 v29; // x8
  __int64 v30; // [xsp+0h] [xbp-20h]
  __int64 v31; // [xsp+8h] [xbp-18h]
  __int64 v32; // [xsp+10h] [xbp-10h]
  int v33; // [xsp+1Ch] [xbp-4h]

  if ( (*(_BYTE *)(a1 + 40) & 2) != 0 )
    return 23LL;
  v8 = a6;
  if ( a3 == 2 )
  {
    v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(a2 + 576);
    if ( !v12 )
    {
      if ( *(_QWORD *)(a2 + 496) )
        v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(a2 + 568);
      else
        v12 = 0LL;
    }
    v14 = 0LL;
    v13 = (__int64 *)(a2 + 496);
    v33 = 1;
    if ( v12 )
      goto LABEL_5;
LABEL_41:
    result = 0LL;
    *a7 = a6;
    return result;
  }
  if ( a3 != 1 )
    goto LABEL_41;
  v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(a2 + 568);
  v33 = 0;
  v13 = (__int64 *)(a2 + 480);
  v14 = 0x4000LL;
  if ( !v12 )
    goto LABEL_41;
LABEL_5:
  v15 = *v13;
  if ( a3 == 1 )
    v16 = "body";
  else
    v16 = "header";
  *a7 = 0LL;
  v31 = (__int64)v16;
  v32 = v15;
  if ( !a6 )
    return 0LL;
  v17 = (_DWORD *)(a2 + 2458);
  while ( 1 )
  {
    if ( (*(_BYTE *)(a1 + 40) & 1) != 0 )
      return 0LL;
    if ( v33 | (v8 < v14) )
      v18 = v8;
    else
      v18 = v14;
    sub_6324230(a2, 1);
    v19 = v12(a5, 1LL, v18, v32);
    sub_6324230(a2, 0);
    if ( (*v17 & 0x100000) != 0 )
    {
      v26 = *(_QWORD *)(a2 + 4576);
      if ( v26 )
      {
        if ( *(int *)(v26 + 8) >= 1 && dword_6CA6340 > 0 )
LABEL_18:
          sub_62FB6C0(a2, (__int64)"cw_out, wrote %zu %s bytes -> %zu", v18, v31, v19, v23, v24, v25, v30);
      }
      else if ( dword_6CA6340 >= 1 )
      {
        goto LABEL_18;
      }
    }
    if ( v19 == 0xFFFFFFFFLL )
    {
      sub_62FB0E8(a2, (__int64)"client returned ERROR on write of %zu bytes", v18);
      return 23LL;
    }
    if ( v19 == 268435457 )
      break;
    if ( v19 != v18 )
    {
      sub_62FB0E8(a2, (__int64)"Failure writing output to destination, passed %zu returned %zd", v18, v19);
      return 23LL;
    }
    result = 0LL;
    v8 -= v18;
    a5 += v18;
    *a7 += v18;
    if ( !v8 )
      return result;
  }
  v28 = *(_QWORD *)(a2 + 24);
  if ( v28 && (*(_BYTE *)(*(_QWORD *)(v28 + 928) + 148LL) & 0x10) != 0 )
  {
    sub_62FB0E8(a2, (__int64)"Write callback asked for PAUSE when not supported");
    return 23LL;
  }
  *(_DWORD *)(a2 + 312) |= 0x10u;
  *(_BYTE *)(a1 + 40) |= 1u;
  if ( (*v17 & 0x100000) == 0 )
    return 0LL;
  v29 = *(_QWORD *)(a2 + 4576);
  if ( !v29 )
  {
    if ( dword_6CA6340 < 1 )
      return 0LL;
    goto LABEL_44;
  }
  result = 0LL;
  if ( *(int *)(v29 + 8) >= 1 && dword_6CA6340 > 0 )
  {
LABEL_44:
    sub_62FB6C0(a2, (__int64)"cw_out, PAUSE requested by client", v20, v21, v22, v23, v24, v25, v30);
    return 0LL;
  }
  return result;
}


================================================================================
Function: sub_632EBEC (0x632EBEC)
================================================================================

_DWORD *sub_632EBEC()
{
  _DWORD *v0; // x0
  _DWORD *v1; // x19
  int v2; // w8

  v0 = (_DWORD *)off_6CA6320(1LL, 288LL);
  v1 = v0;
  if ( v0 )
  {
    v2 = v0[1] | 2;
    *v0 = 2115074590;
    v0[1] = v2;
    sub_630F978(v0 + 50, 23LL);
  }
  return v1;
}


================================================================================
Function: sub_632EC48 (0x632EC48)
================================================================================

__int64 __fastcall sub_632EC48(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        long double a9,
        long double a10,
        long double a11,
        long double a12,
        __int64 a13)
{
  __int64 result; // x0
  __int64 v15; // x8
  int *v16; // x8
  __int64 v17; // x8
  __int64 *v18; // x8
  __int64 v19; // x8
  __int64 *v20; // x8
  __int64 v21; // x8
  int *v22; // x8
  __int64 v23; // x8
  __int64 *v24; // x8
  int v25; // w21
  __int64 v26; // x0
  int v27; // w8
  __int64 v28; // x0
  __int64 v29; // x0
  _QWORD v30[7]; // [xsp+80h] [xbp-60h] BYREF
  __int64 *v31; // [xsp+B8h] [xbp-28h] BYREF
  __int64 **v32; // [xsp+C0h] [xbp-20h]
  _QWORD *v33; // [xsp+C8h] [xbp-18h]
  unsigned __int64 v34; // [xsp+D0h] [xbp-10h]

  v30[4] = a6;
  v30[5] = a7;
  v30[2] = a4;
  v30[3] = a5;
  v30[1] = a3;
  v30[6] = a8;
  if ( !a1 || *(_DWORD *)a1 != 2115074590 )
    return 3LL;
  if ( *(_DWORD *)(a1 + 8) )
    return 2LL;
  v33 = v30;
  v34 = 0xFFFFFF80FFFFFFD0LL;
  v31 = &a13;
  v32 = &v31;
  switch ( (int)a2 )
  {
    case 1:
      v15 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v15 > 0xFFFFFFF8 )
        v16 = (int *)v31++;
      else
        v16 = (int *)((char *)v32 + v15);
      v25 = *v16;
      result = 5LL;
      switch ( *v16 )
      {
        case 2:
          if ( !*(_QWORD *)(a1 + 248) )
          {
            v26 = sub_630A930(0, 0LL);
            *(_QWORD *)(a1 + 248) = v26;
            if ( !v26 )
              goto LABEL_47;
          }
          goto LABEL_46;
        case 3:
          goto LABEL_46;
        case 4:
          if ( !*(_QWORD *)(a1 + 264) )
          {
            *(_QWORD *)(a1 + 272) = 8LL;
            v28 = off_6CA6320(8LL, 184LL);
            *(_QWORD *)(a1 + 280) = 0LL;
            *(_QWORD *)(a1 + 264) = v28;
            if ( !v28 )
              goto LABEL_47;
          }
          goto LABEL_46;
        case 5:
          if ( *(_QWORD *)(a1 + 160) || !(unsigned int)sub_6301A50(a1 + 40, sub_63335F8, 0LL, a1, 103LL) )
            goto LABEL_46;
          goto LABEL_47;
        case 6:
          return result;
        case 7:
          if ( *(_QWORD *)(a1 + 256) || (v29 = sub_6310090(5LL), (*(_QWORD *)(a1 + 256) = v29) != 0LL) )
          {
LABEL_46:
            result = 0LL;
            *(_DWORD *)(a1 + 4) |= 1 << v25;
          }
          else
          {
LABEL_47:
            result = 4LL;
          }
          break;
        default:
          goto LABEL_31;
      }
      break;
    case 2:
      v21 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v21 > 0xFFFFFFF8 )
        v22 = (int *)v31++;
      else
        v22 = (int *)((char *)v32 + v21);
      v27 = *v22;
      *(_DWORD *)(a1 + 4) &= ~(1 << v27);
      result = 0LL;
      switch ( v27 )
      {
        case 2:
          result = *(_QWORD *)(a1 + 248);
          if ( result )
          {
            sub_630C7FC(
              result,
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              *(_QWORD *)&a9,
              *((_QWORD *)&a9 + 1),
              *(_QWORD *)&a10,
              *((_QWORD *)&a10 + 1),
              *(_QWORD *)&a11,
              *((_QWORD *)&a11 + 1),
              *(_QWORD *)&a12,
              *((_QWORD *)&a12 + 1));
            result = 0LL;
            *(_QWORD *)(a1 + 248) = 0LL;
          }
          break;
        case 3:
        case 5:
          return result;
        case 4:
          ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 264));
          result = 0LL;
          *(_QWORD *)(a1 + 264) = 0LL;
          break;
        case 7:
          if ( *(_QWORD *)(a1 + 256) )
            sub_63100D8(a1 + 256);
          result = 0LL;
          break;
        default:
          goto LABEL_31;
      }
      break;
    case 3:
      v17 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v17 > 0xFFFFFFF8 )
        v18 = v31++;
      else
        v18 = (__int64 *)((char *)v32 + v17);
      result = 0LL;
      *(_QWORD *)(a1 + 16) = *v18;
      break;
    case 4:
      v23 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v23 > 0xFFFFFFF8 )
        v24 = v31++;
      else
        v24 = (__int64 *)((char *)v32 + v23);
      result = 0LL;
      *(_QWORD *)(a1 + 24) = *v24;
      break;
    case 5:
      v19 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v19 > 0xFFFFFFF8 )
        v20 = v31++;
      else
        v20 = (__int64 *)((char *)v32 + v19);
      result = 0LL;
      *(_QWORD *)(a1 + 32) = *v20;
      break;
    default:
LABEL_31:
      result = 1LL;
      break;
  }
  return result;
}


================================================================================
Function: sub_632F114 (0x632F114)
================================================================================

__int64 __fastcall sub_632F114(__int64 a1, char a2)
{
  __int64 v2; // x8
  void (*v3)(void); // x9

  v2 = *(_QWORD *)(a1 + 224);
  if ( !v2 )
    return 3LL;
  if ( ((*(_DWORD *)(v2 + 4) >> a2) & 1) != 0 )
  {
    v3 = *(void (**)(void))(v2 + 16);
    if ( v3 )
      v3();
  }
  return 0LL;
}


================================================================================
Function: sub_632F158 (0x632F158)
================================================================================

__int64 __fastcall sub_632F158(__int64 a1, char a2)
{
  __int64 v2; // x8
  void (*v3)(void); // x9

  v2 = *(_QWORD *)(a1 + 224);
  if ( !v2 )
    return 3LL;
  if ( ((*(_DWORD *)(v2 + 4) >> a2) & 1) != 0 )
  {
    v3 = *(void (**)(void))(v2 + 24);
    if ( v3 )
      v3();
  }
  return 0LL;
}


================================================================================
Function: sub_632F298 (0x632F298)
================================================================================

unsigned __int64 __fastcall sub_632F298(unsigned __int64 result)
{
  unsigned __int64 *v1; // x19
  unsigned __int64 *v2; // x21

  if ( result )
  {
    v1 = (unsigned __int64 *)result;
    do
    {
      v2 = (unsigned __int64 *)v1[1];
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*v1);
      *v1 = 0LL;
      result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v1);
      v1 = v2;
    }
    while ( v2 );
  }
  return result;
}


================================================================================
Function: sub_632F2EC (0x632F2EC)
================================================================================

__int64 __fastcall sub_632F2EC(int *a1, char a2)
{
  __int64 result; // x0

  if ( pipe(a1) )
    return 0xFFFFFFFFLL;
  if ( !fcntl(*a1, 2, 1LL)
    && !fcntl(a1[1], 2, 1LL)
    && ((a2 & 1) == 0
     || (sub_6324958((unsigned int)*a1, 1LL) & 0x80000000) == 0
     && (sub_6324958((unsigned int)a1[1], 1LL) & 0x80000000) == 0) )
  {
    return 0LL;
  }
  close(*a1);
  close(a1[1]);
  result = 0xFFFFFFFFLL;
  *(_QWORD *)a1 = -1LL;
  return result;
}


================================================================================
Function: sub_6330C24 (0x6330C24)
================================================================================

__int64 *__fastcall sub_6330C24(__int64 a1, int a2, __int64 *a3)
{
  __int64 *v3; // x19
  __int64 *v6; // x23
  __int64 *v7; // x24
  __int64 v8; // x0
  __int64 v9; // x8
  __int64 *result; // x0
  __int64 v11; // x8
  __int64 v12; // x8
  __int64 v13; // [xsp+0h] [xbp-40h] BYREF
  __int64 v14; // [xsp+8h] [xbp-38h]

  if ( !a3 )
    return 0LL;
  v3 = a3;
  v6 = &v13;
  v7 = &v13;
  v13 = 0LL;
  v14 = 0LL;
  while ( 1 )
  {
    while ( 1 )
    {
      v8 = sub_6331730(a1, a2, v3[4], v3[5]);
      if ( (v8 & 0x8000000000000000LL) == 0 )
        break;
      if ( !*v3 )
        goto LABEL_14;
      if ( sub_6331730(a1, a2, *(_QWORD *)(*v3 + 32), *(_QWORD *)(*v3 + 40)) < 0 )
      {
        result = (__int64 *)*v3;
        *v3 = *(_QWORD *)(*v3 + 8);
        v12 = *result;
        result[1] = (__int64)v3;
        v3 = result;
        if ( !v12 )
          goto LABEL_15;
      }
      *v7 = (__int64)v3;
      v7 = v3;
      v3 = (__int64 *)*v3;
    }
    if ( !v8 )
      break;
    v9 = v3[1];
    if ( !v9 )
      break;
    if ( sub_6331730(a1, a2, *(_QWORD *)(v9 + 32), *(_QWORD *)(v9 + 40)) >= 1 )
    {
      result = (__int64 *)v3[1];
      v3[1] = *result;
      v11 = result[1];
      *result = (__int64)v3;
      v3 = result;
      if ( !v11 )
        goto LABEL_15;
    }
    v6[1] = (__int64)v3;
    v6 = v3;
    v3 = (__int64 *)v3[1];
  }
LABEL_14:
  result = v3;
LABEL_15:
  v6[1] = *result;
  *v7 = result[1];
  *result = v14;
  result[1] = v13;
  return result;
}


================================================================================
Function: sub_6330D78 (0x6330D78)
================================================================================

__int64 *__fastcall sub_6330D78(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4)
{
  __int64 *v7; // x22
  __int64 v8; // x8
  __int64 *result; // x0

  if ( !a3 )
  {
    *a4 = 0LL;
    a4[1] = 0LL;
LABEL_8:
    v7 = a4;
    a4[4] = a1;
    a4[5] = a2;
    a4[2] = (__int64)a4;
    goto LABEL_9;
  }
  v7 = sub_6330C24(a1, a2, a3);
  if ( sub_6331730(a1, a2, v7[4], v7[5]) )
  {
    if ( sub_6331730(a1, a2, v7[4], v7[5]) < 0 )
    {
      *a4 = *v7;
      a4[1] = (__int64)v7;
      *v7 = 0LL;
    }
    else
    {
      v8 = v7[1];
      *a4 = (__int64)v7;
      a4[1] = v8;
      v7[1] = 0LL;
    }
    goto LABEL_8;
  }
  a4[2] = (__int64)v7;
  a4[4] = -1LL;
  a4[5] = -1LL;
  a4[3] = v7[3];
  *(_QWORD *)(v7[3] + 16) = a4;
LABEL_9:
  result = v7;
  v7[3] = (__int64)a4;
  return result;
}


================================================================================
Function: sub_6330EFC (0x6330EFC)
================================================================================

__int64 __fastcall sub_6330EFC(__int64 a1, _QWORD *a2, __int64 *a3)
{
  __int64 v4; // x21
  __int64 result; // x0
  _QWORD *v7; // x8
  __int64 v8; // x9
  __int64 v9; // x8
  __int64 v10; // x9
  __int64 v11; // x10
  __int64 v12; // x8

  if ( !a1 )
    return 1LL;
  v4 = a1;
  if ( sub_6331730(-1LL, 0xFFFFFFFFLL, a2[4], a2[5]) )
  {
    if ( (_QWORD *)sub_6330C24(a2[4], a2[5], v4) != a2 )
      return 2LL;
    v4 = a2[2];
    if ( (_QWORD *)v4 == a2 )
    {
      if ( *a2 )
      {
        v4 = sub_6330C24(a2[4], a2[5], *a2);
        *(_QWORD *)(v4 + 8) = a2[1];
      }
      else
      {
        v4 = a2[1];
      }
    }
    else
    {
      *(_OWORD *)(v4 + 32) = *((_OWORD *)a2 + 2);
      v11 = *a2;
      v10 = a2[1];
      *(_QWORD *)(v4 + 24) = a2[3];
      v12 = a2[3];
      *(_QWORD *)v4 = v11;
      *(_QWORD *)(v4 + 8) = v10;
      *(_QWORD *)(v12 + 16) = v4;
    }
  }
  else
  {
    v7 = (_QWORD *)a2[2];
    if ( v7 == a2 )
      return 3LL;
    v8 = a2[3];
    *(_QWORD *)(v8 + 16) = v7;
    v9 = a2[2];
    a2[2] = a2;
    *(_QWORD *)(v9 + 24) = v8;
  }
  result = 0LL;
  *a3 = v4;
  return result;
}


================================================================================
Function: sub_6330FEC (0x6330FEC)
================================================================================

__int64 __fastcall sub_6330FEC(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 48) = a2;
  return result;
}


================================================================================
Function: sub_6330FFC (0x6330FFC)
================================================================================

__int64 __fastcall sub_6330FFC(unsigned __int8 a1)
{
  return byte_16B9DB0[a1];
}


================================================================================
Function: sub_6331024 (0x6331024)
================================================================================

bool __fastcall sub_6331024(unsigned __int64 a1, unsigned __int64 a2)
{
  int v2; // w8
  unsigned __int8 *v3; // x9
  int v4; // t1

  if ( !a1 || !a2 )
    return (a1 | a2) == 0;
  v2 = *(unsigned __int8 *)a1;
  if ( *(_BYTE *)a1 )
  {
    v3 = (unsigned __int8 *)(a1 + 1);
    while ( *(_BYTE *)a2 )
    {
      if ( byte_16B9DB0[(unsigned __int8)v2] != byte_16B9DB0[*(unsigned __int8 *)a2] )
        return 0LL;
      v4 = *v3++;
      v2 = v4;
      ++a2;
      if ( !v4 )
        return (v2 != 0) ^ (*(_BYTE *)a2 == 0);
    }
  }
  return (v2 != 0) ^ (*(_BYTE *)a2 == 0);
}


================================================================================
Function: sub_633109C (0x633109C)
================================================================================

bool __fastcall sub_633109C(unsigned __int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int8 v3; // w9
  unsigned __int8 *v4; // x10
  int v5; // t1

  if ( !a1 || !a2 )
    return (a1 | a2) == 0 && a3 != 0;
  v3 = *(_BYTE *)a1;
  if ( *(_BYTE *)a1 )
  {
    v4 = (unsigned __int8 *)(a1 + 1);
    while ( *(_BYTE *)a2 && a3 )
    {
      if ( byte_16B9DB0[v3] != byte_16B9DB0[*(unsigned __int8 *)a2] )
        return 0LL;
      v5 = *v4++;
      v3 = v5;
      --a3;
      ++a2;
      if ( !v5 )
        break;
    }
  }
  return !a3 || byte_16B9DB0[v3] == byte_16B9DB0[*(unsigned __int8 *)a2];
}


================================================================================
Function: sub_6331274 (0x6331274)
================================================================================

_BYTE *__fastcall sub_6331274(const void *a1, size_t a2)
{
  _BYTE *v4; // x0
  _BYTE *v5; // x21

  v4 = (_BYTE *)((__int64 (__fastcall *)(unsigned __int64))off_6CA6300[0])(a2 + 1);
  v5 = v4;
  if ( v4 )
  {
    memcpy(v4, a1, a2);
    v5[a2] = 0;
  }
  return v5;
}


================================================================================
Function: sub_633132C (0x633132C)
================================================================================

const char *__fastcall sub_633132C(unsigned int a1)
{
  if ( a1 > 0x65 )
    return "Unknown error";
  else
    return (char *)dword_16B9FB0 + dword_16B9FB0[a1];
}


================================================================================
Function: sub_6331454 (0x6331454)
================================================================================

__int64 __fastcall sub_6331454(const char *a1, const char **a2, int a3, __int64 *a4)
{
  const char *v7; // x20
  _DWORD *v8; // x23
  int v9; // w8
  __int64 result; // x0
  __int64 v11; // x8
  char *v12; // [xsp+0h] [xbp-10h] BYREF

  v7 = a1;
  v12 = 0LL;
  v8 = (_DWORD *)__errno(a1);
  *v8 = 0;
  *a4 = 0LL;
  while ( 1 )
  {
    v9 = *(unsigned __int8 *)v7;
    if ( v9 != 9 && v9 != 32 )
      break;
    ++v7;
  }
  if ( v9 == 45 || (unsigned int)(v9 - 10) <= 3 )
  {
    result = 2LL;
    if ( a2 )
      *a2 = v7;
  }
  else
  {
    v11 = strtol(v7, &v12, a3);
    if ( a2 )
      *a2 = v12;
    if ( *v8 == 34 )
    {
      return 1LL;
    }
    else if ( v7 == v12 )
    {
      return 2LL;
    }
    else
    {
      result = 0LL;
      *a4 = v11;
    }
  }
  return result;
}


================================================================================
Function: sub_633155C (0x633155C)
================================================================================

unsigned __int64 *__fastcall sub_633155C(unsigned __int64 *result, unsigned __int64 a2)
{
  unsigned __int64 *v2; // x2

  v2 = 0LL;
  if ( result && (a2 & 0x8000000000000000LL) == 0 )
  {
    if ( a2 )
    {
      *result = a2 / 0x3E8;
      result[1] = 1000 * (a2 % 0x3E8);
      return result;
    }
    v2 = result;
    *result = 0LL;
    result[1] = 0LL;
  }
  return v2;
}


================================================================================
Function: sub_63315AC (0x63315AC)
================================================================================

__time_t sub_63315AC()
{
  __int64 v1; // [xsp+8h] [xbp-28h] BYREF
  struct timeval tv; // [xsp+18h] [xbp-18h] BYREF

  if ( !clock_gettime(4, (struct timespec *)&v1) || !clock_gettime(1, (struct timespec *)&v1) )
    return v1;
  gettimeofday(&tv, 0LL);
  return tv.tv_sec;
}


================================================================================
Function: sub_633164C (0x633164C)
================================================================================

__int64 __fastcall sub_633164C(__int64 a1, int a2, __int64 a3, int a4)
{
  signed __int64 v4; // x8

  v4 = a1 - a3;
  if ( a1 - a3 > 0x20C49BA5E353F6LL )
    return 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 >= (__int64)0xFFDF3B645A1CAC0ALL )
    return 1000 * v4 + (a2 - a4) / 1000;
  return 0x8000000000000000LL;
}


================================================================================
Function: sub_63316BC (0x63316BC)
================================================================================

__int64 __fastcall sub_63316BC(__int64 a1, int a2, __int64 a3, int a4)
{
  signed __int64 v4; // x8

  v4 = a1 - a3;
  if ( a1 - a3 > 0x20C49BA5E353F6LL )
    return 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 >= (__int64)0xFFDF3B645A1CAC0ALL )
    return 1000 * v4 + (a2 - a4 + 999) / 1000;
  return 0x8000000000000000LL;
}


================================================================================
Function: sub_6331730 (0x6331730)
================================================================================

__int64 __fastcall sub_6331730(__int64 a1, int a2, __int64 a3, int a4)
{
  signed __int64 v4; // x8

  v4 = a1 - a3;
  if ( a1 - a3 > 0x8637BD05AF5LL )
    return 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 >= (__int64)0xFFFFF79C842FA50BLL )
    return 1000000 * v4 + a2 - a4;
  return 0x8000000000000000LL;
}


================================================================================
Function: sub_63318AC (0x63318AC)
================================================================================

__int64 __fastcall sub_63318AC(__int64 a1, _BYTE *a2)
{
  __int64 v2; // x8
  int v3; // w9

  if ( a1 && (v2 = *(_QWORD *)(a1 + 24)) != 0 && (v3 = *(_DWORD *)(v2 + 964), v3 != -1) )
    return sub_62FDED4(a1, v3 == *(_DWORD *)(v2 + 572), a2);
  else
    return 2LL;
}


================================================================================
Function: sub_6331E5C (0x6331E5C)
================================================================================

__int64 __fastcall sub_6331E5C(__int64 result)
{
  int v1; // w9
  __int64 v2; // x11
  int v3; // w8

  v1 = *(_DWORD *)(result + 4692);
  v2 = *(_QWORD *)(result + 488);
  v3 = *(unsigned __int8 *)(result + 4690);
  *(_QWORD *)(result + 4256) = *(_QWORD *)(result + 592);
  *(_QWORD *)(result + 4264) = v2;
  *(_DWORD *)(result + 4692) = v1 & 0xFFFEFFFF | ((v3 == 4) << 16);
  return result;
}


================================================================================
Function: sub_6332C04 (0x6332C04)
================================================================================

// attributes: thunk
__int64 __fastcall sub_6332C04(__int64 a1, __int64 a2)
{
  return sub_6329BA4(a1, a2);
}


================================================================================
Function: sub_6332C08 (0x6332C08)
================================================================================

__int64 sub_6332C08()
{
  return sub_62FE638();
}


================================================================================
Function: sub_6332C58 (0x6332C58)
================================================================================

__int64 __fastcall sub_6332C58(__int64 a1, __int64 a2, __int64 a3, char a4, _QWORD *a5)
{
  __int64 v5; // x9
  int v10; // w10
  _BOOL8 v11; // x1
  __int64 result; // x0

  v5 = *(_QWORD *)(a1 + 24);
  v10 = *(_DWORD *)(v5 + 964);
  v11 = v10 != -1 && v10 == *(_DWORD *)(v5 + 572);
  result = sub_62FF26C(a1, v11, a2, a3, a4 & 1, a5);
  if ( (_DWORD)result )
  {
    if ( (_DWORD)result == 81 )
    {
      result = 0LL;
      *a5 = 0LL;
    }
  }
  else
  {
    result = 0LL;
    if ( *a5 )
      *(_QWORD *)(a1 + 4720) += *a5;
  }
  return result;
}


================================================================================
Function: sub_6332CF0 (0x6332CF0)
================================================================================

__int64 sub_6332CF0()
{
  sub_62FEFD0();
  return 0LL;
}


================================================================================
Function: sub_6332D74 (0x6332D74)
================================================================================

unsigned __int64 __fastcall sub_6332D74(__int64 a1)
{
  __int64 v2; // x21
  __int64 v3; // x22
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  unsigned int v11; // w8
  unsigned __int64 result; // x0

  v2 = 0LL;
  v3 = a1 + 1784;
  do
  {
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v3 + v2));
    *(_QWORD *)(v3 + v2) = 0LL;
    v2 += 8LL;
  }
  while ( v2 != 496 );
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 2280));
  v4 = off_6CA6308[0];
  *(_QWORD *)(a1 + 2280) = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(*(_QWORD *)(a1 + 2288));
  v5 = off_6CA6308[0];
  *(_QWORD *)(a1 + 2288) = 0LL;
  ((void (__fastcall *)(_QWORD))v5)(*(_QWORD *)(a1 + 2296));
  v6 = off_6CA6308[0];
  *(_QWORD *)(a1 + 2296) = 0LL;
  ((void (__fastcall *)(_QWORD))v6)(*(_QWORD *)(a1 + 2304));
  v7 = off_6CA6308[0];
  *(_QWORD *)(a1 + 2304) = 0LL;
  ((void (__fastcall *)(_QWORD))v7)(*(_QWORD *)(a1 + 2312));
  v8 = off_6CA6308[0];
  *(_QWORD *)(a1 + 2312) = 0LL;
  ((void (__fastcall *)(_QWORD))v8)(*(_QWORD *)(a1 + 2320));
  v9 = off_6CA6308[0];
  *(_QWORD *)(a1 + 2320) = 0LL;
  ((void (__fastcall *)(_QWORD))v9)(*(_QWORD *)(a1 + 2328));
  v10 = off_6CA6308[0];
  *(_QWORD *)(a1 + 2328) = 0LL;
  ((void (__fastcall *)(_QWORD))v10)(*(_QWORD *)(a1 + 2336));
  v11 = *(_DWORD *)(a1 + 4692);
  *(_QWORD *)(a1 + 2336) = 0LL;
  if ( (v11 & 0x4000) != 0 )
  {
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 4352));
    v11 = *(_DWORD *)(a1 + 4692) & 0xFFFFBFFF;
    *(_DWORD *)(a1 + 4692) = v11;
  }
  *(_QWORD *)(a1 + 4352) = 0LL;
  if ( (v11 & 0x2000) != 0 )
  {
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 4344));
    *(_DWORD *)(a1 + 4692) &= ~0x2000u;
  }
  *(_QWORD *)(a1 + 4344) = 0LL;
  sub_631CECC(a1 + 856);
  result = sub_632F298(*(_QWORD *)(a1 + 4568));
  *(_QWORD *)(a1 + 4568) = 0LL;
  return result;
}


================================================================================
Function: sub_6332E9C (0x6332E9C)
================================================================================

__int64 __fastcall sub_6332E9C(unsigned __int64 *a1)
{
  unsigned __int64 v1; // x19
  __int64 v2; // x0
  char v3; // w8
  int v4; // w8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 v13; // x0
  __int64 v14; // x8
  __int64 (__fastcall *v15)(); // x8
  __int64 (__fastcall *v16)(); // x8
  __int64 (__fastcall *v17)(); // x8
  __int64 (__fastcall *v18)(); // x8
  __int64 (__fastcall *v19)(); // x8
  __int64 (__fastcall *v20)(); // x8
  __int64 (__fastcall *v21)(); // x8
  __int64 (__fastcall *v22)(); // x8
  __int64 (__fastcall *v23)(); // x8
  __int64 (__fastcall *v24)(); // x8
  __int64 (__fastcall *v25)(); // x8
  __int64 (__fastcall *v26)(); // x8
  __int64 (__fastcall *v27)(); // x8
  __int64 v28; // x0

  if ( a1 )
  {
    v1 = *a1;
    if ( *a1 )
    {
      *a1 = 0LL;
      sub_6321A20(v1);
      if ( (*(_BYTE *)(v1 + 4694) & 2) == 0 )
      {
        v2 = *(_QWORD *)(v1 + 208);
        if ( v2 )
          sub_6321560(v2, v1);
        if ( *(_QWORD *)(v1 + 216) )
        {
          sub_63211CC();
          *(_QWORD *)(v1 + 216) = 0LL;
        }
      }
      sub_63218F4(v1);
      v3 = *(_BYTE *)(v1 + 4693);
      *(_DWORD *)v1 = 0;
      if ( (v3 & 2) != 0 )
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v1 + 4232));
      sub_63266DC(v1 + 232, v1);
      sub_633E844(v1);
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v1 + 2976));
      *(_QWORD *)(v1 + 2976) = 0LL;
      sub_633EACC(v1);
      if ( (*(_BYTE *)(v1 + 4693) & 0x40) != 0 )
      {
        ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v1 + 4352));
        v4 = *(_DWORD *)(v1 + 4692);
        *(_QWORD *)(v1 + 4352) = 0LL;
        *(_DWORD *)(v1 + 4692) = v4 & 0xFFFFBFFF;
      }
      v5 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4352) = 0LL;
      ((void (__fastcall *)(_QWORD))v5)(*(_QWORD *)(v1 + 4280));
      v6 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4280) = 0LL;
      ((void (__fastcall *)(_QWORD))v6)(*(_QWORD *)(v1 + 4288));
      v7 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4288) = 0LL;
      ((void (__fastcall *)(_QWORD))v7)(*(_QWORD *)(v1 + 4296));
      v8 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4296) = 0LL;
      ((void (__fastcall *)(_QWORD))v8)(*(_QWORD *)(v1 + 4304));
      v9 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4304) = 0LL;
      ((void (__fastcall *)(_QWORD))v9)(*(_QWORD *)(v1 + 4312));
      v10 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4312) = 0LL;
      ((void (__fastcall *)(_QWORD))v10)(*(_QWORD *)(v1 + 4320));
      v11 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4320) = 0LL;
      ((void (__fastcall *)(_QWORD))v11)(*(_QWORD *)(v1 + 4328));
      v12 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4328) = 0LL;
      ((void (__fastcall *)(_QWORD))v12)(*(_QWORD *)(v1 + 4336));
      v13 = *(_QWORD *)(v1 + 4272);
      *(_QWORD *)(v1 + 4336) = 0LL;
      sub_6338688(v13);
      *(_QWORD *)(v1 + 4272) = 0LL;
      sub_6304DA0((unsigned __int64 *)(v1 + 2928));
      sub_630CA48(v1, 1LL);
      sub_6309880(v1, *(_QWORD *)(v1 + 2480), *(_QWORD *)(v1 + 2200));
      sub_63097D8(v1 + 2480);
      sub_63105D0(v1, *(_QWORD *)(v1 + 2472), *(char **)(v1 + 2208));
      v14 = *(_QWORD *)(v1 + 224);
      if ( !v14 || !*(_QWORD *)(v14 + 256) )
        sub_63100D8((unsigned __int64 *)(v1 + 2472));
      sub_632F298(*(_QWORD *)(v1 + 2960));
      sub_631BBA8(v1);
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v1 + 4752));
      v15 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4752) = 0LL;
      ((void (__fastcall *)(_QWORD))v15)(*(_QWORD *)(v1 + 4760));
      *(_QWORD *)(v1 + 4760) = 0LL;
      sub_63038B0(v1);
      sub_63038A0(*(_QWORD *)(v1 + 3248));
      if ( *(_QWORD *)(v1 + 224) )
      {
        sub_632F114(v1, 1);
        --*(_DWORD *)(*(_QWORD *)(v1 + 224) + 8LL);
        sub_632F158(v1, 1LL);
      }
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v1 + 4664));
      v16 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4664) = 0LL;
      ((void (__fastcall *)(_QWORD))v16)(*(_QWORD *)(v1 + 4584));
      v17 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4584) = 0LL;
      ((void (__fastcall *)(_QWORD))v17)(*(_QWORD *)(v1 + 4600));
      v18 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4600) = 0LL;
      ((void (__fastcall *)(_QWORD))v18)(*(_QWORD *)(v1 + 4592));
      v19 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4592) = 0LL;
      ((void (__fastcall *)(_QWORD))v19)(*(_QWORD *)(v1 + 4640));
      v20 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4640) = 0LL;
      ((void (__fastcall *)(_QWORD))v20)(*(_QWORD *)(v1 + 4608));
      v21 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4608) = 0LL;
      ((void (__fastcall *)(_QWORD))v21)(*(_QWORD *)(v1 + 4616));
      v22 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4616) = 0LL;
      ((void (__fastcall *)(_QWORD))v22)(*(_QWORD *)(v1 + 4624));
      v23 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4624) = 0LL;
      ((void (__fastcall *)(_QWORD))v23)(*(_QWORD *)(v1 + 4632));
      v24 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4632) = 0LL;
      ((void (__fastcall *)(_QWORD))v24)(*(_QWORD *)(v1 + 4648));
      v25 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4648) = 0LL;
      ((void (__fastcall *)(_QWORD))v25)(*(_QWORD *)(v1 + 4656));
      v26 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4656) = 0LL;
      ((void (__fastcall *)(_QWORD))v26)(*(_QWORD *)(v1 + 4672));
      v27 = off_6CA6308[0];
      *(_QWORD *)(v1 + 4672) = 0LL;
      ((void (__fastcall *)(_QWORD))v27)(*(_QWORD *)(v1 + 4680));
      v28 = *(_QWORD *)(v1 + 4376);
      *(_QWORD *)(v1 + 4680) = 0LL;
      sub_631CECC(v28);
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v1 + 4376));
      *(_QWORD *)(v1 + 4376) = 0LL;
      sub_6332D74(v1);
      sub_630E550(v1);
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1);
    }
  }
  return 0LL;
}


================================================================================
Function: sub_63331E4 (0x63331E4)
================================================================================

long double __fastcall sub_63331E4(__int64 a1)
{
  int *v1; // x20
  __int64 v3; // x22
  struct _IO_FILE *v4; // x10
  struct _IO_FILE *v5; // x9
  int v6; // w12
  __int64 v7; // x0
  __int16 v8; // w8
  __int64 v9; // x0
  int v10; // w10
  unsigned __int16 v11; // w8
  long double result; // q0

  v1 = (int *)(a1 + 2458);
  v3 = a1 + 776;
  v4 = stdin;
  *(_QWORD *)(a1 + 480) = stdout;
  *(_QWORD *)(a1 + 488) = v4;
  v5 = stderr;
  *(_QWORD *)(a1 + 792) = -1LL;
  *(_QWORD *)(a1 + 552) = -1LL;
  *(_QWORD *)(a1 + 456) = v5;
  LOWORD(v5) = *(_WORD *)(a1 + 2462);
  *(_QWORD *)(a1 + 568) = &fwrite;
  v6 = *(_DWORD *)(a1 + 2458);
  *(_QWORD *)(a1 + 592) = &fread;
  *(_DWORD *)(a1 + 1720) = 86400;
  *(_QWORD *)(a1 + 696) = 0LL;
  *(_QWORD *)(a1 + 528) = 30LL;
  *(_DWORD *)(a1 + 1728) = 60;
  *(_BYTE *)(a1 + 1321) = 0;
  *(_QWORD *)(a1 + 1712) = 5LL;
  *(_WORD *)(a1 + 1704) = 0;
  *(_BYTE *)(a1 + 1706) = 0;
  *(int64x2_t *)(a1 + 512) = vdupq_n_s64(1uLL);
  *(_BYTE *)(a1 + 1707) = 5;
  *(_WORD *)(a1 + 2462) = (_WORD)v5;
  *(_DWORD *)(a1 + 2458) = v6 & 0xFFFFFBFD | 0x400;
  sub_631CFC8(a1 + 856);
  v7 = sub_633D608(a1);
  v8 = *((_WORD *)v1 + 2) | 0x600;
  *(_DWORD *)(a1 + 1780) = 420;
  *((_WORD *)v1 + 2) = v8;
  *(_QWORD *)(a1 + 2348) = 0xFFFFFFFFFLL;
  v9 = sub_633DE04(v7);
  if ( (_DWORD)v9 != 8 )
    sub_633DE04(v9);
  v10 = *v1;
  *(_DWORD *)(a1 + 2452) = 5;
  v11 = *((_WORD *)v1 + 2);
  *(_QWORD *)(a1 + 2376) = 1000LL;
  *(_DWORD *)(a1 + 2368) = 9;
  *(_QWORD *)(v3 + 956) = 0x1000000004000LL;
  *(_DWORD *)(a1 + 760) = 200;
  *(_QWORD *)(a1 + 2360) = 0x3C0000003CLL;
  result = *(long double *)&xmmword_B03E60;
  *(_QWORD *)(a1 + 2400) = 60000LL;
  *(_BYTE *)(a1 + 1322) = 2;
  *(_OWORD *)v3 = xmmword_B03E60;
  *v1 = v10 & 0x3EFFFFDB | 0x1000004;
  *((_WORD *)v1 + 2) = (v10 & 0x3EFFFFDB | ((unsigned __int64)v11 << 32) & 0xEFFE3EFFFFDBLL | 0x101000004LL) >> 32;
  return result;
}


================================================================================
Function: sub_6333390 (0x6333390)
================================================================================

__int64 __fastcall sub_6333390(unsigned __int64 *a1)
{
  _DWORD *v2; // x0
  unsigned __int64 v3; // x20
  _DWORD *v4; // x22
  unsigned int v5; // w21
  int v6; // w9

  v2 = (_DWORD *)off_6CA6320(1LL, 4944LL);
  if ( v2 )
  {
    v3 = (unsigned __int64)v2;
    *v2 = -1059136595;
    v4 = v2 + 58;
    sub_63262FC(v2 + 58);
    v5 = sub_6303858(v3, v3 + 3248);
    if ( v5 )
    {
      sub_63266DC(v4, v3);
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v3);
    }
    else
    {
      sub_63331E4(v3);
      sub_6304D94((_QWORD *)(v3 + 2928), 102400LL);
      sub_630D0F4(v3);
      v6 = *(_DWORD *)(v3 + 2604) | 0x10;
      *(_QWORD *)(v3 + 2416) = -1LL;
      *(_QWORD *)(v3 + 8) = -1LL;
      *(_QWORD *)(v3 + 16) = -1LL;
      *(_QWORD *)(v3 + 2912) = -1LL;
      *(_QWORD *)(v3 + 2920) = -1LL;
      *(_DWORD *)(v3 + 2604) = v6;
      *(_QWORD *)(v3 + 2968) = -1LL;
      sub_631CC00((_QWORD *)(v3 + 4424), 0LL);
      *a1 = v3;
    }
  }
  else
  {
    return 27;
  }
  return v5;
}


================================================================================
Function: sub_6333488 (0x6333488)
================================================================================

__int64 __fastcall sub_6333488(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 (__fastcall *v13)(); // x8
  __int64 (__fastcall *v14)(); // x8
  __int64 (__fastcall *v15)(); // x8
  __int64 (__fastcall *v16)(); // x8
  __int64 (__fastcall *v17)(); // x8
  __int64 (__fastcall *v18)(); // x8
  __int64 (__fastcall *v19)(); // x8
  __int64 (__fastcall *v20)(); // x1

  sub_62FDE20(a1, a2, 0LL);
  sub_62FDE20(a1, a2, 1LL);
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(a2[33]);
  v4 = off_6CA6308[0];
  a2[33] = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(a2[26]);
  v5 = off_6CA6308[0];
  a2[26] = 0LL;
  ((void (__fastcall *)(_QWORD))v5)(a2[34]);
  v6 = off_6CA6308[0];
  a2[34] = 0LL;
  ((void (__fastcall *)(_QWORD))v6)(a2[27]);
  v7 = off_6CA6308[0];
  a2[27] = 0LL;
  ((void (__fastcall *)(_QWORD))v7)(a2[28]);
  v8 = off_6CA6308[0];
  a2[28] = 0LL;
  ((void (__fastcall *)(_QWORD))v8)(a2[21]);
  v9 = off_6CA6308[0];
  a2[21] = 0LL;
  ((void (__fastcall *)(_QWORD))v9)(a2[60]);
  v10 = off_6CA6308[0];
  a2[60] = 0LL;
  ((void (__fastcall *)(_QWORD))v10)(a2[61]);
  v11 = off_6CA6308[0];
  a2[61] = 0LL;
  ((void (__fastcall *)(_QWORD))v11)(a2[63]);
  v12 = off_6CA6308[0];
  a2[63] = 0LL;
  ((void (__fastcall *)(_QWORD))v12)(a2[62]);
  v13 = off_6CA6308[0];
  a2[62] = 0LL;
  ((void (__fastcall *)(_QWORD))v13)(a2[64]);
  v14 = off_6CA6308[0];
  a2[64] = 0LL;
  ((void (__fastcall *)(_QWORD))v14)(a2[11]);
  v15 = off_6CA6308[0];
  a2[11] = 0LL;
  ((void (__fastcall *)(_QWORD))v15)(a2[17]);
  v16 = off_6CA6308[0];
  a2[17] = 0LL;
  ((void (__fastcall *)(_QWORD))v16)(a2[15]);
  v17 = off_6CA6308[0];
  a2[15] = 0LL;
  ((void (__fastcall *)(_QWORD))v17)(a2[16]);
  v18 = off_6CA6308[0];
  a2[16] = 0LL;
  ((void (__fastcall *)(_QWORD))v18)(a2[134]);
  a2[134] = 0LL;
  sub_633DC04(a2);
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(a2[133]);
  v19 = off_6CA6308[0];
  a2[133] = 0LL;
  ((void (__fastcall *)(_QWORD))v19)(a2[7]);
  v20 = off_6CA6308[0];
  a2[7] = 0LL;
  return ((__int64 (__fastcall *)(_QWORD *))v20)(a2);
}


================================================================================
Function: sub_6337864 (0x6337864)
================================================================================

char *__fastcall sub_6337864(const char *a1)
{
  char *v1; // x0

  v1 = getenv(a1);
  if ( v1 && *v1 )
    return off_6CA6318(v1);
  else
    return 0LL;
}


================================================================================
Function: sub_6338688 (0x6338688)
================================================================================

unsigned __int64 *__fastcall sub_6338688(unsigned __int64 *result)
{
  unsigned __int64 *v1; // x19

  if ( result )
  {
    v1 = result;
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*result);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1[1]);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1[2]);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1[3]);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1[4]);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1[5]);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1[6]);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1[7]);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1[8]);
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v1[9]);
    return (unsigned __int64 *)((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])((unsigned __int64)v1);
  }
  return result;
}


================================================================================
Function: sub_633B058 (0x633B058)
================================================================================

__int64 __fastcall sub_633B058(int a1)
{
  return a1 & 0x7FFFFFFF;
}


================================================================================
Function: sub_633B648 (0x633B648)
================================================================================

__int64 __fastcall sub_633B648(__int64 a1)
{
  __int64 (__fastcall *v2)(); // x8
  __int64 (__fastcall *v3)(); // x8
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 result; // x0
  char v7; // w8

  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)a1);
  *(_QWORD *)a1 = 0LL;
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 8));
  v2 = off_6CA6308[0];
  *(_QWORD *)(a1 + 8) = 0LL;
  ((void (__fastcall *)(_QWORD))v2)(*(_QWORD *)(a1 + 16));
  v3 = off_6CA6308[0];
  *(_QWORD *)(a1 + 16) = 0LL;
  ((void (__fastcall *)(_QWORD))v3)(*(_QWORD *)(a1 + 24));
  v4 = off_6CA6308[0];
  *(_QWORD *)(a1 + 24) = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(*(_QWORD *)(a1 + 32));
  v5 = off_6CA6308[0];
  *(_QWORD *)(a1 + 32) = 0LL;
  result = ((__int64 (__fastcall *)(_QWORD))v5)(*(_QWORD *)(a1 + 40));
  v7 = *(_BYTE *)(a1 + 53);
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = v7 & 0xFC;
  return result;
}


================================================================================
Function: sub_633C38C (0x633C38C)
================================================================================

unsigned __int64 __fastcall sub_633C38C(__int64 a1)
{
  unsigned __int64 result; // x0

  result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}


================================================================================
Function: sub_633D608 (0x633D608)
================================================================================

long double __fastcall sub_633D608(__int64 a1)
{
  __int128 v1; // q0
  __int128 v2; // q1
  __int128 v3; // q2
  __int128 v4; // q0
  __int128 v5; // q1
  __int128 v6; // q0
  __int128 v7; // q2
  __int128 v8; // q1
  __int128 v9; // q0
  __int64 v10; // x10
  __int128 v11; // q1
  long double result; // q0

  v1 = *(_OWORD *)(a1 + 1392);
  v2 = *(_OWORD *)(a1 + 1408);
  v3 = *(_OWORD *)(a1 + 1328);
  *(_BYTE *)(a1 + 1433) |= 0xBu;
  *(_OWORD *)(a1 + 1576) = v1;
  v4 = *(_OWORD *)(a1 + 1456);
  *(_OWORD *)(a1 + 1512) = v3;
  *(_OWORD *)(a1 + 1592) = v2;
  v5 = *(_OWORD *)(a1 + 1472);
  *(_OWORD *)(a1 + 1640) = v4;
  v6 = *(_OWORD *)(a1 + 1488);
  v7 = *(_OWORD *)(a1 + 1440);
  *(_OWORD *)(a1 + 1656) = v5;
  v8 = *(_OWORD *)(a1 + 1344);
  *(_OWORD *)(a1 + 1672) = v6;
  v9 = *(_OWORD *)(a1 + 1360);
  *(_OWORD *)(a1 + 1624) = v7;
  v10 = *(_QWORD *)(a1 + 1504);
  *(_OWORD *)(a1 + 1528) = v8;
  v11 = *(_OWORD *)(a1 + 1376);
  *(_OWORD *)(a1 + 1544) = v9;
  result = *(long double *)(a1 + 1424);
  *(_QWORD *)(a1 + 1688) = v10;
  *(_OWORD *)(a1 + 1560) = v11;
  *(long double *)(a1 + 1608) = result;
  return result;
}


================================================================================
Function: sub_633DC04 (0x633DC04)
================================================================================

__int64 __fastcall sub_633DC04(_QWORD *a1)
{
  __int64 (__fastcall *v2)(); // x8
  __int64 (__fastcall *v3)(); // x8
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 (__fastcall *v13)(); // x8
  __int64 (__fastcall *v14)(); // x8
  __int64 (__fastcall *v15)(); // x8
  __int64 (__fastcall *v16)(); // x8
  __int64 (__fastcall *v17)(); // x8
  __int64 (__fastcall *v18)(); // x8
  __int64 (__fastcall *v19)(); // x8
  __int64 (__fastcall *v20)(); // x8
  __int64 (__fastcall *v21)(); // x8
  __int64 (__fastcall *v22)(); // x8
  __int64 (__fastcall *v23)(); // x8
  __int64 (__fastcall *v24)(); // x8
  __int64 result; // x0

  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(a1[87]);
  v2 = off_6CA6308[0];
  a1[87] = 0LL;
  ((void (__fastcall *)(_QWORD))v2)(a1[88]);
  v3 = off_6CA6308[0];
  a1[88] = 0LL;
  ((void (__fastcall *)(_QWORD))v3)(a1[89]);
  v4 = off_6CA6308[0];
  a1[89] = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(a1[90]);
  v5 = off_6CA6308[0];
  a1[90] = 0LL;
  ((void (__fastcall *)(_QWORD))v5)(a1[91]);
  v6 = off_6CA6308[0];
  a1[91] = 0LL;
  ((void (__fastcall *)(_QWORD))v6)(a1[92]);
  v7 = off_6CA6308[0];
  a1[92] = 0LL;
  ((void (__fastcall *)(_QWORD))v7)(a1[93]);
  v8 = off_6CA6308[0];
  a1[93] = 0LL;
  ((void (__fastcall *)(_QWORD))v8)(a1[95]);
  v9 = off_6CA6308[0];
  a1[95] = 0LL;
  ((void (__fastcall *)(_QWORD))v9)(a1[96]);
  v10 = off_6CA6308[0];
  a1[96] = 0LL;
  ((void (__fastcall *)(_QWORD))v10)(a1[97]);
  v11 = off_6CA6308[0];
  a1[97] = 0LL;
  ((void (__fastcall *)(_QWORD))v11)(a1[98]);
  v12 = off_6CA6308[0];
  a1[98] = 0LL;
  ((void (__fastcall *)(_QWORD))v12)(a1[94]);
  v13 = off_6CA6308[0];
  a1[94] = 0LL;
  ((void (__fastcall *)(_QWORD))v13)(a1[101]);
  v14 = off_6CA6308[0];
  a1[101] = 0LL;
  ((void (__fastcall *)(_QWORD))v14)(a1[102]);
  v15 = off_6CA6308[0];
  a1[102] = 0LL;
  ((void (__fastcall *)(_QWORD))v15)(a1[103]);
  v16 = off_6CA6308[0];
  a1[103] = 0LL;
  ((void (__fastcall *)(_QWORD))v16)(a1[104]);
  v17 = off_6CA6308[0];
  a1[104] = 0LL;
  ((void (__fastcall *)(_QWORD))v17)(a1[105]);
  v18 = off_6CA6308[0];
  a1[105] = 0LL;
  ((void (__fastcall *)(_QWORD))v18)(a1[106]);
  v19 = off_6CA6308[0];
  a1[106] = 0LL;
  ((void (__fastcall *)(_QWORD))v19)(a1[107]);
  v20 = off_6CA6308[0];
  a1[107] = 0LL;
  ((void (__fastcall *)(_QWORD))v20)(a1[109]);
  v21 = off_6CA6308[0];
  a1[109] = 0LL;
  ((void (__fastcall *)(_QWORD))v21)(a1[110]);
  v22 = off_6CA6308[0];
  a1[110] = 0LL;
  ((void (__fastcall *)(_QWORD))v22)(a1[111]);
  v23 = off_6CA6308[0];
  a1[111] = 0LL;
  ((void (__fastcall *)(_QWORD))v23)(a1[112]);
  v24 = off_6CA6308[0];
  a1[112] = 0LL;
  result = ((__int64 (__fastcall *)(_QWORD))v24)(a1[108]);
  a1[108] = 0LL;
  return result;
}


================================================================================
Function: sub_633DE04 (0x633DE04)
================================================================================

__int64 sub_633DE04()
{
  sub_633DE28(0LL);
  return (unsigned int)*off_6CA6898;
}


================================================================================
Function: sub_633DE28 (0x633DE28)
================================================================================

__int64 __fastcall sub_633DE28(__int64 a1)
{
  __int64 result; // x0
  unsigned __int64 v3; // x0
  unsigned __int64 v4; // x19
  __int64 v5; // x8
  _QWORD *v6; // x22
  __int64 v7; // x8

  if ( (_UNKNOWN *)off_6CA6898 != &unk_6C1FEA8 )
    return 1LL;
  if ( a1 )
  {
    result = 0LL;
    off_6CA6898 = a1;
    return result;
  }
  if ( !off_6CA68A0 )
    return 1LL;
  v3 = sub_6337864("CURL_SSL_BACKEND");
  v4 = v3;
  v5 = off_6CA68A0;
  if ( !v3 || !off_6CA68A0 )
    goto LABEL_13;
  v6 = &off_6CA68A0;
  if ( !sub_6331024(v3, *(_QWORD *)&byte_8[off_6CA68A0]) )
  {
    while ( 1 )
    {
      v7 = v6[1];
      if ( !v7 )
        break;
      ++v6;
      if ( sub_6331024(v4, *(_QWORD *)(v7 + 8)) )
        goto LABEL_9;
    }
    v5 = off_6CA68A0;
LABEL_13:
    off_6CA6898 = v5;
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v4);
    return 0LL;
  }
LABEL_9:
  off_6CA6898 = *v6;
  ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v4);
  return 0LL;
}


================================================================================
Function: sub_633DF18 (0x633DF18)
================================================================================

__int64 sub_633DF18()
{
  if ( (byte_6FF45A8 & 1) != 0 )
    return 1LL;
  byte_6FF45A8 = 1;
  return (*(__int64 (**)(void))((char *)&qword_20 + off_6CA6898))();
}


================================================================================
Function: sub_633E250 (0x633E250)
================================================================================

unsigned __int64 __fastcall sub_633E250(__int64 a1)
{
  unsigned __int64 result; // x0
  unsigned __int64 v3; // x0
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 (__fastcall *v13)(); // x8
  __int64 (__fastcall *v14)(); // x8
  __int64 (__fastcall *v15)(); // x8

  result = *(_QWORD *)(a1 + 24);
  if ( result )
  {
    (*(void (__fastcall **)(unsigned __int64, _QWORD))(a1 + 40))(result, *(_QWORD *)(a1 + 32));
    *(_QWORD *)(a1 + 24) = 0LL;
    v3 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 40) = 0LL;
    *(_QWORD *)(a1 + 48) = 0LL;
    ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v3);
    v4 = off_6CA6308[0];
    *(_QWORD *)(a1 + 72) = 0LL;
    ((void (__fastcall *)(_QWORD))v4)(*(_QWORD *)(a1 + 80));
    v5 = off_6CA6308[0];
    *(_QWORD *)(a1 + 80) = 0LL;
    ((void (__fastcall *)(_QWORD))v5)(*(_QWORD *)(a1 + 88));
    v6 = off_6CA6308[0];
    *(_QWORD *)(a1 + 88) = 0LL;
    ((void (__fastcall *)(_QWORD))v6)(*(_QWORD *)(a1 + 96));
    v7 = off_6CA6308[0];
    *(_QWORD *)(a1 + 96) = 0LL;
    ((void (__fastcall *)(_QWORD))v7)(*(_QWORD *)(a1 + 104));
    v8 = off_6CA6308[0];
    *(_QWORD *)(a1 + 104) = 0LL;
    ((void (__fastcall *)(_QWORD))v8)(*(_QWORD *)(a1 + 112));
    v9 = off_6CA6308[0];
    *(_QWORD *)(a1 + 112) = 0LL;
    ((void (__fastcall *)(_QWORD))v9)(*(_QWORD *)(a1 + 120));
    v10 = off_6CA6308[0];
    *(_QWORD *)(a1 + 120) = 0LL;
    ((void (__fastcall *)(_QWORD))v10)(*(_QWORD *)(a1 + 136));
    v11 = off_6CA6308[0];
    *(_QWORD *)(a1 + 136) = 0LL;
    ((void (__fastcall *)(_QWORD))v11)(*(_QWORD *)(a1 + 144));
    v12 = off_6CA6308[0];
    *(_QWORD *)(a1 + 144) = 0LL;
    ((void (__fastcall *)(_QWORD))v12)(*(_QWORD *)(a1 + 152));
    v13 = off_6CA6308[0];
    *(_QWORD *)(a1 + 152) = 0LL;
    ((void (__fastcall *)(_QWORD))v13)(*(_QWORD *)(a1 + 160));
    v14 = off_6CA6308[0];
    *(_QWORD *)(a1 + 160) = 0LL;
    ((void (__fastcall *)(_QWORD))v14)(*(_QWORD *)(a1 + 128));
    v15 = off_6CA6308[0];
    *(_QWORD *)(a1 + 128) = 0LL;
    ((void (__fastcall *)(_QWORD))v15)(*(_QWORD *)a1);
    *(_QWORD *)a1 = 0LL;
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(a1 + 8));
    *(_QWORD *)(a1 + 8) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_633E844 (0x633E844)
================================================================================

__int64 __fastcall sub_633E844(_QWORD *a1)
{
  unsigned __int64 v2; // x0
  __int64 v3; // x8
  unsigned __int64 v4; // x20
  __int64 v5; // x21

  v2 = a1[375];
  if ( v2 )
  {
    v3 = a1[28];
    if ( !v3 || (*(_BYTE *)(v3 + 4) & 0x10) == 0 )
    {
      if ( a1[214] )
      {
        ((void (*)(void))sub_633E250)();
        if ( a1[214] >= 2uLL )
        {
          v4 = 1LL;
          v5 = 184LL;
          do
          {
            sub_633E250(a1[375] + v5);
            ++v4;
            v5 += 184LL;
          }
          while ( v4 < a1[214] );
        }
        v2 = a1[375];
      }
      ((void (__fastcall *)(unsigned __int64))off_6CA6308[0])(v2);
      a1[375] = 0LL;
    }
  }
  return (*(__int64 (__fastcall **)(_QWORD *))((char *)off_88 + off_6CA6898))(a1);
}


================================================================================
Function: sub_633EACC (0x633EACC)
================================================================================

unsigned __int64 __fastcall sub_633EACC(unsigned __int64 result)
{
  int v1; // w8
  unsigned __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x21
  __int64 v5; // x8

  v1 = *(_DWORD *)(result + 4904);
  if ( v1 )
  {
    v2 = result;
    if ( v1 >= 1 )
    {
      v3 = 0LL;
      do
      {
        v4 = 8 * v3;
        sub_632F298(*(_QWORD *)(*(_QWORD *)(v2 + 4912) + 8 * v3));
        v5 = *(int *)(v2 + 4904);
        ++v3;
        *(_QWORD *)(*(_QWORD *)(v2 + 4912) + v4) = 0LL;
      }
      while ( v3 < v5 );
    }
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6CA6308[0])(*(_QWORD *)(v2 + 4912));
    *(_QWORD *)(v2 + 4912) = 0LL;
    *(_DWORD *)(v2 + 4904) = 0;
  }
  return result;
}


================================================================================
Function: sub_633ED08 (0x633ED08)
================================================================================

__int64 sub_633ED08()
{
  __int64 (*v0)(void); // x3

  v0 = *(__int64 (**)(void))((char *)off_50 + off_6CA6898);
  if ( v0 )
    return v0();
  else
    return 4LL;
}


================================================================================
Function: sub_63A1F90 (0x63A1F90)
================================================================================

long double __fastcall sub_63A1F90(__int64 a1)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_WORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 116) = 0;
  *(_QWORD *)a1 = "RbxStorage";
  *(_QWORD *)(a1 + 8) = 10LL;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 97) = 0u;
  *(_QWORD *)(a1 + 120) = 0LL;
  *(_BYTE *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0LL;
  *(_QWORD *)(a1 + 144) = 0LL;
  *(_QWORD *)(a1 + 152) = 0LL;
  *(_QWORD *)(a1 + 160) = 0LL;
  *(_QWORD *)(a1 + 168) = 0LL;
  *(_QWORD *)(a1 + 176) = 0LL;
  *(_QWORD *)(a1 + 184) = 0LL;
  *(_QWORD *)(a1 + 192) = 0LL;
  return result;
}


================================================================================
Function: sub_648B444 (0x648B444)
================================================================================

size_t __usercall sub_648B444@<X0>(__int128 *a1@<X0>, unsigned __int64 *a2@<X8>)
{
  size_t v3; // x22
  unsigned __int64 v4; // x8
  bool v5; // zf
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x11
  char *v8; // x4
  char *v9; // x8
  char *v10; // x9
  unsigned __int64 v11; // x11
  __int64 v12; // x12
  __int64 v13; // x14
  char *v14; // x5
  size_t v15; // x22
  unsigned __int64 v16; // x8
  bool v17; // zf
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x11
  char *v20; // x4
  char *v21; // x8
  char *v22; // x9
  unsigned __int64 v23; // x11
  __int64 v24; // x12
  __int64 v25; // x14
  char *v26; // x5
  size_t v27; // x22
  size_t result; // x0
  unsigned __int64 v29; // x8
  bool v30; // zf
  unsigned __int64 v31; // x8
  unsigned __int64 v32; // x11
  char *v33; // x4
  char *v34; // x8
  char *v35; // x9
  unsigned __int64 v36; // x11
  __int64 v37; // x12
  __int64 v38; // x14
  char *v39; // x5

  sub_68497A0(a2, a1);
  v3 = __strlen_chk(" ", 2uLL);
  __strlen_chk("\\ ", 3uLL);
  v4 = *(unsigned __int8 *)a2;
  v5 = (v4 & 1) == 0;
  v6 = v4 >> 1;
  if ( v5 )
    v7 = v6;
  else
    v7 = a2[1];
  if ( v5 )
    v8 = (char *)a2 + 1;
  else
    v8 = (char *)a2[2];
  if ( v7 && v3 )
  {
    v9 = &asc_B57FE3[v3];
    v10 = &v8[v7];
    v11 = v7 - 1;
    while ( 2 )
    {
      v12 = 0LL;
      do
      {
        if ( v8[v12] != asc_B57FE3[v12] )
        {
          v14 = &v8[v12];
          if ( &asc_B57FE3[v12] == v9 )
            goto LABEL_20;
          goto LABEL_18;
        }
        v13 = v12 + 1;
        if ( v11 == v12 )
          break;
        v5 = v3 - 1 == v12++;
      }
      while ( !v5 );
      v14 = &v8[v13];
      if ( &asc_B57FE3[v13] == v9 )
      {
LABEL_20:
        if ( v8 != v14 )
          sub_2D6A56C((int)a2);
        break;
      }
LABEL_18:
      ++v8;
      --v11;
      if ( v8 != v10 )
        continue;
      break;
    }
  }
  v15 = __strlen_chk(",", 2uLL);
  __strlen_chk("\\,", 3uLL);
  v16 = *(unsigned __int8 *)a2;
  v17 = (v16 & 1) == 0;
  v18 = v16 >> 1;
  if ( v17 )
    v19 = v18;
  else
    v19 = a2[1];
  if ( v17 )
    v20 = (char *)a2 + 1;
  else
    v20 = (char *)a2[2];
  if ( v19 && v15 )
  {
    v21 = &asc_BAB20D[v15];
    v22 = &v20[v19];
    v23 = v19 - 1;
    while ( 2 )
    {
      v24 = 0LL;
      do
      {
        if ( v20[v24] != asc_BAB20D[v24] )
        {
          v26 = &v20[v24];
          if ( &asc_BAB20D[v24] == v21 )
            goto LABEL_41;
          goto LABEL_39;
        }
        v25 = v24 + 1;
        if ( v23 == v24 )
          break;
        v5 = v15 - 1 == v24++;
      }
      while ( !v5 );
      v26 = &v20[v25];
      if ( &asc_BAB20D[v25] == v21 )
      {
LABEL_41:
        if ( v20 != v26 )
          sub_2D6A56C((int)a2);
        break;
      }
LABEL_39:
      ++v20;
      --v23;
      if ( v20 != v22 )
        continue;
      break;
    }
  }
  v27 = __strlen_chk("=", 2uLL);
  result = __strlen_chk("\\=", 3uLL);
  v29 = *(unsigned __int8 *)a2;
  v30 = (v29 & 1) == 0;
  v31 = v29 >> 1;
  if ( v30 )
    v32 = v31;
  else
    v32 = a2[1];
  if ( v30 )
    v33 = (char *)a2 + 1;
  else
    v33 = (char *)a2[2];
  if ( v32 && v27 )
  {
    v34 = &asc_C211EE[v27];
    v35 = &v33[v32];
    v36 = v32 - 1;
    while ( 2 )
    {
      v37 = 0LL;
      do
      {
        if ( v33[v37] != asc_C211EE[v37] )
        {
          v39 = &v33[v37];
          if ( &asc_C211EE[v37] == v34 )
            goto LABEL_62;
          goto LABEL_60;
        }
        v38 = v37 + 1;
        if ( v36 == v37 )
          break;
        v5 = v27 - 1 == v37++;
      }
      while ( !v5 );
      v39 = &v33[v38];
      if ( &asc_C211EE[v38] == v34 )
      {
LABEL_62:
        if ( v33 != v39 )
          return sub_2D6A56C((int)a2);
        return result;
      }
LABEL_60:
      ++v33;
      --v36;
      if ( v33 != v35 )
        continue;
      break;
    }
  }
  return result;
}


================================================================================
Function: sub_648B7F4 (0x648B7F4)
================================================================================

__int64 __fastcall sub_648B7F4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x9
  __int64 v3; // x8
  unsigned __int64 v4; // x10
  size_t v5; // x19
  const char *v6; // x21
  unsigned __int8 *v7; // x20
  unsigned __int64 v8; // x22
  char *v9; // x0
  char *v10; // x23

  v2 = *a2;
  v3 = *((_QWORD *)a2 + 1);
  if ( (v2 & 1) == 0 )
    v3 = v2 >> 1;
  if ( !v3 )
    return 1LL;
  v4 = *a1;
  if ( (v4 & 1) != 0 )
    v5 = *((_QWORD *)a1 + 1);
  else
    v5 = v4 >> 1;
  if ( v5 )
  {
    v6 = (v2 & 1) != 0 ? (const char *)*((_QWORD *)a2 + 2) : (const char *)(a2 + 1);
    v7 = (v4 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a1 + 2) : a1 + 1;
    if ( v3 >= 1 )
    {
      v8 = (unsigned __int64)&v6[v3];
      while ( 1 )
      {
        v9 = strchr(v6, 59);
        v10 = v9 ? v9 : (char *)v8;
        if ( v5 == (_DWORD)v10 - (_DWORD)v6 && (!((v10 - v6) << 32) || !memcmp(v6, v7, v5)) )
          break;
        v6 = v10 + 1;
        if ( (unsigned __int64)(v10 + 1) >= v8 )
          return 0LL;
      }
      return 1LL;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_648B910 (0x648B910)
================================================================================

__int64 __fastcall sub_648B910(__int64 a1, _BYTE *a2, __int64 a3)
{
  __int64 v4; // x20
  __int64 v7; // x1

  v4 = a3;
  sub_6601820(a1, a3 + 10);
  sub_6601588(a1, 34LL);
  for ( ; v4; ++a2 )
  {
    v7 = (unsigned __int8)*a2;
    if ( !*a2 )
      break;
    if ( (unsigned __int8)(v7 - 127) < 0xA1u )
    {
      v7 = 32LL;
    }
    else if ( (_DWORD)v7 == 92 || (_DWORD)v7 == 34 )
    {
      sub_6601588(a1, 92LL);
      v7 = (unsigned __int8)*a2;
    }
    sub_6601588(a1, v7);
    --v4;
  }
  return sub_6601588(a1, 34LL);
}


================================================================================
Function: sub_648B9B0 (0x648B9B0)
================================================================================

__int64 __fastcall sub_648B9B0(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x9
  bool v3; // zf
  unsigned __int64 v4; // x9
  _BYTE *v5; // x1
  __int64 v6; // x2

  v2 = *a2;
  v3 = (v2 & 1) == 0;
  if ( (v2 & 1) != 0 )
    v4 = *((_QWORD *)a2 + 1);
  else
    v4 = v2 >> 1;
  if ( v3 )
    v5 = a2 + 1;
  else
    v5 = (_BYTE *)*((_QWORD *)a2 + 2);
  if ( v4 >= 0xF000 )
    v6 = 61440LL;
  else
    v6 = v4;
  return sub_648B910(a1, v5, v6);
}


================================================================================
Function: sub_648BA6C (0x648BA6C)
================================================================================

long double __fastcall sub_648BA6C(__int64 a1)
{
  long double result; // q0
  __int64 v3; // x8
  long double v4; // [xsp+0h] [xbp-20h] BYREF
  __int64 v5; // [xsp+10h] [xbp-10h]

  sub_65F13AC("%di", &v4);
  if ( (*(_BYTE *)a1 & 1) != 0 )
    sub_65ECAF4();
  result = v4;
  v3 = v5;
  *(long double *)a1 = v4;
  *(_QWORD *)(a1 + 16) = v3;
  return result;
}


================================================================================
Function: sub_648BC4C (0x648BC4C)
================================================================================

unsigned __int8 *__fastcall sub_648BC4C(unsigned __int8 *result)
{
  int v1; // w8
  __int64 i; // x8
  int v3; // w11
  bool v4; // cf
  bool v5; // cf

  if ( result )
  {
    v1 = *result;
    if ( (unsigned int)(v1 - 48) < 0xA || (unsigned int)(v1 - 65) < 0x1A || (unsigned int)(v1 - 97) <= 0x19 )
    {
      for ( i = 1LL; ; ++i )
      {
        v3 = result[i];
        v4 = (unsigned int)(v3 - 48) >= 0xA && (unsigned int)(v3 - 65) >= 0x1A;
        v5 = v4 && (unsigned int)(v3 - 97) >= 0x1A;
        if ( v5 && ((unsigned int)(v3 - 37) > 0x3A || ((1LL << ((unsigned __int8)v3 - 37)) & 0x400000000200701LL) == 0) )
          break;
      }
      return (unsigned __int8 *)((v3 == 0) & (unsigned __int8)((unsigned int)i < 0x81));
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}


================================================================================
Function: sub_648BE34 (0x648BE34)
================================================================================

__int64 __fastcall sub_648BE34(__int64 a1, signed int a2, int a3)
{
  __int64 v6; // x0
  signed int v7; // w8
  bool v8; // w8

  v6 = sub_25F4F30(a1, 0LL);
  *(_QWORD *)(a1 + 392) = 0LL;
  *(_QWORD *)(a1 + 400) = 0LL;
  *(_QWORD *)(a1 + 408) = 0LL;
  *(_DWORD *)(a1 + 416) = a3;
  if ( a2 == -1 )
  {
    v8 = 1;
  }
  else
  {
    v7 = dword_6CA8E70;
    if ( dword_6CA8E70 == -1 )
    {
      v6 = sub_65F1790(v6);
      v7 = (unsigned int)v6 % 0x2710;
      dword_6CA8E70 = (unsigned int)v6 % 0x2710;
    }
    v8 = v7 < a2;
  }
  *(_BYTE *)(a1 + 420) = v8;
  *(_QWORD *)(a1 + 432) = 0LL;
  *(_QWORD *)(a1 + 440) = 0LL;
  *(_QWORD *)(a1 + 424) = 0LL;
  *(_DWORD *)(a1 + 452) = 0;
  return sub_65ADBD0(v6);
}


================================================================================
Function: sub_648BF18 (0x648BF18)
================================================================================

__int64 __usercall sub_648BF18@<X0>(
        unsigned __int8 *a1@<X0>,
        __int64 a2@<X1>,
        unsigned __int8 *a3@<X2>,
        int a4@<W3>,
        unsigned __int64 *a5@<X8>)
{
  unsigned __int8 v8; // w9
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x8
  bool v11; // zf
  size_t v12; // x8
  void *v13; // x1
  size_t v14; // x2
  unsigned __int64 v15; // x8
  bool v16; // zf
  size_t v17; // x8
  __int128 *v18; // x8
  char *v19; // x1
  size_t v20; // x2
  __int64 v21; // x0
  unsigned __int8 *v22; // x0
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x8
  _QWORD *v25; // x0
  __int64 v26; // x0
  __int128 *v27; // x1
  size_t v28; // x2
  _QWORD *v29; // x0
  __int64 v30; // x0
  char *v31; // x1
  size_t v32; // x2
  __int64 v33; // x0
  char *v34; // x1
  size_t v35; // x2
  __int64 v36; // x0
  char *v37; // x1
  size_t v38; // x2
  __int64 v39; // x0
  char *v40; // x1
  size_t v41; // x2
  unsigned __int64 *v42; // x0
  unsigned __int64 v43; // x8
  char *v44; // x1
  size_t v45; // x2
  unsigned __int64 v46; // x8
  char v47; // w21
  size_t v48; // x2
  unsigned __int64 v49; // x8
  unsigned __int8 *v50; // x8
  unsigned __int8 *v51; // x1
  unsigned __int64 v52; // x9
  int v53; // w10
  int v54; // t1
  int v55; // t1
  __int128 *v57; // x1
  size_t v58; // x2
  __int128 *v59; // x1
  size_t v60; // x2
  __int64 v61; // x0
  unsigned __int64 v62; // x8
  unsigned __int64 v63; // x8
  char *v64; // x1
  size_t v65; // x2
  int v66; // w21
  unsigned __int64 v67; // x8
  unsigned __int64 v68; // x8
  __int128 *v69; // x1
  size_t v70; // x2
  __int64 v71; // x0
  unsigned __int64 v72; // x8
  char *v73; // x1
  size_t v74; // x2
  char v75; // w0
  char v76; // w9
  int v77; // w21
  size_t v78; // x10
  unsigned __int64 v79; // x8
  __int64 v80; // x11
  size_t v81; // x2
  unsigned __int64 v82; // x9
  unsigned __int8 *v83; // x9
  const char *v84; // x0
  unsigned __int8 *v85; // x1
  unsigned __int64 v86; // x8
  int v87; // w10
  int v88; // t1
  int v89; // w11
  int v90; // t1
  __int64 v92; // x0
  unsigned __int64 v93; // x8
  __int128 *v94; // x1
  size_t v95; // x2
  unsigned __int64 v96; // x8
  __int128 *v97; // x1
  size_t v98; // x2
  char *v99; // x1
  size_t v100; // x2
  unsigned __int64 *v101; // x0
  char *v102; // x0
  char *v103; // x0
  unsigned __int64 *v104; // x0
  unsigned __int64 v105; // x8
  char *v106; // x1
  size_t v107; // x2
  unsigned __int64 v108; // x8
  char *v109; // x22
  size_t v110; // x0
  unsigned __int64 v111; // x8
  unsigned __int8 v112; // w8
  __int64 **i; // x21
  unsigned __int64 v114; // x8
  unsigned __int64 v115; // x8
  unsigned __int64 v116; // x8
  bool v117; // zf
  unsigned __int64 v118; // x8
  char *v119; // x1
  size_t v120; // x2
  __int128 *v121; // x1
  size_t v122; // x2
  __int128 *v123; // x8
  char *v124; // x1
  size_t v125; // x2
  __int64 v126; // x22
  _QWORD *v127; // x8
  _QWORD *v128; // x28
  unsigned int v129; // w9
  unsigned int *v130; // x21
  int v131; // w10
  unsigned int v132; // w11
  __int64 v133; // x13
  _QWORD *v134; // x24
  char *v135; // x1
  size_t v136; // x2
  int v137; // w8
  unsigned __int64 v138; // x9
  char *v139; // x1
  size_t v140; // x2
  __int64 **j; // x22
  unsigned __int64 v142; // x8
  bool v143; // zf
  size_t v144; // x8
  __int64 *v145; // x1
  size_t v146; // x2
  unsigned __int64 v147; // x8
  bool v148; // zf
  size_t v149; // x8
  __int64 *v150; // x1
  size_t v151; // x2
  unsigned __int64 v152; // x8
  bool v153; // zf
  unsigned __int64 v154; // x8
  const char *v155; // x24
  unsigned __int64 v156; // x10
  size_t v157; // x0
  size_t v158; // x25
  char *v159; // x22
  unsigned __int64 v160; // x27
  const char *v161; // x0
  const char *v162; // x0
  __int64 v163; // x0
  _QWORD *v164; // x22
  _QWORD *v165; // x8
  unsigned int v166; // w9
  int v167; // w10
  unsigned int v168; // w11
  _QWORD *v169; // x13
  _QWORD *v170; // x24
  unsigned __int64 v171; // x9
  const char *v172; // x0
  unsigned int v173; // w8
  unsigned __int64 v174; // x9
  const char *v175; // x8
  const char *v176; // x25
  size_t v177; // x0
  size_t v178; // x24
  char *v179; // x22
  unsigned __int64 v180; // x9
  const char *v181; // x0
  unsigned int v182; // w8
  unsigned __int64 v183; // x27
  const char *v184; // x0
  char *v185; // x1
  size_t v186; // x2
  bool v187; // zf
  size_t v188; // x8
  size_t v189; // x2
  char *v190; // x1
  bool v191; // zf
  size_t v192; // x8
  size_t v193; // x2
  char *v194; // x1
  _QWORD *v195; // x0
  __int64 v196; // x0
  unsigned __int64 v197; // x8
  unsigned __int64 v198; // x9
  const char *v199; // x0
  unsigned int v200; // w8
  bool v201; // zf
  size_t v202; // x8
  size_t v203; // x2
  char *v204; // x1
  char v205; // w9
  int v206; // w24
  size_t v207; // x10
  unsigned __int64 v208; // x8
  __int64 v209; // x11
  size_t v210; // x2
  unsigned __int64 v211; // x9
  unsigned __int8 *v212; // x9
  unsigned __int8 *v213; // x1
  unsigned __int64 v214; // x8
  int v215; // w10
  int v216; // t1
  int v217; // w11
  int v218; // t1
  __int64 v220; // x0
  __int64 v221; // x0
  unsigned __int64 v222; // x9
  char *v223; // x1
  size_t v224; // x2
  unsigned __int64 v225; // x8
  char *v226; // x1
  size_t v227; // x2
  unsigned __int64 v228; // x8
  __int64 v229; // x0
  unsigned __int64 v230; // x8
  int v231; // w9
  unsigned __int64 v232; // x10
  unsigned __int64 v233; // x11
  char *v234; // x1
  size_t v235; // x2
  char v236; // w9
  int v237; // w24
  size_t v238; // x10
  unsigned __int64 v239; // x8
  __int64 v240; // x11
  size_t v241; // x2
  unsigned __int64 v242; // x9
  unsigned __int8 *v243; // x9
  unsigned __int8 *v244; // x1
  unsigned __int64 v245; // x8
  int v246; // w10
  int v247; // t1
  int v248; // w11
  int v249; // t1
  unsigned __int64 v251; // x8
  char *v252; // x1
  size_t v253; // x2
  unsigned __int64 v254; // x8
  char *v255; // x1
  size_t v256; // x2
  char *v257; // x1
  size_t v258; // x2
  char *v259; // x1
  size_t v260; // x2
  __int64 v261; // x0
  char *v262; // x1
  size_t v263; // x2
  unsigned __int64 v264; // x8
  char *v265; // x1
  size_t v266; // x2
  char *v267; // x1
  size_t v268; // x2
  char *v269; // x1
  size_t v270; // x2
  __int64 v271; // x0
  __int64 v272; // x4
  __int64 v273; // x5
  __int64 v274; // x6
  __int64 v275; // x7
  long double v276; // q0
  long double v277; // q1
  long double v278; // q2
  long double v279; // q3
  int v280; // w8
  unsigned int v281; // w10
  unsigned __int8 *v282; // x9
  unsigned int v283; // w11
  _QWORD *v284; // x13
  unsigned __int8 *v285; // x21
  unsigned __int8 *v286; // x22
  unsigned int v287; // w11
  unsigned __int64 v288; // x13
  unsigned __int64 v289; // x14
  unsigned __int64 v290; // x12
  __int64 v291; // x13
  bool v292; // zf
  unsigned int v293; // w8
  unsigned __int8 *v294; // x23
  unsigned __int64 v295; // x8
  bool v296; // zf
  size_t v297; // x8
  void *v298; // x1
  size_t v299; // x2
  unsigned __int64 v300; // x9
  char *v301; // x10
  char *v302; // x8
  _BYTE *v303; // x12
  unsigned __int64 v304; // x13
  unsigned __int64 v305; // d0
  __int128 v306; // q0
  const char *v307; // x8
  char *v308; // x1
  size_t v309; // x2
  unsigned __int64 v310; // x9
  unsigned __int64 v311; // x10
  unsigned __int64 v312; // x8
  unsigned __int8 *v313; // x9
  unsigned __int8 *v314; // x10
  char *v315; // x9
  __int64 v316; // x1
  __int64 v317; // x3
  char *v318; // x1
  size_t v319; // x2
  char *v320; // x1
  size_t v321; // x2
  __int64 result; // x0
  __int64 v323; // [xsp+0h] [xbp-180h]
  _QWORD *v326; // [xsp+28h] [xbp-158h]
  __int128 *v327; // [xsp+30h] [xbp-150h]
  unsigned __int64 v328[2]; // [xsp+38h] [xbp-148h] BYREF
  char v329; // [xsp+50h] [xbp-130h] BYREF
  char v330[12]; // [xsp+51h] [xbp-12Fh] BYREF
  __int128 v331; // [xsp+68h] [xbp-118h] BYREF
  char *v332; // [xsp+78h] [xbp-108h]
  unsigned __int64 v333[2]; // [xsp+80h] [xbp-100h] BYREF
  unsigned __int64 v334[2]; // [xsp+98h] [xbp-E8h] BYREF
  _BYTE v335[16]; // [xsp+B0h] [xbp-D0h] BYREF
  unsigned __int64 v336[2]; // [xsp+C8h] [xbp-B8h] BYREF
  __int64 v337; // [xsp+E0h] [xbp-A0h] BYREF
  size_t v338; // [xsp+E8h] [xbp-98h]
  const char *v339; // [xsp+F0h] [xbp-90h]
  unsigned __int64 v340[2]; // [xsp+F8h] [xbp-88h] BYREF
  unsigned __int64 v341[2]; // [xsp+110h] [xbp-70h] BYREF
  __int128 v342; // [xsp+128h] [xbp-58h] BYREF
  char *v343; // [xsp+138h] [xbp-48h]
  __int128 v344; // [xsp+140h] [xbp-40h] BYREF
  const char *v345; // [xsp+150h] [xbp-30h]

  v8 = atomic_load(byte_6FF17C0);
  if ( (v8 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6FF17C0) )
  {
    qword_6FF1780 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6FF1788);
    qword_6FF17B0 = 0LL;
    unk_6FF17B8 = 0LL;
    qword_6FF1780 = (__int64)off_6C1C590;
    qword_6FF17C8 = (__int64)&qword_6FF1780;
    sub_6862850(byte_6FF17C0);
  }
  v327 = (__int128 *)sub_6285D50(&qword_6FF1780);
  a5[1] = 0LL;
  a5[2] = 0LL;
  *a5 = 0LL;
  sub_6601820(a5, 0x400uLL);
  if ( !byte_724A7A8 || !byte_72400A8 )
    goto LABEL_13;
  v9 = qword_6FF5558;
  if ( (word_6FF5550 & 1) == 0 )
    v9 = (unsigned __int64)(unsigned __int8)word_6FF5550 >> 1;
  if ( v9 )
  {
    sub_684A544(a5, "romark-");
    v10 = *a1;
    v11 = (v10 & 1) == 0;
    v12 = v10 >> 1;
    if ( v11 )
      v13 = a1 + 1;
    else
      v13 = (void *)*((_QWORD *)a1 + 2);
    if ( v11 )
      v14 = v12;
    else
      v14 = *((_QWORD *)a1 + 1);
  }
  else
  {
LABEL_13:
    v15 = *a1;
    v16 = (v15 & 1) == 0;
    v17 = v15 >> 1;
    if ( v16 )
      v13 = a1 + 1;
    else
      v13 = (void *)*((_QWORD *)a1 + 2);
    if ( v16 )
      v14 = v17;
    else
      v14 = *((_QWORD *)a1 + 1);
  }
  sub_65FFB9C(a5, v13, v14);
  sub_684A544(a5, ",");
  v18 = v327;
  if ( v327 )
    v18 = (__int128 *)*((_QWORD *)v327 + 6);
  sub_68497A0((unsigned __int64 *)&v344, v18 + 1);
  if ( (v344 & 1) != 0 )
    v19 = (char *)v345;
  else
    v19 = (char *)&v344 + 1;
  if ( (v344 & 1) != 0 )
    v20 = *((_QWORD *)&v344 + 1);
  else
    v20 = (unsigned __int64)(unsigned __int8)v344 >> 1;
  v21 = (__int64)sub_65FFB9C(a5, v19, v20);
  if ( (v344 & 1) != 0 )
    v21 = sub_65ECAF4();
  v22 = (unsigned __int8 *)sub_64994C0(v21);
  v23 = *v22;
  if ( (v23 & 1) != 0 )
    v24 = *((_QWORD *)v22 + 1);
  else
    v24 = v23 >> 1;
  if ( v24 )
  {
    v25 = sub_684A544(a5, ",baseurl=");
    v26 = sub_64994C0(v25);
    sub_648B444(&v344, v26);
    v27 = (v344 & 1) != 0 ? (__int128 *)v345 : (__int128 *)((char *)&v344 + 1);
    v28 = (v344 & 1) != 0 ? *((_QWORD *)&v344 + 1) : (unsigned __int64)(unsigned __int8)v344 >> 1;
    sub_65FFB9C(a5, v27, v28);
    if ( (v344 & 1) != 0 )
      sub_65ECAF4();
  }
  v29 = sub_684A544(a5, ",channel=");
  v30 = sub_6499074(v29);
  sub_648B444(&v344, v30);
  if ( (v344 & 1) != 0 )
    v31 = (char *)v345;
  else
    v31 = (char *)&v344 + 1;
  if ( (v344 & 1) != 0 )
    v32 = *((_QWORD *)&v344 + 1);
  else
    v32 = (unsigned __int64)(unsigned __int8)v344 >> 1;
  v33 = (__int64)sub_65FFB9C(a5, v31, v32);
  if ( (v344 & 1) != 0 )
    v33 = sub_65ECAF4();
  if ( (sub_649525C(v33) & 1) != 0 )
  {
    v344 = 0uLL;
    v345 = 0LL;
    if ( (sub_64952FC() & 1) != 0 )
    {
      sub_65B6B3C(&v342, 3LL);
      if ( (v344 & 1) != 0 )
        sub_65ECAF4();
      v344 = v342;
      v345 = v343;
      sub_684A544(a5, ",datacenterid=");
      if ( (v344 & 1) != 0 )
        v34 = (char *)v345;
      else
        v34 = (char *)&v344 + 1;
      if ( (v344 & 1) != 0 )
        v35 = *((_QWORD *)&v344 + 1);
      else
        v35 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      v36 = (__int64)sub_65FFB9C(a5, v34, v35);
    }
    else
    {
      sub_684A544(a5, ",datacenterid=");
      sub_65F13AC("%d", &v342);
      if ( (v342 & 1) != 0 )
        v40 = v343;
      else
        v40 = (char *)&v342 + 1;
      if ( (v342 & 1) != 0 )
        v41 = *((_QWORD *)&v342 + 1);
      else
        v41 = (unsigned __int64)(unsigned __int8)v342 >> 1;
      v36 = (__int64)sub_65FFB9C(a5, v40, v41);
      if ( (v342 & 1) != 0 )
        v36 = sub_65ECAF4();
    }
    v42 = (unsigned __int64 *)sub_64952BC(v36);
    if ( ((unsigned __int8)v42 & 1) != 0 )
    {
      if ( (v344 & 1) != 0 )
        v43 = *((_QWORD *)&v344 + 1);
      else
        v43 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      if ( !v43 )
      {
        sub_65B6B3C(&v342, 3LL);
        if ( (v344 & 1) != 0 )
          sub_65ECAF4();
        v344 = v342;
        v345 = v343;
      }
      sub_684A544(a5, ",datacenterid_fromcontext=");
      if ( (v344 & 1) != 0 )
        v44 = (char *)v345;
      else
        v44 = (char *)&v344 + 1;
      if ( (v344 & 1) != 0 )
        v45 = *((_QWORD *)&v344 + 1);
      else
        v45 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      v42 = sub_65FFB9C(a5, v44, v45);
    }
    v39 = sub_649533C(v42);
    if ( (v39 & 1) != 0 )
    {
      if ( (v344 & 1) != 0 )
        v46 = *((_QWORD *)&v344 + 1);
      else
        v46 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      if ( !v46 )
      {
        sub_65B6BB0(&v342, 3LL);
        if ( (v344 & 1) != 0 )
          sub_65ECAF4();
        v344 = v342;
        v345 = v343;
      }
      v39 = (__int64)sub_684BDC8(&v342, (unsigned int)dword_6CA8E8C);
      v47 = v342;
      if ( (v344 & 1) != 0 )
        v48 = *((_QWORD *)&v344 + 1);
      else
        v48 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      v49 = (unsigned __int64)(unsigned __int8)v342 >> 1;
      if ( (v342 & 1) != 0 )
        v49 = *((_QWORD *)&v342 + 1);
      if ( v48 == v49 )
      {
        v50 = (unsigned __int8 *)&v344 + 1;
        if ( (v344 & 1) != 0 )
          v39 = (__int64)v345;
        else
          v39 = (__int64)&v344 + 1;
        if ( (v342 & 1) != 0 )
          v51 = (unsigned __int8 *)v343;
        else
          v51 = (unsigned __int8 *)&v342 + 1;
        if ( (v344 & 1) != 0 )
        {
          if ( v48 )
            v39 = memcmp((const void *)v39, v51, v48);
        }
        else if ( v48 )
        {
          v52 = ((unsigned __int64)(unsigned __int8)v344 >> 1) - 1;
          do
          {
            v54 = *v50++;
            v53 = v54;
            v55 = *v51++;
          }
          while ( v53 == v55 && v52-- != 0 );
        }
      }
      if ( (v47 & 1) != 0 )
        v39 = sub_65ECAF4();
      if ( (v344 & 1) == 0 )
        goto LABEL_123;
    }
    else if ( (v344 & 1) == 0 )
    {
      goto LABEL_123;
    }
    v39 = sub_65ECAF4();
    goto LABEL_123;
  }
  sub_684A544(a5, ",datacenterid=");
  sub_65F13AC("%d", &v344);
  if ( (v344 & 1) != 0 )
    v37 = (char *)v345;
  else
    v37 = (char *)&v344 + 1;
  if ( (v344 & 1) != 0 )
    v38 = *((_QWORD *)&v344 + 1);
  else
    v38 = (unsigned __int64)(unsigned __int8)v344 >> 1;
  v39 = (__int64)sub_65FFB9C(a5, v37, v38);
  if ( (v344 & 1) != 0 )
    v39 = sub_65ECAF4();
LABEL_123:
  if ( byte_724A7A8 && byte_6FF5660 )
  {
    if ( dword_6CA8E90 != 0x80000000 )
    {
      sub_684A544(a5, ",serverpartitionid=");
      sub_65F13AC("%d", &v344);
      v57 = (v344 & 1) != 0 ? (__int128 *)v345 : (__int128 *)((char *)&v344 + 1);
      v58 = (v344 & 1) != 0 ? *((_QWORD *)&v344 + 1) : (unsigned __int64)(unsigned __int8)v344 >> 1;
      v39 = (__int64)sub_65FFB9C(a5, v57, v58);
      if ( (v344 & 1) != 0 )
        v39 = sub_65ECAF4();
    }
    if ( dword_6CA8E94 != 0x80000000 )
    {
      sub_684A544(a5, ",gameinstanceisolationtag=");
      sub_65F13AC("%d", &v344);
      v59 = (v344 & 1) != 0 ? (__int128 *)v345 : (__int128 *)((char *)&v344 + 1);
      v60 = (v344 & 1) != 0 ? *((_QWORD *)&v344 + 1) : (unsigned __int64)(unsigned __int8)v344 >> 1;
      v39 = (__int64)sub_65FFB9C(a5, v59, v60);
      if ( (v344 & 1) != 0 )
        v39 = sub_65ECAF4();
    }
  }
  if ( (sub_649525C(v39) & 1) != 0 )
  {
    v344 = 0uLL;
    v345 = 0LL;
    v61 = sub_64952FC();
    if ( (v61 & 1) == 0 )
      goto LABEL_179;
    v61 = (__int64)sub_65B6B3C(&v342, 2LL);
    if ( (v344 & 1) != 0 )
      v61 = sub_65ECAF4();
    v344 = v342;
    v62 = qword_6FF5510;
    if ( (word_6FF5508 & 1) == 0 )
      v62 = (unsigned __int64)(unsigned __int8)word_6FF5508 >> 1;
    v345 = v343;
    if ( v62
      && ((v344 & 1) != 0 ? (v63 = *((_QWORD *)&v344 + 1)) : (v63 = (unsigned __int64)(unsigned __int8)v344 >> 1),
          v63 && (v61 = sub_648B7F4(&v344, &word_6FF5508), (v61 & 1) != 0)) )
    {
      sub_684A544(a5, ",selecteduniverseid=");
      sub_648B444(&v342, &v344);
      if ( (v342 & 1) != 0 )
        v64 = v343;
      else
        v64 = (char *)&v342 + 1;
      if ( (v342 & 1) != 0 )
        v65 = *((_QWORD *)&v342 + 1);
      else
        v65 = (unsigned __int64)(unsigned __int8)v342 >> 1;
      v61 = (__int64)sub_65FFB9C(a5, v64, v65);
      if ( (v342 & 1) != 0 )
        v61 = sub_65ECAF4();
      v66 = 1;
    }
    else
    {
LABEL_179:
      v66 = 0;
    }
    v71 = sub_64952BC(v61);
    if ( (v71 & 1) == 0 )
      goto LABEL_199;
    if ( (v344 & 1) != 0 )
      v72 = *((_QWORD *)&v344 + 1);
    else
      v72 = (unsigned __int64)(unsigned __int8)v344 >> 1;
    if ( v72 )
    {
      if ( !v66 )
      {
LABEL_199:
        v75 = sub_649533C(v71);
        v76 = v344;
        v77 = v344 & 1;
        if ( (v75 & 1) == 0 )
          goto LABEL_233;
        v78 = *((_QWORD *)&v344 + 1);
        v79 = (unsigned __int8)v344 >> 1;
        if ( (v344 & 1) != 0 )
          v80 = *((_QWORD *)&v344 + 1);
        else
          v80 = (unsigned __int8)v344 >> 1;
        if ( !v80 )
        {
          sub_65B6BB0(&v342, 2LL);
          if ( (v344 & 1) != 0 )
            sub_65ECAF4();
          v344 = v342;
          v76 = v342;
          v345 = v343;
          v78 = *((_QWORD *)&v342 + 1);
          v79 = (unsigned __int64)(unsigned __int8)v342 >> 1;
        }
        v77 = v76 & 1;
        if ( (v76 & 1) != 0 )
          v81 = v78;
        else
          v81 = v79;
        v82 = *((_QWORD *)&xmmword_6FF59B0 + 1);
        if ( (xmmword_6FF59B0 & 1) == 0 )
          v82 = (unsigned __int64)(unsigned __int8)xmmword_6FF59B0 >> 1;
        if ( v81 != v82 )
          goto LABEL_233;
        v83 = (unsigned __int8 *)&v344 + 1;
        if ( v77 )
          v84 = v345;
        else
          v84 = (char *)&v344 + 1;
        if ( (xmmword_6FF59B0 & 1) != 0 )
          v85 = (unsigned __int8 *)qword_6FF59C0;
        else
          v85 = (unsigned __int8 *)&xmmword_6FF59B0 + 1;
        if ( !v77 )
        {
          if ( !v81 )
            goto LABEL_235;
          v86 = v79 - 1;
          do
          {
            v88 = *v83++;
            v87 = v88;
            v90 = *v85++;
            v89 = v90;
          }
          while ( v87 == v90 && v86-- != 0 );
          if ( v87 == v89 )
            goto LABEL_235;
          goto LABEL_233;
        }
        if ( v81 && memcmp(v84, v85, v81) )
        {
LABEL_233:
          if ( !v77 )
            goto LABEL_235;
        }
LABEL_234:
        sub_65ECAF4();
        goto LABEL_235;
      }
    }
    else
    {
      v71 = (__int64)sub_65B6B3C(&v342, 2LL);
      if ( (v344 & 1) != 0 )
        v71 = sub_65ECAF4();
      v344 = v342;
      v345 = v343;
      if ( !v66 )
        goto LABEL_199;
    }
    sub_684A544(a5, ",selecteduniverseid_fromcontext=");
    sub_648B444(&v342, &v344);
    if ( (v342 & 1) != 0 )
      v73 = v343;
    else
      v73 = (char *)&v342 + 1;
    if ( (v342 & 1) != 0 )
      v74 = *((_QWORD *)&v342 + 1);
    else
      v74 = (unsigned __int64)(unsigned __int8)v342 >> 1;
    v71 = (__int64)sub_65FFB9C(a5, v73, v74);
    if ( (v342 & 1) != 0 )
      v71 = sub_65ECAF4();
    goto LABEL_199;
  }
  v67 = qword_6FF5510;
  if ( (word_6FF5508 & 1) == 0 )
    v67 = (unsigned __int64)(unsigned __int8)word_6FF5508 >> 1;
  if ( v67 )
  {
    v68 = *((_QWORD *)&xmmword_6FF59B0 + 1);
    if ( (xmmword_6FF59B0 & 1) == 0 )
      v68 = (unsigned __int64)(unsigned __int8)xmmword_6FF59B0 >> 1;
    if ( v68 && (sub_648B7F4(&xmmword_6FF59B0, &word_6FF5508) & 1) != 0 )
    {
      sub_684A544(a5, ",selecteduniverseid=");
      sub_648B444(&v344, &xmmword_6FF59B0);
      v69 = (v344 & 1) != 0 ? (__int128 *)v345 : (__int128 *)((char *)&v344 + 1);
      v70 = (v344 & 1) != 0 ? *((_QWORD *)&v344 + 1) : (unsigned __int64)(unsigned __int8)v344 >> 1;
      sub_65FFB9C(a5, v69, v70);
      if ( (v344 & 1) != 0 )
        goto LABEL_234;
    }
  }
LABEL_235:
  if ( a4 == 4 )
  {
    v92 = (__int64)sub_684A544(a5, ",type=statistic");
  }
  else if ( a4 == 5 )
  {
    v92 = (__int64)sub_684A544(a5, ",type=counter");
  }
  else
  {
    v92 = (__int64)sub_684A544(a5, ",type=event");
  }
  if ( byte_724A7A8 && byte_6FF5530 )
  {
    v93 = qword_6FF5558;
    if ( (word_6FF5550 & 1) == 0 )
      v93 = (unsigned __int64)(unsigned __int8)word_6FF5550 >> 1;
    if ( v93 )
    {
      sub_684A544(a5, ",playtestid=");
      sub_648B444(&v344, &word_6FF5550);
      v94 = (v344 & 1) != 0 ? (__int128 *)v345 : (__int128 *)((char *)&v344 + 1);
      v95 = (v344 & 1) != 0 ? *((_QWORD *)&v344 + 1) : (unsigned __int64)(unsigned __int8)v344 >> 1;
      v92 = (__int64)sub_65FFB9C(a5, v94, v95);
      if ( (v344 & 1) != 0 )
        v92 = sub_65ECAF4();
    }
    v96 = qword_6FF5580;
    if ( (word_6FF5578 & 1) == 0 )
      v96 = (unsigned __int64)(unsigned __int8)word_6FF5578 >> 1;
    if ( v96 )
    {
      sub_684A544(a5, ",runteamcityid=");
      sub_648B444(&v344, &word_6FF5578);
      v97 = (v344 & 1) != 0 ? (__int128 *)v345 : (__int128 *)((char *)&v344 + 1);
      v98 = (v344 & 1) != 0 ? *((_QWORD *)&v344 + 1) : (unsigned __int64)(unsigned __int8)v344 >> 1;
      v92 = (__int64)sub_65FFB9C(a5, v97, v98);
      if ( (v344 & 1) != 0 )
        v92 = sub_65ECAF4();
    }
  }
  if ( (sub_649525C(v92) & 1) != 0 )
  {
    v344 = 0uLL;
    v345 = 0LL;
    if ( (sub_64952FC() & 1) != 0 )
    {
      sub_65B6B3C(&v342, 12LL);
      if ( (v344 & 1) != 0 )
        sub_65ECAF4();
      v344 = v342;
      v345 = v343;
      sub_684A544(a5, ",streamingenabled=");
      if ( (v344 & 1) != 0 )
        v99 = (char *)v345;
      else
        v99 = (char *)&v344 + 1;
      if ( (v344 & 1) != 0 )
        v100 = *((_QWORD *)&v344 + 1);
      else
        v100 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      v101 = sub_65FFB9C(a5, v99, v100);
    }
    else
    {
      sub_684A544(a5, ",streamingenabled=");
      v103 = (char *)sub_64949D8((unsigned int)dword_6FF59E0);
      v101 = sub_684A544(a5, v103);
    }
    v104 = (unsigned __int64 *)sub_64952BC(v101);
    if ( ((unsigned __int8)v104 & 1) != 0 )
    {
      if ( (v344 & 1) != 0 )
        v105 = *((_QWORD *)&v344 + 1);
      else
        v105 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      if ( !v105 )
      {
        sub_65B6B3C(&v342, 12LL);
        if ( (v344 & 1) != 0 )
          sub_65ECAF4();
        v344 = v342;
        v345 = v343;
      }
      sub_684A544(a5, ",streamingenabled_fromcontext=");
      if ( (v344 & 1) != 0 )
        v106 = (char *)v345;
      else
        v106 = (char *)&v344 + 1;
      if ( (v344 & 1) != 0 )
        v107 = *((_QWORD *)&v344 + 1);
      else
        v107 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      v104 = sub_65FFB9C(a5, v106, v107);
    }
    if ( (sub_649533C(v104) & 1) != 0 )
    {
      if ( (v344 & 1) != 0 )
        v108 = *((_QWORD *)&v344 + 1);
      else
        v108 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      if ( !v108 )
      {
        sub_65B6BB0(&v342, 12LL);
        if ( (v344 & 1) != 0 )
          sub_65ECAF4();
        v344 = v342;
        v345 = v343;
      }
      v109 = (char *)sub_64949D8((unsigned int)dword_6FF59E0);
      v110 = strlen(v109);
      if ( (v344 & 1) != 0 )
        v111 = *((_QWORD *)&v344 + 1);
      else
        v111 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      if ( v110 == v111 )
        sub_684A118((int)&v344, 0, -1, v109);
    }
    if ( (v344 & 1) != 0 )
      sub_65ECAF4();
  }
  else
  {
    sub_684A544(a5, ",streamingenabled=");
    v102 = (char *)sub_64949D8((unsigned int)dword_6FF59E0);
    sub_684A544(a5, v102);
  }
  v112 = atomic_load(byte_6D95888);
  if ( (v112 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6D95888) )
  {
    qword_6D95848 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6D95850);
    qword_6D95878 = 0LL;
    unk_6D95880 = 0LL;
    qword_6D95848 = (__int64)off_690F7A8;
    qword_6CB14F8 = (__int64)&qword_6D95848;
    sub_6862850(byte_6D95888);
  }
  v326 = (_QWORD *)sub_3324E40(&qword_6D95848);
  for ( i = *(__int64 ***)(sub_6495824(v326[6]) + 16); i; i = (__int64 **)*i )
  {
    v114 = *((unsigned __int8 *)i + 16);
    if ( (v114 & 1) != 0 )
      v115 = (unsigned __int64)i[3];
    else
      v115 = v114 >> 1;
    if ( v115 != 11 || (unsigned int)sub_684A118((int)i + 16, 0, -1, "application") )
    {
      sub_684A544(a5, ",");
      v116 = *((unsigned __int8 *)i + 16);
      v117 = (v116 & 1) == 0;
      v118 = v116 >> 1;
      v119 = v117 ? (char *)i + 17 : (char *)i[4];
      v120 = v117 ? v118 : (size_t)i[3];
      sub_65FFB9C(a5, v119, v120);
      sub_684A544(a5, "=");
      sub_648B444(&v344, i + 5);
      v121 = (v344 & 1) != 0 ? (__int128 *)v345 : (__int128 *)((char *)&v344 + 1);
      v122 = (v344 & 1) != 0 ? *((_QWORD *)&v344 + 1) : (unsigned __int64)(unsigned __int8)v344 >> 1;
      sub_65FFB9C(a5, v121, v122);
      if ( (v344 & 1) != 0 )
        sub_65ECAF4();
    }
  }
  sub_6601588(a5, 32);
  v123 = v327;
  if ( v327 )
    v123 = (__int128 *)*((_QWORD *)v327 + 6);
  sub_68497A0((unsigned __int64 *)&v344, (__int128 *)((char *)v123 + 40));
  if ( (v344 & 1) != 0 )
    v124 = (char *)v345;
  else
    v124 = (char *)&v344 + 1;
  if ( (v344 & 1) != 0 )
    v125 = *((_QWORD *)&v344 + 1);
  else
    v125 = (unsigned __int64)(unsigned __int8)v344 >> 1;
  sub_65FFB9C(a5, v124, v125);
  if ( (v344 & 1) != 0 )
    sub_65ECAF4();
  LOBYTE(v344) = 16;
  strcpy((char *)&v344 + 1, "location");
  if ( (sub_649334C(a2, (unsigned __int8 *)&v344, &v342) & 1) != 0 )
  {
    v126 = v342;
    v128 = (_QWORD *)(a2 + 8);
    v127 = *(_QWORD **)(a2 + 8);
    v130 = (unsigned int *)(a2 + 16);
    v129 = *(_DWORD *)(a2 + 16);
    v131 = *(_DWORD *)a2 & 1;
  }
  else
  {
    v130 = (unsigned int *)(a2 + 16);
    v129 = *(_DWORD *)(a2 + 16);
    v128 = (_QWORD *)(a2 + 8);
    v127 = *(_QWORD **)(a2 + 8);
    v131 = *(_DWORD *)a2 & 1;
    if ( v131 )
      v132 = 8;
    else
      v132 = *(_DWORD *)(a2 + 16);
    if ( (*(_DWORD *)a2 & 1) != 0 )
      v133 = a2 + 8;
    else
      v133 = *(_QWORD *)(a2 + 8);
    v126 = v133 + 48LL * v132;
  }
  if ( v131 )
  {
    v129 = 8;
    v127 = v128;
  }
  v134 = &v127[6 * v129];
  if ( (v344 & 1) != 0 )
    sub_65ECAF4();
  if ( (_QWORD *)v126 == v134 )
  {
    sub_684A544(a5, ",location=");
    sub_68497A0(v341, &xmmword_6FF5908);
    sub_648E910((__int64 *)&v344, (int)v341);
    if ( (v344 & 1) != 0 )
      v135 = (char *)v345;
    else
      v135 = (char *)&v344 + 1;
    if ( (v344 & 1) != 0 )
      v136 = *((_QWORD *)&v344 + 1);
    else
      v136 = (unsigned __int64)(unsigned __int8)v344 >> 1;
    sub_65FFB9C(a5, v135, v136);
    if ( (v344 & 1) != 0 )
      sub_65ECAF4();
    if ( (v341[0] & 1) != 0 )
      sub_65ECAF4();
  }
  if ( byte_724A7A8 && byte_6FF79A8 )
  {
    sub_65B6B3C(&v344, 7LL);
    v137 = v344 & 1;
    v138 = (unsigned __int64)(unsigned __int8)v344 >> 1;
    if ( v137 )
      v138 = *((_QWORD *)&v344 + 1);
    if ( v138 )
    {
      sub_684A544(a5, ",playSessionId=");
      sub_68497A0(v340, &v344);
      sub_648E910((__int64 *)&v342, (int)v340);
      if ( (v342 & 1) != 0 )
        v139 = v343;
      else
        v139 = (char *)&v342 + 1;
      if ( (v342 & 1) != 0 )
        v140 = *((_QWORD *)&v342 + 1);
      else
        v140 = (unsigned __int64)(unsigned __int8)v342 >> 1;
      sub_65FFB9C(a5, v139, v140);
      if ( (v342 & 1) != 0 )
        sub_65ECAF4();
      if ( (v340[0] & 1) != 0 )
        sub_65ECAF4();
      v137 = v344 & 1;
    }
    if ( v137 )
      sub_65ECAF4();
  }
  for ( j = *(__int64 ***)(sub_649582C(v326[6]) + 16); j; j = (__int64 **)*j )
  {
    sub_684A544(a5, ",");
    v142 = *((unsigned __int8 *)j + 16);
    v143 = (v142 & 1) == 0;
    v144 = v142 >> 1;
    if ( v143 )
      v145 = (__int64 *)((char *)j + 17);
    else
      v145 = j[4];
    if ( v143 )
      v146 = v144;
    else
      v146 = (size_t)j[3];
    sub_65FFB9C(a5, v145, v146);
    sub_684A544(a5, "=");
    v147 = *((unsigned __int8 *)j + 40);
    v148 = (v147 & 1) == 0;
    v149 = v147 >> 1;
    if ( v148 )
      v150 = (__int64 *)((char *)j + 41);
    else
      v150 = j[7];
    if ( v148 )
      v151 = v149;
    else
      v151 = (size_t)j[6];
    sub_65FFB9C(a5, v150, v151);
  }
  v152 = *a3;
  v153 = (v152 & 1) == 0;
  if ( (v152 & 1) != 0 )
    v154 = *((_QWORD *)a3 + 1);
  else
    v154 = v152 >> 1;
  if ( v154 )
  {
    if ( v153 )
      v155 = (const char *)(a3 + 1);
    else
      v155 = (const char *)*((_QWORD *)a3 + 2);
  }
  else
  {
    v156 = qword_6FF5928;
    if ( (qword_6FF5920 & 1) == 0 )
      v156 = (unsigned __int64)(unsigned __int8)qword_6FF5920 >> 1;
    if ( v156 )
    {
      if ( (qword_6FF5920 & 1) != 0 )
        v155 = (const char *)qword_6FF5930;
      else
        v155 = (char *)&qword_6FF5920 + 1;
    }
    else
    {
      v155 = "0";
    }
  }
  v157 = strlen(v155);
  if ( v157 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v158 = v157;
  if ( v157 >= 0x17 )
  {
    v160 = (v157 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v159 = (char *)sub_65ECAAC();
    v338 = v158;
    v339 = v159;
    v337 = v160 | 1;
    goto LABEL_415;
  }
  v159 = (char *)&v337 + 1;
  LOBYTE(v337) = 2 * v157;
  if ( v157 )
LABEL_415:
    memcpy(v159, v155, v158);
  v159[v158] = 0;
  if ( (v337 & 1) != 0 )
    v161 = v339;
  else
    v161 = (char *)&v337 + 1;
  if ( strtoll(v161, 0LL, 10) < 0 )
  {
    sub_684A29C((int)&v337, "-1");
  }
  else
  {
    if ( (v337 & 1) != 0 )
      v162 = v339;
    else
      v162 = (char *)&v337 + 1;
    if ( !strtoll(v162, 0LL, 10) )
      sub_684A29C((int)&v337, "0");
  }
  LOBYTE(v344) = 14;
  strcpy((char *)&v344 + 1, "placeid");
  v163 = sub_649334C(a2, (unsigned __int8 *)&v344, &v342);
  if ( (v163 & 1) != 0 )
  {
    v164 = (_QWORD *)v342;
    v165 = *(_QWORD **)(a2 + 8);
    v166 = *(_DWORD *)(a2 + 16);
    v167 = *(_DWORD *)a2 & 1;
  }
  else
  {
    v166 = *(_DWORD *)(a2 + 16);
    v165 = *(_QWORD **)(a2 + 8);
    v167 = *(_DWORD *)a2 & 1;
    if ( v167 )
      v168 = 8;
    else
      v168 = *(_DWORD *)(a2 + 16);
    if ( (*(_DWORD *)a2 & 1) != 0 )
      v169 = v128;
    else
      v169 = *(_QWORD **)(a2 + 8);
    v164 = &v169[6 * v168];
  }
  if ( v167 )
  {
    v166 = 8;
    v165 = v128;
  }
  v170 = &v165[6 * v166];
  if ( (v344 & 1) != 0 )
    v163 = sub_65ECAF4();
  if ( v164 != v170 )
    goto LABEL_572;
  if ( (sub_649525C(v163) & 1) != 0 )
  {
    v344 = 0uLL;
    v345 = 0LL;
    if ( (sub_64952FC() & 1) != 0 )
    {
      sub_65B6B3C(&v342, 1LL);
      if ( (v344 & 1) != 0 )
        sub_65ECAF4();
      v344 = v342;
      v345 = v343;
      sub_684A544(a5, ",placeid=");
      v171 = *((_QWORD *)&v344 + 1);
      if ( (v344 & 1) == 0 )
        v171 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      if ( v171 && ((v344 & 1) != 0 ? (v172 = v345) : (v172 = (char *)&v344 + 1), strtoll(v172, 0LL, 10) > 0) )
      {
        sub_68497A0((unsigned __int64 *)&v342, &v344);
        v173 = (unsigned __int8)v342;
      }
      else
      {
        v173 = 2;
        BYTE2(v342) = 0;
        LOWORD(v342) = 12290;
      }
      v191 = (v173 & 1) == 0;
      v192 = v173 >> 1;
      if ( v191 )
        v193 = v192;
      else
        v193 = *((_QWORD *)&v342 + 1);
      if ( v191 )
        v194 = (char *)&v342 + 1;
      else
        v194 = v343;
      sub_65FFB9C(a5, v194, v193);
      if ( (v342 & 1) != 0 )
        sub_65ECAF4();
    }
    else
    {
      sub_684A544(a5, ",placeid=");
      if ( (xmmword_6FF5938 & 1) != 0 )
        v180 = *((_QWORD *)&xmmword_6FF5938 + 1);
      else
        v180 = (unsigned __int64)(unsigned __int8)xmmword_6FF5938 >> 1;
      if ( v180
        && ((xmmword_6FF5938 & 1) == 0 ? (v181 = (char *)&xmmword_6FF5938 + 1) : (v181 = (const char *)qword_6FF5948),
            strtoll(v181, 0LL, 10) > 0) )
      {
        sub_68497A0((unsigned __int64 *)&v342, &xmmword_6FF5938);
        v182 = (unsigned __int8)v342;
      }
      else
      {
        v182 = 2;
        BYTE2(v342) = 0;
        LOWORD(v342) = 12290;
      }
      v187 = (v182 & 1) == 0;
      v188 = v182 >> 1;
      if ( v187 )
        v189 = v188;
      else
        v189 = *((_QWORD *)&v342 + 1);
      if ( v187 )
        v190 = (char *)&v342 + 1;
      else
        v190 = v343;
      sub_65FFB9C(a5, v190, v189);
      if ( (v342 & 1) != 0 )
        sub_65ECAF4();
    }
    v195 = sub_684A544(a5, "i");
    v196 = sub_64952BC(v195);
    if ( (v196 & 1) != 0 )
    {
      if ( (v344 & 1) != 0 )
        v197 = *((_QWORD *)&v344 + 1);
      else
        v197 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      if ( !v197 )
      {
        sub_65B6B3C(&v342, 1LL);
        if ( (v344 & 1) != 0 )
          sub_65ECAF4();
        v344 = v342;
        v345 = v343;
      }
      sub_684A544(a5, ",placeid_fromcontext=");
      v198 = *((_QWORD *)&v344 + 1);
      if ( (v344 & 1) == 0 )
        v198 = (unsigned __int64)(unsigned __int8)v344 >> 1;
      if ( v198 && ((v344 & 1) != 0 ? (v199 = v345) : (v199 = (char *)&v344 + 1), strtoll(v199, 0LL, 10) > 0) )
      {
        sub_68497A0((unsigned __int64 *)&v342, &v344);
        v200 = (unsigned __int8)v342;
      }
      else
      {
        v200 = 2;
        BYTE2(v342) = 0;
        LOWORD(v342) = 12290;
      }
      v201 = (v200 & 1) == 0;
      v202 = v200 >> 1;
      if ( v201 )
        v203 = v202;
      else
        v203 = *((_QWORD *)&v342 + 1);
      if ( v201 )
        v204 = (char *)&v342 + 1;
      else
        v204 = v343;
      sub_65FFB9C(a5, v204, v203);
      if ( (v342 & 1) != 0 )
        sub_65ECAF4();
      v196 = (__int64)sub_684A544(a5, "i");
    }
    v163 = sub_649533C(v196);
    v205 = v344;
    v206 = v344 & 1;
    if ( (v163 & 1) == 0 )
      goto LABEL_570;
    v207 = *((_QWORD *)&v344 + 1);
    v208 = (unsigned __int8)v344 >> 1;
    if ( (v344 & 1) != 0 )
      v209 = *((_QWORD *)&v344 + 1);
    else
      v209 = (unsigned __int8)v344 >> 1;
    if ( !v209 )
    {
      v163 = (__int64)sub_65B6BB0(&v342, 1LL);
      if ( (v344 & 1) != 0 )
        v163 = sub_65ECAF4();
      v344 = v342;
      v205 = v342;
      v345 = v343;
      v207 = *((_QWORD *)&v342 + 1);
      v208 = (unsigned __int64)(unsigned __int8)v342 >> 1;
    }
    v206 = v205 & 1;
    if ( (v205 & 1) != 0 )
      v210 = v207;
    else
      v210 = v208;
    v211 = *((_QWORD *)&xmmword_6FF5938 + 1);
    if ( (xmmword_6FF5938 & 1) == 0 )
      v211 = (unsigned __int64)(unsigned __int8)xmmword_6FF5938 >> 1;
    if ( v210 != v211 )
      goto LABEL_570;
    v212 = (unsigned __int8 *)&v344 + 1;
    if ( v206 )
      v163 = (__int64)v345;
    else
      v163 = (__int64)&v344 + 1;
    if ( (xmmword_6FF5938 & 1) != 0 )
      v213 = (unsigned __int8 *)qword_6FF5948;
    else
      v213 = (unsigned __int8 *)&xmmword_6FF5938 + 1;
    if ( !v206 )
    {
      if ( !v210 )
        goto LABEL_572;
      v214 = v208 - 1;
      do
      {
        v216 = *v212++;
        v215 = v216;
        v218 = *v213++;
        v217 = v218;
      }
      while ( v215 == v218 && v214-- != 0 );
      if ( v215 == v217 )
        goto LABEL_572;
      goto LABEL_570;
    }
    if ( v210 )
    {
      v163 = memcmp((const void *)v163, v213, v210);
      if ( (_DWORD)v163 )
      {
LABEL_570:
        if ( !v206 )
          goto LABEL_572;
      }
    }
LABEL_571:
    v163 = sub_65ECAF4();
    goto LABEL_572;
  }
  if ( (xmmword_6FF5938 & 1) != 0 )
    v174 = *((_QWORD *)&xmmword_6FF5938 + 1);
  else
    v174 = (unsigned __int64)(unsigned __int8)xmmword_6FF5938 >> 1;
  if ( (xmmword_6FF5938 & 1) != 0 )
    v175 = (const char *)qword_6FF5948;
  else
    v175 = (char *)&xmmword_6FF5938 + 1;
  if ( v174 )
    v176 = v175;
  else
    v176 = "0";
  v177 = strlen(v176);
  if ( v177 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v178 = v177;
  if ( v177 >= 0x17 )
  {
    v183 = (v177 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v179 = (char *)sub_65ECAAC();
    *((_QWORD *)&v344 + 1) = v178;
    v345 = v179;
    *(_QWORD *)&v344 = v183 | 1;
    goto LABEL_475;
  }
  v179 = (char *)&v344 + 1;
  LOBYTE(v344) = 2 * v177;
  if ( v177 )
LABEL_475:
    memcpy(v179, v176, v178);
  v179[v178] = 0;
  if ( (v344 & 1) != 0 )
    v184 = v345;
  else
    v184 = (char *)&v344 + 1;
  if ( strtoll(v184, 0LL, 10) <= 0 )
    sub_684A29C((int)&v344, "0");
  sub_684A544(a5, ",placeid=");
  if ( (v344 & 1) != 0 )
    v185 = (char *)v345;
  else
    v185 = (char *)&v344 + 1;
  if ( (v344 & 1) != 0 )
    v186 = *((_QWORD *)&v344 + 1);
  else
    v186 = (unsigned __int64)(unsigned __int8)v344 >> 1;
  sub_65FFB9C(a5, v185, v186);
  v163 = (__int64)sub_684A544(a5, "i");
  if ( (v344 & 1) != 0 )
    goto LABEL_571;
LABEL_572:
  v220 = sub_649525C(v163);
  if ( (v220 & 1) != 0 )
  {
    if ( !byte_724A7A8 )
      goto LABEL_674;
    if ( byte_6FF5600 )
    {
      v344 = 0uLL;
      v345 = 0LL;
      v221 = sub_64952FC();
      if ( (v221 & 1) != 0 )
      {
        v221 = (__int64)sub_65B6B3C(&v342, 9LL);
        if ( (v344 & 1) != 0 )
          v221 = sub_65ECAF4();
        v344 = v342;
        v222 = *((_QWORD *)&v342 + 1);
        if ( (v342 & 1) == 0 )
          v222 = (unsigned __int64)(unsigned __int8)v344 >> 1;
        v345 = v343;
        if ( v222 )
        {
          sub_684A544(a5, ",placeversion=");
          if ( (v344 & 1) != 0 )
            v223 = (char *)v345;
          else
            v223 = (char *)&v344 + 1;
          if ( (v344 & 1) != 0 )
            v224 = *((_QWORD *)&v344 + 1);
          else
            v224 = (unsigned __int64)(unsigned __int8)v344 >> 1;
LABEL_610:
          sub_65FFB9C(a5, v223, v224);
          v221 = (__int64)sub_684A544(a5, "i");
        }
      }
      else
      {
        if ( (xmmword_6FF5950 & 1) != 0 )
          v228 = *((_QWORD *)&xmmword_6FF5950 + 1);
        else
          v228 = (unsigned __int64)(unsigned __int8)xmmword_6FF5950 >> 1;
        if ( v228 )
        {
          sub_684A544(a5, ",placeversion=");
          if ( (xmmword_6FF5950 & 1) != 0 )
            v223 = (char *)qword_6FF5960;
          else
            v223 = (char *)&xmmword_6FF5950 + 1;
          if ( (xmmword_6FF5950 & 1) != 0 )
            v224 = *((_QWORD *)&xmmword_6FF5950 + 1);
          else
            v224 = (unsigned __int64)(unsigned __int8)xmmword_6FF5950 >> 1;
          goto LABEL_610;
        }
      }
      v229 = sub_64952BC(v221);
      if ( (v229 & 1) != 0 )
      {
        v230 = *((_QWORD *)&v344 + 1);
        v231 = v344 & 1;
        v232 = (unsigned __int64)(unsigned __int8)v344 >> 1;
        if ( v231 )
          v233 = *((_QWORD *)&v344 + 1);
        else
          v233 = (unsigned __int64)(unsigned __int8)v344 >> 1;
        if ( !v233 )
        {
          v229 = (__int64)sub_65B6B3C(&v342, 9LL);
          if ( (v344 & 1) != 0 )
            v229 = sub_65ECAF4();
          v344 = v342;
          v345 = v343;
          v230 = *((_QWORD *)&v342 + 1);
          v231 = v342 & 1;
          v232 = (unsigned __int64)(unsigned __int8)v342 >> 1;
        }
        if ( !v231 )
          v230 = v232;
        if ( v230 )
        {
          sub_684A544(a5, ",placeversion_fromcontext=");
          if ( (v344 & 1) != 0 )
            v234 = (char *)v345;
          else
            v234 = (char *)&v344 + 1;
          if ( (v344 & 1) != 0 )
            v235 = *((_QWORD *)&v344 + 1);
          else
            v235 = (unsigned __int64)(unsigned __int8)v344 >> 1;
          sub_65FFB9C(a5, v234, v235);
          v229 = (__int64)sub_684A544(a5, "i");
        }
      }
      v220 = sub_649533C(v229);
      v236 = v344;
      v237 = v344 & 1;
      if ( (v220 & 1) != 0 )
      {
        v238 = *((_QWORD *)&v344 + 1);
        v239 = (unsigned __int8)v344 >> 1;
        if ( (v344 & 1) != 0 )
          v240 = *((_QWORD *)&v344 + 1);
        else
          v240 = (unsigned __int8)v344 >> 1;
        if ( !v240 )
        {
          v220 = (__int64)sub_65B6BB0(&v342, 9LL);
          if ( (v344 & 1) != 0 )
            v220 = sub_65ECAF4();
          v344 = v342;
          v236 = v342;
          v345 = v343;
          v238 = *((_QWORD *)&v342 + 1);
          v239 = (unsigned __int64)(unsigned __int8)v342 >> 1;
        }
        v237 = v236 & 1;
        if ( (v236 & 1) != 0 )
          v241 = v238;
        else
          v241 = v239;
        v242 = *((_QWORD *)&xmmword_6FF5950 + 1);
        if ( (xmmword_6FF5950 & 1) == 0 )
          v242 = (unsigned __int64)(unsigned __int8)xmmword_6FF5950 >> 1;
        if ( v241 == v242 )
        {
          v243 = (unsigned __int8 *)&v344 + 1;
          if ( v237 )
            v220 = (__int64)v345;
          else
            v220 = (__int64)&v344 + 1;
          if ( (xmmword_6FF5950 & 1) != 0 )
            v244 = (unsigned __int8 *)qword_6FF5960;
          else
            v244 = (unsigned __int8 *)&xmmword_6FF5950 + 1;
          if ( v237 )
          {
            if ( !v241 || (v220 = memcmp((const void *)v220, v244, v241), !(_DWORD)v220) )
            {
LABEL_662:
              v220 = sub_65ECAF4();
              goto LABEL_663;
            }
          }
          else
          {
            if ( !v241 )
              goto LABEL_663;
            v245 = v239 - 1;
            do
            {
              v247 = *v243++;
              v246 = v247;
              v249 = *v244++;
              v248 = v249;
            }
            while ( v246 == v249 && v245-- != 0 );
            if ( v246 == v248 )
              goto LABEL_663;
          }
        }
      }
      if ( !v237 )
        goto LABEL_663;
      goto LABEL_662;
    }
  }
  else
  {
    if ( !byte_724A7A8 )
      goto LABEL_674;
    if ( byte_6FF5600 )
    {
      if ( (xmmword_6FF5950 & 1) != 0 )
        v225 = *((_QWORD *)&xmmword_6FF5950 + 1);
      else
        v225 = (unsigned __int64)(unsigned __int8)xmmword_6FF5950 >> 1;
      if ( v225 )
      {
        sub_684A544(a5, ",placeversion=");
        if ( (xmmword_6FF5950 & 1) != 0 )
          v226 = (char *)qword_6FF5960;
        else
          v226 = (char *)&xmmword_6FF5950 + 1;
        if ( (xmmword_6FF5950 & 1) != 0 )
          v227 = *((_QWORD *)&xmmword_6FF5950 + 1);
        else
          v227 = (unsigned __int64)(unsigned __int8)xmmword_6FF5950 >> 1;
        sub_65FFB9C(a5, v226, v227);
        v220 = (__int64)sub_684A544(a5, "i");
      }
LABEL_663:
      if ( !byte_724A7A8 )
        goto LABEL_674;
    }
  }
  v251 = qword_6FF5558;
  if ( (word_6FF5550 & 1) == 0 )
    v251 = (unsigned __int64)(unsigned __int8)word_6FF5550 >> 1;
  if ( v251 )
  {
    sub_684A544(a5, ",userid=");
    if ( (v337 & 1) != 0 )
      v252 = (char *)v339;
    else
      v252 = (char *)&v337 + 1;
    if ( (v337 & 1) != 0 )
      v253 = v338;
    else
      v253 = (unsigned __int64)(unsigned __int8)v337 >> 1;
    sub_65FFB9C(a5, v252, v253);
    v220 = (__int64)sub_684A544(a5, "i");
  }
LABEL_674:
  if ( (qword_6FF5980 & 1) != 0 )
    v254 = qword_6FF5988;
  else
    v254 = (unsigned __int64)(unsigned __int8)qword_6FF5980 >> 1;
  if ( v254 )
  {
    sub_684A544(a5, ",logguid=");
    v344 = 0uLL;
    v345 = 0LL;
    sub_684A29C((int)&v344, "0");
    sub_684A544(&v344, "/");
    if ( (qword_6FF5980 & 1) != 0 )
      v255 = (char *)qword_6FF5990;
    else
      v255 = (char *)&qword_6FF5980 + 1;
    if ( (qword_6FF5980 & 1) != 0 )
      v256 = qword_6FF5988;
    else
      v256 = (unsigned __int64)(unsigned __int8)qword_6FF5980 >> 1;
    sub_65FFB9C((unsigned __int64 *)&v344, v255, v256);
    sub_684A544(&v344, "_last.log");
    sub_68497A0(v336, &v344);
    sub_648E910((__int64 *)&v342, (int)v336);
    if ( (v342 & 1) != 0 )
      v257 = v343;
    else
      v257 = (char *)&v342 + 1;
    if ( (v342 & 1) != 0 )
      v258 = *((_QWORD *)&v342 + 1);
    else
      v258 = (unsigned __int64)(unsigned __int8)v342 >> 1;
    v220 = (__int64)sub_65FFB9C(a5, v257, v258);
    if ( (v342 & 1) != 0 )
    {
      v220 = sub_65ECAF4();
      if ( (v336[0] & 1) == 0 )
      {
LABEL_692:
        if ( (v344 & 1) == 0 )
          goto LABEL_694;
        goto LABEL_693;
      }
    }
    else if ( (v336[0] & 1) == 0 )
    {
      goto LABEL_692;
    }
    v220 = sub_65ECAF4();
    if ( (v344 & 1) != 0 )
LABEL_693:
      v220 = sub_65ECAF4();
  }
LABEL_694:
  sub_649523C(v220);
  sub_684A544(a5, ",sessionDuration=");
  sub_65F13AC("%f", &v344);
  if ( (v344 & 1) != 0 )
    v259 = (char *)v345;
  else
    v259 = (char *)&v344 + 1;
  if ( (v344 & 1) != 0 )
    v260 = *((_QWORD *)&v344 + 1);
  else
    v260 = (unsigned __int64)(unsigned __int8)v344 >> 1;
  sub_65FFB9C(a5, v259, v260);
  if ( (v344 & 1) != 0 )
    sub_65ECAF4();
  sub_684A544(a5, ",clientTimestamp=");
  v261 = sub_65F7CCC();
  sub_65F8770(v261, (__int64)v335);
  sub_648E910((__int64 *)&v344, (int)v335);
  if ( (v344 & 1) != 0 )
    v262 = (char *)v345;
  else
    v262 = (char *)&v344 + 1;
  if ( (v344 & 1) != 0 )
    v263 = *((_QWORD *)&v344 + 1);
  else
    v263 = (unsigned __int64)(unsigned __int8)v344 >> 1;
  sub_65FFB9C(a5, v262, v263);
  if ( (v344 & 1) != 0 )
    sub_65ECAF4();
  if ( (v335[0] & 1) != 0 )
    sub_65ECAF4();
  v264 = qword_6FF5970;
  if ( (qword_6FF5968 & 1) == 0 )
    v264 = (unsigned __int64)(unsigned __int8)qword_6FF5968 >> 1;
  if ( v264 && dword_6CA8E88 != -1 )
  {
    sub_684A544(a5, ",serverIp=");
    sub_68497A0(v334, (__int128 *)&qword_6FF5968);
    sub_648E910((__int64 *)&v344, (int)v334);
    if ( (v344 & 1) != 0 )
      v265 = (char *)v345;
    else
      v265 = (char *)&v344 + 1;
    if ( (v344 & 1) != 0 )
      v266 = *((_QWORD *)&v344 + 1);
    else
      v266 = (unsigned __int64)(unsigned __int8)v344 >> 1;
    sub_65FFB9C(a5, v265, v266);
    if ( (v344 & 1) != 0 )
      sub_65ECAF4();
    if ( (v334[0] & 1) != 0 )
      sub_65ECAF4();
    sub_65F13AC("%d", &v344);
    sub_684A544(a5, ",port=");
    sub_68497A0(v333, &v344);
    sub_648E910((__int64 *)&v342, (int)v333);
    if ( (v342 & 1) != 0 )
      v267 = v343;
    else
      v267 = (char *)&v342 + 1;
    if ( (v342 & 1) != 0 )
      v268 = *((_QWORD *)&v342 + 1);
    else
      v268 = (unsigned __int64)(unsigned __int8)v342 >> 1;
    sub_65FFB9C(a5, v267, v268);
    if ( (v342 & 1) != 0 )
    {
      sub_65ECAF4();
      if ( (v333[0] & 1) == 0 )
      {
LABEL_734:
        if ( (v344 & 1) == 0 )
          goto LABEL_736;
        goto LABEL_735;
      }
    }
    else if ( (v333[0] & 1) == 0 )
    {
      goto LABEL_734;
    }
    sub_65ECAF4();
    if ( (v344 & 1) != 0 )
LABEL_735:
      sub_65ECAF4();
  }
LABEL_736:
  sub_684A544(a5, ",mult=");
  sub_65F13AC("%f", &v344);
  if ( (v344 & 1) != 0 )
    v269 = (char *)v345;
  else
    v269 = (char *)&v344 + 1;
  if ( (v344 & 1) != 0 )
    v270 = *((_QWORD *)&v344 + 1);
  else
    v270 = (unsigned __int64)(unsigned __int8)v344 >> 1;
  v271 = (__int64)sub_65FFB9C(a5, v269, v270);
  if ( (v344 & 1) != 0 )
    v271 = sub_65ECAF4();
  v280 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 <= 1u )
  {
    v281 = *v130;
    v282 = (unsigned __int8 *)*v128;
    if ( v280 )
      v283 = 8;
    else
      v283 = *v130;
    if ( v280 )
      v284 = v128;
    else
      v284 = (_QWORD *)*v128;
    v285 = (unsigned __int8 *)&v284[6 * v283];
    v286 = v285;
    goto LABEL_778;
  }
  v281 = *v130;
  v280 = *(_DWORD *)a2 & 1;
  v282 = (unsigned __int8 *)*v128;
  if ( v280 )
    v287 = 8;
  else
    v287 = *v130;
  BYTE2(v344) = 0;
  if ( v280 )
    v285 = (unsigned __int8 *)v128;
  else
    v285 = v282;
  v286 = &v285[48 * v287];
  LOWORD(v344) = 24322;
  if ( v287 )
  {
    while ( 1 )
    {
      v288 = *v285;
      v289 = *((_QWORD *)v285 + 1);
      v290 = v288 >> 1;
      if ( (v288 & 1) == 0 )
        v289 = v288 >> 1;
      if ( v289 )
      {
        if ( v289 != 1 )
          break;
        if ( (v288 & 1) == 0 )
        {
          v291 = 0LL;
          while ( v285[v291 + 1] == *((unsigned __int8 *)&v344 + v291 + 1) )
          {
            if ( v290 == ++v291 )
              goto LABEL_761;
          }
          break;
        }
        if ( **((_BYTE **)v285 + 2) != 95 )
          break;
      }
LABEL_761:
      v285 += 48;
      if ( v285 == v286 )
      {
        v285 = v286;
        break;
      }
    }
  }
LABEL_778:
  v292 = v280 == 0;
  if ( v280 )
    v293 = 8;
  else
    v293 = v281;
  if ( !v292 )
    v282 = (unsigned __int8 *)v128;
  v294 = &v282[48 * v293];
  if ( v294 != v285 )
  {
LABEL_787:
    sub_6601588(a5, 44);
    v295 = *v285;
    v296 = (v295 & 1) == 0;
    v297 = v295 >> 1;
    if ( v296 )
      v298 = v285 + 1;
    else
      v298 = (void *)*((_QWORD *)v285 + 2);
    if ( v296 )
      v299 = v297;
    else
      v299 = *((_QWORD *)v285 + 1);
    sub_65FFB9C(a5, v298, v299);
    sub_6601588(a5, 61);
    sub_68497A0((unsigned __int64 *)&v331, (__int128 *)(v285 + 24));
    v300 = *((_QWORD *)&v331 + 1);
    v301 = v332;
    if ( (v331 & 1) == 0 )
    {
      v300 = (unsigned __int64)(unsigned __int8)v331 >> 1;
      v301 = (char *)&v331 + 1;
    }
    if ( !v300 )
      goto LABEL_817;
    v302 = v301;
    if ( v300 < 8 )
    {
LABEL_840:
      v315 = &v301[v300];
      do
      {
        if ( *v302 == 44 )
          *v302 = 95;
        ++v302;
      }
      while ( v302 != v315 );
      goto LABEL_817;
    }
    v303 = v301 + 3;
    v302 = &v301[v300 & 0xFFFFFFFFFFFFFFF8LL];
    v304 = v300 & 0xFFFFFFFFFFFFFFF8LL;
    while ( 1 )
    {
      v305 = vceq_s8(*(int8x8_t *)(v303 - 3), (int8x8_t)0x2C2C2C2C2C2C2C2CLL).n64_u64[0];
      if ( (v305 & 1) != 0 )
      {
        *(v303 - 3) = 95;
        if ( (v305 & 0x100) == 0 )
          goto LABEL_801;
      }
      else if ( (v305 & 0x100) == 0 )
      {
LABEL_801:
        if ( (v305 & 0x10000) != 0 )
          goto LABEL_802;
        goto LABEL_810;
      }
      *(v303 - 2) = 95;
      if ( (v305 & 0x10000) != 0 )
      {
LABEL_802:
        *(v303 - 1) = 95;
        if ( (v305 & 0x1000000) == 0 )
          goto LABEL_803;
        goto LABEL_811;
      }
LABEL_810:
      if ( (v305 & 0x1000000) == 0 )
      {
LABEL_803:
        if ( (v305 & 0x100000000LL) != 0 )
          goto LABEL_804;
        goto LABEL_812;
      }
LABEL_811:
      *v303 = 95;
      if ( (v305 & 0x100000000LL) != 0 )
      {
LABEL_804:
        v303[1] = 95;
        if ( (v305 & 0x10000000000LL) == 0 )
          goto LABEL_805;
        goto LABEL_813;
      }
LABEL_812:
      if ( (v305 & 0x10000000000LL) == 0 )
      {
LABEL_805:
        if ( (v305 & 0x1000000000000LL) != 0 )
          goto LABEL_806;
        goto LABEL_814;
      }
LABEL_813:
      v303[2] = 95;
      if ( (v305 & 0x1000000000000LL) != 0 )
      {
LABEL_806:
        v303[3] = 95;
        if ( (v305 & 0x100000000000000LL) != 0 )
          goto LABEL_815;
        goto LABEL_798;
      }
LABEL_814:
      if ( (v305 & 0x100000000000000LL) != 0 )
LABEL_815:
        v303[4] = 95;
LABEL_798:
      v304 -= 8LL;
      v303 += 8;
      if ( !v304 )
      {
        if ( v300 != (v300 & 0xFFFFFFFFFFFFFFF8LL) )
          goto LABEL_840;
LABEL_817:
        v306 = v331;
        v331 = 0uLL;
        v307 = v332;
        v332 = 0LL;
        v344 = v306;
        v345 = v307;
        if ( (v306 & 1) != 0 )
          v308 = (char *)v307;
        else
          v308 = (char *)&v344 + 1;
        if ( (v344 & 1) != 0 )
          v309 = *((_QWORD *)&v344 + 1);
        else
          v309 = (unsigned __int64)(unsigned __int8)v344 >> 1;
        v271 = (__int64)sub_65FFB9C(a5, v308, v309);
        if ( (v344 & 1) != 0 )
          v271 = sub_65ECAF4();
        if ( (v331 & 1) != 0 )
          v271 = sub_65ECAF4();
        v285 += 48;
        LOWORD(v344) = 24322;
        BYTE2(v344) = 0;
        if ( v285 == v286 )
        {
LABEL_785:
          v285 = v286;
          goto LABEL_786;
        }
        while ( 2 )
        {
          v310 = *v285;
          v311 = *((_QWORD *)v285 + 1);
          v312 = v310 >> 1;
          if ( (v310 & 1) == 0 )
            v311 = v310 >> 1;
          if ( !v311 )
            goto LABEL_830;
          if ( v311 != 1 )
            goto LABEL_786;
          if ( (v310 & 1) != 0 )
          {
            if ( **((_BYTE **)v285 + 2) != 95 )
              goto LABEL_786;
LABEL_830:
            v285 += 48;
            if ( v285 == v286 )
              goto LABEL_785;
            continue;
          }
          break;
        }
        v313 = v285 + 1;
        v314 = (unsigned __int8 *)&v344 + 1;
        while ( *v313 == *v314 )
        {
          --v312;
          ++v313;
          ++v314;
          if ( !v312 )
            goto LABEL_830;
        }
LABEL_786:
        if ( v285 == v294 )
          break;
        goto LABEL_787;
      }
    }
  }
  if ( !byte_724A7A8 )
  {
    v271 = qword_6FF53B0;
    v316 = qword_6FF53B8;
    if ( !(_BYTE)qword_6FF53B0 )
      goto LABEL_866;
    goto LABEL_858;
  }
  if ( !byte_6FF54E8 )
  {
    v271 = qword_6FF53B0;
    v316 = qword_6FF53B8;
    if ( byte_724A758 )
    {
      if ( (unsigned __int8)qword_6FF53B0 < 6u || BYTE1(qword_6FF53B0) < 3u )
        goto LABEL_866;
    }
    else if ( !(_BYTE)qword_6FF53B0 )
    {
      goto LABEL_866;
    }
LABEL_858:
    if ( (*(_BYTE *)a5 & 1) != 0 )
      v317 = a5[2];
    else
      v317 = (__int64)a5 + 1;
    goto LABEL_865;
  }
  if ( a4 != 3 )
  {
    v271 = qword_6FF53B0;
    v316 = qword_6FF53B8;
    if ( byte_724A758 )
    {
      if ( (unsigned __int8)qword_6FF53B0 < 6u || BYTE1(qword_6FF53B0) < 3u )
        goto LABEL_866;
      goto LABEL_862;
    }
    if ( (_BYTE)qword_6FF53B0 )
    {
LABEL_862:
      if ( (*(_BYTE *)a5 & 1) != 0 )
        v317 = a5[2];
      else
        v317 = (__int64)a5 + 1;
LABEL_865:
      v271 = sub_65C5C5C(
               v271,
               v316,
               (__int64)"[DFLog::InfluxTrace] Influx[%s]",
               v317,
               v272,
               v273,
               v274,
               v275,
               v276,
               v277,
               v278,
               v279,
               v323);
    }
  }
LABEL_866:
  if ( byte_724A7A8 )
  {
    if ( !byte_6FF5690 )
      goto LABEL_879;
    sub_684A544(a5, ",engineversion=");
    v329 = 22;
    strcpy(v330, "2.663.0.660");
    sub_648E910((__int64 *)&v344, (int)&v329);
    if ( (v344 & 1) != 0 )
      v318 = (char *)v345;
    else
      v318 = (char *)&v344 + 1;
    if ( (v344 & 1) != 0 )
      v319 = *((_QWORD *)&v344 + 1);
    else
      v319 = (unsigned __int64)(unsigned __int8)v344 >> 1;
    v271 = (__int64)sub_65FFB9C(a5, v318, v319);
    if ( (v344 & 1) != 0 )
      v271 = sub_65ECAF4();
    if ( (v329 & 1) != 0 )
      v271 = sub_65ECAF4();
    if ( byte_724A7A8 )
    {
LABEL_879:
      if ( byte_6FF56B0 )
      {
        sub_684A544(a5, ",sessionid=");
        sub_68497A0(v328, (__int128 *)&qword_6FF5980);
        sub_648E910((__int64 *)&v344, (int)v328);
        if ( (v344 & 1) != 0 )
          v320 = (char *)v345;
        else
          v320 = (char *)&v344 + 1;
        if ( (v344 & 1) != 0 )
          v321 = *((_QWORD *)&v344 + 1);
        else
          v321 = (unsigned __int64)(unsigned __int8)v344 >> 1;
        v271 = (__int64)sub_65FFB9C(a5, v320, v321);
        if ( (v344 & 1) != 0 )
          v271 = sub_65ECAF4();
        if ( (v328[0] & 1) != 0 )
          v271 = sub_65ECAF4();
      }
    }
  }
  if ( (sub_649533C(v271) & 1) != 0 )
    sub_649537C((int)a1);
  if ( (v337 & 1) != 0 )
    sub_65ECAF4();
  if ( v326 )
    (*(void (__fastcall **)(_QWORD *))(*v326 + 16LL))(v326);
  result = (__int64)v327;
  if ( v327 )
    return (*(__int64 (__fastcall **)(__int128 *))(*(_QWORD *)v327 + 16LL))(v327);
  return result;
}


================================================================================
Function: sub_648E910 (0x648E910)
================================================================================

__int64 *__usercall sub_648E910@<X0>(__int64 *__return_ptr a1@<X8>, unsigned __int8 *a2@<X0>)
{
  unsigned __int8 *v4; // x22
  unsigned __int8 *v5; // x8
  size_t v6; // x9
  unsigned __int64 v7; // x11
  int v8; // w10
  size_t v9; // x11
  size_t v10; // x12
  unsigned __int8 *v11; // x4
  unsigned __int8 *v12; // x13
  int v13; // t1
  unsigned __int64 v14; // x11
  size_t v15; // x12
  unsigned __int8 *v16; // x4
  unsigned __int8 *v17; // x13
  int v18; // t1
  unsigned __int64 v19; // x11
  unsigned __int8 *v20; // x1
  size_t v21; // x2
  unsigned __int64 *v22; // x0
  __int128 v23; // q0
  __int64 *result; // x0
  __int64 v25; // x8
  __int128 v26; // q0
  char v27; // w9
  unsigned __int64 v28; // [xsp+8h] [xbp-38h] BYREF
  __int128 v29; // [xsp+20h] [xbp-20h] BYREF
  unsigned __int64 v30; // [xsp+30h] [xbp-10h]

  v4 = a2 + 1;
  v6 = *((_QWORD *)a2 + 1);
  v5 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  v7 = *a2;
  v8 = v7 & 1;
  v9 = v7 >> 1;
  if ( v8 )
    v10 = *((_QWORD *)a2 + 1);
  else
    v10 = v9;
  if ( v8 )
    v11 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v11 = a2 + 1;
  if ( v10 )
  {
    v12 = v11;
    while ( 1 )
    {
      v13 = *v12++;
      if ( v13 == 92 )
        break;
      ++v11;
      if ( !--v10 )
        goto LABEL_13;
    }
    *(_QWORD *)&v29 = "\\";
    *((_QWORD *)&v29 + 1) = "";
    sub_2D6A56C((int)a2);
    v14 = *a2;
    v6 = *((_QWORD *)a2 + 1);
    v5 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
    v8 = v14 & 1;
    v9 = v14 >> 1;
  }
LABEL_13:
  if ( v8 )
    v15 = v6;
  else
    v15 = v9;
  if ( v8 )
    v16 = v5;
  else
    v16 = v4;
  if ( v15 )
  {
    v17 = v16;
    while ( 1 )
    {
      v18 = *v17++;
      if ( v18 == 34 )
        break;
      ++v16;
      if ( !--v15 )
        goto LABEL_25;
    }
    *(_QWORD *)&v29 = "\"";
    *((_QWORD *)&v29 + 1) = "";
    sub_2D6A56C((int)a2);
    v19 = *a2;
    v6 = *((_QWORD *)a2 + 1);
    v5 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
    v8 = v19 & 1;
    v9 = v19 >> 1;
  }
LABEL_25:
  if ( v8 )
    v20 = v5;
  else
    v20 = v4;
  if ( v8 )
    v21 = v6;
  else
    v21 = v9;
  BYTE2(v28) = 0;
  LOWORD(v28) = 8706;
  v22 = sub_65FFB9C(&v28, v20, v21);
  v23 = *(_OWORD *)v22;
  v30 = v22[2];
  v29 = v23;
  v22[1] = 0LL;
  v22[2] = 0LL;
  *v22 = 0LL;
  result = sub_684A544(&v29, "\"");
  v25 = result[2];
  v26 = *(_OWORD *)result;
  *result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  v27 = v29;
  a1[2] = v25;
  *(_OWORD *)a1 = v26;
  if ( (v27 & 1) != 0 )
    result = (__int64 *)sub_65ECAF4();
  if ( (v28 & 1) != 0 )
    return (__int64 *)sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_648EF10 (0x648EF10)
================================================================================

__int64 __usercall sub_648EF10@<X0>(__int64 a1@<X0>, __int128 *a2@<X1>, __int64 a3@<X8>)
{
  __int64 result; // x0
  __int64 v7; // x21
  char v8; // w8
  __int128 *v9; // x24
  __int128 v10; // q0
  __int64 v11; // x8
  __int128 v12; // q0
  char v13; // w10
  unsigned int v14; // w11
  __int64 v15; // x9
  bool v16; // zf
  unsigned int v17; // w10
  __int64 v18; // [xsp+0h] [xbp-10h] BYREF

  result = sub_649334C(a1, a2, &v18);
  v7 = v18;
  if ( (result & 1) != 0 )
  {
    v8 = 0;
  }
  else
  {
    v9 = (__int128 *)((char *)a2 + 24);
    result = sub_649364C(a1, a2, a2, v18);
    v7 = result;
    if ( (*(_BYTE *)result & 1) != 0 )
      result = sub_65ECAF4();
    v10 = *a2;
    *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v7 = v10;
    v11 = *((_QWORD *)a2 + 5);
    *(_WORD *)a2 = 0;
    v12 = *v9;
    *(_QWORD *)(v7 + 40) = v11;
    v8 = 1;
    *(_OWORD *)(v7 + 24) = v12;
    *((_QWORD *)a2 + 4) = 0LL;
    *((_QWORD *)a2 + 5) = 0LL;
    *(_QWORD *)v9 = 0LL;
  }
  v13 = *(_DWORD *)a1;
  v14 = *(_DWORD *)(a1 + 16);
  *(_BYTE *)(a3 + 16) = v8;
  v15 = a1 + 8;
  v16 = (v13 & 1) == 0;
  if ( (v13 & 1) != 0 )
    v17 = 8;
  else
    v17 = v14;
  if ( v16 )
    v15 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a3 = v7;
  *(_QWORD *)(a3 + 8) = v15 + 48LL * v17;
  return result;
}


================================================================================
Function: sub_648F020 (0x648F020)
================================================================================

__int64 __fastcall sub_648F020(__int64 a1, __int64 a2, unsigned int a3, char a4, char a5)
{
  signed int v9; // w8
  bool v10; // w24
  __int64 v11; // x8
  __int64 v12; // x10
  __int64 v13; // x11
  unsigned __int64 v14; // x8
  char v16; // w0
  __int64 v17; // x23
  unsigned __int64 v18; // x8
  char v20; // w0
  __int64 v21; // x23
  __int128 v22; // q0
  __int64 v23; // x8
  _WORD *v24; // x26
  unsigned __int64 v25; // x8
  _BYTE *v26; // x1
  unsigned __int64 v27; // x8
  __int64 v28; // x2
  __int64 v29; // x23
  unsigned __int64 *v30; // x19
  unsigned __int64 *v31; // x19
  __int128 v32; // q0
  __int64 v33; // x8
  _WORD *v34; // x26
  unsigned __int64 v35; // x8
  _BYTE *v36; // x1
  unsigned __int64 v37; // x8
  __int64 v38; // x2
  __int64 v39; // x23
  __int64 result; // x0
  __int64 v41; // [xsp+8h] [xbp-1E8h] BYREF
  __int64 v42; // [xsp+10h] [xbp-1E0h]
  __int128 v43; // [xsp+18h] [xbp-1D8h] BYREF
  __int64 v44; // [xsp+28h] [xbp-1C8h]
  __int128 v45; // [xsp+30h] [xbp-1C0h]
  __int64 v46; // [xsp+40h] [xbp-1B0h]
  __int64 v47; // [xsp+48h] [xbp-1A8h] BYREF
  __int64 v48; // [xsp+50h] [xbp-1A0h]
  __int64 v49; // [xsp+58h] [xbp-198h] BYREF
  char v50[8]; // [xsp+60h] [xbp-190h] BYREF

  if ( (a4 & 1) != 0 )
  {
    v9 = dword_6CA8E70;
    if ( dword_6CA8E70 == -1 )
    {
      v9 = (unsigned int)sub_65F1790() % 0x2710;
      dword_6CA8E70 = v9;
    }
    v10 = v9 >= (int)a3;
  }
  else
  {
    v10 = 0;
  }
  sub_25F4F30((__int64)v50, 0);
  sub_648F57C(v50, a1);
  if ( byte_724A7A8 )
  {
    if ( byte_6FF56E8 )
    {
      sub_65ADBD0(&v47);
      v11 = v47;
      if ( v47 && *(_QWORD *)(a1 + 456) )
      {
        v12 = *(_QWORD *)(a1 + 464);
        v13 = v48;
        v47 = *(_QWORD *)(a1 + 456);
        v48 = v12;
        *(_QWORD *)(a1 + 456) = v11;
        *(_QWORD *)(a1 + 464) = v13;
      }
      if ( byte_724A7A8 && byte_6FF5640 )
      {
        v14 = *(unsigned __int8 *)(a1 + 424);
        if ( (v14 & 1) != 0 ? *(_QWORD *)(a1 + 432) : v14 >> 1 )
        {
          BYTE12(v43) = 0;
          LOBYTE(v43) = 22;
          DWORD2(v43) = 1735746149;
          LOBYTE(v45) = 0;
          *(_QWORD *)((char *)&v43 + 1) = *(_QWORD *)"pointsdebug";
          *(_QWORD *)((char *)&v45 + 1) = 0LL;
          *((_QWORD *)&v45 + 1) = 0LL;
          v46 = 0LL;
          v16 = sub_649334C(v50, &v43, &v49);
          v17 = v49;
          if ( (v16 & 1) != 0 )
          {
            if ( (v45 & 1) != 0 )
              sub_65ECAF4();
          }
          else
          {
            v17 = sub_649364C(v50, &v43, &v43, v49);
            if ( (*(_BYTE *)v17 & 1) != 0 )
              sub_65ECAF4();
            v22 = v43;
            *(_QWORD *)(v17 + 16) = v44;
            *(_OWORD *)v17 = v22;
            LOWORD(v43) = 0;
            v23 = v46;
            *(_OWORD *)(v17 + 24) = v45;
            *(_QWORD *)(v17 + 40) = v23;
            v46 = 0LL;
            v45 = 0uLL;
          }
          v24 = (_WORD *)(a1 + 424);
          if ( (v43 & 1) != 0 )
            sub_65ECAF4();
          v25 = *(unsigned __int8 *)(a1 + 424);
          if ( (v25 & 1) != 0 )
            v26 = *(_BYTE **)(a1 + 440);
          else
            v26 = (_BYTE *)(a1 + 425);
          if ( (v25 & 1) != 0 )
            v27 = *(_QWORD *)(a1 + 432);
          else
            v27 = v25 >> 1;
          if ( v27 >= 0xF000 )
            v28 = 61440LL;
          else
            v28 = v27;
          sub_648B910(v17 + 24, v26, v28);
          if ( v47 )
            (*(void (**)(void))(*(_QWORD *)v47 + 24LL))();
          if ( (*(_BYTE *)v24 & 1) != 0 )
          {
            **(_BYTE **)(a1 + 440) = 0;
            *(_QWORD *)(a1 + 432) = 0LL;
          }
          else
          {
            *v24 = 0;
          }
        }
      }
      if ( !v10 && *(_BYTE *)(a1 + 420) != 0 )
      {
        v29 = *(unsigned int *)(a1 + 416);
        if ( sub_648FB14(*(_DWORD *)(a1 + 416)) )
        {
          v41 = v47;
          v42 = v48;
          if ( v48 )
            sub_6867420(1uLL, (atomic_ullong *)(v48 + 8));
          sub_648FBF4(a2, v50, a5 & 1, a1 + 392, v29, a3, &v41, *(unsigned int *)(a1 + 416));
          v30 = (unsigned __int64 *)v42;
          if ( v42 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v42 + 8)) )
          {
            (*(void (__fastcall **)(unsigned __int64 *))(*v30 + 16))(v30);
            sub_68488BC(v30);
          }
        }
      }
      v31 = (unsigned __int64 *)v48;
      if ( v48 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v48 + 8)) )
      {
        (*(void (__fastcall **)(unsigned __int64 *))(*v31 + 16))(v31);
        sub_68488BC(v31);
      }
      goto LABEL_77;
    }
    if ( byte_6FF5640 )
    {
      v18 = *(unsigned __int8 *)(a1 + 424);
      if ( (v18 & 1) != 0 ? *(_QWORD *)(a1 + 432) : v18 >> 1 )
      {
        BYTE12(v43) = 0;
        LOBYTE(v43) = 22;
        DWORD2(v43) = 1735746149;
        LOBYTE(v45) = 0;
        *(_QWORD *)((char *)&v43 + 1) = *(_QWORD *)"pointsdebug";
        *(_QWORD *)((char *)&v45 + 1) = 0LL;
        *((_QWORD *)&v45 + 1) = 0LL;
        v46 = 0LL;
        v20 = sub_649334C(v50, &v43, &v47);
        v21 = v47;
        if ( (v20 & 1) != 0 )
        {
          if ( (v45 & 1) != 0 )
            sub_65ECAF4();
        }
        else
        {
          v21 = sub_649364C(v50, &v43, &v43, v47);
          if ( (*(_BYTE *)v21 & 1) != 0 )
            sub_65ECAF4();
          v32 = v43;
          *(_QWORD *)(v21 + 16) = v44;
          *(_OWORD *)v21 = v32;
          LOWORD(v43) = 0;
          v33 = v46;
          *(_OWORD *)(v21 + 24) = v45;
          *(_QWORD *)(v21 + 40) = v33;
          v46 = 0LL;
          v45 = 0uLL;
        }
        v34 = (_WORD *)(a1 + 424);
        if ( (v43 & 1) != 0 )
          sub_65ECAF4();
        v35 = *(unsigned __int8 *)(a1 + 424);
        if ( (v35 & 1) != 0 )
          v36 = *(_BYTE **)(a1 + 440);
        else
          v36 = (_BYTE *)(a1 + 425);
        if ( (v35 & 1) != 0 )
          v37 = *(_QWORD *)(a1 + 432);
        else
          v37 = v35 >> 1;
        if ( v37 >= 0xF000 )
          v38 = 61440LL;
        else
          v38 = v37;
        sub_648B910(v21 + 24, v36, v38);
        if ( (*(_BYTE *)v34 & 1) != 0 )
        {
          **(_BYTE **)(a1 + 440) = 0;
          *(_QWORD *)(a1 + 432) = 0LL;
        }
        else
        {
          *v34 = 0;
        }
      }
    }
  }
  if ( !v10 && *(_BYTE *)(a1 + 420) != 0 )
  {
    v39 = *(unsigned int *)(a1 + 416);
    if ( sub_648FB14(*(_DWORD *)(a1 + 416)) )
      sub_64900AC(a2, v50, a5 & 1, a1 + 392, v39, a3);
  }
LABEL_77:
  result = sub_256B1A8((__int64)v50);
  if ( (v50[0] & 1) == 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_648F57C (0x648F57C)
================================================================================

__int64 __fastcall sub_648F57C(__int64 result, __int64 a2)
{
  int v2; // w8
  int v3; // w10
  int v4; // w8
  int v5; // w9
  __int64 v6; // x9
  __int64 v7; // x13
  __int64 v8; // x8
  __int64 v9; // x10
  int v10; // w14
  _OWORD *v11; // x9
  int v12; // w11
  _OWORD *v13; // x14
  __int64 v14; // x13
  __int128 v15; // q0
  _OWORD *v16; // x15
  unsigned __int8 *v17; // x14
  __int128 v18; // q0
  unsigned __int64 v19; // x15
  unsigned __int64 v20; // x16
  unsigned __int64 v21; // x13
  unsigned __int8 *v22; // x14
  unsigned __int8 *v23; // x15
  unsigned int v24; // w8
  __int64 v25; // x21
  __int64 v26; // x22
  __int64 v27; // x23
  __int64 v28; // x9
  __int64 v29; // x8
  __int128 v30; // q0
  unsigned __int8 *v31; // x8
  unsigned __int64 v32; // x26
  unsigned __int64 v33; // x11
  int v34; // w9
  unsigned __int8 *v35; // x11
  __int64 v36; // x12
  unsigned __int8 *v37; // x13
  int v38; // w9
  int v39; // t1
  int v40; // t1
  bool v41; // zf
  unsigned __int8 *v42; // x27
  unsigned __int64 v43; // x12
  unsigned __int64 v44; // x11
  unsigned __int64 v45; // x13
  int v46; // w10
  unsigned __int8 *v47; // x10
  unsigned __int8 *v48; // x12
  char v49; // w11
  unsigned __int8 v50; // w20
  unsigned __int8 v51; // w9
  __int64 v52; // x19
  __int64 v53; // x10
  __int64 v54; // x11
  __int64 v55; // x12
  _QWORD *v56; // x19
  char v57; // w24
  char v58; // t1
  __int64 v59; // x25
  __int64 v60; // x13
  __int64 v61; // x13
  __int64 v62; // x14
  __int128 v63; // q0
  __int128 *v64; // x28
  __int128 v65; // q0
  char v66; // w8
  __int64 v67; // x8
  __int64 v68; // x9
  __int64 v69; // x11
  __int128 v70; // q1
  __int64 v71; // x12
  __int64 v72; // x8
  __int64 v73; // x9
  char v74; // w10
  __int64 v75; // x8
  __int64 v76; // x9
  int v77; // [xsp+14h] [xbp-7Ch]
  __int64 v78; // [xsp+18h] [xbp-78h]
  unsigned __int8 v79; // [xsp+24h] [xbp-6Ch]
  __int16 v80; // [xsp+28h] [xbp-68h] BYREF
  char v81; // [xsp+2Ah] [xbp-66h]
  __int128 v82; // [xsp+60h] [xbp-30h]
  _QWORD v83[2]; // [xsp+78h] [xbp-18h]

  v2 = *(_DWORD *)a2;
  v81 = 0;
  *(_DWORD *)a2 = *(_DWORD *)result & 0xFFFFFFFE | v2 & 1;
  v3 = *(_DWORD *)(result + 4);
  *(_DWORD *)result = v2 & 0xFFFFFFFE | *(_DWORD *)result & 1;
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 4) = v3;
  v4 = *(_DWORD *)result;
  v5 = *(_DWORD *)a2;
  HIBYTE(v80) = 95;
  if ( (v4 & 1) == 0 )
  {
    if ( (v5 & 1) == 0 )
    {
      v6 = *(_QWORD *)(result + 8);
      *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 8) = v6;
      LODWORD(v6) = *(_DWORD *)(result + 16);
      *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = v6;
      return result;
    }
    v5 = v4;
    v7 = result;
    result = a2;
    goto LABEL_7;
  }
  if ( (v5 & 1) == 0 )
  {
    v7 = a2;
LABEL_7:
    v8 = 0LL;
    v9 = v7 + 8;
    v10 = v5 | 1;
    v11 = (_OWORD *)(result + 8);
    v12 = HIBYTE(v80);
    v82 = *(_OWORD *)(v7 + 8);
    *(_DWORD *)v7 = v10;
    while ( 1 )
    {
      v16 = &v11[3 * v8];
      v17 = (unsigned __int8 *)(v9 + 48 * v8);
      v18 = *v16;
      *((_QWORD *)v17 + 2) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v17 = v18;
      *((_QWORD *)v16 + 1) = 0LL;
      *((_QWORD *)v16 + 2) = 0LL;
      *(_QWORD *)v16 = 0LL;
      v19 = *v17;
      v20 = *((_QWORD *)v17 + 1);
      v21 = v19 >> 1;
      if ( (v19 & 1) == 0 )
        v20 = v19 >> 1;
      if ( !v20 )
        goto LABEL_9;
      if ( v20 == 1 )
      {
        if ( (v19 & 1) != 0 )
        {
          if ( **(unsigned __int8 **)(v9 + 48 * v8 + 16) == v12 )
            goto LABEL_9;
        }
        else
        {
          v22 = v17 + 1;
          v23 = (unsigned __int8 *)&v80 + 1;
          while ( *v22 == *v23 )
          {
            --v21;
            ++v22;
            ++v23;
            if ( !v21 )
              goto LABEL_9;
          }
        }
      }
      v13 = &v11[3 * v8];
      v14 = v9 + 48 * v8;
      v15 = *(_OWORD *)((char *)v13 + 24);
      *(_QWORD *)(v14 + 40) = *((_QWORD *)v13 + 5);
      *(_OWORD *)(v14 + 24) = v15;
      *((_QWORD *)v13 + 4) = 0LL;
      *((_QWORD *)v13 + 5) = 0LL;
      *((_QWORD *)v13 + 3) = 0LL;
LABEL_9:
      if ( ++v8 == 8 )
      {
        v24 = *(_DWORD *)result & 0xFFFFFFFE;
        *v11 = v82;
        *(_DWORD *)result = v24;
        return result;
      }
    }
  }
  v25 = 0LL;
  v26 = result + 8;
  v27 = a2 + 8;
  v77 = HIBYTE(v80);
  do
  {
    v31 = (unsigned __int8 *)(v26 + 48 * v25);
    v32 = *v31;
    if ( (v32 & 1) != 0 )
      v33 = *((_QWORD *)v31 + 1);
    else
      v33 = v32 >> 1;
    v34 = 0;
    if ( v33 )
    {
      if ( v33 == 1 )
      {
        if ( (v32 & 1) != 0 )
        {
          v34 = **(unsigned __int8 **)(v26 + 48 * v25 + 16) == v77;
        }
        else
        {
          v35 = v31 + 1;
          v36 = (v32 >> 1) - 1;
          v37 = (unsigned __int8 *)&v80 + 1;
          do
          {
            v39 = *v35++;
            v38 = v39;
            v40 = *v37++;
            v41 = v38 == v40;
            v34 = v38 == v40;
            v41 = !v41 || v36-- == 0;
          }
          while ( !v41 );
        }
      }
      v34 ^= 1u;
    }
    v42 = (unsigned __int8 *)(v27 + 48 * v25);
    v43 = *v42;
    v44 = v43 >> 1;
    if ( (v43 & 1) != 0 )
      v45 = *(_QWORD *)(v27 + 48 * v25 + 8);
    else
      v45 = v43 >> 1;
    v46 = 0;
    if ( !v45 )
      goto LABEL_60;
    if ( v45 == 1 )
    {
      if ( (v43 & 1) != 0 )
      {
        v46 = **(unsigned __int8 **)(v27 + 48 * v25 + 16) == v77;
      }
      else
      {
        v47 = v42 + 1;
        v48 = (unsigned __int8 *)&v80 + 1;
        while ( *v47 == *v48 )
        {
          --v44;
          ++v47;
          ++v48;
          if ( !v44 )
          {
            v46 = 0;
            goto LABEL_60;
          }
        }
        v46 = 0;
      }
    }
    v49 = v46;
    v46 ^= 1u;
    if ( (v49 & 1) != 0 || ((v34 ^ 1) & 1) != 0 )
    {
LABEL_60:
      v69 = *((_QWORD *)v42 + 2);
      v70 = *(_OWORD *)v31;
      v71 = *((_QWORD *)v31 + 2);
      *(_OWORD *)v31 = *(_OWORD *)v42;
      *((_QWORD *)v31 + 2) = v69;
      *(_OWORD *)v42 = v70;
      *((_QWORD *)v42 + 2) = v71;
      if ( v34 )
      {
        v28 = v26 + 48 * v25;
        v29 = v27 + 48 * v25;
LABEL_25:
        v30 = *(_OWORD *)(v28 + 24);
        *(_QWORD *)(v29 + 40) = *(_QWORD *)(v28 + 40);
        *(_OWORD *)(v29 + 24) = v30;
        *(_QWORD *)(v28 + 32) = 0LL;
        *(_QWORD *)(v28 + 40) = 0LL;
        *(_QWORD *)(v28 + 24) = 0LL;
        goto LABEL_26;
      }
      if ( v46 )
      {
        v28 = v27 + 48 * v25;
        v29 = v26 + 48 * v25;
        goto LABEL_25;
      }
    }
    else
    {
      v50 = v31[1];
      v51 = v31[25];
      v52 = v26 + 48 * v25;
      v53 = *(_QWORD *)(v31 + 2);
      v54 = *((_QWORD *)v31 + 1);
      *(_QWORD *)v31 = 0LL;
      *((_QWORD *)v31 + 1) = 0LL;
      v79 = v51;
      v55 = *(_QWORD *)(v31 + 26);
      v58 = *(_BYTE *)(v52 + 24);
      v56 = (_QWORD *)(v52 + 24);
      v57 = v58;
      v59 = *(v56 - 1);
      *((_QWORD *)v31 + 2) = 0LL;
      *(_QWORD *)&v82 = v53;
      v60 = v56[2];
      *(_QWORD *)((char *)&v82 + 6) = v54;
      v83[0] = v55;
      v78 = v60;
      v61 = *((_QWORD *)v31 + 4);
      *v56 = 0LL;
      v56[1] = 0LL;
      v56[2] = 0LL;
      v62 = *((_QWORD *)v42 + 2);
      *(_QWORD *)((char *)v83 + 6) = v61;
      v63 = *(_OWORD *)v42;
      *((_QWORD *)v31 + 2) = v62;
      *(_OWORD *)v31 = v63;
      *(_WORD *)v42 = 0;
      if ( (*(_BYTE *)v56 & 1) != 0 )
        result = sub_65ECAF4();
      v64 = (__int128 *)(v27 + 48 * v25 + 24);
      v65 = *v64;
      v56[2] = *(_QWORD *)(v27 + 48 * v25 + 40);
      *(_OWORD *)v56 = v65;
      v66 = *v42;
      *(_WORD *)v64 = 0;
      if ( (v66 & 1) != 0 )
      {
        result = sub_65ECAF4();
        v72 = v82;
        v73 = *(_QWORD *)((char *)&v82 + 6);
        *(_QWORD *)(v27 + 48 * v25 + 16) = v59;
        v74 = *(_BYTE *)v64;
        *v42 = v32;
        v42[1] = v50;
        *(_QWORD *)(v42 + 2) = v72;
        *((_QWORD *)v42 + 1) = v73;
        if ( (v74 & 1) != 0 )
          result = sub_65ECAF4();
      }
      else
      {
        v67 = v82;
        v68 = *(_QWORD *)((char *)&v82 + 6);
        *v42 = v32;
        v42[1] = v50;
        *(_QWORD *)(v42 + 2) = v67;
        *((_QWORD *)v42 + 1) = v68;
        *(_QWORD *)(v27 + 48 * v25 + 16) = v59;
      }
      v75 = v83[0];
      v76 = *(_QWORD *)((char *)v83 + 6);
      *(_BYTE *)v64 = v57;
      *(_QWORD *)(v42 + 26) = v75;
      *((_QWORD *)v42 + 4) = v76;
      v42[25] = v79;
      *(_QWORD *)(v27 + 48 * v25 + 40) = v78;
    }
LABEL_26:
    ++v25;
  }
  while ( v25 != 8 );
  return result;
}


================================================================================
Function: sub_648FA5C (0x648FA5C)
================================================================================

long double __fastcall sub_648FA5C(__int64 a1, char *s, __int64 a3)
{
  size_t v6; // x0
  size_t v7; // x21
  void *v8; // x23
  unsigned __int64 v9; // x24
  long double result; // q0

  v6 = strlen(s);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v9 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (void *)sub_65ECAAC();
    *(_QWORD *)(a1 + 8) = v7;
    *(_QWORD *)(a1 + 16) = v8;
    *(_QWORD *)a1 = v9 | 1;
  }
  else
  {
    *(_BYTE *)a1 = 2 * v6;
    v8 = (void *)(a1 + 1);
    if ( !v6 )
      goto LABEL_7;
  }
  memcpy(v8, s, v7);
LABEL_7:
  *((_BYTE *)v8 + v7) = 0;
  result = *(long double *)a3;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a3 + 16);
  *(long double *)(a1 + 24) = result;
  *(_QWORD *)(a3 + 8) = 0LL;
  *(_QWORD *)(a3 + 16) = 0LL;
  *(_QWORD *)a3 = 0LL;
  return result;
}


================================================================================
Function: sub_648FB14 (0x648FB14)
================================================================================

bool __fastcall sub_648FB14(int a1)
{
  __int64 v2; // x0
  unsigned __int64 v4; // x8
  unsigned __int8 v5; // w8

  v2 = sub_64D12DC();
  if ( (sub_64D151C(v2) & 1) == 0 )
    return 0LL;
  if ( a1 != 1 || byte_724A7A8 && byte_6FF55C0 )
    return 1LL;
  v4 = *((_QWORD *)&xmmword_6FF5938 + 1);
  if ( (xmmword_6FF5938 & 1) == 0 )
    v4 = (unsigned __int64)(unsigned __int8)xmmword_6FF5938 >> 1;
  if ( !v4 )
    return 0LL;
  v5 = atomic_load(byte_6FF5738);
  if ( (v5 & 1) == 0 )
  {
    if ( (unsigned int)sub_68626F8((__int64)byte_6FF5738) )
    {
      byte_6FF5730 = sub_6491B58() & 1;
      sub_6862850(byte_6FF5738);
    }
  }
  return byte_6FF5730 != 0;
}


================================================================================
Function: sub_648FBF4 (0x648FBF4)
================================================================================

__int64 __fastcall sub_648FBF4(
        unsigned __int8 *a1,
        __int64 a2,
        char a3,
        __int64 a4,
        unsigned int a5,
        unsigned int a6,
        _QWORD *a7,
        unsigned int a8)
{
  unsigned __int8 v16; // w8
  void (__fastcall ***v17)(_QWORD, _QWORD *, _QWORD); // x27
  __int64 result; // x0
  unsigned __int64 v19; // x8
  bool v20; // zf
  size_t v21; // x8
  const void *v22; // x22
  size_t v23; // x23
  char *v24; // x10
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x8
  __int64 v29; // x26
  unsigned __int64 v30; // x25
  int v31; // w22
  char *v32; // x1
  size_t v33; // x2
  unsigned __int64 *v34; // x19
  unsigned __int64 *v35; // x19
  char s2; // [xsp+8h] [xbp-98h] BYREF
  _BYTE v37[15]; // [xsp+9h] [xbp-97h] BYREF
  __int64 v38; // [xsp+20h] [xbp-80h] BYREF
  unsigned __int64 v39; // [xsp+28h] [xbp-78h]
  char *v40; // [xsp+30h] [xbp-70h]
  unsigned __int64 v41[3]; // [xsp+38h] [xbp-68h] BYREF
  char v42; // [xsp+50h] [xbp-50h]
  _QWORD v43[4]; // [xsp+70h] [xbp-30h] BYREF
  __int64 v44; // [xsp+90h] [xbp-10h]

  v16 = atomic_load(byte_6FF5778);
  if ( (v16 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6FF5778) )
  {
    sub_64929B8();
    __cxa_atexit((void (*)(void *))sub_6492AF8, &qword_6FF5740, &off_686E780);
    sub_6862850(byte_6FF5778);
  }
  sub_6848980((pthread_mutex_t *)&xmmword_6FF5750);
  v17 = (void (__fastcall ***)(_QWORD, _QWORD *, _QWORD))qword_6FF5740;
  v43[3] = qword_6FF5740;
  v44 = qword_6FF5748;
  if ( qword_6FF5748 )
    sub_6867420(1uLL, (atomic_ullong *)(qword_6FF5748 + 8));
  result = sub_68489D4((pthread_mutex_t *)&xmmword_6FF5750);
  if ( !v17 )
    goto LABEL_58;
  sub_648BF18(v43, a1, a2, a4, a5, a6);
  (**v17)(v17, v43, a3 & 1);
  v19 = *a1;
  v20 = (v19 & 1) == 0;
  v21 = v19 >> 1;
  if ( v20 )
    v22 = a1 + 1;
  else
    v22 = (const void *)*((_QWORD *)a1 + 2);
  if ( v20 )
    v23 = v21;
  else
    v23 = *((_QWORD *)a1 + 1);
  result = (__int64)sub_68497A0(v41, (__int128 *)&word_6FF5708);
  v24 = (char *)v41[2];
  v25 = (unsigned __int64)LOBYTE(v41[0]) >> 1;
  if ( (v41[0] & 1) != 0 )
    v25 = v41[1];
  else
    v24 = (char *)v41 + 1;
  v38 = (__int64)v24;
  v39 = v25;
  if ( !v25 )
  {
    v31 = 0;
    if ( (v41[0] & 1) != 0 )
      goto LABEL_34;
    goto LABEL_35;
  }
  do
  {
    s2 = 44;
    v26 = sub_65F6474((int)&v38, &s2, 1uLL);
    if ( v26 == -1LL )
    {
      result = v38;
      v29 = 0LL;
      v30 = 0LL;
      if ( v39 != v23 )
        goto LABEL_16;
    }
    else
    {
      result = v38;
      if ( v39 >= v26 )
        v27 = v26;
      else
        v27 = v39;
      if ( v39 >= v26 + 1 )
        v28 = v26 + 1;
      else
        v28 = v39;
      v29 = v38 + v28;
      v30 = v39 - v28;
      if ( v27 != v23 )
        goto LABEL_16;
    }
    if ( !v23 || (result = memcmp((const void *)result, v22, v23), !(_DWORD)result) )
    {
      v31 = 1;
      goto LABEL_33;
    }
LABEL_16:
    v38 = v29;
    v39 = v30;
  }
  while ( v30 );
  v31 = 0;
LABEL_33:
  if ( (v41[0] & 1) != 0 )
LABEL_34:
    result = sub_65ECAF4();
LABEL_35:
  if ( v31 )
  {
    sub_684B0A8("pointsv2_dualwrite_", a1);
    v37[7] = 0;
    s2 = 14;
    if ( (v38 & 1) != 0 )
      v32 = v40;
    else
      v32 = (char *)&v38 + 1;
    if ( (v38 & 1) != 0 )
      v33 = v39;
    else
      v33 = (unsigned __int64)(unsigned __int8)v38 >> 1;
    qmemcpy(v37, "default", 7);
    sub_25A0260((int)v41, v32, v33, (int)&unk_6FF56D0, v37, 7uLL);
    if ( (s2 & 1) != 0 )
      sub_65ECAF4();
    if ( (v38 & 1) != 0 )
      sub_65ECAF4();
    sub_65ADA20(&v38, v41);
    result = v38;
    if ( v38 && *a7 )
    {
      (*(void (**)(void))(*(_QWORD *)v38 + 96LL))();
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v38 + 88LL))(v38, a8);
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v38 + 48LL))(v38);
    }
    v34 = (unsigned __int64 *)v39;
    if ( v39 )
    {
      result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v39 + 8));
      if ( !result )
      {
        (*(void (__fastcall **)(unsigned __int64 *))(*v34 + 16))(v34);
        result = sub_68488BC(v34);
      }
    }
    if ( (v42 & 1) != 0 )
      result = sub_65ECAF4();
    if ( (v41[0] & 1) != 0 )
      result = sub_65ECAF4();
  }
  if ( (v43[0] & 1) != 0 )
    result = sub_65ECAF4();
LABEL_58:
  v35 = (unsigned __int64 *)v44;
  if ( v44 )
  {
    result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v44 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v35 + 16))(v35);
      return sub_68488BC(v35);
    }
  }
  return result;
}


================================================================================
Function: sub_649005C (0x649005C)
================================================================================

unsigned __int64 __fastcall sub_649005C(unsigned __int64 result)
{
  unsigned __int64 *v1; // x19

  v1 = *(unsigned __int64 **)(result + 8);
  if ( v1 )
  {
    result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v1 + 1));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v1 + 16))(v1);
      return sub_68488BC(v1);
    }
  }
  return result;
}


================================================================================
Function: sub_64900AC (0x64900AC)
================================================================================

__int64 __fastcall sub_64900AC(__int64 a1, __int64 a2, char a3, __int64 a4, unsigned int a5, unsigned int a6)
{
  unsigned __int8 v12; // w8
  __int64 (__fastcall ***v13)(_QWORD, _QWORD *, _QWORD); // x25
  __int64 result; // x0
  unsigned __int64 *v15; // x19
  _QWORD v16[4]; // [xsp+0h] [xbp-30h] BYREF
  __int64 v17; // [xsp+20h] [xbp-10h]

  v12 = atomic_load(byte_6FF5778);
  if ( (v12 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6FF5778) )
  {
    sub_64929B8();
    __cxa_atexit((void (*)(void *))sub_6492AF8, &qword_6FF5740, &off_686E780);
    sub_6862850(byte_6FF5778);
  }
  sub_6848980((pthread_mutex_t *)&xmmword_6FF5750);
  v13 = (__int64 (__fastcall ***)(_QWORD, _QWORD *, _QWORD))qword_6FF5740;
  v16[3] = qword_6FF5740;
  v17 = qword_6FF5748;
  if ( qword_6FF5748 )
    sub_6867420(1uLL, (atomic_ullong *)(qword_6FF5748 + 8));
  result = sub_68489D4((pthread_mutex_t *)&xmmword_6FF5750);
  if ( v13 )
  {
    sub_648BF18(v16, a1, a2, a4, a5, a6);
    result = (**v13)(v13, v16, a3 & 1);
    if ( (v16[0] & 1) != 0 )
      result = sub_65ECAF4();
  }
  v15 = (unsigned __int64 *)v17;
  if ( v17 )
  {
    result = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v17 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v15 + 16))(v15);
      return sub_68488BC(v15);
    }
  }
  return result;
}


================================================================================
Function: sub_6490454 (0x6490454)
================================================================================

__int64 __fastcall sub_6490454(
        __int64 result,
        char *a2,
        char *a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  __int64 v14; // x22
  __int64 v15; // x23
  char *v16; // x24
  size_t v17; // x0
  __int64 v18; // x2
  __int64 v19; // x22
  size_t v20; // x0

  if ( a2 )
  {
    v14 = result;
    result = (__int64)sub_649100C(result, a2, 0, a4, a5, a6, a7, 0LL, a9, a10, a11, a12);
    if ( result )
    {
      v15 = result;
      if ( a3 )
        v16 = a3;
      else
        v16 = &byte_CC4FFC;
      v17 = strlen(v16);
      if ( v17 >= 0xF000 )
        v18 = 61440LL;
      else
        v18 = v17;
      result = sub_648B910(v15, v16, v18);
      if ( byte_724A7A8 && byte_6FF56E8 )
      {
        v19 = *(_QWORD *)(v14 + 456);
        if ( v19 )
        {
          v20 = strlen(a2);
          return (*(__int64 (__fastcall **)(__int64, char *, size_t, char *, __int64))(*(_QWORD *)v19 + 32LL))(
                   v19,
                   a2,
                   v20,
                   a3,
                   1LL);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6490538 (0x6490538)
================================================================================

__int64 __fastcall sub_6490538(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_6490540(a1, a2, a3, 0LL);
}


================================================================================
Function: sub_6490540 (0x6490540)
================================================================================

__int64 __fastcall sub_6490540(
        __int64 result,
        char *a2,
        unsigned __int8 *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        long double a9,
        long double a10,
        long double a11,
        long double a12)
{
  char v13; // w20
  __int64 v15; // x22
  unsigned __int64 v16; // x8
  bool v17; // zf
  unsigned __int64 v18; // x8
  unsigned __int8 *v19; // x1
  __int64 v20; // x2
  __int64 v21; // x22
  size_t v22; // x2
  unsigned __int64 v23; // x8
  bool v24; // zf
  unsigned __int64 v25; // x8
  unsigned __int8 *v26; // x3
  unsigned __int64 v27; // x4

  if ( a2 )
  {
    v13 = a4;
    v15 = result;
    result = (__int64)sub_649100C(result, a2, a4 & 1, a9, a10, a11, a12, a4, a5, a6, a7, a8);
    if ( result )
    {
      v16 = *a3;
      v17 = (v16 & 1) == 0;
      v18 = (v16 & 1) != 0 ? *((_QWORD *)a3 + 1) : v16 >> 1;
      v19 = v17 ? a3 + 1 : (unsigned __int8 *)*((_QWORD *)a3 + 2);
      v20 = v18 >= 0xF000 ? 61440LL : v18;
      result = sub_648B910(result, v19, v20);
      if ( byte_724A7A8 )
      {
        if ( byte_6FF56E8 )
        {
          v21 = *(_QWORD *)(v15 + 456);
          if ( v21 )
          {
            v22 = strlen(a2);
            v23 = *a3;
            v24 = (v23 & 1) == 0;
            v25 = v23 >> 1;
            if ( v24 )
              v26 = a3 + 1;
            else
              v26 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
            if ( v24 )
              v27 = v25;
            else
              v27 = *((_QWORD *)a3 + 1);
            return (*(__int64 (__fastcall **)(__int64, char *, size_t, unsigned __int8 *, unsigned __int64, bool))(*(_QWORD *)v21 + 24LL))(
                     v21,
                     a2,
                     v22,
                     v26,
                     v27,
                     (v13 & 1) == 0);
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6490850 (0x6490850)
================================================================================

__int64 __fastcall sub_6490850(int a1, char *a2)
{
  return sub_6490858(a1, a2);
}


================================================================================
Function: sub_6490858 (0x6490858)
================================================================================

__int64 __fastcall sub_6490858(
        __int64 a1,
        char *s,
        char a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        long double a9,
        long double a10,
        long double a11,
        long double a12)
{
  double v12; // d8
  __int64 result; // x0
  __int64 v17; // x22
  __int128 v18; // q0
  __int64 v19; // x21
  size_t v20; // x2
  __int128 v21; // [xsp+0h] [xbp-30h] BYREF
  __int64 v22; // [xsp+10h] [xbp-20h]

  v12 = *(double *)&a9;
  result = (__int64)sub_649100C(a1, s, a3 & 1, a9, a10, a11, a12, a4, a5, a6, a7, a8);
  if ( result )
  {
    v17 = result;
    result = sub_65F13AC("%f", &v21);
    if ( (*(_BYTE *)v17 & 1) != 0 )
      result = sub_65ECAF4();
    v18 = v21;
    *(_QWORD *)(v17 + 16) = v22;
    *(_OWORD *)v17 = v18;
    if ( byte_724A7A8 )
    {
      if ( byte_6FF56E8 )
      {
        v19 = *(_QWORD *)(a1 + 456);
        if ( v19 )
        {
          if ( s )
            v20 = strlen(s);
          else
            v20 = 0LL;
          return (*(__int64 (__fastcall **)(__int64, char *, size_t, bool, double))(*(_QWORD *)v19 + 16LL))(
                   v19,
                   s,
                   v20,
                   (a3 & 1) == 0,
                   v12);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_64909C4 (0x64909C4)
================================================================================

__int64 __fastcall sub_64909C4(__int64 a1, char *a2, int a3)
{
  __int64 result; // x0
  __int64 v7; // x23
  __int128 v8; // q0
  __int64 (__fastcall ***v9)(_QWORD, char *, size_t, _QWORD, __int64); // x22
  size_t v10; // x2
  __int128 v11; // [xsp+0h] [xbp-20h] BYREF
  __int64 v12; // [xsp+10h] [xbp-10h]

  result = sub_649100C(a1, a2);
  if ( result )
  {
    v7 = result;
    result = sub_65F13AC("%di", &v11);
    if ( (*(_BYTE *)v7 & 1) != 0 )
      result = sub_65ECAF4();
    v8 = v11;
    *(_QWORD *)(v7 + 16) = v12;
    *(_OWORD *)v7 = v8;
    if ( byte_724A7A8 )
    {
      if ( byte_6FF56E8 )
      {
        v9 = *(__int64 (__fastcall ****)(_QWORD, char *, size_t, _QWORD, __int64))(a1 + 456);
        if ( v9 )
        {
          if ( a2 )
            v10 = strlen(a2);
          else
            v10 = 0LL;
          return (**v9)(v9, a2, v10, a3, 1LL);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_649100C (0x649100C)
================================================================================

_WORD *__fastcall sub_649100C(
        __int64 a1,
        char *s,
        char a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  int v15; // w8
  _WORD *v16; // x8
  size_t v17; // x0
  size_t v18; // x22
  char *v19; // x23
  const char *v20; // x3
  __int64 i; // x8
  int v22; // w11
  bool v23; // cf
  bool v24; // cf
  size_t v25; // x0
  size_t v26; // x22
  char *v27; // x23
  unsigned __int64 v28; // x24
  __int64 v29; // x8
  char v30; // w22
  unsigned __int8 *v31; // x21
  __int128 v32; // q0
  __int64 v33; // x8
  unsigned __int64 v35; // x24
  __int64 v36; // x8
  char v37; // w22
  __int128 v38; // q0
  __int64 v39; // x8
  __int128 v40; // [xsp+0h] [xbp-50h] BYREF
  char *v41; // [xsp+10h] [xbp-40h]
  __int128 v42; // [xsp+18h] [xbp-38h]
  __int64 v43; // [xsp+28h] [xbp-28h]
  unsigned __int8 *v44; // [xsp+30h] [xbp-20h] BYREF
  _QWORD v45[2]; // [xsp+38h] [xbp-18h] BYREF

  if ( !*(_BYTE *)(a1 + 420) )
    return 0LL;
  if ( !byte_724A7A8 || !byte_6FF55A0 )
  {
    if ( !*s )
      return 0LL;
    memset(v45, 0, 15);
    v17 = strlen(s);
    if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_6849630();
    v18 = v17;
    if ( v17 >= 0x17 )
    {
      v28 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v19 = (char *)sub_65ECAAC();
      *((_QWORD *)&v40 + 1) = v18;
      v41 = v19;
      *(_QWORD *)&v40 = v28 | 1;
    }
    else
    {
      v19 = (char *)&v40 + 1;
      LOBYTE(v40) = 2 * v17;
      if ( !v17 )
      {
LABEL_44:
        v29 = v45[0];
        v19[v18] = 0;
        LOBYTE(v42) = 0;
        *(_QWORD *)((char *)&v42 + 1) = v29;
        *((_QWORD *)&v42 + 1) = *(_QWORD *)((char *)v45 + 7);
        v43 = 0LL;
        v30 = sub_649334C(a1, (unsigned __int8 *)&v40, &v44);
        v31 = v44;
        if ( (v30 & 1) != 0 )
        {
          if ( (v42 & 1) == 0 )
          {
            if ( (v40 & 1) == 0 )
              goto LABEL_47;
LABEL_52:
            sub_65ECAF4();
            if ( (v30 & 1) == 0 )
              goto LABEL_70;
LABEL_53:
            if ( (a3 & 1) != 0 )
              goto LABEL_70;
            return 0LL;
          }
          sub_65ECAF4();
          if ( (v40 & 1) != 0 )
            goto LABEL_52;
        }
        else
        {
          v31 = sub_649364C((_DWORD *)a1, (__int64)&v40, (unsigned __int8 *)&v40, v44);
          if ( (*v31 & 1) != 0 )
            sub_65ECAF4();
          v32 = v40;
          *((_QWORD *)v31 + 2) = v41;
          *(_OWORD *)v31 = v32;
          LOWORD(v40) = 0;
          v33 = v43;
          *(_OWORD *)(v31 + 24) = v42;
          *((_QWORD *)v31 + 5) = v33;
          v43 = 0LL;
          v42 = 0uLL;
          if ( (v40 & 1) != 0 )
            goto LABEL_52;
        }
LABEL_47:
        if ( (v30 & 1) == 0 )
          goto LABEL_70;
        goto LABEL_53;
      }
    }
    memcpy(v19, s, v18);
    goto LABEL_44;
  }
  if ( s )
  {
    v15 = (unsigned __int8)*s;
    if ( (unsigned int)(v15 - 48) < 0xA || (unsigned int)(v15 - 65) < 0x1A || (unsigned int)(v15 - 97) <= 0x19 )
    {
      for ( i = 1LL; ; ++i )
      {
        v22 = (unsigned __int8)s[i];
        v23 = (unsigned int)(v22 - 48) >= 0xA && (unsigned int)(v22 - 65) >= 0x1A;
        v24 = v23 && (unsigned int)(v22 - 97) >= 0x1A;
        if ( v24
          && ((unsigned int)(v22 - 37) > 0x3A || ((1LL << ((unsigned __int8)v22 - 37)) & 0x400000000200701LL) == 0) )
        {
          break;
        }
      }
      if ( !s[i] && (unsigned int)i < 0x81 )
      {
        memset(v45, 0, 15);
        v25 = strlen(s);
        if ( v25 >= 0xFFFFFFFFFFFFFFF0LL )
          sub_6849630();
        v26 = v25;
        if ( v25 >= 0x17 )
        {
          v35 = (v25 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v27 = (char *)sub_65ECAAC();
          *((_QWORD *)&v40 + 1) = v26;
          v41 = v27;
          *(_QWORD *)&v40 = v35 | 1;
        }
        else
        {
          v27 = (char *)&v40 + 1;
          LOBYTE(v40) = 2 * v25;
          if ( !v25 )
          {
LABEL_60:
            v36 = v45[0];
            v27[v26] = 0;
            LOBYTE(v42) = 0;
            *(_QWORD *)((char *)&v42 + 1) = v36;
            *((_QWORD *)&v42 + 1) = *(_QWORD *)((char *)v45 + 7);
            v43 = 0LL;
            v37 = sub_649334C(a1, (unsigned __int8 *)&v40, &v44);
            v31 = v44;
            if ( (v37 & 1) != 0 )
            {
              if ( (v42 & 1) == 0 )
              {
                if ( (v40 & 1) == 0 )
                  goto LABEL_63;
LABEL_68:
                sub_65ECAF4();
                if ( (v37 & 1) == 0 )
                  goto LABEL_70;
LABEL_69:
                if ( (a3 & 1) != 0 )
                  goto LABEL_70;
                return 0LL;
              }
              sub_65ECAF4();
              if ( (v40 & 1) != 0 )
                goto LABEL_68;
            }
            else
            {
              v31 = sub_649364C((_DWORD *)a1, (__int64)&v40, (unsigned __int8 *)&v40, v44);
              if ( (*v31 & 1) != 0 )
                sub_65ECAF4();
              v38 = v40;
              *((_QWORD *)v31 + 2) = v41;
              *(_OWORD *)v31 = v38;
              LOWORD(v40) = 0;
              v39 = v43;
              *(_OWORD *)(v31 + 24) = v42;
              *((_QWORD *)v31 + 5) = v39;
              v43 = 0LL;
              v42 = 0uLL;
              if ( (v40 & 1) != 0 )
                goto LABEL_68;
            }
LABEL_63:
            if ( (v37 & 1) == 0 )
            {
LABEL_70:
              v16 = v31 + 24;
              if ( (v31[24] & 1) != 0 )
              {
                **((_BYTE **)v31 + 5) = 0;
                *((_QWORD *)v31 + 4) = 0LL;
              }
              else
              {
                *v16 = 0;
              }
              return v16;
            }
            goto LABEL_69;
          }
        }
        memcpy(v27, s, v26);
        goto LABEL_60;
      }
    }
  }
  if ( *(_BYTE *)(a1 + 448) )
    ++*(_DWORD *)(a1 + 452);
  if ( byte_724A758 )
  {
    v16 = 0LL;
    if ( (unsigned __int8)qword_6FF53B0 < 6u || BYTE1(qword_6FF53B0) < 3u )
      return v16;
  }
  else if ( !(_BYTE)qword_6FF53B0 )
  {
    return 0LL;
  }
  if ( s )
    v20 = s;
  else
    v20 = "NULL";
  sub_65C5C5C(
    qword_6FF53B0,
    qword_6FF53B8,
    (__int64)"[DFLog::InfluxTrace] Rejected invalid key name: %s",
    (__int64)v20,
    a9,
    a10,
    a11,
    a12,
    a4,
    a5,
    a6,
    a7,
    v40);
  return 0LL;
}


================================================================================
Function: sub_6491634 (0x6491634)
================================================================================

__int64 __fastcall sub_6491634(__int64 a1, __int64 a2, int a3, char a4)
{
  __int64 result; // x0
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x8
  __int64 v12; // x10
  __int64 v13; // x11
  unsigned __int64 v14; // x8
  _WORD *v16; // x23
  unsigned __int64 v17; // x8
  char v19; // w0
  __int64 v20; // x23
  __int64 v21; // x23
  unsigned __int64 *v22; // x19
  __int128 v23; // q0
  __int64 v24; // x8
  _WORD *v25; // x24
  unsigned __int64 v26; // x8
  __int64 v27; // x1
  unsigned __int64 v28; // x8
  __int64 v29; // x2
  __int64 v30; // x23
  _QWORD v31[5]; // [xsp+0h] [xbp-210h] BYREF
  __int128 v32; // [xsp+28h] [xbp-1E8h] BYREF
  __int64 v33; // [xsp+38h] [xbp-1D8h]
  __int128 v34; // [xsp+40h] [xbp-1D0h]
  __int64 v35; // [xsp+50h] [xbp-1C0h]
  __int64 v36; // [xsp+58h] [xbp-1B8h]
  __int64 v37; // [xsp+60h] [xbp-1B0h]
  _QWORD v38[3]; // [xsp+68h] [xbp-1A8h] BYREF
  char v39[8]; // [xsp+80h] [xbp-190h] BYREF

  if ( byte_723FF78 )
    return sub_648F020(a1, a2, (unsigned int)a3, 1LL, a4 & 1);
  sub_25F4F30(v39, 0LL);
  v9 = sub_648F57C(v39, a1);
  if ( byte_724A7A8 )
  {
    if ( byte_6FF56E8 )
    {
      v10 = sub_65ADBD0(v9);
      v11 = v36;
      if ( v36 && *(_QWORD *)(a1 + 456) )
      {
        v12 = *(_QWORD *)(a1 + 464);
        v13 = v37;
        v36 = *(_QWORD *)(a1 + 456);
        v37 = v12;
        *(_QWORD *)(a1 + 456) = v11;
        *(_QWORD *)(a1 + 464) = v13;
      }
      if ( byte_724A7A8 && byte_6FF5640 )
      {
        v14 = *(unsigned __int8 *)(a1 + 424);
        if ( (v14 & 1) != 0 ? *(_QWORD *)(a1 + 432) : v14 >> 1 )
        {
          memset(&v31[2], 0, 24);
          sub_648FA5C((int)&v32, "pointsdebug");
          sub_648EF10(v38, v39, &v32);
          v16 = (_WORD *)(a1 + 424);
          sub_25226F8(&v32);
          sub_648B9B0(v38[0] + 24LL, a1 + 424);
          v10 = v36;
          if ( v36 )
            v10 = (*(__int64 (**)(void))(*(_QWORD *)v36 + 24LL))();
          if ( (*(_BYTE *)v16 & 1) != 0 )
          {
            **(_BYTE **)(a1 + 440) = 0;
            *(_QWORD *)(a1 + 432) = 0LL;
          }
          else
          {
            *v16 = 0;
          }
        }
      }
      if ( !*(_BYTE *)(a1 + 420) )
        goto LABEL_36;
      v21 = *(unsigned int *)(a1 + 416);
      if ( dword_6CA8E70 == -1 )
      {
        dword_6CA8E70 = (unsigned int)sub_65F1790(v10) % 0x2710;
        if ( dword_6CA8E70 >= a3 )
        {
LABEL_36:
          v22 = (unsigned __int64 *)v37;
          if ( v37 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v37 + 8)) )
          {
            (*(void (__fastcall **)(unsigned __int64 *))(*v22 + 16))(v22);
            sub_68488BC(v22);
          }
          goto LABEL_63;
        }
      }
      else if ( dword_6CA8E70 >= a3 )
      {
        goto LABEL_36;
      }
      if ( (sub_648FB14(*(unsigned int *)(a1 + 416)) & 1) != 0 )
      {
        v31[0] = v36;
        v31[1] = v37;
        if ( v37 )
          sub_6867420(1uLL, (atomic_ullong *)(v37 + 8));
        ((void (__fastcall *)(__int64, char *, _QWORD, __int64, __int64, _QWORD, _QWORD *, _QWORD))sub_648FBF4)(
          a2,
          v39,
          a4 & 1,
          a1 + 392,
          v21,
          (unsigned int)a3,
          v31,
          *(unsigned int *)(a1 + 416));
        sub_649005C(v31);
      }
      goto LABEL_36;
    }
    if ( byte_6FF5640 )
    {
      v17 = *(unsigned __int8 *)(a1 + 424);
      if ( (v17 & 1) != 0 ? *(_QWORD *)(a1 + 432) : v17 >> 1 )
      {
        BYTE12(v32) = 0;
        LOBYTE(v32) = 22;
        DWORD2(v32) = 1735746149;
        LOBYTE(v34) = 0;
        *(_QWORD *)((char *)&v32 + 1) = *(_QWORD *)"pointsdebug";
        *(_QWORD *)((char *)&v34 + 1) = 0LL;
        *((_QWORD *)&v34 + 1) = 0LL;
        v35 = 0LL;
        v19 = sub_649334C(v39, &v32, v38);
        v20 = v38[0];
        if ( (v19 & 1) != 0 )
        {
          if ( (v34 & 1) != 0 )
            sub_65ECAF4();
        }
        else
        {
          v20 = sub_649364C(v39, &v32, &v32, v38[0]);
          if ( (*(_BYTE *)v20 & 1) != 0 )
            sub_65ECAF4();
          v23 = v32;
          *(_QWORD *)(v20 + 16) = v33;
          *(_OWORD *)v20 = v23;
          LOWORD(v32) = 0;
          v24 = v35;
          *(_OWORD *)(v20 + 24) = v34;
          *(_QWORD *)(v20 + 40) = v24;
          v35 = 0LL;
          v34 = 0uLL;
        }
        v25 = (_WORD *)(a1 + 424);
        if ( (v32 & 1) != 0 )
          sub_65ECAF4();
        v26 = *(unsigned __int8 *)(a1 + 424);
        if ( (v26 & 1) != 0 )
          v27 = *(_QWORD *)(a1 + 440);
        else
          v27 = a1 + 425;
        if ( (v26 & 1) != 0 )
          v28 = *(_QWORD *)(a1 + 432);
        else
          v28 = v26 >> 1;
        if ( v28 >= 0xF000 )
          v29 = 61440LL;
        else
          v29 = v28;
        v9 = sub_648B910(v20 + 24, v27, v29);
        if ( (*(_BYTE *)v25 & 1) != 0 )
        {
          **(_BYTE **)(a1 + 440) = 0;
          *(_QWORD *)(a1 + 432) = 0LL;
        }
        else
        {
          *v25 = 0;
        }
      }
    }
  }
  if ( *(_BYTE *)(a1 + 420) )
  {
    v30 = *(unsigned int *)(a1 + 416);
    if ( dword_6CA8E70 == -1 )
    {
      dword_6CA8E70 = (unsigned int)sub_65F1790(v9) % 0x2710;
      if ( dword_6CA8E70 >= a3 )
        goto LABEL_63;
    }
    else if ( dword_6CA8E70 >= a3 )
    {
      goto LABEL_63;
    }
    if ( (sub_648FB14(*(unsigned int *)(a1 + 416)) & 1) != 0 )
      sub_64900AC(a2, v39, a4 & 1, a1 + 392, v30, (unsigned int)a3);
  }
LABEL_63:
  result = sub_256B1A8(v39);
  if ( (v39[0] & 1) == 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_6491B58 (0x6491B58)
================================================================================

__int64 sub_6491B58()
{
  char v0; // w19
  char v1; // w19
  char v2; // w20
  char v3; // w21
  char v4; // w22
  char v5; // w23
  char v6; // w24
  char v7; // w19
  _QWORD v9[2]; // [xsp+8h] [xbp-38h] BYREF
  _QWORD v10[2]; // [xsp+20h] [xbp-20h] BYREF

  if ( (int)((unsigned int)sub_65F1790() % 0x2710) <= dword_6FF54D0 )
  {
    sub_65B0B0C(v10);
    v1 = sub_648B7F4(&xmmword_6FF5938, &word_6FF53D0);
    v2 = sub_648B7F4(v10, &word_6FF53F8);
    v3 = sub_648B7F4(&xmmword_6FF58D8, &word_6FF5420);
    sub_65B0B64(v9);
    v4 = sub_648B7F4(v9, &word_6FF5448);
    if ( (v9[0] & 1) != 0 )
      sub_65ECAF4();
    v5 = sub_648B7F4(&xmmword_6FF5908, &word_6FF5470);
    sub_65B0DD8(v9);
    v6 = sub_648B7F4(v9, &word_6FF5498);
    v7 = v1 & v2 & v3 & v4 & v5;
    if ( (v9[0] & 1) != 0 )
      sub_65ECAF4();
    v0 = v7 & v6;
    if ( (v10[0] & 1) != 0 )
      sub_65ECAF4();
  }
  else
  {
    v0 = 0;
  }
  return v0 & 1;
}


================================================================================
Function: sub_64929B8 (0x64929B8)
================================================================================

long double sub_64929B8()
{
  bool v0; // zf
  __int64 v1; // x0
  __int64 v2; // x20
  __int64 v3; // x19
  __int64 v4; // x20
  __int64 v5; // x0
  long double result; // q0

  if ( byte_724A7A8 )
    v0 = byte_7301120 == 0;
  else
    v0 = 1;
  if ( v0 )
  {
    v3 = sub_65ECAAC();
    *(_QWORD *)(v3 + 128) = 0LL;
    *(_QWORD *)v3 = off_6C225B8;
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_QWORD *)(v3 + 24) = off_6C22560;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    v1 = sub_65EE9A8(0x6000uLL);
    v4 = v3 + 24;
    *(_QWORD *)(v3 + 128) = 0LL;
    *(_QWORD *)(v3 + 64) = v1;
    *(_QWORD *)(v3 + 72) = 1024LL;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
  }
  else
  {
    v2 = sub_680599C();
    v3 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v2 + 16LL))(v2, 144LL, 8LL);
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_QWORD *)(v3 + 24) = v2;
    *(_QWORD *)(v3 + 136) = 0LL;
    *(_QWORD *)v3 = off_6C22510;
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
    *(_QWORD *)(v3 + 32) = off_6C22560;
    v4 = v3 + 32;
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    v5 = sub_65EE9A8(0x6000uLL);
    *(_QWORD *)(v3 + 136) = 0LL;
    *(_QWORD *)(v3 + 72) = v5;
    *(_QWORD *)(v3 + 80) = 1024LL;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
  }
  *(_OWORD *)&result = 0uLL;
  qword_6FF5740 = v4;
  qword_6FF5748 = v3;
  xmmword_6FF5750 = 0u;
  unk_6FF5760 = 0u;
  qword_6FF5770 = 0LL;
  return result;
}


================================================================================
Function: sub_649334C (0x649334C)
================================================================================

__int64 __fastcall sub_649334C(__int64 a1, unsigned __int8 *a2, _QWORD *a3)
{
  void *v4; // x22
  int v5; // w11
  __int64 v6; // x23
  size_t v7; // x9
  char *v8; // x10
  unsigned __int64 v10; // x8
  unsigned __int8 *v11; // x24
  unsigned __int64 v12; // x12
  char *v13; // x13
  unsigned __int64 v14; // x10
  __int64 v15; // t1
  unsigned int v16; // w20
  unsigned __int8 *v17; // x13
  int v18; // w26
  int i; // w28
  __int64 v20; // x25
  __int64 v21; // x10
  unsigned __int8 *v22; // x21
  size_t v23; // x2
  unsigned __int64 v24; // x11
  unsigned __int64 v25; // x9
  unsigned __int8 *v26; // x0
  unsigned __int8 *v27; // x1
  unsigned __int8 *v28; // x8
  void *v29; // x27
  int v30; // w22
  unsigned __int8 *v31; // x28
  int v32; // w0
  char v33; // w0
  char v34; // w8
  unsigned __int8 *v36; // [xsp+0h] [xbp-40h]
  __int16 v37; // [xsp+8h] [xbp-38h] BYREF
  char v38; // [xsp+Ah] [xbp-36h]
  __int16 v39[8]; // [xsp+20h] [xbp-20h] BYREF

  v4 = &_stack_chk_guard;
  v5 = *(_DWORD *)(a1 + 16);
  if ( (*(_DWORD *)a1 & 1) != 0 )
  {
    v5 = 8;
    v6 = a1 + 8;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 8);
  }
  if ( v5 )
  {
    v7 = *((_QWORD *)a2 + 1);
    v8 = (char *)*((_QWORD *)a2 + 2);
    v10 = *a2;
    v11 = a2 + 1;
    v39[0] = 0;
    v37 = 24322;
    v12 = v10 >> 1;
    if ( (v10 & 1) != 0 )
    {
      v12 = v7;
      v13 = v8;
    }
    else
    {
      v13 = (char *)(a2 + 1);
    }
    v38 = 0;
    if ( v12 )
    {
      v14 = 0LL;
      do
      {
        v15 = *v13++;
        --v12;
        v14 ^= (v14 << 6) + (v14 >> 2) + v15 + 2654435769u;
      }
      while ( v12 );
    }
    else
    {
      LODWORD(v14) = 0;
    }
    v17 = 0LL;
    v18 = v5 - 1;
    for ( i = 1; ; ++i )
    {
      v20 = (unsigned int)v14 & v18;
      v21 = (unsigned __int8)(v10 >> 1);
      v22 = (unsigned __int8 *)(v6 + 48LL * (unsigned int)v20);
      if ( (v10 & 1) != 0 )
        v23 = v7;
      else
        v23 = (unsigned __int8)(v10 >> 1);
      v24 = *v22;
      v25 = v24 >> 1;
      if ( (v24 & 1) != 0 )
        v25 = *((_QWORD *)v22 + 1);
      if ( v23 == v25 )
      {
        if ( (v10 & 1) != 0 )
          v26 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
        else
          v26 = v11;
        if ( (v24 & 1) != 0 )
          v27 = *(unsigned __int8 **)(v6 + 48 * v20 + 16);
        else
          v27 = v22 + 1;
        if ( (v10 & 1) != 0 )
        {
          if ( !v23 || (v29 = v4, v30 = i, v31 = v17, v32 = memcmp(v26, v27, v23), v17 = v31, i = v30, v4 = v29, !v32) )
          {
LABEL_37:
            v16 = 1;
            goto LABEL_38;
          }
        }
        else
        {
          v28 = v11;
          if ( !v23 )
            goto LABEL_37;
          while ( *v28 == *v27 )
          {
            --v21;
            ++v28;
            ++v27;
            if ( !v21 )
              goto LABEL_37;
          }
        }
      }
      v36 = v17;
      if ( (sub_6493590(v6 + 48LL * (unsigned int)v20, v39) & 1) != 0 )
        break;
      v33 = sub_6493590(v6 + 48LL * (unsigned int)v20, &v37);
      v17 = v36;
      v7 = *((_QWORD *)a2 + 1);
      LODWORD(v14) = v20 + i;
      v10 = *a2;
      if ( v36 == 0LL && (v33 & 1) != 0 )
        v17 = (unsigned __int8 *)(v6 + 48LL * (unsigned int)v20);
    }
    v16 = 0;
    if ( v36 )
      v22 = v36;
LABEL_38:
    v34 = v37;
    *a3 = v22;
    if ( (v34 & 1) != 0 )
      sub_65ECAF4();
    if ( (v39[0] & 1) != 0 )
      sub_65ECAF4();
  }
  else
  {
    v16 = 0;
    *a3 = 0LL;
  }
  return v16;
}


================================================================================
Function: sub_6493590 (0x6493590)
================================================================================

bool __fastcall sub_6493590(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x9
  unsigned __int64 v3; // x11
  size_t v4; // x2
  unsigned __int64 v5; // x8
  const void *v6; // x8
  unsigned __int8 *v7; // x1
  unsigned __int8 *v8; // x8
  __int64 v9; // x9
  int v10; // w10
  int v11; // t1
  int v12; // t1
  _BOOL8 result; // x0

  v2 = *a1;
  v3 = *a2;
  if ( (v2 & 1) != 0 )
    v4 = *((_QWORD *)a1 + 1);
  else
    v4 = v2 >> 1;
  v5 = v3 >> 1;
  if ( (v3 & 1) != 0 )
    v5 = *((_QWORD *)a2 + 1);
  if ( v4 != v5 )
    return 0LL;
  v6 = (const void *)*((_QWORD *)a1 + 2);
  if ( (v2 & 1) == 0 )
    v6 = a1 + 1;
  if ( (v3 & 1) != 0 )
    v7 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v7 = a2 + 1;
  if ( (v2 & 1) != 0 )
  {
    if ( v4 )
      return memcmp(v6, v7, v4) == 0;
    return 1LL;
  }
  if ( !v4 )
    return 1LL;
  v8 = a1 + 1;
  v9 = (v2 >> 1) - 1;
  do
  {
    v11 = *v8++;
    v10 = v11;
    v12 = *v7++;
    result = v10 == v12;
  }
  while ( v10 == v12 && v9-- != 0 );
  return result;
}


================================================================================
Function: sub_649364C (0x649364C)
================================================================================

unsigned __int8 *__fastcall sub_649364C(_DWORD *a1, __int64 a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int v6; // w8
  __int64 v7; // x1
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x8
  unsigned __int8 *v11; // [xsp+0h] [xbp-10h] BYREF

  v6 = *a1 >> 1;
  if ( (*a1 & 1) != 0 )
    v7 = 8LL;
  else
    v7 = (unsigned int)a1[4];
  if ( 4 * v6 + 4 >= (unsigned int)(3 * v7) )
  {
    v7 = (unsigned int)(2 * v7);
  }
  else if ( (int)v7 + ~v6 - a1[1] > (unsigned int)v7 >> 3 )
  {
    goto LABEL_6;
  }
  sub_649373C(a1, v7);
  sub_649334C((__int64)a1, a3, &v11);
  a4 = v11;
LABEL_6:
  *a1 += 2;
  v8 = *a4;
  if ( (v8 & 1) != 0 )
    v9 = *((_QWORD *)a4 + 1);
  else
    v9 = v8 >> 1;
  if ( v9 )
    --a1[1];
  return a4;
}


================================================================================
Function: sub_649373C (0x649373C)
================================================================================

__int64 __fastcall sub_649373C(__int64 result, unsigned int a2)
{
  unsigned int v2; // w20
  __int64 v3; // x25
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x8
  int v7; // w8
  __int64 v8; // x21
  __int64 v9; // x19
  unsigned __int64 v10; // x9
  __int64 v11; // x23
  unsigned __int64 v12; // x8
  __int64 v13; // x24
  _BYTE *v14; // x21
  unsigned __int8 *v15; // x25
  unsigned __int64 v16; // x19
  unsigned __int64 v17; // x27
  size_t v18; // x22
  const void *v19; // x0
  unsigned __int8 *v20; // x1
  unsigned __int8 *v21; // x8
  unsigned __int64 v22; // x9
  unsigned __int64 v23; // x9
  const void *v24; // x0
  unsigned __int8 *v25; // x1
  unsigned __int8 *v26; // x8
  __int64 v27; // x9
  __int128 v28; // q0
  __int128 v29; // q0
  char v30; // w8
  __int64 v31; // [xsp+0h] [xbp-1D0h]
  __int16 v32; // [xsp+10h] [xbp-1C0h] BYREF
  char v33; // [xsp+12h] [xbp-1BEh]
  unsigned __int64 v34; // [xsp+18h] [xbp-1B8h]
  __int16 v35; // [xsp+28h] [xbp-1A8h] BYREF
  char *v36; // [xsp+30h] [xbp-1A0h]
  unsigned __int8 *v37; // [xsp+38h] [xbp-198h]
  _BYTE v38[384]; // [xsp+40h] [xbp-190h] BYREF

  v2 = a2;
  v3 = result;
  if ( a2 >= 8 )
  {
    v4 = (a2 - 1) | ((unsigned __int64)(a2 - 1) >> 1);
    v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    v6 = v5 | (v5 >> 8) | ((v5 | (v5 >> 8)) >> 16);
    v7 = HIDWORD(v6) | v6;
    if ( (unsigned int)(v7 + 1) > 0x10 )
      v2 = v7 + 1;
    else
      v2 = 16;
  }
  if ( (*(_DWORD *)result & 1) == 0 )
  {
    v8 = *(_QWORD *)(result + 8);
    v9 = *(unsigned int *)(result + 16);
    if ( v2 > 8 )
    {
      *(_QWORD *)(result + 8) = sub_65ECAAC();
      *(_QWORD *)(v3 + 16) = v2;
    }
    else
    {
      *(_DWORD *)result |= 1u;
    }
    sub_6493AB8(v3, v8, v8 + 48 * v9);
    return sub_65ECAF4();
  }
  if ( v2 < 8 )
    return result;
  v10 = (unsigned __int64)&v32 + 1;
  v11 = result + 8;
  v12 = 0LL;
  v13 = 0LL;
  v14 = v38;
  v31 = result;
  v15 = (unsigned __int8 *)(result + 8);
  v35 = 0;
  v32 = 24322;
  v33 = 0;
  while ( 1 )
  {
    v16 = *v15;
    v17 = v16 >> 1;
    if ( (v16 & 1) != 0 )
      v18 = *(_QWORD *)(v11 + 48 * v13 + 8);
    else
      v18 = v16 >> 1;
    if ( (v12 & 1) == 0 )
      v10 = (unsigned __int8)(v12 >> 1);
    if ( v18 == v10 )
    {
      if ( (v16 & 1) != 0 )
        v19 = *(const void **)(v11 + 48 * v13 + 16);
      else
        v19 = v15 + 1;
      if ( (v12 & 1) != 0 )
        v20 = v37;
      else
        v20 = (unsigned __int8 *)&v35 + 1;
      if ( (v16 & 1) != 0 )
      {
        if ( !v18 || !memcmp(v19, v20, v18) )
          goto LABEL_45;
      }
      else
      {
        if ( !v18 )
          goto LABEL_46;
        v21 = v15 + 1;
        v22 = v16 >> 1;
        while ( *v21 == *v20 )
        {
          --v22;
          ++v21;
          ++v20;
          if ( !v22 )
            goto LABEL_46;
        }
      }
    }
    v23 = v34;
    if ( (v32 & 1) == 0 )
      v23 = (unsigned __int64)(unsigned __int8)v32 >> 1;
    if ( v18 != v23 )
      goto LABEL_44;
    if ( (v16 & 1) != 0 )
      v24 = *(const void **)(v11 + 48 * v13 + 16);
    else
      v24 = v15 + 1;
    v25 = (unsigned __int8 *)&v32 + 1;
    if ( (v16 & 1) == 0 )
    {
      if ( !v18 )
        goto LABEL_46;
      v26 = v15 + 1;
      while ( *v26 == *v25 )
      {
        --v17;
        ++v26;
        ++v25;
        if ( !v17 )
          goto LABEL_46;
      }
LABEL_44:
      v27 = v11 + 48 * v13;
      v28 = *(_OWORD *)v15;
      *((_QWORD *)v14 + 2) = *((_QWORD *)v15 + 2);
      *(_OWORD *)v14 = v28;
      *(_QWORD *)v15 = 0LL;
      *((_QWORD *)v15 + 1) = 0LL;
      *((_QWORD *)v15 + 2) = 0LL;
      v29 = *(_OWORD *)(v27 + 24);
      *((_QWORD *)v14 + 5) = *(_QWORD *)(v27 + 40);
      *(_OWORD *)(v14 + 24) = v29;
      v14 += 48;
      *(_QWORD *)(v27 + 32) = 0LL;
      *(_QWORD *)(v27 + 40) = 0LL;
      v30 = *v15;
      *(_QWORD *)(v27 + 24) = 0LL;
      if ( (v30 & 1) == 0 )
        goto LABEL_46;
      goto LABEL_45;
    }
    if ( v18 && memcmp(v24, (char *)&v32 + 1, v18) )
      goto LABEL_44;
LABEL_45:
    sub_65ECAF4();
LABEL_46:
    if ( ++v13 == 8 )
      break;
    v12 = (unsigned __int8)v35;
    v15 = (unsigned __int8 *)(v11 + 48 * v13);
    v10 = (unsigned __int64)v36;
  }
  *(_DWORD *)v31 &= ~1u;
  *(_QWORD *)(v31 + 8) = sub_65ECAAC();
  *(_QWORD *)(v31 + 16) = v2;
  result = sub_6493AB8(v31, v38, v14);
  if ( (v32 & 1) != 0 )
    result = sub_65ECAF4();
  if ( (v35 & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_6493AB8 (0x6493AB8)
================================================================================

__int64 __fastcall sub_6493AB8(__int64 result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  _DWORD *v5; // x21
  char v6; // w10
  int v7; // w10
  unsigned __int64 *v8; // x22
  __int64 v9; // x8
  __int64 v10; // x24
  int v11; // w24
  unsigned __int64 v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x8
  __int64 v15; // x9
  _BYTE *v16; // x25
  __int128 v17; // q0
  __int64 v18; // x8
  __int128 v19; // q0
  __int128 v20; // [xsp+8h] [xbp-28h] BYREF
  _BYTE *v21; // [xsp+20h] [xbp-10h] BYREF

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  LOWORD(v20) = 0;
  v7 = v6 & 1;
  if ( v7 )
    v8 = (unsigned __int64 *)(result + 8);
  else
    v8 = *(unsigned __int64 **)(result + 8);
  if ( v7 )
    v9 = 8LL;
  else
    v9 = *(unsigned int *)(result + 16);
  *(_DWORD *)result = v7;
  *(_DWORD *)(result + 4) = 0;
  if ( (_DWORD)v9 )
  {
    v10 = 48 * v9;
    do
    {
      result = (__int64)sub_68497A0(v8, &v20);
      v8 += 6;
      v10 -= 48LL;
    }
    while ( v10 );
    if ( (v20 & 1) != 0 )
      result = sub_65ECAF4();
  }
  BYTE2(v20) = 0;
  LOWORD(v20) = 24322;
  if ( a2 != a3 )
  {
    v11 = BYTE1(v20);
    while ( 1 )
    {
      v12 = *a2;
      v13 = *((_QWORD *)a2 + 1);
      v14 = v12 >> 1;
      if ( (v12 & 1) == 0 )
        v13 = v12 >> 1;
      if ( !v13 )
        goto LABEL_29;
      if ( v13 != 1 )
        goto LABEL_25;
      if ( (v12 & 1) == 0 )
        break;
      if ( **((unsigned __int8 **)a2 + 2) != v11 )
        goto LABEL_25;
LABEL_29:
      if ( (*a2 & 1) != 0 )
        result = sub_65ECAF4();
      a2 += 48;
      if ( a2 == a3 )
        return result;
    }
    v15 = 0LL;
    while ( a2[v15 + 1] == *((unsigned __int8 *)&v20 + v15 + 1) )
    {
      if ( v14 == ++v15 )
        goto LABEL_29;
    }
LABEL_25:
    result = sub_649334C((__int64)v5, a2, &v21);
    v16 = v21;
    if ( (*v21 & 1) != 0 )
      result = sub_65ECAF4();
    v17 = *(_OWORD *)a2;
    *((_QWORD *)v16 + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v16 = v17;
    v18 = *((_QWORD *)a2 + 5);
    *(_WORD *)a2 = 0;
    v19 = *(_OWORD *)(a2 + 24);
    *((_QWORD *)v16 + 5) = v18;
    *(_OWORD *)(v16 + 24) = v19;
    *((_QWORD *)a2 + 4) = 0LL;
    *((_QWORD *)a2 + 5) = 0LL;
    *((_QWORD *)a2 + 3) = 0LL;
    *v5 += 2;
    if ( (a2[24] & 1) != 0 )
      result = sub_65ECAF4();
    goto LABEL_29;
  }
  return result;
}


================================================================================
Function: sub_64949D8 (0x64949D8)
================================================================================

char *__fastcall sub_64949D8(unsigned int a1)
{
  if ( a1 > 2 )
    return &byte_CC4FFC;
  else
    return off_6C225F8[a1];
}


================================================================================
Function: sub_649523C (0x649523C)
================================================================================

double sub_649523C()
{
  return sub_65F819C() - *(double *)&qword_6FF5A00;
}


================================================================================
Function: sub_649525C (0x649525C)
================================================================================

bool sub_649525C()
{
  bool v0; // zf

  if ( byte_724A7A8 )
    v0 = byte_7248960 == 0;
  else
    v0 = 1;
  if ( v0 )
    return 0LL;
  if ( (unsigned __int8)byte_6FF5878 | (unsigned __int8)byte_6FF5898 )
    return 1LL;
  return byte_6FF58B8 != 0;
}


================================================================================
Function: sub_64952BC (0x64952BC)
================================================================================

bool sub_64952BC()
{
  bool v0; // zf

  if ( byte_724A7A8 )
    v0 = byte_7248960 == 0;
  else
    v0 = 1;
  return !v0 && byte_6FF5878 != 0;
}


================================================================================
Function: sub_64952FC (0x64952FC)
================================================================================

bool sub_64952FC()
{
  bool v0; // zf

  if ( byte_724A7A8 )
    v0 = byte_7248960 == 0;
  else
    v0 = 1;
  return !v0 && byte_6FF5898 != 0;
}


================================================================================
Function: sub_649533C (0x649533C)
================================================================================

bool sub_649533C()
{
  bool v0; // zf

  if ( byte_724A7A8 )
    v0 = byte_7248960 == 0;
  else
    v0 = 1;
  return !v0 && byte_6FF58B8 != 0;
}


================================================================================
Function: sub_649537C (0x649537C)
================================================================================

unsigned __int8 *__fastcall sub_649537C(unsigned __int8 *result, int a2)
{
  unsigned __int8 *v3; // x20
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x8
  bool v6; // w8
  char *v7; // x2
  _QWORD v8[3]; // [xsp+8h] [xbp-1F8h] BYREF
  _BYTE v9[472]; // [xsp+20h] [xbp-1E0h] BYREF

  v3 = result;
  v4 = *result;
  if ( (v4 & 1) != 0 )
    v5 = *((_QWORD *)result + 1);
  else
    v5 = v4 >> 1;
  if ( v5 == 19 )
  {
    result = (unsigned __int8 *)sub_684A118(result, 0LL, 0xFFFFFFFFFFFFFFFFLL, "ContextInfoMismatch", 0x13uLL);
    v6 = (_DWORD)result == 0;
    if ( !a2 )
      return result;
  }
  else
  {
    v6 = 0;
    if ( !a2 )
      return result;
  }
  if ( !v6 )
  {
    result = (unsigned __int8 *)sub_65F1790();
    if ( (unsigned int)result % 0x2710 < dword_6FF5860 )
    {
      sub_648BE34((__int64)v9, -1, 0);
      if ( (a2 & 1) != 0 )
      {
        sub_65B6B3C(v8, 1LL);
        sub_6490538(v9, "PlaceIdFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_65ECAF4();
        sub_6490538(v9, "PlaceIdFromAnalytics", &xmmword_6FF5938);
      }
      if ( (a2 & 8) != 0 )
      {
        sub_65B6B3C(v8, 9LL);
        sub_6490538(v9, "PlaceVersionFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_65ECAF4();
        sub_6490538(v9, "PlaceVersionFromAnalytics", &xmmword_6FF5950);
      }
      if ( (a2 & 2) != 0 )
      {
        sub_65B6B3C(v8, 2LL);
        sub_6490538(v9, "UniverseIdFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_65ECAF4();
        sub_6490538(v9, "UniverseIdFromAnalytics", &xmmword_6FF59B0);
      }
      if ( (a2 & 4) != 0 )
      {
        sub_65B6B3C(v8, 3LL);
        sub_6490538(v9, "DatacenterIdFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_65ECAF4();
        sub_64909C4((__int64)v9, "DatacenterIdFromAnalytics", dword_6CA8E8C);
      }
      if ( (a2 & 0x10) != 0 )
      {
        sub_65B6B3C(v8, 10LL);
        sub_6490538(v9, "ServerIpFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_65ECAF4();
        sub_6490538(v9, "ServerIpFromAnalytics", &qword_6FF5968);
      }
      if ( (a2 & 0x20) != 0 )
      {
        sub_65B6B3C(v8, 11LL);
        sub_6490538(v9, "ServerPortFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_65ECAF4();
        sub_64909C4((__int64)v9, "ServerPortFromAnalytics", dword_6CA8E88);
      }
      if ( (a2 & 0x40) != 0 )
      {
        sub_65B6B3C(v8, 12LL);
        sub_6490538(v9, "StreamingEnabledFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_65ECAF4();
        if ( (unsigned int)dword_6FF59E0 > 2 )
          v7 = &byte_CC4FFC;
        else
          v7 = off_6C225F8[dword_6FF59E0];
        sub_6490454(v9, "StreamingEnabledFromAnalytics", v7);
      }
      sub_6490538(v9, "EventName", v3);
      sub_65B6BB0(v8, 0LL);
      sub_6490538(v9, "PrimaryContext", v8);
      if ( (v8[0] & 1) != 0 )
        sub_65ECAF4();
      sub_65B6B3C(v8, 0LL);
      sub_6490538(v9, "CurrentContext", v8);
      if ( (v8[0] & 1) != 0 )
        sub_65ECAF4();
      sub_64909C4((__int64)v9, "MismatchedFields", a2);
      strcpy((char *)v8, "&ContextInfoMismatch");
      sub_6491634((__int64)v9, (__int64)v8, 10000, 0);
      if ( (v8[0] & 1) != 0 )
        sub_65ECAF4();
      return (unsigned __int8 *)sub_256AE00((__int64)v9);
    }
  }
  return result;
}


================================================================================
Function: sub_64957EC (0x64957EC)
================================================================================

long double __fastcall sub_64957EC(__int64 a1)
{
  long double result; // q0

  *(_QWORD *)(a1 + 128) = 0LL;
  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)a1 = "TelemetryInformation";
  *(_QWORD *)(a1 + 8) = 20LL;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 1065353216;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 88) = 1065353216;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  return result;
}


================================================================================
Function: sub_6495824 (0x6495824)
================================================================================

__int64 __fastcall sub_6495824(__int64 a1)
{
  return a1 + 16;
}


================================================================================
Function: sub_649582C (0x649582C)
================================================================================

__int64 __fastcall sub_649582C(__int64 a1)
{
  return a1 + 56;
}


================================================================================
Function: sub_64959E4 (0x64959E4)
================================================================================

__int64 __fastcall sub_64959E4(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  __int64 v6; // x0
  __int64 result; // x0
  __int64 v8; // x0
  _QWORD v9[3]; // [xsp+0h] [xbp-30h] BYREF
  _BYTE v10[8]; // [xsp+18h] [xbp-18h] BYREF
  __int64 v11; // [xsp+20h] [xbp-10h] BYREF

  if ( (*(_BYTE *)a2 & 1) != 0 )
    v6 = *(_QWORD *)(a2 + 16);
  else
    v6 = a2 + 1;
  result = sub_648BC4C(v6);
  if ( (result & 1) != 0 )
  {
    sub_6848980((pthread_mutex_t *)(a1 + 96));
    memset(v9, 0, sizeof(v9));
    sub_648B9B0((__int64)v9, a3);
    v11 = a2;
    v8 = sub_25B1368(a1 + 56, a2, &unk_16C3014, &v11, v10);
    sub_684A438((unsigned __int8 *)(v8 + 40), (unsigned __int8 *)v9);
    if ( (v9[0] & 1) != 0 )
      sub_65ECAF4();
    return sub_68489D4((pthread_mutex_t *)(a1 + 96));
  }
  return result;
}


================================================================================
Function: sub_6495AE4 (0x6495AE4)
================================================================================

__int64 __fastcall sub_6495AE4(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v6; // x0
  __int64 result; // x0
  __int64 v8; // x0
  _QWORD v9[3]; // [xsp+0h] [xbp-30h] BYREF
  _BYTE v10[8]; // [xsp+18h] [xbp-18h] BYREF
  __int64 v11; // [xsp+20h] [xbp-10h] BYREF

  if ( (*(_BYTE *)a2 & 1) != 0 )
    v6 = *(_QWORD *)(a2 + 16);
  else
    v6 = a2 + 1;
  result = sub_648BC4C(v6);
  if ( (result & 1) != 0 )
  {
    sub_6848980((pthread_mutex_t *)(a1 + 96));
    memset(v9, 0, sizeof(v9));
    sub_648BA6C(v9, a3);
    v11 = a2;
    v8 = sub_25B1368(a1 + 56, a2, &unk_16C3014, &v11, v10);
    sub_684A438((unsigned __int8 *)(v8 + 40), (unsigned __int8 *)v9);
    if ( (v9[0] & 1) != 0 )
      sub_65ECAF4();
    return sub_68489D4((pthread_mutex_t *)(a1 + 96));
  }
  return result;
}


================================================================================
Function: sub_6496200 (0x6496200)
================================================================================

__int64 __fastcall sub_6496200(__int64 a1)
{
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)a1 = "AnalyticsStaticAttributes";
  *(_QWORD *)(a1 + 8) = 25LL;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_64962AC();
  return sub_649673C(a1);
}


================================================================================
Function: sub_64962AC (0x64962AC)
================================================================================

__int64 __fastcall sub_64962AC(__int64 a1)
{
  unsigned __int64 *v1; // x20
  unsigned __int8 v2; // w8
  __int64 *v3; // x19
  __int64 v4; // x0
  __int64 v5; // x21
  __int64 v6; // x0
  __int64 v7; // x0
  char *v8; // x1
  size_t v9; // x2
  __int64 v10; // x0
  unsigned __int64 v11; // x21
  char *v12; // x1
  size_t v13; // x2
  unsigned __int64 v14; // x21
  _QWORD *v15; // x0
  char *v16; // x1
  size_t v17; // x2
  char *v18; // x1
  size_t v19; // x2
  __int64 result; // x0
  __int128 v21; // [xsp+8h] [xbp-58h] BYREF
  unsigned __int8 v22; // [xsp+20h] [xbp-40h] BYREF
  char v23[15]; // [xsp+21h] [xbp-3Fh] BYREF
  char *v24; // [xsp+30h] [xbp-30h]
  __int128 v25; // [xsp+38h] [xbp-28h] BYREF
  _BYTE v26[8]; // [xsp+50h] [xbp-10h] BYREF

  v1 = (unsigned __int64 *)(a1 + 16);
  sub_6601820((unsigned __int64 *)(a1 + 16), 0x200uLL);
  sub_684A29C(v1, "application");
  sub_6601588(v1, 61);
  LOBYTE(v25) = 12;
  strcpy((char *)&v25 + 1, "Client");
  v2 = atomic_load(byte_6D95888);
  if ( (v2 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6D95888) )
  {
    qword_6D95848 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6D95850);
    qword_6D95878 = 0LL;
    unk_6D95880 = 0LL;
    qword_6D95848 = (__int64)off_690F7A8;
    qword_6CB14F8 = (__int64)&qword_6D95848;
    sub_6862850(byte_6D95888);
  }
  v3 = (__int64 *)sub_3324E40((__int64)&qword_6D95848);
  v4 = sub_6495824(v3[6]);
  v22 = 22;
  strcpy(v23, "application");
  v5 = sub_2638B34(v4, &v22);
  if ( (v22 & 1) != 0 )
    sub_65ECAF4();
  if ( v5 )
  {
    v6 = sub_6495824(v3[6]);
    v22 = 22;
    strcpy(v23, "application");
    *(_QWORD *)&v21 = &v22;
    v7 = sub_252DBAC(v6, &v22, &unk_16C3015, &v21, v26);
    sub_684A438((unsigned __int8 *)&v25, (unsigned __int8 *)(v7 + 40));
    if ( (v22 & 1) != 0 )
      sub_65ECAF4();
  }
  sub_648B444(&v25, (unsigned __int64 *)&v22);
  if ( (v22 & 1) != 0 )
    v8 = v24;
  else
    v8 = v23;
  if ( (v22 & 1) != 0 )
    v9 = *(_QWORD *)&v23[7];
  else
    v9 = (unsigned __int64)v22 >> 1;
  sub_65FFB9C(v1, v8, v9);
  if ( (v22 & 1) != 0 )
    sub_65ECAF4();
  sub_65B0B0C(&v22);
  if ( (v22 & 1) != 0 )
    v11 = *(_QWORD *)&v23[7];
  else
    v11 = (unsigned __int64)v22 >> 1;
  if ( (v22 & 1) != 0 )
    v10 = sub_65ECAF4();
  if ( v11 )
  {
    sub_684A544(v1, ",ostype=");
    sub_65B0B0C(&v21);
    sub_648B444(&v21, (unsigned __int64 *)&v22);
    if ( (v22 & 1) != 0 )
      v12 = v24;
    else
      v12 = v23;
    if ( (v22 & 1) != 0 )
      v13 = *(_QWORD *)&v23[7];
    else
      v13 = (unsigned __int64)v22 >> 1;
    v10 = (__int64)sub_65FFB9C(v1, v12, v13);
    if ( (v22 & 1) != 0 )
      v10 = sub_65ECAF4();
    if ( (v21 & 1) != 0 )
      v10 = sub_65ECAF4();
  }
  sub_65B0B34(&v22, v10);
  if ( (v22 & 1) != 0 )
    v14 = *(_QWORD *)&v23[7];
  else
    v14 = (unsigned __int64)v22 >> 1;
  if ( (v22 & 1) != 0 )
    sub_65ECAF4();
  if ( v14 )
  {
    v15 = sub_684A544(v1, ",osname=");
    sub_65B0B34(&v21, v15);
    sub_648B444(&v21, (unsigned __int64 *)&v22);
    if ( (v22 & 1) != 0 )
      v16 = v24;
    else
      v16 = v23;
    if ( (v22 & 1) != 0 )
      v17 = *(_QWORD *)&v23[7];
    else
      v17 = (unsigned __int64)v22 >> 1;
    sub_65FFB9C(v1, v16, v17);
    if ( (v22 & 1) != 0 )
      sub_65ECAF4();
    if ( (v21 & 1) != 0 )
      sub_65ECAF4();
  }
  sub_684A544(v1, ",appversion=");
  LOBYTE(v21) = 22;
  strcpy((char *)&v21 + 1, "2.663.0.660");
  sub_648B444(&v21, (unsigned __int64 *)&v22);
  if ( (v22 & 1) != 0 )
    v18 = v24;
  else
    v18 = v23;
  if ( (v22 & 1) != 0 )
    v19 = *(_QWORD *)&v23[7];
  else
    v19 = (unsigned __int64)v22 >> 1;
  sub_65FFB9C(v1, v18, v19);
  if ( (v22 & 1) != 0 )
    sub_65ECAF4();
  if ( (v21 & 1) != 0 )
    sub_65ECAF4();
  result = (*(__int64 (__fastcall **)(__int64 *))(*v3 + 16))(v3);
  if ( (v25 & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_649673C (0x649673C)
================================================================================

__int64 __fastcall sub_649673C(__int64 a1)
{
  unsigned __int64 *v1; // x20
  char *v3; // x1
  size_t v4; // x2
  char *v5; // x1
  size_t v6; // x2
  _QWORD *v7; // x0
  char v8; // w0
  char *v9; // x1
  size_t v10; // x2
  unsigned __int8 *v11; // x19
  _QWORD *v12; // x0
  __int64 v13; // x0
  char *v14; // x1
  size_t v15; // x2
  _QWORD *v16; // x0
  char *v17; // x1
  size_t v18; // x2
  _QWORD *v19; // x0
  __int64 v20; // x0
  const char *v21; // x21
  size_t v22; // x0
  size_t v23; // x20
  char *v24; // x22
  unsigned __int64 v25; // x23
  char *v26; // x1
  size_t v27; // x2
  _QWORD *v28; // x0
  __int64 v29; // x0
  char *v30; // x1
  size_t v31; // x2
  _QWORD *v32; // x0
  __int64 v33; // x0
  char *v34; // x1
  size_t v35; // x2
  _QWORD *v36; // x0
  __int64 v37; // x0
  char *v38; // x1
  size_t v39; // x2
  __int64 v40; // x0
  _QWORD *v41; // x0
  unsigned __int64 v42; // x20
  _QWORD *v43; // x0
  char *v44; // x1
  size_t v45; // x2
  unsigned __int64 v46; // x20
  _QWORD *v47; // x0
  char *v48; // x1
  size_t v49; // x2
  _QWORD *v50; // x0
  __int64 v51; // x0
  char *v52; // x1
  size_t v53; // x2
  __int64 result; // x0
  _QWORD v55[2]; // [xsp+0h] [xbp-140h] BYREF
  _QWORD v56[2]; // [xsp+18h] [xbp-128h] BYREF
  _QWORD v57[2]; // [xsp+30h] [xbp-110h] BYREF
  _QWORD v58[2]; // [xsp+48h] [xbp-F8h] BYREF
  _QWORD v59[2]; // [xsp+60h] [xbp-E0h] BYREF
  _QWORD v60[2]; // [xsp+78h] [xbp-C8h] BYREF
  _QWORD v61[3]; // [xsp+90h] [xbp-B0h] BYREF
  _QWORD v62[2]; // [xsp+A8h] [xbp-98h] BYREF
  unsigned __int64 v63[2]; // [xsp+C0h] [xbp-80h] BYREF
  unsigned __int64 v64[2]; // [xsp+D8h] [xbp-68h] BYREF
  unsigned __int64 v65[2]; // [xsp+F0h] [xbp-50h] BYREF
  unsigned __int64 v66[2]; // [xsp+108h] [xbp-38h] BYREF
  __int64 v67; // [xsp+120h] [xbp-20h] BYREF
  size_t v68; // [xsp+128h] [xbp-18h]
  char *v69; // [xsp+130h] [xbp-10h]

  v1 = (unsigned __int64 *)(a1 + 40);
  sub_684A29C((_QWORD *)(a1 + 40), &byte_CC4FFC);
  sub_6601820(v1, 0x200uLL);
  sub_684A544(v1, "device=");
  sub_65B0DD8(v66);
  sub_6496FE8(&v67, (int)v66);
  if ( (v67 & 1) != 0 )
    v3 = v69;
  else
    v3 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v4 = v68;
  else
    v4 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_65FFB9C(v1, v3, v4);
  if ( (v67 & 1) != 0 )
    sub_65ECAF4();
  if ( (v66[0] & 1) != 0 )
    sub_65ECAF4();
  sub_684A544(v1, ",osversion=");
  sub_65B0B64(v65);
  sub_6496FE8(&v67, (int)v65);
  if ( (v67 & 1) != 0 )
    v5 = v69;
  else
    v5 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v6 = v68;
  else
    v6 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_65FFB9C(v1, v5, v6);
  if ( (v67 & 1) != 0 )
    sub_65ECAF4();
  if ( (v65[0] & 1) != 0 )
    sub_65ECAF4();
  v7 = sub_684A544(v1, ",64bit=");
  v8 = sub_65B058C(v7);
  sub_684BDC8(v8 & 1, v64);
  sub_6496FE8(&v67, (int)v64);
  if ( (v67 & 1) != 0 )
    v9 = v69;
  else
    v9 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v10 = v68;
  else
    v10 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_65FFB9C(v1, v9, v10);
  if ( (v67 & 1) != 0 )
    sub_65ECAF4();
  if ( (v64[0] & 1) != 0 )
    sub_65ECAF4();
  v11 = (unsigned __int8 *)(a1 + 64);
  sub_684A438(v11, (unsigned __int8 *)v1);
  v12 = sub_684A544(v11, ",platformid=");
  v13 = sub_65B0B5C(v12);
  sub_684BDC8(v13, v63);
  sub_6496FE8(&v67, (int)v63);
  if ( (v67 & 1) != 0 )
    v14 = v69;
  else
    v14 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v15 = v68;
  else
    v15 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_65FFB9C((unsigned __int64 *)v11, v14, v15);
  if ( (v67 & 1) != 0 )
    sub_65ECAF4();
  if ( (v63[0] & 1) != 0 )
    sub_65ECAF4();
  v16 = sub_684A544(v11, ",cpu=");
  sub_65B03C8(v62, v16);
  sub_6496FE8(&v67, (int)v62);
  if ( (v67 & 1) != 0 )
    v17 = v69;
  else
    v17 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v18 = v68;
  else
    v18 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_65FFB9C((unsigned __int64 *)v11, v17, v18);
  if ( (v67 & 1) != 0 )
    sub_65ECAF4();
  if ( (v62[0] & 1) != 0 )
    sub_65ECAF4();
  if ( byte_7247D28 )
  {
    v19 = sub_684A544(v11, ",binary_arch=");
    v20 = sub_65FE32C(v19);
    v21 = (const char *)sub_65FE334(v20);
    v22 = strlen(v21);
    if ( v22 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_6849630();
    v23 = v22;
    if ( v22 >= 0x17 )
    {
      v25 = (v22 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v24 = (char *)sub_65ECAAC();
      v61[1] = v23;
      v61[2] = v24;
      v61[0] = v25 | 1;
    }
    else
    {
      v24 = (char *)v61 + 1;
      LOBYTE(v61[0]) = 2 * v22;
      if ( !v22 )
        goto LABEL_58;
    }
    memcpy(v24, v21, v23);
LABEL_58:
    v24[v23] = 0;
    sub_6496FE8(&v67, (int)v61);
    if ( (v67 & 1) != 0 )
      v26 = v69;
    else
      v26 = (char *)&v67 + 1;
    if ( (v67 & 1) != 0 )
      v27 = v68;
    else
      v27 = (unsigned __int64)(unsigned __int8)v67 >> 1;
    sub_65FFB9C((unsigned __int64 *)v11, v26, v27);
    if ( (v67 & 1) != 0 )
      sub_65ECAF4();
    if ( (v61[0] & 1) != 0 )
      sub_65ECAF4();
  }
  v28 = sub_684A544(v11, ",coretotal=");
  v29 = sub_65B0568(v28);
  sub_684C254(v60, v29);
  sub_6496FE8(&v67, (int)v60);
  if ( (v67 & 1) != 0 )
    v30 = v69;
  else
    v30 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v31 = v68;
  else
    v31 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_65FFB9C((unsigned __int64 *)v11, v30, v31);
  if ( (v67 & 1) != 0 )
    sub_65ECAF4();
  if ( (v60[0] & 1) != 0 )
    sub_65ECAF4();
  v32 = sub_684A544(v11, ",corelogical=");
  v33 = sub_65B0550(v32);
  sub_684C254(v59, v33);
  sub_6496FE8(&v67, (int)v59);
  if ( (v67 & 1) != 0 )
    v34 = v69;
  else
    v34 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v35 = v68;
  else
    v35 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_65FFB9C((unsigned __int64 *)v11, v34, v35);
  if ( (v67 & 1) != 0 )
    sub_65ECAF4();
  if ( (v59[0] & 1) != 0 )
    sub_65ECAF4();
  v36 = sub_684A544(v11, ",corephysical=");
  v37 = sub_65B0534(v36);
  sub_684C254(v58, v37);
  sub_6496FE8(&v67, (int)v58);
  if ( (v67 & 1) != 0 )
    v38 = v69;
  else
    v38 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v39 = v68;
  else
    v39 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  v40 = (__int64)sub_65FFB9C((unsigned __int64 *)v11, v38, v39);
  if ( (v67 & 1) != 0 )
    v40 = sub_65ECAF4();
  if ( (v58[0] & 1) != 0 )
    v40 = sub_65ECAF4();
  v41 = sub_65B0E80(&v67, v40);
  if ( (v67 & 1) != 0 )
    v42 = v68;
  else
    v42 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  if ( (v67 & 1) != 0 )
    v41 = (_QWORD *)sub_65ECAF4();
  if ( v42 )
  {
    v43 = sub_684A544(v11, ",manufacturer=");
    sub_65B0E80(v57, v43);
    sub_6496FE8(&v67, (int)v57);
    if ( (v67 & 1) != 0 )
      v44 = v69;
    else
      v44 = (char *)&v67 + 1;
    if ( (v67 & 1) != 0 )
      v45 = v68;
    else
      v45 = (unsigned __int64)(unsigned __int8)v67 >> 1;
    v41 = sub_65FFB9C((unsigned __int64 *)v11, v44, v45);
    if ( (v67 & 1) != 0 )
      v41 = (_QWORD *)sub_65ECAF4();
    if ( (v57[0] & 1) != 0 )
      v41 = (_QWORD *)sub_65ECAF4();
  }
  sub_65B0E90(&v67, v41);
  if ( (v67 & 1) != 0 )
    v46 = v68;
  else
    v46 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  if ( (v67 & 1) != 0 )
    sub_65ECAF4();
  if ( v46 )
  {
    v47 = sub_684A544(v11, ",gpu=");
    sub_65B0E90(v56, v47);
    sub_6496FE8(&v67, (int)v56);
    if ( (v67 & 1) != 0 )
      v48 = v69;
    else
      v48 = (char *)&v67 + 1;
    if ( (v67 & 1) != 0 )
      v49 = v68;
    else
      v49 = (unsigned __int64)(unsigned __int8)v67 >> 1;
    sub_65FFB9C((unsigned __int64 *)v11, v48, v49);
    if ( (v67 & 1) != 0 )
      sub_65ECAF4();
    if ( (v56[0] & 1) != 0 )
      sub_65ECAF4();
  }
  v50 = sub_684A544(v11, ",rammb=");
  v51 = sub_65B0A90(v50);
  sub_684C254(v55, v51);
  sub_6496FE8(&v67, (int)v55);
  if ( (v67 & 1) != 0 )
    v52 = v69;
  else
    v52 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v53 = v68;
  else
    v53 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  result = (__int64)sub_65FFB9C((unsigned __int64 *)v11, v52, v53);
  if ( (v67 & 1) != 0 )
    result = sub_65ECAF4();
  if ( (v55[0] & 1) != 0 )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_6496FE8 (0x6496FE8)
================================================================================

__int64 *__usercall sub_6496FE8@<X0>(__int64 *__return_ptr a1@<X8>, unsigned __int8 *a2@<X0>)
{
  char *v4; // x22
  char *v5; // x8
  size_t v6; // x9
  unsigned __int64 v7; // x11
  int v8; // w10
  unsigned __int64 v9; // x11
  unsigned __int64 v10; // x12
  unsigned __int8 *v11; // x13
  unsigned __int8 *v12; // x8
  _BYTE *v13; // x10
  unsigned __int64 v14; // x14
  unsigned __int64 v15; // d1
  unsigned __int64 v16; // x11
  size_t v17; // x12
  char *v18; // x4
  char *v19; // x13
  int v20; // t1
  unsigned __int64 v21; // x11
  size_t v22; // x12
  char *v23; // x4
  char *v24; // x13
  int v25; // t1
  unsigned __int64 v26; // x11
  char *v27; // x1
  size_t v28; // x2
  unsigned __int64 *v29; // x0
  __int128 v30; // q0
  __int64 *result; // x0
  __int64 v32; // x8
  __int128 v33; // q0
  char v34; // w9
  unsigned __int64 v35; // [xsp+8h] [xbp-38h] BYREF
  __int128 v36; // [xsp+20h] [xbp-20h] BYREF
  unsigned __int64 v37; // [xsp+30h] [xbp-10h]

  v4 = (char *)(a2 + 1);
  v6 = *((_QWORD *)a2 + 1);
  v5 = (char *)*((_QWORD *)a2 + 2);
  v7 = *a2;
  v8 = v7 & 1;
  v9 = v7 >> 1;
  if ( v8 )
    v10 = *((_QWORD *)a2 + 1);
  else
    v10 = v9;
  if ( v8 )
    v11 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v11 = a2 + 1;
  if ( v10 )
  {
    v12 = v11;
    if ( v10 >= 8 )
    {
      v12 = &v11[v10 & 0xFFFFFFFFFFFFFFF8LL];
      v13 = v11 + 3;
      v14 = v10 & 0xFFFFFFFFFFFFFFF8LL;
      while ( 1 )
      {
        v15 = vceq_s8(*(int8x8_t *)(v13 - 3), (int8x8_t)0x2C2C2C2C2C2C2C2CLL).n64_u64[0];
        if ( (v15 & 1) != 0 )
        {
          *(v13 - 3) = 95;
          if ( (v15 & 0x100) == 0 )
          {
LABEL_13:
            if ( (v15 & 0x10000) == 0 )
              goto LABEL_14;
            goto LABEL_22;
          }
        }
        else if ( (v15 & 0x100) == 0 )
        {
          goto LABEL_13;
        }
        *(v13 - 2) = 95;
        if ( (v15 & 0x10000) == 0 )
        {
LABEL_14:
          if ( (v15 & 0x1000000) == 0 )
            goto LABEL_15;
          goto LABEL_23;
        }
LABEL_22:
        *(v13 - 1) = 95;
        if ( (v15 & 0x1000000) == 0 )
        {
LABEL_15:
          if ( (v15 & 0x100000000LL) == 0 )
            goto LABEL_16;
          goto LABEL_24;
        }
LABEL_23:
        *v13 = 95;
        if ( (v15 & 0x100000000LL) == 0 )
        {
LABEL_16:
          if ( (v15 & 0x10000000000LL) == 0 )
            goto LABEL_17;
          goto LABEL_25;
        }
LABEL_24:
        v13[1] = 95;
        if ( (v15 & 0x10000000000LL) == 0 )
        {
LABEL_17:
          if ( (v15 & 0x1000000000000LL) == 0 )
            goto LABEL_18;
          goto LABEL_26;
        }
LABEL_25:
        v13[2] = 95;
        if ( (v15 & 0x1000000000000LL) == 0 )
        {
LABEL_18:
          if ( (v15 & 0x100000000000000LL) != 0 )
            goto LABEL_27;
          goto LABEL_10;
        }
LABEL_26:
        v13[3] = 95;
        if ( (v15 & 0x100000000000000LL) != 0 )
LABEL_27:
          v13[4] = 95;
LABEL_10:
        v14 -= 8LL;
        v13 += 8;
        if ( !v14 )
        {
          if ( v10 == (v10 & 0xFFFFFFFFFFFFFFF8LL) )
            goto LABEL_29;
          goto LABEL_43;
        }
      }
    }
    do
    {
LABEL_43:
      if ( *v12 == 44 )
        *v12 = 95;
      ++v12;
    }
    while ( v12 != &v11[v10] );
LABEL_29:
    v16 = *a2;
    v6 = *((_QWORD *)a2 + 1);
    v5 = (char *)*((_QWORD *)a2 + 2);
    v8 = v16 & 1;
    v9 = v16 >> 1;
  }
  if ( v8 )
    v17 = v6;
  else
    v17 = v9;
  if ( v8 )
    v18 = v5;
  else
    v18 = (char *)(a2 + 1);
  if ( v17 )
  {
    v19 = v18;
    while ( 1 )
    {
      v20 = (unsigned __int8)*v19++;
      if ( v20 == 92 )
        break;
      ++v18;
      if ( !--v17 )
        goto LABEL_46;
    }
    *(_QWORD *)&v36 = "\\";
    *((_QWORD *)&v36 + 1) = "";
    sub_2D6A56C(a2, (__int64 *)&v36, "\\\\", (__int64)"", v18, v18 + 1, "\\\\");
    v21 = *a2;
    v6 = *((_QWORD *)a2 + 1);
    v5 = (char *)*((_QWORD *)a2 + 2);
    v8 = v21 & 1;
    v9 = v21 >> 1;
  }
LABEL_46:
  if ( v8 )
    v22 = v6;
  else
    v22 = v9;
  if ( v8 )
    v23 = v5;
  else
    v23 = v4;
  if ( v22 )
  {
    v24 = v23;
    while ( 1 )
    {
      v25 = (unsigned __int8)*v24++;
      if ( v25 == 34 )
        break;
      ++v23;
      if ( !--v22 )
        goto LABEL_58;
    }
    *(_QWORD *)&v36 = "\"";
    *((_QWORD *)&v36 + 1) = "";
    sub_2D6A56C(a2, (__int64 *)&v36, "\\\"", (__int64)"", v23, v23 + 1, "\\\"");
    v26 = *a2;
    v6 = *((_QWORD *)a2 + 1);
    v5 = (char *)*((_QWORD *)a2 + 2);
    v8 = v26 & 1;
    v9 = v26 >> 1;
  }
LABEL_58:
  if ( v8 )
    v27 = v5;
  else
    v27 = v4;
  if ( v8 )
    v28 = v6;
  else
    v28 = v9;
  BYTE2(v35) = 0;
  LOWORD(v35) = 8706;
  v29 = sub_65FFB9C(&v35, v27, v28);
  v30 = *(_OWORD *)v29;
  v37 = v29[2];
  v36 = v30;
  v29[1] = 0LL;
  v29[2] = 0LL;
  *v29 = 0LL;
  result = sub_684A544(&v36, "\"");
  v32 = result[2];
  v33 = *(_OWORD *)result;
  *result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  v34 = v36;
  a1[2] = v32;
  *(_OWORD *)a1 = v33;
  if ( (v34 & 1) != 0 )
    result = (__int64 *)sub_65ECAF4();
  if ( (v35 & 1) != 0 )
    return (__int64 *)sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_6499074 (0x6499074)
================================================================================

char *sub_6499074()
{
  __int64 v0; // x19
  unsigned __int64 v1; // x9
  unsigned __int64 v2; // x8
  size_t v3; // x2
  char *v4; // x0
  __int64 v5; // x10
  int v6; // w12
  bool v7; // zf
  unsigned int v8; // w12
  char v9; // w13
  int v10; // w12
  unsigned __int64 v11; // x11
  unsigned __int8 *v12; // x1
  __int64 v13; // x9

  v0 = qword_6FF5D60;
  v1 = *(unsigned __int8 *)qword_6FF5D60;
  v2 = v1 >> 1;
  if ( (v1 & 1) != 0 )
    v3 = *(_QWORD *)(qword_6FF5D60 + 8);
  else
    v3 = v1 >> 1;
  if ( (v1 & 1) != 0 )
    v4 = *(char **)(qword_6FF5D60 + 16);
  else
    v4 = (char *)(qword_6FF5D60 + 1);
  if ( !v3 )
    return &byte_6FF5D40;
  v5 = 0LL;
  do
  {
    v6 = v4[v5];
    v7 = v6 == 32;
    v8 = v6 - 14;
    v9 = !v7;
    v10 = (unsigned __int8)v9 & (v8 < 0xFFFFFFFB);
    if ( (v10 & 1) != 0 )
      break;
    v7 = v3 - 1 == v5++;
  }
  while ( !v7 );
  if ( !v10 )
    return &byte_6FF5D40;
  v11 = qword_6FF5D48;
  if ( (byte_6FF5D40 & 1) == 0 )
    v11 = (unsigned __int64)(unsigned __int8)byte_6FF5D40 >> 1;
  if ( v3 != v11 )
    return (char *)v0;
  if ( (byte_6FF5D40 & 1) != 0 )
    v12 = (unsigned __int8 *)qword_6FF5D50;
  else
    v12 = (unsigned __int8 *)&unk_6FF5D41;
  if ( (v1 & 1) != 0 )
  {
    if ( memcmp(v4, v12, v3) )
      return (char *)v0;
    return &byte_6FF5D40;
  }
  v13 = 0LL;
  while ( *(unsigned __int8 *)(qword_6FF5D60 + v13 + 1) == v12[v13] )
  {
    if ( v2 == ++v13 )
      return &byte_6FF5D40;
  }
  return (char *)v0;
}


================================================================================
Function: sub_64994C0 (0x64994C0)
================================================================================

__int64 sub_64994C0()
{
  return qword_6FF5D70;
}


================================================================================
Function: sub_649DBA8 (0x649DBA8)
================================================================================

unsigned __int64 *__usercall sub_649DBA8@<X0>(__int64 a1@<X0>, unsigned __int64 *a2@<X8>)
{
  unsigned __int8 *v4; // x0
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x8
  __int64 v7; // x0
  _BYTE *v8; // x8
  __int64 v9; // x0
  __int128 *v11; // x0

  v4 = (unsigned __int8 *)sub_64994C0();
  v5 = *v4;
  if ( (v5 & 1) != 0 )
    v6 = *((_QWORD *)v4 + 1);
  else
    v6 = v5 >> 1;
  if ( v6
    && ((v7 = sub_64994C0(), (*(_BYTE *)v7 & 1) == 0) ? (v8 = (_BYTE *)(v7 + 1)) : (v8 = *(_BYTE **)(v7 + 16)),
        a1 && *v8 == 46) )
  {
    v9 = sub_64994C0();
    return (unsigned __int64 *)sub_684B0A8(a1, v9);
  }
  else
  {
    v11 = (__int128 *)sub_64994C0();
    return sub_68497A0(a2, v11);
  }
}


================================================================================
Function: sub_649DC84 (0x649DC84)
================================================================================

__int64 sub_649DC84()
{
  return sub_649DBA8("ephemeralcounters.api");
}


================================================================================
Function: sub_649F0D0 (0x649F0D0)
================================================================================

_QWORD *__fastcall sub_649F0D0(_QWORD *result)
{
  *result = 0LL;
  result[1] = 0LL;
  return result;
}


================================================================================
Function: sub_64D0BC0 (0x64D0BC0)
================================================================================

__int64 __fastcall sub_64D0BC0(__int64 result)
{
  int v1; // w8

  *(_BYTE *)(result + 4) = 0;
  v1 = (unsigned __int8)byte_6FF71C8;
  *(_DWORD *)result = -1;
  *(_QWORD *)(result + 8) = -1LL;
  if ( v1 )
    result = sub_64D0C0C();
  if ( byte_72400A8 )
    return sub_64D0DE0(result);
  return result;
}


================================================================================
Function: sub_64D0C0C (0x64D0C0C)
================================================================================

__int64 __fastcall sub_64D0C0C(__int64 result)
{
  bool v1; // zf
  unsigned int *v2; // x20
  unsigned __int8 v3; // w8
  __int64 v4; // x4
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  _QWORD *v8; // x19
  long double v9; // q0
  long double v10; // q1
  long double v11; // q2
  long double v12; // q3
  __int64 v13; // x0
  __int64 v14; // x2
  __int64 v15[3]; // [xsp+0h] [xbp-20h] BYREF

  if ( byte_724A7A8 )
    v1 = byte_72400A8 == 0;
  else
    v1 = 1;
  if ( v1 )
    return result;
  v2 = (unsigned int *)result;
  v3 = atomic_load(byte_6D95888);
  if ( (v3 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6D95888) )
  {
    qword_6D95848 = (__int64)off_686F7E8;
    sub_68489F4(&stru_6D95850);
    qword_6D95878 = 0LL;
    unk_6D95880 = 0LL;
    qword_6D95848 = (__int64)off_690F7A8;
    qword_6CB14F8 = (__int64)&qword_6D95848;
    sub_6862850(byte_6D95888);
  }
  v8 = (_QWORD *)sub_3324E40((__int64)&qword_6D95848);
  if ( byte_724A7A8 && byte_724A758 )
  {
    if ( (unsigned __int8)qword_6FF7250 < 6u || BYTE1(qword_6FF7250) < 3u )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( (_BYTE)qword_6FF7250 )
LABEL_12:
    sub_65C5C5C(
      qword_6FF7250,
      qword_6FF7258,
      (__int64)"[DFLog::ConnectionStatusMonitor] Labeling connection status %d",
      *v2,
      v4,
      v5,
      v6,
      v7,
      v9,
      v10,
      v11,
      v12,
      v15[0]);
LABEL_13:
  v13 = v8[6];
  v14 = *v2;
  strcpy((char *)v15, " connectionStatus");
  result = sub_6495AE4(v13, v15, v14);
  if ( (v15[0] & 1) != 0 )
    result = sub_65ECAF4();
  if ( v8 )
    return (*(__int64 (__fastcall **)(_QWORD *))(*v8 + 16LL))(v8);
  return result;
}


================================================================================
Function: sub_64D0DE0 (0x64D0DE0)
================================================================================

void sub_64D0DE0()
{
  unsigned __int64 v0; // x8
  unsigned __int8 v1; // w8
  _QWORD *v2; // x19
  __int64 v3; // x0
  char v4; // [xsp+0h] [xbp-20h] BYREF
  _QWORD v5[2]; // [xsp+1h] [xbp-1Fh] BYREF

  if ( byte_72400A8 )
  {
    v0 = qword_6FF7210;
    if ( (word_6FF7208 & 1) == 0 )
      v0 = (unsigned __int64)(unsigned __int8)word_6FF7208 >> 1;
    if ( v0 )
    {
      v1 = atomic_load(byte_6D95888);
      if ( (v1 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6D95888) )
      {
        qword_6D95848 = (__int64)off_686F7E8;
        sub_68489F4(&stru_6D95850);
        qword_6D95878 = 0LL;
        unk_6D95880 = 0LL;
        qword_6D95848 = (__int64)off_690F7A8;
        qword_6CB14F8 = (__int64)&qword_6D95848;
        sub_6862850(byte_6D95888);
      }
      v2 = (_QWORD *)sub_3324E40((__int64)&qword_6D95848);
      v3 = v2[6];
      v4 = 30;
      strcpy((char *)v5, "Playtest_Owners");
      sub_64959E4(v3, &v4, &word_6FF7208);
      if ( (v4 & 1) != 0 )
        sub_65ECAF4();
      if ( v2 )
        (*(void (__fastcall **)(_QWORD *))(*v2 + 16LL))(v2);
    }
  }
}


================================================================================
Function: sub_64D12DC (0x64D12DC)
================================================================================

void *sub_64D12DC()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_6FF73B8);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_6FF73B8) )
  {
    sub_64D0BC0(&unk_6FF73A8);
    __cxa_atexit((void (*)(void *))sub_64D0F60, &unk_6FF73A8, &off_686E780);
    sub_6862850(byte_6FF73B8);
  }
  return &unk_6FF73A8;
}


================================================================================
Function: sub_64D151C (0x64D151C)
================================================================================

bool __fastcall sub_64D151C(__int64 a1)
{
  bool v1; // zf

  if ( byte_724A7A8 )
    v1 = byte_6FF71E8 == 0;
  else
    v1 = 1;
  return v1 || *(_BYTE *)(a1 + 4) == 0;
}


================================================================================
Function: sub_650A098 (0x650A098)
================================================================================

unsigned __int64 __fastcall sub_650A098(char *a1, const char *a2, int a3)
{
  __int64 v6; // x0
  pthread_mutex_t *v7; // x19
  unsigned __int64 v8; // x22
  unsigned __int16 v9; // w20
  int *v10; // x22
  unsigned __int16 v11; // w25
  unsigned int v12; // w28
  int v13; // w8
  unsigned int v14; // w0
  unsigned int v15; // w9
  __int64 v16; // x27
  int v17; // w10
  unsigned int v18; // w8
  unsigned int v19; // w0
  size_t v20; // x25
  char v21; // w9
  unsigned __int8 *v22; // x10
  char v23; // w8
  int v24; // t1
  char v25; // w9
  unsigned __int8 *v26; // x10
  int v27; // t1
  int *v28; // x8

  v6 = sub_650A36C();
  v7 = (pthread_mutex_t *)sub_650A2D0(v6);
  sub_6848AE0(v7);
  v8 = sub_650AB08(a1, a2);
  if ( !v8 )
  {
    if ( dword_6FF86D8[0] == 1024 )
    {
      v8 = 0LL;
      goto LABEL_23;
    }
    v9 = sub_650ABCC(a1);
    v10 = &dword_6FF86D8[23 * v9];
    v11 = dword_6FF86D8[0];
    v12 = v10[481];
    v13 = v10[480] + 1;
    ++dword_6FF86D8[0];
    v10[480] = v13;
    v14 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
    v15 = dword_6FF8768;
    v16 = v11;
    if ( v12 <= v14 )
      v17 = v14;
    else
      v17 = v12;
    v18 = v10[480];
    v10[481] = v17;
    if ( v15 > v18 )
      v18 = v15;
    v8 = (0x10000LL << v9) & 0xFFFFFFFFFFFF0000LL | v11;
    dword_6FF8768 = v18;
    *(_QWORD *)&dword_6FF86D8[24 * v11 + 1566] = v8;
    v19 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
    if ( v19 >= 0x3F )
      v20 = 63LL;
    else
      v20 = v19;
    memcpy(&dword_6FF86D8[24 * v16 + 1570], a2, v20);
    if ( a3 != -1 )
    {
LABEL_22:
      v28 = &dword_6FF86D8[24 * v16];
      *((_BYTE *)v28 + v20 + 6280) = 0;
      v28[1586] = v20;
      v28[1587] = a3 & 0xFFFFFF;
      v28[1569] = v9;
      v28[1568] = v16;
      *((_BYTE *)&dword_6FF86D8[26142] + v16) = v9;
      goto LABEL_23;
    }
    v21 = *a1;
    if ( *a1 )
    {
      v22 = (unsigned __int8 *)(a1 + 1);
      v23 = 5;
      do
      {
        v23 = (33 * v23) ^ v21;
        v24 = *v22++;
        v21 = v24;
      }
      while ( v24 );
      v25 = *a2;
      if ( !*a2 )
        goto LABEL_21;
    }
    else
    {
      v23 = 5;
      v25 = *a2;
      if ( !*a2 )
      {
LABEL_21:
        a3 = dword_16C5E98[v23 & 0x1F];
        goto LABEL_22;
      }
    }
    v26 = (unsigned __int8 *)(a2 + 1);
    do
    {
      v23 = (33 * v23) ^ v25;
      v27 = *v26++;
      v25 = v27;
    }
    while ( v27 );
    goto LABEL_21;
  }
LABEL_23:
  sub_6848B0C(v7);
  return v8;
}


================================================================================
Function: sub_650A2AC (0x650A2AC)
================================================================================

__int64 __fastcall sub_650A2AC(__int64 a1)
{
  __int64 v1; // x8

  v1 = *(int *)(a1 + 1336);
  if ( (unsigned int)v1 > 3 )
    return 0x40000LL;
  else
    return (unsigned int)dword_AFD1A0[v1];
}


================================================================================
Function: sub_650A2D0 (0x650A2D0)
================================================================================

__int64 sub_650A2D0()
{
  unsigned __int8 v0; // w8
  pthread_mutex_t *v2; // x20

  v0 = atomic_load(byte_715FA40);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_715FA40) )
  {
    v2 = (pthread_mutex_t *)sub_65ECAAC();
    sub_68489F4(v2);
    qword_715FA38 = (__int64)v2;
    sub_6862850(byte_715FA40);
  }
  return qword_715FA38;
}


================================================================================
Function: sub_650A35C (0x650A35C)
================================================================================

// attributes: thunk
__int64 sub_650A35C()
{
  return sub_650A2D0();
}


================================================================================
Function: sub_650A360 (0x650A360)
================================================================================

int *sub_650A360()
{
  return dword_6FF86D8;
}


================================================================================
Function: sub_650A36C (0x650A36C)
================================================================================

__int64 __fastcall sub_650A36C(__int64 a1)
{
  pthread_mutex_t *v1; // x20
  __int64 v2; // x9
  char *v3; // x8
  __int64 v4; // x23
  __int64 v5; // x27
  int *v6; // x8
  int *v7; // x9
  __int64 v8; // x9
  __int128 *v9; // x8
  int64x2_t v10; // q0
  int64x2_t v11; // q1
  __int64 *v12; // x23
  int v13; // w22
  __int64 v14; // t1
  __int64 v15; // x20
  __int64 v16; // x0
  pthread_mutex_t *v18; // [xsp+0h] [xbp-20h]
  __int64 v19; // [xsp+8h] [xbp-18h] BYREF
  __int64 v20; // [xsp+10h] [xbp-10h]

  v1 = (pthread_mutex_t *)sub_650A2D0(a1);
  sub_6848AE0(v1);
  if ( (byte_715FA48 & 1) == 0 )
  {
    v18 = v1;
    byte_715FA48 = 1;
    memset(dword_6FF86D8, 0, 0x167320uLL);
    atomic_store(0x167320u, &dword_7082680);
    *((_BYTE *)dword_6FF86D8 + (unsigned int)&qword_1758[1] + 4) = 0;
    byte_6FF8E10 = 0;
    byte_6FF970C = 0;
    byte_6FF9768 = 0;
    byte_6FF97C4 = 0;
    byte_6FF9820 = 0;
    byte_6FF987C = 0;
    byte_6FF98D8 = 0;
    byte_6FF9934 = 0;
    byte_6FF9990 = 0;
    byte_6FF99EC = 0;
    byte_6FF9A48 = 0;
    byte_6FF9AA4 = 0;
    byte_6FF9B00 = 0;
    byte_6FF9B5C = 0;
    byte_6FF9BB8 = 0;
    byte_6FF9C14 = 0;
    byte_6FF9C70 = 0;
    byte_6FF9CCC = 0;
    byte_6FF9D28 = 0;
    byte_6FF9D84 = 0;
    byte_6FF9DE0 = 0;
    *((_BYTE *)dword_6FF86D8 + (unsigned int)qword_1818 + 4) = 0;
    v2 = 1024LL;
    byte_6FF8E6C = 0;
    *((_BYTE *)dword_6FF86D8 + (unsigned int)&qword_17B8[1]) = 0;
    byte_6FF8EC8 = 0;
    byte_6FF8F24 = 0;
    byte_6FF8F80 = 0;
    byte_6FF8FDC = 0;
    byte_6FF9038 = 0;
    qword_6FF8990 = 0x746C7561666564LL;
    v3 = &byte_6FF9FC0;
    byte_6FF9094 = 0;
    byte_6FF90F0 = 0;
    byte_6FF914C = 0;
    byte_6FF91A8 = 0;
    byte_6FF9204 = 0;
    byte_6FF9260 = 0;
    byte_6FF92BC = 0;
    byte_6FF9318 = 0;
    byte_6FF9374 = 0;
    byte_6FF93D0 = 0;
    byte_6FF942C = 0;
    byte_6FF9488 = 0;
    byte_6FF94E4 = 0;
    byte_6FF9540 = 0;
    byte_6FF959C = 0;
    byte_6FF95F8 = 0;
    byte_6FF9654 = 0;
    byte_6FF96B0 = 0;
    qword_6FF89D0 = 0LL;
    byte_6FF89D8 = 0;
    qword_6FF8A18 = 0LL;
    byte_6FF8A20 = 0;
    qword_6FF8A60 = 0LL;
    byte_6FF8A68 = 0;
    qword_6FF8AA8 = 0LL;
    byte_6FF8AB0 = 0;
    qword_6FF8AF0 = 0LL;
    byte_6FF8AF8 = 0;
    qword_6FF8B38 = 0LL;
    byte_6FF8B40 = 0;
    qword_6FF8B80 = 0LL;
    byte_6FF8B88 = 0;
    qword_6FF8BC8 = 0LL;
    byte_6FF8BD0 = 0;
    qword_6FF8C10 = 0LL;
    byte_6FF8C18 = 0;
    qword_6FF8C58 = 0LL;
    byte_6FF8C60 = 0;
    qword_6FF8CA0 = 0LL;
    byte_6FF8CA8 = 0;
    qword_6FF8CE8 = 0LL;
    byte_6FF8CF0 = 0;
    qword_6FF8D30 = 0LL;
    byte_6FF8D38 = 0;
    qword_6FF8D78 = 0LL;
    byte_6FF8D80 = 0;
    qword_6FF8DC0 = 0LL;
    byte_6FF8DC8 = 0;
    qword_6FF8E08 = 0LL;
    dword_6FF86E0 = 1;
    do
    {
      v2 -= 2LL;
      *(v3 - 96) = 0;
      *v3 = 0;
      v3 += 192;
    }
    while ( v2 );
    dword_6FF86DC = 0;
    clock_gettime(1, (struct timespec *)&v19);
    dword_6FF8704 = 22;
    qword_6FF8708 = 0LL;
    dword_6FF8710 = 0;
    qword_6FF86F8 = v20 + 1000000000 * v19;
    *(int *)((char *)dword_6FF86D8 + (unsigned int)&stru_88978) = -1;
    dword_7081458 = -1;
    dword_6FF86E8 = 60;
    *(int *)((char *)dword_6FF86D8 + (unsigned int)&stru_89188) = -1;
    qword_6FF8738 = 0LL;
    *(_QWORD *)&dword_6FF8740 = 0x100000000LL;
    qword_6FF8720 = 0LL;
    qword_6FF8728 = 0LL;
    dword_6FF86D8[0] = 0;
    dword_7081C68 = -1;
    dword_7082070 = -1;
    dword_6FF8760 = 1;
    qword_6FF8988 = 0x3CF5C8D9420551ECLL;
    clock_gettime(1, (struct timespec *)&v19);
    v4 = 0LL;
    v5 = v20 + 1000000000 * v19;
    do
    {
      v6 = &dword_6FF86D8[v4];
      v7 = &dword_6FF86D8[v4 + 141296];
      *((_QWORD *)v7 + 2) = 0LL;
      *(_OWORD *)v7 = 0u;
      *((_QWORD *)v6 + 70652) = 0LL;
      *((_QWORD *)v6 + 70651) = v5;
      *((_WORD *)v6 + 282896) = 0;
      v6[141306] = -1;
      v6[141437] = 0;
      v6[141436] = 0;
      v6[141435] = 0;
      sub_65C22CC(&dword_6FF86D8[v4 + 141438]);
      v4 += 154LL;
    }
    while ( v4 != 78848 );
    v8 = 512LL;
    v9 = &xmmword_715C770;
    v10 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    v11 = vdupq_n_s64(0x8000000000000000LL);
    dword_70DC768 = 0;
    do
    {
      v8 -= 4LL;
      v9[256] = (__int128)v10;
      v9[257] = (__int128)v10;
      *v9 = (__int128)v11;
      v9[1] = (__int128)v11;
      v9 += 2;
    }
    while ( v8 );
    v12 = &qword_7082280;
    dword_715E770 = -1;
    if ( qword_7082280 )
    {
      v13 = 0;
      v12 = &qword_7082280;
      do
      {
        v14 = v12[1];
        ++v12;
        ++v13;
      }
      while ( v14 );
    }
    else
    {
      v13 = 0;
    }
    v15 = sub_65ECAAC();
    sub_68673F0(0x540u, (atomic_uint *)&dword_7082680);
    *v12 = v15;
    memset((void *)v15, 0, 0x540uLL);
    *(_DWORD *)(v15 + 56) = v13;
    *(_WORD *)(v15 + 1272) = 20551;
    *(_BYTE *)(v15 + 1274) = 85;
    v16 = syscall(178LL);
    dword_6FF8774 = 0;
    *(_BYTE *)(v15 + 1340) = 1;
    *(_DWORD *)(v15 + 1336) = 2;
    qword_715F9F8 = v15;
    unk_715E7E0 = 0;
    dword_715E7E4 = 0;
    *(_QWORD *)(v15 + 48) = 1LL;
    byte_715E7E8 = 0;
    byte_70D3738 = 0;
    sub_651C08C(v16);
    v1 = v18;
  }
  return sub_6848B0C(v1);
}


================================================================================
Function: sub_650A860 (0x650A860)
================================================================================

__int64 sub_650A860()
{
  return *sub_6866980(qword_6CA8FC8);
}


================================================================================
Function: sub_650A880 (0x650A880)
================================================================================

_QWORD *__fastcall sub_650A880(__int64 a1)
{
  _QWORD *result; // x0

  result = sub_6866980(qword_6CA8FC8);
  *result = a1;
  return result;
}


================================================================================
Function: sub_650A8B0 (0x650A8B0)
================================================================================

__int64 __fastcall sub_650A8B0(const char *a1, int a2)
{
  __int64 v4; // x0
  pthread_mutex_t *v5; // x19
  int v6; // w24
  const char *v7; // x21
  __int64 v8; // x22
  __int64 v9; // x20
  int v10; // w0
  __int64 v11; // x23

  v4 = sub_650A36C();
  v5 = (pthread_mutex_t *)sub_650A2D0(v4);
  sub_6848AE0(v5);
  if ( !sub_650A860() )
  {
    if ( a1 )
      v6 = a2;
    else
      v6 = 0;
    if ( a1 )
      v7 = a1;
    else
      v7 = "<Unknown>";
    v8 = 0LL;
    while ( *(_QWORD *)&dword_6FF86D8[2 * v8 + 141034] )
    {
      if ( ++v8 == 128 )
      {
        v9 = 0LL;
        goto LABEL_16;
      }
    }
    v9 = sub_65ECAAC();
    sub_68673F0(0x540u, (atomic_uint *)&unk_7082680);
    *(_QWORD *)&dword_6FF86D8[2 * v8 + 141034] = v9;
    memset((void *)v9, 0, 0x540uLL);
    *(_DWORD *)(v9 + 56) = v8;
    v10 = __strlen_chk(v7, 0xFFFFFFFFFFFFFFFFLL);
    if ( v10 >= 63 )
      v11 = 63LL;
    else
      v11 = v10;
    __memcpy_chk(v9 + 1272, v7);
    *(_BYTE *)(v9 + 1272 + v11) = 0;
    *(_DWORD *)(v9 + 52) = syscall(178LL);
    *(_DWORD *)(v9 + 1336) = v6;
    *(_BYTE *)(v9 + 1340) = 1;
LABEL_16:
    sub_650A880(v9);
  }
  return sub_6848B0C(v5);
}


================================================================================
Function: sub_650AB08 (0x650AB08)
================================================================================

__int64 __fastcall sub_650AB08(const char *a1, const char *a2)
{
  pthread_mutex_t *v4; // x19
  __int64 v5; // x23
  const char *v6; // x22
  char *v7; // x24
  __int64 v8; // x20

  sub_650A36C((__int64)a1);
  v4 = (pthread_mutex_t *)sub_650A2D0();
  sub_6848AE0(v4);
  v5 = (unsigned int)dword_6FF86D8[0];
  if ( dword_6FF86D8[0] )
  {
    v6 = (const char *)&unk_6FF9F60;
    v7 = &byte_7011F50;
    while ( strcasecmp(a2, v6) || strcasecmp(a1, (const char *)&dword_6FF86D8[23 * (unsigned __int8)*v7 + 462]) )
    {
      v6 += 96;
      ++v7;
      if ( !--v5 )
        goto LABEL_7;
    }
    v8 = *((_QWORD *)v6 - 2);
  }
  else
  {
LABEL_7:
    v8 = 0LL;
  }
  sub_6848B0C(v4);
  return v8;
}


================================================================================
Function: sub_650ABCC (0x650ABCC)
================================================================================

__int64 __fastcall sub_650ABCC(char *s1, int a2)
{
  __int64 v4; // x19
  __int64 v5; // x23
  const char *v6; // x22
  bool v7; // zf
  size_t v8; // x0
  __int64 v9; // x25
  int *v10; // x8
  size_t v11; // x22
  int *v12; // x23
  __int64 v13; // x11
  int *v14; // x9
  __int64 v15; // x10
  __int64 v16; // x12
  int v17; // w13

  v4 = (unsigned int)dword_6FF86DC;
  if ( dword_6FF86DC )
  {
    v5 = 0LL;
    v6 = &byte_6FF8E10;
    while ( strcasecmp(s1, v6) )
    {
      ++v5;
      v6 += 92;
      if ( v4 == v5 )
        goto LABEL_5;
    }
    LODWORD(v4) = v5;
  }
  else
  {
LABEL_5:
    if ( byte_724A7A8 )
      v7 = byte_6FF8698 == 0;
    else
      v7 = 1;
    if ( v7 )
    {
      dword_6FF86DC = v4 + 1;
      v8 = strlen(s1);
      v9 = (unsigned __int16)v4;
    }
    else
    {
      if ( (unsigned int)(v4 - 48) < 0xFFFFFFCF )
      {
        LODWORD(v4) = 47;
        return (unsigned int)v4;
      }
      v9 = (unsigned __int16)v4;
      if ( (unsigned __int16)v4 == 47 )
        s1 = "OverflowGroup";
      dword_6FF86DC = v4 + 1;
      v8 = strlen(s1);
    }
    v10 = &dword_6FF86D8[23 * v9];
    if ( v8 >= 0x3F )
      v11 = 63LL;
    else
      v11 = v8;
    v12 = v10 + 462;
    memcpy(v10 + 462, s1, v11);
    v13 = qword_6FF89D0;
    v14 = &dword_6FF86D8[23 * v9];
    v15 = qword_6FF8750;
    v16 = qword_6FF8758;
    *((_BYTE *)v12 + v11) = 0;
    v14[478] = v11;
    v17 = dword_6FF8714;
    v14[479] = v9;
    v14[484] = a2;
    *((_OWORD *)v14 + 120) = xmmword_AFD6C0;
    qword_6FF89D0 = v13 | (1LL << v9);
    qword_6FF8750 = v15 | (1LL << v9);
    qword_6FF8758 = v16 | ((unsigned __int64)(a2 == 1) << v9);
    if ( dword_6FF8760 | v17 && dword_6FF8740 )
      qword_6FF8708 |= 1LL << v9;
  }
  return (unsigned int)v4;
}


================================================================================
Function: sub_650ADB4 (0x650ADB4)
================================================================================

__int64 __fastcall sub_650ADB4(char *a1)
{
  __int64 v2; // x0
  pthread_mutex_t *v3; // x19
  __int64 v4; // x20

  v2 = sub_650A36C();
  v3 = (pthread_mutex_t *)sub_650A2D0(v2);
  sub_6848AE0(v3);
  v4 = 0x10000LL << sub_650ABCC(a1);
  sub_6848B0C(v3);
  return v4;
}


================================================================================
Function: sub_650B298 (0x650B298)
================================================================================

__int64 __fastcall sub_650B298(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // x22
  __int16 v4; // w21
  __int64 v5; // x20
  __int64 v6; // x0
  unsigned int v7; // w0
  __int64 v8; // x24
  __int64 v9; // x27
  __int64 v10; // x8
  unsigned int v11; // w8
  __int64 v13; // x24
  __int64 v14; // x8
  unsigned int v15; // w8
  unsigned int v16; // w25
  __int64 v17; // x9
  size_t v18; // x22
  void *v19; // x0
  unsigned int *v20; // x10
  unsigned int v21; // w28
  __int64 v22; // x9
  __int64 v23; // x26
  size_t v24; // x22
  void *v25; // x0
  int v26; // w22
  __int64 v27; // x21
  __int64 v28; // x8
  unsigned int v29; // w8
  __int64 v30; // x9
  size_t v31; // x20
  void *v32; // x0
  unsigned __int64 v33; // x8
  __int64 v34; // [xsp+8h] [xbp-18h] BYREF
  __int64 v35; // [xsp+10h] [xbp-10h]

  v2 = a1 >> 16;
  if ( (qword_6FF8708 & (a1 >> 16)) == 0 )
    return -1LL;
  v4 = a1;
  v5 = sub_650A860(a1);
  if ( !v5 )
  {
    v6 = sub_650A8B0(0LL, 2LL);
    v5 = sub_650A860(v6);
    if ( !v5 )
      return -1LL;
  }
  if ( a2 == -1 )
  {
    clock_gettime(1, (struct timespec *)&v34);
    a2 = v35 + 1000000000 * v34;
  }
  if ( (qword_6FF8758 & v2) == 0 )
  {
    if ( dword_6FF8760 )
    {
      v13 = *(unsigned int *)(v5 + 8);
      v14 = *(int *)(v5 + 1336);
      if ( (unsigned int)v14 > 3 )
        v15 = 0x40000;
      else
        v15 = dword_AFD1A0[v14];
      v16 = ((int)v13 + 1) % v15;
      if ( v16 != *(_DWORD *)(v5 + 12) )
      {
        v17 = *(_QWORD *)v5;
        if ( !*(_QWORD *)v5 )
        {
          v18 = 8 * v15;
          v19 = (void *)sub_65EE9A8(v18);
          *(_QWORD *)v5 = v19;
          memset(v19, 0, v18);
          sub_68673F0(v18, (atomic_uint *)&unk_7082680);
          v17 = *(_QWORD *)v5;
        }
        v20 = (unsigned int *)(v5 + 8);
        *(_QWORD *)(v17 + 8 * v13) = a2 & 0xFFFFFFFFFFFFLL | ((unsigned __int64)(v4 & 0x1FFF) << 48) | 0x2000000000000000LL;
        goto LABEL_40;
      }
      dword_6FF8748 = 100;
    }
    return a2;
  }
  if ( !*(_BYTE *)(v5 + 1340) )
    return -1LL;
  if ( !unk_715E788 )
    return -1LL;
  v7 = unk_715E788(*(_QWORD *)(v5 + 40));
  if ( v7 == -1 )
    return -1LL;
  if ( dword_6FF8760 )
  {
    v8 = qword_715F9F8;
    v9 = *(unsigned int *)(qword_715F9F8 + 8);
    v10 = *(int *)(qword_715F9F8 + 1336);
    if ( (unsigned int)v10 > 3 )
      v11 = 0x40000;
    else
      v11 = dword_AFD1A0[v10];
    v21 = ((int)v9 + 1) % v11;
    if ( v21 == *(_DWORD *)(qword_715F9F8 + 12) )
    {
      dword_6FF8748 = 100;
LABEL_31:
      v26 = *(_DWORD *)(v5 + 56);
      v27 = *(unsigned int *)(v8 + 8);
      v28 = *(int *)(v8 + 1336);
      if ( (unsigned int)v28 > 3 )
        v29 = 0x40000;
      else
        v29 = dword_AFD1A0[v28];
      v16 = ((int)v27 + 1) % v29;
      if ( v16 == *(_DWORD *)(v8 + 12) )
      {
        a2 = 0LL;
        dword_6FF8748 = 100;
        return a2;
      }
      v30 = *(_QWORD *)v8;
      if ( !*(_QWORD *)v8 )
      {
        v31 = 8 * v29;
        v32 = (void *)sub_65EE9A8(v31);
        *(_QWORD *)v8 = v32;
        memset(v32, 0, v31);
        sub_68673F0(v31, (atomic_uint *)&unk_7082680);
        v30 = *(_QWORD *)v8;
      }
      v20 = (unsigned int *)(v8 + 8);
      v33 = a2 & 0xFFFFFFFFFFFFLL | ((unsigned __int64)(v26 & 0x1FFF) << 48);
      a2 = 0LL;
      *(_QWORD *)(v30 + 8 * v27) = v33 | 0x8000000000000000LL;
LABEL_40:
      atomic_store(v16, v20);
      return a2;
    }
    v22 = *(_QWORD *)qword_715F9F8;
    v23 = v7;
    if ( !*(_QWORD *)qword_715F9F8 )
    {
      v24 = 8 * v11;
      v25 = (void *)sub_65EE9A8(v24);
      *(_QWORD *)v8 = v25;
      memset(v25, 0, v24);
      sub_68673F0(v24, (atomic_uint *)&unk_7082680);
      v22 = *(_QWORD *)v8;
    }
    *(_QWORD *)(v22 + 8 * v9) = v23 & 0xE000FFFFFFFFFFFFLL | ((unsigned __int64)(v4 & 0x1FFF) << 48) | 0x2000000000000000LL;
    atomic_store(v21, (unsigned int *)(v8 + 8));
    if ( dword_6FF8760 )
    {
      v8 = qword_715F9F8;
      goto LABEL_31;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_650B5B4 (0x650B5B4)
================================================================================

unsigned __int64 __fastcall sub_650B5B4(char *s)
{
  char *v2; // x20
  pthread_mutex_t *v3; // x21
  size_t v4; // x0
  size_t v5; // x21
  __int64 v6; // x8
  unsigned __int64 v7; // x24
  int v8; // w8
  unsigned __int64 v9; // x22
  char *v10; // x20
  unsigned __int16 v11; // w0
  __int64 v13; // [xsp+0h] [xbp-10h] BYREF

  v2 = (char *)atomic_load((unsigned __int64 *)&qword_70D3750);
  if ( !v2 )
  {
    v3 = (pthread_mutex_t *)sub_650A2D0();
    sub_6848AE0(v3);
    v2 = (char *)atomic_load((unsigned __int64 *)&qword_70D3750);
    if ( !v2 )
    {
      v2 = (char *)sub_65EE9A8(0x1000100uLL);
      memset(v2, 0, 0x1000100uLL);
      sub_68673F0(0x1000100u, (atomic_uint *)&dword_7082680);
      atomic_store((unsigned __int64)v2, (unsigned __int64 *)&qword_70D3750);
    }
    sub_6848B0C(v3);
  }
  v4 = strlen(s);
  if ( v4 >= 0xFF )
    v5 = 255LL;
  else
    v5 = v4;
  v13 = 0LL;
  __memcpy_chk(&v13, s);
  if ( v5 > 8 )
    v6 = v13 + *(_QWORD *)&s[(unsigned __int8)v5 / 3u - 2] + *(_QWORD *)&s[v5 - 8];
  else
    v6 = v13;
  v7 = (0x9E3779B97F4A7C15LL * v6) >> 51;
  v8 = word_715FA4A[v7];
  if ( (unsigned __int16)word_7167A70 - v8 > 2048
    || (v9 = qword_7163A50[v8 & 0x7FF], strncmp(s, &v2[v9 & 0xFFFFFF], v5)) )
  {
    v9 = sub_6867420(v5 + 1, (atomic_ullong *)qword_70D3758);
    v10 = &v2[v9 & 0xFFFFFF];
    memcpy(v10, s, v5);
    v10[v5] = 0;
    v11 = sub_68672D0(1LL, &word_7167A70);
    word_715FA4A[v7] = v11;
    qword_7163A50[v11 & 0x7FF] = v9;
  }
  return v9;
}


================================================================================
Function: sub_650B7AC (0x650B7AC)
================================================================================

__int64 __fastcall sub_650B7AC(unsigned __int64 a1, char *a2)
{
  __int64 v4; // x0
  int v5; // w20
  __int64 v6; // x0
  __int64 v7; // x22
  __int64 v8; // x21
  _QWORD *v9; // x23
  __int64 v10; // x24
  __int64 v11; // x8
  unsigned int v12; // w8
  __int64 result; // x0
  __int64 v14; // x21
  __int64 v15; // x20
  _QWORD *v16; // x22
  __int64 v17; // x23
  __int64 v18; // x8
  unsigned int v19; // w8
  __int64 v20; // x8
  unsigned int v21; // w8
  __int64 v22; // x8
  unsigned int v23; // w8
  unsigned int v24; // w25
  __int64 v25; // x9
  size_t v26; // x22
  void *v27; // x0
  __int64 v28; // x8
  unsigned int *v29; // x10
  unsigned int v30; // w24
  __int64 v31; // x9
  size_t v32; // x21
  void *v33; // x0
  __int64 v34; // x8
  unsigned int *v35; // x10
  size_t v36; // x23
  void *v37; // x0
  size_t v38; // x22
  void *v39; // x0

  if ( !byte_6FF8628 )
  {
    result = sub_650A860(a1);
    if ( !result )
      return result;
    v14 = result;
    result = sub_650B5B4(a2);
    v15 = result;
    if ( (qword_6FF8758 & (a1 >> 16)) != 0 )
    {
      if ( !dword_6FF8760 )
        return result;
      v16 = (_QWORD *)qword_715F9F8;
      v17 = *(unsigned int *)(qword_715F9F8 + 8);
      v18 = *(int *)(qword_715F9F8 + 1336);
      if ( (unsigned int)v18 > 3 )
        v19 = 0x40000;
      else
        v19 = dword_AFD1A0[v18];
      v30 = ((int)v17 + 1) % v19;
      if ( v30 != *(_DWORD *)(qword_715F9F8 + 12) )
      {
        v31 = *(_QWORD *)qword_715F9F8;
        if ( !*(_QWORD *)qword_715F9F8 )
        {
          v32 = 8 * v19;
          v33 = (void *)sub_65EE9A8(v32);
          *v16 = v33;
          memset(v33, 0, v32);
          result = sub_68673F0(v32, (atomic_uint *)&unk_7082680);
          v31 = *v16;
        }
        v34 = v15 & 0xFFFFFFFFFFFFLL;
        v35 = (unsigned int *)(v16 + 1);
LABEL_43:
        *(_QWORD *)(v31 + 8 * v17) = v34 & 0xE000FFFFFFFFFFFFLL | ((a1 & 0x1FFF) << 48) | 0x6000000000000000LL;
        atomic_store(v30, v35);
        return result;
      }
    }
    else
    {
      if ( !dword_6FF8760 )
        return result;
      v17 = *(unsigned int *)(v14 + 8);
      v22 = *(int *)(v14 + 1336);
      if ( (unsigned int)v22 > 3 )
        v23 = 0x40000;
      else
        v23 = dword_AFD1A0[v22];
      v30 = ((int)v17 + 1) % v23;
      if ( v30 != *(_DWORD *)(v14 + 12) )
      {
        v31 = *(_QWORD *)v14;
        if ( !*(_QWORD *)v14 )
        {
          v38 = 8 * v23;
          v39 = (void *)sub_65EE9A8(v38);
          *(_QWORD *)v14 = v39;
          memset(v39, 0, v38);
          result = sub_68673F0(v38, (atomic_uint *)&unk_7082680);
          v31 = *(_QWORD *)v14;
        }
        v34 = v15 & 0xFFFFFFFFFFFFLL;
        v35 = (unsigned int *)(v14 + 8);
        goto LABEL_43;
      }
    }
    dword_6FF8748 = 100;
    return result;
  }
  v4 = sub_65EBFB8(dword_7239EC8);
  v5 = v4;
  v6 = sub_650A860(v4);
  if ( v6 )
  {
    v7 = v6;
    v8 = sub_650B5B4(a2);
    if ( (qword_6FF8758 & (a1 >> 16)) != 0 )
    {
      if ( dword_6FF8760 )
      {
        v9 = (_QWORD *)qword_715F9F8;
        v10 = *(unsigned int *)(qword_715F9F8 + 8);
        v11 = *(int *)(qword_715F9F8 + 1336);
        if ( (unsigned int)v11 > 3 )
          v12 = 0x40000;
        else
          v12 = dword_AFD1A0[v11];
        v24 = ((int)v10 + 1) % v12;
        if ( v24 != *(_DWORD *)(qword_715F9F8 + 12) )
        {
          v25 = *(_QWORD *)qword_715F9F8;
          if ( !*(_QWORD *)qword_715F9F8 )
          {
            v26 = 8 * v12;
            v27 = (void *)sub_65EE9A8(v26);
            *v9 = v27;
            memset(v27, 0, v26);
            sub_68673F0(v26, (atomic_uint *)&unk_7082680);
            v25 = *v9;
          }
          v28 = v8 & 0xFFFFFFFFFFFFLL;
          v29 = (unsigned int *)(v9 + 1);
LABEL_34:
          *(_QWORD *)(v25 + 8 * v10) = v28 & 0xE000FFFFFFFFFFFFLL | ((a1 & 0x1FFF) << 48) | 0x6000000000000000LL;
          atomic_store(v24, v29);
          return sub_65EBFB8(v5);
        }
LABEL_30:
        dword_6FF8748 = 100;
      }
    }
    else if ( dword_6FF8760 )
    {
      v10 = *(unsigned int *)(v7 + 8);
      v20 = *(int *)(v7 + 1336);
      if ( (unsigned int)v20 > 3 )
        v21 = 0x40000;
      else
        v21 = dword_AFD1A0[v20];
      v24 = ((int)v10 + 1) % v21;
      if ( v24 != *(_DWORD *)(v7 + 12) )
      {
        v25 = *(_QWORD *)v7;
        if ( !*(_QWORD *)v7 )
        {
          v36 = 8 * v21;
          v37 = (void *)sub_65EE9A8(v36);
          *(_QWORD *)v7 = v37;
          memset(v37, 0, v36);
          sub_68673F0(v36, (atomic_uint *)&unk_7082680);
          v25 = *(_QWORD *)v7;
        }
        v28 = v8 & 0xFFFFFFFFFFFFLL;
        v29 = (unsigned int *)(v7 + 8);
        goto LABEL_34;
      }
      goto LABEL_30;
    }
  }
  return sub_65EBFB8(v5);
}


================================================================================
Function: sub_650BB60 (0x650BB60)
================================================================================

__int64 __fastcall sub_650BB60(int a1, __int64 a2)
{
  if ( a1 != 5 )
  {
    if ( (unsigned __int64)(qword_70D3758[0] - a2) <= 0x1000000 )
      return qword_70D3750 + (a2 & 0xFFFFFF);
    else
      return 0LL;
  }
  return a2;
}


================================================================================
Function: sub_650BCA4 (0x650BCA4)
================================================================================

unsigned __int64 __fastcall sub_650BCA4(unsigned __int64 result, char *format, _OWORD *a3)
{
  __int128 v3; // q1
  unsigned __int64 v4; // x19
  _OWORD v5[2]; // [xsp+0h] [xbp-130h] BYREF
  char s[256]; // [xsp+28h] [xbp-108h] BYREF

  if ( (qword_6FF8708 & (result >> 16)) != 0 )
  {
    v3 = a3[1];
    v4 = result;
    v5[0] = *a3;
    v5[1] = v3;
    vsnprintf(s, 0xFFuLL, format, v5);
    s[255] = 0;
    return sub_650B7AC(v4, s);
  }
  return result;
}


================================================================================
Function: sub_650BEE8 (0x650BEE8)
================================================================================

__int64 __fastcall sub_650BEE8(__int64 result, int a2, int a3, int a4, char *a5)
{
  int v9; // w26
  int v10; // w19
  __int64 v11; // x0
  __int64 v12; // x25
  unsigned __int8 v13; // w8
  unsigned int v14; // w0
  _BYTE v15[48]; // [xsp+8h] [xbp-38h] BYREF

  v9 = result;
  if ( dword_6FF8760 || qword_6FF8708 )
  {
    v10 = sub_65EBFB8(dword_7239EC8);
    v11 = sub_650A860();
    if ( v11 )
    {
      v12 = v11;
      v13 = atomic_load((unsigned __int8 *)sub_6866980(qword_6CA8FE8));
      if ( (v13 & 1) == 0 )
      {
        atomic_store(1u, (unsigned __int8 *)sub_6866980(qword_6CA8FE8));
        v14 = sub_651AA38((int)v15, v9, a2, a3, a4, a5);
        sub_651A8B8(v15, v14, v12);
        atomic_store(0, (unsigned __int8 *)sub_6866980(qword_6CA8FE8));
      }
    }
    return sub_65EBFB8(v10);
  }
  return result;
}


================================================================================
Function: sub_650C02C (0x650C02C)
================================================================================

__int64 __fastcall sub_650C02C(__int64 result, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // x20
  __int64 v5; // x21
  __int64 v6; // x0
  __int64 v7; // x25
  __int64 v8; // x24
  __int64 v9; // x8
  unsigned int v10; // w8
  __int64 v11; // x24
  __int64 v12; // x28
  __int64 v13; // x8
  unsigned int v14; // w8
  unsigned int v15; // w27
  __int64 v16; // x9
  size_t v17; // x22
  void *v18; // x0
  int v19; // w22
  __int64 v20; // x21
  __int64 v21; // x8
  unsigned int v22; // w8
  unsigned int v23; // w25
  __int64 v24; // x9
  size_t v25; // x22
  void *v26; // x0
  unsigned int *v27; // x10
  __int64 v28; // x9
  size_t v29; // x20
  void *v30; // x0
  __int64 v31; // [xsp+8h] [xbp-18h] BYREF
  __int64 v32; // [xsp+10h] [xbp-10h]

  if ( a2 != -1 )
  {
    v4 = result;
    result = ((__int64 (*)(void))sub_650A860)();
    v5 = result;
    if ( result || (v6 = sub_650A8B0(0LL, 2LL), result = sub_650A860(v6), (v5 = result) != 0) )
    {
      if ( a3 == -1 )
      {
        result = clock_gettime(1, (struct timespec *)&v31);
        a3 = v32 + 1000000000 * v31;
      }
      if ( (qword_6FF8758 & (v4 >> 16)) == 0 )
      {
        if ( !dword_6FF8760 )
          return result;
        v8 = *(unsigned int *)(v5 + 8);
        v9 = *(int *)(v5 + 1336);
        if ( (unsigned int)v9 > 3 )
          v10 = 0x40000;
        else
          v10 = dword_AFD1A0[v9];
        v23 = ((int)v8 + 1) % v10;
        if ( v23 == *(_DWORD *)(v5 + 12) )
          goto LABEL_33;
        v24 = *(_QWORD *)v5;
        if ( !*(_QWORD *)v5 )
        {
          v25 = 8 * v10;
          v26 = (void *)sub_65EE9A8(v25);
          *(_QWORD *)v5 = v26;
          memset(v26, 0, v25);
          result = sub_68673F0(v25, (atomic_uint *)&unk_7082680);
          v24 = *(_QWORD *)v5;
        }
        v27 = (unsigned int *)(v5 + 8);
        *(_QWORD *)(v24 + 8 * v8) = a3 & 0xFFFFFFFFFFFFLL | ((v4 & 0x1FFF) << 48);
LABEL_37:
        atomic_store(v23, v27);
        return result;
      }
      if ( *(_BYTE *)(v5 + 1340) )
      {
        if ( unk_715E788 )
        {
          result = unk_715E788(*(_QWORD *)(v5 + 40));
          v7 = (unsigned int)result;
        }
        else
        {
          v7 = 0xFFFFFFFFLL;
        }
        if ( dword_6FF8760 )
        {
          v11 = qword_715F9F8;
          v12 = *(unsigned int *)(qword_715F9F8 + 8);
          v13 = *(int *)(qword_715F9F8 + 1336);
          if ( (unsigned int)v13 > 3 )
            v14 = 0x40000;
          else
            v14 = dword_AFD1A0[v13];
          v15 = ((int)v12 + 1) % v14;
          if ( v15 == *(_DWORD *)(qword_715F9F8 + 12) )
          {
            dword_6FF8748 = 100;
LABEL_24:
            v19 = *(_DWORD *)(v5 + 56);
            v20 = *(unsigned int *)(v11 + 8);
            v21 = *(int *)(v11 + 1336);
            if ( (unsigned int)v21 > 3 )
              v22 = 0x40000;
            else
              v22 = dword_AFD1A0[v21];
            v23 = ((int)v20 + 1) % v22;
            if ( v23 == *(_DWORD *)(v11 + 12) )
            {
LABEL_33:
              dword_6FF8748 = 100;
              return result;
            }
            v28 = *(_QWORD *)v11;
            if ( !*(_QWORD *)v11 )
            {
              v29 = 8 * v22;
              v30 = (void *)sub_65EE9A8(v29);
              *(_QWORD *)v11 = v30;
              memset(v30, 0, v29);
              result = sub_68673F0(v29, (atomic_uint *)&unk_7082680);
              v28 = *(_QWORD *)v11;
            }
            v27 = (unsigned int *)(v11 + 8);
            *(_QWORD *)(v28 + 8 * v20) = a3 & 0xFFFFFFFFFFFFLL | ((unsigned __int64)(v19 & 0x1FFF) << 48) | 0x8000000000000000LL;
            goto LABEL_37;
          }
          v16 = *(_QWORD *)qword_715F9F8;
          if ( !*(_QWORD *)qword_715F9F8 )
          {
            v17 = 8 * v14;
            v18 = (void *)sub_65EE9A8(v17);
            *(_QWORD *)v11 = v18;
            memset(v18, 0, v17);
            result = sub_68673F0(v17, (atomic_uint *)&unk_7082680);
            v16 = *(_QWORD *)v11;
          }
          *(_QWORD *)(v16 + 8 * v12) = v7 & 0xE000FFFFFFFFFFFFLL | ((v4 & 0x1FFF) << 48);
          atomic_store(v15, (unsigned int *)(v11 + 8));
          if ( dword_6FF8760 )
          {
            v11 = qword_715F9F8;
            goto LABEL_24;
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_651A8B8 (0x651A8B8)
================================================================================

__int64 __fastcall sub_651A8B8(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 result; // x0
  __int64 v7; // x22
  unsigned int v8; // w25
  int v9; // w8
  __int64 v10; // x9
  unsigned int *v11; // x10
  __int64 v12; // x23
  void *v13; // x0
  __int64 v14; // x8
  __int64 v15; // x10
  __int64 *v16; // x11
  unsigned int *v17; // x12
  __int64 v18; // x13
  __int64 v19; // x14
  __int64 v20; // x15
  __int64 v21; // x16
  __int64 v22; // x17
  __int64 *v23; // x11
  unsigned int *v24; // x12
  __int64 v25; // x9
  __int64 v26; // x13
  unsigned int v27; // t1
  __int64 v28; // t1
  _BYTE v29[4]; // [xsp+0h] [xbp-20h] BYREF
  int v30; // [xsp+4h] [xbp-1Ch] BYREF

  result = sub_650A360();
  if ( !*(_DWORD *)(result + 136) )
    return result;
  v7 = result;
  v8 = *((_DWORD *)a3 + 2);
  result = sub_650A2AC(a3);
  v9 = *((_DWORD *)a3 + 3);
  if ( !a2 )
  {
LABEL_6:
    if ( !*a3 )
    {
      v12 = 8LL * (unsigned int)result;
      v13 = (void *)sub_65EE9A8(v12);
      *a3 = (__int64)v13;
      memset(v13, 0, v12);
      result = sub_68673F0(v12, (atomic_uint *)(v7 + 565160));
    }
    if ( !a2 )
      goto LABEL_17;
    v14 = *a3;
    if ( a2 == 1 )
    {
      v15 = 0LL;
    }
    else
    {
      v15 = a2 & 0xFFFFFFFE;
      v16 = (__int64 *)(a1 + 8);
      v17 = (unsigned int *)&v30;
      v18 = v15;
      do
      {
        v19 = *(v16 - 1);
        v20 = *v16;
        v16 += 2;
        v18 -= 2LL;
        v21 = *(v17 - 1);
        v22 = *v17;
        v17 += 2;
        *(_QWORD *)(v14 + 8 * v21) = v19;
        *(_QWORD *)(v14 + 8 * v22) = v20;
      }
      while ( v18 );
      if ( v15 == a2 )
        goto LABEL_17;
    }
    v23 = (__int64 *)(a1 + 8 * v15);
    v24 = (unsigned int *)&v29[4 * v15];
    v25 = a2 - v15;
    do
    {
      v27 = *v24++;
      v26 = v27;
      --v25;
      v28 = *v23++;
      *(_QWORD *)(v14 + 8 * v26) = v28;
    }
    while ( v25 );
LABEL_17:
    atomic_store(v8, (unsigned int *)a3 + 2);
    return result;
  }
  v10 = a2;
  v11 = (unsigned int *)v29;
  while ( 1 )
  {
    *v11 = v8;
    v8 = (v8 + 1) % (unsigned int)result;
    if ( v8 == v9 )
      break;
    ++v11;
    if ( !--v10 )
      goto LABEL_6;
  }
  *(_DWORD *)(v7 + 112) = 100;
  return result;
}


================================================================================
Function: sub_651AA38 (0x651AA38)
================================================================================

__int64 __fastcall sub_651AA38(
        unsigned __int64 *a1,
        unsigned __int8 a2,
        __int64 a3,
        char *a4,
        unsigned __int64 a5,
        char *s,
        _QWORD *a7,
        unsigned __int64 a8)
{
  unsigned int v8; // w21
  __int64 v9; // x8
  __int64 v10; // x10
  unsigned __int64 v11; // x8
  int v14; // w8
  __int64 v15; // x9
  __int64 v16; // x10
  int64x2_t *v17; // x11
  __int64 v18; // x12
  int64x2_t v19; // q0
  __int64 v20; // x11
  unsigned __int64 *v21; // x10
  bool v22; // cf
  _BYTE *v23; // x10
  int v24; // w11
  unsigned int v25; // w12
  char v26; // t1
  unsigned int v27; // w15
  bool v28; // zf
  __int64 v29; // x15
  __int64 v30; // x0
  unsigned __int64 v31; // x9
  unsigned __int64 v32; // x7

  v8 = 1;
  if ( a5 <= 0xA )
    v9 = 1LL;
  else
    v9 = 2LL;
  if ( a5 )
    v10 = v9;
  else
    v10 = 0LL;
  v11 = 0xC000000000000000LL;
  if ( (unsigned __int64)s | a8 )
    v11 = 0xD000000000000000LL;
  *a1 = v11 & 0xFC00000000000000LL | (v10 << 58) | ((unsigned __int64)a2 << 50) | a3 & 0x3FFFFFFFFFFFFLL;
  if ( a5 )
  {
    if ( (unsigned int)a5 >= 0x14 )
      v14 = 20;
    else
      v14 = a5;
    v15 = (unsigned int)(2 * v10);
    if ( !(_DWORD)v10 )
      goto LABEL_22;
    if ( (_DWORD)v10 == 1 )
    {
      v16 = 0LL;
    }
    else
    {
      v16 = (2 * (_BYTE)v10) & 4;
      v17 = (int64x2_t *)(a1 + 3);
      v18 = v16;
      v19 = vdupq_n_s64(0xDC00000000000000LL);
      do
      {
        v17[-1] = v19;
        *v17 = v19;
        v17 += 2;
        v18 -= 4LL;
      }
      while ( v18 );
      if ( v16 == v15 )
        goto LABEL_22;
    }
    v20 = v16 - v15;
    v21 = &a1[v16 + 1];
    do
    {
      v22 = __CFADD__(v20++, 1LL);
      *v21++ = 0xDC00000000000000LL;
    }
    while ( !v22 );
LABEL_22:
    if ( a4 && v14 )
    {
      v23 = a1 + 1;
      v24 = -1;
      v25 = 1;
      do
      {
        --v14;
        v26 = *a4++;
        v27 = v25 / 5;
        ++v25;
        *v23 = v26;
        v28 = v24 + 5 * v27 == 0;
        --v24;
        if ( v28 )
          v29 = 4LL;
        else
          v29 = 1LL;
        v23 += v29;
      }
      while ( v14 );
    }
    v8 = v15 | 1;
  }
  if ( a8 )
  {
LABEL_38:
    a1[v8++] = a8;
    return v8;
  }
  if ( s )
  {
    v30 = sub_651ABB0((int)&qword_7167BB8, s);
    v31 = 0xDE00000000000000LL;
    if ( !*a7 )
      v31 = 0xDC00000000000000LL;
    if ( *a7 == 0x1000000000000000LL )
      v32 = 0xDF00000000000000LL;
    else
      v32 = v31;
    a8 = v32 & 0xFFFF000000000000LL | v30 & 0xFFFFFFFFFFFFLL;
    goto LABEL_38;
  }
  return v8;
}


================================================================================
Function: sub_651ABB0 (0x651ABB0)
================================================================================

unsigned __int64 __fastcall sub_651ABB0(__int64 *a1, char *s, unsigned __int64 *a3)
{
  unsigned __int64 v3; // x8
  char *v5; // x21
  size_t v7; // x0
  unsigned __int64 v8; // x8
  char *v9; // x10
  __int64 v10; // t1
  pthread_mutex_t *v12; // x20
  __int64 v13; // x9
  __int64 v14; // x8
  unsigned int v15; // w12
  _QWORD *v16; // x24
  __int64 v17; // x13
  int v18; // w14
  unsigned int v19; // w12
  unsigned __int64 *v20; // x24
  __int64 v21; // t1
  int v22; // w9
  unsigned int v23; // w11
  _QWORD *v24; // x24
  __int64 v25; // x14
  _QWORD *v26; // x12
  int v27; // w15
  unsigned int v28; // w11
  bool v29; // zf
  unsigned __int64 v30; // x27
  __int64 v31; // x28
  _QWORD *v32; // x24
  int v33; // w9
  unsigned int v34; // w11
  _QWORD *v35; // x0
  __int64 v36; // x13
  _QWORD *v37; // x12
  int v38; // w14
  unsigned int v39; // w11
  bool v40; // zf
  _QWORD *v41; // x1
  __int64 v42; // x10
  __int64 v43; // x9
  _QWORD *v44; // x9
  __int64 v45; // t1
  int v46; // w8
  unsigned int v47; // w11
  __int64 v48; // x8
  __int64 v49; // x9
  __int64 v50; // x12
  unsigned __int64 v51; // d0
  int64x2_t v52; // q0
  __int64 v53; // x8
  __int64 v54; // x11
  __int64 v55; // x10
  unsigned __int64 v56; // x9
  int v57; // w13
  int v58; // w8
  _QWORD *v59; // x1
  unsigned __int64 v60; // x0
  __int64 v61; // x8
  __int64 v62; // x9
  __int64 v63; // x10
  __int64 v64; // x11
  unsigned __int64 v65; // x21
  unsigned __int64 v66; // x22
  __int64 v67; // x9
  __int64 v68; // x9
  __int64 v69; // x12
  unsigned __int64 v70; // x9
  unsigned __int64 *v71; // x8

  v3 = *a3;
  v5 = s;
  if ( *a3 == 0xF000000000000000LL )
  {
    if ( s )
    {
      v7 = strlen(s);
      v8 = 0LL;
      if ( v7 )
      {
        v9 = v5;
        do
        {
          v10 = *v9++;
          --v7;
          v8 ^= (v8 << 6) + (v8 >> 2) + v10 + 2654435769u;
        }
        while ( v7 );
        v8 &= 0xFFFFFFFFFFFFFFFuLL;
      }
    }
    else
    {
      v8 = 0LL;
    }
    *a3 = v8;
    goto LABEL_13;
  }
  if ( !v3 )
    return sub_650B5B4(s);
  if ( v3 != 0x1000000000000000LL )
  {
LABEL_13:
    v12 = (pthread_mutex_t *)sub_650A35C();
    sub_6848AE0(v12);
    v13 = *((unsigned int *)a1 + 4);
    v14 = *a1;
    if ( (_DWORD)v13 )
    {
      v15 = (37 * *a3) & (v13 - 1);
      v16 = (_QWORD *)(v14 + 16LL * v15);
      v17 = *v16;
      if ( *a3 == *v16 )
      {
LABEL_20:
        if ( v16 != (_QWORD *)(v14 + 16 * v13) )
        {
          v21 = v16[1];
          v20 = v16 + 1;
          if ( !sub_650BB60(6LL, v21) )
            *v20 = sub_650B5B4(v5);
LABEL_80:
          v5 = (char *)*v20;
          sub_6848B0C(v12);
          return (unsigned __int64)v5;
        }
        if ( a1[9] > (unsigned __int64)*((unsigned int *)a1 + 2) )
        {
LABEL_24:
          if ( (_DWORD)v13 )
          {
            v22 = v13 - 1;
            v23 = (37 * *a3) & v22;
            v24 = (_QWORD *)(v14 + 16LL * v23);
            v25 = *v24;
            if ( *a3 == *v24 )
            {
LABEL_74:
              v60 = sub_650B5B4(v5);
              v61 = a1[4];
              v62 = a1[5];
              v24[1] = v60;
              v20 = v24 + 1;
              v63 = a1[7];
              v64 = a1[8];
              v65 = v60;
              v66 = *a3;
              v67 = v62 - v61;
              v29 = v67 == 0;
              v68 = 32 * v67 - 1;
              if ( v29 )
                v69 = 0LL;
              else
                v69 = v68;
              v70 = v64 + v63;
              if ( v69 == v64 + v63 )
              {
                sub_651C4A0(a1 + 3);
                v61 = a1[4];
                v70 = a1[7] + a1[8];
              }
              v71 = (unsigned __int64 *)(*(_QWORD *)(v61 + ((v70 >> 5) & 0x7FFFFFFFFFFFFF8LL))
                                       + 16LL * (unsigned __int8)v70);
              *v71 = v66;
              v71[1] = v65;
              ++a1[8];
              goto LABEL_80;
            }
            v26 = 0LL;
            v27 = 1;
            while ( v25 != -1 )
            {
              v28 = v23 + v27;
              if ( v26 )
                v29 = 0;
              else
                v29 = v25 == -2;
              v23 = v28 & v22;
              ++v27;
              if ( v29 )
                v26 = v24;
              v24 = (_QWORD *)(v14 + 16LL * v23);
              v25 = *v24;
              if ( *a3 == *v24 )
                goto LABEL_74;
            }
            if ( v26 )
              v59 = v26;
            else
              v59 = v24;
          }
          else
          {
            v59 = 0LL;
          }
          v24 = (_QWORD *)sub_651C194(a1, v59, a3);
          goto LABEL_74;
        }
        v30 = a1[7];
        while ( 1 )
        {
          v31 = *(_QWORD *)(a1[4] + ((v30 >> 5) & 0x7FFFFFFFFFFFFF8LL));
          v32 = (_QWORD *)(v31 + 16LL * (unsigned __int8)v30);
          if ( (_DWORD)v13 )
          {
            v33 = v13 - 1;
            v34 = (37 * *v32) & v33;
            v35 = (_QWORD *)(v14 + 16LL * v34);
            v36 = *v35;
            if ( *v32 == *v35 )
              goto LABEL_53;
            v37 = 0LL;
            v38 = 1;
            while ( v36 != -1 )
            {
              v39 = v34 + v38;
              if ( v37 )
                v40 = 0;
              else
                v40 = v36 == -2;
              v34 = v39 & v33;
              ++v38;
              if ( v40 )
                v37 = v35;
              v35 = (_QWORD *)(v14 + 16LL * v34);
              v36 = *v35;
              if ( *v32 == *v35 )
                goto LABEL_53;
            }
            if ( v37 )
              v41 = v37;
            else
              v41 = v35;
          }
          else
          {
            v41 = 0LL;
          }
          v35 = (_QWORD *)sub_651C194(a1, v41, v31 + 16LL * (unsigned __int8)v30);
LABEL_53:
          v42 = v35[1];
          v43 = v31 + 16LL * (unsigned __int8)v30;
          v45 = *(_QWORD *)(v43 + 8);
          v44 = (_QWORD *)(v43 + 8);
          if ( v45 == v42 )
          {
            v46 = *((_DWORD *)a1 + 4);
            if ( v46 )
            {
              v47 = v46 - 1;
              v48 = (37 * (unsigned int)*v32) & (v46 - 1);
              v49 = *a1;
              v50 = *(_QWORD *)(*a1 + 16 * v48);
              if ( *v32 == v50 )
              {
LABEL_56:
                v51 = vadd_s32((int32x2_t)a1[1], (int32x2_t)0x1FFFFFFFFLL).n64_u64[0];
                *(_QWORD *)(v49 + 16 * v48) = -2LL;
                a1[1] = v51;
              }
              else
              {
                v57 = 1;
                while ( v50 != -1 )
                {
                  v58 = v48 + v57++;
                  v48 = v58 & v47;
                  v50 = *(_QWORD *)(v49 + 16 * v48);
                  if ( *v32 == v50 )
                    goto LABEL_56;
                }
              }
            }
            v52 = vaddq_s64(*(int64x2_t *)(a1 + 7), (int64x2_t)xmmword_AFE0C0);
            v30 = v52.n128_u64[0];
            *(int64x2_t *)(a1 + 7) = v52;
            if ( v52.n128_u64[0] < 0x200 )
              goto LABEL_38;
          }
          else
          {
            v53 = a1[4];
            v54 = a1[5];
            *v44 = v42;
            v55 = 32 * (v54 - v53) - 1;
            if ( v54 == v53 )
              v55 = 0LL;
            v56 = a1[8] + a1[7];
            if ( v55 == v56 )
            {
              sub_651C4A0(a1 + 3);
              v53 = a1[4];
              v56 = a1[7] + a1[8];
            }
            *(_OWORD *)(*(_QWORD *)(v53 + ((v56 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * (unsigned __int8)v56) = *(_OWORD *)v32;
            v30 = a1[7] + 1;
            a1[7] = v30;
            if ( v30 <= 0x1FF )
              goto LABEL_38;
          }
          sub_65ECAF4();
          v30 = a1[7] - 256;
          a1[4] += 8LL;
          a1[7] = v30;
LABEL_38:
          v14 = *a1;
          LODWORD(v13) = *((_DWORD *)a1 + 4);
          if ( a1[9] > (unsigned __int64)*((unsigned int *)a1 + 2) )
            goto LABEL_24;
        }
      }
      v18 = 1;
      while ( v17 != -1 )
      {
        v19 = v15 + v18++;
        v15 = v19 & (v13 - 1);
        v16 = (_QWORD *)(v14 + 16LL * v15);
        v17 = *v16;
        if ( *a3 == *v16 )
          goto LABEL_20;
      }
    }
    v16 = (_QWORD *)(v14 + 16 * v13);
    goto LABEL_20;
  }
  return (unsigned __int64)v5;
}


================================================================================
Function: sub_651C08C (0x651C08C)
================================================================================

void *sub_651C08C()
{
  void *result; // x0

  result = memset(&unk_7167C38, 0, 0x1100uLL);
  *(_WORD *)((char *)&unk_7167C38 + (unsigned int)&algn_1018[5]) = 257;
  return result;
}


================================================================================
Function: sub_651C194 (0x651C194)
================================================================================

_QWORD *__fastcall sub_651C194(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // w9
  __int64 v5; // x1
  _QWORD *result; // x0
  int v9; // w8
  int v10; // w11
  unsigned int v11; // w12
  __int64 v12; // x15
  _QWORD *v13; // x13
  int v14; // w16
  unsigned int v15; // w12
  bool v16; // zf

  v3 = *(_DWORD *)(a1 + 8);
  v5 = *(unsigned int *)(a1 + 16);
  if ( 4 * v3 + 4 >= (unsigned int)(3 * v5) )
  {
    v5 = (unsigned int)(2 * v5);
  }
  else if ( (int)v5 + ~v3 - *(_DWORD *)(a1 + 12) > (unsigned int)v5 >> 3 )
  {
    goto LABEL_3;
  }
  sub_651C2AC(a1, v5);
  v9 = *(_DWORD *)(a1 + 16);
  if ( v9 )
  {
    v10 = v9 - 1;
    v11 = (37 * *a3) & (v9 - 1);
    a2 = (_QWORD *)(*(_QWORD *)a1 + 16LL * v11);
    v12 = *a2;
    if ( *a3 != *a2 )
    {
      v13 = 0LL;
      v14 = 1;
      while ( v12 != -1 )
      {
        v15 = v11 + v14;
        if ( v13 )
          v16 = 0;
        else
          v16 = v12 == -2;
        v11 = v15 & v10;
        ++v14;
        if ( v16 )
          v13 = a2;
        a2 = (_QWORD *)(*(_QWORD *)a1 + 16LL * v11);
        v12 = *a2;
        if ( *a3 == *a2 )
          goto LABEL_3;
      }
      if ( v13 )
        a2 = v13;
    }
  }
  else
  {
    a2 = 0LL;
  }
LABEL_3:
  v16 = *a2 == -1LL;
  ++*(_DWORD *)(a1 + 8);
  if ( !v16 )
    --*(_DWORD *)(a1 + 12);
  result = a2;
  *a2 = *a3;
  a2[1] = 0LL;
  return result;
}


================================================================================
Function: sub_651C2AC (0x651C2AC)
================================================================================

__int64 __fastcall sub_651C2AC(__int64 a1, int a2)
{
  __int64 v3; // x21
  unsigned __int64 v4; // x8
  __int64 *v5; // x20
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x8
  int v8; // w8
  int v9; // w8
  __int64 result; // x0
  __int64 v11; // x10
  __int64 v12; // x8
  __int64 v13; // x9
  _QWORD *v14; // x12
  __int64 v15; // x11
  __int64 v16; // x14
  _QWORD *v17; // x8
  __int64 v18; // x8
  __int64 v19; // x9
  __int64 v20; // x10
  _QWORD *v21; // x12
  __int64 v22; // x11
  __int64 v23; // x14
  _QWORD *v24; // x9
  int v25; // w8
  int v26; // w10
  __int64 *v27; // x13
  _QWORD *v28; // x8
  _QWORD *v29; // x15
  __int64 v30; // x14
  __int64 v31; // x14
  unsigned int v32; // w16
  __int64 v33; // x1
  _QWORD *v34; // x17
  int v35; // w2
  unsigned int v36; // w16
  bool v37; // zf

  v3 = *(unsigned int *)(a1 + 16);
  v4 = (unsigned int)(a2 - 1) | ((unsigned __int64)(unsigned int)(a2 - 1) >> 1);
  v5 = *(__int64 **)a1;
  v6 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
  v7 = v6 | (v6 >> 8) | ((v6 | (v6 >> 8)) >> 16);
  v8 = HIDWORD(v7) | v7;
  if ( (unsigned int)(v8 + 1) > 0x40 )
    v9 = v8 + 1;
  else
    v9 = 64;
  *(_DWORD *)(a1 + 16) = v9;
  result = sub_65ECAAC();
  *(_QWORD *)a1 = result;
  if ( !v5 )
  {
    v18 = *(unsigned int *)(a1 + 16);
    *(_QWORD *)(a1 + 8) = 0LL;
    if ( !(_DWORD)v18 )
      return result;
    v19 = (v18 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if ( v19 )
    {
      v20 = v19 + 1;
      v21 = (_QWORD *)(result + 16);
      v22 = (v19 + 1) & 0x1FFFFFFFFFFFFFFELL;
      v23 = v22;
      v24 = (_QWORD *)(result + 16 * v22);
      do
      {
        v23 -= 2LL;
        *(v21 - 2) = -1LL;
        *v21 = -1LL;
        v21 += 4;
      }
      while ( v23 );
      if ( v20 == v22 )
        return result;
    }
    else
    {
      v24 = (_QWORD *)result;
    }
    v28 = (_QWORD *)(result + 16 * v18);
    do
    {
      *v24 = -1LL;
      v24 += 2;
    }
    while ( v24 != v28 );
    return result;
  }
  v11 = *(unsigned int *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = 0LL;
  if ( (_DWORD)v11 )
  {
    v12 = (v11 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if ( v12 )
    {
      v13 = v12 + 1;
      v14 = (_QWORD *)(result + 16);
      v15 = (v12 + 1) & 0x1FFFFFFFFFFFFFFELL;
      v16 = v15;
      v17 = (_QWORD *)(result + 16 * v15);
      do
      {
        v16 -= 2LL;
        *(v14 - 2) = -1LL;
        *v14 = -1LL;
        v14 += 4;
      }
      while ( v16 );
      if ( v13 == v15 )
        goto LABEL_19;
    }
    else
    {
      v17 = (_QWORD *)result;
    }
    do
    {
      *v17 = -1LL;
      v17 += 2;
    }
    while ( v17 != (_QWORD *)(result + 16 * v11) );
  }
LABEL_19:
  if ( (_DWORD)v3 )
  {
    v25 = 0;
    v26 = v11 - 1;
    v27 = v5;
    do
    {
      v31 = *v27;
      if ( (unsigned __int64)*v27 <= 0xFFFFFFFFFFFFFFFDLL )
      {
        v32 = (37 * v31) & v26;
        v29 = (_QWORD *)(result + 16LL * v32);
        v33 = *v29;
        if ( v31 != *v29 )
        {
          v34 = 0LL;
          v35 = 1;
          while ( v33 != -1 )
          {
            v36 = v32 + v35;
            if ( v34 )
              v37 = 0;
            else
              v37 = v33 == -2;
            v32 = v36 & v26;
            ++v35;
            if ( v37 )
              v34 = v29;
            v29 = (_QWORD *)(result + 16LL * v32);
            v33 = *v29;
            if ( v31 == *v29 )
              goto LABEL_27;
          }
          if ( v34 )
            v29 = v34;
        }
LABEL_27:
        *v29 = v31;
        ++v25;
        v30 = v27[1];
        *(_DWORD *)(a1 + 8) = v25;
        v29[1] = v30;
      }
      v27 += 2;
    }
    while ( v27 != &v5[2 * v3] );
  }
  return sub_65ECAF4();
}


================================================================================
Function: sub_651C4A0 (0x651C4A0)
================================================================================

__int64 __fastcall sub_651C4A0(__int64 *a1)
{
  unsigned __int64 v2; // x8
  bool v3; // cf
  unsigned __int64 v4; // x8
  __int64 *v5; // x9
  __int64 v6; // x8
  __int64 result; // x0
  __int64 v8; // x8
  __int64 v9; // x9
  __int64 v10; // x10
  unsigned __int64 v11; // x22
  unsigned __int64 v12; // x8
  __int64 v13; // x20
  __int64 v14; // x20
  __int64 v15; // x22
  __int128 v16; // q0
  __int64 v17; // x10
  __int64 v18; // x8
  __int64 v19; // x9
  __int64 *v20; // x8
  __int64 v21; // t1
  __int64 v22; // [xsp+8h] [xbp-38h] BYREF
  __int64 v23; // [xsp+10h] [xbp-30h] BYREF
  __int128 v24; // [xsp+18h] [xbp-28h]
  __int64 v25; // [xsp+28h] [xbp-18h]
  _QWORD *v26; // [xsp+30h] [xbp-10h]

  v2 = a1[4];
  v3 = v2 >= 0x100;
  v4 = v2 - 256;
  if ( v3 )
  {
    v5 = (__int64 *)a1[1];
    a1[4] = v4;
    v6 = *v5;
    a1[1] = (__int64)(v5 + 1);
    v23 = v6;
    return sub_651C6BC(a1, &v23);
  }
  v8 = a1[2];
  v9 = a1[3];
  v10 = v9 - *a1;
  v11 = (v8 - a1[1]) >> 3;
  if ( v11 < v10 >> 3 )
  {
    if ( v9 != v8 )
    {
      v23 = sub_65ECAAC();
      return sub_651C874(a1, &v23);
    }
    v23 = sub_65ECAAC();
    sub_651CA2C(a1, &v23);
    v20 = (__int64 *)a1[1];
    v21 = *v20;
    a1[1] = (__int64)(v20 + 1);
    v23 = v21;
    return sub_651C6BC(a1, &v23);
  }
  v12 = v10 >> 2;
  if ( !v10 )
    v12 = 1LL;
  v26 = a1 + 3;
  if ( v12 >> 61 )
    sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v13 = 8 * v12;
  v23 = sub_65ECAAC();
  *(_QWORD *)&v24 = v23 + 8 * v11;
  *((_QWORD *)&v24 + 1) = v24;
  v25 = v23 + v13;
  v22 = sub_65ECAAC();
  sub_651CBEC(&v23, &v22);
  v14 = a1[2];
  v15 = v14 + 8;
  while ( v14 != a1[1] )
  {
    v14 -= 8LL;
    v15 -= 8LL;
    sub_651CDA4(&v23, v14);
  }
  result = *a1;
  v16 = v24;
  *a1 = v23;
  v17 = v25;
  v18 = a1[2];
  v19 = a1[3];
  *(_OWORD *)(a1 + 1) = v16;
  v23 = result;
  *(_QWORD *)&v24 = v14;
  a1[3] = v17;
  *((_QWORD *)&v24 + 1) = v18;
  v25 = v19;
  if ( v14 != v18 )
    *((_QWORD *)&v24 + 1) = v18 + 8 * ~((unsigned __int64)(v18 - v15) >> 3);
  if ( result )
    return sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_651C6BC (0x651C6BC)
================================================================================

__int64 __fastcall sub_651C6BC(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_65ECAAC();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_65ECAF4();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_651C874 (0x651C874)
================================================================================

__int64 __fastcall sub_651C874(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_65ECAAC();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_65ECAF4();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_651CA2C (0x651CA2C)
================================================================================

__int64 __fastcall sub_651CA2C(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_65ECAAC();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_65ECAF4();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_651CBEC (0x651CBEC)
================================================================================

__int64 __fastcall sub_651CBEC(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_65ECAAC();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_65ECAF4();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_651CDA4 (0x651CDA4)
================================================================================

__int64 __fastcall sub_651CDA4(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_65ECAAC();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_65ECAF4();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_6522520 (0x6522520)
================================================================================

_QWORD *sub_6522520()
{
  return sub_6866980(qword_6CA9008);
}


================================================================================
Function: sub_652253C (0x652253C)
================================================================================

_QWORD *__fastcall sub_652253C(_QWORD *result)
{
  __int16 v1; // w19
  __int64 v2; // x20

  if ( result )
  {
    v1 = (__int16)result;
    sub_6522520();
    v2 = *((unsigned __int8 *)sub_6866980(qword_6CA9008) + 32);
    result = sub_6866980(qword_6CA9008);
    if ( (unsigned int)v2 > 0xF )
    {
      ++*((_DWORD *)result + 9);
    }
    else
    {
      *((_WORD *)result + v2) = v1;
      *((_BYTE *)result + 32) = v2 + 1;
    }
  }
  return result;
}


================================================================================
Function: sub_65225A4 (0x65225A4)
================================================================================

_QWORD *__fastcall sub_65225A4(_QWORD *result)
{
  unsigned __int16 v1; // w19
  int v2; // w8
  int v3; // w19
  char v4; // w8
  unsigned __int8 v5; // w20

  if ( result )
  {
    v1 = (unsigned __int16)result;
    sub_6522520();
    v2 = *((_DWORD *)sub_6866980(qword_6CA9008) + 9);
    if ( v2 )
    {
      v3 = v2 - 1;
      result = sub_6866980(qword_6CA9008);
      *((_DWORD *)result + 9) = v3;
    }
    else
    {
      v4 = *((_BYTE *)sub_6866980(qword_6CA9008) + 32);
      if ( !v4
        || (v5 = v4 - 1,
            result = sub_6866980(qword_6CA9008),
            *((_BYTE *)result + 32) = v5,
            *((unsigned __int16 *)result + v5) != v1) )
      {
        result = sub_6866980(qword_6CA9008);
        *((_BYTE *)result + 40) = 1;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6535D1C (0x6535D1C)
================================================================================

__int64 __fastcall sub_6535D1C(const char *a1, __int64 a2, unsigned int a3)
{
  _BOOL8 v6; // x3

  v6 = strcmp(a1, "GPU") == 0;
  return sub_650A098(a1, a2, a3, v6);
}


================================================================================
Function: sub_65368B4 (0x65368B4)
================================================================================

__int64 __fastcall sub_65368B4(const char *a1)
{
  int v2; // w8

  v2 = strcmp(a1, "GPU");
  return sub_650ADB4(a1, v2 == 0);
}


================================================================================
Function: sub_65368FC (0x65368FC)
================================================================================

__int64 __fastcall sub_65368FC(__int64 a1, __int64 a2, __int64 a3)
{
  bool v6; // zf
  __int64 v7; // x19
  unsigned int v8; // w21
  __int64 v9; // x23
  unsigned __int64 v10; // x0
  __int64 v11; // x8
  unsigned int v12; // w11
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x10
  bool v15; // cf
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x10
  unsigned __int64 v18; // x10
  unsigned int v19; // w12
  unsigned int v20; // w11
  unsigned int v21; // w12
  unsigned int v22; // w13
  unsigned int v23; // w12
  unsigned __int64 v24; // x10
  unsigned int v25; // w11
  unsigned int v26; // w12

  if ( byte_724A7A8 )
  {
    if ( byte_7239D80 )
      v6 = 1;
    else
      v6 = qword_6FF8708 == 0;
    if ( !v6 )
      goto LABEL_9;
    return -1LL;
  }
  if ( !qword_6FF8708 )
    return -1LL;
LABEL_9:
  v8 = sub_65EBFB8((unsigned int)dword_7239EC8);
  if ( !a3 )
    a3 = *sub_25706F4();
  if ( byte_7239E58 && a3 && *(_QWORD *)(a3 + 88) )
    ++*(_QWORD *)(a3 + 96);
  if ( byte_724A7A8 )
  {
    if ( byte_7239E18 )
    {
      if ( a3 )
      {
        v9 = sub_65C2500();
        *(_DWORD *)(a3 + 72) = sub_65C225C();
        *(_DWORD *)(a3 + 76) = sub_65C2264(v9);
        *(_QWORD *)(a3 + 56) = sub_65C226C(v9);
        v10 = sub_65C2274(v9);
        v11 = *(_QWORD *)(a3 + 8);
        *(_QWORD *)(a3 + 64) = v10;
        *(_QWORD *)(a3 + 40) = 0LL;
        *(_QWORD *)(a3 + 48) = 0LL;
        *(_QWORD *)(a3 + 32) = 0LL;
        if ( v11 )
        {
          v12 = *(_DWORD *)(v11 + 72);
          if ( v12 )
          {
            v13 = *(_QWORD *)(a3 + 56);
            v14 = *(_QWORD *)(v11 + 56);
            v15 = v13 >= v14;
            v16 = v13 - v14;
            if ( v15 )
            {
              v17 = *(_QWORD *)(v11 + 64);
              v15 = v10 >= v17;
              v18 = v10 - v17;
              if ( v15 )
              {
                v19 = *(_DWORD *)(a3 + 72);
                v15 = v19 >= v12;
                v20 = v19 - v12;
                if ( v15 )
                {
                  v21 = *(_DWORD *)(a3 + 76);
                  v22 = *(_DWORD *)(v11 + 76);
                  v15 = v21 >= v22;
                  v23 = v21 - v22;
                  if ( v15 )
                  {
                    v24 = v18 + *(_QWORD *)(v11 + 40);
                    v25 = v20 + *(_DWORD *)(v11 + 48);
                    v26 = v23 + *(_DWORD *)(v11 + 52);
                    *(_QWORD *)(v11 + 32) += v16;
                    *(_QWORD *)(v11 + 40) = v24;
                    *(_DWORD *)(v11 + 48) = v25;
                    *(_DWORD *)(v11 + 52) = v26;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v7 = sub_650B298(a1, a2);
  sub_65EBFB8(v8);
  return v7;
}


================================================================================
Function: sub_6536AFC (0x6536AFC)
================================================================================

__int64 sub_6536AFC(__int64 result, char *a2, ...)
{
  gcc_va_list va1; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-28h] BYREF

  if ( !byte_724A7A8 || !byte_7239D80 )
  {
    va_start(va, a2);
    va_copy(va1, va);
    return sub_650BCA4(result, a2);
  }
  return result;
}


================================================================================
Function: sub_6536BEC (0x6536BEC)
================================================================================

__int64 __fastcall sub_6536BEC(__int64 result, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  __int64 v6; // x22
  __int64 v9; // x21
  __int64 v10; // x8
  bool v11; // w9
  int v12; // w23
  __int64 v13; // x1
  __int64 v14; // x26
  unsigned int v15; // w23
  unsigned int v16; // w24
  unsigned __int64 v17; // x25
  unsigned __int64 v18; // x0
  unsigned int v19; // w10
  unsigned __int64 v20; // x8
  bool v21; // cf
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x9
  unsigned int v25; // w10
  unsigned int v26; // w11
  unsigned int v27; // w11
  unsigned __int64 v28; // x9
  unsigned int v29; // w10
  unsigned int v30; // w11
  __int64 v31; // x8
  unsigned __int64 v32; // x1
  unsigned __int64 v33; // x8
  unsigned __int64 v34; // [xsp+8h] [xbp-18h] BYREF
  __int64 v35; // [xsp+10h] [xbp-10h] BYREF

  v6 = a4;
  v9 = result;
  if ( byte_724A7A8 )
  {
    if ( a2 == -1 || byte_7239D80 )
      return result;
  }
  else if ( a2 == -1 )
  {
    return result;
  }
  if ( !a4 )
    v6 = *(_QWORD *)sub_25706F4(result);
  if ( byte_7239E58 )
  {
    if ( v6 )
    {
      v10 = *(_QWORD *)(v6 + 88);
      if ( v10 )
      {
        v11 = *(_QWORD *)(v6 + 96) == 1LL;
        v12 = a5 & 1;
        v13 = v12 ? 0LL : 0x2000000000000LL;
        v35 = 0LL;
        sub_650BEE8(
          33LL,
          v13 & 0xFFFE000000000000LL | v10 & 0xFFFFFFFFFFFFLL | ((unsigned __int64)v11 << 48),
          0LL,
          0LL,
          0LL,
          &v35);
        if ( !v12 )
          *(_QWORD *)(v6 + 96) = 0LL;
      }
    }
  }
  if ( byte_724A7A8 && byte_7239E18 && *off_6CA9080 && v6 )
  {
    v14 = sub_65C2500();
    v15 = sub_65C225C();
    v16 = sub_65C2264(v14);
    v17 = sub_65C226C(v14);
    v18 = sub_65C2274(v14);
    v19 = *(_DWORD *)(v6 + 72);
    if ( v19 )
    {
      v20 = *(_QWORD *)(v6 + 56);
      v21 = v17 >= v20;
      v22 = v17 - v20;
      if ( v21 )
      {
        v23 = *(_QWORD *)(v6 + 64);
        v21 = v18 >= v23;
        v24 = v18 - v23;
        if ( v21 )
        {
          v21 = v15 >= v19;
          v25 = v15 - v19;
          if ( v21 )
          {
            v26 = *(_DWORD *)(v6 + 76);
            v21 = v16 >= v26;
            v27 = v16 - v26;
            if ( v21 )
            {
              v28 = v24 + *(_QWORD *)(v6 + 40);
              v29 = v25 + *(_DWORD *)(v6 + 48);
              v30 = v27 + *(_DWORD *)(v6 + 52);
              *(_QWORD *)(v6 + 32) += v22;
              *(_QWORD *)(v6 + 40) = v28;
              *(_DWORD *)(v6 + 48) = v29;
              *(_DWORD *)(v6 + 52) = v30;
            }
          }
        }
      }
    }
    v31 = *(_QWORD *)(v6 + 8);
    if ( v31 )
    {
      *(_QWORD *)(v31 + 56) = v17;
      *(_QWORD *)(v31 + 64) = v18;
      *(_DWORD *)(v31 + 72) = v15;
      *(_DWORD *)(v31 + 76) = v16;
    }
    v32 = *(_DWORD *)(v6 + 52) & 0xFFFFFFLL | ((unsigned __int64)(*(_DWORD *)(v6 + 48) & 0xFFFFFF) << 24);
    v33 = v32 | *(unsigned int *)(v6 + 40) | ((unsigned __int64)(unsigned int)*(_QWORD *)(v6 + 32) << 32);
    v34 = *(unsigned int *)(v6 + 40) | ((unsigned __int64)(unsigned int)*(_QWORD *)(v6 + 32) << 32);
    if ( v33 )
    {
      v35 = 0LL;
      sub_650BEE8(20LL, v32, &v34, 8LL, 0LL, &v35);
    }
  }
  return sub_650C02C(v9, a2, a3);
}


================================================================================
Function: sub_658EC24 (0x658EC24)
================================================================================

__int64 __usercall sub_658EC24@<X0>(__int64 a1@<X0>, __int64 a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  return sub_6591534(a3, a1, a2);
}


================================================================================
Function: sub_658F364 (0x658F364)
================================================================================

__int64 *__usercall sub_658F364@<X0>(__int64 *__return_ptr a1@<X8>, __int64 *src@<X0>, size_t a3@<X1>)
{
  __int64 *v4; // x21
  size_t v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x22
  bool v8; // cf
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x0
  size_t v11; // x11
  unsigned __int64 v12; // x10
  const void *v13; // x21
  size_t v14; // x20
  char *v15; // x22
  const void *v16; // x21
  size_t v17; // x20
  char *v18; // x22
  size_t v19; // x23
  __int64 v20; // x8
  size_t v21; // x23
  __int64 v22; // x8
  unsigned __int64 v23; // x0
  unsigned __int64 v24; // x11
  unsigned __int64 v25; // x10
  const void *v26; // x21
  size_t v27; // x20
  char *v28; // x22
  char *v29; // x23
  __int64 v30; // x8
  unsigned __int64 v31; // x0
  char *v32; // x21
  size_t v33; // x20
  unsigned __int64 v34; // x26
  size_t v35; // x22
  char *v36; // x23
  char *v37; // x22
  __int64 v38; // x8
  __int64 v39; // x8
  char v40; // w8
  __int64 v41; // x8
  __int128 v42; // [xsp+8h] [xbp-88h] BYREF
  char *v43; // [xsp+18h] [xbp-78h]
  __int128 s2; // [xsp+20h] [xbp-70h] BYREF
  char *v45; // [xsp+30h] [xbp-60h]
  unsigned __int64 v46; // [xsp+38h] [xbp-58h]
  size_t n[2]; // [xsp+40h] [xbp-50h] BYREF
  __int128 v48; // [xsp+50h] [xbp-40h] BYREF
  char *v49; // [xsp+68h] [xbp-28h]
  size_t v50; // [xsp+70h] [xbp-20h]
  __int128 v51; // [xsp+78h] [xbp-18h] BYREF

  *(_OWORD *)((char *)a1 + 106) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  if ( !a3 )
    return src;
  v4 = src;
  v5 = 0LL;
  while ( byte_1713460[*((unsigned __int8 *)src + v5)] < 0 )
  {
    if ( a3 == ++v5 )
    {
      v50 = a3;
      v51 = (unsigned __int64)src + a3;
LABEL_12:
      *(_QWORD *)&v51 = src;
      *((_QWORD *)&v51 + 1) = a3;
      v49 = &byte_CC4FFC;
      v50 = 0LL;
      goto LABEL_13;
    }
  }
  v6 = a3 - v5;
  if ( a3 >= v5 )
    v7 = v5;
  else
    v7 = a3;
  v8 = v6 >= 3;
  v9 = v6 - 3;
  v49 = (char *)src;
  v50 = v7;
  if ( !v8 || *(unsigned __int16 *)((char *)src + v5) ^ 0x2F3A | *((unsigned __int8 *)src + v5 + 2) ^ 0x2F )
    goto LABEL_12;
  *(_QWORD *)&v51 = (char *)src + v5 + 3;
  *((_QWORD *)&v51 + 1) = v9;
  if ( src )
  {
    if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_6849630();
    if ( v7 >= 0x17 )
    {
      v29 = (char *)sub_65ECAAC();
      n[1] = v7;
      *(_QWORD *)&v48 = v29;
      n[0] = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v29 = (char *)n + 1;
      LOBYTE(n[0]) = 2 * v7;
      if ( !v7 )
      {
LABEL_104:
        v40 = *(_BYTE *)a1;
        v29[v7] = 0;
        if ( (v40 & 1) != 0 )
          sub_65ECAF4();
        goto LABEL_106;
      }
    }
    memcpy(v29, v4, v7);
    goto LABEL_104;
  }
  n[0] = 0LL;
  n[1] = 0LL;
  *(_QWORD *)&v48 = 0LL;
LABEL_106:
  v41 = v48;
  *(_OWORD *)a1 = *(_OWORD *)n;
  a1[2] = v41;
LABEL_13:
  LOBYTE(s2) = 47;
  v10 = sub_65F6474((int)&v51, &s2, 1uLL);
  if ( v10 == -1LL )
  {
    v48 = 0uLL;
    *(_OWORD *)n = v51;
  }
  else
  {
    if ( *((_QWORD *)&v51 + 1) >= v10 )
      v11 = v10;
    else
      v11 = *((_QWORD *)&v51 + 1);
    if ( *((_QWORD *)&v51 + 1) >= v10 + 1 )
      v12 = v10 + 1;
    else
      v12 = *((_QWORD *)&v51 + 1);
    n[0] = v51;
    n[1] = v11;
    *(_QWORD *)&v48 = v51 + v12;
    *((_QWORD *)&v48 + 1) = *((_QWORD *)&v51 + 1) - v12;
    if ( *((_QWORD *)&v51 + 1) != v12 )
    {
      v13 = (const void *)n[0];
      if ( !n[0] )
      {
        s2 = 0uLL;
        v45 = 0LL;
        goto LABEL_43;
      }
      v14 = n[1];
      if ( n[1] >= 0xFFFFFFFFFFFFFFF0LL )
        sub_6849630();
      if ( n[1] >= 0x17 )
      {
        v21 = (n[1] + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v15 = (char *)sub_65ECAAC();
        *((_QWORD *)&s2 + 1) = v14;
        v45 = v15;
        *(_QWORD *)&s2 = v21 | 1;
      }
      else
      {
        v15 = (char *)&s2 + 1;
        LOBYTE(s2) = 2 * LOBYTE(n[1]);
        if ( !n[1] )
          goto LABEL_42;
      }
      memcpy(v15, v13, v14);
LABEL_42:
      v15[v14] = 0;
LABEL_43:
      if ( (a1[3] & 1) != 0 )
        sub_65ECAF4();
      v22 = (__int64)v45;
      *(_OWORD *)(a1 + 3) = s2;
      a1[5] = v22;
      LOBYTE(v42) = 35;
      v23 = sub_65F6474((int)&v48, &v42, 1uLL);
      if ( v23 == -1LL )
      {
        v45 = 0LL;
        v46 = 0LL;
        s2 = v48;
      }
      else
      {
        if ( *((_QWORD *)&v48 + 1) >= v23 )
          v24 = v23;
        else
          v24 = *((_QWORD *)&v48 + 1);
        if ( *((_QWORD *)&v48 + 1) >= v23 + 1 )
          v25 = v23 + 1;
        else
          v25 = *((_QWORD *)&v48 + 1);
        v26 = (const void *)(v48 + v25);
        v27 = *((_QWORD *)&v48 + 1) - v25;
        *(_QWORD *)&s2 = v48;
        *((_QWORD *)&s2 + 1) = v24;
        v45 = (char *)(v48 + v25);
        v46 = *((_QWORD *)&v48 + 1) - v25;
        if ( *((_QWORD *)&v48 + 1) != v25 )
        {
          if ( (_QWORD)v48 )
          {
            if ( v27 >= 0xFFFFFFFFFFFFFFF0LL )
              sub_6849630();
            if ( v27 >= 0x17 )
            {
              v28 = (char *)sub_65ECAAC();
              *((_QWORD *)&v42 + 1) = v27;
              v43 = v28;
              *(_QWORD *)&v42 = (v27 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              v28 = (char *)&v42 + 1;
              LOBYTE(v42) = 2 * v27;
            }
            memcpy(v28, v26, v27);
            v28[v27] = 0;
          }
          else
          {
            v42 = 0uLL;
            v43 = 0LL;
          }
          if ( (a1[12] & 1) != 0 )
            sub_65ECAF4();
          v30 = (__int64)v43;
          *((_OWORD *)a1 + 6) = v42;
          a1[14] = v30;
        }
      }
      LOBYTE(v42) = 63;
      v31 = sub_65F6474((int)&s2, &v42, 1uLL);
      if ( v31 == -1LL )
      {
        v33 = *((_QWORD *)&s2 + 1);
        v32 = (char *)s2;
      }
      else
      {
        v32 = (char *)s2;
        if ( *((_QWORD *)&s2 + 1) >= v31 )
          v33 = v31;
        else
          v33 = *((_QWORD *)&s2 + 1);
        if ( *((_QWORD *)&s2 + 1) >= v31 + 1 )
          v34 = v31 + 1;
        else
          v34 = *((_QWORD *)&s2 + 1);
        v35 = *((_QWORD *)&s2 + 1) - v34;
        if ( *((_QWORD *)&s2 + 1) != v34 )
        {
          if ( (_QWORD)s2 )
          {
            if ( v35 >= 0xFFFFFFFFFFFFFFF0LL )
              sub_6849630();
            if ( v35 >= 0x17 )
            {
              v36 = (char *)sub_65ECAAC();
              *((_QWORD *)&v42 + 1) = v35;
              v43 = v36;
              *(_QWORD *)&v42 = (v35 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              v36 = (char *)&v42 + 1;
              LOBYTE(v42) = 2 * v35;
            }
            memcpy(v36, &v32[v34], v35);
            v36[v35] = 0;
          }
          else
          {
            v42 = 0uLL;
            v43 = 0LL;
          }
          if ( (a1[9] & 1) != 0 )
            sub_65ECAF4();
          v38 = (__int64)v43;
          *(_OWORD *)(a1 + 9) = v42;
          a1[11] = v38;
          if ( !v32 )
            goto LABEL_96;
          goto LABEL_83;
        }
      }
      if ( !v32 )
      {
LABEL_96:
        v42 = 0uLL;
        v43 = 0LL;
        goto LABEL_97;
      }
LABEL_83:
      if ( v33 >= 0xFFFFFFFFFFFFFFF0LL )
        sub_6849630();
      if ( v33 >= 0x17 )
      {
        v37 = (char *)sub_65ECAAC();
        *((_QWORD *)&v42 + 1) = v33;
        v43 = v37;
        *(_QWORD *)&v42 = (v33 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        v37 = (char *)&v42 + 1;
        LOBYTE(v42) = 2 * v33;
        if ( !v33 )
          goto LABEL_89;
      }
      memcpy(v37, v32, v33);
LABEL_89:
      v37[v33] = 0;
LABEL_97:
      if ( (a1[6] & 1) != 0 )
        sub_65ECAF4();
      v39 = (__int64)v43;
      *((_OWORD *)a1 + 3) = v42;
      a1[8] = v39;
      return (__int64 *)sub_658F98C((__int64)a1);
    }
  }
  v16 = (const void *)n[0];
  if ( n[0] )
  {
    v17 = n[1];
    if ( n[1] >= 0xFFFFFFFFFFFFFFF0LL )
      sub_6849630();
    if ( n[1] >= 0x17 )
    {
      v19 = (n[1] + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v18 = (char *)sub_65ECAAC();
      *((_QWORD *)&s2 + 1) = v17;
      v45 = v18;
      *(_QWORD *)&s2 = v19 | 1;
    }
    else
    {
      v18 = (char *)&s2 + 1;
      LOBYTE(s2) = 2 * LOBYTE(n[1]);
      if ( !n[1] )
        goto LABEL_35;
    }
    memcpy(v18, v16, v17);
LABEL_35:
    v18[v17] = 0;
    goto LABEL_36;
  }
  s2 = 0uLL;
  v45 = 0LL;
LABEL_36:
  if ( (a1[3] & 1) != 0 )
    sub_65ECAF4();
  v20 = (__int64)v45;
  *(_OWORD *)(a1 + 3) = s2;
  a1[5] = v20;
  sub_684A29C((_DWORD)a1 + 48, "/");
  return (__int64 *)sub_658F98C((__int64)a1);
}


================================================================================
Function: sub_658F98C (0x658F98C)
================================================================================

__int64 __fastcall sub_658F98C(__int64 result)
{
  unsigned __int8 *v1; // x19
  unsigned __int64 v2; // x8
  bool v3; // zf
  unsigned __int64 v4; // x8
  int8x16_t *v5; // x9
  char *v6; // x11
  unsigned __int64 v7; // x10
  int8x16_t *v8; // x11
  int32x4_t v9; // q0
  unsigned __int64 v10; // x12
  uint32x4_t v11; // q1
  int8x16_t v12; // q2
  int8x16_t v13; // q3
  int16x8_t v14; // q5
  int16x8_t v15; // q6
  int16x8_t v16; // q7
  int16x8_t v17; // q16
  int8x16_t v18; // q4
  int32x4_t v19; // q0
  uint32x4_t v20; // q1
  int8x8_t *v21; // x13
  unsigned __int64 v22; // x10
  int16x8_t v23; // q4
  char *v24; // x8
  int v25; // w9
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x8
  int8x16_t *v28; // x9
  char *v29; // x11
  __int64 v30; // x10
  int8x16_t *v31; // x11
  int32x4_t v32; // q0
  unsigned __int64 v33; // x12
  uint32x4_t v34; // q1
  int8x16_t v35; // q2
  int8x16_t v36; // q3
  int16x8_t v37; // q5
  int16x8_t v38; // q6
  int16x8_t v39; // q7
  int16x8_t v40; // q16
  int8x16_t v41; // q4
  int32x4_t v42; // q0
  uint32x4_t v43; // q1
  int8x8_t *v44; // x13
  __int64 v45; // x10
  int16x8_t v46; // q4
  char *v47; // x8
  int v48; // w9
  char v49; // w8
  unsigned __int64 v50; // x10
  unsigned __int8 *v51; // x20
  unsigned __int64 v52; // x8
  int v53; // w9
  unsigned __int64 v54; // x10
  unsigned __int64 v55; // x11
  unsigned __int8 *v56; // x11
  unsigned __int8 *v57; // x22
  _BYTE *v58; // x1
  unsigned __int64 v59; // x10
  unsigned __int8 *v60; // x23
  unsigned __int8 *v61; // x8
  unsigned __int8 *v62; // x8
  int v63; // t1
  unsigned __int8 *v64; // x26
  unsigned __int8 *v65; // x0
  unsigned __int8 *v66; // x1
  __int64 v67; // x8
  __int64 v68; // x10
  unsigned __int8 *v69; // x9
  unsigned __int8 *v70; // x11
  signed __int64 v71; // x27
  signed __int64 v72; // x19
  unsigned __int64 v73; // x8
  unsigned __int64 v74; // x8
  unsigned __int64 v75; // x8

  v1 = (unsigned __int8 *)result;
  v2 = *(unsigned __int8 *)result;
  v3 = (v2 & 1) == 0;
  v4 = v2 >> 1;
  if ( v3 )
  {
    v5 = (int8x16_t *)(result + 1);
  }
  else
  {
    v4 = *(_QWORD *)(result + 8);
    v5 = *(int8x16_t **)(result + 16);
  }
  if ( !v4 )
    goto LABEL_21;
  v6 = (char *)v5;
  if ( v4 >= 8 )
  {
    if ( v4 < 0x20 )
    {
      v7 = 0LL;
      goto LABEL_12;
    }
    v7 = v4 & 0xFFFFFFFFFFFFFFE0LL;
    v8 = v5 + 1;
    v9.n128_u64[0] = 0x4000000040LL;
    v9.n128_u64[1] = 0x4000000040LL;
    v10 = v4 & 0xFFFFFFFFFFFFFFE0LL;
    v11.n128_u64[0] = 0x1A0000001ALL;
    v11.n128_u64[1] = 0x1A0000001ALL;
    v12.n128_u64[0] = 0x2020202020202020LL;
    v12.n128_u64[1] = 0x2020202020202020LL;
    do
    {
      v13 = v8[-1];
      v10 -= 32LL;
      v14 = vmovl_s8((int8x8_t)v13.n128_u64[0]);
      v15 = vmovl_high_s8(v13);
      v16 = vmovl_high_s8(*v8);
      v17 = vmovl_s8((int8x8_t)v8->n128_u64[0]);
      v18 = vbslq_s8(
              vuzp1q_s8(
                vuzp1q_s16(
                  vcgtq_u32(v11, vaddw_s16(v9, (int16x4_t)v17.n128_u64[0])),
                  vcgtq_u32(v11, vaddw_high_s16(v9, v17))),
                vuzp1q_s16(
                  vcgtq_u32(v11, vaddw_s16(v9, (int16x4_t)v16.n128_u64[0])),
                  vcgtq_u32(v11, vaddw_high_s16(v9, v16)))),
              vorrq_s8(*v8, v12),
              *v8);
      v8[-1] = vbslq_s8(
                 vuzp1q_s8(
                   vuzp1q_s16(
                     vcgtq_u32(v11, vaddw_s16(v9, (int16x4_t)v14.n128_u64[0])),
                     vcgtq_u32(v11, vaddw_high_s16(v9, v14))),
                   vuzp1q_s16(
                     vcgtq_u32(v11, vaddw_s16(v9, (int16x4_t)v15.n128_u64[0])),
                     vcgtq_u32(v11, vaddw_high_s16(v9, v15)))),
                 vorrq_s8(v13, v12),
                 v13);
      *v8 = v18;
      v8 += 2;
    }
    while ( v10 );
    if ( v4 == v7 )
      goto LABEL_21;
    if ( (v4 & 0x18) != 0 )
    {
LABEL_12:
      v19.n128_u64[0] = 0x4000000040LL;
      v19.n128_u64[1] = 0x4000000040LL;
      v6 = (char *)v5 + (v4 & 0xFFFFFFFFFFFFFFF8LL);
      v20.n128_u64[0] = 0x1A0000001ALL;
      v20.n128_u64[1] = 0x1A0000001ALL;
      v21 = (int8x8_t *)((char *)v5 + v7);
      v22 = v7 - (v4 & 0xFFFFFFFFFFFFFFF8LL);
      do
      {
        v22 += 8LL;
        v23 = vmovl_s8((int8x8_t)v21->n64_u64[0]);
        v21->n64_u64[0] = vbsl_s8(
                            vmovn_s16(
                              vuzp1q_s16(
                                vcgtq_u32(v20, vaddw_s16(v19, (int16x4_t)v23.n128_u64[0])),
                                vcgtq_u32(v20, vaddw_high_s16(v19, v23)))),
                            vorr_s8((int8x8_t)v21->n64_u64[0], (int8x8_t)0x2020202020202020LL),
                            (int8x8_t)v21->n64_u64[0]).n64_u64[0];
        ++v21;
      }
      while ( v22 );
      if ( v4 == (v4 & 0xFFFFFFFFFFFFFFF8LL) )
        goto LABEL_21;
      goto LABEL_17;
    }
    v6 = (char *)v5 + v7;
  }
LABEL_17:
  v24 = (char *)v5 + v4;
  do
  {
    v25 = *v6;
    if ( (unsigned int)(v25 - 65) < 0x1A )
      LOBYTE(v25) = v25 | 0x20;
    *v6++ = v25;
  }
  while ( v6 != v24 );
LABEL_21:
  v26 = *(unsigned __int8 *)(result + 24);
  v3 = (v26 & 1) == 0;
  v27 = v26 >> 1;
  if ( v3 )
  {
    v28 = (int8x16_t *)(result + 25);
  }
  else
  {
    v27 = *(_QWORD *)(result + 32);
    v28 = *(int8x16_t **)(result + 40);
  }
  if ( !v27 )
    goto LABEL_41;
  v29 = (char *)v28;
  if ( v27 >= 8 )
  {
    if ( v27 < 0x20 )
    {
      v30 = 0LL;
LABEL_32:
      v42.n128_u64[0] = 0x4000000040LL;
      v42.n128_u64[1] = 0x4000000040LL;
      v29 = (char *)v28 + (v27 & 0xFFFFFFFFFFFFFFF8LL);
      v43.n128_u64[0] = 0x1A0000001ALL;
      v43.n128_u64[1] = 0x1A0000001ALL;
      v44 = (int8x8_t *)((char *)v28 + v30);
      v45 = v30 - (v27 & 0xFFFFFFFFFFFFFFF8LL);
      do
      {
        v45 += 8LL;
        v46 = vmovl_s8((int8x8_t)v44->n64_u64[0]);
        v44->n64_u64[0] = vbsl_s8(
                            vmovn_s16(
                              vuzp1q_s16(
                                vcgtq_u32(v43, vaddw_s16(v42, (int16x4_t)v46.n128_u64[0])),
                                vcgtq_u32(v43, vaddw_high_s16(v42, v46)))),
                            vorr_s8((int8x8_t)v44->n64_u64[0], (int8x8_t)0x2020202020202020LL),
                            (int8x8_t)v44->n64_u64[0]).n64_u64[0];
        ++v44;
      }
      while ( v45 );
      if ( v27 == (v27 & 0xFFFFFFFFFFFFFFF8LL) )
        goto LABEL_41;
      goto LABEL_37;
    }
    v30 = v27 & 0xFFFFFFFFFFFFFFE0LL;
    v31 = v28 + 1;
    v32.n128_u64[0] = 0x4000000040LL;
    v32.n128_u64[1] = 0x4000000040LL;
    v33 = v27 & 0xFFFFFFFFFFFFFFE0LL;
    v34.n128_u64[0] = 0x1A0000001ALL;
    v34.n128_u64[1] = 0x1A0000001ALL;
    v35.n128_u64[0] = 0x2020202020202020LL;
    v35.n128_u64[1] = 0x2020202020202020LL;
    do
    {
      v36 = v31[-1];
      v33 -= 32LL;
      v37 = vmovl_s8((int8x8_t)v36.n128_u64[0]);
      v38 = vmovl_high_s8(v36);
      v39 = vmovl_high_s8(*v31);
      v40 = vmovl_s8((int8x8_t)v31->n128_u64[0]);
      v41 = vbslq_s8(
              vuzp1q_s8(
                vuzp1q_s16(
                  vcgtq_u32(v34, vaddw_s16(v32, (int16x4_t)v40.n128_u64[0])),
                  vcgtq_u32(v34, vaddw_high_s16(v32, v40))),
                vuzp1q_s16(
                  vcgtq_u32(v34, vaddw_s16(v32, (int16x4_t)v39.n128_u64[0])),
                  vcgtq_u32(v34, vaddw_high_s16(v32, v39)))),
              vorrq_s8(*v31, v35),
              *v31);
      v31[-1] = vbslq_s8(
                  vuzp1q_s8(
                    vuzp1q_s16(
                      vcgtq_u32(v34, vaddw_s16(v32, (int16x4_t)v37.n128_u64[0])),
                      vcgtq_u32(v34, vaddw_high_s16(v32, v37))),
                    vuzp1q_s16(
                      vcgtq_u32(v34, vaddw_s16(v32, (int16x4_t)v38.n128_u64[0])),
                      vcgtq_u32(v34, vaddw_high_s16(v32, v38)))),
                  vorrq_s8(v36, v35),
                  v36);
      *v31 = v41;
      v31 += 2;
    }
    while ( v33 );
    if ( v27 == v30 )
      goto LABEL_41;
    if ( (v27 & 0x18) != 0 )
      goto LABEL_32;
    v29 = (char *)v28 + v30;
  }
LABEL_37:
  v47 = (char *)v28 + v27;
  do
  {
    v48 = *v29;
    if ( (unsigned int)(v48 - 65) < 0x1A )
      LOBYTE(v48) = v48 | 0x20;
    *v29++ = v48;
  }
  while ( v29 != v47 );
LABEL_41:
  if ( byte_724A7A8 && byte_7247030 )
  {
    result = sub_65902CC(result);
    if ( (result & 1) != 0
      && (result = sub_65902CC(v1 + 24), (result & 1) != 0)
      && (result = sub_65902CC(v1 + 48), (result & 1) != 0)
      && (result = sub_65902CC(v1 + 72), (result & 1) != 0) )
    {
      result = sub_65902CC(v1 + 96);
      v49 = result ^ 1;
    }
    else
    {
      v49 = 1;
    }
    v1[120] = v49 & 1;
  }
  v51 = v1 + 48;
  v50 = v1[48];
  v52 = *((_QWORD *)v1 + 7);
  v53 = v50 & 1;
  v54 = v50 >> 1;
  if ( v53 )
    v55 = *((_QWORD *)v1 + 7);
  else
    v55 = v54;
  if ( v55 )
  {
    v56 = (unsigned __int8 *)*((_QWORD *)v1 + 8);
    v57 = v1 + 49;
    if ( v53 )
      v58 = (_BYTE *)*((_QWORD *)v1 + 8);
    else
      v58 = v1 + 49;
    if ( *v58 != 47 )
    {
      sub_684A624(v1 + 48);
      v59 = v1[48];
      v52 = *((_QWORD *)v1 + 7);
      v56 = (unsigned __int8 *)*((_QWORD *)v1 + 8);
      v53 = v59 & 1;
      v54 = v59 >> 1;
    }
    if ( v53 )
      v57 = v56;
    else
      v52 = v54;
    v60 = &v57[v52];
    v61 = &v57[v52];
    v63 = *(v61 - 1);
    v62 = v61 - 1;
    if ( v63 == 47 )
      v64 = v62;
    else
      v64 = v60;
    if ( v64 != v57 )
    {
      v65 = 0LL;
      v66 = 0LL;
      v67 = 0LL;
      while ( 1 )
      {
        v68 = 0LL;
        v69 = v64;
        do
          v70 = &v64[v68--];
        while ( *(v70 - 1) != 47 );
        v64 += v68;
        if ( v68 == -1 )
          goto LABEL_69;
        if ( -v68 == 3 )
        {
          if ( v64[1] == 46 && v69[v68 + 2] == 46 )
          {
            ++v67;
            if ( byte_724A7A8 && byte_7247050 )
              v1[121] = 1;
            goto LABEL_69;
          }
        }
        else if ( -v68 == 2 && v64[1] == 46 )
        {
          goto LABEL_69;
        }
        if ( v67 )
        {
          --v67;
LABEL_69:
          v65 = v64;
          if ( !v66 )
            v66 = v69;
          goto LABEL_71;
        }
        if ( v65 )
        {
          v71 = v65 - v66;
          memmove(v65, v66, v60 - v66);
          v67 = 0LL;
          v66 = 0LL;
          v65 = 0LL;
          v60 += v71;
        }
        else
        {
          v67 = 0LL;
        }
LABEL_71:
        if ( v64 == v57 )
        {
          if ( v65 )
          {
            v72 = v65 - v66;
            memmove(v65, v66, v60 - v66);
            v60 += v72;
          }
          break;
        }
      }
    }
    if ( v60 > v57 )
      return (__int64)sub_684A708(v51, v60 - v57, 0);
    return sub_684A29C((int)v51, "/");
  }
  v73 = *v1;
  if ( (v73 & 1) != 0 )
    v74 = *((_QWORD *)v1 + 1);
  else
    v74 = v73 >> 1;
  if ( v74 )
  {
    v75 = v1[24];
    if ( (v75 & 1) != 0 ? *((_QWORD *)v1 + 4) : v75 >> 1 )
      return sub_684A29C((int)v51, "/");
  }
  return result;
}


================================================================================
Function: sub_658FEF4 (0x658FEF4)
================================================================================

__int64 *__usercall sub_658FEF4@<X0>(
        __int64 *__return_ptr a1@<X8>,
        void *src@<X0>,
        size_t n@<X1>,
        void *a4@<X2>,
        void *a5@<X4>,
        size_t a6@<X3>,
        size_t a7@<X5>,
        const void *a8@<X6>,
        size_t a9@<X7>,
        void *a10,
        size_t na)
{
  char *v19; // x28
  size_t v20; // x21
  __int64 v21; // x8
  char *v22; // x26
  __int64 v23; // x8
  char *v24; // x24
  __int64 v25; // x8
  char *v26; // x22
  __int64 v27; // x8
  char *v28; // x22
  __int64 v29; // x8
  __int128 v32; // [xsp+10h] [xbp-20h] BYREF
  char *v33; // [xsp+20h] [xbp-10h]

  *(_OWORD *)((char *)a1 + 106) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  if ( !src )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_11;
  }
  if ( n >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( n >= 0x17 )
  {
    v20 = (n + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v19 = (char *)sub_65ECAAC();
    *((_QWORD *)&v32 + 1) = n;
    v33 = v19;
    *(_QWORD *)&v32 = v20 | 1;
    goto LABEL_8;
  }
  v19 = (char *)&v32 + 1;
  LOBYTE(v32) = 2 * n;
  if ( n )
LABEL_8:
    memcpy(v19, src, n);
  v19[n] = 0;
  if ( (*(_BYTE *)a1 & 1) != 0 )
    sub_65ECAF4();
LABEL_11:
  v21 = (__int64)v33;
  *(_OWORD *)a1 = v32;
  a1[2] = v21;
  if ( !a4 )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_20;
  }
  if ( a6 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( a6 >= 0x17 )
  {
    v22 = (char *)sub_65ECAAC();
    *((_QWORD *)&v32 + 1) = a6;
    v33 = v22;
    *(_QWORD *)&v32 = (a6 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v22 = (char *)&v32 + 1;
    LOBYTE(v32) = 2 * a6;
    if ( !a6 )
      goto LABEL_19;
  }
  memcpy(v22, a4, a6);
LABEL_19:
  v22[a6] = 0;
LABEL_20:
  if ( (a1[3] & 1) != 0 )
    sub_65ECAF4();
  v23 = (__int64)v33;
  *(_OWORD *)(a1 + 3) = v32;
  a1[5] = v23;
  if ( !a5 )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_31;
  }
  if ( a7 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( a7 >= 0x17 )
  {
    v24 = (char *)sub_65ECAAC();
    *((_QWORD *)&v32 + 1) = a7;
    v33 = v24;
    *(_QWORD *)&v32 = (a7 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v24 = (char *)&v32 + 1;
    LOBYTE(v32) = 2 * a7;
    if ( !a7 )
      goto LABEL_30;
  }
  memcpy(v24, a5, a7);
LABEL_30:
  v24[a7] = 0;
LABEL_31:
  if ( (a1[6] & 1) != 0 )
    sub_65ECAF4();
  v25 = (__int64)v33;
  *((_OWORD *)a1 + 3) = v32;
  a1[8] = v25;
  if ( !a8 )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_42;
  }
  if ( a9 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( a9 >= 0x17 )
  {
    v26 = (char *)sub_65ECAAC();
    *((_QWORD *)&v32 + 1) = a9;
    v33 = v26;
    *(_QWORD *)&v32 = (a9 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v26 = (char *)&v32 + 1;
    LOBYTE(v32) = 2 * a9;
    if ( !a9 )
      goto LABEL_41;
  }
  memcpy(v26, a8, a9);
LABEL_41:
  v26[a9] = 0;
LABEL_42:
  if ( (a1[9] & 1) != 0 )
    sub_65ECAF4();
  v27 = (__int64)v33;
  *(_OWORD *)(a1 + 9) = v32;
  a1[11] = v27;
  if ( !a10 )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_53;
  }
  if ( na >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( na >= 0x17 )
  {
    v28 = (char *)sub_65ECAAC();
    *((_QWORD *)&v32 + 1) = na;
    v33 = v28;
    *(_QWORD *)&v32 = (na + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v28 = (char *)&v32 + 1;
    LOBYTE(v32) = 2 * na;
    if ( !na )
      goto LABEL_52;
  }
  memcpy(v28, a10, na);
LABEL_52:
  v28[na] = 0;
LABEL_53:
  if ( (a1[12] & 1) != 0 )
    sub_65ECAF4();
  v29 = (__int64)v33;
  *((_OWORD *)a1 + 6) = v32;
  a1[14] = v29;
  return (__int64 *)sub_658F98C((int)a1);
}


================================================================================
Function: sub_65902CC (0x65902CC)
================================================================================

__int64 __fastcall sub_65902CC(unsigned __int8 *a1)
{
  unsigned __int64 v1; // x15
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x14
  unsigned __int64 v4; // x1
  unsigned __int64 v5; // x13
  unsigned __int8 *v6; // x15
  int v7; // w13
  unsigned __int8 *v8; // x2
  int v9; // w3
  int v10; // w17
  int v11; // w3
  int v12; // w2
  bool v13; // zf
  int v14; // w17
  unsigned __int8 *v15; // x15
  int v16; // w16
  unsigned __int8 *v17; // x15
  unsigned __int8 *v18; // x15
  unsigned __int8 *v19; // x14
  unsigned __int8 *v20; // x15
  int v21; // w14

  v1 = *a1;
  v2 = *((_QWORD *)a1 + 1);
  if ( (v1 & 1) == 0 )
    v2 = v1 >> 1;
  if ( v2 )
  {
    v3 = 0LL;
    v4 = 0LL;
    while ( 1 )
    {
      if ( (v1 & 1) != 0 )
        v6 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      else
        v6 = a1 + 1;
      v7 = v6[v3];
      if ( v7 == 37 )
      {
        v5 = v3 + 3;
        if ( v3 + 3 > v2 )
          return 0LL;
        v8 = &v6[v3 + 1];
        v9 = *v8;
        v10 = v9 - 48;
        if ( (unsigned int)(v9 - 48) > 9 )
        {
          v10 = (v9 | 0x20) - 87;
          if ( (v9 | 0x20u) - 97 > 5 )
            v10 = -1;
        }
        v11 = v8[1];
        v12 = v11 - 48;
        if ( (unsigned int)(v11 - 48) > 9 )
        {
          if ( (v11 | 0x20u) - 97 > 5 )
            v12 = -1;
          else
            v12 = (v11 | 0x20) - 87;
        }
        v13 = v12 == -1 || v10 == -1;
        v14 = v12 + 16 * v10;
        if ( v13 )
          v14 = -1;
        if ( v14 < 0 )
          return 0LL;
        if ( (byte_1713460[(unsigned __int8)v14] & 1) != 0 )
        {
          v6[v4++] = v14;
          if ( v5 >= v2 )
            goto LABEL_42;
        }
        else
        {
          v6[v4] = 37;
          if ( (*a1 & 1) != 0 )
            v15 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
          else
            v15 = a1 + 1;
          v16 = (char)v15[v3 + 1];
          v17 = &v15[v4];
          if ( (unsigned int)(v16 - 97) < 0x1A )
            LOBYTE(v16) = v16 ^ 0x20;
          v17[1] = v16;
          if ( (*a1 & 1) != 0 )
            v18 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
          else
            v18 = a1 + 1;
          v19 = &v18[v3];
          v20 = &v18[v4];
          v4 += 3LL;
          v21 = (char)v19[2];
          if ( (unsigned int)(v21 - 97) < 0x1A )
            LOBYTE(v21) = v21 ^ 0x20;
          v20[2] = v21;
          if ( v5 >= v2 )
            goto LABEL_42;
        }
      }
      else
      {
        v6[v4++] = v7;
        v5 = v3 + 1;
        if ( v3 + 1 >= v2 )
          goto LABEL_42;
      }
      LOBYTE(v1) = *a1;
      v3 = v5;
    }
  }
  v4 = 0LL;
LABEL_42:
  sub_684A708(a1, v4, 0);
  return 1LL;
}


================================================================================
Function: sub_659046C (0x659046C)
================================================================================

unsigned __int64 *__usercall sub_659046C@<X0>(unsigned __int8 *a1@<X0>, unsigned __int64 *a2@<X8>)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x12
  unsigned __int8 *v5; // x24
  unsigned __int64 v6; // x13
  unsigned __int8 *v7; // x23
  unsigned __int64 v8; // x11
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x10
  unsigned __int8 *v13; // x22
  unsigned __int64 v14; // x13
  unsigned __int8 *v15; // x21
  unsigned __int64 v16; // x10
  unsigned __int64 v17; // x8
  unsigned __int64 v19; // x9
  unsigned __int64 v20; // x8
  size_t v21; // x2
  void *v22; // x1
  unsigned __int64 v23; // x8
  bool v24; // zf
  size_t v25; // x8
  void *v26; // x1
  size_t v27; // x2
  unsigned __int64 *result; // x0
  unsigned __int64 v29; // x10
  size_t v30; // x8
  int v31; // w9
  size_t v32; // x10
  size_t v33; // x11
  void *v34; // x11
  _BYTE *v35; // x12
  unsigned __int64 v36; // x10
  void *v37; // x1
  size_t v38; // x2
  unsigned __int64 v39; // x8
  unsigned __int64 v40; // x8
  unsigned __int64 v41; // x8
  unsigned __int64 v42; // x8
  unsigned __int64 v43; // x8
  bool v44; // zf
  size_t v45; // x8
  void *v46; // x1
  size_t v47; // x2
  unsigned __int64 v48; // x8
  unsigned __int64 v49; // x8
  unsigned __int64 v50; // x8
  bool v51; // zf
  size_t v52; // x8
  void *v53; // x1
  size_t v54; // x2

  v3 = *a1;
  v5 = a1 + 24;
  v4 = a1[24];
  v7 = a1 + 48;
  v6 = a1[48];
  v8 = *((_QWORD *)a1 + 7);
  if ( (v3 & 1) != 0 )
    v9 = *((_QWORD *)a1 + 1);
  else
    v9 = v3 >> 1;
  v10 = v4 >> 1;
  if ( (v4 & 1) != 0 )
    v10 = *((_QWORD *)a1 + 4);
  v11 = v9 + v10;
  v13 = a1 + 72;
  v12 = a1[72];
  if ( (v6 & 1) == 0 )
    v8 = v6 >> 1;
  v15 = a1 + 96;
  v14 = a1[96];
  if ( (v12 & 1) != 0 )
    v16 = *((_QWORD *)a1 + 10);
  else
    v16 = v12 >> 1;
  v17 = v11 + v8;
  if ( (v14 & 1) != 0 )
    v19 = *((_QWORD *)a1 + 13);
  else
    v19 = v14 >> 1;
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  sub_6601820(a2, v17 + v16 + v19 + 6);
  v20 = *a1;
  if ( (v20 & 1) != 0 )
    v21 = *((_QWORD *)a1 + 1);
  else
    v21 = v20 >> 1;
  if ( v21 )
  {
    if ( (v20 & 1) != 0 )
      v22 = (void *)*((_QWORD *)a1 + 2);
    else
      v22 = a1 + 1;
    sub_65FFB9C(a2, v22, v21);
    sub_684A544(a2, "://");
  }
  v23 = a1[24];
  v24 = (v23 & 1) == 0;
  v25 = v23 >> 1;
  if ( v24 )
    v26 = v5 + 1;
  else
    v26 = (void *)*((_QWORD *)a1 + 5);
  if ( v24 )
    v27 = v25;
  else
    v27 = *((_QWORD *)a1 + 4);
  result = sub_65FFB9C(a2, v26, v27);
  v29 = a1[48];
  v30 = *((_QWORD *)a1 + 7);
  v31 = v29 & 1;
  v32 = v29 >> 1;
  if ( v31 )
    v33 = *((_QWORD *)a1 + 7);
  else
    v33 = v32;
  if ( v33 )
  {
    v34 = (void *)*((_QWORD *)a1 + 8);
    if ( v31 )
      v35 = (_BYTE *)*((_QWORD *)a1 + 8);
    else
      v35 = v7 + 1;
    if ( *v35 != 47 )
    {
      sub_6601588(a2, 47LL);
      v36 = a1[48];
      v30 = *((_QWORD *)a1 + 7);
      v34 = (void *)*((_QWORD *)a1 + 8);
      v31 = v36 & 1;
      v32 = v36 >> 1;
    }
    if ( v31 )
      v37 = v34;
    else
      v37 = v7 + 1;
    if ( v31 )
      v38 = v30;
    else
      v38 = v32;
    result = sub_65FFB9C(a2, v37, v38);
  }
  else
  {
    v39 = a1[24];
    if ( (v39 & 1) != 0 )
      v40 = *((_QWORD *)a1 + 4);
    else
      v40 = v39 >> 1;
    if ( v40 )
      result = (unsigned __int64 *)sub_6601588(a2, 47LL);
  }
  v41 = a1[72];
  if ( (v41 & 1) != 0 )
    v42 = *((_QWORD *)a1 + 10);
  else
    v42 = v41 >> 1;
  if ( v42 )
  {
    sub_6601588(a2, 63LL);
    v43 = a1[72];
    v44 = (v43 & 1) == 0;
    v45 = v43 >> 1;
    if ( v44 )
      v46 = v13 + 1;
    else
      v46 = (void *)*((_QWORD *)a1 + 11);
    if ( v44 )
      v47 = v45;
    else
      v47 = *((_QWORD *)a1 + 10);
    result = sub_65FFB9C(a2, v46, v47);
  }
  v48 = a1[96];
  if ( (v48 & 1) != 0 )
    v49 = *((_QWORD *)a1 + 13);
  else
    v49 = v48 >> 1;
  if ( v49 )
  {
    sub_6601588(a2, 35LL);
    v50 = a1[96];
    v51 = (v50 & 1) == 0;
    v52 = v50 >> 1;
    if ( v51 )
      v53 = v15 + 1;
    else
      v53 = (void *)*((_QWORD *)a1 + 14);
    if ( v51 )
      v54 = v52;
    else
      v54 = *((_QWORD *)a1 + 13);
    return sub_65FFB9C(a2, v53, v54);
  }
  return result;
}


================================================================================
Function: sub_65906C0 (0x65906C0)
================================================================================

bool __fastcall sub_65906C0(unsigned __int8 *a1)
{
  bool v2; // zf
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x9
  unsigned __int8 *v5; // x8
  unsigned __int8 *v6; // x8
  unsigned __int64 v7; // x9
  _BOOL8 result; // x0
  int v9; // t1
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x9
  unsigned __int8 *v12; // x8
  unsigned __int8 *v13; // x8
  unsigned __int64 v14; // x9
  int v15; // t1
  unsigned __int64 v16; // x10
  unsigned __int64 v17; // x8
  unsigned __int8 *v18; // x9
  int v19; // t1
  unsigned __int64 v20; // x10
  unsigned __int8 *v21; // x9
  int v22; // t1

  if ( byte_724A7A8 )
    v2 = byte_7247030 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = *a1;
    v4 = *((_QWORD *)a1 + 1);
    if ( (v3 & 1) == 0 )
      v4 = v3 >> 1;
    if ( v4 )
    {
      v5 = (v3 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a1 + 2) : a1 + 1;
      if ( ((char)*v5 & 0xFFFFFFDF) - 91 >= 0xFFFFFFE6 && byte_1713460[*v5] < 0 )
      {
        v6 = v5 + 1;
        v7 = v4 - 1;
        result = 0LL;
        while ( v7 )
        {
          v9 = *v6++;
          --v7;
          if ( (byte_1713460[v9] & 0x80000000) == 0 )
            return result;
        }
        if ( (sub_6590988(a1) & 1) != 0 )
        {
          v16 = a1[48];
          v17 = *((_QWORD *)a1 + 7);
          if ( (v16 & 1) == 0 )
            v17 = v16 >> 1;
          if ( v17 )
          {
            if ( (v16 & 1) != 0 )
              v18 = (unsigned __int8 *)*((_QWORD *)a1 + 8);
            else
              v18 = a1 + 49;
            while ( (byte_1713460[*v18] & 0x37) != 0 )
            {
              if ( (byte_1713460[*v18] & 2) != 0 )
              {
                if ( v17 < 3 )
                  return v17 == 0;
                v19 = v18[2];
                v18 += 2;
                if ( ((unsigned __int8)byte_1713460[*(v18 - 1)] & (unsigned __int8)byte_1713460[v19] & 8) == 0 )
                {
LABEL_46:
                  v17 = 1LL;
                  return v17 == 0;
                }
                v17 -= 2LL;
              }
              ++v18;
              if ( !--v17 )
                return v17 == 0;
            }
            return v17 == 0;
          }
        }
      }
    }
  }
  else if ( !a1[120] )
  {
    v10 = *a1;
    v11 = *((_QWORD *)a1 + 1);
    if ( (v10 & 1) == 0 )
      v11 = v10 >> 1;
    if ( v11 )
    {
      v12 = (v10 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a1 + 2) : a1 + 1;
      if ( ((char)*v12 & 0xFFFFFFDF) - 91 >= 0xFFFFFFE6 && byte_1713460[*v12] < 0 )
      {
        v13 = v12 + 1;
        v14 = v11 - 1;
        result = 0LL;
        while ( v14 )
        {
          v15 = *v13++;
          --v14;
          if ( (byte_1713460[v15] & 0x80000000) == 0 )
            return result;
        }
        if ( (sub_6590988(a1) & 1) != 0 )
        {
          v20 = a1[48];
          v17 = *((_QWORD *)a1 + 7);
          if ( (v20 & 1) == 0 )
            v17 = v20 >> 1;
          if ( v17 )
          {
            if ( (v20 & 1) != 0 )
              v21 = (unsigned __int8 *)*((_QWORD *)a1 + 8);
            else
              v21 = a1 + 49;
            while ( (byte_1713460[*v21] & 0x37) != 0 )
            {
              if ( (byte_1713460[*v21] & 2) != 0 )
              {
                if ( v17 < 3 )
                  return v17 == 0;
                v22 = v21[2];
                v21 += 2;
                if ( ((unsigned __int8)byte_1713460[*(v21 - 1)] & (unsigned __int8)byte_1713460[v22] & 8) == 0 )
                  goto LABEL_46;
                v17 -= 2LL;
              }
              ++v21;
              if ( !--v17 )
                return v17 == 0;
            }
            return v17 == 0;
          }
        }
      }
    }
  }
  return 0LL;
}


================================================================================
Function: sub_6590988 (0x6590988)
================================================================================

bool __fastcall sub_6590988(__int64 a1)
{
  unsigned __int64 v1; // x9
  unsigned __int64 v2; // x10
  unsigned __int64 v3; // x11
  unsigned __int8 *v4; // x8
  unsigned __int64 v6; // x9
  bool v7; // w12
  __int64 v8; // x11
  unsigned __int64 v9; // x9
  _BYTE *i; // x8
  unsigned int v11; // w12
  char v13; // w11
  int v14; // t1
  unsigned int v15; // t1

  v1 = *(unsigned __int8 *)(a1 + 24);
  v2 = *(_QWORD *)(a1 + 32);
  if ( (v1 & 1) == 0 )
    v2 = v1 >> 1;
  if ( !v2 )
    return 0LL;
  v3 = v2 - 1;
  if ( (v1 & 1) != 0 )
    v4 = *(unsigned __int8 **)(a1 + 40);
  else
    v4 = (unsigned __int8 *)(a1 + 25);
  if ( v2 == 1 || v2 + 4 <= v3 )
    goto LABEL_30;
  if ( (unsigned int)v4[v3] - 48 > 9 )
  {
    v7 = 0;
    v6 = v2 - 1;
  }
  else
  {
    v6 = v2 - 2;
    v7 = v2 == 2;
    if ( v2 != 2 && v2 + 3 > v3 )
    {
      if ( (unsigned int)v4[v6] - 48 > 9 )
        goto LABEL_28;
      v6 = v2 - 3;
      v7 = v2 == 3;
      if ( v2 != 3 && v2 + 2 > v3 )
      {
        if ( (unsigned int)v4[v6] - 48 > 9 )
          goto LABEL_28;
        v6 = v2 - 4;
        v7 = v2 == 4;
        if ( v2 != 4 && v2 + 1 > v3 )
        {
          if ( (unsigned int)v4[v6] - 48 > 9 )
            goto LABEL_28;
          v6 = v2 - 5;
          v7 = v2 == 5;
          if ( v2 != 5 )
          {
            if ( (unsigned int)v4[v6] - 48 <= 9 )
            {
              v6 = v2 - 6;
              if ( v2 == 6 )
                goto LABEL_30;
            }
            goto LABEL_28;
          }
        }
      }
    }
  }
  if ( v7 )
  {
LABEL_30:
    v6 = v2;
    goto LABEL_31;
  }
LABEL_28:
  if ( v6 == v3 || v4[v6] != 58 )
    goto LABEL_30;
LABEL_31:
  v8 = *v4;
  if ( v8 != 91 || v4[v6 - 1] != 93 )
  {
    if ( v6 )
    {
      while ( 1 )
      {
        v13 = byte_1713460[v8];
        if ( (v13 & 7) == 0 )
          break;
        if ( (v13 & 2) != 0 )
        {
          if ( v6 < 3 )
            return 0LL;
          v14 = v4[2];
          v4 += 2;
          if ( ((unsigned __int8)byte_1713460[*(v4 - 1)] & (unsigned __int8)byte_1713460[v14] & 8) == 0 )
            return 0LL;
          v6 -= 2LL;
        }
        if ( !--v6 )
          return 1LL;
        v15 = *++v4;
        v8 = v15;
      }
    }
    return 0LL;
  }
  v9 = v6 - 2;
  for ( i = v4 + 1; ; ++i )
  {
    if ( (unsigned __int8)(*i - 48) >= 0xAu )
    {
      v11 = (unsigned __int8)*i - 46;
      if ( v11 > 0x38 || ((1LL << v11) & 0x1F8000001F81001LL) == 0 )
        break;
    }
    --v9;
  }
  return v9 == 0;
}


================================================================================
Function: sub_6590C18 (0x6590C18)
================================================================================

bool __fastcall sub_6590C18(unsigned __int8 *a1)
{
  unsigned __int64 v1; // x10
  unsigned __int64 v3; // x8
  int v4; // w9
  unsigned __int64 v5; // x10
  unsigned __int64 v6; // x11
  unsigned __int64 v7; // x10

  v1 = *a1;
  v3 = *((_QWORD *)a1 + 1);
  v4 = v1 & 1;
  v5 = v1 >> 1;
  if ( v4 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v5;
  if ( v6 == 4 )
  {
    if ( !(unsigned int)sub_684A118(a1, 0LL, 0xFFFFFFFFFFFFFFFFLL, "http", 4uLL) )
      return 1LL;
    v7 = *a1;
    v3 = *((_QWORD *)a1 + 1);
    v4 = v7 & 1;
    v5 = v7 >> 1;
  }
  if ( !v4 )
    v3 = v5;
  return v3 == 5 && (unsigned int)sub_684A118(a1, 0LL, 0xFFFFFFFFFFFFFFFFLL, "https", 5uLL) == 0;
}


================================================================================
Function: sub_6590CCC (0x6590CCC)
================================================================================

bool __fastcall sub_6590CCC(unsigned __int8 *a1)
{
  unsigned __int64 v1; // x10
  unsigned __int64 v3; // x8
  int v4; // w9
  unsigned __int64 v5; // x10
  unsigned __int64 v6; // x11
  unsigned __int64 v7; // x10

  v1 = *a1;
  v3 = *((_QWORD *)a1 + 1);
  v4 = v1 & 1;
  v5 = v1 >> 1;
  if ( v4 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v5;
  if ( v6 == 2 )
  {
    if ( !(unsigned int)sub_684A118(a1, 0LL, 0xFFFFFFFFFFFFFFFFLL, "ws", 2uLL) )
      return 1LL;
    v7 = *a1;
    v3 = *((_QWORD *)a1 + 1);
    v4 = v7 & 1;
    v5 = v7 >> 1;
  }
  if ( !v4 )
    v3 = v5;
  return v3 == 3 && (unsigned int)sub_684A118(a1, 0LL, 0xFFFFFFFFFFFFFFFFLL, "wss", 3uLL) == 0;
}


================================================================================
Function: sub_6590DA0 (0x6590DA0)
================================================================================

bool __fastcall sub_6590DA0(__int64 a1, __int64 a2)
{
  __int64 v3; // x21
  __int64 v4; // x22
  unsigned __int8 *v5; // x1
  unsigned __int8 *v6; // x19
  __int64 v7; // x9
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  unsigned __int8 *v11; // x8
  int v12; // w10
  unsigned __int8 *v13; // x9
  int v14; // w10
  unsigned __int8 *v15; // x9
  _BOOL8 result; // x0
  int v17; // t1
  __int64 v18; // [xsp+8h] [xbp-18h] BYREF
  __int64 v19; // [xsp+10h] [xbp-10h] BYREF

  v3 = a1 + 24;
  v19 = a2;
  sub_683B7A0(&v18);
  v4 = sub_6590EF4(v3, &v19, &v18);
  v6 = v5;
  sub_683B844(&v18);
  v7 = *(_QWORD *)(a1 + 40);
  v8 = *(unsigned __int8 *)(a1 + 24);
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v7 = v3 + 1;
  if ( !v9 )
    v10 = *(_QWORD *)(a1 + 32);
  v11 = (unsigned __int8 *)(v7 + v10);
  if ( v11 == (unsigned __int8 *)v4 || v7 != v4 && *(_BYTE *)(v4 - 1) != 46 )
    return 0LL;
  if ( v11 == v6 )
    return 1LL;
  v12 = *v6;
  if ( v12 == 46 )
  {
    v13 = v6 + 1;
    if ( v6 + 1 != v11 )
    {
      v14 = *v13;
      if ( v14 != 46 )
        goto LABEL_15;
      v13 = v6 + 2;
      if ( v6 + 2 != v11 )
      {
        v14 = *v13;
LABEL_15:
        if ( v14 == 58 )
          goto LABEL_16;
        return 0LL;
      }
    }
    return 1LL;
  }
  v13 = v6;
  if ( v12 != 58 )
    return 0LL;
LABEL_16:
  v15 = v13 + 1;
  do
  {
    result = v15 == v11;
    if ( v15 == v11 )
      break;
    v17 = *v15++;
  }
  while ( (unsigned int)(v17 - 58) > 0xFFFFFFF5 );
  return result;
}


================================================================================
Function: sub_6590EF4 (0x6590EF4)
================================================================================

unsigned __int8 *__fastcall sub_6590EF4(unsigned __int8 *a1, const char **a2, __int64 *a3)
{
  const char *v5; // x21
  const char *v6; // x22
  __int64 v7; // x2
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x12
  const char *v11; // x8
  unsigned __int8 *v12; // x24
  unsigned __int64 v13; // x9
  unsigned __int8 *v14; // x9
  __int64 v15; // x27
  unsigned __int8 *v16; // x25
  unsigned __int8 *v17; // x20
  const char *v18; // x28
  __int64 v19; // x26
  unsigned int v20; // w22
  __int64 *v21; // x0
  char v22; // w0
  unsigned int v23; // w23
  __int64 v24; // x2
  __int64 *v25; // x0
  __int64 v26; // x9
  const char *v27; // x10
  unsigned __int8 *v29; // [xsp+8h] [xbp-38h]
  __int64 v30; // [xsp+10h] [xbp-30h] BYREF
  const char *v31; // [xsp+18h] [xbp-28h]
  const char *v32; // [xsp+20h] [xbp-20h]
  __int64 v33; // [xsp+28h] [xbp-18h] BYREF
  __int64 v34; // [xsp+30h] [xbp-10h] BYREF

  sub_683B82C(&v30, a3);
  v5 = *a2;
  v6 = &v5[__strlen_chk(*a2, 0xFFFFFFFFFFFFFFFFLL)];
  sub_683B82C(&v34, &v30);
  v31 = v5;
  v32 = v6;
  sub_683B82C(&v33, &v34);
  sub_683B844(&v34);
  v8 = *a1;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  v11 = v32;
  if ( v9 )
    v12 = a1 + 1;
  else
    v12 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( v9 )
    v13 = v10;
  else
    v13 = *((_QWORD *)a1 + 1);
  v14 = &v12[v13];
  if ( v31 != v32 )
  {
    v15 = 0LL;
    v16 = v14;
    v29 = v14;
    while ( v16 != v12 )
    {
      v17 = v16--;
      v18 = v31;
      if ( v16 != v14 && v31 != v11 )
      {
        v19 = 0LL;
        while ( 1 )
        {
          v20 = v17[v19 - 1];
          v21 = sub_683BBD0(&v33, (__int64)&qword_79D7E58, v7);
          v22 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*v21 + 24))(v21, v20);
          v23 = (unsigned __int8)v18[v19];
          LOBYTE(v20) = v22;
          v25 = sub_683BBD0(&v33, (__int64)&qword_79D7E58, v24);
          if ( (unsigned __int8)v20 != (*(unsigned __int8 (__fastcall **)(__int64 *, _QWORD))(*v25 + 24))(v25, v23) )
            break;
          v11 = v32;
          v26 = v19 + 1;
          if ( v15 != v19 )
          {
            v27 = &v18[v19++];
            if ( v27 + 1 != v32 )
              continue;
          }
          v18 += v26;
          goto LABEL_19;
        }
        v11 = v32;
        v18 += v19;
LABEL_19:
        v14 = v29;
      }
      ++v15;
      if ( v18 == v11 )
        goto LABEL_21;
    }
  }
  v16 = v14;
LABEL_21:
  sub_683B844(&v33);
  sub_683B844(&v30);
  return v16;
}


================================================================================
Function: sub_6591534 (0x6591534)
================================================================================

_QWORD *__fastcall sub_6591534(_QWORD *result, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v4; // x19
  _QWORD *v5; // x20
  unsigned __int64 v6; // x23
  unsigned __int64 v7; // x8
  unsigned __int8 *v8; // x11
  unsigned int v9; // w12
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x1
  char v13; // w9
  char s[4]; // [xsp+4h] [xbp-Ch] BYREF

  v4 = a2;
  v5 = result;
  v6 = (unsigned __int64)&a2[a3];
  v7 = a3;
  strcpy(s, "%00");
  if ( a3 > 4096 )
  {
    v8 = a2;
    v7 = a3;
    do
    {
      v9 = *v8;
      if ( v9 < 0x30 || v9 - 58 <= 0x26 && ((1LL << ((unsigned __int8)v9 - 58)) & 0x7E0000007FLL) != 0 || v9 >= 0x7B )
        v7 += 2LL;
      ++v8;
    }
    while ( (unsigned __int64)v8 < v6 );
  }
  v10 = *(unsigned __int8 *)result;
  if ( (v10 & 1) != 0 )
    v11 = result[1];
  else
    v11 = v10 >> 1;
  if ( v7 < ~v11 )
  {
    result = (_QWORD *)sub_6601820(result, v11 + v7);
    if ( a3 >= 1 )
    {
      do
      {
        v12 = *v4;
        if ( v12 < 0x30
          || (unsigned int)(v12 - 58) <= 0x26 && ((1LL << ((unsigned __int8)v12 - 58)) & 0x7E0000007FLL) != 0
          || (unsigned int)v12 >= 0x7B )
        {
          v13 = a0123456789abcd[v12 & 0xF];
          s[1] = a0123456789abcd[v12 >> 4];
          s[2] = v13;
          result = sub_684A544(v5, s);
        }
        else
        {
          result = (_QWORD *)sub_6601588(v5, v12);
        }
        ++v4;
      }
      while ( (unsigned __int64)v4 < v6 );
    }
  }
  return result;
}


================================================================================
Function: sub_659193C (0x659193C)
================================================================================

__int64 __fastcall sub_659193C(unsigned __int8 *a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x21
  unsigned __int64 *v9; // x0
  int v10; // w1
  unsigned __int8 *v11; // x23
  int v12; // w9
  int v13; // w8
  int v14; // w10
  int v15; // w9
  bool v16; // zf
  int v17; // w8
  int v18; // w1

  v3 = *(unsigned __int8 *)a3;
  if ( (v3 & 1) != 0 )
    v7 = a3[1];
  else
    v7 = v3 >> 1;
  sub_6601820(a3, v7 + a2);
  if ( a2 < 1 )
    return 1LL;
  v8 = (unsigned __int64)&a1[a2];
  while ( 1 )
  {
    while ( 1 )
    {
      v10 = *a1;
      if ( v10 == 43 )
      {
        v9 = a3;
        LOBYTE(v10) = 32;
        goto LABEL_7;
      }
      if ( v10 == 37 )
        break;
      v9 = a3;
LABEL_7:
      sub_6601588(v9, v10);
      if ( (unsigned __int64)++a1 >= v8 )
        return 1LL;
    }
    v11 = a1 + 3;
    if ( (unsigned __int64)(a1 + 3) > v8 )
      return 0LL;
    v12 = a1[1];
    v13 = v12 - 48;
    if ( (unsigned int)(v12 - 48) > 9 )
    {
      if ( (v12 | 0x20u) - 97 > 5 )
        v13 = -1;
      else
        v13 = (v12 | 0x20) - 87;
    }
    v14 = a1[2];
    v15 = v14 - 48;
    if ( (unsigned int)(v14 - 48) > 9 )
    {
      if ( (v14 | 0x20u) - 97 > 5 )
        v15 = -1;
      else
        v15 = (v14 | 0x20) - 87;
    }
    v16 = v15 == -1 || v13 == -1;
    v17 = v15 + 16 * v13;
    v18 = v16 ? -1 : v17;
    if ( v18 < 0 )
      return 0LL;
    sub_6601588(a3, v18);
    a1 += 3;
    if ( (unsigned __int64)v11 >= v8 )
      return 1LL;
  }
}


================================================================================
Function: sub_6591A70 (0x6591A70)
================================================================================

__int64 __usercall sub_6591A70@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  return sub_6591AB4(a2, a1 + 72);
}


================================================================================
Function: sub_6591AB4 (0x6591AB4)
================================================================================

_BYTE *__fastcall sub_6591AB4(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int64 v3; // x8
  bool v4; // zf
  __int64 v5; // x8
  _BYTE *result; // x0
  _BYTE *v7; // x22
  _BYTE *v8; // x23
  __int64 v9; // x24
  _BOOL4 v10; // w26
  _BYTE *v11; // x25
  _BYTE *v12; // x10
  __int64 v13; // x9
  _BYTE *v14; // x8
  __int64 v15; // x8
  _BYTE *v16; // x8
  _BYTE *v17; // x20
  unsigned __int64 v18; // x8
  __int128 v19; // q0
  __int64 v20; // x9
  __int128 v21; // [xsp+8h] [xbp-38h] BYREF
  __int64 v22; // [xsp+18h] [xbp-28h]
  __int128 v23; // [xsp+20h] [xbp-20h] BYREF
  __int64 v24; // [xsp+30h] [xbp-10h]

  v3 = *a2;
  v4 = (v3 & 1) == 0;
  v5 = v3 >> 1;
  if ( v4 )
    result = a2 + 1;
  else
    result = (_BYTE *)*((_QWORD *)a2 + 2);
  if ( !v4 )
    v5 = *((_QWORD *)a2 + 1);
  if ( v5 >= 1 )
  {
    v7 = &result[v5];
    v8 = &result[v5];
    v9 = (__int64)&result[v5 - 1];
    do
    {
      if ( result >= v8 )
      {
        v10 = 0;
      }
      else
      {
        if ( *result != 38 )
        {
          v12 = result + 1;
          v13 = v9 - (_QWORD)result;
          while ( 1 )
          {
            v14 = v12;
            if ( !v13 )
              break;
            --v13;
            ++v12;
            if ( *v14 == 38 )
            {
              v11 = v14;
              goto LABEL_22;
            }
          }
          v11 = v7;
LABEL_22:
          v10 = v14 < v8;
          if ( result < v11 )
          {
            v15 = 0LL;
            do
            {
              if ( result[v15] == 61 )
              {
                v16 = &result[v15];
                v17 = v16 + 1;
                if ( result == v16 )
                  goto LABEL_27;
                goto LABEL_29;
              }
              ++v15;
            }
            while ( v11 - result != v15 );
            v16 = v11;
            v17 = v11;
            if ( result == v11 )
            {
LABEL_27:
              v23 = 0uLL;
              v24 = 0LL;
              goto LABEL_30;
            }
LABEL_29:
            v23 = 0uLL;
            v24 = 0LL;
            sub_659193C(result, v16 - result, &v23);
LABEL_30:
            v21 = 0uLL;
            v22 = 0LL;
            if ( v17 != v11 )
              sub_659193C(v17, v11 - v17, &v21);
            v18 = *(_QWORD *)(a1 + 8);
            if ( v18 >= *(_QWORD *)(a1 + 16) )
            {
              sub_62615EC(a1, &v23, &v21);
              if ( (v21 & 1) != 0 )
                sub_65ECAF4();
            }
            else
            {
              v19 = v23;
              *(_QWORD *)(v18 + 16) = v24;
              *(_OWORD *)v18 = v19;
              v24 = 0LL;
              v20 = v22;
              v23 = 0uLL;
              *(_OWORD *)(v18 + 24) = v21;
              *(_QWORD *)(v18 + 40) = v20;
              *(_QWORD *)(a1 + 8) = v18 + 48;
            }
            if ( (v23 & 1) != 0 )
              sub_65ECAF4();
          }
          goto LABEL_8;
        }
        v10 = 1;
      }
      v11 = result;
LABEL_8:
      if ( v10 )
        result = v11 + 1;
      else
        result = v8;
    }
    while ( result < v8 );
  }
  return result;
}


================================================================================
Function: sub_6593970 (0x6593970)
================================================================================

_QWORD *__fastcall sub_6593970(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6)
{
  __int64 v11; // x19
  _QWORD *result; // x0
  _QWORD *v13; // x22
  _QWORD *i; // x23
  bool v15; // zf
  __int64 v16; // x21
  __int64 v17; // x0
  __int64 v18; // x8
  __int64 v19; // x21
  __int64 (__fastcall *v20)(); // [xsp+8h] [xbp-28h] BYREF
  __int64 v21; // [xsp+10h] [xbp-20h] BYREF
  int v22; // [xsp+1Ch] [xbp-14h] BYREF
  __int64 v23; // [xsp+20h] [xbp-10h] BYREF

  v23 = a2;
  v22 = a4;
  *(_QWORD *)(a1 + 8) = a5;
  v11 = a1 + 8;
  *(_QWORD *)a1 = off_6C25BD8;
  result = (_QWORD *)sub_65ECAAC();
  result[2] = 0LL;
  result[3] = a5;
  *(_QWORD *)(a1 + 24) = 0LL;
  *result = off_6C25CC8;
  result[1] = 0LL;
  *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = a6;
  *(_DWORD *)(a1 + 56) = a4;
  if ( a3 )
  {
    result = (_QWORD *)sub_6594A20(a1 + 24, a3);
    v13 = *(_QWORD **)(a1 + 24);
    for ( i = *(_QWORD **)(a1 + 32); v13 != i; result = (_QWORD *)sub_684D7B0(&v21) )
    {
      if ( byte_724A7A8 )
        v15 = byte_7301120 == 0;
      else
        v15 = 1;
      if ( v15 )
      {
        v17 = sub_65ECAAC();
        *(_QWORD *)(v17 + 8) = 0LL;
        *(_QWORD *)(v17 + 16) = 0LL;
        *(_QWORD *)v17 = off_6C25D68;
        *(_OWORD *)(v17 + 40) = 0u;
        *(_OWORD *)(v17 + 56) = 0u;
        *(_OWORD *)(v17 + 72) = 0u;
        *(_OWORD *)(v17 + 88) = 0u;
        *(_OWORD *)(v17 + 100) = 0u;
        *(_OWORD *)(v17 + 24) = 0u;
        v18 = v17 + 24;
      }
      else
      {
        v16 = sub_680599C();
        v17 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v16 + 16LL))(v16, 128LL, 8LL);
        *(_QWORD *)v17 = off_6C25D18;
        *(_QWORD *)(v17 + 8) = 0LL;
        *(_QWORD *)(v17 + 16) = 0LL;
        *(_QWORD *)(v17 + 24) = v16;
        *(_OWORD *)(v17 + 48) = 0u;
        *(_OWORD *)(v17 + 64) = 0u;
        *(_OWORD *)(v17 + 80) = 0u;
        *(_OWORD *)(v17 + 96) = 0u;
        *(_OWORD *)(v17 + 108) = 0u;
        *(_OWORD *)(v17 + 32) = 0u;
        v18 = v17 + 32;
      }
      v19 = v13[2];
      v13[1] = v18;
      v13[2] = v17;
      if ( v19 && !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v19 + 8)) )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16LL))(v19);
        sub_68488BC((unsigned __int64 *)v19);
      }
      v20 = sub_6593BC4;
      sub_6593E30(&v21, &v20, &v23, v11, v13 + 1, &v22);
      if ( *v13 )
        sub_68629B8();
      *v13 = v21;
      v13 += 3;
      v21 = 0LL;
    }
  }
  return result;
}


================================================================================
Function: sub_6593E30 (0x6593E30)
================================================================================

__int64 __fastcall sub_6593E30(pthread_t *a1, __int64 *a2, __int64 *a3, __int64 *a4, _QWORD *a5, int *a6)
{
  __int64 v12; // x22
  __int64 v13; // x0
  __int64 v14; // x24
  __int64 v15; // x28
  _QWORD *v16; // x19
  __int64 v17; // x26
  __int64 v18; // x25
  __int64 v19; // x23
  __int64 v20; // x27
  _QWORD *v21; // t2
  int v22; // w8
  __int64 result; // x0

  v12 = sub_65ECAAC();
  sub_684DAE4();
  v13 = sub_65ECAAC();
  v15 = *a4;
  v14 = a4[1];
  v16 = (_QWORD *)v13;
  v17 = *a2;
  v18 = *a3;
  if ( v14 )
    sub_6867420(1uLL, (atomic_ullong *)(v14 + 8));
  v21 = a5;
  v19 = *a5;
  v20 = v21[1];
  if ( v20 )
    sub_6867420(1uLL, (atomic_ullong *)(v20 + 8));
  v22 = *a6;
  *v16 = v12;
  v16[1] = v17;
  v16[2] = v18;
  v16[3] = v15;
  v16[4] = v14;
  v16[5] = v19;
  v16[6] = v20;
  *((_DWORD *)v16 + 14) = v22;
  result = pthread_create(a1, 0LL, (void *(*)(void *))sub_6594DD0, v16);
  if ( (_DWORD)result )
    sub_684D644(result, "thread constructor failed");
  return result;
}


================================================================================
Function: sub_659409C (0x659409C)
================================================================================

__int64 __fastcall sub_659409C(_QWORD *a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5)
{
  __int64 v10; // x24
  __int64 result; // x0

  v10 = sub_65ECAAC();
  *(_OWORD *)v10 = 0u;
  *(_OWORD *)(v10 + 16) = 0u;
  *(_OWORD *)(v10 + 32) = 0u;
  *(_OWORD *)(v10 + 48) = 0u;
  *(_OWORD *)(v10 + 64) = 0u;
  *(_OWORD *)(v10 + 80) = 0u;
  *(_OWORD *)(v10 + 96) = 0u;
  *(_OWORD *)(v10 + 112) = 0u;
  *(_OWORD *)(v10 + 128) = 0u;
  *(_BYTE *)(v10 + 96) = 0;
  *(_BYTE *)(v10 + 97) = 0;
  *(_QWORD *)v10 = off_6C25C50;
  *(_QWORD *)(v10 + 104) = sub_65EE9A8(0x180uLL);
  *(_QWORD *)(v10 + 112) = 8LL;
  *(_QWORD *)(v10 + 120) = 0LL;
  *(_QWORD *)(v10 + 128) = 0LL;
  *(_BYTE *)(v10 + 136) = 0;
  result = sub_6593970(a1, a2, a3, a4, v10, a5);
  *a1 = off_6C25BF8;
  return result;
}


================================================================================
Function: sub_6594154 (0x6594154)
================================================================================

__int64 __fastcall sub_6594154(__int64 a1, __int64 a2)
{
  char v4; // w19
  pthread_mutex_t *v5; // x21
  __int64 v6; // x8

  v4 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 8) + 16LL))(*(_QWORD *)(a1 + 8), a1);
  if ( (v4 & 1) != 0 )
  {
    sub_65941D8(*(_QWORD *)(a1 + 8) + 104LL, a2);
    v5 = (pthread_mutex_t *)(*(_QWORD *)(a1 + 8) + 56LL);
    sub_6848980(v5);
    v6 = *(_QWORD *)(a1 + 8);
    *(_BYTE *)(v6 + 97) = 1;
    sub_6819D84(v6 + 8);
    sub_68489D4(v5);
  }
  return v4 & 1;
}


================================================================================
Function: sub_65941D8 (0x65941D8)
================================================================================

__int64 __fastcall sub_65941D8(__int64 a1, __int64 a2)
{
  int v4; // w22
  int v5; // w23
  __int64 v6; // x0
  __int64 v7; // x9
  __int64 result; // x0
  __int64 v9; // x8
  _BYTE v10[32]; // [xsp+0h] [xbp-40h] BYREF
  _BYTE *v11; // [xsp+20h] [xbp-20h]
  __int64 v12; // [xsp+30h] [xbp-10h] BYREF

  if ( dword_6CA9418 <= 1 )
    v4 = 1;
  else
    v4 = dword_6CA9418;
LABEL_4:
  v5 = v4;
  while ( (sub_6867150(1LL, a1 + 32) & 1) != 0 )
  {
    if ( !--v5 )
      goto LABEL_4;
  }
  v6 = *(_QWORD *)(a2 + 32);
  if ( !v6 )
    goto LABEL_11;
  if ( a2 != v6 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
LABEL_11:
    v11 = (_BYTE *)v6;
    goto LABEL_13;
  }
  v7 = *(_QWORD *)v6;
  v11 = v10;
  (*(void (__fastcall **)(__int64, _BYTE *))(v7 + 24))(v6, v10);
LABEL_13:
  sub_5247D84(a1, v10, &v12);
  result = (__int64)v11;
  if ( v10 == v11 )
  {
    v9 = 4LL;
    goto LABEL_17;
  }
  if ( v11 )
  {
    v9 = 5LL;
LABEL_17:
    result = (*(__int64 (**)(void))(*(_QWORD *)v11 + 8 * v9))();
  }
  atomic_store(0, (unsigned __int8 *)(a1 + 32));
  return result;
}


================================================================================
Function: sub_6594A20 (0x6594A20)
================================================================================

char **__fastcall sub_6594A20(char **result, unsigned __int64 a2)
{
  char *v2; // x8
  char *v3; // x19
  char **v4; // x20
  char *v6; // x23
  unsigned __int64 v7; // x22
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x25
  __int64 v11; // x0
  size_t v12; // x21
  __int64 v13; // x9
  char *v14; // x21
  unsigned __int64 v15; // x24
  size_t v16; // x22
  char *v17; // x8
  __int64 v18; // x9
  char *v19; // x10
  char *v20; // x11
  char *v21; // x9
  char *v22; // x19
  char *v23; // x21
  __int64 v24; // x20

  v3 = result[1];
  v2 = result[2];
  v4 = result;
  if ( 0xAAAAAAAAAAAAAAABLL * ((v2 - v3) >> 3) >= a2 )
  {
    if ( a2 )
    {
      v12 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      result = (char **)memset(result[1], 0, v12);
      v3 += v12;
    }
    v4[1] = v3;
  }
  else
  {
    v6 = *result;
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *result) >> 3);
    v8 = v7 + a2;
    if ( v7 + a2 > 0xAAAAAAAAAAAAAAALL )
      sub_684DBEC();
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v2 - v6) >> 3);
    if ( 2 * v9 >= v8 )
      v8 = 2 * v9;
    if ( v9 >= 0x555555555555555LL )
      v10 = 0xAAAAAAAAAAAAAAALL;
    else
      v10 = v8;
    if ( v10 )
    {
      if ( v10 > 0xAAAAAAAAAAAAAAALL )
        sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v11 = sub_65ECAAC();
    }
    else
    {
      v11 = 0LL;
    }
    v13 = 24 * a2;
    v15 = v11 + 24 * v10;
    v14 = (char *)(v11 + 24 * v7);
    v16 = 24 * ((v13 - 24) / 0x18uLL) + 24;
    result = (char **)memset(v14, 0, v16);
    v17 = &v14[v16];
    if ( v3 == v6 )
    {
      *v4 = v14;
      v4[1] = v17;
      v4[2] = (char *)v15;
      if ( v3 )
        return (char **)sub_65ECAF4();
    }
    else
    {
      v18 = 0LL;
      do
      {
        v19 = &v3[v18];
        v20 = &v14[v18];
        v18 -= 24LL;
        *(_OWORD *)(v20 - 24) = *(_OWORD *)(v19 - 24);
        *((_QWORD *)v20 - 1) = *((_QWORD *)v19 - 1);
        *((_QWORD *)v19 - 3) = 0LL;
        *((_QWORD *)v19 - 2) = 0LL;
        *((_QWORD *)v19 - 1) = 0LL;
      }
      while ( &v3[v18] != v6 );
      v21 = &v14[v18];
      v4[2] = (char *)v15;
      v22 = *v4;
      v23 = v4[1];
      *v4 = v21;
      for ( v4[1] = v17; v23 != v22; result = (char **)sub_684D7B0(v23) )
      {
        v24 = *((_QWORD *)v23 - 1);
        v23 -= 24;
        if ( v24 )
        {
          if ( !sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8)) )
          {
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 16LL))(v24);
            sub_68488BC((unsigned __int64 *)v24);
          }
        }
      }
      if ( v22 )
        return (char **)sub_65ECAF4();
    }
  }
  return result;
}


================================================================================
Function: sub_65ADA20 (0x65ADA20)
================================================================================

__int64 __usercall sub_65ADA20@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  __int64 result; // x0

  result = qword_7248240;
  if ( qword_7248240 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_7248240 + 48LL))(qword_7248240, a1);
  *a2 = 0LL;
  a2[1] = 0LL;
  return result;
}


================================================================================
Function: sub_65ADBD0 (0x65ADBD0)
================================================================================

__int64 __usercall sub_65ADBD0@<X0>(_QWORD *a1@<X8>)
{
  __int64 result; // x0

  result = qword_72482A0;
  if ( qword_72482A0 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_72482A0 + 48LL))(qword_72482A0);
  *a1 = 0LL;
  a1[1] = 0LL;
  return result;
}


================================================================================
Function: sub_65AF224 (0x65AF224)
================================================================================

__int64 __usercall sub_65AF224@<X0>(char a1@<W0>, int a2@<W1>, char *a3@<X2>, unsigned __int64 *a4@<X8>)
{
  __int64 result; // x0
  unsigned __int64 v9[2]; // [xsp+8h] [xbp-38h] BYREF
  __int128 v10; // [xsp+20h] [xbp-20h] BYREF

  sub_68497A0((unsigned __int64 *)&v10, &xmmword_72484D0);
  switch ( a2 )
  {
    case 0:
      sub_67DABB8((int)&v10, "appData");
      break;
    case 1:
      sub_67DABB8((int)&v10, "picture");
      break;
    case 2:
      sub_67DABB8((int)&v10, "video");
      break;
    case 3:
      sub_67DABB8((int)&v10, "exe");
      break;
    case 4:
      sub_68497A0(v9, &xmmword_72484E8);
      sub_684A438((unsigned __int8 *)&v10, (unsigned __int8 *)v9);
      if ( (v9[0] & 1) != 0 )
        sub_65ECAF4();
      break;
    default:
      break;
  }
  if ( a3 )
    sub_67DABB8((int)&v10, a3);
  LODWORD(v9[0]) = 0;
  v9[1] = (unsigned __int64)sub_67DDA30();
  if ( (a1 & 1) == 0 || (sub_65D5F48(&v10, v9) & 1) != 0 || (result = sub_65D5FE4(&v10, v9), (result & 1) != 0) )
  {
    result = (__int64)sub_68497A0(a4, &v10);
    if ( (v10 & 1) == 0 )
      return result;
  }
  else
  {
    *(_WORD *)a4 = 0;
    if ( (v10 & 1) == 0 )
      return result;
  }
  return sub_65ECAF4();
}


================================================================================
Function: sub_65B03C8 (0x65B03C8)
================================================================================

void __usercall sub_65B03C8(__int64 a1@<X8>)
{
  *(_BYTE *)a1 = 6;
  *(_DWORD *)(a1 + 1) = 5067329;
}


================================================================================
Function: sub_65B0534 (0x65B0534)
================================================================================

__int64 sub_65B0534()
{
  return sysconf(96);
}


================================================================================
Function: sub_65B0550 (0x65B0550)
================================================================================

__int64 sub_65B0550()
{
  return sysconf(96);
}


================================================================================
Function: sub_65B0568 (0x65B0568)
================================================================================

__int64 sub_65B0568()
{
  return sysconf(96);
}


================================================================================
Function: sub_65B058C (0x65B058C)
================================================================================

__int64 sub_65B058C()
{
  return 1LL;
}


================================================================================
Function: sub_65B0A90 (0x65B0A90)
================================================================================

__int64 sub_65B0A90()
{
  return dword_6CA9228;
}


================================================================================
Function: sub_65B0B0C (0x65B0B0C)
================================================================================

void __usercall sub_65B0B0C(_BYTE *a1@<X8>)
{
  *a1 = 14;
  strcpy(a1 + 1, "Android");
}


================================================================================
Function: sub_65B0B34 (0x65B0B34)
================================================================================

void __usercall sub_65B0B34(_BYTE *a1@<X8>)
{
  *a1 = 14;
  strcpy(a1 + 1, "Android");
}


================================================================================
Function: sub_65B0B5C (0x65B0B5C)
================================================================================

__int64 sub_65B0B5C()
{
  return 23LL;
}


================================================================================
Function: sub_65B0B64 (0x65B0B64)
================================================================================

unsigned __int64 *__usercall sub_65B0B64@<X0>(unsigned __int64 *a1@<X8>)
{
  return sub_68497A0(a1, &xmmword_7248578);
}


================================================================================
Function: sub_65B0DD8 (0x65B0DD8)
================================================================================

unsigned __int64 *__usercall sub_65B0DD8@<X0>(unsigned __int64 *a1@<X8>)
{
  return sub_68497A0(a1, &xmmword_7248590);
}


================================================================================
Function: sub_65B0E80 (0x65B0E80)
================================================================================

unsigned __int64 *__usercall sub_65B0E80@<X0>(unsigned __int64 *a1@<X8>)
{
  return sub_68497A0(a1, &xmmword_72485A8);
}


================================================================================
Function: sub_65B0E90 (0x65B0E90)
================================================================================

void __usercall sub_65B0E90(_BYTE *a1@<X8>)
{
  *a1 = 14;
  strcpy(a1 + 1, "Android");
}


================================================================================
Function: sub_65B6B3C (0x65B6B3C)
================================================================================

__int64 __fastcall sub_65B6B3C(unsigned int a1)
{
  __int64 v2; // x0

  v2 = sub_65B80B8();
  if ( v2 )
    return sub_65B80E0(v2, a1);
  if ( qword_6CBB0B0 )
  {
    if ( *(_QWORD *)(qword_6CBB0B0 + 48) )
      JUMPOUT(0x65B6BD8LL);
  }
  return sub_65B737C(&unk_7248980, a1);
}


================================================================================
Function: sub_65B6BB0 (0x65B6BB0)
================================================================================

__int64 __fastcall sub_65B6BB0(unsigned int a1)
{
  __int64 v1; // x1
  __int64 v2; // x0
  __int64 v4; // x19
  __int64 v5; // x22
  unsigned int v6; // w20
  __int64 v7; // x0

  v1 = a1;
  if ( !qword_6CBB0B0 )
    return sub_65B737C(&unk_7248980, v1);
  v2 = *(_QWORD *)(qword_6CBB0B0 + 48);
  if ( !v2 )
    return sub_65B737C(&unk_7248980, v1);
  v4 = v2 + 24;
  v5 = *(_QWORD *)(qword_6CBB0B0 + 48);
  v6 = v1;
  sub_25C5EF4(v2 + 24);
  v7 = *(_QWORD *)(v5 + 16);
  if ( v7 )
    sub_65B80E0(v7, v6);
  else
    sub_65B737C(&unk_7248980, v6);
  return sub_25C7AF8(v4);
}


================================================================================
Function: sub_65B737C (0x65B737C)
================================================================================

__int64 __usercall sub_65B737C@<X0>(__int64 *a1@<X0>, int a2@<W1>, unsigned __int64 *a3@<X8>)
{
  __int64 *v3; // x19
  int v7; // w8
  unsigned int v8; // w10
  __int64 v9; // x8
  __int64 v10; // x9
  int v11; // w11
  int v12; // w12
  int v13; // w8

  v3 = a1 + 3;
  sub_25C5EF4(a1 + 3);
  v7 = *((_DWORD *)a1 + 4);
  if ( !v7 )
  {
LABEL_8:
    *a3 = 0LL;
    a3[1] = 0LL;
    a3[2] = 0LL;
    return sub_25C7AF8(v3);
  }
  v8 = v7 - 1;
  v9 = (v7 - 1) & (unsigned int)(37 * a2);
  v10 = *a1;
  v11 = *(_DWORD *)(*a1 + 32 * v9);
  if ( v11 != a2 )
  {
    v12 = 1;
    while ( v11 != -1 )
    {
      v13 = v9 + v12++;
      v9 = v13 & v8;
      v11 = *(_DWORD *)(v10 + 32 * v9);
      if ( v11 == a2 )
        goto LABEL_3;
    }
    goto LABEL_8;
  }
LABEL_3:
  sub_68497A0(a3, (__int128 *)(v10 + 32 * v9 + 8));
  return sub_25C7AF8(v3);
}


================================================================================
Function: sub_65B80B8 (0x65B80B8)
================================================================================

// attributes: thunk
__int64 sub_65B80B8(void)
{
  return sub_65B8BAC();
}


================================================================================
Function: sub_65B80E0 (0x65B80E0)
================================================================================

__int64 __fastcall sub_65B80E0(__int64 a1, __int64 a2)
{
  return sub_65B737C(a1 + 96, a2);
}


================================================================================
Function: sub_65B8BAC (0x65B8BAC)
================================================================================

__int64 sub_65B8BAC()
{
  return *(_QWORD *)sub_65FAAE0((__int64)&qword_7248BB0);
}


================================================================================
Function: sub_65C1D80 (0x65C1D80)
================================================================================

__int64 __fastcall sub_65C1D80(__int64 a1)
{
  return a1 + 80;
}


================================================================================
Function: sub_65C1D88 (0x65C1D88)
================================================================================

__int128 *sub_65C1D88()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_7248F80);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_7248F80) )
  {
    qword_7248F78 = 0LL;
    xmmword_7248F58 = 0u;
    unk_7248F68 = 0u;
    xmmword_7248F38 = 0u;
    unk_7248F48 = 0u;
    xmmword_7248F18 = 0u;
    unk_7248F28 = 0u;
    xmmword_7248EF8 = 0u;
    unk_7248F08 = 0u;
    sub_6862850(byte_7248F80);
  }
  return &xmmword_7248EF8;
}


================================================================================
Function: sub_65C1E08 (0x65C1E08)
================================================================================

__int64 __fastcall sub_65C1E08(__int64 *a1)
{
  __int64 v1; // x19
  _DWORD v3[6]; // [xsp+0h] [xbp-20h] BYREF

  v1 = *a1;
  sub_65FE394(v3, a1 + 1);
  return v1 + v3[0];
}


================================================================================
Function: sub_65C1E64 (0x65C1E64)
================================================================================

__int64 (__fastcall ***__usercall sub_65C1E64@<X0>(
        char a1@<W0>,
        char a2@<W1>,
        __int64 a3@<X2>,
        char a4@<W3>,
        __int64 a5@<X8>))(_QWORD, __int64)
{
  __int64 (__fastcall ***result)(_QWORD, __int64); // x0

  *(_DWORD *)(a5 + 32) = 0;
  *(_QWORD *)(a5 + 16) = 0LL;
  *(_QWORD *)(a5 + 24) = 0LL;
  *(_BYTE *)(a5 + 40) = a1;
  *(_BYTE *)(a5 + 41) = a2;
  *(_BYTE *)(a5 + 42) = 0;
  *(_QWORD *)a5 = a3;
  *(_QWORD *)(a5 + 8) = 0LL;
  result = (__int64 (__fastcall ***)(_QWORD, __int64))sub_65EBF30();
  *(_DWORD *)(a5 + 8) = (_DWORD)result;
  *(_BYTE *)(a5 + 42) = a4;
  if ( byte_7248FCC == 1 && byte_724A7A8 && byte_7248FA8 )
  {
    result = *(__int64 (__fastcall ****)(_QWORD, __int64))sub_65EF3F8();
    if ( result )
      return (__int64 (__fastcall ***)(_QWORD, __int64))(**result)(result, a5);
  }
  return result;
}


================================================================================
Function: sub_65C1EE8 (0x65C1EE8)
================================================================================

__int64 __fastcall sub_65C1EE8(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 result; // x0

  if ( byte_7248FCC != 1 )
    return sub_65C21A0(&unk_7248FD0, a2, 0.0);
  v4 = sub_65C2500();
  result = sub_65C21A0(v4, a2, 0.0);
  if ( byte_724A7A8 && byte_7248FA8 )
  {
    result = *(_QWORD *)sub_65EF3F8(result);
    if ( result )
      return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)result + 8LL))(result, a1, a2);
  }
  return result;
}


================================================================================
Function: sub_65C1F78 (0x65C1F78)
================================================================================

void *sub_65C1F78()
{
  return &unk_7248FD0;
}


================================================================================
Function: sub_65C1F84 (0x65C1F84)
================================================================================

long double __usercall sub_65C1F84@<Q0>(char a1@<W0>, char a2@<W1>, char a3@<W2>, __int64 a4@<X8>)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_DWORD *)(a4 + 32) = 0;
  *(_BYTE *)(a4 + 40) = a1;
  *(_BYTE *)(a4 + 41) = a2;
  *(_BYTE *)(a4 + 42) = a3;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  return result;
}


================================================================================
Function: sub_65C1FA0 (0x65C1FA0)
================================================================================

__int64 __fastcall sub_65C1FA0(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 result; // x0

  if ( byte_7248FCC != 1 )
    return sub_65C2214(&unk_7248FD0, a2, 0.0);
  v4 = sub_65C2500();
  result = sub_65C2214(v4, a2, 0.0);
  if ( byte_724A7A8 && byte_7248FA8 )
  {
    result = *(_QWORD *)sub_65EF3F8(result);
    if ( result )
      return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)result + 24LL))(result, a1, a2);
  }
  return result;
}


================================================================================
Function: sub_65C2030 (0x65C2030)
================================================================================

bool sub_65C2030()
{
  __int64 v0; // x0

  if ( byte_7248FCC != 1 )
    return 0LL;
  v0 = sub_65C1D88();
  return *(_BYTE *)(sub_65C1D80(v0) + 48) != 0;
}


================================================================================
Function: sub_65C21A0 (0x65C21A0)
================================================================================

__int64 __fastcall sub_65C21A0(__int64 result, __int64 a2, double a3)
{
  int v3; // w15
  unsigned int v4; // w11
  unsigned int v5; // w13
  __int64 v6; // x8
  __int64 v7; // x9
  __int64 v8; // x8
  __int64 v9; // x9
  unsigned __int64 v10; // x10
  double v11; // d0
  unsigned int v13; // w10
  unsigned __int64 v14; // x14
  unsigned int v15; // w8

  v3 = *(_DWORD *)(result + 24);
  v4 = *(_DWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 36);
  v6 = *(_QWORD *)(result + 8);
  v7 = *(_QWORD *)(result + 16);
  ++*(_DWORD *)result;
  v8 = v6 + a2;
  v9 = v8 - v7;
  v10 = (unsigned __int64)(v9 - 1) >> 4;
  *(_QWORD *)(result + 8) = v8;
  v11 = a3 * 1000.0 * 1000.0 * 1000.0;
  if ( v4 >= (int)v10 + 1 || v9 <= 0 )
    v13 = v4;
  else
    v13 = v10 + 1;
  v14 = llround(v11);
  if ( v5 >= (unsigned int)a2 )
    v15 = v5;
  else
    v15 = a2;
  *(_DWORD *)(result + 32) = v13;
  *(_DWORD *)(result + 36) = v15;
  *(_DWORD *)(result + 24) = v3 + (v14 >> 4);
  return result;
}


================================================================================
Function: sub_65C2214 (0x65C2214)
================================================================================

double __fastcall sub_65C2214(__int64 a1, __int64 a2, double a3)
{
  int v3; // w10
  __int64 v4; // x11
  double result; // d0

  v3 = *(_DWORD *)(a1 + 28);
  v4 = *(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 4);
  result = a3 * 1000.0 * 1000.0 * 1000.0;
  *(_DWORD *)(a1 + 28) = v3 + (llround(result) >> 4);
  *(_QWORD *)(a1 + 16) = v4 + a2;
  return result;
}


================================================================================
Function: sub_65C225C (0x65C225C)
================================================================================

__int64 __fastcall sub_65C225C(unsigned int *a1)
{
  return *a1;
}


================================================================================
Function: sub_65C2264 (0x65C2264)
================================================================================

__int64 __fastcall sub_65C2264(__int64 a1)
{
  return *(unsigned int *)(a1 + 4);
}


================================================================================
Function: sub_65C226C (0x65C226C)
================================================================================

__int64 __fastcall sub_65C226C(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}


================================================================================
Function: sub_65C2274 (0x65C2274)
================================================================================

__int64 __fastcall sub_65C2274(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}


================================================================================
Function: sub_65C22CC (0x65C22CC)
================================================================================

long double __fastcall sub_65C22CC(__int64 a1)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}


================================================================================
Function: sub_65C2500 (0x65C2500)
================================================================================

void *sub_65C2500()
{
  _QWORD *v0; // x0
  _QWORD *v2; // x19

  if ( (*(_BYTE *)sub_6866980(qword_6CA9360) & 1) == 0 )
  {
    v2 = sub_6866980(qword_6CA9340);
    sub_65C2590();
    sub_6863688((__int64)sub_65C2694, (__int64)v2);
    *(_BYTE *)sub_6866980(qword_6CA9360) = 1;
  }
  v0 = sub_6866980(qword_6CA9340);
  if ( *v0 )
    return (void *)*v0;
  else
    return &unk_724A478;
}


================================================================================
Function: sub_65C2590 (0x65C2590)
================================================================================

__int64 __fastcall sub_65C2590(_QWORD *a1)
{
  unsigned __int8 v2; // w8
  char *v3; // x21
  __int64 v4; // x8
  char *v5; // x13
  __int64 v6; // x11
  __int64 result; // x0
  __int64 v8; // x0
  __int128 v9; // q0
  __int64 v10; // x8

  v2 = atomic_load(byte_724A470);
  if ( (v2 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_724A470) )
  {
    v8 = sub_65C1F78();
    v9 = *(_OWORD *)(v8 + 16);
    v10 = *(_QWORD *)(v8 + 32);
    xmmword_7249010 = *(_OWORD *)v8;
    unk_7249020 = v9;
    qword_7249030 = v10;
    memset(&unk_7249038, 0, 0x1438uLL);
    sub_6862850(byte_724A470);
  }
  v3 = (char *)&unk_7249038;
  sub_6848980(&stru_724A448);
  v4 = 0LL;
  while ( 1 )
  {
    v5 = (char *)&xmmword_7249010 + 8 * ((unsigned int)v4 >> 6);
    v6 = *((_QWORD *)v5 + 645);
    if ( ((1LL << v4) & v6) == 0 )
      break;
    ++v4;
    v3 += 40;
    if ( v4 == 128 )
    {
      v3 = 0LL;
      goto LABEL_7;
    }
  }
  *((_QWORD *)v5 + 645) = (1LL << v4) | v6;
LABEL_7:
  result = sub_68489D4(&stru_724A448);
  *a1 = v3;
  return result;
}


================================================================================
Function: sub_65C2EA8 (0x65C2EA8)
================================================================================

_BYTE *__fastcall sub_65C2EA8(__int64 a1, unsigned __int8 *a2)
{
  _BYTE *v3; // x0
  __int64 v5; // x9
  unsigned __int64 v6; // x8
  __int64 v7; // x22
  unsigned __int64 v8; // x21
  _BYTE *result; // x0
  unsigned __int8 *v10; // x20
  __int64 v11; // x9
  size_t v12; // x2

  v3 = *(_BYTE **)a1;
  if ( !v3[9] )
  {
    v5 = *(_QWORD *)v3;
    v3[9] = 1;
    (*(void (**)(void))(v5 + 32))();
    v3 = *(_BYTE **)a1;
  }
  v6 = *a2;
  v7 = *((int *)v3 + 6);
  if ( (v6 & 1) != 0 )
    v8 = *((_QWORD *)a2 + 1);
  else
    v8 = v6 >> 1;
  sub_684A708(a2, v8 + v7, 0LL);
  result = *(_BYTE **)a1;
  if ( (*a2 & 1) != 0 )
    v10 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v10 = a2 + 1;
  if ( *(_BYTE *)(*(_QWORD *)a1 + 9LL) )
  {
    if ( !v10 )
      return result;
  }
  else
  {
    v11 = *(_QWORD *)result;
    result[9] = 1;
    result = (_BYTE *)(*(__int64 (**)(void))(v11 + 32))();
    if ( !v10 )
      return result;
  }
  v12 = *(int *)(*(_QWORD *)a1 + 24LL);
  if ( (int)v12 <= (int)v7 )
    return memcpy(&v10[v8], *(const void **)(*(_QWORD *)a1 + 16LL), v12);
  return result;
}


================================================================================
Function: sub_65C2F80 (0x65C2F80)
================================================================================

unsigned __int8 *__fastcall sub_65C2F80(unsigned __int8 *result, unsigned __int8 *a2)
{
  __int64 *v3; // x20
  __int64 v4; // x9
  unsigned __int8 *v5; // x21
  __int64 *v6; // x0
  __int64 v7; // x20
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x21
  unsigned __int8 *v10; // x8
  char *v11; // x8
  unsigned __int8 *v12; // x9
  unsigned int v13; // t1
  char v14; // w11
  _BYTE v15[128]; // [xsp+8h] [xbp-88h] BYREF

  v3 = *(__int64 **)result;
  if ( !*(_BYTE *)(*(_QWORD *)result + 9LL) )
  {
    v4 = *v3;
    v5 = result;
    v6 = *(__int64 **)result;
    *((_BYTE *)v3 + 9) = 1;
    result = (unsigned __int8 *)(*(__int64 (__fastcall **)(__int64 *))(v4 + 32))(v6);
    v3 = *(__int64 **)v5;
  }
  if ( *((int *)v3 + 6) <= 128 )
  {
    result = (unsigned __int8 *)__memcpy_chk(v15, v3[2]);
    v7 = *((unsigned int *)v3 + 6);
    if ( (unsigned int)v7 <= 0x7F )
    {
      v8 = *a2;
      if ( (v8 & 1) != 0 )
        v9 = *((_QWORD *)a2 + 1);
      else
        v9 = v8 >> 1;
      result = sub_684A708(a2, v9 + 2 * v7, 0);
      if ( (*a2 & 1) != 0 )
        v10 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      else
        v10 = a2 + 1;
      if ( (_DWORD)v7 )
      {
        v11 = (char *)&v10[v9 + 1];
        v12 = v15;
        do
        {
          v13 = *v12++;
          --v7;
          v14 = a0123456789abcd_1[v13 & 0xF];
          *(v11 - 1) = a0123456789abcd_1[(unsigned __int64)v13 >> 4];
          *v11 = v14;
          v11 += 2;
        }
        while ( v7 );
      }
    }
  }
  return result;
}


================================================================================
Function: sub_65C316C (0x65C316C)
================================================================================

__int64 sub_65C316C()
{
  unsigned __int64 v0; // x20
  __int64 v1; // x22
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x8
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x0
  __int64 result; // x0
  unsigned int v9; // w20
  unsigned int v10; // w0

  sub_65C4D1C();
  v0 = atomic_load((unsigned __int64 *)&qword_724A510);
  v1 = (unsigned int)dword_724A520;
  v2 = (unsigned int)v0;
  if ( (unsigned int)v0 >= (unsigned __int64)(unsigned int)dword_724A520 )
    goto LABEL_18;
  v3 = qword_724A518;
  if ( !qword_724A518 )
    goto LABEL_18;
  while ( 1 )
  {
    v4 = *(_QWORD *)(v3 + 136 * v2);
    if ( v3 <= v4 && v3 + 136 * v1 > v4 )
    {
      v6 = 0xF0F0F0F0F0F0F0F1LL * ((__int64)(v4 - v3) >> 3);
      if ( v6 >= 0xFFFFFFFF )
        v6 = 0xFFFFFFFFLL;
    }
    else
    {
      v6 = 0xFFFFFFFFLL;
    }
    v7 = sub_6867020(v0, v6 | v0 & 0xFFFFFFFF00000000LL, (atomic_ullong *)&qword_724A510);
    if ( v7 == v0 )
      break;
    v1 = (unsigned int)dword_724A520;
    v2 = (unsigned int)v7;
    if ( (unsigned int)v7 < (unsigned __int64)(unsigned int)dword_724A520 )
    {
      v3 = qword_724A518;
      v0 = v7;
      if ( qword_724A518 )
        continue;
    }
    goto LABEL_18;
  }
  LODWORD(v1) = dword_724A520;
  if ( (unsigned int)v0 < (unsigned __int64)(unsigned int)dword_724A520 && qword_724A518 )
  {
    result = qword_724A518 + 136LL * (unsigned int)v0;
    if ( !result )
      return sub_65ECAAC();
  }
  else
  {
LABEL_18:
    v9 = dword_724A508;
    if ( (unsigned int)v1 <= dword_724A508 )
      return sub_65ECAAC();
    while ( 1 )
    {
      v10 = sub_6866E60(v9, v9 + 1, (atomic_uint *)&dword_724A508);
      if ( v10 == v9 )
        break;
      v9 = v10;
      if ( (unsigned int)v1 <= v10 )
        return sub_65ECAAC();
    }
    if ( (unsigned int)v1 <= v9 )
      return sub_65ECAAC();
    result = qword_724A518 + 136LL * v9;
    if ( !result )
      return sub_65ECAAC();
  }
  return result;
}


================================================================================
Function: sub_65C3D24 (0x65C3D24)
================================================================================

__int64 sub_65C3D24()
{
  unsigned __int64 v0; // x20
  __int64 v1; // x22
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x8
  unsigned __int64 v6; // x8
  __int64 v7; // x0
  __int64 result; // x0
  unsigned int v9; // w20
  unsigned int v10; // w0

  sub_65C504C();
  v0 = atomic_load((unsigned __int64 *)&qword_724A5B0);
  v1 = (unsigned int)dword_724A5C0;
  v2 = (unsigned int)v0;
  if ( (unsigned int)v0 >= (unsigned __int64)(unsigned int)dword_724A5C0 )
    goto LABEL_18;
  v3 = qword_724A5B8;
  if ( !qword_724A5B8 )
    goto LABEL_18;
  while ( 1 )
  {
    v4 = *(_QWORD *)(v3 + 2008 * v2);
    if ( v3 <= v4 && v3 + 2008 * v1 > v4 )
    {
      v6 = 0x28CBFBEB9A020A33LL * ((__int64)(v4 - v3) >> 3);
      if ( v6 >= 0xFFFFFFFF )
        v6 = 0xFFFFFFFFLL;
    }
    else
    {
      v6 = 0xFFFFFFFFLL;
    }
    v7 = sub_6867020(v0, v6 | v0 & 0xFFFFFFFF00000000LL, &qword_724A5B0);
    if ( v7 == v0 )
      break;
    v1 = (unsigned int)dword_724A5C0;
    v2 = (unsigned int)v7;
    if ( (unsigned int)v7 < (unsigned __int64)(unsigned int)dword_724A5C0 )
    {
      v3 = qword_724A5B8;
      v0 = v7;
      if ( qword_724A5B8 )
        continue;
    }
    goto LABEL_18;
  }
  LODWORD(v1) = dword_724A5C0;
  if ( (unsigned int)v0 < (unsigned __int64)(unsigned int)dword_724A5C0 && qword_724A5B8 )
  {
    result = qword_724A5B8 + 2008LL * (unsigned int)v0;
    if ( !result )
      return sub_65ECAAC();
  }
  else
  {
LABEL_18:
    v9 = dword_724A5A8;
    if ( (unsigned int)v1 <= dword_724A5A8 )
      return sub_65ECAAC();
    while ( 1 )
    {
      v10 = sub_6866E60(v9, v9 + 1, &dword_724A5A8);
      if ( v10 == v9 )
        break;
      v9 = v10;
      if ( (unsigned int)v1 <= v10 )
        return sub_65ECAAC();
    }
    if ( (unsigned int)v1 <= v9 )
      return sub_65ECAAC();
    result = qword_724A5B8 + 2008LL * v9;
    if ( !result )
      return sub_65ECAAC();
  }
  return result;
}


================================================================================
Function: sub_65C416C (0x65C416C)
================================================================================

__int64 __usercall sub_65C416C@<X0>(__int64 a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  __int64 v6; // x19
  __int64 v8; // [xsp+0h] [xbp-10h] BYREF

  v6 = sub_65C316C(136LL);
  v8 = v6;
  *(_DWORD *)(v6 + 24) = 16;
  *(_QWORD *)v6 = &off_6C26BD8;
  *(_WORD *)(v6 + 8) = 1;
  *(_QWORD *)(v6 + 120) = 0LL;
  *(_QWORD *)(v6 + 16) = v6 + 120;
  *(_QWORD *)(v6 + 128) = 0LL;
  sub_6768674(v6 + 28);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v6 + 24LL))(v6, a1, a2);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  sub_65C2F80(&v8, a3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
}


================================================================================
Function: sub_65C4398 (0x65C4398)
================================================================================

__int64 __usercall sub_65C4398@<X0>(__int64 a1@<X0>, unsigned int a2@<W1>, int a3@<W2>, _QWORD *a4@<X8>)
{
  __int64 v8; // x19
  __int64 v10; // [xsp+0h] [xbp-10h] BYREF

  v8 = sub_65C3D24(2008LL);
  *(_DWORD *)(v8 + 24) = a3;
  *(_QWORD *)v8 = &off_6C26CD8;
  v10 = v8;
  *(_QWORD *)(v8 + 16) = v8 + 28;
  *(_WORD *)(v8 + 8) = 1;
  memset((void *)(v8 + 28), 0, a3);
  sub_6801348(v8 + 96);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v8 + 24LL))(v8, a1, a2);
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  sub_65C2EA8(&v10, a4);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 8LL))(v8);
}


================================================================================
Function: sub_65C4D1C (0x65C4D1C)
================================================================================

void sub_65C4D1C()
{
  unsigned __int8 v0; // w8
  int v1; // w20

  v0 = atomic_load(byte_724A528);
  if ( (v0 & 1) == 0 )
  {
    if ( (unsigned int)sub_68626F8((__int64)byte_724A528) )
    {
      v1 = dword_6CA9380;
      dword_724A508 = 0;
      qword_724A510 = 0xFFFFFFFFLL;
      qword_724A518 = sub_65ED63C(136LL * (unsigned int)dword_6CA9380);
      dword_724A520 = v1;
      __cxa_atexit((void (*)(void *))sub_65C4DCC, &dword_724A508, &off_686E780);
      sub_6862850(byte_724A528);
    }
  }
}


================================================================================
Function: sub_65C504C (0x65C504C)
================================================================================

void sub_65C504C()
{
  unsigned __int8 v0; // w8
  int v1; // w20

  v0 = atomic_load(byte_724A5C8);
  if ( (v0 & 1) == 0 )
  {
    if ( (unsigned int)sub_68626F8((__int64)byte_724A5C8) )
    {
      v1 = dword_6CA9380;
      dword_724A5A8 = 0;
      qword_724A5B0 = 0xFFFFFFFFLL;
      qword_724A5B8 = sub_65ED63C(2008LL * (unsigned int)dword_6CA9380, 8LL);
      dword_724A5C0 = v1;
      __cxa_atexit((void (*)(void *))sub_65C50FC, &dword_724A5A8, &off_686E780);
      sub_6862850(byte_724A5C8);
    }
  }
}


================================================================================
Function: sub_65C5554 (0x65C5554)
================================================================================

__int64 __fastcall sub_65C5554(__int64 a1, int a2, int a3, int a4, double a5)
{
  __int64 v9; // x22
  const char *v10; // x4
  unsigned int v11; // w19
  _QWORD v13[3]; // [xsp+0h] [xbp-30h] BYREF

  v9 = (unsigned int)(a2 - 1);
  sub_65F8770(v13, (__int64)((*(double *)&qword_72EA7D8 + a5) * 1000.0));
  if ( (v13[0] & 1) != 0 )
    v10 = (const char *)v13[2];
  else
    v10 = (char *)v13 + 1;
  v11 = sub_65C61DC(a1, -1LL, v9, "%s,%.6f,%04x,%d%s ", v10, a5, a3, a4, (const char *)off_6CA9390);
  if ( (v13[0] & 1) != 0 )
    sub_65ECAF4();
  return v11;
}


================================================================================
Function: sub_65C5664 (0x65C5664)
================================================================================

__int64 __fastcall sub_65C5664(__int64 a1, int a2, int a3, int a4, char a5, void *a6, double a7)
{
  __int64 v14; // x23
  const char *v15; // x4
  const char *v16; // x7
  unsigned int v17; // w26
  int v18; // w0
  __int64 v19; // x21
  __int64 v20; // x22
  __int64 result; // x0
  _QWORD v22[2]; // [xsp+8h] [xbp-158h] BYREF
  const char *v23; // [xsp+18h] [xbp-148h]
  __int64 v24; // [xsp+20h] [xbp-140h]
  __int64 v25; // [xsp+28h] [xbp-138h]
  __int64 v26; // [xsp+30h] [xbp-130h]
  __int64 v27; // [xsp+38h] [xbp-128h]

  v14 = (unsigned int)(a2 - 1);
  sub_65F8770(v22, (__int64)((*(double *)&qword_72EA7D8 + a7) * 1000.0));
  if ( (v22[0] & 1) != 0 )
    v15 = v23;
  else
    v15 = (char *)v22 + 1;
  if ( (unsigned __int8)(a5 + 1) > 7u )
    v16 = "invalid";
  else
    v16 = (char *)dword_1714740 + dword_1714740[(char)(a5 + 1)];
  v17 = sub_65C61DC(a1, -1LL, v14, "%s,%.6f,%04x,%d,%s%s ", v15, a7, a3, a4, v16, (const char *)off_6CA9390);
  if ( (v22[0] & 1) != 0 )
    sub_65ECAF4();
  v18 = sub_65F15A8(v14, v17);
  v19 = a1 + v18;
  v20 = (unsigned int)(a2 - v18 - 2);
  v25 = 0LL;
  v26 = v20;
  v23 = 0LL;
  v24 = v20;
  v22[0] = off_6C26D78;
  v22[1] = v19;
  v27 = v19;
  result = sub_68070F4((int)v22, a6);
  *(_BYTE *)(v19 + v20) = 0;
  return result;
}


================================================================================
Function: sub_65C5818 (0x65C5818)
================================================================================

__int64 __fastcall sub_65C5818(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_65C582C(a1, a2, a3, a4, 0LL, 0LL, 0LL, 0LL);
}


================================================================================
Function: sub_65C582C (0x65C582C)
================================================================================

__int64 __fastcall sub_65C582C(
        __int64 result,
        __int64 a2,
        const char *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned __int64 v8; // x19
  double v16; // d8
  int v17; // w0
  unsigned __int8 v18; // w8
  int v19; // w19
  __int64 v20; // x22
  double *v21; // x8
  int v22; // w27
  float v23; // s0
  int v24; // w0
  int v25; // w0
  __int64 v26; // x2
  _BYTE *v27; // x0
  float v28; // s0
  float v29; // s1
  float v30; // s2
  float v31; // s3
  _BYTE s[1024]; // [xsp+10h] [xbp-420h] BYREF

  v8 = result;
  if ( (_BYTE)result )
  {
    if ( (unsigned __int8)result < 6u )
    {
LABEL_6:
      v16 = off_6CA9388();
      v17 = pthread_self();
      v18 = v8 - 1;
      v19 = v17 & 0x7FFFFFFF;
      v20 = v18;
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)((char *)&unk_72EA9E0 + 4 * v18));
      v21 = (double *)((char *)&unk_724A7B8 + 0x20000 * v20 + 64 * (unsigned __int64)(((_WORD)result - 1) & 0x7FF));
      *(_QWORD *)v21 = a3;
      v21[1] = v16;
      *((_QWORD *)v21 + 2) = a4;
      v21[3] = *(double *)&a5;
      v21[4] = *(double *)&a6;
      v21[5] = *(double *)&a7;
      v21[6] = *(double *)&a8;
      *((_DWORD *)v21 + 14) = v19;
      return result;
    }
    if ( !off_72EA7C8 && !off_72EA7D0 )
    {
      LOBYTE(v8) = 1;
      goto LABEL_6;
    }
    memset(s, 0, sizeof(s));
    v22 = pthread_self();
    v23 = off_6CA9388();
    v24 = sub_65C5554((__int64)s, 1024, v22, (unsigned __int8)v8, v23);
    v25 = sub_65F15A8(1023, v24);
    v26 = (unsigned int)(1023 - v25);
    v27 = &s[v25];
    if ( a4 == 4294906029LL )
    {
      v28 = *(double *)&a5;
      v29 = *(double *)&a6;
      v30 = *(double *)&a7;
      v31 = *(double *)&a8;
      result = sub_65C61DC((__int64)v27, -1LL, v26, a3, v28, v29, v30, v31);
    }
    else
    {
      result = sub_65C61DC((__int64)v27, -1LL, v26, a3, a4, a5, a6, a7, a8);
    }
    if ( off_72EA7C8 )
      result = off_72EA7C8(v8, a2, s);
    if ( off_72EA7D0 )
      return off_72EA7D0(v8, a2, v8 >> 8, s);
  }
  return result;
}


================================================================================
Function: sub_65C5A5C (0x65C5A5C)
================================================================================

__int64 __fastcall sub_65C5A5C(unsigned __int64 a1, __int64 a2, const char *a3, __int128 *a4)
{
  unsigned __int64 v6; // x19
  __int128 v8; // q0
  __int128 v9; // q1
  __int64 result; // x0
  _OWORD *v11; // x8
  __int128 v12; // q1
  __int128 v13; // q2
  __int128 v14; // q3
  pthread_t v15; // x23
  float v16; // s0
  unsigned int v17; // w0
  int v18; // w0
  __int128 v19; // [xsp+0h] [xbp-470h]
  __int128 v20; // [xsp+10h] [xbp-460h]
  __int128 v21; // [xsp+20h] [xbp-450h]
  __int128 v22; // [xsp+30h] [xbp-440h]
  __int128 arg; // [xsp+40h] [xbp-430h] BYREF
  __int128 v24; // [xsp+50h] [xbp-420h]
  __int128 s; // [xsp+68h] [xbp-408h] BYREF
  __int128 v26; // [xsp+78h] [xbp-3F8h] BYREF
  _BYTE v27[28]; // [xsp+88h] [xbp-3E8h]

  v6 = a1;
  if ( (unsigned __int8)a1 < 6u )
    goto LABEL_5;
  if ( !off_72EA7C8 && !off_72EA7D0 )
  {
    LOBYTE(v6) = 1;
LABEL_5:
    v8 = *a4;
    v9 = a4[1];
    *(_QWORD *)&s = "%s";
    v19 = v8;
    v20 = v9;
    *((_QWORD *)&s + 1) = off_6CA9388();
    *(_DWORD *)&v27[24] = pthread_self();
    arg = v19;
    v24 = v20;
    vsnprintf((char *)&v26, 0x28uLL, a3, &arg);
    v27[23] = 0;
    *(_DWORD *)&v27[24] |= 0x80000000;
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)((char *)&unk_72EA9E0 + 4 * (unsigned __int8)(v6 - 1)));
    v11 = (_OWORD *)((char *)&unk_724A7B8
                   + 0x20000 * (unsigned __int64)(unsigned __int8)(v6 - 1)
                   + 64 * (unsigned __int64)(((_WORD)result - 1) & 0x7FF));
    v12 = *(_OWORD *)v27;
    v13 = s;
    v14 = v26;
    *(_OWORD *)((char *)v11 + 44) = *(_OWORD *)&v27[12];
    *v11 = v13;
    v11[1] = v14;
    v11[2] = v12;
    return result;
  }
  memset(&s, 0, 0x400uLL);
  v15 = pthread_self();
  v16 = off_6CA9388();
  v21 = *a4;
  v22 = a4[1];
  v17 = sub_65C5554(&s, 1024LL, v15, (unsigned __int8)v6, v16);
  v18 = sub_65F15A8(1023LL, v17);
  arg = v21;
  v24 = v22;
  result = vsnprintf((char *)&s + v18, (unsigned int)(1023 - v18), a3, &arg);
  if ( off_72EA7C8 )
    result = off_72EA7C8(v6, a2, &s);
  if ( off_72EA7D0 )
    return off_72EA7D0(v6, a2, v6 >> 8, &s);
  return result;
}


================================================================================
Function: sub_65C5C5C (0x65C5C5C)
================================================================================

__int64 __fastcall sub_65C5C5C(
        __int64 result,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        long double a9,
        long double a10,
        long double a11,
        long double a12,
        __int64 a13)
{
  _QWORD v13[6]; // [xsp+80h] [xbp-80h] BYREF
  _OWORD v14[2]; // [xsp+B0h] [xbp-50h] BYREF
  __int128 v15; // [xsp+D8h] [xbp-28h]
  __int128 v16; // [xsp+E8h] [xbp-18h]

  v13[3] = a6;
  v13[4] = a7;
  v13[1] = a4;
  v13[2] = a5;
  v13[5] = a8;
  if ( (_BYTE)result )
  {
    *(_QWORD *)&v16 = v13;
    *((_QWORD *)&v16 + 1) = 0xFFFFFF80FFFFFFD8LL;
    *(_QWORD *)&v15 = &a13;
    *((_QWORD *)&v15 + 1) = v14;
    v14[0] = v15;
    v14[1] = v16;
    return sub_65C5A5C(
             result,
             a2,
             a3,
             v14,
             a5,
             a6,
             a7,
             a8,
             *(_QWORD *)&a9,
             *((_QWORD *)&a9 + 1),
             *(_QWORD *)&a10,
             *((_QWORD *)&a10 + 1),
             *(_QWORD *)&a11,
             *((_QWORD *)&a11 + 1),
             *(_QWORD *)&a12,
             *((_QWORD *)&a12 + 1));
  }
  return result;
}


================================================================================
Function: sub_65C5CFC (0x65C5CFC)
================================================================================

__int64 __fastcall sub_65C5CFC(
        __int64 result,
        __int64 a2,
        unsigned int a3,
        void *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8)
{
  __int64 v9; // x19
  _OWORD *v13; // x8
  __int128 v14; // q1
  __int128 v15; // q3
  pthread_t v19; // x27
  __int64 v20; // x7
  float v21; // s0
  double v22; // d0
  unsigned int v23; // w0
  int v24; // w0
  __int64 v25; // x26
  char *v26; // x27
  _QWORD s[2]; // [xsp+18h] [xbp-548h] BYREF
  __int128 v28; // [xsp+28h] [xbp-538h]
  __int128 v29; // [xsp+38h] [xbp-528h]
  __int128 *v30; // [xsp+48h] [xbp-518h]
  __int128 v31; // [xsp+418h] [xbp-148h] BYREF
  __int128 v32; // [xsp+428h] [xbp-138h] BYREF
  _BYTE v33[28]; // [xsp+438h] [xbp-128h]

  v9 = result;
  if ( (unsigned __int8)result < 6u )
    goto LABEL_2;
  if ( BYTE1(result) >= (unsigned int)(unsigned __int8)a3 )
  {
    if ( !off_72EA7C8 && !off_72EA7D0 )
    {
      LOBYTE(v9) = 1;
LABEL_2:
      *(_QWORD *)&v31 = "%s";
      *((_QWORD *)&v31 + 1) = off_6CA9388();
      *(_DWORD *)&v33[24] = pthread_self();
      s[0] = off_6C26D78;
      s[1] = &v32;
      v29 = xmmword_AFE4B0;
      v28 = xmmword_AFE4B0;
      v30 = &v32;
      sub_68070F4((int)s, a4);
      v33[23] = 0;
      *(_DWORD *)&v33[24] |= 0x80000000;
      result = sub_68673F0(0xFFFFFFFFLL, (char *)&unk_72EA9E0 + 4 * (unsigned __int8)(v9 - 1));
      v13 = (_OWORD *)((char *)&unk_724A7B8
                     + 0x20000 * (unsigned __int64)(unsigned __int8)(v9 - 1)
                     + 64 * (unsigned __int64)(((_WORD)result - 1) & 0x7FF));
      v14 = *(_OWORD *)v33;
      *(_OWORD *)((char *)v13 + 44) = *(_OWORD *)&v33[12];
      v15 = v32;
      *v13 = v31;
      v13[1] = v15;
      v13[2] = v14;
      return result;
    }
    memset(s, 0, 0x400uLL);
    v19 = pthread_self();
    v21 = off_6CA9388();
    v22 = v21;
    if ( (a8 & 1) != 0 )
    {
      result = sub_65C5664(s, 1024LL, v19, (unsigned __int8)v9, a3, a4, a5, v20, v22, a6, a7);
    }
    else
    {
      v23 = sub_65C5554(s, 1024LL, v19, (unsigned __int8)v9, v22);
      v24 = sub_65F15A8(1023LL, v23);
      v25 = (unsigned int)(1022 - v24);
      v26 = (char *)s + v24;
      *(_QWORD *)v33 = 0LL;
      *(_QWORD *)&v33[8] = v25;
      *(_QWORD *)&v32 = 0LL;
      *((_QWORD *)&v32 + 1) = v25;
      *((_QWORD *)&v31 + 1) = v26;
      *(_QWORD *)&v31 = off_6C26D78;
      *(_QWORD *)&v33[16] = v26;
      result = sub_68070F4((int)&v31, a4);
      v26[v25] = 0;
    }
    if ( off_72EA7C8 )
      result = off_72EA7C8(v9, a2, s);
    if ( off_72EA7D0 )
      return off_72EA7D0(v9, a2, a3, s);
  }
  return result;
}


================================================================================
Function: sub_65C5FE4 (0x65C5FE4)
================================================================================

__int64 __fastcall sub_65C5FE4(__int64 result, __int64 a2, const char *a3, const char *a4)
{
  unsigned __int64 v4; // x19
  int v8; // w21
  const char *v9; // x1
  _OWORD *v10; // x8
  __int128 v11; // q1
  __int128 v12; // q2
  __int128 v13; // q3
  int v14; // w23
  float v15; // s0
  int v16; // w0
  int v17; // w0
  __int128 s; // [xsp+8h] [xbp-408h] BYREF
  __int128 v19; // [xsp+18h] [xbp-3F8h] BYREF
  _BYTE v20[28]; // [xsp+28h] [xbp-3E8h]

  v4 = result;
  if ( !(_BYTE)result )
    return result;
  if ( (unsigned __int8)result < 6u )
    goto LABEL_6;
  if ( !off_72EA7C8 && !off_72EA7D0 )
  {
    LOBYTE(v4) = 1;
LABEL_6:
    *(_QWORD *)&s = a3;
    *((_QWORD *)&s + 1) = off_6CA9388();
    v8 = pthread_self();
    if ( a4 )
      v9 = a4;
    else
      v9 = "NULL";
    *(_DWORD *)&v20[24] = v8;
    strncpy((char *)&v19, v9, 0x28uLL);
    v20[23] = 0;
    *(_DWORD *)&v20[24] = v8 | 0x80000000;
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)((char *)&unk_72EA9E0 + 4 * (unsigned __int8)(v4 - 1)));
    v10 = (_OWORD *)((char *)&unk_724A7B8
                   + 0x20000 * (unsigned __int64)(unsigned __int8)(v4 - 1)
                   + 64 * (unsigned __int64)(((_WORD)result - 1) & 0x7FF));
    v11 = *(_OWORD *)v20;
    v12 = s;
    v13 = v19;
    *(_OWORD *)((char *)v10 + 44) = *(_OWORD *)&v20[12];
    *v10 = v12;
    v10[1] = v13;
    v10[2] = v11;
    return result;
  }
  memset(&s, 0, 0x400uLL);
  v14 = pthread_self();
  v15 = off_6CA9388();
  v16 = sub_65C5554((__int64)&s, 1024, v14, (unsigned __int8)v4, v15);
  v17 = sub_65F15A8(1023, v16);
  result = sub_65C61DC((__int64)&s + v17, -1LL, (unsigned int)(1023 - v17), a3, a4);
  if ( off_72EA7C8 )
    result = off_72EA7C8(v4, a2, &s);
  if ( off_72EA7D0 )
    return off_72EA7D0(v4, a2, v4 >> 8, &s);
  return result;
}


================================================================================
Function: sub_65C61C8 (0x65C61C8)
================================================================================

__int64 __fastcall sub_65C61C8(__int64 a1, __int64 a2, const char *a3, __int64 a4)
{
  __int64 v4; // x3

  if ( (*(_BYTE *)a4 & 1) != 0 )
    v4 = *(_QWORD *)(a4 + 16);
  else
    v4 = a4 + 1;
  return sub_65C5FE4(a1, a2, a3, v4);
}


================================================================================
Function: sub_65C61DC (0x65C61DC)
================================================================================

__int64 sub_65C61DC(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  gcc_va_list va1; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, a4);
  va_copy(va1, va);
  return __vsnprintf_chk(a1, a3, 0LL, a2, a4, va1);
}


================================================================================
Function: sub_65C63EC (0x65C63EC)
================================================================================

__int64 __fastcall sub_65C63EC(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_65CDD2C(qword_72EA9F8, a1, a2, a3);
}


================================================================================
Function: sub_65C67A0 (0x65C67A0)
================================================================================

__int64 sub_65C67A0()
{
  return sub_65D09A8(qword_72EA9F8);
}


================================================================================
Function: sub_65CDD2C (0x65CDD2C)
================================================================================

__int64 __fastcall sub_65CDD2C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  pthread_mutex_t *v4; // x19
  __int64 *i; // x26
  int v10; // w8
  __int128 *v11; // x1
  __int64 v12; // x23
  _QWORD *v13; // x8

  v4 = (pthread_mutex_t *)(a1 + 40);
  sub_6848980((pthread_mutex_t *)(a1 + 40));
  for ( i = *(__int64 **)(a1 + 296); i; i = (__int64 *)*i )
  {
    v10 = *((_DWORD *)i + 10);
    v11 = (__int128 *)(i + 2);
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        v12 = *(_QWORD *)(a3 + 8);
        if ( v12 == *(_QWORD *)(a3 + 16) )
        {
          sub_2527530(a3, v11);
          continue;
        }
        sub_68497A0(*(unsigned __int64 **)(a3 + 8), v11);
        v13 = (_QWORD *)(a3 + 8);
      }
      else
      {
        if ( v10 != 2 )
          continue;
        v12 = *(_QWORD *)(a2 + 8);
        if ( v12 == *(_QWORD *)(a2 + 16) )
        {
          sub_2527530(a2, v11);
          continue;
        }
        sub_68497A0(*(unsigned __int64 **)(a2 + 8), v11);
        v13 = (_QWORD *)(a2 + 8);
      }
    }
    else
    {
      v12 = *(_QWORD *)(a4 + 8);
      if ( v12 == *(_QWORD *)(a4 + 16) )
      {
        sub_2527530(a4, v11);
        continue;
      }
      sub_68497A0(*(unsigned __int64 **)(a4 + 8), v11);
      v13 = (_QWORD *)(a4 + 8);
    }
    *v13 = v12 + 24;
  }
  return sub_68489D4(v4);
}


================================================================================
Function: sub_65D09A8 (0x65D09A8)
================================================================================

__int64 __fastcall sub_65D09A8(__int64 a1)
{
  pthread_mutex_t *v1; // x20
  __int64 v3; // x19

  v1 = (pthread_mutex_t *)(a1 + 40);
  sub_6848980((pthread_mutex_t *)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 568);
  sub_68489D4(v1);
  return v3;
}


================================================================================
Function: sub_65D5F28 (0x65D5F28)
================================================================================

bool __fastcall sub_65D5F28(__int64 a1)
{
  return (sub_67D97C4(a1, 0LL) & 0xFFFFFFFELL) != 0;
}


================================================================================
Function: sub_65D5F48 (0x65D5F48)
================================================================================

bool __fastcall sub_65D5F48(__int64 a1, __int64 a2)
{
  return (sub_67D97C4(a1, a2) & 0xFFFFFFFELL) != 0;
}


================================================================================
Function: sub_65D5FE4 (0x65D5FE4)
================================================================================

__int64 sub_65D5FE4()
{
  return sub_67D8348() & 1;
}


================================================================================
Function: sub_65DA834 (0x65DA834)
================================================================================

__int64 __fastcall sub_65DA834(__int64 a1, unsigned int a2)
{
  __int64 v4; // x0
  __int64 result; // x0

  v4 = sub_65ECAAC();
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(v4 + 32) = 0LL;
  *(_QWORD *)(v4 + 40) = 256LL;
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  result = sub_65DA884(a2, v4);
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}


================================================================================
Function: sub_65DA884 (0x65DA884)
================================================================================

__int64 __fastcall sub_65DA884(int a1, __int64 a2)
{
  __int64 result; // x0
  __int64 (__fastcall **v4)(); // x8
  _QWORD *v5; // x19

  if ( a1 == 1 )
  {
    result = sub_65ECAAC();
    *(_QWORD *)(result + 16) = a2;
    *(_DWORD *)(result + 8) = 4;
    *(_DWORD *)(result + 72) = 324;
    *(_OWORD *)(result + 24) = 0u;
    *(_QWORD *)(result + 56) = 0LL;
    *(_QWORD *)(result + 64) = 512LL;
    *(_OWORD *)(result + 40) = 0u;
    *(_WORD *)(result + 76) = 0x2000;
    v4 = off_6C27710;
    *(_QWORD *)(result + 80) = 4LL;
  }
  else
  {
    if ( a1 )
    {
      v5 = (_QWORD *)sub_6861FD0(16LL);
      sub_684956C(v5, "Unsupported Writer::Type.");
      sub_6862048((__int64)v5, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_6865364);
    }
    result = sub_65ECAAC();
    *(_QWORD *)(result + 16) = a2;
    *(_BYTE *)(result + 76) = 0;
    *(_DWORD *)(result + 8) = 4;
    *(_DWORD *)(result + 72) = 324;
    *(_OWORD *)(result + 24) = 0u;
    *(_QWORD *)(result + 56) = 0LL;
    *(_QWORD *)(result + 64) = 512LL;
    *(_OWORD *)(result + 40) = 0u;
    v4 = off_6C27610;
  }
  *(_QWORD *)result = v4;
  return result;
}


================================================================================
Function: sub_65DA9D8 (0x65DA9D8)
================================================================================

__int64 __fastcall sub_65DA9D8(__int64 *a1)
{
  __int64 result; // x0
  __int64 v3; // x19

  result = a1[1];
  if ( result )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)result + 8LL))(result);
  v3 = *a1;
  if ( v3 )
  {
    sub_65EC4D4(*(_QWORD *)(v3 + 16));
    if ( *(_QWORD *)(v3 + 8) )
      sub_65ECAF4();
    return sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_65DAA38 (0x65DAA38)
================================================================================

__int64 __fastcall sub_65DAA38(__int64 a1)
{
  int v1; // w8
  __int64 *v3; // x0
  __int64 v4; // x9

  v1 = *(_DWORD *)(a1 + 16);
  v3 = *(__int64 **)(a1 + 8);
  v4 = *v3;
  *(_DWORD *)(a1 + 16) = v1 + 1;
  (*(void (__fastcall **)(__int64 *))(v4 + 16))(v3);
  return a1;
}


================================================================================
Function: sub_65DAA74 (0x65DAA74)
================================================================================

__int64 __fastcall sub_65DAA74(__int64 a1)
{
  int v1; // w8
  _QWORD *v4; // x19

  v1 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v1 - 1;
  if ( v1 <= 0 )
  {
    v4 = (_QWORD *)sub_6861FD0(16LL);
    sub_684956C(v4, "RBX::json::Writer depth underflow");
    sub_6862048((__int64)v4, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_6865364);
  }
  (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 32LL))(*(_QWORD *)(a1 + 8), 0LL);
  return a1;
}


================================================================================
Function: sub_65DAB00 (0x65DAB00)
================================================================================

__int64 __fastcall sub_65DAB00(__int64 a1)
{
  int v1; // w8
  __int64 *v3; // x0
  __int64 v4; // x9

  v1 = *(_DWORD *)(a1 + 16);
  v3 = *(__int64 **)(a1 + 8);
  v4 = *v3;
  *(_DWORD *)(a1 + 16) = v1 + 1;
  (*(void (__fastcall **)(__int64 *))(v4 + 40))(v3);
  return a1;
}


================================================================================
Function: sub_65DAB3C (0x65DAB3C)
================================================================================

__int64 __fastcall sub_65DAB3C(__int64 a1)
{
  int v1; // w8
  _QWORD *v4; // x19

  v1 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v1 - 1;
  if ( v1 <= 0 )
  {
    v4 = (_QWORD *)sub_6861FD0(16LL);
    sub_684956C(v4, "RBX::json::Writer depth underflow");
    sub_6862048((__int64)v4, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_6865364);
  }
  (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 48LL))(*(_QWORD *)(a1 + 8), 0LL);
  return a1;
}


================================================================================
Function: sub_65DB020 (0x65DB020)
================================================================================

__int64 __fastcall sub_65DB020(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  (*(void (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(**(_QWORD **)(a1 + 8) + 72LL))(
    *(_QWORD *)(a1 + 8),
    a2,
    a3,
    0LL);
  (*(void (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(**(_QWORD **)(a1 + 8) + 72LL))(
    *(_QWORD *)(a1 + 8),
    a4,
    a5,
    0LL);
  return a1;
}


================================================================================
Function: sub_65DB080 (0x65DB080)
================================================================================

__int64 __fastcall sub_65DB080(__int64 a1, double a2)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 64LL))(*(_QWORD *)(a1 + 8));
  (*(void (__fastcall **)(_QWORD, double))(**(_QWORD **)(a1 + 8) + 120LL))(*(_QWORD *)(a1 + 8), a2);
  return a1;
}


================================================================================
Function: sub_65DB208 (0x65DB208)
================================================================================

__int64 __fastcall sub_65DB208(__int64 a1, __int64 a2, unsigned int a3)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 80LL))(*(_QWORD *)(a1 + 8));
  (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 88LL))(*(_QWORD *)(a1 + 8), a3);
  return a1;
}


================================================================================
Function: sub_65DB5DC (0x65DB5DC)
================================================================================

__int64 __fastcall sub_65DB5DC(_DWORD *a1)
{
  __int64 v1; // x19
  _BYTE *v2; // x8
  __int64 result; // x0
  _QWORD *v4; // x19

  if ( a1[4] )
  {
    v4 = (_QWORD *)sub_6861FD0(16LL);
    sub_684956C(v4, "RBX::json::Writer stack is not balanced!");
    sub_6862048((__int64)v4, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_6865364);
  }
  v1 = *(_QWORD *)a1;
  v2 = *(_BYTE **)(*(_QWORD *)a1 + 24LL);
  if ( (unsigned __int64)(v2 + 1) > *(_QWORD *)(*(_QWORD *)a1 + 32LL) )
  {
    sub_65DBF4C(*(_QWORD *)a1, 1LL);
    v2 = *(_BYTE **)(v1 + 24);
  }
  *(_QWORD *)(v1 + 24) = v2 + 1;
  *v2 = 0;
  result = *(_QWORD *)(v1 + 16);
  --*(_QWORD *)(v1 + 24);
  return result;
}


================================================================================
Function: sub_65DB680 (0x65DB680)
================================================================================

__int64 __fastcall sub_65DB680(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 24LL) - *(_QWORD *)(*(_QWORD *)a1 + 16LL);
}


================================================================================
Function: sub_65DBF4C (0x65DBF4C)
================================================================================

__int64 __fastcall sub_65DBF4C(__int64 *a1, __int64 a2)
{
  __int64 v3; // x20
  unsigned __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x0
  __int64 v8; // x22
  unsigned __int64 v9; // x21
  __int64 result; // x0
  _QWORD *v11; // x19

  v3 = a1[2];
  if ( v3 )
  {
    v5 = a1[4] - v3 + ((unsigned __int64)(a1[4] - v3 + 1) >> 1);
    v6 = a1[2];
  }
  else
  {
    if ( !*a1 )
    {
      v7 = sub_65ECAAC();
      *a1 = v7;
      a1[1] = v7;
    }
    v5 = a1[5];
    v6 = 0LL;
  }
  v8 = a1[3] - v6;
  if ( v5 >= v8 + a2 )
    v9 = v5;
  else
    v9 = v8 + a2;
  result = sub_65EE1A8(v3, v9);
  if ( !result )
  {
    v11 = (_QWORD *)sub_6861FD0(8LL);
    sub_6865270(v11);
    sub_6862048((__int64)v11, (__int64)&`typeinfo for'std::bad_alloc, (__int64)sub_6865238);
  }
  a1[2] = result;
  a1[3] = result + v8;
  a1[4] = result + v9;
  return result;
}


================================================================================
Function: sub_65EBF30 (0x65EBF30)
================================================================================

__int64 sub_65EBF30()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_72FB238);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB238) )
  {
    qword_72FB218 = 0LL;
    unk_72FB220 = 0LL;
    dword_72FB230 = 0;
    qword_72FB228 = 0LL;
    sub_65FA98C();
    sub_6862850(byte_72FB238);
  }
  return *(unsigned int *)(sub_65FAAE0((__int64)&qword_72FB218) + 8);
}


================================================================================
Function: sub_65EBFB8 (0x65EBFB8)
================================================================================

__int64 __fastcall sub_65EBFB8(int a1)
{
  unsigned __int8 v2; // w8
  __int64 v3; // x8
  __int64 result; // x0

  v2 = atomic_load(byte_72FB238);
  if ( (v2 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB238) )
  {
    qword_72FB218 = 0LL;
    unk_72FB220 = 0LL;
    dword_72FB230 = 0;
    qword_72FB228 = 0LL;
    sub_65FA98C();
    sub_6862850(byte_72FB238);
  }
  v3 = sub_65FAAE0((__int64)&qword_72FB218);
  result = *(unsigned int *)(v3 + 8);
  *(_DWORD *)(v3 + 8) = a1;
  return result;
}


================================================================================
Function: sub_65EC4D4 (0x65EC4D4)
================================================================================

__int64 __fastcall sub_65EC4D4(__int64 result)
{
  __int64 v1; // x19
  unsigned __int64 v2; // x20
  __int64 v3; // x1
  unsigned __int8 v4; // w8
  __int64 v5; // [xsp+8h] [xbp-38h] BYREF
  __int64 v6; // [xsp+10h] [xbp-30h]
  __int64 v7; // [xsp+18h] [xbp-28h]

  if ( result )
  {
    v1 = result;
    v2 = sub_67F49D4(result);
    sub_65C1F84(&v5, 0LL, 0LL, 0LL);
    v6 = sub_65FE40C(v1, v2);
    v7 = v3;
    sub_6867420(-(__int64)v2, (char *)&unk_72EB200 + 64 * (unsigned __int64)(unsigned int)v6 + 16);
    v4 = atomic_load((unsigned __int8 *)&byte_72FB240);
    if ( (v4 & 1) != 0 && qword_72FB250 > v2 )
      sub_6867420(-(__int64)v2, &qword_72FB250);
    sub_67F3C08(v1);
    return sub_65C1FA0(&v5, v2);
  }
  return result;
}


================================================================================
Function: sub_65ECAAC (0x65ECAAC)
================================================================================

__int64 sub_65ECAAC()
{
  __int64 result; // x0
  __int64 v1; // x19

  result = sub_65ED488();
  if ( !result )
  {
    v1 = sub_6861FD0(8LL);
    sub_6865270();
    sub_6862048(v1, &`typeinfo for'std::bad_alloc, sub_6865238);
  }
  return result;
}


================================================================================
Function: sub_65ECAF4 (0x65ECAF4)
================================================================================

__int64 sub_65ECAF4()
{
  return sub_65EC4D4();
}


================================================================================
Function: sub_65ED488 (0x65ED488)
================================================================================

__int64 __fastcall sub_65ED488(unsigned __int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x0
  __int64 v3; // x0
  __int64 v4; // x20
  char *v5; // x21
  __int64 v6; // x22
  __int64 v7; // x0
  char *v8; // x21
  unsigned __int64 v9; // x23
  unsigned __int64 v10; // t1
  unsigned __int64 v11; // x22
  unsigned __int64 v12; // x0
  unsigned __int8 v13; // w8
  __int64 v15; // [xsp+0h] [xbp-50h] BYREF
  unsigned int v16[10]; // [xsp+8h] [xbp-48h] BYREF
  _BYTE v17[24]; // [xsp+30h] [xbp-20h] BYREF

  if ( a1 > 0xFFFFFFFFFFFFFFF6LL )
    return 0LL;
  sub_65C1E64(&v15, 0LL, 0LL, a1, 0LL);
  v2 = sub_65C1E08(&v15);
  v3 = sub_67F3A24(v2);
  v1 = v3;
  if ( v3 )
  {
    v4 = sub_67F49D4(v3);
    sub_65C1EE8(&v15, v4);
    sub_65FE394(v17, v16);
    sub_65FE3D8(v1, v4, v17);
    v5 = (char *)&unk_72EB200 + 64 * (unsigned __int64)v16[0];
    v6 = sub_6867420(v4, v5 + 16);
    v7 = sub_6867420(1LL, v5 + 32);
    if ( (sub_65C2030(v7) & 1) != 0 )
    {
      v10 = *((_QWORD *)v5 + 6);
      v8 = v5 + 48;
      v9 = v10;
      v11 = v6 + v4;
      if ( v10 < v11 )
      {
        do
        {
          v12 = sub_6866F60(v9, v11, v8);
          if ( v12 == v9 )
            break;
          v9 = v12;
        }
        while ( v12 < v11 );
      }
    }
    v13 = atomic_load((unsigned __int8 *)&byte_72FB240);
    if ( (v13 & 1) != 0 )
    {
      sub_6867420(v4, &qword_72FB250);
      if ( qword_72FB250 >= (unsigned __int64)qword_72FB248 && (unsigned int)sub_6866D60(1LL, 0LL, &byte_72FB240) == 1 )
      {
        if ( !qword_72EB1C0 )
          sub_25095A8();
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_72EB1C0 + 48LL))(qword_72EB1C0);
        atomic_store(0LL, (unsigned __int64 *)&qword_72FB250);
        byte_72FB240 = 1;
      }
    }
  }
  return v1;
}


================================================================================
Function: sub_65ED63C (0x65ED63C)
================================================================================

__int64 __fastcall sub_65ED63C(unsigned __int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x0
  __int64 v3; // x0
  __int64 v4; // x20
  char *v5; // x21
  unsigned __int64 v6; // x22
  atomic_ullong *v7; // x21
  unsigned __int64 v8; // x23
  unsigned __int64 v9; // t1
  unsigned __int64 v10; // x22
  unsigned __int64 v11; // x0
  unsigned __int8 v12; // w8
  __int64 v14; // [xsp+0h] [xbp-50h] BYREF
  _DWORD v15[10]; // [xsp+8h] [xbp-48h] BYREF
  _DWORD v16[6]; // [xsp+30h] [xbp-20h] BYREF

  if ( a1 > 0xFFFFFFFFFFFFFFF6LL )
    return 0LL;
  sub_65C1E64(0, 2, a1, 0, (__int64)&v14);
  v2 = sub_65C1E08(&v14);
  v3 = sub_67F449C(v2);
  v1 = v3;
  if ( v3 )
  {
    v4 = sub_67F49D4(v3);
    sub_65C1EE8((__int64)&v14, v4);
    sub_65FE394(v16, v15);
    sub_65FE3D8(v1, v4, v16);
    v5 = (char *)&unk_72EB200 + 64 * (unsigned __int64)v15[0];
    v6 = sub_6867420(v4, (atomic_ullong *)(v5 + 16));
    sub_6867420(1uLL, (atomic_ullong *)(v5 + 32));
    if ( sub_65C2030() )
    {
      v9 = *((_QWORD *)v5 + 6);
      v7 = (atomic_ullong *)(v5 + 48);
      v8 = v9;
      v10 = v6 + v4;
      if ( v9 < v10 )
      {
        do
        {
          v11 = sub_6866F60(v8, v10, v7);
          if ( v11 == v8 )
            break;
          v8 = v11;
        }
        while ( v11 < v10 );
      }
    }
    v12 = atomic_load((unsigned __int8 *)&byte_72FB240);
    if ( (v12 & 1) != 0 )
    {
      sub_6867420(v4, (atomic_ullong *)&qword_72FB250);
      if ( qword_72FB250 >= (unsigned __int64)qword_72FB248 && sub_6866D60(1, 0, (atomic_uchar *)&byte_72FB240) == 1 )
      {
        if ( !qword_72EB1C0 )
          sub_25095A8();
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_72EB1C0 + 48LL))(qword_72EB1C0);
        atomic_store(0LL, (unsigned __int64 *)&qword_72FB250);
        byte_72FB240 = 1;
      }
    }
  }
  return v1;
}


================================================================================
Function: sub_65EE1A8 (0x65EE1A8)
================================================================================

__int64 __fastcall sub_65EE1A8(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 v4; // x20
  __int64 v5; // x1
  unsigned __int8 v6; // w8
  __int64 v7; // x0
  __int64 v8; // x0
  __int64 v9; // x20
  char *v10; // x21
  unsigned __int64 v11; // x22
  atomic_ullong *v12; // x21
  unsigned __int64 v13; // x23
  unsigned __int64 v14; // t1
  unsigned __int64 v15; // x22
  unsigned __int64 v16; // x0
  unsigned __int8 v17; // w8
  __int64 v19; // [xsp+C0h] [xbp-68h] BYREF
  __int64 v20; // [xsp+C8h] [xbp-60h] BYREF
  int v21; // [xsp+F0h] [xbp-38h] BYREF
  __int64 v22; // [xsp+F8h] [xbp-30h]
  __int64 v23; // [xsp+100h] [xbp-28h]

  if ( a2 > 0xFFFFFFFFFFFFFFF6LL )
    return 0LL;
  sub_65C1E64(0, 1, a2, 0, (__int64)&v19);
  if ( a1 )
  {
    sub_65C1F84(0, 1, 0, (__int64)&v21);
    v4 = sub_67F49D4(a1);
    v22 = sub_65FE40C(a1, v4);
    v23 = v5;
    sub_6867420(-(__int64)v4, (atomic_ullong *)((char *)&unk_72EB200 + 64 * (unsigned __int64)(unsigned int)v22 + 16));
    v6 = atomic_load((unsigned __int8 *)&byte_72FB240);
    if ( (v6 & 1) != 0 && qword_72FB250 > v4 )
      sub_6867420(-(__int64)v4, (atomic_ullong *)&qword_72FB250);
    sub_65C1FA0((__int64)&v21, v4);
  }
  v7 = sub_65C1E08(&v19);
  v8 = sub_67F3BA8(a1, v7);
  v2 = v8;
  if ( v8 )
  {
    v9 = sub_67F49D4(v8);
    sub_65C1EE8((__int64)&v19, v9);
    sub_65FE394(&v21, &v20);
    sub_65FE3D8(v2, v9, &v21);
    v10 = (char *)&unk_72EB200 + 64 * (unsigned __int64)(unsigned int)v20;
    v11 = sub_6867420(v9, (atomic_ullong *)(v10 + 16));
    sub_6867420(1uLL, (atomic_ullong *)(v10 + 32));
    if ( sub_65C2030() )
    {
      v14 = *((_QWORD *)v10 + 6);
      v12 = (atomic_ullong *)(v10 + 48);
      v13 = v14;
      v15 = v11 + v9;
      if ( v14 < v15 )
      {
        do
        {
          v16 = sub_6866F60(v13, v15, v12);
          if ( v16 == v13 )
            break;
          v13 = v16;
        }
        while ( v16 < v15 );
      }
    }
    v17 = atomic_load((unsigned __int8 *)&byte_72FB240);
    if ( (v17 & 1) != 0 )
    {
      sub_6867420(v9, (atomic_ullong *)&qword_72FB250);
      if ( qword_72FB250 >= (unsigned __int64)qword_72FB248 && sub_6866D60(1, 0, (atomic_uchar *)&byte_72FB240) == 1 )
      {
        if ( !qword_72EB1C0 )
          sub_25095A8();
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_72EB1C0 + 48LL))(qword_72EB1C0);
        atomic_store(0LL, (unsigned __int64 *)&qword_72FB250);
        byte_72FB240 = 1;
      }
    }
  }
  return v2;
}


================================================================================
Function: sub_65EE9A8 (0x65EE9A8)
================================================================================

__int64 __fastcall sub_65EE9A8(unsigned __int64 a1)
{
  __int64 result; // x0
  _QWORD *v2; // x19

  result = sub_65ED488(a1);
  if ( !result )
  {
    v2 = (_QWORD *)sub_6861FD0(8LL);
    sub_6865270(v2);
    sub_6862048((__int64)v2, (__int64)&`typeinfo for'std::bad_alloc, (__int64)sub_6865238);
  }
  return result;
}


================================================================================
Function: sub_65EEA20 (0x65EEA20)
================================================================================

__int64 __fastcall sub_65EEA20(__int64 a1)
{
  return sub_65EC4D4(a1);
}


================================================================================
Function: sub_65EF3F8 (0x65EF3F8)
================================================================================

void *sub_65EF3F8()
{
  return &unk_72FB258;
}


================================================================================
Function: sub_65EF448 (0x65EF448)
================================================================================

__int64 __fastcall sub_65EF448(pthread_mutex_t *a1)
{
  unsigned __int64 v3; // x20
  __int64 result; // x0
  __int64 v5; // x0

  if ( !byte_724A7A8 )
    return sub_6848980(a1);
  if ( !byte_72FB278 || dword_72FB264 == 0 )
    return sub_6848980(a1);
  v3 = dword_72FB264;
  if ( sub_6867420(1uLL, (atomic_ullong *)&unk_72FB348) % v3 )
    return sub_6848980(a1);
  result = sub_68489AC(a1);
  if ( (result & 1) == 0 )
  {
    sub_65F7E10(result);
    v5 = sub_6848980(a1);
    sub_65F7E10(v5);
    JUMPOUT(0x65EF740LL);
  }
  return result;
}


================================================================================
Function: sub_65EF508 (0x65EF508)
================================================================================

__int64 __fastcall sub_65EF508(__int64 a1)
{
  unsigned __int64 v3; // x20
  __int64 result; // x0
  double v5; // d8
  __int64 v6; // x0
  double v7; // d0
  int v8; // w8
  int v9; // w9
  int v10; // w10
  int v11; // w11
  int v12; // w8
  int v13; // w9
  int v14; // w8
  int v15; // w10
  int v16; // w8
  int v17; // w11
  int v18; // w8
  int v19; // w9
  int v20; // w8
  int v21; // w10
  int v22; // w8
  int v23; // w11
  __int64 vars10; // [xsp+30h] [xbp+10h]
  __int64 vars18; // [xsp+38h] [xbp+18h]

  if ( !byte_724A7A8 )
    return sub_6848AE0(a1);
  if ( !byte_72FB278 || dword_72FB264 == 0 )
    return sub_6848AE0(a1);
  v3 = dword_72FB264;
  if ( sub_6867420(1uLL, (atomic_ullong *)&unk_72FB348) % v3 )
    return sub_6848AE0(a1);
  result = sub_6848B2C(a1);
  if ( (result & 1) == 0 )
  {
    v5 = ((double (*)(void))sub_65F7E10)();
    v6 = sub_6848AE0(a1);
    v7 = sub_65F7E10(v6) - v5;
    vars10 = vars18;
    result = sub_6867480(1LL, qword_72FB2B0, v7);
    if ( result == -1 )
    {
      do
      {
        atomic_store(0LL, qword_72FB2B0);
        atomic_store(0LL, &qword_72FB2B0[1]);
        atomic_store(0LL, &qword_72FB2B0[2]);
        atomic_store(0LL, &qword_72FB2B0[3]);
        atomic_store(0LL, &qword_72FB2B0[4]);
        atomic_store(0LL, &qword_72FB2B0[5]);
        atomic_store(0LL, &qword_72FB2B0[6]);
        atomic_store(0LL, &qword_72FB2B0[7]);
        atomic_store(0LL, &qword_72FB2B0[8]);
        atomic_store(0LL, &qword_72FB2B0[9]);
        v8 = atomic_load(qword_72FB2B0);
        v9 = atomic_load(&qword_72FB2B0[1]);
        v10 = atomic_load(&qword_72FB2B0[2]);
        v11 = atomic_load(&qword_72FB2B0[3]);
        v12 = v9 + v8;
        v13 = atomic_load(&qword_72FB2B0[4]);
        v14 = v12 + v10;
        v15 = atomic_load(&qword_72FB2B0[5]);
        v16 = v14 + v11;
        v17 = atomic_load(&qword_72FB2B0[6]);
        v18 = v16 + v13;
        v19 = atomic_load(&qword_72FB2B0[7]);
        v20 = v18 + v15;
        v21 = atomic_load(&qword_72FB2B0[8]);
        v22 = v20 + v17;
        v23 = atomic_load(&qword_72FB2B0[9]);
      }
      while ( v22 + v19 + v21 + v23 );
    }
  }
  return result;
}


================================================================================
Function: sub_65EFD58 (0x65EFD58)
================================================================================

__int64 __fastcall sub_65EFD58(unsigned int a1)
{
  int v1; // w8

  if ( a1 >= 8 )
    v1 = 8;
  else
    v1 = a1;
  return sub_65F04E4(off_6C27890[v1]);
}


================================================================================
Function: sub_65F04E4 (0x65F04E4)
================================================================================

__int64 __fastcall sub_65F04E4(_BYTE *a1, char *a2)
{
  __int64 result; // x0
  __int64 v5; // x3
  __int64 v6; // x4
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  long double v10; // q0
  long double v11; // q1
  long double v12; // q2
  long double v13; // q3
  char *v14; // x1
  unsigned __int64 v15; // x2
  char *v16; // x1
  unsigned __int64 v17; // x2
  __int64 v18; // [xsp+0h] [xbp-50h] BYREF
  unsigned __int64 v19; // [xsp+8h] [xbp-48h]
  char *v20; // [xsp+10h] [xbp-40h]
  _BYTE *v21; // [xsp+20h] [xbp-30h] BYREF
  unsigned __int64 v22; // [xsp+28h] [xbp-28h]
  char *v23; // [xsp+30h] [xbp-20h]
  __int64 v24; // [xsp+38h] [xbp-18h]

  if ( off_72FB408 )
  {
    result = off_72FB408(a1, a2);
    if ( (result & 1) == 0 )
      return result;
  }
  result = sub_65F0738();
  if ( !(_DWORD)result )
    return result;
  if ( a1 && a2 )
  {
    if ( *a1 )
    {
      if ( *a2 )
      {
        sub_65C5C5C(
          774LL,
          (__int64)"Unknown",
          (__int64)"[LOGCHANNELS + 1] RBXCRASH: %s (%s)",
          (__int64)a1,
          (__int64)a2,
          v7,
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v18);
        v21 = a1;
        v22 = 0LL;
        v23 = a2;
        v24 = 0LL;
        sub_6806FC8(&v18, "RBXCRASH: {} ({})\n", 18LL, 204LL, &v21);
        if ( (v18 & 1) != 0 )
          v14 = v20;
        else
          v14 = (char *)&v18 + 1;
        if ( (v18 & 1) != 0 )
          v15 = v19;
        else
          v15 = (unsigned __int64)(unsigned __int8)v18 >> 1;
        sub_2530DB0(&qword_79D77B0, v14, v15);
        if ( (v18 & 1) != 0 )
          goto LABEL_31;
        goto LABEL_32;
      }
      goto LABEL_18;
    }
  }
  else if ( a1 && *a1 )
  {
LABEL_18:
    sub_65C5C5C(
      774LL,
      (__int64)"Unknown",
      (__int64)"[LOGCHANNELS + 1] RBXCRASH: %s",
      (__int64)a1,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v18);
    v18 = (__int64)a1;
    v19 = 0LL;
    sub_6806FC8(&v21, "RBXCRASH: {}\n", 13LL, 12LL, &v18);
    if ( ((unsigned __int8)v21 & 1) != 0 )
      v16 = v23;
    else
      v16 = (char *)&v21 + 1;
    if ( ((unsigned __int8)v21 & 1) != 0 )
      v17 = v22;
    else
      v17 = (unsigned __int64)(unsigned __int8)v21 >> 1;
    goto LABEL_30;
  }
  sub_65C5C5C(
    774LL,
    (__int64)"Unknown",
    (__int64)"[LOGCHANNELS + 1] RBXCRASH",
    v5,
    v6,
    v7,
    v8,
    v9,
    v10,
    v11,
    v12,
    v13,
    v18);
  sub_6806FC8(&v21, "RBXCRASH\n", 9LL, 0LL, &v18);
  if ( ((unsigned __int8)v21 & 1) != 0 )
    v16 = v23;
  else
    v16 = (char *)&v21 + 1;
  if ( ((unsigned __int8)v21 & 1) != 0 )
    v17 = v22;
  else
    v17 = (unsigned __int64)(unsigned __int8)v21 >> 1;
LABEL_30:
  sub_2530DB0(&qword_79D77B0, v16, v17);
  if ( ((unsigned __int8)v21 & 1) != 0 )
LABEL_31:
    sub_65ECAF4();
LABEL_32:
  if ( byte_724A7A8 )
  {
    if ( byte_72FB398 )
      abort();
  }
  return raise(5);
}


================================================================================
Function: sub_65F0738 (0x65F0738)
================================================================================

__int64 sub_65F0738()
{
  return (unsigned __int8)byte_6CA9404;
}


================================================================================
Function: sub_65F0744 (0x65F0744)
================================================================================

__int64 sub_65F0744()
{
  return getpid();
}


================================================================================
Function: sub_65F07BC (0x65F07BC)
================================================================================

pthread_t sub_65F07BC()
{
  return pthread_self();
}


================================================================================
Function: sub_65F11C4 (0x65F11C4)
================================================================================

unsigned __int8 *__fastcall sub_65F11C4(unsigned __int8 *result, char *format, __int128 *a3)
{
  unsigned __int8 *v5; // x20
  int v6; // w0
  unsigned __int64 v7; // x9
  unsigned int v8; // w10
  __int64 v9; // x24
  unsigned __int64 v10; // x25
  __int128 v11; // q1
  unsigned __int8 *v12; // x8
  __int128 v13; // [xsp+10h] [xbp-40h]
  __int128 arg; // [xsp+20h] [xbp-30h] BYREF
  __int128 v15; // [xsp+30h] [xbp-20h]

  if ( format )
  {
    v5 = result;
    v13 = a3[1];
    arg = *a3;
    v15 = v13;
    v6 = vsnprintf(0LL, 0LL, format, &arg);
    v7 = *v5;
    v8 = v6 & ~(v6 >> 31);
    if ( v8 >= 0xF4240 )
      v9 = 1000000LL;
    else
      v9 = v8;
    if ( (v7 & 1) != 0 )
      v10 = *((_QWORD *)v5 + 1);
    else
      v10 = v7 >> 1;
    sub_684A708(v5, v10 + v9, 0);
    v11 = a3[1];
    if ( (*v5 & 1) != 0 )
      v12 = (unsigned __int8 *)*((_QWORD *)v5 + 2);
    else
      v12 = v5 + 1;
    arg = *a3;
    v15 = v11;
    vsnprintf((char *)&v12[v10], (unsigned int)(v9 + 1), format, &arg);
    return sub_684A708(v5, v10 + v9, 0);
  }
  return result;
}


================================================================================
Function: sub_65F12C8 (0x65F12C8)
================================================================================

void __noreturn sub_65F12C8(char *format, ...)
{
  _QWORD *v1; // x20
  gcc_va_list va1; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-38h] BYREF
  _QWORD v4[3]; // [xsp+108h] [xbp-18h] BYREF

  va_start(va, format);
  memset(v4, 0, sizeof(v4));
  va_copy(va1, va);
  sub_65F11C4((unsigned __int8 *)v4, format, (__int128 *)va1);
  v1 = (_QWORD *)sub_6861FD0(16LL);
  sub_68494D4(v1, (char *)v4);
  sub_6862048((__int64)v1, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_6865364);
}


================================================================================
Function: sub_65F13AC (0x65F13AC)
================================================================================

__int64 __usercall sub_65F13AC@<X0>(char *format@<X0>, _QWORD *a2@<X8>, ...)
{
  gcc_va_list va1; // [xsp+C0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-28h] BYREF

  va_start(va, a2);
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  va_copy(va1, va);
  return sub_65F11C4((int)a2, format);
}


================================================================================
Function: sub_65F15A8 (0x65F15A8)
================================================================================

__int64 __fastcall sub_65F15A8(int a1, int a2)
{
  int v2; // w8

  v2 = a1 - 1;
  if ( a1 - 1 >= a2 )
    v2 = a2;
  return v2 & (unsigned int)~(v2 >> 31);
}


================================================================================
Function: sub_65F1628 (0x65F1628)
================================================================================

unsigned __int64 sub_65F1628()
{
  __int64 v0; // x21
  __int64 v1; // x21
  __int64 v2; // x0
  __int64 v3; // x21
  int v4; // w0
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x10
  unsigned __int64 v8; // [xsp+0h] [xbp-10h] BYREF

  v8 = qword_72FB448;
  if ( !qword_72FB448 )
  {
    v0 = 7 * sub_6819D00();
    v1 = v0 ^ (97 * sub_6819C28());
    v2 = sub_65F0744();
    v3 = (997LL * (int)v2) ^ v1 ^ (1997 * sub_65F07BC(v2));
    v8 = (unsigned __int64)&v8 ^ ((_QWORD)&qword_72FB448 << 32) ^ (19997 * sub_65F7B88()) ^ v3;
  }
  v4 = sub_68673F0(1u, (atomic_uint *)&unk_72FB450);
  v5 = v8 ^ (unsigned int)(2 * v4);
  v6 = 0x5851F42D4C957F2DLL * v5 + 105;
  qword_72FB448 = 0x5851F42D4C957F2DLL * v6 + 105;
  return (unsigned int)__ROR4__((v5 >> 27) ^ (v8 >> 45), v8 >> 59) | ((unsigned __int64)(unsigned int)__ROR4__((v6 >> 45) ^ (v6 >> 27), v6 >> 59) << 32);
}


================================================================================
Function: sub_65F1790 (0x65F1790)
================================================================================

__int64 sub_65F1790()
{
  unsigned __int8 v0; // w8
  unsigned __int8 v1; // w8
  unsigned int v2; // w19

  v0 = atomic_load(byte_72FB490);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB490) )
  {
    __cxa_atexit((void (*)(void *))sub_6848C84, &stru_72FB468, &off_686E780);
    sub_6862850(byte_72FB490);
  }
  sub_6848980(&stru_72FB468);
  v1 = atomic_load(byte_72FB460);
  if ( (v1 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB460) )
  {
    qword_72FB458 = sub_65F1628();
    sub_6862850(byte_72FB460);
  }
  v2 = __ROR4__(
         ((unsigned __int64)qword_72FB458 >> 45) ^ ((unsigned __int64)qword_72FB458 >> 27),
         (unsigned __int64)qword_72FB458 >> 59);
  qword_72FB458 = 0x5851F42D4C957F2DLL * qword_72FB458 + 105;
  sub_68489D4(&stru_72FB468);
  return v2;
}


================================================================================
Function: sub_65F3D60 (0x65F3D60)
================================================================================

unsigned int **__fastcall sub_65F3D60(unsigned int **result)
{
  unsigned int *v1; // x20
  unsigned int v2; // w21
  unsigned int ***v3; // x19
  unsigned int **v4; // [xsp+0h] [xbp-10h]

  v1 = *result;
  if ( *result )
  {
    v2 = atomic_load(v1);
    if ( v2 )
    {
      v3 = (unsigned int ***)result;
      while ( 1 )
      {
        result = (unsigned int **)sub_6866F20(v2, v2 + 1, v1);
        if ( (_DWORD)result == v2 )
          break;
        v2 = (unsigned int)result;
        if ( !(_DWORD)result )
          return result;
      }
      result = *v3;
      v4 = *v3;
      if ( *v3 )
      {
        sub_65F3E68();
        result = (unsigned int **)sub_68673F0(0xFFFFFFFFLL, v4);
        if ( (_DWORD)result == 1 )
        {
          sub_65F4714(v4);
          result = (unsigned int **)sub_68673F0(0xFFFFFFFFLL, (char *)v4 + 4);
          if ( (_DWORD)result == 1 )
            return (unsigned int **)sub_65F582C(v4);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_65F3E68 (0x65F3E68)
================================================================================

__int64 __fastcall sub_65F3E68(__int64 a1)
{
  unsigned __int8 v2; // w8
  pthread_mutex_t *v3; // x20
  unsigned int *v4; // x21
  unsigned int v5; // w22
  unsigned int v6; // w0
  __int64 v8; // x0

  v2 = atomic_load(byte_72FB5C8);
  if ( (v2 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB5C8) )
  {
    v8 = sub_65ECAAC();
    *(_QWORD *)(v8 + 32) = 0LL;
    qword_72FB5C0 = v8;
    *(_OWORD *)v8 = 0u;
    *(_OWORD *)(v8 + 16) = 0u;
    sub_6862850(byte_72FB5C8);
  }
  v3 = (pthread_mutex_t *)qword_72FB5C0;
  sub_6848980((pthread_mutex_t *)qword_72FB5C0);
  v4 = *(unsigned int **)(a1 + 32);
  if ( v4 )
  {
    v5 = atomic_load(v4);
    if ( v5 )
    {
      while ( 1 )
      {
        v6 = sub_6866F20(v5, v5 + 1, (atomic_uint *)v4);
        if ( v6 == v5 )
          break;
        v5 = v6;
        if ( !v6 )
        {
          v4 = 0LL;
          goto LABEL_8;
        }
      }
      v4 = *(unsigned int **)(a1 + 32);
    }
    else
    {
      v4 = 0LL;
    }
  }
LABEL_8:
  if ( !v4 )
    return sub_68489D4(v3);
  sub_65F4610(v4, a1);
  sub_68489D4(v3);
  return sub_65F5D5C(v4);
}


================================================================================
Function: sub_65F43C0 (0x65F43C0)
================================================================================

bool __fastcall sub_65F43C0(unsigned int **a1, unsigned int **a2)
{
  unsigned int *v2; // x21
  unsigned int v4; // w22
  unsigned int v6; // w0
  unsigned int *v7; // x19
  unsigned int *v8; // x21
  unsigned int v9; // w22
  unsigned int v10; // w0
  unsigned int *v11; // x20

  v2 = *a1;
  if ( *a1 && (v4 = atomic_load(v2)) != 0 )
  {
    while ( 1 )
    {
      v6 = sub_6866F20(v4, v4 + 1, v2);
      if ( v6 == v4 )
        break;
      v4 = v6;
      if ( !v6 )
        goto LABEL_5;
    }
    v7 = *a1;
    v8 = *a2;
    if ( !*a2 )
      goto LABEL_11;
  }
  else
  {
LABEL_5:
    v7 = 0LL;
    v8 = *a2;
    if ( !*a2 )
    {
LABEL_11:
      v11 = 0LL;
      goto LABEL_12;
    }
  }
  v9 = atomic_load(v8);
  if ( !v9 )
    goto LABEL_11;
  while ( 1 )
  {
    v10 = sub_6866F20(v9, v9 + 1, v8);
    if ( v10 == v9 )
      break;
    v9 = v10;
    if ( !v10 )
      goto LABEL_11;
  }
  v11 = *a2;
  if ( v11 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFFLL, v11) == 1 )
    {
      sub_65F4714(v11);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFFLL, v11 + 1) == 1 )
        sub_65F582C(v11);
    }
  }
LABEL_12:
  if ( v7 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFFLL, v7) == 1 )
    {
      sub_65F4714(v7);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFFLL, v7 + 1) == 1 )
        sub_65F582C(v7);
    }
  }
  return v7 != v11;
}


================================================================================
Function: sub_65F44E8 (0x65F44E8)
================================================================================

__int64 *__fastcall sub_65F44E8(__int64 *a1, __int64 *a2)
{
  __int64 v3; // x20
  __int64 v4; // x21

  v3 = *a1;
  v4 = *a2;
  if ( *a1 && (unsigned int)sub_68673F0(0xFFFFFFFFLL, v3 + 4) == 1 )
    sub_65F582C(v3);
  *a1 = v4;
  if ( v4 )
    sub_68673F0(1LL, v4 + 4);
  return a1;
}


================================================================================
Function: sub_65F4610 (0x65F4610)
================================================================================

__int64 __fastcall sub_65F4610(__int64 result, _QWORD *a2)
{
  __int64 v3; // x21
  __int64 v4; // x20
  unsigned int v5; // w21
  int v6; // w22
  __int64 v7; // x8
  __int64 *v8; // x9
  __int64 v9; // x20

  v3 = a2[4];
  v4 = result;
  a2[4] = 0LL;
  if ( v3 )
  {
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v3 + 4));
    if ( (_DWORD)result == 1 )
      result = sub_65F52D0(v3);
  }
  v5 = *(_DWORD *)(v4 + 20);
  v6 = *(_DWORD *)(v4 + 16);
  if ( (v6 & v5) != 0 )
  {
    while ( 1 )
    {
      result = sub_6866E60(v5, v5 | 0x80000000, (atomic_uint *)(v4 + 20));
      if ( (_DWORD)result == v5 )
        break;
      v5 = result;
      if ( (v6 & (unsigned int)result) == 0 )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v7 = a2[2];
    if ( v7 )
      *(_QWORD *)(v7 + 24) = a2[3] & 0xFFFFFFFFFFFFFFF8LL | *(_QWORD *)(v7 + 24) & 7LL;
    v8 = (__int64 *)((a2[3] & 0xFFFFFFFFFFFFFFF8LL) + 16);
    if ( (a2[3] & 0xFFFFFFFFFFFFFFF8LL) == 0 )
      v8 = (__int64 *)(v4 + 8);
    v9 = *v8;
    *v8 = v7;
    a2[2] = 0LL;
    if ( v9 )
    {
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)v9);
      if ( (_DWORD)result == 1 )
      {
        sub_65F4714(v9);
        result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v9 + 4));
        if ( (_DWORD)result == 1 )
          return sub_65F582C((__int64 *)v9);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_65F4714 (0x65F4714)
================================================================================

__int64 __fastcall sub_65F4714(__int64 result)
{
  __int64 v1; // x19
  __int64 v2; // x20
  __int64 v3; // x19

  v1 = result;
  if ( (*(_BYTE *)(result + 24) & 4) != 0 )
    result = (*(__int64 (__fastcall **)(__int64))(result + 40))(result);
  v2 = *(_QWORD *)(v1 + 32);
  if ( v2 )
  {
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v2 + 4));
    if ( (_DWORD)result == 1 )
      result = sub_65F52D0(v2);
  }
  v3 = *(_QWORD *)(v1 + 16);
  if ( v3 )
  {
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)v3);
    if ( (_DWORD)result == 1 )
    {
      sub_65F4714(v3);
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v3 + 4));
      if ( (_DWORD)result == 1 )
        return sub_65F582C((__int64 *)v3);
    }
  }
  return result;
}


================================================================================
Function: sub_65F488C (0x65F488C)
================================================================================

__int64 __fastcall sub_65F488C(__int64 a1)
{
  unsigned __int8 v2; // w8
  pthread_mutex_t *v3; // x19
  unsigned int v4; // w21
  int v5; // w23
  unsigned int v6; // w0
  __int64 v7; // x21
  __int64 i; // x21
  __int64 result; // x0
  __int64 v10; // x8
  __int64 v11; // x20
  __int64 v12; // x0
  __int64 v13; // [xsp+0h] [xbp-10h]

  v2 = atomic_load(byte_72FB5C8);
  if ( (v2 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB5C8) )
  {
    v12 = sub_65ECAAC();
    *(_QWORD *)(v12 + 32) = 0LL;
    qword_72FB5C0 = v12;
    *(_OWORD *)v12 = 0u;
    *(_OWORD *)(v12 + 16) = 0u;
    sub_6862850(byte_72FB5C8);
  }
  v3 = (pthread_mutex_t *)qword_72FB5C0;
  sub_6848980((pthread_mutex_t *)qword_72FB5C0);
  v4 = *(_DWORD *)(a1 + 20);
  v5 = *(_DWORD *)(a1 + 16);
  if ( (v5 & v4) != 0 )
  {
    while ( 1 )
    {
      v6 = sub_6866E60(v4, v4 | 0x80000000, (atomic_uint *)(a1 + 20));
      if ( v6 == v4 )
        break;
      v4 = v6;
      if ( (v5 & v6) == 0 )
        goto LABEL_5;
    }
    for ( i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(i + 16) )
    {
      v11 = *(_QWORD *)(i + 32);
      *(_QWORD *)(i + 32) = 0LL;
      if ( v11 && (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v11 + 4)) == 1 )
        sub_65F52D0((__int64 *)v11);
    }
    v7 = 0LL;
  }
  else
  {
LABEL_5:
    v7 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 8) = 0LL;
  }
  result = sub_68489D4(v3);
  if ( v7 )
  {
    do
    {
      v10 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v7 + 16) = 0LL;
      v13 = v10;
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)v7);
      if ( (_DWORD)result == 1 )
      {
        sub_65F4714(v7);
        result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 4));
        if ( (_DWORD)result == 1 )
          result = sub_65F582C((__int64 *)v7);
      }
      v7 = v13;
    }
    while ( v13 );
  }
  return result;
}


================================================================================
Function: sub_65F4B5C (0x65F4B5C)
================================================================================

__int64 __fastcall sub_65F4B5C(__int64 a1, __int64 a2)
{
  unsigned __int8 v4; // w8
  pthread_mutex_t *v5; // x20
  __int64 v6; // x23
  __int64 v7; // x22
  __int64 v8; // x8
  __int64 v9; // x21
  __int64 v11; // x0

  *(_QWORD *)(a2 + 24) &= 7uLL;
  v4 = atomic_load(byte_72FB5C8);
  if ( (v4 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB5C8) )
  {
    v11 = sub_65ECAAC();
    *(_QWORD *)(v11 + 32) = 0LL;
    qword_72FB5C0 = v11;
    *(_OWORD *)v11 = 0u;
    *(_OWORD *)(v11 + 16) = 0u;
    sub_6862850(byte_72FB5C8);
  }
  v5 = (pthread_mutex_t *)qword_72FB5C0;
  sub_6848980((pthread_mutex_t *)qword_72FB5C0);
  v6 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0LL;
  sub_68673F0(1u, (atomic_uint *)a2);
  v7 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2;
  if ( v7 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)v7) == 1 )
    {
      sub_65F4714(v7);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 4)) == 1 )
        sub_65F582C((__int64 *)v7);
    }
  }
  if ( v6 )
  {
    v8 = *(_QWORD *)(v6 + 24);
    v9 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = v6;
    *(_QWORD *)(v6 + 24) = v8 & 7 | a2;
    if ( v9 )
    {
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)v9) == 1 )
      {
        sub_65F4714(v9);
        if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v9 + 4)) == 1 )
          sub_65F582C((__int64 *)v9);
      }
    }
  }
  return sub_68489D4(v5);
}


================================================================================
Function: sub_65F5110 (0x65F5110)
================================================================================

__int64 sub_65F5110()
{
  unsigned __int8 v0; // w8
  __int64 v1; // x20
  unsigned __int64 v2; // x22
  unsigned __int64 v3; // x21
  __int64 v4; // x8
  unsigned __int64 v5; // x8
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x0
  unsigned int v10; // w21
  unsigned int v11; // w0
  _QWORD *v12; // x20

  v0 = atomic_load(byte_72FB5F8);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB5F8) )
  {
    v12 = (_QWORD *)sub_65ECAAC();
    memset(v12, 0, 0x15F910uLL);
    qword_72FB5F0 = (__int64)v12;
    v12[1] = 0xFFFFFFFFLL;
    sub_6862850(byte_72FB5F8);
  }
  v1 = qword_72FB5F0;
  v2 = qword_72FB5F0 + 16;
  v3 = atomic_load((unsigned __int64 *)(qword_72FB5F0 + 8));
  if ( (unsigned int)v3 >> 5 <= 0x752uLL )
  {
    v4 = (unsigned int)v3;
    while ( 1 )
    {
      v5 = *(_QWORD *)(v2 + 24 * v4);
      if ( v2 <= v5 && v1 + 1440016 > v5 )
      {
        v7 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - v2) >> 3);
        if ( v7 >= 0xFFFFFFFF )
          v7 = 0xFFFFFFFFLL;
      }
      else
      {
        v7 = 0xFFFFFFFFLL;
      }
      v8 = sub_6867020(v3, v7 | v3 & 0xFFFFFFFF00000000LL, (atomic_ullong *)(v1 + 8));
      if ( v8 == v3 )
        break;
      v4 = (unsigned int)v8;
      v3 = v8;
      if ( (unsigned int)v8 >> 5 >= 0x753uLL )
        goto LABEL_16;
    }
    if ( (unsigned int)v3 >> 5 < 0x753uLL )
      return v2 + 24LL * (unsigned int)v3;
  }
LABEL_16:
  v10 = *(_DWORD *)v1;
  if ( *(_DWORD *)v1 >> 5 > 0x752u )
    return sub_65ECAAC();
  while ( 1 )
  {
    v11 = sub_6866E60(v10, v10 + 1, (atomic_uint *)v1);
    if ( v11 == v10 )
      break;
    v10 = v11;
    if ( v11 >> 5 >= 0x753 )
      return sub_65ECAAC();
  }
  return v2 + 24LL * v10;
}


================================================================================
Function: sub_65F52D0 (0x65F52D0)
================================================================================

unsigned __int64 __fastcall sub_65F52D0(__int64 *a1)
{
  unsigned __int8 v2; // w8
  bool v4; // zf
  unsigned __int64 result; // x0
  unsigned __int8 v6; // w8
  __int64 v7; // x22
  unsigned __int64 v8; // x24
  __int64 v9; // x23
  unsigned __int64 v10; // x21
  __int64 v11; // x8
  unsigned __int64 v12; // x20
  __int64 v13; // x8
  _QWORD *v14; // x20
  _QWORD *v15; // x20

  v2 = atomic_load(byte_72FB5F8);
  if ( (v2 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB5F8) )
  {
    v14 = (_QWORD *)sub_65ECAAC();
    memset(v14, 0, 0x15F910uLL);
    qword_72FB5F0 = (__int64)v14;
    v14[1] = 0xFFFFFFFFLL;
    sub_6862850(byte_72FB5F8);
  }
  v4 = (unsigned __int64)a1 < qword_72FB5F0 + 16
    || qword_72FB5F0 + 1440016 <= (unsigned __int64)a1
    || (__int64 *)((char *)a1 - qword_72FB5F0 - 16) == (__int64 *)0x17FFFFFFE8LL;
  if ( v4 )
    return sub_65ECAF4();
  v6 = atomic_load(byte_72FB5F8);
  if ( (v6 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB5F8) )
  {
    v15 = (_QWORD *)sub_65ECAAC();
    memset(v15, 0, 0x15F910uLL);
    qword_72FB5F0 = (__int64)v15;
    v15[1] = 0xFFFFFFFFLL;
    sub_6862850(byte_72FB5F8);
  }
  v7 = qword_72FB5F0;
  v8 = 0xFFFFFFFFLL;
  v9 = qword_72FB5F0 + 16;
  if ( qword_72FB5F0 + 16 <= (unsigned __int64)a1 && qword_72FB5F0 + 1440016 > (unsigned __int64)a1 )
  {
    if ( 0xAAAAAAAAAAAAAAABLL * (((__int64)a1 - v9) >> 3) >= 0xFFFFFFFF )
      v8 = 0xFFFFFFFFLL;
    else
      v8 = 0xAAAAAAAAAAAAAAABLL * (((__int64)a1 - v9) >> 3);
  }
  v10 = *(_QWORD *)(qword_72FB5F0 + 8);
  v11 = v9 + 24LL * (unsigned int)v10;
  if ( (unsigned int)v10 >> 5 >= 0x753uLL )
    v11 = 0LL;
  *a1 = v11;
  result = sub_6866FE0(v10, (v10 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v8, (atomic_ullong *)(v7 + 8));
  if ( result != v10 )
  {
    v12 = result;
    do
    {
      v13 = v9 + 24LL * (unsigned int)v12;
      if ( (unsigned int)v12 >> 5 >= 0x753uLL )
        v13 = 0LL;
      *a1 = v13;
      result = sub_6866FE0(v12, (v12 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v8, (atomic_ullong *)(v7 + 8));
      v4 = result == v12;
      v12 = result;
    }
    while ( !v4 );
  }
  return result;
}


================================================================================
Function: sub_65F54E8 (0x65F54E8)
================================================================================

__int64 __fastcall sub_65F54E8(__int64 a1)
{
  unsigned __int8 v1; // w8
  __int64 v2; // x20
  unsigned __int64 v3; // x22
  unsigned __int64 v4; // x21
  __int64 v5; // x8
  unsigned __int64 v6; // x24
  unsigned __int64 v7; // x8
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x0
  unsigned __int8 v11; // w8
  __int64 v12; // x20
  unsigned __int64 v13; // x21
  __int64 v14; // x8
  unsigned __int64 v15; // x24
  unsigned __int64 v16; // x8
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x0
  unsigned int v21; // w21
  unsigned int v22; // w0
  unsigned int v23; // w0
  unsigned int v24; // w8
  _QWORD *v25; // x20
  _QWORD *v26; // x20

  if ( a1 == 48 )
  {
    v11 = atomic_load(byte_72FB618);
    if ( (v11 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB618) )
    {
      v26 = (_QWORD *)sub_65ECAAC();
      memset(v26, 0, 0x15F910uLL);
      qword_72FB610 = (__int64)v26;
      v26[1] = 0xFFFFFFFFLL;
      sub_6862850(byte_72FB618);
    }
    v12 = qword_72FB610;
    v3 = qword_72FB610 + 16;
    v13 = atomic_load((unsigned __int64 *)(qword_72FB610 + 8));
    if ( (unsigned int)v13 >> 4 <= 0x752uLL )
    {
      v14 = (unsigned int)v13;
      v15 = qword_72FB610 + 1440016;
      while ( 1 )
      {
        v16 = *(_QWORD *)(v3 + 48 * v14);
        if ( v3 <= v16 && v15 > v16 )
        {
          v18 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v16 - v3) >> 4);
          if ( v18 >= 0xFFFFFFFF )
            v18 = 0xFFFFFFFFLL;
        }
        else
        {
          v18 = 0xFFFFFFFFLL;
        }
        v19 = sub_6867020(v13, v18 | v13 & 0xFFFFFFFF00000000LL, (atomic_ullong *)(v12 + 8));
        if ( v19 == v13 )
          break;
        v14 = (unsigned int)v19;
        v13 = v19;
        if ( (unsigned int)v19 >> 4 >= 0x753uLL )
          goto LABEL_37;
      }
      if ( (unsigned int)v13 >> 4 < 0x753uLL )
        return v3 + 48LL * (unsigned int)v13;
    }
LABEL_37:
    v21 = *(_DWORD *)v12;
    if ( *(_DWORD *)v12 >> 4 <= 0x752u )
    {
      while ( 1 )
      {
        v23 = sub_6866E60(v21, v21 + 1, (atomic_uint *)v12);
        if ( v23 == v21 )
          break;
        v21 = v23;
        if ( v23 >> 4 >= 0x753 )
          return sub_65ECAAC();
      }
      v24 = 48;
      return v3 + v21 * (unsigned __int64)v24;
    }
    return sub_65ECAAC();
  }
  if ( a1 != 56 )
    return sub_65ECAAC();
  v1 = atomic_load(byte_72FB608);
  if ( (v1 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB608) )
  {
    v25 = (_QWORD *)sub_65ECAAC();
    memset(v25, 0, 0x334510uLL);
    qword_72FB600 = (__int64)v25;
    v25[1] = 0xFFFFFFFFLL;
    sub_6862850(byte_72FB608);
  }
  v2 = qword_72FB600;
  v3 = qword_72FB600 + 16;
  v4 = atomic_load((unsigned __int64 *)(qword_72FB600 + 8));
  if ( (unsigned int)v4 >> 5 <= 0x752uLL )
  {
    v5 = (unsigned int)v4;
    v6 = qword_72FB600 + 3360016;
    while ( 1 )
    {
      v7 = *(_QWORD *)(v3 + 56 * v5);
      if ( v3 <= v7 && v6 > v7 )
      {
        v9 = 0x6DB6DB6DB6DB6DB7LL * ((__int64)(v7 - v3) >> 3);
        if ( v9 >= 0xFFFFFFFF )
          v9 = 0xFFFFFFFFLL;
      }
      else
      {
        v9 = 0xFFFFFFFFLL;
      }
      v10 = sub_6867020(v4, v9 | v4 & 0xFFFFFFFF00000000LL, (atomic_ullong *)(v2 + 8));
      if ( v10 == v4 )
        break;
      v5 = (unsigned int)v10;
      v4 = v10;
      if ( (unsigned int)v10 >> 5 >= 0x753uLL )
        goto LABEL_31;
    }
    if ( (unsigned int)v4 >> 5 < 0x753uLL )
      return v3 + 56LL * (unsigned int)v4;
  }
LABEL_31:
  v21 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 >> 5 > 0x752u )
    return sub_65ECAAC();
  while ( 1 )
  {
    v22 = sub_6866E60(v21, v21 + 1, (atomic_uint *)v2);
    if ( v22 == v21 )
      break;
    v21 = v22;
    if ( v22 >> 5 >= 0x753 )
      return sub_65ECAAC();
  }
  v24 = 56;
  return v3 + v21 * (unsigned __int64)v24;
}


================================================================================
Function: sub_65F582C (0x65F582C)
================================================================================

__int64 __fastcall sub_65F582C(__int64 *a1)
{
  unsigned __int8 v2; // w8
  bool v4; // zf
  unsigned __int8 v5; // w8
  unsigned __int8 v6; // w8
  __int64 v7; // x22
  unsigned __int64 v8; // x24
  __int64 v9; // x23
  __int64 v10; // x21
  __int64 v11; // x8
  __int64 result; // x0
  __int64 v13; // x20
  __int64 v14; // x8
  unsigned __int8 v15; // w8
  __int64 v16; // x22
  __int64 v17; // x24
  __int64 v18; // x23
  __int64 v19; // x21
  __int64 v20; // x2
  __int64 v21; // x8
  __int64 v22; // x20
  __int64 v23; // x8
  _QWORD *v24; // x20
  _QWORD *v25; // x20
  _QWORD *v26; // x20
  _QWORD *v27; // x20

  v2 = atomic_load(byte_72FB608);
  if ( (v2 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB608) )
  {
    v24 = (_QWORD *)sub_65ECAAC();
    memset(v24, 0, 0x334510uLL);
    qword_72FB600 = (__int64)v24;
    v24[1] = 0xFFFFFFFFLL;
    sub_6862850(byte_72FB608);
  }
  v4 = (unsigned __int64)a1 < qword_72FB600 + 16
    || qword_72FB600 + 3360016 <= (unsigned __int64)a1
    || (__int64 *)((char *)a1 - qword_72FB600 - 16) == (__int64 *)0x37FFFFFFC8LL;
  if ( v4 )
  {
    v5 = atomic_load(byte_72FB618);
    if ( (v5 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB618) )
    {
      v25 = (_QWORD *)sub_65ECAAC();
      memset(v25, 0, 0x15F910uLL);
      qword_72FB610 = (__int64)v25;
      v25[1] = 0xFFFFFFFFLL;
      sub_6862850(byte_72FB618);
    }
    if ( (unsigned __int64)a1 < qword_72FB610 + 16
      || qword_72FB610 + 1440016 <= (unsigned __int64)a1
      || (__int64 *)((char *)a1 - qword_72FB610 - 16) == (__int64 *)0x2FFFFFFFD0LL )
    {
      return sub_65ECAF4();
    }
    else
    {
      v6 = atomic_load(byte_72FB618);
      if ( (v6 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB618) )
      {
        v27 = (_QWORD *)sub_65ECAAC();
        memset(v27, 0, 0x15F910uLL);
        qword_72FB610 = (__int64)v27;
        v27[1] = 0xFFFFFFFFLL;
        sub_6862850(byte_72FB618);
      }
      v7 = qword_72FB610;
      v8 = 0xFFFFFFFFLL;
      v9 = qword_72FB610 + 16;
      if ( qword_72FB610 + 16 <= (unsigned __int64)a1 && qword_72FB610 + 1440016 > (unsigned __int64)a1 )
      {
        if ( 0xAAAAAAAAAAAAAAABLL * (((__int64)a1 - v9) >> 4) >= 0xFFFFFFFF )
          v8 = 0xFFFFFFFFLL;
        else
          v8 = 0xAAAAAAAAAAAAAAABLL * (((__int64)a1 - v9) >> 4);
      }
      v10 = *(_QWORD *)(qword_72FB610 + 8);
      v11 = v9 + 48LL * (unsigned int)v10;
      if ( (unsigned int)v10 >> 4 >= 0x753uLL )
        v11 = 0LL;
      *a1 = v11;
      result = sub_6866FE0(v10, (v10 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v8, v7 + 8);
      if ( result != v10 )
      {
        v13 = result;
        do
        {
          v14 = v9 + 48LL * (unsigned int)v13;
          if ( (unsigned int)v13 >> 4 >= 0x753uLL )
            v14 = 0LL;
          *a1 = v14;
          result = sub_6866FE0(v13, (v13 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v8, v7 + 8);
          v4 = result == v13;
          v13 = result;
        }
        while ( !v4 );
      }
    }
  }
  else
  {
    v15 = atomic_load(byte_72FB608);
    if ( (v15 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB608) )
    {
      v26 = (_QWORD *)sub_65ECAAC();
      memset(v26, 0, 0x334510uLL);
      qword_72FB600 = (__int64)v26;
      v26[1] = 0xFFFFFFFFLL;
      sub_6862850(byte_72FB608);
    }
    v16 = qword_72FB600;
    v17 = 0xFFFFFFFFLL;
    v18 = qword_72FB600 + 16;
    if ( qword_72FB600 + 16 <= (unsigned __int64)a1 && qword_72FB600 + 3360016 > (unsigned __int64)a1 )
    {
      if ( (unsigned __int64)(0x6DB6DB6DB6DB6DB7LL * (((__int64)a1 - v18) >> 3)) >= 0xFFFFFFFF )
        v17 = 0xFFFFFFFFLL;
      else
        v17 = 0x6DB6DB6DB6DB6DB7LL * (((__int64)a1 - v18) >> 3);
    }
    v19 = *(_QWORD *)(qword_72FB600 + 8);
    v20 = qword_72FB600 + 8;
    v21 = v18 + 56LL * (unsigned int)v19;
    if ( (unsigned int)v19 >> 5 >= 0x753uLL )
      v21 = 0LL;
    *a1 = v21;
    result = sub_6866FE0(v19, (v19 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v17, v20);
    if ( result != v19 )
    {
      v22 = result;
      do
      {
        v23 = v18 + 56LL * (unsigned int)v22;
        if ( (unsigned int)v22 >> 5 >= 0x753uLL )
          v23 = 0LL;
        *a1 = v23;
        result = sub_6866FE0(v22, (v22 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v17, v16 + 8);
        v4 = result == v22;
        v22 = result;
      }
      while ( !v4 );
    }
  }
  return result;
}


================================================================================
Function: sub_65F5C18 (0x65F5C18)
================================================================================

__int64 *__fastcall sub_65F5C18(__int64 *result)
{
  __int64 *v1; // x20
  int v2; // w19
  unsigned __int8 v3; // w8
  pthread_mutex_t *v4; // x21
  __int64 v5; // x22
  __int64 v6; // x0
  __int64 v7; // x0

  if ( *result )
  {
    __dmb(9u);
  }
  else
  {
    v1 = result;
    v2 = sub_65EBFB8(dword_72FB548);
    v3 = atomic_load(byte_72FB5C8);
    if ( (v3 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_72FB5C8) )
    {
      v7 = sub_65ECAAC();
      *(_QWORD *)(v7 + 32) = 0LL;
      qword_72FB5C0 = v7;
      *(_OWORD *)v7 = 0u;
      *(_OWORD *)(v7 + 16) = 0u;
      sub_6862850(byte_72FB5C8);
    }
    v4 = (pthread_mutex_t *)qword_72FB5C0;
    sub_6848980((pthread_mutex_t *)qword_72FB5C0);
    if ( !*v1 )
    {
      v5 = sub_65F5110(24LL);
      *(_QWORD *)v5 = 0LL;
      *(_QWORD *)(v5 + 8) = 0LL;
      *(_DWORD *)(v5 + 4) = 1;
      *(_QWORD *)(v5 + 16) = 0x7FFFFFFFLL;
      __dmb(0xBu);
      sub_68673F0(1u, (atomic_uint *)v5);
      v6 = *v1;
      *v1 = v5;
      if ( v6 )
        sub_65F5D5C(v6);
    }
    sub_68489D4(v4);
    return (__int64 *)sub_65EBFB8(v2);
  }
  return result;
}


================================================================================
Function: sub_65F5D5C (0x65F5D5C)
================================================================================

__int64 __fastcall sub_65F5D5C(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x20

  result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)a1);
  if ( (_DWORD)result == 1 )
  {
    sub_65F488C(a1);
    v3 = *(_QWORD *)(a1 + 8);
    if ( v3 )
    {
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, *(atomic_uint **)(a1 + 8)) == 1 )
      {
        sub_65F4714(v3);
        if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v3 + 4)) == 1 )
          sub_65F582C((__int64 *)v3);
      }
    }
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(a1 + 4));
    if ( (_DWORD)result == 1 )
      return sub_65F52D0(a1);
  }
  return result;
}


================================================================================
Function: sub_65F6474 (0x65F6474)
================================================================================

__int64 __fastcall sub_65F6474(__int64 *a1, char *s2, size_t n, unsigned __int64 a4)
{
  unsigned __int64 v5; // x8
  size_t v6; // x2
  unsigned __int64 v7; // x22
  __int64 result; // x0
  __int64 v9; // x25
  size_t v11; // x21
  unsigned __int8 *v12; // x20
  void *v13; // x0
  size_t v14; // x26
  __int64 v15; // x8
  __int64 v16; // x10
  char v17; // w11
  int v18; // w22
  __int64 v19; // x27
  _OWORD v20[14]; // [xsp+0h] [xbp-110h]
  int8x16_t v21; // [xsp+E0h] [xbp-30h]
  int8x16_t v22; // [xsp+F0h] [xbp-20h]

  v5 = a1[1];
  v6 = v5 - a4;
  if ( v5 < a4 )
    return -1LL;
  v7 = a4;
  if ( !n )
    return v7;
  if ( v6 < n )
    return -1LL;
  v9 = *a1;
  v11 = n - 1;
  v12 = (unsigned __int8 *)(*a1 + a4);
  if ( n == 1 )
  {
    v13 = memchr((const void *)(*a1 + a4), *s2, v6);
    if ( v13 )
      return (__int64)v13 - v9;
    else
      return -1LL;
  }
  v14 = (size_t)&v12[v6 - n + 1];
  if ( n > 0xFF || v6 <= 0xF )
  {
    while ( memcmp((const void *)(v9 + v7), s2, n) )
    {
      ++v7;
      result = -1LL;
      if ( v9 + v7 >= v14 )
        return result;
    }
    return v7;
  }
  v15 = 0LL;
  v21 = vdupq_n_s8(n);
  v22 = v21;
  v20[12] = v21;
  v20[13] = v21;
  v20[10] = v21;
  v20[11] = v21;
  v20[8] = v21;
  v20[9] = v21;
  v20[6] = v21;
  v20[7] = v21;
  v20[4] = v21;
  v20[5] = v21;
  v20[2] = v21;
  v20[3] = v21;
  v20[0] = v21;
  v20[1] = v21;
  do
  {
    v16 = (unsigned __int8)s2[v15];
    v17 = v11 - v15;
    v15 = (unsigned int)(v15 + 1);
    *((_BYTE *)v20 + v16) = v17;
  }
  while ( v11 != v15 );
  v18 = (unsigned __int8)s2[v11];
  while ( 1 )
  {
    v19 = v12[v11];
    if ( (_DWORD)v19 == v18 && !memcmp(v12, s2, v11) )
      break;
    v12 += *((unsigned __int8 *)v20 + v19);
    if ( (unsigned __int64)v12 >= v14 )
      return -1LL;
  }
  return (__int64)&v12[-v9];
}


================================================================================
Function: sub_65F6EFC (0x65F6EFC)
================================================================================

__int64 __fastcall sub_65F6EFC(unsigned __int8 **a1, unsigned int a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x12
  unsigned __int8 *v5; // x9
  unsigned __int64 v6; // x10
  unsigned int v7; // w13
  int v8; // w14
  unsigned int v9; // w13
  unsigned __int64 v10; // x13
  unsigned __int8 *v12; // x9
  unsigned __int8 *v13; // x9
  int v14; // t1
  __int64 v15; // x10

  v3 = (unsigned __int64)a1[1];
  if ( a2 )
  {
    if ( v3 )
      goto LABEL_3;
    return (unsigned int)v3;
  }
  if ( v3 >= 2 )
  {
    v12 = *a1;
    if ( *(_WORD *)*a1 == 30768 || *(_WORD *)v12 == 22576 )
    {
      v13 = v12 + 2;
      a2 = 16;
    }
    else if ( *(_WORD *)v12 == 25136 || *(_WORD *)v12 == 16944 )
    {
      v13 = v12 + 2;
      a2 = 2;
    }
    else
    {
      if ( *(_WORD *)v12 != 28464 )
      {
        if ( *v12 != 48 || (v14 = v12[1], v13 = v12 + 1, (unsigned int)(v14 - 48) > 9) )
        {
          a2 = 10;
          goto LABEL_3;
        }
        a2 = 8;
        v15 = -1LL;
        goto LABEL_34;
      }
      v13 = v12 + 2;
      a2 = 8;
    }
    v15 = -2LL;
LABEL_34:
    v3 += v15;
    *a1 = v13;
    a1[1] = (unsigned __int8 *)v3;
    if ( !v3 )
      return (unsigned int)v3;
    goto LABEL_3;
  }
  a2 = 10;
  if ( !v3 )
    return (unsigned int)v3;
LABEL_3:
  v4 = 0LL;
  v5 = *a1;
  v6 = v3;
  *a3 = 0LL;
  do
  {
    if ( (char)*v5 < 48 )
      break;
    v7 = *v5;
    if ( v7 >= 0x3A )
    {
      if ( v7 < 0x61 )
      {
        if ( v7 - 65 > 0x19 )
          break;
        v8 = -55;
      }
      else
      {
        if ( v7 >= 0x7B )
          break;
        v8 = -87;
      }
    }
    else
    {
      v8 = -48;
    }
    v9 = v8 + v7;
    if ( v9 >= a2 )
      break;
    v10 = v4 * a2 + v9;
    *a3 = v10;
    if ( v10 / a2 < v4 )
      return 0LL;
    ++v5;
    --v6;
    v4 = v10;
  }
  while ( v6 );
  if ( v3 == v6 )
    return 0LL;
  *a1 = v5;
  a1[1] = (unsigned __int8 *)v6;
  return 1LL;
}


================================================================================
Function: sub_65F71D0 (0x65F71D0)
================================================================================

bool __fastcall sub_65F71D0(_BYTE *a1, __int64 a2, unsigned int a3, __int64 *a4)
{
  __int64 v5; // x8
  __int128 v7; // [xsp+0h] [xbp-30h] BYREF
  __int128 v8; // [xsp+10h] [xbp-20h] BYREF
  __int64 v9; // [xsp+20h] [xbp-10h] BYREF

  *(_QWORD *)&v7 = a1;
  *((_QWORD *)&v7 + 1) = a2;
  if ( !a2 || *a1 != 45 )
  {
    if ( (sub_65F6EFC(&v7, a3, &v9) & 1) == 0 )
      return 0LL;
    v5 = v9;
    if ( v9 < 0 )
      return 0LL;
LABEL_9:
    *a4 = v5;
    return *((_QWORD *)&v7 + 1) == 0LL;
  }
  *(_QWORD *)&v8 = a1 + 1;
  *((_QWORD *)&v8 + 1) = a2 - 1;
  if ( (sub_65F6EFC(&v8, a3, &v9) & 1) != 0 )
  {
    v5 = -v9;
    if ( -v9 < 0 || v9 == 0 )
    {
      v7 = v8;
      goto LABEL_9;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_65F7B88 (0x65F7B88)
================================================================================

__int64 sub_65F7B88()
{
  __int64 v1; // [xsp+8h] [xbp-18h] BYREF
  __int64 v2; // [xsp+10h] [xbp-10h]

  clock_gettime(1, (struct timespec *)&v1);
  if ( byte_724A7A8 && byte_72FCB88 )
    return v2 + 1000000000 * v1;
  else
    return (__int64)((double)v1 * 1000000000.0 + (double)v2);
}


================================================================================
Function: sub_65F7C30 (0x65F7C30)
================================================================================

__int64 sub_65F7C30()
{
  __int64 v0; // x0
  bool v1; // zf

  if ( byte_724A7A8 )
  {
    v0 = qword_72FCBD8;
    if ( byte_72FCB88 )
      v1 = 1;
    else
      v1 = qword_72FCBD8 == 0;
    if ( v1 )
      return sub_6819C28() / 1000000;
  }
  else
  {
    v0 = qword_72FCBD8;
    if ( !qword_72FCBD8 )
      return sub_6819C28() / 1000000;
  }
  if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 16LL))(v0) & 1) != 0 )
    return (__int64)(*(double (__fastcall **)(__int64))(*(_QWORD *)qword_72FCBD8 + 8LL))(qword_72FCBD8);
  return sub_6819C28() / 1000000;
}


================================================================================
Function: sub_65F7CCC (0x65F7CCC)
================================================================================

__int64 sub_65F7CCC()
{
  __int64 v0; // x0
  bool v1; // zf

  if ( byte_724A7A8 )
  {
    v0 = qword_72FCBD8;
    if ( byte_72FCB88 )
      v1 = 1;
    else
      v1 = qword_72FCBD8 == 0;
    if ( v1 )
      return sub_6819C28() / 1000;
  }
  else
  {
    v0 = qword_72FCBD8;
    if ( !qword_72FCBD8 )
      return sub_6819C28() / 1000;
  }
  if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 16LL))(v0) & 1) != 0 )
    return (__int64)((*(double (__fastcall **)(__int64))(*(_QWORD *)qword_72FCBD8 + 8LL))(qword_72FCBD8) * 1000.0);
  return sub_6819C28() / 1000;
}


================================================================================
Function: sub_65F7E10 (0x65F7E10)
================================================================================

__int64 sub_65F7E10()
{
  bool v0; // zf

  if ( byte_724A7A8 )
    v0 = byte_72FCB88 == 0;
  else
    v0 = 1;
  if ( v0
    && qword_72FCBD8
    && ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_72FCBD8 + 16LL))(qword_72FCBD8) & 1) != 0 )
  {
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_72FCBD8 + 8LL))(qword_72FCBD8);
  }
  else
  {
    return sub_65F7E7C();
  }
}


================================================================================
Function: sub_65F7E7C (0x65F7E7C)
================================================================================

double sub_65F7E7C()
{
  bool v0; // zf
  __int64 v1; // x0
  __int64 v2; // x20
  unsigned __int64 StatusReg; // x21
  __int64 *v4; // x20
  double v5; // d0
  __int64 v6; // x0
  unsigned __int8 v7; // w8
  double v9; // d8
  double v10; // [xsp+8h] [xbp-30h]
  __int64 v11; // [xsp+10h] [xbp-28h] BYREF
  __int64 v12; // [xsp+18h] [xbp-20h]

  if ( byte_724A7A8 )
    v0 = byte_72FCB88 == 0;
  else
    v0 = 1;
  if ( !v0 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    if ( *(double *)&qword_7300C08 != 0.0 )
    {
LABEL_10:
      __dmb(9u);
      v4 = &qword_7300C08;
      v5 = (double)(StatusReg - qword_7300C38);
      return *(double *)v4 * v5;
    }
    *(double *)&qword_7300C08 = 1.0 / (double)(unsigned __int64)sub_65F8C38(*(double *)&qword_7300C08);
    __dmb(0xBu);
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    qword_7300C38 = StatusReg;
    __dmb(9u);
    if ( byte_724A7A8 && byte_724A758 )
    {
      if ( (unsigned __int8)qword_72FCB38 < 6u || (qword_72FCB38 & 0xFC00) == 0 )
      {
LABEL_22:
        if ( byte_7300C19 == 1 )
        {
          v9 = (double)(sub_65F7B88() - qword_7300C20);
          qword_7300C38 -= (unsigned __int64)(sub_65F94B0() * v9 / *(double *)&qword_7300C08 + 0.5);
        }
        goto LABEL_10;
      }
    }
    else if ( !(_BYTE)qword_72FCB38 )
    {
      goto LABEL_22;
    }
    v11 = (__int64)&unk_7300C40;
    v12 = 0LL;
    sub_65C5CFC(qword_72FCB38, qword_72FCB40, 4u, "[FLog::TimingInfo] {}", 21LL, 12LL, (__int64)&v11, 1);
    goto LABEL_22;
  }
  v1 = clock_gettime(1, (struct timespec *)&v11);
  if ( byte_724A7A8 && byte_72FCB88 )
    v2 = v12 + 1000000000 * v11;
  else
    v2 = (__int64)((double)v11 * 1000000000.0 + (double)v12);
  v6 = sub_65F8644(v1);
  v5 = (double)(v2 - v6);
  v7 = atomic_load(byte_7300D08);
  if ( (v7 & 1) != 0 )
  {
    v4 = &qword_7300D00;
  }
  else
  {
    v10 = (double)(v2 - v6);
    v4 = &qword_7300D00;
    if ( (unsigned int)sub_68626F8((__int64)byte_7300D08) )
    {
      qword_7300D00 = 0x3E112E0BE826D695LL;
      sub_6862850(byte_7300D08);
    }
    v5 = v10;
  }
  return *(double *)v4 * v5;
}


================================================================================
Function: sub_65F819C (0x65F819C)
================================================================================

void sub_65F819C()
{
  int v0; // w8
  int v1; // w9
  bool v2; // zf

  v0 = (unsigned __int8)byte_72FCB88;
  v1 = (unsigned __int8)byte_724A7A8;
  if ( byte_724A7A8 )
    v2 = byte_72FCB88 == 0;
  else
    v2 = 1;
  if ( !v2 )
    goto LABEL_10;
  if ( qword_72FCBD8 )
  {
    if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_72FCBD8 + 16LL))(qword_72FCBD8) & 1) != 0 )
      goto LABEL_14;
    v1 = (unsigned __int8)byte_724A7A8;
    v0 = (unsigned __int8)byte_72FCB88;
  }
  if ( v1 )
  {
LABEL_10:
    if ( v0 )
    {
LABEL_13:
      sub_65F7E7C();
      return;
    }
  }
  if ( !qword_72FCBD8
    || ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_72FCBD8 + 16LL))(qword_72FCBD8) & 1) == 0 )
  {
    goto LABEL_13;
  }
LABEL_14:
  (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_72FCBD8 + 8LL))(qword_72FCBD8);
}


================================================================================
Function: sub_65F8644 (0x65F8644)
================================================================================

__int64 sub_65F8644()
{
  bool v0; // zf
  __int64 result; // x0
  __int64 v2; // [xsp+8h] [xbp-18h] BYREF
  __int64 v3; // [xsp+10h] [xbp-10h]

  if ( byte_724A7A8 )
    v0 = byte_72FCB88 == 0;
  else
    v0 = 1;
  if ( v0 )
  {
    result = qword_7300C20;
    if ( !qword_7300C20 )
    {
      if ( (byte_7300C19 & 1) != 0 )
      {
        return 0LL;
      }
      else
      {
        clock_gettime(1, (struct timespec *)&v2);
        if ( byte_724A7A8 && byte_72FCB88 )
          result = v3 + 1000000000 * v2;
        else
          result = (__int64)((double)v2 * 1000000000.0 + (double)v3);
        qword_7300C20 = result;
        byte_7300C19 = 1;
      }
    }
  }
  else
  {
    if ( (byte_7300C19 & 1) == 0 )
    {
      qword_7300C20 = sub_65F7B88();
      __dmb(0xBu);
      byte_7300C19 = 1;
    }
    __dmb(9u);
    return qword_7300C20;
  }
  return result;
}


================================================================================
Function: sub_65F8770 (0x65F8770)
================================================================================

char *__usercall sub_65F8770@<X0>(__int64 a1@<X0>, __int64 a2@<X8>)
{
  char *result; // x0
  int v4; // [xsp+8h] [xbp-38h] BYREF
  unsigned __int64 v5; // [xsp+30h] [xbp-10h] BYREF

  v5 = (a1 & (unsigned __int64)~(a1 >> 63)) / 0x3E8;
  if ( sub_6806D24(&v5, &v4) )
    return (char *)sub_65F13AC("%04d-%02d-%02dT%02d:%02d:%02d.%03dZ");
  result = (char *)sub_65ECAAC();
  *(_QWORD *)(a2 + 16) = result;
  *(_OWORD *)a2 = xmmword_AFCD60;
  strcpy(result, "0000-00-00T00:00:00.000Z");
  return result;
}


================================================================================
Function: sub_65F8C38 (0x65F8C38)
================================================================================

unsigned __int64 sub_65F8C38()
{
  __int64 v0; // x28
  __int64 v1; // x19
  __int64 v2; // x22
  unsigned __int64 i; // x20
  unsigned __int64 v4; // x24
  __int64 v5; // x25
  __int64 v6; // x23
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x26
  unsigned __int64 v9; // x27
  __int64 v10; // x9
  __int64 v11; // x8
  unsigned __int64 v12; // x10
  unsigned __int64 v13; // x8
  __int64 v14; // x26
  __int64 v15; // x27
  unsigned __int64 j; // x25
  unsigned __int64 v17; // x19
  __int64 v18; // x10
  __int64 v19; // x9
  unsigned __int64 v20; // x8
  unsigned __int64 v21; // x24
  unsigned __int64 v22; // x19
  __int64 v23; // x0
  __int64 v24; // x1
  __int64 v25; // x9
  __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x9
  double v30; // d1
  double v31; // d0
  unsigned __int64 v32; // x5
  unsigned __int64 v33; // x6
  bool v34; // cc
  unsigned __int64 v35; // x22
  unsigned int v36; // w25
  unsigned int v37; // w23
  unsigned __int64 v38; // x20
  unsigned __int64 v39; // x8
  double *v40; // x10
  unsigned __int64 v41; // x20
  __int64 v42; // x9
  __int64 v43; // x21
  __int64 v44; // x8
  unsigned __int64 v45; // x9
  int64x2_t *v46; // x12
  double *v47; // x13
  int64x2_t v48; // q0
  __int64 v49; // x15
  int64x2_t v50; // t1
  double *v51; // x15
  double *v52; // x10
  unsigned int v53; // w12
  __int64 v54; // x13
  double *v55; // x14
  double *v56; // x12
  unsigned __int64 v57; // x14
  unsigned __int64 v58; // x12
  double v59; // d10
  __int64 v60; // x11
  __int64 v61; // x10
  double v62; // d1
  double v63; // d2
  double v64; // d5
  unsigned __int64 v65; // x12
  unsigned __int64 v66; // x9
  unsigned __int64 v67; // x8
  unsigned int v68; // w14
  __int64 *v69; // x15
  __int64 v70; // x15
  __int64 v71; // x16
  double v72; // d6
  unsigned __int64 v73; // x20
  double v74; // d5
  unsigned __int64 v75; // x11
  __int64 *v76; // x16
  __int64 v77; // x16
  __int64 v78; // x17
  __int64 v79; // x16
  double v80; // d6
  double v81; // d9
  double v82; // d8
  double v83; // d11
  int v84; // w9
  unsigned int v85; // w8
  int v86; // w10
  int32x4_t v87; // q0
  unsigned int v88; // w8
  int32x4_t v89; // q1
  int32x4_t v90; // q2
  int8x16_t v91; // q0
  unsigned int v92; // w9
  unsigned __int64 v93; // x9
  __int64 v94; // x8
  __int64 v95; // x21
  void *v96; // x0
  __int64 v97; // x1
  long double v98; // q0
  long double v99; // q1
  long double v100; // q2
  long double v101; // q3
  unsigned __int64 v102; // x8
  const char *v103; // x3
  unsigned __int64 v105; // [xsp+0h] [xbp-9FD0h]
  unsigned __int64 StatusReg; // [xsp+8h] [xbp-9FC8h]
  __int64 v107; // [xsp+10h] [xbp-9FC0h]
  __int64 v108; // [xsp+18h] [xbp-9FB8h] BYREF
  __int64 v109; // [xsp+20h] [xbp-9FB0h]
  __int64 v110; // [xsp+28h] [xbp-9FA8h] BYREF
  __int64 v111; // [xsp+30h] [xbp-9FA0h]
  __int64 v112; // [xsp+38h] [xbp-9F98h] BYREF
  __int64 v113; // [xsp+40h] [xbp-9F90h]
  _QWORD v114[3046]; // [xsp+48h] [xbp-9F88h] BYREF
  double v115; // [xsp+5F78h] [xbp-4058h] BYREF
  double v116; // [xsp+5F80h] [xbp-4050h]
  double v117; // [xsp+5F88h] [xbp-4048h]
  __int64 v118; // [xsp+5F90h] [xbp-4040h]
  unsigned int v119; // [xsp+5F98h] [xbp-4038h]
  _QWORD v120[1024]; // [xsp+5FA0h] [xbp-4030h]
  _QWORD v121[1024]; // [xsp+7FA0h] [xbp-2030h] BYREF
  float64x2x3_t v122; // 0:q4.16,16:q5.16,32:q6.16

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 0));
  if ( !byte_72FCBB8 )
  {
    v35 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    clock_gettime(1, (struct timespec *)&v110);
    v36 = 0;
    do
    {
      v38 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
      v37 = 1;
      clock_gettime(1, (struct timespec *)&v108);
      v39 = v38 - v35;
      v40 = &v115 + v36;
      v41 = v109 + 1000000000 * (v108 - v110) - v111;
      *((_QWORD *)v40 + 5) = v39;
      *((_QWORD *)v40 + 1029) = v41;
      if ( v36 )
      {
        v42 = v36 - 1;
        if ( v39 == v120[(unsigned int)v42] || v41 == v121[v42] )
        {
          v37 = v36;
        }
        else
        {
          v37 = v36 + 1;
          if ( v36 >= 0x7F && (v41 - v121[0]) >> 5 >= 0xC35 && ((v39 - v120[0]) >> 4 > 0x270 || v41 - v121[0] > 0xF423F) )
            goto LABEL_53;
        }
      }
      v36 = v37;
    }
    while ( v37 < 0x400 );
    v37 = 1024;
    v41 = v121[1023];
LABEL_53:
    v43 = v37 - 8;
    v119 = v37;
    qword_7300C10 = v41;
    v44 = 0LL;
    if ( (unsigned int)v43 < 2 )
      goto LABEL_59;
    if ( (~(v37 - 9) & 0xFFFFFFF8) == 0 )
      goto LABEL_59;
    v45 = (unsigned __int64)(v43 - 1) >> 32;
    if ( v45 )
      goto LABEL_59;
    v44 = (unsigned int)v43 & 0xFFFFFFFE;
    v46 = (int64x2_t *)v121;
    v47 = (double *)&v112;
    do
    {
      v48 = v46[-512];
      v49 = ((_DWORD)v45 + 8) & 0xFFFFFFFE;
      v45 += 2LL;
      v50 = *v46++;
      v51 = &v115 + v49;
      v122.val[0] = vsubq_s64(*(int64x2_t *)(v51 + 5), v48);
      v122.val[1] = vsubq_s64(*(int64x2_t *)(v51 + 1029), v50);
      v122.val[2] = vdivq_f64(vcvtq_f64_u64(v122.val[0]), vcvtq_f64_u64(v122.val[1]));
      vst3q_f64(v47, v122);
      v47 += 6;
    }
    while ( v44 != v45 );
    if ( v44 != v43 )
    {
LABEL_59:
      v52 = (double *)&v114[3 * v44];
      do
      {
        v53 = v44 + 8;
        v54 = v44;
        v55 = &v115 + v44++;
        v56 = &v115 + v53;
        v57 = *((_QWORD *)v56 + 5) - *((_QWORD *)v55 + 5);
        v58 = *((_QWORD *)v56 + 1029) - v121[v54];
        *((_QWORD *)v52 - 2) = v57;
        *((_QWORD *)v52 - 1) = v58;
        *v52 = (double)v57 / (double)v58;
        v52 += 3;
      }
      while ( v43 != v44 );
    }
    sub_65F95C8(&v112, &v112 + 3 * v43);
    v59 = (*(double *)&v114[3 * ((v37 - 9) >> 1)] + *(double *)&v114[3 * ((unsigned int)v43 >> 1)]) * 0.5;
    v60 = ((unsigned int)v43 >> 1) - ((unsigned int)v43 >> 2);
    v61 = (unsigned int)v43 - (((unsigned int)v43 >> 2) + ((unsigned int)v43 >> 1));
    v115 = v59;
    if ( (_DWORD)v60 )
    {
      v62 = 0.0;
      v63 = 0.0;
      v64 = v59 * 0.0005;
      v65 = 0LL;
      v66 = 0LL;
      v67 = 0LL;
      v68 = ((unsigned int)v43 >> 1) - 1;
      do
      {
        v72 = v59 - *(double *)&v114[3 * v68];
        if ( v65 >= (unsigned int)v60 >> 1 && v72 > v64 )
          break;
        v63 = v63 + 1.0;
        v69 = &v112 + 3 * v68;
        ++v65;
        --v68;
        v62 = v62 + v72 * v72;
        v71 = *v69;
        v70 = v69[1];
        if ( v64 < v72 * 20.0 )
          v64 = v72 * 20.0;
        v66 += v71;
        v67 += v70;
      }
      while ( v60 != v65 );
      if ( !(_DWORD)v61 )
      {
LABEL_77:
        v81 = (double)v66 / (double)v67 * 1000000000.0;
        v116 = v81;
        v82 = sqrt(v62 / v63) * 1000000000.0;
        v117 = v82;
        if ( v59 * 0.0005 >= v82 + v82 )
          v83 = v59 * 0.0005;
        else
          v83 = v82 + v82;
        v84 = (int)(log(v83 * 20.0) * 0.434294482 + 0.00999999978);
        if ( v84 < 1 )
        {
          v85 = 1;
        }
        else
        {
          if ( (unsigned int)v84 >= 8 )
          {
            v86 = v84 & 7;
            v87.n128_u64[0] = 0x100000001LL;
            v87.n128_u64[1] = 0x100000001LL;
            v88 = v84 & 0xFFFFFFF8;
            v89.n128_u64[0] = 0xA0000000ALL;
            v89.n128_u64[1] = 0xA0000000ALL;
            v90.n128_u64[0] = 0x100000001LL;
            v90.n128_u64[1] = 0x100000001LL;
            do
            {
              v87 = vmulq_s32(v87, v89);
              v88 -= 8;
              v90 = vmulq_s32(v90, v89);
            }
            while ( v88 );
            v91 = vmulq_s32(v90, v87);
            v91.n128_u64[0] = vmul_s32((int32x2_t)v91.n128_u64[0], (int32x2_t)vextq_s8(v91, v91, 8uLL).n128_u64[0]).n64_u64[0];
            v85 = v91.n128_u32[0] * v91.n128_u32[1];
            if ( (v84 & 0x7FFFFFF8) == v84 )
              goto LABEL_89;
          }
          else
          {
            v85 = 1;
            v86 = v84;
          }
          v92 = v86 + 1;
          do
          {
            --v92;
            v85 *= 10;
          }
          while ( v92 > 1 );
        }
LABEL_89:
        v93 = (unsigned __int64)v81;
        v94 = (int)(((v85 >> 1) + (unsigned __int64)v81) / v85 * v85 - (unsigned __int64)v81);
        if ( fabs((double)(int)v94) >= v83 )
          v94 = 0LL;
        v95 = v94 + v93;
        v118 = v94 + v93;
        v96 = memcpy(&unk_72FCBE0, &v115, 0x4028uLL);
        v102 = StatusReg - v95;
        if ( (__int64)(StatusReg - v95) < 0 )
          v102 = v95 - StatusReg;
        *(double *)&v101 = (double)v41 * 0.000001;
        *(double *)&v98 = v81;
        *(double *)&v100 = v82;
        if ( v82 * 5.0 <= (double)v102 )
          v103 = "Precise time not using hw freq %lu; using freq %lu from measured %.0lf median %.0lf std dev %lf; measur"
                 "ing took %lf ms\n";
        else
          v103 = "Precise time using hw freq %lu; got %lu from measured %.0lf median %.0lf std dev %lf; measuring took %lf ms\n";
        if ( v82 * 5.0 <= (double)v102 )
          v73 = v95;
        else
          v73 = StatusReg;
        *(double *)&v99 = v59 * 1000000000.0;
        sub_65F9514(v96, v97, 192LL, v103, v98, v99, v100, v101);
        return v73;
      }
    }
    else
    {
      v67 = 0LL;
      v63 = 0.0;
      v62 = 0.0;
      v66 = 0LL;
      if ( !(_DWORD)v61 )
        goto LABEL_77;
    }
    v74 = v59 * 0.0005;
    v75 = 0LL;
    do
    {
      v79 = ((v37 - 8) >> 1) + (unsigned int)v75;
      v80 = *(double *)&v114[3 * (unsigned int)v79] - v59;
      if ( v75 >= (unsigned int)v61 >> 1 && v80 > v74 )
        break;
      v76 = &v112 + 3 * v79;
      v63 = v63 + 1.0;
      ++v75;
      v78 = *v76;
      v77 = v76[1];
      v62 = v62 + v80 * v80;
      if ( v74 < v80 * 20.0 )
        v74 = v80 * 20.0;
      v66 += v78;
      v67 += v77;
    }
    while ( v61 != v75 );
    goto LABEL_77;
  }
  clock_gettime(1, (struct timespec *)&v110);
  v1 = v110;
  v2 = v111;
  for ( i = 10000LL; ; i *= 2LL )
  {
    do
    {
      clock_gettime(1, (struct timespec *)&v112);
      v4 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
      clock_gettime(1, (struct timespec *)&v115);
      v5 = v113 - v2 + 1000000000 * (v112 - v1);
      v6 = *(_QWORD *)&v116 - v2 + 1000000000 * (*(_QWORD *)&v115 - v1);
      v7 = v6 - v5;
    }
    while ( v6 == v5 );
    if ( v7 < i )
      break;
  }
  if ( v7 >= 0x3B9ACA00 )
    v8 = 1000000000LL;
  else
    v8 = v6 - v5;
  while ( 1 )
  {
    do
    {
      clock_gettime(1, (struct timespec *)&v112);
      v9 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
      clock_gettime(1, (struct timespec *)&v115);
      v10 = v113 - v2 + 1000000000 * (v112 - v1);
      v11 = *(_QWORD *)&v116 - v2 + 1000000000 * (*(_QWORD *)&v115 - v1);
      v12 = v11 - v10;
    }
    while ( v11 == v10 );
    if ( v12 < i )
      break;
    i *= 2LL;
  }
  if ( v12 < v8 )
    v6 = *(_QWORD *)&v116 - v2 + 1000000000 * (*(_QWORD *)&v115 - v1);
  else
    v10 = v5;
  if ( v12 >= v8 )
    v13 = v4;
  else
    v13 = v9;
  v107 = v10;
  v105 = v13;
  do
  {
    do
    {
      v15 = v110;
      v14 = v111;
      for ( j = 10000LL; ; j *= 2LL )
      {
        do
        {
          clock_gettime(1, (struct timespec *)&v112);
          v17 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
          clock_gettime(1, (struct timespec *)&v115);
          v18 = v113 - v14 + 1000000000 * (v112 - v15);
          v19 = *(_QWORD *)&v116 - v14 + 1000000000 * (*(_QWORD *)&v115 - v15);
          v20 = v19 - v18;
        }
        while ( v19 == v18 );
        if ( v20 < j )
          break;
      }
      v21 = 1000000000LL;
      if ( v20 < 0x3B9ACA00 )
      {
        v0 = v113 - v14 + 1000000000 * (v112 - v15);
        v2 = *(_QWORD *)&v116 - v14 + 1000000000 * (*(_QWORD *)&v115 - v15);
        i = v17;
        v21 = v19 - v18;
      }
      while ( 1 )
      {
        do
        {
          clock_gettime(1, (struct timespec *)&v112);
          v22 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
          v23 = clock_gettime(1, (struct timespec *)&v115);
          v25 = v113 - v14 + 1000000000 * (v112 - v15);
          v26 = *(_QWORD *)&v116 - v14 + 1000000000 * (*(_QWORD *)&v115 - v15);
          v27 = v26 - v25;
        }
        while ( v26 == v25 );
        if ( v27 < j )
          break;
        j *= 2LL;
      }
      if ( v27 < v21 )
      {
        v0 = v113 - v14 + 1000000000 * (v112 - v15);
        v2 = *(_QWORD *)&v116 - v14 + 1000000000 * (*(_QWORD *)&v115 - v15);
      }
      v28 = v0 - v6;
      if ( v27 < v21 )
        i = v22;
      v29 = v2 - v107;
    }
    while ( v2 - v107 - v28 > v28 >> 4 );
    v30 = (double)(i - v105) * 1000000000.0;
    v31 = (double)v28;
    v32 = (unsigned __int64)(v30 / (double)v29);
    v33 = (unsigned __int64)(v30 / (double)v28);
    v34 = StatusReg < v32 || StatusReg > v33;
    qword_7300C10 = v0 - v6;
    if ( !v34 )
    {
      v73 = StatusReg;
      byte_7300C18 = 0;
      sub_65F9514(v23, v24, 192LL, "Precise time using hw freq %lu; measuring took %lf ms\n", StatusReg, v31 * 0.000001);
      return v73;
    }
  }
  while ( v28 <= 0x5F5E0FF && v2 - v107 - v28 > v28 >> 8 );
  byte_7300C18 = 1;
  v73 = (unsigned __int64)(v30 / (double)((v29 + v28) >> 1));
  sub_65F9514(
    v23,
    v24,
    192LL,
    "Precise time using measured freq %lu, between %lu and %lu, instead of %lu; measuring took %lf ms\n",
    v73,
    v32,
    v33,
    StatusReg,
    v31 * 0.000001);
  return v73;
}


================================================================================
Function: sub_65F94B0 (0x65F94B0)
================================================================================

double sub_65F94B0()
{
  unsigned __int8 v0; // w9
  double *v1; // x8
  int v3; // w0

  v0 = atomic_load(byte_7300D08);
  v1 = (double *)&unk_7300000;
  if ( (v0 & 1) == 0 )
  {
    v3 = sub_68626F8((__int64)byte_7300D08);
    v1 = (double *)&unk_7300000;
    if ( v3 )
    {
      qword_7300D00 = 0x3E112E0BE826D695LL;
      sub_6862850(byte_7300D08);
      v1 = (double *)&unk_7300000;
    }
  }
  return v1[416];
}


================================================================================
Function: sub_65F9514 (0x65F9514)
================================================================================

__int64 sub_65F9514(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  gcc_va_list va1; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, a4);
  va_copy(va1, va);
  return __vsnprintf_chk();
}


================================================================================
Function: sub_65F95C8 (0x65F95C8)
================================================================================

__int64 __fastcall sub_65F95C8(__int64 result, double *a2)
{
  __int64 v3; // x19
  __int128 *v4; // x21
  unsigned __int64 v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x0
  unsigned __int64 v8; // x27
  unsigned __int64 v9; // x25
  unsigned __int64 v10; // x22
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x23
  __int128 *v13; // x24
  __int128 v14; // q0
  unsigned __int64 v15; // x8
  double *v16; // x8
  double v17; // t1
  __int128 v18; // q0
  unsigned __int64 v19; // x9
  double v20; // d1
  double *v21; // x9
  double v22; // t1
  __int128 v23; // q0
  double v24; // d1
  __int128 v25; // q0
  double v26; // d1
  __int64 v27; // x8
  double *v28; // x8
  double v29; // t1
  double v30; // d0
  bool v31; // nf
  double v32; // d1
  __int128 v33; // q0
  __int128 v34; // q0
  __int128 v35; // q0
  __int128 v36; // q0
  __int128 v37; // q0
  double v38; // d0
  double v39; // d1
  unsigned __int64 v40; // x8
  double *v41; // x9
  double v42; // d2
  __int128 v43; // q0
  unsigned __int64 v44; // x23
  double v45; // d0
  unsigned __int64 v46; // x9
  double v47; // d1
  double v48; // d1
  __int128 v49; // q0
  __int128 v50; // q0
  char v51; // w24
  __int64 v52; // x8
  __int128 v53; // q0
  double *i; // x9
  double v55; // d0
  double v56; // d1
  double v57; // d1
  __int128 v58; // q0
  __int128 v59; // q0
  double v60; // d0
  __int128 *v61; // x8
  double v62; // d1
  __int128 v63; // q0
  __int128 *v64; // x21
  __int128 *v65; // x22
  __int128 *v66; // x23
  __int128 v67; // q0
  __int64 v68; // x9
  __int64 v69; // x9
  double v70; // d1
  __int128 v71; // q2
  double v72; // d0
  __int128 v73; // q3
  __int64 v74; // x9
  double v75; // d1
  __int128 v76; // q2
  double v77; // d0
  __int128 v78; // q3
  __int64 v79; // x9
  double v80; // d2
  double *v81; // x8
  double v82; // d1
  __int128 *v83; // x9
  double v84; // d0
  __int64 v85; // x10
  __int128 v86; // q0
  __int64 v87; // x10
  __int64 v88; // x10
  __int64 v89; // x11
  __int128 v90; // q2
  __int128 v91; // q3
  double v92; // d0
  __int64 v93; // x11
  __int64 v94; // x9
  __int128 v95; // q0
  __int64 v96; // x10
  __int64 v97; // x11
  double v98; // d1
  __int64 v99; // x10
  __int128 v100; // q1
  __int64 v101; // x11
  double *v102; // x10
  __int64 v103; // x9
  __int64 v104; // x10
  double *v105; // x11
  double v106; // d0
  __int64 v107; // x10
  __int64 v108; // x11
  __int64 v109; // x12
  __int128 v110; // [xsp+80h] [xbp-20h]
  __int128 v111; // [xsp+80h] [xbp-20h]
  __int128 v112; // [xsp+80h] [xbp-20h]
  __int128 v113; // [xsp+80h] [xbp-20h]
  __int128 v114; // [xsp+80h] [xbp-20h]
  __int128 v115; // [xsp+80h] [xbp-20h]
  __int128 v116; // [xsp+80h] [xbp-20h]
  __int128 v117; // [xsp+80h] [xbp-20h]
  __int128 v118; // [xsp+80h] [xbp-20h]
  __int128 v119; // [xsp+80h] [xbp-20h]
  __int128 v120; // [xsp+80h] [xbp-20h]
  __int128 v121; // [xsp+80h] [xbp-20h]
  __int128 v122; // [xsp+80h] [xbp-20h]
  __int128 v123; // [xsp+80h] [xbp-20h]
  __int128 v124; // [xsp+80h] [xbp-20h]
  __int128 v125; // [xsp+80h] [xbp-20h]
  __int128 v126; // [xsp+80h] [xbp-20h]
  __int128 v127; // [xsp+80h] [xbp-20h]
  __int128 v128; // [xsp+80h] [xbp-20h]
  __int128 v129; // [xsp+80h] [xbp-20h]
  __int128 v130; // [xsp+80h] [xbp-20h]
  __int128 v131; // [xsp+80h] [xbp-20h]
  __int64 v132; // [xsp+90h] [xbp-10h]
  __int64 v133; // [xsp+90h] [xbp-10h]
  __int64 v134; // [xsp+90h] [xbp-10h]
  __int64 v135; // [xsp+90h] [xbp-10h]
  __int64 v136; // [xsp+90h] [xbp-10h]
  __int64 v137; // [xsp+90h] [xbp-10h]
  __int64 v138; // [xsp+90h] [xbp-10h]
  __int64 v139; // [xsp+90h] [xbp-10h]
  __int64 v140; // [xsp+90h] [xbp-10h]
  __int64 v141; // [xsp+90h] [xbp-10h]
  __int64 v142; // [xsp+90h] [xbp-10h]
  __int64 v143; // [xsp+90h] [xbp-10h]
  __int64 v144; // [xsp+90h] [xbp-10h]
  __int64 v145; // [xsp+90h] [xbp-10h]
  __int64 v146; // [xsp+90h] [xbp-10h]
  __int64 v147; // [xsp+90h] [xbp-10h]
  __int64 v148; // [xsp+90h] [xbp-10h]
  __int64 v149; // [xsp+90h] [xbp-10h]
  __int64 v150; // [xsp+90h] [xbp-10h]
  __int64 v151; // [xsp+90h] [xbp-10h]
  __int64 v152; // [xsp+90h] [xbp-10h]
  __int64 v153; // [xsp+90h] [xbp-10h]
  __int64 v154; // [xsp+90h] [xbp-10h]
  __int64 v155; // [xsp+90h] [xbp-10h]

  v3 = result;
LABEL_2:
  v4 = (__int128 *)(a2 - 3);
  v5 = v3;
LABEL_3:
  while ( 2 )
  {
    v6 = (unsigned __int64)a2 - v5;
    v3 = v5;
    switch ( 0xAAAAAAAAAAAAAAABLL * ((__int64)((__int64)a2 - v5) >> 3) )
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        if ( *(a2 - 1) < *(double *)(v5 + 16) )
        {
          v145 = *(_QWORD *)(v5 + 16);
          v123 = *(_OWORD *)v5;
          v59 = *(_OWORD *)(a2 - 3);
          *(double *)(v5 + 16) = *(a2 - 1);
          *(_OWORD *)v5 = v59;
          *((_QWORD *)a2 - 1) = v145;
          *(_OWORD *)(a2 - 3) = v123;
        }
        return result;
      case 3uLL:
        v60 = *(double *)(v5 + 40);
        v61 = (__int128 *)(v5 + 24);
        v62 = *(a2 - 1);
        if ( v60 >= *(double *)(v5 + 16) )
        {
          if ( v62 < v60 )
          {
            v86 = *v61;
            v150 = *(_QWORD *)(v5 + 40);
            v87 = *((_QWORD *)a2 - 1);
            *v61 = *v4;
            *(_QWORD *)(v5 + 40) = v87;
            *((_QWORD *)a2 - 1) = v150;
            *v4 = v86;
            if ( *(double *)(v5 + 40) < *(double *)(v5 + 16) )
            {
              v88 = *(_QWORD *)(v5 + 40);
              v151 = *(_QWORD *)(v5 + 16);
              v127 = *(_OWORD *)v5;
              *(_OWORD *)v5 = *v61;
              *(_QWORD *)(v5 + 16) = v88;
              *v61 = v127;
              *(_QWORD *)(v5 + 40) = v151;
            }
          }
        }
        else if ( v62 >= v60 )
        {
          v153 = *(_QWORD *)(v5 + 16);
          v94 = *(_QWORD *)(v5 + 40);
          v129 = *(_OWORD *)v5;
          *(_OWORD *)v5 = *v61;
          *(_QWORD *)(v5 + 16) = v94;
          *v61 = v129;
          *(_QWORD *)(v5 + 40) = v153;
          if ( *(a2 - 1) < *(double *)(v5 + 40) )
          {
            v95 = *v61;
            v154 = *(_QWORD *)(v5 + 40);
            v96 = *((_QWORD *)a2 - 1);
            *v61 = *v4;
            *(_QWORD *)(v5 + 40) = v96;
            *((_QWORD *)a2 - 1) = v154;
            *v4 = v95;
          }
        }
        else
        {
          v146 = *(_QWORD *)(v5 + 16);
          v124 = *(_OWORD *)v5;
          v63 = *v4;
          *(double *)(v5 + 16) = *(a2 - 1);
          *(_OWORD *)v5 = v63;
          *((_QWORD *)a2 - 1) = v146;
          *v4 = v124;
        }
        return result;
      case 4uLL:
        return sub_65FA038(v5, v5 + 24, v5 + 48, a2 - 3);
      case 5uLL:
        v64 = (__int128 *)(v5 + 24);
        v65 = (__int128 *)(v5 + 48);
        v66 = (__int128 *)(v3 + 72);
        result = sub_65FA038(v3, v3 + 24, v3 + 48, v3 + 72);
        if ( *(a2 - 1) < *(double *)(v3 + 88) )
        {
          v67 = *v66;
          v147 = *(_QWORD *)(v3 + 88);
          v68 = *((_QWORD *)a2 - 1);
          *v66 = *(_OWORD *)(a2 - 3);
          *(_QWORD *)(v3 + 88) = v68;
          *((_QWORD *)a2 - 1) = v147;
          *(_OWORD *)(a2 - 3) = v67;
          if ( *(double *)(v3 + 88) < *(double *)(v3 + 64) )
          {
            v69 = *(_QWORD *)(v3 + 64);
            v70 = *(double *)(v3 + 40);
            *(_QWORD *)(v3 + 64) = *(_QWORD *)(v3 + 88);
            v71 = *v66;
            v72 = *(double *)(v3 + 64);
            *(_QWORD *)(v3 + 88) = v69;
            v73 = *v65;
            *v65 = v71;
            *v66 = v73;
            if ( v72 < v70 )
            {
              v74 = *(_QWORD *)(v3 + 40);
              v75 = *(double *)(v3 + 16);
              *(_QWORD *)(v3 + 40) = *(_QWORD *)(v3 + 64);
              v76 = *v65;
              v77 = *(double *)(v3 + 40);
              *(_QWORD *)(v3 + 64) = v74;
              v78 = *v64;
              *v64 = v76;
              *v65 = v78;
              if ( v77 < v75 )
              {
                v79 = *(_QWORD *)(v3 + 40);
                v148 = *(_QWORD *)(v3 + 16);
                v125 = *(_OWORD *)v3;
                *(_OWORD *)v3 = *v64;
                *(_QWORD *)(v3 + 16) = v79;
                *v64 = v125;
                *(_QWORD *)(v3 + 40) = v148;
              }
            }
          }
        }
        return result;
      default:
        if ( (__int64)v6 > 743 )
        {
          if ( v6 >= 0x5DA9 )
          {
            v7 = v5;
            v8 = v6 / 0x30;
            v9 = v6 / 0x60;
            v10 = v5 + 24 * (v6 / 0x30);
            v11 = 24 * (v6 / 0x60);
            v12 = v3 + v11;
            v13 = (__int128 *)(v10 + v11);
            result = sub_65FA038(v7, v3 + v11, v10, v10 + v11);
            if ( *(a2 - 1) < *((double *)v13 + 2) )
            {
              v132 = *((_QWORD *)v13 + 2);
              v110 = *v13;
              v14 = *v4;
              *((double *)v13 + 2) = *(a2 - 1);
              v15 = v3 + 24 * v8;
              *v13 = v14;
              *((_QWORD *)a2 - 1) = v132;
              *v4 = v110;
              v17 = *(double *)(v15 + 16);
              v16 = (double *)(v15 + 16);
              if ( *((double *)v13 + 2) >= v17 )
              {
                result = (unsigned int)(result + 1);
              }
              else
              {
                v133 = *(_QWORD *)(v10 + 16);
                v111 = *(_OWORD *)v10;
                v18 = *v13;
                *(_QWORD *)(v10 + 16) = *((_QWORD *)v13 + 2);
                v19 = v3 + 24 * v9;
                *(_OWORD *)v10 = v18;
                *((_QWORD *)v13 + 2) = v133;
                v20 = *v16;
                *v13 = v111;
                v22 = *(double *)(v19 + 16);
                v21 = (double *)(v19 + 16);
                if ( v20 >= v22 )
                {
                  result = (unsigned int)(result + 2);
                }
                else
                {
                  v134 = *(_QWORD *)(v12 + 16);
                  v112 = *(_OWORD *)v12;
                  v23 = *(_OWORD *)v10;
                  *(_QWORD *)(v12 + 16) = *(_QWORD *)(v10 + 16);
                  *(_OWORD *)v12 = v23;
                  *(_QWORD *)(v10 + 16) = v134;
                  v24 = *v21;
                  *(_OWORD *)v10 = v112;
                  if ( v24 >= *(double *)(v3 + 16) )
                  {
                    result = (unsigned int)(result + 3);
                  }
                  else
                  {
                    result = (unsigned int)(result + 4);
                    v135 = *(_QWORD *)(v3 + 16);
                    v113 = *(_OWORD *)v3;
                    v25 = *(_OWORD *)v12;
                    *(_QWORD *)(v3 + 16) = *(_QWORD *)(v12 + 16);
                    *(_OWORD *)v3 = v25;
                    *(_QWORD *)(v12 + 16) = v135;
                    *(_OWORD *)v12 = v113;
                  }
                }
              }
            }
LABEL_27:
            v38 = *(double *)(v3 + 16);
            v39 = *(double *)(v10 + 16);
            if ( v38 < v39 )
            {
              v40 = (unsigned __int64)(a2 - 3);
              goto LABEL_33;
            }
            v41 = a2 - 3;
            while ( 1 )
            {
              v40 = (unsigned __int64)(v41 - 3);
              if ( v41 - 3 == (double *)v3 )
                break;
              v42 = *(v41 - 1);
              v41 -= 3;
              if ( v42 < v39 )
              {
                LODWORD(result) = result + 1;
                v140 = *(_QWORD *)(v3 + 16);
                v118 = *(_OWORD *)v3;
                v43 = *(_OWORD *)v40;
                *(_QWORD *)(v3 + 16) = *(_QWORD *)(v40 + 16);
                *(_OWORD *)v3 = v43;
                *(_QWORD *)(v40 + 16) = v140;
                *(_OWORD *)v40 = v118;
LABEL_33:
                v44 = v3 + 24;
                if ( v3 + 24 < v40 )
                {
                  while ( 1 )
                  {
                    v45 = *(double *)(v10 + 16);
                    v46 = v44 - 24;
                    do
                    {
                      v47 = *(double *)(v46 + 40);
                      v46 += 24LL;
                    }
                    while ( v47 < v45 );
                    v44 = v46 + 24;
                    do
                    {
                      v48 = *(double *)(v40 - 8);
                      v40 -= 24LL;
                    }
                    while ( v48 >= v45 );
                    if ( v46 > v40 )
                      break;
                    LODWORD(result) = result + 1;
                    if ( v46 == v10 )
                      v10 = v40;
                    v141 = *(_QWORD *)(v46 + 16);
                    v119 = *(_OWORD *)v46;
                    v49 = *(_OWORD *)v40;
                    *(_QWORD *)(v46 + 16) = *(_QWORD *)(v40 + 16);
                    *(_OWORD *)v46 = v49;
                    *(_QWORD *)(v40 + 16) = v141;
                    *(_OWORD *)v40 = v119;
                  }
                  v44 = v46;
                }
                if ( v44 != v10 && *(double *)(v10 + 16) < *(double *)(v44 + 16) )
                {
                  LODWORD(result) = result + 1;
                  v142 = *(_QWORD *)(v44 + 16);
                  v120 = *(_OWORD *)v44;
                  v50 = *(_OWORD *)v10;
                  *(_QWORD *)(v44 + 16) = *(_QWORD *)(v10 + 16);
                  *(_OWORD *)v44 = v50;
                  *(_QWORD *)(v10 + 16) = v142;
                  *(_OWORD *)v10 = v120;
                }
                if ( (_DWORD)result )
                {
LABEL_49:
                  if ( (__int64)(0xAAAAAAAAAAAAAAABLL * ((__int64)(v44 - v3) >> 3)) < (__int64)(0xAAAAAAAAAAAAAAABLL
                                                                                              * ((__int64)((__int64)a2 - v44) >> 3)) )
                  {
                    result = sub_65F95C8(v3, v44);
                    v5 = v44 + 24;
                    goto LABEL_3;
                  }
                  result = sub_65F95C8(v44 + 24, a2);
                  a2 = (double *)v44;
                  goto LABEL_2;
                }
                v5 = v44 + 24;
                v51 = sub_65FA224(v3, v44);
                result = sub_65FA224(v44 + 24, a2);
                if ( (result & 1) == 0 )
                {
                  if ( (v51 & 1) != 0 )
                    goto LABEL_3;
                  goto LABEL_49;
                }
                a2 = (double *)v44;
                if ( (v51 & 1) == 0 )
                  goto LABEL_2;
                return result;
              }
            }
            v52 = v3 + 24;
            if ( v38 >= *(a2 - 1) )
            {
              if ( (__int128 *)v52 == v4 )
                return result;
              while ( v38 >= *(double *)(v52 + 16) )
              {
                v52 += 24LL;
                if ( (__int128 *)v52 == v4 )
                  return result;
              }
              v143 = *(_QWORD *)(v52 + 16);
              v121 = *(_OWORD *)v52;
              v53 = *v4;
              *(double *)(v52 + 16) = *(a2 - 1);
              *(_OWORD *)v52 = v53;
              v52 += 24LL;
              *((_QWORD *)a2 - 1) = v143;
              *v4 = v121;
            }
            if ( (__int128 *)v52 != v4 )
            {
              for ( i = a2 - 3; ; *(_OWORD *)i = v122 )
              {
                v55 = *(double *)(v3 + 16);
                v5 = v52 - 24;
                do
                {
                  v56 = *(double *)(v5 + 40);
                  v5 += 24LL;
                }
                while ( v55 >= v56 );
                v52 = v5 + 24;
                do
                {
                  v57 = *(i - 1);
                  i -= 3;
                }
                while ( v55 < v57 );
                if ( v5 >= (unsigned __int64)i )
                  break;
                v144 = *(_QWORD *)(v5 + 16);
                v122 = *(_OWORD *)v5;
                v58 = *(_OWORD *)i;
                *(double *)(v5 + 16) = i[2];
                *(_OWORD *)v5 = v58;
                *((_QWORD *)i + 2) = v144;
              }
              continue;
            }
            return result;
          }
          v26 = *(double *)(v5 + 16);
          v10 = v5 + 24LL * ((unsigned __int16)((_WORD)a2 - v5) / 0x30u);
          v27 = v3 + 24LL * ((unsigned __int16)v6 / 0x30u);
          v29 = *(double *)(v27 + 16);
          v28 = (double *)(v27 + 16);
          v30 = v29;
          v31 = v29 < v26;
          v32 = *(a2 - 1);
          if ( !v31 )
          {
            if ( v32 >= v30 )
            {
              result = 0LL;
              goto LABEL_27;
            }
            v137 = *(_QWORD *)(v10 + 16);
            v115 = *(_OWORD *)v10;
            v34 = *v4;
            *(double *)(v10 + 16) = *(a2 - 1);
            *(_OWORD *)v10 = v34;
            *((_QWORD *)a2 - 1) = v137;
            *v4 = v115;
            if ( *v28 < *(double *)(v3 + 16) )
            {
              result = 2LL;
              v138 = *(_QWORD *)(v3 + 16);
              v116 = *(_OWORD *)v3;
              v35 = *(_OWORD *)v10;
              *(_QWORD *)(v3 + 16) = *(_QWORD *)(v10 + 16);
              *(_OWORD *)v3 = v35;
              *(_QWORD *)(v10 + 16) = v138;
              *(_OWORD *)v10 = v116;
              goto LABEL_27;
            }
            goto LABEL_24;
          }
          if ( v32 >= v30 )
          {
            v139 = *(_QWORD *)(v3 + 16);
            v117 = *(_OWORD *)v3;
            v36 = *(_OWORD *)v10;
            *(_QWORD *)(v3 + 16) = *(_QWORD *)(v10 + 16);
            *(_OWORD *)v3 = v36;
            *(_QWORD *)(v10 + 16) = v139;
            *(_OWORD *)v10 = v117;
            if ( *(a2 - 1) >= *v28 )
            {
LABEL_24:
              result = 1LL;
              goto LABEL_27;
            }
            result = 2LL;
            v136 = *(_QWORD *)(v10 + 16);
            v114 = *(_OWORD *)v10;
            v37 = *v4;
            *(double *)(v10 + 16) = *(a2 - 1);
            *(_OWORD *)v10 = v37;
          }
          else
          {
            result = 1LL;
            v136 = *(_QWORD *)(v3 + 16);
            v114 = *(_OWORD *)v3;
            v33 = *v4;
            *(double *)(v3 + 16) = *(a2 - 1);
            *(_OWORD *)v3 = v33;
          }
          *((_QWORD *)a2 - 1) = v136;
          *v4 = v114;
          goto LABEL_27;
        }
        v80 = *(double *)(v5 + 40);
        v81 = (double *)(v5 + 48);
        v82 = *(double *)(v5 + 16);
        v83 = (__int128 *)(v5 + 24);
        v84 = *(double *)(v5 + 64);
        if ( v80 >= v82 )
        {
          if ( v84 < v80 )
          {
            v89 = *(_QWORD *)(v5 + 40);
            v90 = *(_OWORD *)v81;
            *(_QWORD *)(v5 + 40) = *(_QWORD *)(v5 + 64);
            v91 = *v83;
            v92 = *(double *)(v5 + 40);
            *(_QWORD *)(v5 + 64) = v89;
            *v83 = v90;
            *(_OWORD *)v81 = v91;
            if ( v92 < v82 )
            {
              v93 = *(_QWORD *)(v5 + 40);
              v152 = *(_QWORD *)(v5 + 16);
              v128 = *(_OWORD *)v5;
              *(_OWORD *)v5 = *v83;
              *(_QWORD *)(v5 + 16) = v93;
              *v83 = v128;
              *(_QWORD *)(v5 + 40) = v152;
            }
          }
        }
        else if ( v84 >= v80 )
        {
          v97 = *(_QWORD *)(v5 + 40);
          v155 = *(_QWORD *)(v5 + 16);
          v130 = *(_OWORD *)v5;
          *(_OWORD *)v5 = *v83;
          *(_QWORD *)(v5 + 16) = v97;
          *(_QWORD *)(v5 + 40) = v155;
          v98 = *(double *)(v5 + 40);
          *v83 = v130;
          if ( v84 < v98 )
          {
            v99 = *(_QWORD *)(v5 + 64);
            v100 = *v83;
            v101 = *(_QWORD *)(v5 + 40);
            *v83 = *(_OWORD *)v81;
            *(_QWORD *)(v5 + 40) = v99;
            *(_OWORD *)v81 = v100;
            *(_QWORD *)(v5 + 64) = v101;
          }
        }
        else
        {
          v85 = *(_QWORD *)(v5 + 64);
          v149 = *(_QWORD *)(v5 + 16);
          v126 = *(_OWORD *)v5;
          *(_OWORD *)v5 = *(_OWORD *)v81;
          *(_QWORD *)(v5 + 16) = v85;
          *(_OWORD *)v81 = v126;
          *(_QWORD *)(v5 + 64) = v149;
        }
        v102 = (double *)(v5 + 72);
        if ( (double *)(v5 + 72) != a2 )
        {
          v103 = 0LL;
          do
          {
            v105 = v81;
            v106 = v102[2];
            v81 = v102;
            if ( v106 < v105[2] )
            {
              v107 = v103;
              v131 = *(_OWORD *)v81;
              do
              {
                v108 = v5 + v107;
                v109 = *(_QWORD *)(v5 + v107 + 64);
                *(_OWORD *)(v108 + 72) = *(_OWORD *)(v5 + v107 + 48);
                *(_QWORD *)(v108 + 88) = v109;
                if ( v107 == -48 )
                {
                  v104 = v5;
                  goto LABEL_96;
                }
                v107 -= 24LL;
              }
              while ( v106 < *(double *)(v108 + 40) );
              v104 = v5 + v107 + 72;
LABEL_96:
              *(double *)(v104 + 16) = v106;
              *(_OWORD *)v104 = v131;
            }
            v102 = v81 + 3;
            v103 += 24LL;
          }
          while ( v81 + 3 != a2 );
        }
        return result;
    }
  }
}


================================================================================
Function: sub_65FA038 (0x65FA038)
================================================================================

__int64 __fastcall sub_65FA038(__int128 *a1, double *a2, double *a3, __int128 *a4)
{
  double v4; // d0
  double v5; // d1
  unsigned int v6; // w8
  __int64 v7; // x10
  __int128 v8; // q1
  __int64 v9; // x11
  __int64 v10; // x8
  __int128 v11; // q1
  __int64 v12; // x10
  __int64 v13; // x10
  __int128 v14; // q1
  __int64 v15; // x11
  __int64 v16; // x8
  __int128 v17; // q1
  __int64 v18; // x10
  __int64 v19; // x10
  __int64 v20; // x10
  __int128 v21; // q1
  __int64 v22; // x11
  __int64 v23; // x10
  __int128 v24; // q1
  __int64 v25; // x11
  __int64 v26; // x10
  __int128 v27; // q1
  __int64 v28; // x11

  v4 = a2[2];
  v5 = a3[2];
  if ( v4 >= *((double *)a1 + 2) )
  {
    if ( v5 >= v4 )
    {
      v6 = 0;
      goto LABEL_12;
    }
    v10 = *((_QWORD *)a3 + 2);
    v11 = *(_OWORD *)a2;
    v12 = *((_QWORD *)a2 + 2);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((_QWORD *)a2 + 2) = v10;
    *(_OWORD *)a3 = v11;
    *((_QWORD *)a3 + 2) = v12;
    if ( a2[2] < *((double *)a1 + 2) )
    {
      v6 = 2;
      v13 = *((_QWORD *)a2 + 2);
      v14 = *a1;
      v15 = *((_QWORD *)a1 + 2);
      *a1 = *(_OWORD *)a2;
      *((_QWORD *)a1 + 2) = v13;
      *(_OWORD *)a2 = v14;
      *((_QWORD *)a2 + 2) = v15;
      goto LABEL_12;
    }
  }
  else
  {
    if ( v5 < v4 )
    {
      v6 = 1;
      v7 = *((_QWORD *)a3 + 2);
      v8 = *a1;
      v9 = *((_QWORD *)a1 + 2);
      *a1 = *(_OWORD *)a3;
      *((_QWORD *)a1 + 2) = v7;
LABEL_9:
      *(_OWORD *)a3 = v8;
      *((_QWORD *)a3 + 2) = v9;
      goto LABEL_12;
    }
    v16 = *((_QWORD *)a2 + 2);
    v17 = *a1;
    v18 = *((_QWORD *)a1 + 2);
    *a1 = *(_OWORD *)a2;
    *((_QWORD *)a1 + 2) = v16;
    *(_OWORD *)a2 = v17;
    *((_QWORD *)a2 + 2) = v18;
    if ( a3[2] < a2[2] )
    {
      v6 = 2;
      v19 = *((_QWORD *)a3 + 2);
      v8 = *(_OWORD *)a2;
      v9 = *((_QWORD *)a2 + 2);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_QWORD *)a2 + 2) = v19;
      goto LABEL_9;
    }
  }
  v6 = 1;
LABEL_12:
  if ( *((double *)a4 + 2) < a3[2] )
  {
    v20 = *((_QWORD *)a4 + 2);
    v21 = *(_OWORD *)a3;
    v22 = *((_QWORD *)a3 + 2);
    *(_OWORD *)a3 = *a4;
    *((_QWORD *)a3 + 2) = v20;
    *a4 = v21;
    *((_QWORD *)a4 + 2) = v22;
    if ( a3[2] >= a2[2] )
    {
      ++v6;
    }
    else
    {
      v23 = *((_QWORD *)a3 + 2);
      v24 = *(_OWORD *)a2;
      v25 = *((_QWORD *)a2 + 2);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_QWORD *)a2 + 2) = v23;
      *(_OWORD *)a3 = v24;
      *((_QWORD *)a3 + 2) = v25;
      if ( a2[2] >= *((double *)a1 + 2) )
      {
        v6 += 2;
      }
      else
      {
        v6 += 3;
        v26 = *((_QWORD *)a2 + 2);
        v27 = *a1;
        v28 = *((_QWORD *)a1 + 2);
        *a1 = *(_OWORD *)a2;
        *((_QWORD *)a1 + 2) = v26;
        *(_OWORD *)a2 = v27;
        *((_QWORD *)a2 + 2) = v28;
      }
    }
  }
  return v6;
}


================================================================================
Function: sub_65FA224 (0x65FA224)
================================================================================

bool __fastcall sub_65FA224(__int64 a1, double *a2)
{
  unsigned __int64 v4; // x8
  _BOOL8 result; // x0
  __int64 v6; // x8
  __int128 v7; // q1
  __int64 v8; // x9
  double v9; // d2
  __int128 *v10; // x8
  double v11; // d0
  __int128 *v12; // x9
  double v13; // d1
  __int64 v14; // x9
  __int128 v15; // q1
  __int64 v16; // x10
  double v17; // d0
  __int128 *v18; // x8
  __int128 *v19; // x9
  double v20; // d1
  __int64 v21; // x8
  __int128 v22; // q1
  __int64 v23; // x10
  __int128 *v24; // x21
  __int128 *v25; // x22
  __int128 *v26; // x23
  __int64 v27; // x8
  __int128 v28; // q1
  __int64 v29; // x9
  __int64 v30; // x9
  double v31; // d1
  __int128 v32; // q2
  double v33; // d0
  __int128 v34; // q3
  __int64 v35; // x9
  double v36; // d1
  __int128 v37; // q2
  double v38; // d0
  __int128 v39; // q3
  __int64 v40; // x8
  __int128 v41; // q1
  __int64 v42; // x9
  __int64 v43; // x11
  __int128 v44; // q2
  __int128 v45; // q3
  double v46; // d1
  __int64 v47; // x10
  __int128 v48; // q1
  __int64 v49; // x11
  __int64 v50; // x10
  __int128 v51; // q1
  __int64 v52; // x11
  __int64 v53; // x9
  __int128 v54; // q1
  __int64 v55; // x10
  __int64 v56; // x11
  __int128 v57; // q2
  __int128 v58; // q3
  double v59; // d0
  __int64 v60; // x10
  __int128 v61; // q1
  __int64 v62; // x11
  double *v63; // x11
  __int64 v64; // x9
  int v65; // w10
  __int64 v66; // x11
  __int128 *v67; // x12
  double v68; // d0
  __int64 v69; // x11
  __int64 v70; // x12
  __int64 v71; // x13
  __int64 v72; // x10
  __int128 v73; // q1
  __int64 v74; // x11
  __int64 v75; // x10
  __int128 v76; // q1
  __int64 v77; // x11
  __int128 v78; // [xsp+0h] [xbp-1F0h]

  v4 = 0xAAAAAAAAAAAAAAABLL * (((__int64)a2 - a1) >> 3);
  result = 1LL;
  switch ( v4 )
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if ( *(a2 - 1) >= *(double *)(a1 + 16) )
        return 1LL;
      result = 1LL;
      v6 = *((_QWORD *)a2 - 1);
      v7 = *(_OWORD *)a1;
      v8 = *(_QWORD *)(a1 + 16);
      *(_OWORD *)a1 = *(_OWORD *)(a2 - 3);
      *(_QWORD *)(a1 + 16) = v6;
      *(_OWORD *)(a2 - 3) = v7;
      *((_QWORD *)a2 - 1) = v8;
      return result;
    case 3uLL:
      v17 = *(double *)(a1 + 40);
      v18 = (__int128 *)(a1 + 24);
      v19 = (__int128 *)(a2 - 3);
      v20 = *(a2 - 1);
      if ( v17 >= *(double *)(a1 + 16) )
      {
        if ( v20 >= v17 )
          return 1LL;
        v50 = *((_QWORD *)a2 - 1);
        v51 = *v18;
        v52 = *(_QWORD *)(a1 + 40);
        *v18 = *v19;
        *(_QWORD *)(a1 + 40) = v50;
        *v19 = v51;
        *((_QWORD *)a2 - 1) = v52;
        if ( *(double *)(a1 + 40) >= *(double *)(a1 + 16) )
          return 1LL;
        result = 1LL;
        v53 = *(_QWORD *)(a1 + 40);
        v54 = *(_OWORD *)a1;
        v55 = *(_QWORD *)(a1 + 16);
        *(_OWORD *)a1 = *v18;
        *(_QWORD *)(a1 + 16) = v53;
        *v18 = v54;
        *(_QWORD *)(a1 + 40) = v55;
      }
      else if ( v20 >= v17 )
      {
        v72 = *(_QWORD *)(a1 + 40);
        v73 = *(_OWORD *)a1;
        v74 = *(_QWORD *)(a1 + 16);
        *(_OWORD *)a1 = *v18;
        *(_QWORD *)(a1 + 16) = v72;
        *v18 = v73;
        *(_QWORD *)(a1 + 40) = v74;
        if ( *(a2 - 1) >= *(double *)(a1 + 40) )
          return 1LL;
        result = 1LL;
        v75 = *((_QWORD *)a2 - 1);
        v76 = *v18;
        v77 = *(_QWORD *)(a1 + 40);
        *v18 = *v19;
        *(_QWORD *)(a1 + 40) = v75;
        *v19 = v76;
        *((_QWORD *)a2 - 1) = v77;
      }
      else
      {
        result = 1LL;
        v21 = *((_QWORD *)a2 - 1);
        v22 = *(_OWORD *)a1;
        v23 = *(_QWORD *)(a1 + 16);
        *(_OWORD *)a1 = *v19;
        *(_QWORD *)(a1 + 16) = v21;
        *v19 = v22;
        *((_QWORD *)a2 - 1) = v23;
      }
      return result;
    case 4uLL:
      sub_65FA038((__int128 *)a1, (double *)(a1 + 24), (double *)(a1 + 48), (__int128 *)(a2 - 3));
      return 1LL;
    case 5uLL:
      v24 = (__int128 *)(a1 + 24);
      v25 = (__int128 *)(a1 + 48);
      v26 = (__int128 *)(a1 + 72);
      sub_65FA038((__int128 *)a1, (double *)(a1 + 24), (double *)(a1 + 48), (__int128 *)(a1 + 72));
      if ( *(a2 - 1) >= *(double *)(a1 + 88) )
        return 1LL;
      v27 = *((_QWORD *)a2 - 1);
      v28 = *v26;
      v29 = *(_QWORD *)(a1 + 88);
      *v26 = *(_OWORD *)(a2 - 3);
      *(_QWORD *)(a1 + 88) = v27;
      *(_OWORD *)(a2 - 3) = v28;
      *((_QWORD *)a2 - 1) = v29;
      if ( *(double *)(a1 + 88) >= *(double *)(a1 + 64) )
        return 1LL;
      v30 = *(_QWORD *)(a1 + 64);
      v31 = *(double *)(a1 + 40);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 88);
      v32 = *v26;
      v33 = *(double *)(a1 + 64);
      *(_QWORD *)(a1 + 88) = v30;
      v34 = *v25;
      *v25 = v32;
      *v26 = v34;
      if ( v33 >= v31 )
        return 1LL;
      v35 = *(_QWORD *)(a1 + 40);
      v36 = *(double *)(a1 + 16);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 64);
      v37 = *v25;
      v38 = *(double *)(a1 + 40);
      *(_QWORD *)(a1 + 64) = v35;
      v39 = *v24;
      *v24 = v37;
      *v25 = v39;
      if ( v38 >= v36 )
        return 1LL;
      result = 1LL;
      v40 = *(_QWORD *)(a1 + 40);
      v41 = *(_OWORD *)a1;
      v42 = *(_QWORD *)(a1 + 16);
      *(_OWORD *)a1 = *v24;
      *(_QWORD *)(a1 + 16) = v40;
      *v24 = v41;
      *(_QWORD *)(a1 + 40) = v42;
      return result;
    default:
      v9 = *(double *)(a1 + 40);
      v10 = (__int128 *)(a1 + 48);
      v11 = *(double *)(a1 + 16);
      v12 = (__int128 *)(a1 + 24);
      v13 = *(double *)(a1 + 64);
      if ( v9 >= v11 )
      {
        if ( v13 < v9 )
        {
          v43 = *(_QWORD *)(a1 + 40);
          v44 = *v10;
          *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 64);
          v45 = *v12;
          v46 = *(double *)(a1 + 40);
          *(_QWORD *)(a1 + 64) = v43;
          *v12 = v44;
          *v10 = v45;
          if ( v46 < v11 )
          {
            v47 = *(_QWORD *)(a1 + 40);
            v48 = *(_OWORD *)a1;
            v49 = *(_QWORD *)(a1 + 16);
            *(_OWORD *)a1 = *v12;
            *(_QWORD *)(a1 + 16) = v47;
            *v12 = v48;
            *(_QWORD *)(a1 + 40) = v49;
          }
        }
      }
      else if ( v13 >= v9 )
      {
        v56 = *(_QWORD *)(a1 + 40);
        v57 = *v12;
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 16);
        v58 = *(_OWORD *)a1;
        v59 = *(double *)(a1 + 40);
        *(_QWORD *)(a1 + 16) = v56;
        *(_OWORD *)a1 = v57;
        *v12 = v58;
        if ( v13 < v59 )
        {
          v60 = *(_QWORD *)(a1 + 64);
          v61 = *v12;
          v62 = *(_QWORD *)(a1 + 40);
          *v12 = *v10;
          *(_QWORD *)(a1 + 40) = v60;
          *v10 = v61;
          *(_QWORD *)(a1 + 64) = v62;
        }
      }
      else
      {
        v14 = *(_QWORD *)(a1 + 64);
        v15 = *(_OWORD *)a1;
        v16 = *(_QWORD *)(a1 + 16);
        *(_OWORD *)a1 = *v10;
        *(_QWORD *)(a1 + 16) = v14;
        *v10 = v15;
        *(_QWORD *)(a1 + 64) = v16;
      }
      v63 = (double *)(a1 + 72);
      if ( (double *)(a1 + 72) == a2 )
        return 1LL;
      v64 = 0LL;
      v65 = 0;
      break;
  }
  while ( 1 )
  {
    v67 = v10;
    v68 = v63[2];
    v10 = (__int128 *)v63;
    if ( v68 < *((double *)v67 + 2) )
    {
      v69 = v64;
      v78 = *v10;
      do
      {
        v70 = a1 + v69;
        v71 = *(_QWORD *)(a1 + v69 + 64);
        *(_OWORD *)(v70 + 72) = *(_OWORD *)(a1 + v69 + 48);
        *(_QWORD *)(v70 + 88) = v71;
        if ( v69 == -48 )
        {
          v66 = a1;
          goto LABEL_27;
        }
        v69 -= 24LL;
      }
      while ( v68 < *(double *)(v70 + 40) );
      v66 = a1 + v69 + 72;
LABEL_27:
      ++v65;
      *(double *)(v66 + 16) = v68;
      *(_OWORD *)v66 = v78;
      if ( v65 == 8 )
        return (double *)((char *)v10 + 24) == a2;
    }
    v63 = (double *)v10 + 3;
    v64 += 24LL;
    if ( (double *)((char *)v10 + 24) == a2 )
      return 1LL;
  }
}


================================================================================
Function: sub_65FA7DC (0x65FA7DC)
================================================================================

_QWORD *sub_65FA7DC()
{
  _QWORD *result; // x0
  _QWORD *v1; // x19
  _QWORD *v2; // x0

  result = sub_6866980(qword_6CA9548);
  if ( (*(_BYTE *)result & 1) == 0 )
  {
    if ( !*(_BYTE *)sub_6866980(qword_6CA9568) )
    {
      *(_BYTE *)sub_6866980(qword_6CA9568) = 1;
      v2 = sub_6866980(qword_6CA9508);
      *((_OWORD *)v2 + 63) = 0u;
      sub_6863688(sub_65FA8C8, v2, &off_686E780);
    }
    v1 = sub_6866980(qword_6CA9528);
    *v1 = sub_6866980(qword_6CA9508);
    result = sub_6866980(qword_6CA9548);
    *(_BYTE *)result = 1;
  }
  return result;
}


================================================================================
Function: sub_65FA898 (0x65FA898)
================================================================================

__int64 sub_65FA898()
{
  sub_65FA7DC();
  return *(_QWORD *)sub_6866980(&unk_6CA9528);
}


================================================================================
Function: sub_65FA98C (0x65FA98C)
================================================================================

__int64 __fastcall sub_65FA98C(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6)
{
  unsigned int i; // w24
  int v13; // w8
  unsigned int v14; // w25
  unsigned int v15; // w0
  __int64 result; // x0
  unsigned __int16 v17; // w8

  if ( *(_QWORD *)a1 )
    sub_65EFD58(0);
  *(_QWORD *)(a1 + 8) = a5;
  *(_QWORD *)(a1 + 16) = a6;
  for ( i = atomic_load((unsigned __int16 *)&unk_7300D10); ; i = v15 )
  {
    if ( ((unsigned __int16)(a4 - 1) & (unsigned __int16)i) != 0 )
      v13 = (a4 + 0xFFFF + (unsigned __int16)i) & -a4;
    else
      v13 = i;
    v14 = v13 + a3;
    *(_WORD *)(a1 + 26) = v13;
    if ( (unsigned __int16)(v13 + a3) >= 0x3F1u )
      sub_65EFD58(0);
    v15 = sub_6866E20(i, v14, &unk_7300D10);
    if ( v15 == (unsigned __int16)i )
      break;
  }
  *(_QWORD *)a1 = a2;
  result = sub_6867360(1LL, &unk_7300D12);
  if ( (unsigned int)result < 0x81 )
  {
    v17 = 127 - result;
    *(_WORD *)(a1 + 24) = 127 - result;
  }
  else
  {
    result = sub_65EFD58(0);
    v17 = *(_WORD *)(a1 + 24);
  }
  *((_QWORD *)&unk_7300D10 + v17 + 1) = a1;
  return result;
}


================================================================================
Function: sub_65FAAE0 (0x65FAAE0)
================================================================================

__int64 __fastcall sub_65FAAE0(__int64 a1)
{
  __int64 v2; // x0
  __int64 v3; // x21
  __int64 v4; // x10
  __int64 v5; // x20

  v2 = sub_65FA898();
  v3 = v2 + 1008;
  v4 = *(unsigned __int16 *)(a1 + 26);
  v5 = v2 + v4;
  if ( ((*(_QWORD *)(v2 + 1008 + (((unsigned __int64)*(unsigned __int16 *)(a1 + 24) >> 3) & 0x1FF8)) >> *(_WORD *)(a1 + 24)) & 1) == 0 )
  {
    (*(void (__fastcall **)(__int64, _QWORD))(a1 + 8))(v2 + v4, *(_QWORD *)a1);
    *(_QWORD *)(v3 + (((unsigned __int64)*(unsigned __int16 *)(a1 + 24) >> 3) & 0x1FF8)) |= 1LL << *(_WORD *)(a1 + 24);
  }
  return v5;
}


================================================================================
Function: sub_65FC630 (0x65FC630)
================================================================================

unsigned __int64 *__usercall sub_65FC630@<X0>(__int128 *a1@<X0>, unsigned __int64 *a2@<X8>)
{
  return sub_68497A0(a2, a1);
}


================================================================================
Function: sub_65FD0A0 (0x65FD0A0)
================================================================================

__int64 __fastcall sub_65FD0A0(__int64 a1, __int64 a2)
{
  pthread_mutex_t *v2; // x19
  __int64 v5; // [xsp+0h] [xbp-10h] BYREF

  v2 = (pthread_mutex_t *)(a1 + 8);
  v5 = a2;
  sub_65EF448(a1 + 8);
  sub_65FD3D4(a1 + 48, &v5, &v5);
  return sub_68489D4(v2);
}


================================================================================
Function: sub_65FD178 (0x65FD178)
================================================================================

unsigned __int64 __fastcall sub_65FD178(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x8
  unsigned __int64 v10; // x10
  uint8x8_t v11; // d0
  _QWORD *i; // x12
  unsigned __int64 v13; // x13
  _QWORD *v14; // x15
  _QWORD *v15; // x14
  __int64 v16; // x13

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_681B888(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_681B888(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_65ECAAC();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_65ECAF4();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          for ( i = (_QWORD *)*v9; *v9; i = (_QWORD *)*v9 )
          {
            v13 = i[1];
            if ( v11.n64_u32[0] > 1uLL )
            {
              if ( v13 >= v3.n64_u64[0] )
                v13 %= v3.n64_u64[0];
            }
            else
            {
              v13 &= v3.n64_u64[0] - 1;
            }
            if ( v13 == v10 )
            {
              v9 = i;
            }
            else
            {
              v14 = i;
              if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v13) )
              {
                do
                {
                  v15 = v14;
                  v14 = (_QWORD *)*v14;
                }
                while ( v14 && i[2] == v14[2] );
                *v9 = v14;
                v16 = 8 * v13;
                *v15 = **(_QWORD **)(v2->n64_u64[0] + v16);
                **(_QWORD **)(v2->n64_u64[0] + v16) = i;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v13) = v9;
                v9 = i;
                v10 = v13;
              }
            }
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_65ECAF4();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_65FD3D4 (0x65FD3D4)
================================================================================

_QWORD *__fastcall sub_65FD3D4(float *a1, _QWORD *a2, __int64 *a3)
{
  unsigned __int64 v3; // x24
  unsigned __int64 v5; // x22
  __int64 v6; // x11
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x23
  uint8x8_t v10; // d0
  _QWORD *v11; // x20
  unsigned __int64 v12; // x11
  _QWORD *v13; // x0
  __int64 v14; // x8
  __int64 v15; // x9
  float v16; // s1
  float v17; // s0
  _BOOL8 v18; // x9
  unsigned __int64 v19; // x10
  __int64 v20; // x1
  __int64 v21; // x8
  _QWORD *v22; // x9
  __int64 v23; // x10
  unsigned __int64 v24; // x8

  v5 = *((_QWORD *)a1 + 1);
  v6 = HIDWORD(*a2);
  v8 = 0x9DDFEA08EB382D69LL * ((8 * (unsigned int)*a2 + 8LL) ^ v6);
  v9 = 0x9DDFEA08EB382D69LL
     * ((0x9DDFEA08EB382D69LL * (v8 ^ v6 ^ (v8 >> 47))) ^ ((0x9DDFEA08EB382D69LL * (v8 ^ v6 ^ (v8 >> 47))) >> 47));
  if ( v5 )
  {
    v10.n64_u64[0] = vcnt_s8((int8x8_t)v5).n64_u64[0];
    v10.n64_u16[0] = vaddlv_u8(v10);
    if ( v10.n64_u32[0] > 1uLL )
    {
      v3 = 0x9DDFEA08EB382D69LL
         * ((0x9DDFEA08EB382D69LL * (v8 ^ v6 ^ (v8 >> 47))) ^ ((0x9DDFEA08EB382D69LL * (v8 ^ v6 ^ (v8 >> 47))) >> 47));
      if ( v9 >= v5 )
        v3 = v9 % v5;
    }
    else
    {
      v3 = v9 & (v5 - 1);
    }
    v11 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if ( v11 )
    {
      while ( 1 )
      {
        v11 = (_QWORD *)*v11;
        if ( !v11 )
          break;
        v12 = v11[1];
        if ( v12 != v9 )
        {
          if ( v10.n64_u32[0] <= 1uLL )
          {
            v12 &= v5 - 1;
          }
          else if ( v12 >= v5 )
          {
            v12 %= v5;
          }
          if ( v12 != v3 )
            break;
        }
        if ( v11[2] == *a2 )
          return v11;
      }
    }
  }
  v13 = (_QWORD *)sub_65ECAAC();
  v14 = *((_QWORD *)a1 + 3);
  v11 = v13;
  v15 = *a3;
  *v13 = 0LL;
  v16 = a1[8];
  v13[1] = v9;
  v13[2] = v15;
  v17 = (float)(unsigned __int64)(v14 + 1);
  if ( !v5 || (float)(v16 * (float)v5) < v17 )
  {
    v18 = v5 < 3 || (v5 & (v5 - 1)) != 0;
    v19 = vcvtps_u32_f32(v17 / v16);
    if ( (v18 | (2 * v5)) >= v19 )
      v20 = v18 | (2 * v5);
    else
      v20 = v19;
    sub_65FD178(a1, v20);
    v5 = *((_QWORD *)a1 + 1);
    if ( (v5 & (v5 - 1)) != 0 )
    {
      if ( v9 >= v5 )
        v3 = v9 % v5;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v5 - 1) & v9;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if ( v22 )
  {
    *v11 = *v22;
    *v22 = v11;
  }
  else
  {
    v23 = *((_QWORD *)a1 + 2);
    *((_QWORD *)a1 + 2) = v11;
    *v11 = v23;
    *(_QWORD *)(v21 + 8 * v3) = a1 + 4;
    if ( *v11 )
    {
      v24 = *(_QWORD *)(*v11 + 8LL);
      if ( (v5 & (v5 - 1)) != 0 )
      {
        if ( v24 >= v5 )
          v24 %= v5;
      }
      else
      {
        v24 &= v5 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v11;
    }
  }
  ++*((_QWORD *)a1 + 3);
  return v11;
}


================================================================================
Function: sub_65FE32C (0x65FE32C)
================================================================================

__int64 sub_65FE32C()
{
  return 3LL;
}


================================================================================
Function: sub_65FE334 (0x65FE334)
================================================================================

const char *__fastcall sub_65FE334(int a1)
{
  if ( (unsigned int)(a1 - 1) > 3 )
    return "unknown";
  else
    return (char *)dword_17168F8 + dword_17168F8[a1 - 1];
}


================================================================================
Function: sub_65FE394 (0x65FE394)
================================================================================

__int64 __fastcall sub_65FE394(_DWORD *a1, _DWORD *a2)
{
  __int64 result; // x0

  result = sub_65FE514(a1 + 2, (a2[3] << 10) & 0x7FFC00 | *a2 & 0x3FFLL | ((a2[2] & 0xFFFLL) << 23));
  *a1 = result;
  return result;
}


================================================================================
Function: sub_65FE3D8 (0x65FE3D8)
================================================================================

__int64 __fastcall sub_65FE3D8(__int64 result, __int64 a2, _DWORD *a3)
{
  char *v3; // x9
  unsigned __int64 v4; // x8
  _BYTE *v5; // x10
  char v6; // t1

  if ( (int)*a3 >= 1 )
  {
    v3 = (char *)(a3 + 2);
    v4 = result + a2 + ~*a3;
    v5 = (_BYTE *)(result + a2 - 1);
    do
    {
      v6 = *v3++;
      *v5-- = v6;
    }
    while ( (unsigned __int64)v5 > v4 );
  }
  return result;
}


================================================================================
Function: sub_65FE40C (0x65FE40C)
================================================================================

__int64 __fastcall sub_65FE40C(__int64 a1, __int64 a2)
{
  __int64 v2; // x21
  char *v3; // x19
  int v4; // w0
  __int64 v5; // x9
  unsigned __int64 v6; // x8
  __int64 v7; // x10
  char *v8; // x9
  __int64 v9; // x11
  char *v10; // x10
  _BYTE *v11; // x13
  unsigned __int64 v12; // x14
  char v13; // w15
  char v14; // w16
  char v15; // t1
  char v17; // [xsp+8h] [xbp-18h] BYREF
  _BYTE v18[7]; // [xsp+9h] [xbp-17h] BYREF

  v2 = a1 + a2;
  v3 = (char *)(a1 + a2 - 1);
  v4 = sub_65FE7D4(v3);
  if ( v4 >= 1 )
  {
    v5 = v2 - 2;
    v6 = v2 + ~v4;
    if ( v6 < v2 - 2 )
      v5 = v2 + ~v4;
    v7 = ~v5;
    v8 = &v17;
    v9 = v2 + v7;
    if ( (unsigned __int64)(v2 + v7) < 2 )
    {
      v10 = v3;
      do
      {
LABEL_9:
        v15 = *v10--;
        *v8++ = v15;
      }
      while ( (unsigned __int64)v10 > v6 );
      return sub_65FE6D8(&v17) & 0x3FF;
    }
    v11 = v18;
    v10 = &v3[-(v9 & 0xFFFFFFFFFFFFFFFELL)];
    v8 = &v18[(v9 & 0xFFFFFFFFFFFFFFFELL) - 1];
    v12 = v9 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v13 = *v3;
      v12 -= 2LL;
      v14 = *(v3 - 1);
      v3 -= 2;
      *(v11 - 1) = v13;
      *v11 = v14;
      v11 += 2;
    }
    while ( v12 );
    if ( v9 != (v9 & 0xFFFFFFFFFFFFFFFELL) )
      goto LABEL_9;
  }
  return sub_65FE6D8(&v17) & 0x3FF;
}


================================================================================
Function: sub_65FE514 (0x65FE514)
================================================================================

__int64 __fastcall sub_65FE514(_BYTE *a1, unsigned __int64 a2)
{
  if ( a2 > 0xF0 )
  {
    if ( a2 > 0x8EF )
    {
      if ( a2 > 0x108EF )
      {
        if ( a2 >> 24 )
        {
          if ( HIDWORD(a2) )
          {
            if ( a2 >> 40 )
            {
              if ( HIWORD(a2) )
              {
                if ( HIBYTE(a2) )
                {
                  a1[2] = BYTE6(a2);
                  a1[3] = BYTE5(a2);
                  a1[5] = BYTE3(a2);
                  a1[1] = HIBYTE(a2);
                  *a1 = -1;
                  a1[4] = BYTE4(a2);
                  a1[6] = BYTE2(a2);
                  a1[7] = BYTE1(a2);
                  a1[8] = a2;
                  return 9LL;
                }
                else
                {
                  a1[2] = BYTE5(a2);
                  a1[3] = BYTE4(a2);
                  a1[4] = BYTE3(a2);
                  a1[1] = BYTE6(a2);
                  *a1 = -2;
                  a1[5] = BYTE2(a2);
                  a1[6] = BYTE1(a2);
                  a1[7] = a2;
                  return 8LL;
                }
              }
              else
              {
                a1[1] = BYTE5(a2);
                a1[2] = BYTE4(a2);
                a1[3] = BYTE3(a2);
                *a1 = -3;
                a1[4] = BYTE2(a2);
                a1[5] = BYTE1(a2);
                a1[6] = a2;
                return 7LL;
              }
            }
            else
            {
              a1[1] = BYTE4(a2);
              a1[2] = BYTE3(a2);
              *a1 = -4;
              a1[3] = BYTE2(a2);
              a1[4] = BYTE1(a2);
              a1[5] = a2;
              return 6LL;
            }
          }
          else
          {
            a1[1] = BYTE3(a2);
            a1[4] = a2;
            *a1 = -5;
            a1[2] = BYTE2(a2);
            a1[3] = BYTE1(a2);
            return 5LL;
          }
        }
        else
        {
          a1[3] = a2;
          *a1 = -6;
          a1[1] = BYTE2(a2);
          a1[2] = BYTE1(a2);
          return 4LL;
        }
      }
      else
      {
        *a1 = -7;
        a1[1] = (unsigned __int16)(a2 - 2288) >> 8;
        a1[2] = a2 + 16;
        return 3LL;
      }
    }
    else
    {
      a1[1] = a2 + 16;
      *a1 = ((unsigned __int16)(a2 - 240) >> 8) - 15;
      return 2LL;
    }
  }
  else
  {
    *a1 = a2;
    return 1LL;
  }
}


================================================================================
Function: sub_65FE6D8 (0x65FE6D8)
================================================================================

unsigned __int64 __fastcall sub_65FE6D8(unsigned __int8 *a1)
{
  unsigned __int64 result; // x0

  result = *a1;
  if ( (unsigned int)result >= 0xF1 )
  {
    if ( (unsigned int)result > 0xF8 )
    {
      switch ( (int)result )
      {
        case 249:
          result = bswap64((unsigned __int64)*(unsigned __int16 *)(a1 + 1) << 48) + 2288;
          break;
        case 250:
          result = bswap64((unsigned __int64)*((unsigned __int16 *)a1 + 1) << 48) & 0xFFFFFFFFFF00FFFFLL | ((unsigned __int64)a1[1] << 16);
          break;
        case 251:
          result = bswap64((unsigned __int64)*(unsigned int *)(a1 + 1) << 32);
          break;
        case 252:
          result = bswap64((unsigned __int64)*(unsigned int *)(a1 + 2) << 32) & 0xFFFFFF00FFFFFFFFLL | ((unsigned __int64)a1[1] << 32);
          break;
        case 253:
          result = bswap64((unsigned __int64)*(unsigned int *)(a1 + 3) << 32) & 0xFFFF0000FFFFFFFFLL | ((unsigned __int64)a1[2] << 32) & 0xFFFF00FFFFFFFFFFLL | ((unsigned __int64)a1[1] << 40);
          break;
        case 254:
          result = bswap64((unsigned __int64)*((unsigned int *)a1 + 1) << 32) & 0xFF000000FFFFFFFFLL | ((unsigned __int64)a1[3] << 32) & 0xFF0000FFFFFFFFFFLL | ((unsigned __int64)a1[2] << 40) & 0xFF00FFFFFFFFFFFFLL | ((unsigned __int64)a1[1] << 48);
          break;
        default:
          result = bswap64(*(_QWORD *)(a1 + 1));
          break;
      }
    }
    else
    {
      return (a1[1] | ((unsigned __int8)result << 8)) - 61456;
    }
  }
  return result;
}


================================================================================
Function: sub_65FE7D4 (0x65FE7D4)
================================================================================

__int64 __fastcall sub_65FE7D4(unsigned __int8 *a1)
{
  unsigned int v1; // w8
  unsigned int v3; // w8

  v1 = *a1;
  if ( v1 < 0xF1 )
    return 1LL;
  if ( v1 < 0xF9 )
    return 2LL;
  v3 = (unsigned __int8)(v1 + 7);
  if ( v3 > 5 )
    return 9LL;
  else
    return v3 + 3;
}


================================================================================
Function: sub_65FF79C (0x65FF79C)
================================================================================

unsigned __int8 *__fastcall sub_65FF79C(unsigned __int8 *a1, size_t n, int c)
{
  unsigned __int64 v4; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x27
  __int64 v9; // x9
  unsigned __int8 *v10; // x23
  const void *v11; // x23
  unsigned __int64 v12; // x24
  void *v13; // x25
  size_t v14; // x8
  unsigned __int64 v16; // x8

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( !n )
    return a1;
  v4 = *a1;
  if ( (v4 & 1) == 0 )
  {
    v7 = v4 >> 1;
    v8 = 22LL;
    LOBYTE(v9) = *a1;
    if ( 22 - (v4 >> 1) >= n )
      goto LABEL_4;
LABEL_7:
    if ( -17LL - v8 < v7 + n - v8 )
      abort();
    if ( (v4 & 1) != 0 )
    {
      v11 = (const void *)*((_QWORD *)a1 + 2);
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
      {
LABEL_10:
        v12 = -17LL;
        v13 = (void *)sub_65ECAAC();
        if ( !v7 )
        {
LABEL_12:
          if ( v8 != 22 )
            sub_65ECAF4();
          *((_QWORD *)a1 + 2) = v13;
          *(_QWORD *)a1 = v12 | 1;
          goto LABEL_15;
        }
LABEL_11:
        memcpy(v13, v11, v7);
        goto LABEL_12;
      }
    }
    else
    {
      v11 = a1 + 1;
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
        goto LABEL_10;
    }
    v16 = 2 * v8;
    if ( v7 + n >= 2 * v8 )
      v16 = v7 + n;
    if ( v16 >= 0x17 )
    {
      v12 = (v16 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v13 = (void *)sub_65ECAAC();
      if ( !v7 )
        goto LABEL_12;
    }
    else
    {
      v12 = 23LL;
      v13 = (void *)sub_65ECAAC();
      if ( !v7 )
        goto LABEL_12;
    }
    goto LABEL_11;
  }
  v9 = *(_QWORD *)a1;
  v7 = *((_QWORD *)a1 + 1);
  v8 = (*(_QWORD *)a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  if ( v8 - v7 < n )
    goto LABEL_7;
LABEL_4:
  if ( (v9 & 1) != 0 )
  {
LABEL_15:
    v10 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    goto LABEL_16;
  }
  v10 = a1 + 1;
LABEL_16:
  memset(&v10[v7], c, n);
  v14 = v7 + n;
  if ( (*a1 & 1) != 0 )
    *((_QWORD *)a1 + 1) = v14;
  else
    *a1 = 2 * v14;
  v10[v14] = 0;
  return a1;
}


================================================================================
Function: sub_65FF9FC (0x65FF9FC)
================================================================================

unsigned __int64 *__fastcall sub_65FF9FC(unsigned __int64 *a1, void *src, size_t n)
{
  unsigned __int64 v6; // x26
  _BYTE *v7; // x22
  unsigned __int64 v8; // x23
  unsigned __int64 v9; // x8
  void *v10; // x24

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v6 >= n )
    {
LABEL_3:
      if ( (*(_BYTE *)a1 & 1) != 0 )
      {
        v7 = (_BYTE *)a1[2];
        if ( !n )
          goto LABEL_13;
      }
      else
      {
        v7 = (char *)a1 + 1;
        if ( !n )
        {
LABEL_13:
          v7[n] = 0;
          if ( (*(_BYTE *)a1 & 1) != 0 )
            a1[1] = n;
          else
            *(_BYTE *)a1 = 2 * n;
          return a1;
        }
      }
      memmove(v7, src, n);
      goto LABEL_13;
    }
  }
  else
  {
    v6 = 22LL;
    if ( n <= 0x16 )
      goto LABEL_3;
  }
  if ( -18LL - v6 < n - v6 )
    abort();
  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
      goto LABEL_10;
LABEL_17:
    v9 = 2 * v6;
    if ( 2 * v6 <= n )
      v9 = n;
    if ( v9 >= 0x17 )
      v8 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v8 = 23LL;
    goto LABEL_22;
  }
  if ( v6 <= 0x7FFFFFFFFFFFFFE6LL )
    goto LABEL_17;
LABEL_10:
  v8 = -17LL;
LABEL_22:
  v10 = (void *)sub_65ECAAC();
  memcpy(v10, src, n);
  if ( v6 != 22 )
    sub_65ECAF4();
  a1[1] = n;
  a1[2] = (unsigned __int64)v10;
  *a1 = v8 | 1;
  *((_BYTE *)v10 + n) = 0;
  return a1;
}


================================================================================
Function: sub_65FFB9C (0x65FFB9C)
================================================================================

unsigned __int64 *__fastcall sub_65FFB9C(unsigned __int64 *a1, void *src, size_t n)
{
  unsigned __int64 v6; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x27
  char *v9; // x23
  unsigned __int64 v10; // x28
  const void *v11; // x23
  unsigned __int64 v12; // x24
  char *v13; // x25
  char *v14; // x8
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x8

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v6 = *(unsigned __int8 *)a1;
  if ( (v6 & 1) == 0 )
  {
    v7 = v6 >> 1;
    v8 = 22LL;
    if ( 22 - (v6 >> 1) >= n )
      goto LABEL_3;
LABEL_7:
    v10 = v7 + n;
    if ( -18LL - v8 < v7 + n - v8 )
      abort();
    if ( (v6 & 1) != 0 )
    {
      v11 = (const void *)a1[2];
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
      {
LABEL_10:
        v12 = -17LL;
        v13 = (char *)sub_65ECAAC();
        if ( !v7 )
        {
LABEL_12:
          memcpy(&v13[v7], src, n);
          if ( v8 != 22 )
            sub_65ECAF4();
          *a1 = v12 | 1;
          v14 = &v13[v10];
          a1[1] = v10;
          a1[2] = (unsigned __int64)v13;
          goto LABEL_26;
        }
LABEL_11:
        memcpy(v13, v11, v7);
        goto LABEL_12;
      }
    }
    else
    {
      v11 = (char *)a1 + 1;
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
        goto LABEL_10;
    }
    v15 = 2 * v8;
    if ( v10 >= 2 * v8 )
      v15 = v7 + n;
    if ( v15 >= 0x17 )
    {
      v12 = (v15 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v13 = (char *)sub_65ECAAC();
      if ( !v7 )
        goto LABEL_12;
    }
    else
    {
      v12 = 23LL;
      v13 = (char *)sub_65ECAAC();
      if ( !v7 )
        goto LABEL_12;
    }
    goto LABEL_11;
  }
  v7 = a1[1];
  v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  if ( v8 - v7 < n )
    goto LABEL_7;
LABEL_3:
  if ( n )
  {
    if ( (v6 & 1) != 0 )
      v9 = (char *)a1[2];
    else
      v9 = (char *)a1 + 1;
    memcpy(&v9[v7], src, n);
    v16 = v7 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v16;
    else
      *(_BYTE *)a1 = 2 * v16;
    v14 = &v9[v16];
LABEL_26:
    *v14 = 0;
  }
  return a1;
}


================================================================================
Function: sub_65FFD70 (0x65FFD70)
================================================================================

_QWORD *__fastcall sub_65FFD70(_QWORD *a1)
{
  char *v2; // x8
  __int64 v3; // x0
  __int64 v4; // x8
  char *v5; // x8
  __int64 v6; // x0

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v2 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  v3 = *((_QWORD *)v2 + 5);
  if ( v3 )
  {
    if ( !*((_DWORD *)v2 + 8) )
    {
      v4 = *((_QWORD *)v2 + 17);
      if ( v4 )
      {
        sub_65FFD70(v4);
        v3 = *(_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 40);
      }
      v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 48LL))(v3);
      if ( (_DWORD)v3 == -1 )
        v3 = sub_681F428(
               (char *)a1 + *(_QWORD *)(*a1 - 24LL),
               *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 1u);
    }
    v5 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    if ( *((_QWORD *)v5 + 5) )
    {
      if ( !*((_DWORD *)v5 + 8) && (v5[9] & 0x20) != 0 && (sub_6819F00(v3) & 1) == 0 )
      {
        v6 = *(_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 40);
        if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v6 + 48LL))(v6) == -1 )
          sub_681F428((char *)a1 + *(_QWORD *)(*a1 - 24LL), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 32) | 1u);
      }
    }
  }
  return a1;
}


================================================================================
Function: sub_66013A0 (0x66013A0)
================================================================================

__int64 __fastcall sub_66013A0(_QWORD *a1)
{
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  *a1 = off_6C27F08;
  return sub_683B844(a1 + 1);
}


================================================================================
Function: sub_6601588 (0x6601588)
================================================================================

unsigned __int64 *__fastcall sub_6601588(unsigned __int64 *result, char a2)
{
  unsigned __int64 *v2; // x20
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x26
  size_t v6; // x21
  char *v7; // x23
  const void *v8; // x22
  unsigned __int64 v9; // x24
  unsigned __int64 v10; // x8
  char *v11; // x8

  v2 = result;
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = *(unsigned __int8 *)result;
  if ( (v4 & 1) != 0 )
  {
    v5 = result[1];
    v6 = (*result & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v5 != v6 )
      goto LABEL_3;
LABEL_6:
    if ( v6 == -17LL )
      abort();
    if ( (v4 & 1) != 0 )
    {
      v8 = (const void *)result[2];
      if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
        goto LABEL_9;
    }
    else
    {
      v8 = (char *)result + 1;
      if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
      {
LABEL_9:
        v9 = -17LL;
        goto LABEL_18;
      }
    }
    if ( v6 + 1 >= 2 * v6 )
      v10 = v6 + 1;
    else
      v10 = 2 * v6;
    if ( v10 >= 0x17 )
      v9 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v9 = 23LL;
LABEL_18:
    v7 = (char *)sub_65ECAAC();
    result = (unsigned __int64 *)memcpy(v7, v8, v6);
    if ( v6 != 22 )
      result = (unsigned __int64 *)sub_65ECAF4();
    v2[2] = (unsigned __int64)v7;
    *v2 = v9 | 1;
    goto LABEL_21;
  }
  v5 = v4 >> 1;
  v6 = 22LL;
  if ( v4 >> 1 == 22 )
    goto LABEL_6;
LABEL_3:
  if ( (v4 & 1) != 0 )
  {
    v7 = (char *)result[2];
LABEL_21:
    v2[1] = v5 + 1;
    goto LABEL_22;
  }
  *(_BYTE *)result = 2 * v5 + 2;
  v7 = (char *)result + 1;
LABEL_22:
  v11 = &v7[v5];
  *v11 = a2;
  v11[1] = 0;
  return result;
}


================================================================================
Function: sub_6601820 (0x6601820)
================================================================================

unsigned __int64 *__fastcall sub_6601820(unsigned __int64 *result, unsigned __int64 a2)
{
  unsigned __int64 v2; // x25
  unsigned __int64 *v3; // x19
  unsigned __int64 v4; // x23
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x24
  const void *v8; // x21
  int v9; // w26
  unsigned __int64 *v10; // x20
  int v11; // w27
  size_t v12; // x2
  unsigned __int64 v13; // x8

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a2 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  v2 = *(unsigned __int8 *)result;
  v3 = result;
  if ( (v2 & 1) == 0 )
  {
    v4 = v2 >> 1;
    v5 = 22LL;
    if ( v2 >> 1 <= a2 )
      v6 = a2;
    else
      v6 = v2 >> 1;
    if ( v6 >= 0x17 )
      goto LABEL_7;
LABEL_15:
    v7 = 22LL;
    if ( v5 == 22 )
      return result;
    goto LABEL_8;
  }
  v4 = result[1];
  v5 = (*result & 0xFFFFFFFFFFFFFFFELL) - 1;
  if ( v4 <= a2 )
    v6 = a2;
  else
    v6 = result[1];
  if ( v6 < 0x17 )
    goto LABEL_15;
LABEL_7:
  v7 = ((v6 + 16) & 0xFFFFFFFFFFFFFFF0LL) - 1;
  if ( v7 == v5 )
    return result;
LABEL_8:
  if ( v7 == 22 )
  {
    v8 = (const void *)result[2];
    v9 = 0;
    v10 = (unsigned __int64 *)((char *)result + 1);
    if ( (v2 & 1) == 0 )
    {
      v11 = 1;
      v12 = ((unsigned int)v2 >> 1) + 1LL;
LABEL_21:
      result = (unsigned __int64 *)memcpy(v10, v8, v12);
      goto LABEL_22;
    }
  }
  else
  {
    result = (unsigned __int64 *)sub_65ECAAC();
    v10 = result;
    if ( (v2 & 1) == 0 )
    {
      v11 = 0;
      v8 = (char *)v3 + 1;
      v9 = 1;
      v12 = ((unsigned int)v2 >> 1) + 1LL;
      goto LABEL_21;
    }
    v8 = (const void *)v3[2];
    v9 = 1;
  }
  v13 = v3[1];
  v11 = 1;
  v12 = v13 + 1;
  if ( v13 != -1LL )
    goto LABEL_21;
LABEL_22:
  if ( v11 )
  {
    result = (unsigned __int64 *)sub_65ECAF4();
    if ( v9 )
      goto LABEL_24;
  }
  else if ( v9 )
  {
LABEL_24:
    *v3 = (v7 + 1) | 1;
    v3[1] = v4;
    v3[2] = (unsigned __int64)v10;
    return result;
  }
  *(_BYTE *)v3 = 2 * v4;
  return result;
}


================================================================================
Function: sub_67371C8 (0x67371C8)
================================================================================

__int64 __fastcall sub_67371C8(int a1, __int16 a2, __int16 a3, __int64 a4, int a5)
{
  __int64 result; // x0
  int v11; // w8
  int v12; // w11
  __int64 v13; // x19
  int v14; // w9
  int v15; // w8
  int v16; // w8
  int v17; // w10
  __int64 v18; // x8
  __int64 v19; // x10
  __int64 v20; // x8

  result = sub_67372B8();
  if ( result )
  {
    v11 = *(_DWORD *)(result + 576);
    v12 = *(_DWORD *)(result + 580);
    v13 = result;
    v14 = v11 + 1;
    if ( v11 + 1 >= 0 )
      v15 = v11 + 1;
    else
      v15 = v11 + 16;
    v16 = v14 - (v15 & 0xFFFFFFF0);
    *(_DWORD *)(result + 576) = v16;
    if ( v16 == v12 )
    {
      v17 = v16 + 16;
      if ( v16 + 1 >= 0 )
        v17 = v16 + 1;
      *(_DWORD *)(result + 580) = v16 + 1 - (v17 & 0xFFFFFFF0);
    }
    *(_DWORD *)(result + 4LL * v16) = 0;
    v18 = *(int *)(result + 576);
    v19 = result + 8 * v18;
    *(_QWORD *)(v19 + 64) = (a1 << 24) | ((a2 & 0xFFF) << 12) | a3 & 0xFFFu;
    *(_QWORD *)(v19 + 384) = a4;
    *(_DWORD *)(result + 4 * v18 + 512) = a5;
    v20 = *(int *)(result + 576);
    if ( (*(_DWORD *)(result + 4 * v20 + 320) & 1) != 0 )
    {
      result = sub_6768BC0(*(_QWORD *)(result + 192 + 8 * v20), "crypto/err/err.c", 457LL);
      v20 = *(int *)(v13 + 576);
      *(_QWORD *)(v13 + 192 + 8 * v20) = 0LL;
    }
    *(_DWORD *)(v13 + 4 * v20 + 320) = 0;
  }
  return result;
}


================================================================================
Function: sub_67372B8 (0x67372B8)
================================================================================

__int64 __fastcall sub_67372B8(__int64 a1)
{
  _DWORD *v1; // x0
  int v2; // w22
  _DWORD *v3; // x19
  __int64 v4; // x20
  __int64 v5; // x0

  v1 = (_DWORD *)__errno(a1);
  v2 = *v1;
  v3 = v1;
  if ( !(unsigned int)sub_675AAF4(0x40000LL, 0LL) )
    return 0LL;
  v4 = 0LL;
  if ( (unsigned int)sub_67ACE84(&unk_730371C, sub_6737FD8) && dword_7303720 )
  {
    v5 = sub_67ACEBC(&unk_7303710);
    if ( v5 != -1 )
    {
      v4 = v5;
      if ( v5 )
      {
LABEL_6:
        *v3 = v2;
        return v4;
      }
      if ( (unsigned int)sub_67ACEC4(&unk_7303710, -1LL) )
      {
        v4 = sub_6768A44(584LL, "crypto/err/err.c", 766LL);
        if ( !v4 )
        {
          sub_67ACEC4(&unk_7303710, 0LL);
          return v4;
        }
        if ( (unsigned int)sub_675A97C(2LL) && (unsigned int)sub_67ACEC4(&unk_7303710, v4) )
        {
          sub_675AAF4(2LL, 0LL);
          goto LABEL_6;
        }
        sub_6737CA4(v4);
        sub_67ACEC4(&unk_7303710, 0LL);
      }
    }
    return 0LL;
  }
  return v4;
}


================================================================================
Function: sub_6737CA4 (0x6737CA4)
================================================================================

unsigned __int64 __fastcall sub_6737CA4(unsigned __int64 result)
{
  unsigned __int64 v1; // x19
  char v2; // w8
  char v3; // w8
  char v4; // w8
  char v5; // w8
  char v6; // w8
  char v7; // w8
  char v8; // w8
  char v9; // w8
  char v10; // w8
  char v11; // w8
  char v12; // w8
  char v13; // w8
  char v14; // w8
  char v15; // w8
  char v16; // w8
  char v17; // w8
  char v18; // w8
  char v19; // w8
  char v20; // w8
  char v21; // w8
  char v22; // w8
  char v23; // w8
  char v24; // w8
  char v25; // w8
  char v26; // w8
  char v27; // w8
  char v28; // w8
  char v29; // w8
  char v30; // w8
  char v31; // w8

  if ( result )
  {
    v1 = result;
    if ( (*(_BYTE *)(result + 320) & 1) != 0 )
    {
      sub_6768BC0(*(_QWORD *)(result + 192), (__int64)"crypto/err/err.c", 296LL);
      *(_QWORD *)(v1 + 192) = 0LL;
      v17 = *(_BYTE *)(v1 + 324);
      *(_DWORD *)(v1 + 320) = 0;
      if ( (v17 & 1) == 0 )
      {
LABEL_4:
        v3 = *(_BYTE *)(v1 + 328);
        *(_DWORD *)(v1 + 324) = 0;
        if ( (v3 & 1) == 0 )
          goto LABEL_5;
        goto LABEL_23;
      }
    }
    else
    {
      v2 = *(_BYTE *)(result + 324);
      *(_DWORD *)(result + 320) = 0;
      if ( (v2 & 1) == 0 )
        goto LABEL_4;
    }
    sub_6768BC0(*(_QWORD *)(v1 + 200), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 200) = 0LL;
    v18 = *(_BYTE *)(v1 + 328);
    *(_DWORD *)(v1 + 324) = 0;
    if ( (v18 & 1) == 0 )
    {
LABEL_5:
      v4 = *(_BYTE *)(v1 + 332);
      *(_DWORD *)(v1 + 328) = 0;
      if ( (v4 & 1) == 0 )
        goto LABEL_6;
      goto LABEL_24;
    }
LABEL_23:
    sub_6768BC0(*(_QWORD *)(v1 + 208), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 208) = 0LL;
    v19 = *(_BYTE *)(v1 + 332);
    *(_DWORD *)(v1 + 328) = 0;
    if ( (v19 & 1) == 0 )
    {
LABEL_6:
      v5 = *(_BYTE *)(v1 + 336);
      *(_DWORD *)(v1 + 332) = 0;
      if ( (v5 & 1) == 0 )
        goto LABEL_7;
      goto LABEL_25;
    }
LABEL_24:
    sub_6768BC0(*(_QWORD *)(v1 + 216), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 216) = 0LL;
    v20 = *(_BYTE *)(v1 + 336);
    *(_DWORD *)(v1 + 332) = 0;
    if ( (v20 & 1) == 0 )
    {
LABEL_7:
      v6 = *(_BYTE *)(v1 + 340);
      *(_DWORD *)(v1 + 336) = 0;
      if ( (v6 & 1) == 0 )
        goto LABEL_8;
      goto LABEL_26;
    }
LABEL_25:
    sub_6768BC0(*(_QWORD *)(v1 + 224), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 224) = 0LL;
    v21 = *(_BYTE *)(v1 + 340);
    *(_DWORD *)(v1 + 336) = 0;
    if ( (v21 & 1) == 0 )
    {
LABEL_8:
      v7 = *(_BYTE *)(v1 + 344);
      *(_DWORD *)(v1 + 340) = 0;
      if ( (v7 & 1) == 0 )
        goto LABEL_9;
      goto LABEL_27;
    }
LABEL_26:
    sub_6768BC0(*(_QWORD *)(v1 + 232), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 232) = 0LL;
    v22 = *(_BYTE *)(v1 + 344);
    *(_DWORD *)(v1 + 340) = 0;
    if ( (v22 & 1) == 0 )
    {
LABEL_9:
      v8 = *(_BYTE *)(v1 + 348);
      *(_DWORD *)(v1 + 344) = 0;
      if ( (v8 & 1) == 0 )
        goto LABEL_10;
      goto LABEL_28;
    }
LABEL_27:
    sub_6768BC0(*(_QWORD *)(v1 + 240), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 240) = 0LL;
    v23 = *(_BYTE *)(v1 + 348);
    *(_DWORD *)(v1 + 344) = 0;
    if ( (v23 & 1) == 0 )
    {
LABEL_10:
      v9 = *(_BYTE *)(v1 + 352);
      *(_DWORD *)(v1 + 348) = 0;
      if ( (v9 & 1) == 0 )
        goto LABEL_11;
      goto LABEL_29;
    }
LABEL_28:
    sub_6768BC0(*(_QWORD *)(v1 + 248), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 248) = 0LL;
    v24 = *(_BYTE *)(v1 + 352);
    *(_DWORD *)(v1 + 348) = 0;
    if ( (v24 & 1) == 0 )
    {
LABEL_11:
      v10 = *(_BYTE *)(v1 + 356);
      *(_DWORD *)(v1 + 352) = 0;
      if ( (v10 & 1) == 0 )
        goto LABEL_12;
      goto LABEL_30;
    }
LABEL_29:
    sub_6768BC0(*(_QWORD *)(v1 + 256), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 256) = 0LL;
    v25 = *(_BYTE *)(v1 + 356);
    *(_DWORD *)(v1 + 352) = 0;
    if ( (v25 & 1) == 0 )
    {
LABEL_12:
      v11 = *(_BYTE *)(v1 + 360);
      *(_DWORD *)(v1 + 356) = 0;
      if ( (v11 & 1) == 0 )
        goto LABEL_13;
      goto LABEL_31;
    }
LABEL_30:
    sub_6768BC0(*(_QWORD *)(v1 + 264), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 264) = 0LL;
    v26 = *(_BYTE *)(v1 + 360);
    *(_DWORD *)(v1 + 356) = 0;
    if ( (v26 & 1) == 0 )
    {
LABEL_13:
      v12 = *(_BYTE *)(v1 + 364);
      *(_DWORD *)(v1 + 360) = 0;
      if ( (v12 & 1) == 0 )
        goto LABEL_14;
      goto LABEL_32;
    }
LABEL_31:
    sub_6768BC0(*(_QWORD *)(v1 + 272), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 272) = 0LL;
    v27 = *(_BYTE *)(v1 + 364);
    *(_DWORD *)(v1 + 360) = 0;
    if ( (v27 & 1) == 0 )
    {
LABEL_14:
      v13 = *(_BYTE *)(v1 + 368);
      *(_DWORD *)(v1 + 364) = 0;
      if ( (v13 & 1) == 0 )
        goto LABEL_15;
      goto LABEL_33;
    }
LABEL_32:
    sub_6768BC0(*(_QWORD *)(v1 + 280), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 280) = 0LL;
    v28 = *(_BYTE *)(v1 + 368);
    *(_DWORD *)(v1 + 364) = 0;
    if ( (v28 & 1) == 0 )
    {
LABEL_15:
      v14 = *(_BYTE *)(v1 + 372);
      *(_DWORD *)(v1 + 368) = 0;
      if ( (v14 & 1) == 0 )
        goto LABEL_16;
      goto LABEL_34;
    }
LABEL_33:
    sub_6768BC0(*(_QWORD *)(v1 + 288), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 288) = 0LL;
    v29 = *(_BYTE *)(v1 + 372);
    *(_DWORD *)(v1 + 368) = 0;
    if ( (v29 & 1) == 0 )
    {
LABEL_16:
      v15 = *(_BYTE *)(v1 + 376);
      *(_DWORD *)(v1 + 372) = 0;
      if ( (v15 & 1) == 0 )
        goto LABEL_17;
      goto LABEL_35;
    }
LABEL_34:
    sub_6768BC0(*(_QWORD *)(v1 + 296), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 296) = 0LL;
    v30 = *(_BYTE *)(v1 + 376);
    *(_DWORD *)(v1 + 372) = 0;
    if ( (v30 & 1) == 0 )
    {
LABEL_17:
      v16 = *(_BYTE *)(v1 + 380);
      *(_DWORD *)(v1 + 376) = 0;
      if ( (v16 & 1) == 0 )
      {
LABEL_19:
        *(_DWORD *)(v1 + 380) = 0;
        return sub_6768BC0(v1, (__int64)"crypto/err/err.c", 298LL);
      }
LABEL_18:
      sub_6768BC0(*(_QWORD *)(v1 + 312), (__int64)"crypto/err/err.c", 296LL);
      *(_QWORD *)(v1 + 312) = 0LL;
      goto LABEL_19;
    }
LABEL_35:
    sub_6768BC0(*(_QWORD *)(v1 + 304), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 304) = 0LL;
    v31 = *(_BYTE *)(v1 + 380);
    *(_DWORD *)(v1 + 376) = 0;
    if ( (v31 & 1) == 0 )
      goto LABEL_19;
    goto LABEL_18;
  }
  return result;
}


================================================================================
Function: sub_675A97C (0x675A97C)
================================================================================

_DWORD *__fastcall sub_675A97C(char a1)
{
  _DWORD *result; // x0
  _BOOL4 v3; // w8
  _BOOL4 v4; // w8
  _BOOL4 v5; // w8
  _DWORD *v6; // x20

  if ( byte_730413C == 1 )
  {
    sub_67371C8(15, 116, 70, (__int64)"crypto/init.c", 615);
    return 0LL;
  }
  v3 = sub_67ACE84(&dword_7304158, (void (*)(void))sub_675AF48);
  result = 0LL;
  if ( v3 )
  {
    if ( dword_730415C )
    {
      v4 = sub_67ACE84(&dword_7304160, (void (*)(void))sub_675AFD0);
      result = 0LL;
      if ( v4 )
      {
        if ( dword_7304164 )
        {
          v5 = sub_67ACE84(&dword_7304168, (void (*)(void))sub_675AFFC);
          result = 0LL;
          if ( v5 )
          {
            if ( byte_7304148 )
            {
              v6 = (_DWORD *)sub_67ACEBC(&qword_6CAD750);
              if ( !v6 )
              {
                result = sub_6768A44(0xCuLL, (__int64)"crypto/init.c", 66LL);
                if ( !result )
                  return result;
                v6 = result;
                if ( !sub_67ACEC4((pthread_key_t *)&qword_6CAD750, result) )
                {
                  sub_6768BC0((unsigned __int64)v6, (__int64)"crypto/init.c", 68LL);
                  return 0LL;
                }
              }
              if ( (a1 & 1) != 0 )
              {
                *v6 = 1;
                if ( (a1 & 2) == 0 )
                {
LABEL_12:
                  result = &dword_0 + 1;
                  if ( (a1 & 4) == 0 )
                    return result;
LABEL_16:
                  v6[2] = 1;
                  return result;
                }
              }
              else if ( (a1 & 2) == 0 )
              {
                goto LABEL_12;
              }
              v6[1] = 1;
              result = &dword_0 + 1;
              if ( (a1 & 4) == 0 )
                return result;
              goto LABEL_16;
            }
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_675AAF4 (0x675AAF4)
================================================================================

__int64 __fastcall sub_675AAF4(int a1, __int64 a2)
{
  __int64 result; // x0
  _BOOL4 v5; // w8
  void (*v6)(void); // x1
  _BOOL4 v7; // w8
  _BOOL4 v8; // w8
  _BOOL4 v9; // w8
  _BOOL4 v10; // w8
  _BOOL4 v11; // w8
  _BOOL4 v12; // w8
  _BOOL4 v13; // w8
  _BOOL4 v14; // w8
  _BOOL4 v15; // w8
  _BOOL4 v16; // w20
  int v17; // w22
  _BOOL4 v18; // w8
  _BOOL4 v19; // w8

  if ( byte_730413C == 1 )
  {
    if ( (a1 & 0x40000) == 0 )
      sub_67371C8(15, 116, 70, (__int64)"crypto/init.c", 615);
    return 0LL;
  }
  else
  {
    v5 = sub_67ACE84(&dword_7304158, (void (*)(void))sub_675AF48);
    result = 0LL;
    if ( v5 && dword_730415C )
    {
      if ( (a1 & 0x40000) != 0 )
        return 1LL;
      v6 = (void (*)(void))((a1 & 0x80000) != 0 ? sub_675AFC0 : sub_675AFD0);
      v7 = sub_67ACE84(&dword_7304160, v6);
      result = 0LL;
      if ( v7 )
      {
        if ( dword_7304164 )
        {
          v8 = sub_67ACE84(&dword_7304168, (void (*)(void))sub_675AFFC);
          result = 0LL;
          if ( v8 )
          {
            if ( byte_7304148 )
            {
              if ( (a1 & 1) == 0
                || (v9 = sub_67ACE84(&dword_730416C, (void (*)(void))sub_675B00C), result = 0LL, v9) && dword_7304170 )
              {
                if ( (a1 & 2) == 0
                  || (v10 = sub_67ACE84(&dword_730416C, (void (*)(void))sub_675B01C), result = 0LL, v10)
                  && dword_7304170 )
                {
                  if ( (a1 & 0x10) == 0
                    || (v11 = sub_67ACE84(dword_7304174, (void (*)(void))sub_675B038), result = 0LL, v11)
                    && byte_730414C )
                  {
                    if ( (a1 & 4) == 0
                      || (v12 = sub_67ACE84(dword_7304174, (void (*)(void))sub_675B048), result = 0LL, v12)
                      && byte_730414C )
                    {
                      if ( (a1 & 0x20) == 0
                        || (v13 = sub_67ACE84(&dword_7304174[1], (void (*)(void))sub_675B068), result = 0LL, v13)
                        && byte_7304150 )
                      {
                        if ( (a1 & 8) == 0
                          || (v14 = sub_67ACE84(&dword_7304174[1], (void (*)(void))sub_675B078), result = 0LL, v14)
                          && byte_7304150 )
                        {
                          if ( (a1 & 0x20000) == 0 || (result = sub_67ACF28(0LL), (_DWORD)result) )
                          {
                            if ( (a1 & 0x80) == 0
                              || (v15 = sub_67ACE84(&dword_730417C, (void (*)(void))sub_675B098), result = 0LL, v15)
                              && dword_7304180 )
                            {
                              if ( (a1 & 0x40) == 0
                                || (sub_67ACE14(qword_7304198),
                                    qword_73041A0 = a2,
                                    v16 = sub_67ACE84(&dword_730417C, (void (*)(void))sub_675B0B8),
                                    v17 = dword_7304180,
                                    qword_73041A0 = 0LL,
                                    sub_67ACE30(qword_7304198),
                                    result = 0LL,
                                    v16)
                                && v17 >= 1 )
                              {
                                if ( (a1 & 0x100) == 0
                                  || (v18 = sub_67ACE84(&dword_7304184, (void (*)(void))sub_675B0E4), result = 0LL, v18)
                                  && dword_7304188 )
                                {
                                  if ( (a1 & 0x10000) == 0 )
                                    return 1LL;
                                  v19 = sub_67ACE84((pthread_once_t *)algn_730418C, (void (*)(void))sub_675B124);
                                  result = 0LL;
                                  if ( v19 )
                                  {
                                    if ( byte_7304154 )
                                      return 1LL;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_675B13C (0x675B13C)
================================================================================

__int64 __fastcall sub_675B13C(__int64 a1)
{
  _QWORD *v2; // x0

  v2 = (_QWORD *)sub_6768A04(16LL, "crypto/init.c", 807LL);
  if ( v2 )
  {
    *v2 = a1;
    v2[1] = qword_7304190;
    qword_7304190 = (__int64)v2;
    return 1LL;
  }
  else
  {
    sub_67371C8(15LL, 114LL, 65LL, "crypto/init.c", 808LL);
    return 0LL;
  }
}


================================================================================
Function: sub_6768674 (0x6768674)
================================================================================

__int64 __fastcall sub_6768674(_OWORD *a1)
{
  __int64 result; // x0

  *(_OWORD *)((char *)a1 + 76) = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[2] = 0u;
  *a1 = xmmword_B00B60;
  result = 1LL;
  a1[1] = 0u;
  return result;
}


================================================================================
Function: sub_676897C (0x676897C)
================================================================================

__int64 __fastcall sub_676897C(__int64 (__fastcall *a1)(), __int64 (__fastcall *a2)(), __int64 (__fastcall *a3)())
{
  if ( (byte_73041C0 & 1) != 0 )
    return 0LL;
  if ( a1 )
    off_6CAD760[0] = a1;
  if ( a2 )
    off_6CAD768[0] = a2;
  if ( a3 )
    off_6CAD770 = a3;
  return 1LL;
}


================================================================================
Function: sub_6768A04 (0x6768A04)
================================================================================

unsigned __int64 __fastcall sub_6768A04(unsigned __int64 result, __int64 a2, __int64 a3)
{
  if ( off_6CAD760 && off_6CAD760 != sub_6768A04 )
    return off_6CAD760(result, a2, a3);
  if ( result )
  {
    if ( (byte_73041C0 & 1) == 0 )
      byte_73041C0 = 1;
    return sub_67F3A24(result);
  }
  return result;
}


================================================================================
Function: sub_6768A44 (0x6768A44)
================================================================================

void *__fastcall sub_6768A44(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  void *v4; // x20

  if ( off_6CAD760 && (char *)off_6CAD760 != (char *)sub_6768A04 )
  {
    v4 = (void *)off_6CAD760(a1, a2, a3);
    if ( !v4 )
      return v4;
    goto LABEL_9;
  }
  if ( a1 )
  {
    if ( (byte_73041C0 & 1) == 0 )
      byte_73041C0 = 1;
    v4 = (void *)sub_67F3A24(a1);
    if ( !v4 )
      return v4;
LABEL_9:
    memset(v4, 0, a1);
    return v4;
  }
  return 0LL;
}


================================================================================
Function: sub_6768BC0 (0x6768BC0)
================================================================================

unsigned __int64 __fastcall sub_6768BC0(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  if ( !off_6CAD770 || off_6CAD770 == sub_6768BC0 )
    return sub_67F3C08(a1);
  else
    return off_6CAD770(a1, a2, a3);
}


================================================================================
Function: sub_67ACE14 (0x67ACE14)
================================================================================

bool __fastcall sub_67ACE14(pthread_rwlock_t *a1)
{
  return pthread_rwlock_wrlock(a1) == 0;
}


================================================================================
Function: sub_67ACE30 (0x67ACE30)
================================================================================

bool __fastcall sub_67ACE30(pthread_rwlock_t *a1)
{
  return pthread_rwlock_unlock(a1) == 0;
}


================================================================================
Function: sub_67ACE84 (0x67ACE84)
================================================================================

bool __fastcall sub_67ACE84(pthread_once_t *a1, void (*a2)(void))
{
  return pthread_once(a1, a2) == 0;
}


================================================================================
Function: sub_67ACEBC (0x67ACEBC)
================================================================================

void *__fastcall sub_67ACEBC(pthread_key_t *a1)
{
  return pthread_getspecific(*a1);
}


================================================================================
Function: sub_67ACEC4 (0x67ACEC4)
================================================================================

bool __fastcall sub_67ACEC4(pthread_key_t *a1, const void *a2)
{
  return pthread_setspecific(*a1, a2) == 0;
}


================================================================================
Function: sub_67ACF28 (0x67ACF28)
================================================================================

bool sub_67ACF28()
{
  return pthread_once(dword_7304490, (void (*)(void))sub_67ACF54) == 0;
}


================================================================================
Function: sub_67D718C (0x67D718C)
================================================================================

__int64 sub_67D718C()
{
  __int64 v1; // [xsp+8h] [xbp-18h] BYREF
  __int64 v2; // [xsp+10h] [xbp-10h]

  clock_gettime(0, (struct timespec *)&v1);
  return v2 + 1000000000 * v1;
}


================================================================================
Function: sub_67D71F4 (0x67D71F4)
================================================================================

__int64 sub_67D71F4()
{
  __int64 v1; // [xsp+8h] [xbp-18h] BYREF
  __int64 v2; // [xsp+10h] [xbp-10h]

  clock_gettime(1, (struct timespec *)&v1);
  return v2 + 1000000000 * v1;
}


================================================================================
Function: sub_67D7D74 (0x67D7D74)
================================================================================

unsigned __int8 *__fastcall sub_67D7D74(__int64 a1, char *a2, unsigned __int8 *a3, __int64 a4, __int64 a5)
{
  __int64 v9; // x0

  sub_68494D4((_QWORD *)a1, a2);
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)a1 = off_68EE7B0;
  v9 = sub_65ECAAC();
  *(_QWORD *)(v9 + 64) = 0LL;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  sub_2DB1428(a1 + 56);
  return sub_684A438(*(unsigned __int8 **)(a1 + 56), a3);
}


================================================================================
Function: sub_67D8348 (0x67D8348)
================================================================================

__int64 __fastcall sub_67D8348(__int64 a1, __int64 a2)
{
  char v4; // w20
  unsigned __int64 v5; // x8
  __int64 v7; // x20
  _BYTE v8[24]; // [xsp+8h] [xbp-48h] BYREF
  _QWORD v9[2]; // [xsp+20h] [xbp-30h] BYREF
  __int128 v10; // [xsp+38h] [xbp-18h] BYREF

  LODWORD(v10) = 0;
  *((_QWORD *)&v10 + 1) = sub_67DDA30();
  if ( (unsigned int)sub_67D97C4(a1, (__int64)&v10) == 3 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = 0;
      v4 = 0;
      *(_QWORD *)(a2 + 8) = sub_67DDA30();
    }
    else
    {
      v4 = 0;
    }
    return v4 & 1;
  }
  sub_67DBF98(v9, a1);
  if ( (v9[0] & 1) != 0 )
    v5 = v9[1];
  else
    v5 = (unsigned __int64)LOBYTE(v9[0]) >> 1;
  if ( !v5 || (unsigned int)sub_67D97C4((__int64)v9, (__int64)&v10) != 1 || (sub_67D8348(v9, &v10), !(_DWORD)v10) )
  {
    v4 = sub_67D8518(a1, a2);
    if ( (v9[0] & 1) == 0 )
      return v4 & 1;
LABEL_14:
    sub_65ECAF4();
    return v4 & 1;
  }
  if ( !a2 )
  {
    v7 = sub_6861FD0(72LL);
    sub_256C7D8((int)v8, "boost::filesystem::create_directories");
    sub_67D7D74(v7, v8, v9, v10, *((_QWORD *)&v10 + 1));
    sub_6862048(v7, (__int64)&`typeinfo for'boost::filesystem::filesystem_error, (__int64)sub_2DB11E8);
  }
  v4 = 0;
  *(_OWORD *)a2 = v10;
  if ( (v9[0] & 1) != 0 )
    goto LABEL_14;
  return v4 & 1;
}


================================================================================
Function: sub_67D8518 (0x67D8518)
================================================================================

bool __fastcall sub_67D8518(__int64 a1, __int64 a2)
{
  const char *v4; // x0
  __int64 v5; // x0
  int v6; // w20
  __int64 v7; // x22
  __int64 *v8; // x0
  __int64 v10; // x19
  __int64 *v11; // x0
  unsigned __int64 v12[3]; // [xsp+0h] [xbp-30h] BYREF
  int v13; // [xsp+18h] [xbp-18h] BYREF
  __int64 *v14; // [xsp+20h] [xbp-10h]

  if ( (*(_BYTE *)a1 & 1) != 0 )
    v4 = *(const char **)(a1 + 16);
  else
    v4 = (const char *)(a1 + 1);
  v5 = mkdir(v4, 0x1FFu);
  v6 = v5;
  if ( (_DWORD)v5 )
  {
    v7 = *(unsigned int *)__errno(v5);
    v13 = 0;
    v14 = sub_67DDA30();
    if ( (_DWORD)v7 != 17 || (unsigned int)sub_67D97C4(a1, (__int64)&v13) != 3 )
    {
      if ( !a2 )
      {
        v10 = sub_6861FD0(72LL);
        sub_256C7D8(v12, "boost::filesystem::create_directory");
        v11 = sub_67DDA30();
        sub_67D7D74(v10, (char *)v12, (unsigned __int8 *)a1, v7, (__int64)v11);
        sub_6862048(v10, (__int64)&`typeinfo for'boost::filesystem::filesystem_error, (__int64)sub_2DB11E8);
      }
      v8 = sub_67DDA30();
      *(_DWORD *)a2 = v7;
      goto LABEL_11;
    }
  }
  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    v8 = sub_67DDA30();
LABEL_11:
    *(_QWORD *)(a2 + 8) = v8;
  }
  return v6 == 0;
}


================================================================================
Function: sub_67D97C4 (0x67D97C4)
================================================================================

unsigned __int64 __fastcall sub_67D97C4(__int64 a1, __int64 a2)
{
  const char *v4; // x0
  __int64 v5; // x0
  _DWORD *v6; // x0
  _DWORD *v7; // x21
  int v8; // w23
  __int64 *v9; // x0
  unsigned __int16 v10; // w9
  __int64 v11; // x0
  int v12; // w0
  bool v13; // zf
  int v14; // w8
  __int64 v15; // x20
  __int64 v16; // x21
  __int64 *v17; // x0
  _BYTE v19[24]; // [xsp+0h] [xbp-A0h] BYREF
  _BYTE v20[16]; // [xsp+18h] [xbp-88h] BYREF
  int v21; // [xsp+28h] [xbp-78h]

  if ( (*(_BYTE *)a1 & 1) != 0 )
    v4 = *(const char **)(a1 + 16);
  else
    v4 = (const char *)(a1 + 1);
  v5 = stat(v4, (struct stat *)v20);
  if ( (_DWORD)v5 )
  {
    v6 = (_DWORD *)__errno(v5);
    v7 = v6;
    if ( a2 )
    {
      v8 = *v6;
      v9 = sub_67DDA30();
      *(_DWORD *)a2 = v8;
      *(_QWORD *)(a2 + 8) = v9;
    }
    v10 = 0;
    v11 = 1LL;
    if ( *v7 != 2 && *v7 != 20 )
    {
      v12 = sub_2DB0BA0(a1, &byte_CC4FFC);
      v13 = v12 == 0;
      v14 = v12;
      v11 = v12 == 0;
      if ( v13 )
        v10 = 0;
      else
        v10 = -1;
      if ( v14 && !a2 )
      {
        v15 = sub_6861FD0(72LL);
        sub_256C7D8((int)v19, "boost::filesystem::status");
        v16 = (unsigned int)*v7;
        v17 = sub_67DDA30();
        sub_67D7D74(v15, v19, a1, v16, v17);
        sub_6862048(v15, (__int64)&`typeinfo for'boost::filesystem::filesystem_error, (__int64)sub_2DB11E8);
      }
    }
  }
  else
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = sub_67DDA30();
    }
    v11 = 10LL;
    v10 = -1;
    switch ( ((v21 & 0xF000u) - 4096) >> 12 )
    {
      case 0u:
        v10 = v21 & 0xFFF;
        v11 = 7LL;
        break;
      case 1u:
        v10 = v21 & 0xFFF;
        v11 = 6LL;
        break;
      case 3u:
        v10 = v21 & 0xFFF;
        v11 = 3LL;
        break;
      case 5u:
        v10 = v21 & 0xFFF;
        v11 = 5LL;
        break;
      case 7u:
        v10 = v21 & 0xFFF;
        v11 = 2LL;
        break;
      case 0xBu:
        v10 = v21 & 0xFFF;
        v11 = 8LL;
        break;
      default:
        return v11 & 0xFFFF0000FFFFFFFFLL | ((unsigned __int64)v10 << 32);
    }
  }
  return v11 & 0xFFFF0000FFFFFFFFLL | ((unsigned __int64)v10 << 32);
}


================================================================================
Function: sub_67DA998 (0x67DA998)
================================================================================

unsigned __int64 *__fastcall sub_67DA998(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v3; // x10
  size_t v4; // x8
  int v5; // w9
  size_t v6; // x10
  size_t v7; // x11
  void *v9; // x11
  _BYTE *v10; // x12
  unsigned __int64 v11; // x12
  unsigned __int64 v12; // x13
  unsigned __int64 *v13; // x12
  unsigned __int64 v14; // x10
  void *v15; // x1
  size_t v16; // x2
  unsigned int v17; // w8
  char *v18; // x9
  int v19; // w10
  char *v20; // x11
  unsigned __int64 v21; // x11
  unsigned __int64 v22; // x12
  unsigned __int8 *v23; // x11
  char *v24; // x1
  size_t v25; // x8
  size_t v26; // x2
  unsigned __int64 v28[2]; // [xsp+0h] [xbp-20h] BYREF
  char *v29; // [xsp+10h] [xbp-10h]

  v3 = *(unsigned __int8 *)a2;
  v4 = a2[1];
  v5 = v3 & 1;
  v6 = v3 >> 1;
  if ( v5 )
    v7 = a2[1];
  else
    v7 = v6;
  if ( v7 )
  {
    if ( a1 == a2 )
    {
      sub_68497A0(v28, (__int128 *)a2);
      v17 = LOBYTE(v28[0]);
      v18 = v29;
      v19 = v28[0] & 1;
      if ( v19 )
        v20 = v29;
      else
        v20 = (char *)v28 + 1;
      if ( *v20 != 47 )
      {
        v21 = *(unsigned __int8 *)a2;
        v22 = a2[1];
        if ( (v21 & 1) == 0 )
          v22 = v21 >> 1;
        if ( v22 )
        {
          v23 = (v21 & 1) != 0 ? (unsigned __int8 *)a2[2] : (unsigned __int8 *)a2 + 1;
          if ( v23[v22 - 1] != 47 )
          {
            sub_6601588(a2, 47);
            v17 = LOBYTE(v28[0]);
            v18 = v29;
            v19 = v28[0] & 1;
          }
        }
      }
      if ( v19 )
        v24 = v18;
      else
        v24 = (char *)v28 + 1;
      v25 = v17 >> 1;
      if ( v19 )
        v26 = v28[1];
      else
        v26 = v25;
      sub_65FFB9C(a2, v24, v26);
      if ( (v28[0] & 1) != 0 )
        sub_65ECAF4();
    }
    else
    {
      v9 = (void *)a2[2];
      if ( v5 )
        v10 = (_BYTE *)a2[2];
      else
        v10 = (char *)a2 + 1;
      if ( *v10 != 47 )
      {
        v11 = *(unsigned __int8 *)a1;
        v12 = a1[1];
        if ( (v11 & 1) == 0 )
          v12 = v11 >> 1;
        if ( v12 )
        {
          v13 = (v11 & 1) != 0 ? (unsigned __int64 *)a1[2] : (unsigned __int64 *)((char *)a1 + 1);
          if ( *((_BYTE *)v13 + v12 - 1) != 47 )
          {
            sub_6601588(a1, 47);
            v14 = *(unsigned __int8 *)a2;
            v4 = a2[1];
            v9 = (void *)a2[2];
            v5 = v14 & 1;
            v6 = v14 >> 1;
          }
        }
      }
      if ( v5 )
        v15 = v9;
      else
        v15 = (char *)a2 + 1;
      if ( v5 )
        v16 = v4;
      else
        v16 = v6;
      sub_65FFB9C(a1, v15, v16);
    }
  }
  return a1;
}


================================================================================
Function: sub_67DABB8 (0x67DABB8)
================================================================================

unsigned __int64 *__fastcall sub_67DABB8(unsigned __int64 *a1, char *s)
{
  unsigned int v3; // w9
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x11
  size_t v7; // x0
  size_t v8; // x21
  char *v9; // x22
  unsigned __int64 v10; // x9
  unsigned __int64 v12; // x23
  unsigned int v13; // w8
  char *v14; // x9
  int v15; // w10
  char *v16; // x11
  unsigned __int64 v17; // x11
  unsigned __int64 v18; // x12
  unsigned __int64 *v19; // x11
  char *v20; // x1
  size_t v21; // x8
  size_t v22; // x2
  __int64 v23; // [xsp+0h] [xbp-20h] BYREF
  size_t v24; // [xsp+8h] [xbp-18h]
  char *v25; // [xsp+10h] [xbp-10h]

  if ( !*s )
    return a1;
  v3 = *(unsigned __int8 *)a1;
  v5 = a1[2];
  if ( (v3 & 1) == 0 )
    v5 = (unsigned __int64)a1 + 1;
  if ( v5 <= (unsigned __int64)s )
  {
    v6 = a1[1];
    if ( (v3 & 1) == 0 )
      v6 = v3 >> 1;
    if ( v5 + v6 > (unsigned __int64)s )
    {
      v7 = strlen(s);
      if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
        sub_6849630();
      v8 = v7;
      if ( v7 >= 0x17 )
      {
        v12 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v9 = (char *)sub_65ECAAC();
        v24 = v8;
        v25 = v9;
        v23 = v12 | 1;
      }
      else
      {
        v9 = (char *)&v23 + 1;
        LOBYTE(v23) = 2 * v7;
        if ( !v7 )
          goto LABEL_23;
      }
      memcpy(v9, s, v8);
LABEL_23:
      v9[v8] = 0;
      v13 = (unsigned __int8)v23;
      v14 = v25;
      v15 = v23 & 1;
      if ( v15 )
        v16 = v25;
      else
        v16 = (char *)&v23 + 1;
      if ( *v16 != 47 )
      {
        v17 = *(unsigned __int8 *)a1;
        v18 = a1[1];
        if ( (v17 & 1) == 0 )
          v18 = v17 >> 1;
        if ( v18 )
        {
          v19 = (v17 & 1) != 0 ? (unsigned __int64 *)a1[2] : (unsigned __int64 *)((char *)a1 + 1);
          if ( *((_BYTE *)v19 + v18 - 1) != 47 )
          {
            sub_6601588(a1, 47);
            v13 = (unsigned __int8)v23;
            v14 = v25;
            v15 = v23 & 1;
          }
        }
      }
      if ( v15 )
        v20 = v14;
      else
        v20 = (char *)&v23 + 1;
      v21 = v13 >> 1;
      if ( v15 )
        v22 = v24;
      else
        v22 = v21;
      sub_65FFB9C(a1, v20, v22);
      if ( (v23 & 1) != 0 )
        sub_65ECAF4();
      return a1;
    }
  }
  if ( *s != 47 )
  {
    v10 = (v3 & 1) != 0 ? a1[1] : v3 >> 1;
    if ( v10 && *(_BYTE *)(v5 + v10 - 1) != 47 )
      sub_6601588(a1, 47);
  }
  sub_684A544(a1, s);
  return a1;
}


================================================================================
Function: sub_67DADC8 (0x67DADC8)
================================================================================

__int64 __fastcall sub_67DADC8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x8
  unsigned int v10; // w19
  _QWORD v12[5]; // [xsp+8h] [xbp-A8h] BYREF
  _QWORD v13[2]; // [xsp+30h] [xbp-80h] BYREF
  _QWORD v14[5]; // [xsp+58h] [xbp-58h] BYREF
  _QWORD v15[2]; // [xsp+80h] [xbp-30h] BYREF

  sub_67DB0AC(v15);
  v4 = *a1;
  memset(v14, 0, 24);
  v5 = *((_QWORD *)a1 + 1);
  v14[3] = a1;
  if ( (v4 & 1) != 0 )
    v6 = v5;
  else
    v6 = v4 >> 1;
  v14[4] = v6;
  sub_67DB0AC(v13);
  v7 = *a2;
  memset(v12, 0, 24);
  v8 = *((_QWORD *)a2 + 1);
  v12[3] = a2;
  if ( (v7 & 1) != 0 )
    v9 = v8;
  else
    v9 = v7 >> 1;
  v12[4] = v9;
  v10 = sub_67DAEDC(v15, v14, v13, v12);
  if ( (v13[0] & 1) != 0 )
    sub_65ECAF4();
  if ( (v15[0] & 1) != 0 )
    sub_65ECAF4();
  return v10;
}


================================================================================
Function: sub_67DAEDC (0x67DAEDC)
================================================================================

__int64 __fastcall sub_67DAEDC(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // x10
  __int64 v5; // x11
  __int64 v8; // x8
  __int64 v9; // x9
  __int64 result; // x0
  __int64 v13; // x12
  __int64 v14; // x13
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x9
  size_t v17; // x28
  size_t v18; // x26
  size_t v19; // x23
  const void *v20; // x24
  const void *v21; // x25
  int v22; // w0
  int v23; // w0
  char *v24; // [xsp+8h] [xbp-8h]

  v4 = *(_QWORD *)(a2 + 24);
  v5 = *(_QWORD *)(a2 + 32);
  v9 = a1[3];
  v8 = a1[4];
  if ( v9 == v4 && v8 == v5 )
  {
LABEL_3:
    v4 = v9;
    v5 = v8;
  }
  else
  {
    v13 = a3[3];
    v14 = *(_QWORD *)(a4 + 24);
    v24 = (char *)a3 + 1;
    while ( v13 != v14 || a3[4] != *(_QWORD *)(a4 + 32) )
    {
      v15 = *(unsigned __int8 *)a3;
      v16 = *(unsigned __int8 *)a1;
      if ( (v15 & 1) != 0 )
        v17 = a3[1];
      else
        v17 = v15 >> 1;
      if ( (v16 & 1) != 0 )
        v18 = a1[1];
      else
        v18 = v16 >> 1;
      if ( v17 >= v18 )
        v19 = v18;
      else
        v19 = v17;
      if ( v19 )
      {
        if ( (v15 & 1) != 0 )
          v20 = (const void *)a3[2];
        else
          v20 = v24;
        if ( (v16 & 1) != 0 )
          v21 = (const void *)a1[2];
        else
          v21 = (char *)a1 + 1;
        v22 = memcmp(v21, v20, v19);
        if ( v22 )
        {
          if ( v22 < 0 )
            return 0xFFFFFFFFLL;
        }
        else if ( v18 < v17 )
        {
          return 0xFFFFFFFFLL;
        }
        v23 = memcmp(v20, v21, v19);
        if ( v23 )
        {
          if ( v23 < 0 )
            return 1LL;
        }
        else if ( v17 < v18 )
        {
          return 1LL;
        }
      }
      else if ( v17 != v18 )
      {
        if ( v17 > v18 )
          return 0xFFFFFFFFLL;
        else
          return 1LL;
      }
      sub_67DD208(a1);
      sub_67DD208(a3);
      v4 = *(_QWORD *)(a2 + 24);
      v5 = *(_QWORD *)(a2 + 32);
      v9 = a1[3];
      v8 = a1[4];
      if ( v9 == v4 && v8 == v5 )
        goto LABEL_3;
      v13 = a3[3];
      v14 = *(_QWORD *)(a4 + 24);
    }
  }
  result = 1LL;
  if ( v9 == v4 && v8 == v5 )
  {
    result = 0xFFFFFFFFLL;
    if ( a3[3] == *(_QWORD *)(a4 + 24) && a3[4] == *(_QWORD *)(a4 + 32) )
      return 0LL;
  }
  return result;
}


================================================================================
Function: sub_67DB0AC (0x67DB0AC)
================================================================================

_QWORD *__usercall sub_67DB0AC@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 *a2@<X8>)
{
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x8
  unsigned __int8 *v5; // x9
  int v6; // w10
  unsigned __int64 v7; // x2
  size_t v8; // x3
  __int64 v9; // x10
  int v10; // w11
  _QWORD *result; // x0
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x8
  size_t v14[2]; // [xsp+0h] [xbp-20h] BYREF

  v3 = *a1;
  *(_QWORD *)a2 = 0LL;
  *((_QWORD *)a2 + 1) = 0LL;
  v4 = *((_QWORD *)a1 + 1);
  *((_QWORD *)a2 + 2) = 0LL;
  *((_QWORD *)a2 + 3) = a1;
  *((_QWORD *)a2 + 4) = 0LL;
  if ( (v3 & 1) == 0 )
    v4 = v3 >> 1;
  if ( v4 )
  {
    if ( (v3 & 1) != 0 )
      v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    else
      v5 = a1 + 1;
    v6 = *v5;
    if ( v4 == 1 )
    {
      v7 = 0LL;
      if ( v6 != 47 )
      {
        v8 = 0LL;
        goto LABEL_23;
      }
      goto LABEL_9;
    }
    if ( v6 != 47 )
    {
      v8 = 0LL;
      goto LABEL_23;
    }
    if ( v5[1] == 47 )
    {
      if ( v4 != 2 && v5[2] == 47 )
      {
        v9 = 2LL;
        do
        {
          v7 = v9 - 1;
          *((_QWORD *)a2 + 4) = v9 - 1;
          if ( v4 == v9 )
            break;
          v10 = v5[v9++];
        }
        while ( v10 == 47 );
LABEL_9:
        v8 = 1LL;
        goto LABEL_27;
      }
      v8 = 2LL;
      if ( v4 > 2 )
      {
LABEL_23:
        while ( v5[v8] != 47 )
        {
          if ( v4 == ++v8 )
          {
            v7 = 0LL;
            v8 = v4;
            goto LABEL_27;
          }
        }
      }
      v7 = 0LL;
    }
    else
    {
      v7 = 0LL;
      v8 = 1LL;
    }
  }
  else
  {
    v7 = 0LL;
    v8 = 0LL;
  }
LABEL_27:
  sub_6849CE0(v14, a1, v7, v8);
  result = sub_684A438(a2, (unsigned __int8 *)v14);
  if ( (v14[0] & 1) != 0 )
    result = (_QWORD *)sub_65ECAF4();
  v12 = *a2;
  if ( (v12 & 1) != 0 )
    v13 = *((_QWORD *)a2 + 1);
  else
    v13 = v12 >> 1;
  if ( v13 == 1 )
  {
    result = (_QWORD *)sub_684A118(a2, 0LL, 0xFFFFFFFFFFFFFFFFLL, "/", 1uLL);
    if ( !(_DWORD)result )
      return sub_684A29C(a2, "/");
  }
  return result;
}


================================================================================
Function: sub_67DB394 (0x67DB394)
================================================================================

__int64 __fastcall sub_67DB394(unsigned __int8 *a1)
{
  unsigned __int64 v1; // x9
  unsigned __int64 v2; // x8
  _BYTE *v3; // x10
  _BYTE *v4; // x20
  unsigned __int64 v5; // x19
  bool v6; // zf
  unsigned __int64 v7; // x9
  _BYTE *v8; // x10
  _BOOL4 v9; // w21
  __int64 v10; // x0
  unsigned __int64 v11; // x9
  __int64 v12; // x8
  int v13; // w10

  v1 = *a1;
  v2 = *((_QWORD *)a1 + 1);
  if ( (v1 & 1) == 0 )
    v2 = v1 >> 1;
  if ( v2 == 2 )
  {
    v3 = (_BYTE *)*((_QWORD *)a1 + 2);
    if ( (v1 & 1) != 0 )
      v4 = (_BYTE *)*((_QWORD *)a1 + 2);
    else
      v4 = a1 + 1;
    if ( *v4 == 47 && v4[1] == 47 )
    {
      v5 = 0LL;
LABEL_26:
      v9 = v4[v5] != 47;
      goto LABEL_29;
    }
  }
  else
  {
    if ( !v2 )
    {
      v3 = (_BYTE *)*((_QWORD *)a1 + 2);
      goto LABEL_17;
    }
    v3 = (_BYTE *)*((_QWORD *)a1 + 2);
  }
  v5 = v2 - 1;
  if ( (v1 & 1) != 0 )
    v4 = v3;
  else
    v4 = a1 + 1;
  if ( v4[v5] == 47 )
    goto LABEL_26;
LABEL_17:
  v6 = (v1 & 1) == 0;
  v7 = v2;
  if ( v6 )
    v4 = a1 + 1;
  else
    v4 = v3;
  do
  {
    if ( !v7 )
      goto LABEL_25;
    v8 = &v4[v7--];
  }
  while ( *(v8 - 1) != 47 );
  if ( v7 == -1LL || v7 == 1 && *v4 == 47 )
  {
LABEL_25:
    v5 = 0LL;
    if ( v2 )
      goto LABEL_26;
    goto LABEL_28;
  }
  v5 = v7 + 1;
  if ( v2 )
    goto LABEL_26;
LABEL_28:
  v9 = 1;
LABEL_29:
  v10 = sub_67DBBCC();
  v11 = v5 - 1;
  v12 = v10 + 1;
  while ( v11 != -1LL )
  {
    if ( v10 == v11 )
      goto LABEL_35;
    v13 = (unsigned __int8)v4[v11--];
    if ( v13 != 47 )
    {
      v12 = v11 + 2;
      goto LABEL_35;
    }
  }
  v12 = 0LL;
LABEL_35:
  if ( v9 || v10 != 0 || v12 != 1 )
    return v12;
  else
    return -1LL;
}


================================================================================
Function: sub_67DBBCC (0x67DBBCC)
================================================================================

__int64 __fastcall sub_67DBBCC(unsigned __int8 *a1, unsigned __int64 a2)
{
  _BYTE *v2; // x10
  int v3; // w9
  _BYTE *v4; // x8
  unsigned int v5; // w12
  _BYTE *v6; // x8
  _BYTE *v7; // x11
  unsigned __int64 v8; // x12
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x10
  unsigned __int64 v11; // x8
  _BYTE *v12; // x8
  _BYTE *v14; // x9
  _BYTE *v15; // x12
  int v16; // w13

  if ( a2 == 2 )
  {
    v2 = (_BYTE *)*((_QWORD *)a1 + 2);
    v3 = *a1 & 1;
    if ( (*a1 & 1) != 0 )
      v4 = (_BYTE *)*((_QWORD *)a1 + 2);
    else
      v4 = a1 + 1;
    if ( *v4 == 47 && v4[1] == 47 )
      return -1LL;
    goto LABEL_22;
  }
  if ( a2 < 4 )
  {
    if ( !a2 )
      return -1LL;
    v2 = (_BYTE *)*((_QWORD *)a1 + 2);
    v3 = *a1 & 1;
LABEL_22:
    if ( v3 )
      v12 = v2;
    else
      v12 = a1 + 1;
    if ( *v12 == 47 )
      return 0LL;
    return -1LL;
  }
  v5 = *a1;
  v2 = (_BYTE *)*((_QWORD *)a1 + 2);
  v3 = v5 & 1;
  if ( (v5 & 1) != 0 )
    v6 = (_BYTE *)*((_QWORD *)a1 + 2);
  else
    v6 = a1 + 1;
  if ( *v6 != 47 )
    goto LABEL_22;
  if ( v6[1] != 47 )
    goto LABEL_22;
  v7 = v6 + 2;
  if ( v6[2] == 47 )
    goto LABEL_22;
  v8 = v5 >> 1;
  if ( v3 )
    v9 = *((_QWORD *)a1 + 1);
  else
    v9 = v8;
  v10 = v9 - 3;
  if ( v9 >= 3 )
  {
    v14 = &v6[v9];
    while ( v10 )
    {
      v15 = v7 + 1;
      v16 = (unsigned __int8)v7[1];
      --v10;
      ++v7;
      if ( v16 == 47 )
        goto LABEL_33;
    }
    v15 = v14;
LABEL_33:
    v11 = v15 - v6;
    if ( v15 == v14 )
      v11 = -1LL;
  }
  else
  {
    v11 = -1LL;
  }
  if ( v11 >= a2 )
    return -1LL;
  else
    return v11;
}


================================================================================
Function: sub_67DBCE4 (0x67DBCE4)
================================================================================

_QWORD *__fastcall sub_67DBCE4(_QWORD *result, _BYTE *src, _BYTE *a3)
{
  int v4; // w19
  size_t v5; // x21
  char *v6; // x22
  char *v7; // x1
  _QWORD v8[2]; // [xsp+0h] [xbp-20h] BYREF
  char *v9; // [xsp+10h] [xbp-10h]

  *result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  if ( src != a3 )
  {
    v4 = (int)result;
    v5 = a3 - src;
    if ( (unsigned __int64)(a3 - src) >= 0xFFFFFFFFFFFFFFF0LL )
      sub_6849630();
    if ( v5 > 0x16 )
    {
      v6 = (char *)sub_65ECAAC();
      v8[1] = v5;
      v9 = v6;
      v8[0] = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v6 = (char *)v8 + 1;
      LOBYTE(v8[0]) = 2 * v5;
    }
    memcpy(v6, src, v5);
    v6[v5] = 0;
    if ( (v8[0] & 1) != 0 )
      v7 = v9;
    else
      v7 = (char *)v8 + 1;
    result = (_QWORD *)sub_535EF40(v4, v7);
    if ( (v8[0] & 1) != 0 )
      return (_QWORD *)sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_67DBF98 (0x67DBF98)
================================================================================

__int64 __usercall sub_67DBF98@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  __int64 result; // x0
  void *v5; // x1

  result = sub_67DB394();
  if ( result == -1 )
  {
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
  }
  else
  {
    if ( (*(_BYTE *)a1 & 1) != 0 )
      v5 = *(void **)(a1 + 16);
    else
      v5 = (void *)(a1 + 1);
    return sub_67DBCE4((int)a2, v5);
  }
  return result;
}


================================================================================
Function: sub_67DD208 (0x67DD208)
================================================================================

unsigned __int8 *__fastcall sub_67DD208(unsigned __int8 *result)
{
  unsigned __int8 *v1; // x19
  unsigned __int64 v2; // x10
  unsigned __int8 *v3; // x1
  __int64 v4; // x12
  unsigned __int64 v5; // x13
  unsigned __int64 v6; // x2
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x11
  _BYTE *v10; // x10
  bool v11; // w14
  unsigned __int8 *v12; // x11
  unsigned __int8 *v13; // x10
  int v14; // w15
  unsigned __int8 *v15; // x10
  unsigned __int8 *v16; // x14
  __int64 v17; // x12
  unsigned __int64 v18; // x12
  _BYTE *v19; // x13
  bool v20; // zf
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x9
  unsigned __int64 v23; // x15
  unsigned __int64 v24; // x14
  int v25; // w16
  __int64 v26; // x13
  __int64 v27; // x16
  _BYTE *v28; // x17
  _BYTE *v29; // x15
  _BYTE *v30; // x16
  unsigned __int8 v31; // w8
  size_t v32[2]; // [xsp+0h] [xbp-20h] BYREF

  v1 = result;
  v2 = *result;
  v3 = (unsigned __int8 *)*((_QWORD *)result + 3);
  v4 = *((_QWORD *)result + 4);
  if ( (v2 & 1) != 0 )
    v5 = *((_QWORD *)result + 1);
  else
    v5 = v2 >> 1;
  v6 = v5 + v4;
  *((_QWORD *)result + 4) = v5 + v4;
  v7 = *((_QWORD *)v3 + 1);
  LODWORD(v8) = *v3;
  v9 = (unsigned __int64)*v3 >> 1;
  if ( (v8 & 1) != 0 )
    v9 = *((_QWORD *)v3 + 1);
  if ( v6 == v9 )
  {
    if ( (v2 & 1) != 0 )
    {
      **((_BYTE **)result + 2) = 0;
      *((_QWORD *)result + 1) = 0LL;
    }
    else
    {
      *(_WORD *)result = 0;
    }
  }
  else
  {
    v11 = v5 >= 3
       && ((v2 & 1) == 0 ? (v10 = result + 1) : (v10 = (_BYTE *)*((_QWORD *)result + 2)), *v10 == 47 && v10[1] == 47)
       && v10[2] != 47;
    v12 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
    if ( (v8 & 1) != 0 )
      v13 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
    else
      v13 = v3 + 1;
    v14 = v13[v6];
    v15 = v3 + 1;
    if ( v14 == 47 )
    {
      if ( v11 )
        return (unsigned __int8 *)sub_6849AD8(result, 47LL);
      if ( (v8 & 1) != 0 )
        v16 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
      else
        v16 = v3 + 1;
      if ( v16[v6] == 47 )
      {
        v17 = v5 + v4 + 1;
        while ( 1 )
        {
          *((_QWORD *)result + 4) = v17;
          v6 = v17;
          v7 = *((_QWORD *)v3 + 1);
          v12 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
          v8 = *v3;
          v18 = v8 >> 1;
          if ( (v8 & 1) != 0 )
            v19 = (_BYTE *)*((_QWORD *)v3 + 2);
          else
            v19 = v3 + 1;
          if ( (v8 & 1) != 0 )
            v18 = *((_QWORD *)v3 + 1);
          if ( v6 == v18 )
            break;
          v17 = v6 + 1;
          if ( v19[v6] != 47 )
            goto LABEL_36;
        }
        v23 = v6;
        while ( 1 )
        {
          v24 = v23 - 1;
          if ( v23 == 1 )
            break;
          v25 = (unsigned __int8)v19[v23-- - 2];
          if ( v25 != 47 )
          {
            if ( v24 < 3 || *v19 != 47 || v19[1] != 47 )
              goto LABEL_65;
            if ( v6 >= 3 )
            {
              v27 = 0LL;
              v28 = v19 + 2;
              v29 = &v19[v6];
              while ( v28[v27] != 47 )
              {
                if ( v6 - 2 == ++v27 )
                {
                  v30 = &v19[v6];
                  goto LABEL_62;
                }
              }
              v30 = &v28[v27];
LABEL_62:
              v26 = v30 - v19;
              if ( v29 == v30 )
                v26 = -1LL;
            }
            else
            {
              v26 = -1LL;
            }
            if ( v26 != v24 )
            {
LABEL_65:
              *((_QWORD *)result + 4) = v6 - 1;
              v31 = atomic_load(byte_73049D8);
              if ( (v31 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_73049D8) )
              {
                sub_54E48D4((int)byte_73049C0, ".");
                __cxa_atexit((void (*)(void *))sub_2758F1C, byte_73049C0, &off_686E780);
                sub_6862850(byte_73049D8);
              }
              return sub_684A438(v1, byte_73049C0);
            }
            break;
          }
        }
      }
    }
LABEL_36:
    v20 = (v8 & 1) == 0;
    v21 = (unsigned int)v8 >> 1;
    if ( !v20 )
    {
      v15 = v12;
      v21 = v7;
    }
    if ( v21 <= v6 )
      goto LABEL_45;
    v22 = v6;
    while ( v15[v22] != 47 )
    {
      if ( v21 == ++v22 )
        goto LABEL_45;
    }
    if ( v21 == v22 || v22 == -1LL )
LABEL_45:
      v22 = v21;
    sub_6849CE0(v32, v3, v6, v22 - v6);
    result = sub_684A438(v1, (unsigned __int8 *)v32);
    if ( (v32[0] & 1) != 0 )
      return (unsigned __int8 *)sub_65ECAF4();
  }
  return result;
}


================================================================================
Function: sub_67DDA30 (0x67DDA30)
================================================================================

__int64 *sub_67DDA30()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_7304A60);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_7304A60) )
  {
    qword_7304A58 = (__int64)off_6C58200;
    sub_6862850(byte_7304A60);
  }
  return &qword_7304A58;
}


================================================================================
Function: sub_67DE264 (0x67DE264)
================================================================================

__int64 (__fastcall ***sub_67DE264())()
{
  return &off_6CAE348;
}


================================================================================
Function: sub_67DE7A8 (0x67DE7A8)
================================================================================

void *sub_67DE7A8()
{
  unsigned __int64 v0; // x8
  __int64 (__fastcall **v2)(); // [xsp+8h] [xbp-18h] BYREF
  __int64 (__fastcall *v3)(); // [xsp+10h] [xbp-10h] BYREF

  v0 = atomic_load(&qword_7304AC8);
  if ( v0 != -1LL )
  {
    v2 = &v3;
    v3 = sub_67DE834;
    sub_6848B54(&qword_7304AC8, (__int64)&v2, (void (__fastcall *)(__int64))sub_4FA43BC);
  }
  return pthread_getspecific(dword_7304AD0);
}


================================================================================
Function: sub_67DE848 (0x67DE848)
================================================================================

_QWORD *__fastcall sub_67DE848(_QWORD *result)
{
  *result = 0LL;
  result[1] = 0LL;
  return result;
}


================================================================================
Function: sub_67DE850 (0x67DE850)
================================================================================

bool __fastcall sub_67DE850(void **a1)
{
  char *v1; // x21
  _QWORD *v2; // x22
  __int64 v4; // x20
  int v5; // w20
  _QWORD *v6; // x8
  __int64 v7; // x19

  v2 = *a1;
  v1 = (char *)a1[1];
  if ( v1 )
    sub_6867390(1LL, v1 + 8);
  v4 = v2[4];
  v2[3] = v2;
  v2[4] = v1;
  if ( v4 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v4 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 16LL))(v4);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v4 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
    }
  }
  v5 = pthread_create((pthread_t *)*a1 + 5, 0LL, (void *(*)(void *))sub_67DE964, *a1);
  if ( v5 )
  {
    v6 = *a1;
    v7 = *((_QWORD *)*a1 + 4);
    v6[3] = 0LL;
    v6[4] = 0LL;
    if ( v7 )
    {
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 8)) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
        if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v7 + 12)) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
      }
    }
  }
  return v5 == 0;
}


================================================================================
Function: sub_67DF254 (0x67DF254)
================================================================================

__int64 __fastcall sub_67DF254(__int64 result)
{
  __int64 v1; // x19
  __int64 v2; // x20
  pthread_mutex_t *v3; // x20
  pthread_mutex_t *mutex[3]; // [xsp+8h] [xbp-58h] BYREF
  _BYTE v5[56]; // [xsp+20h] [xbp-40h] BYREF

  v2 = *(_QWORD *)result;
  v1 = *(_QWORD *)(result + 8);
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = 0LL;
  mutex[1] = (pthread_mutex_t *)v2;
  mutex[2] = (pthread_mutex_t *)v1;
  if ( v2 )
  {
    sub_25C6F84((int)mutex, (pthread_mutex_t *)(v2 + 48));
    if ( !*(_BYTE *)(v2 + 305) )
    {
      pthread_detach(*(_QWORD *)(v2 + 40));
      *(_WORD *)(v2 + 305) = 257;
    }
    v3 = mutex[0];
    do
      result = pthread_mutex_unlock(v3);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25C5E54(v5, (unsigned int)result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24(v5);
    }
  }
  if ( v1 )
  {
    result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v1 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1);
      result = sub_68673F0(0xFFFFFFFF, (atomic_uint *)(v1 + 12));
      if ( (_DWORD)result == 1 )
        return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 24LL))(v1);
    }
  }
  return result;
}


================================================================================
Function: sub_67DF9F4 (0x67DF9F4)
================================================================================

pthread_mutex_t *__fastcall sub_67DF9F4(pthread_mutex_t **a1)
{
  pthread_mutex_t *v1; // x8
  pthread_mutex_t *align; // x19
  pthread_mutex_t *v3; // x20
  unsigned int v4; // w0
  pthread_mutex_t *v5; // x20
  pthread_mutex_t *mutex[2]; // [xsp+8h] [xbp-58h] BYREF
  pthread_mutex_t *v8; // [xsp+18h] [xbp-48h]
  _BYTE v9[56]; // [xsp+20h] [xbp-40h] BYREF

  align = *a1;
  v1 = a1[1];
  mutex[1] = *a1;
  v8 = v1;
  if ( v1 )
    sub_6867390(1LL, &v1->__align + 1);
  if ( align )
  {
    sub_25C6F84((int)mutex, (pthread_mutex_t *)((char *)align + 48));
    align = (pthread_mutex_t *)align[1].__align;
    v3 = mutex[0];
    do
      v4 = pthread_mutex_unlock(v3);
    while ( v4 == 4 );
    if ( v4 )
    {
      sub_25C5E54(v9, v4, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25C5D24(v9);
    }
  }
  v5 = v8;
  if ( v8 )
  {
    if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)(&v8->__align + 1)) == 1 )
    {
      (*(void (__fastcall **)(pthread_mutex_t *))(v5->__align + 16))(v5);
      if ( (unsigned int)sub_68673F0(0xFFFFFFFF, (atomic_uint *)((char *)&v5->__align + 12)) == 1 )
        (*(void (__fastcall **)(pthread_mutex_t *))(v5->__align + 24))(v5);
    }
  }
  return align;
}


================================================================================
Function: sub_67DFB28 (0x67DFB28)
================================================================================

void *sub_67DFB28()
{
  unsigned __int64 v0; // x8
  void *result; // x0
  _BYTE *v2; // x19
  pthread_mutex_t *v3; // x19
  __int64 v4; // x0
  pthread_mutex_t *mutex; // [xsp+18h] [xbp-48h] BYREF
  _QWORD v6[6]; // [xsp+20h] [xbp-40h] BYREF

  v0 = atomic_load(&qword_7304AC8);
  if ( v0 != -1LL )
  {
    mutex = (pthread_mutex_t *)v6;
    v6[0] = sub_67DE834;
    sub_6848B54(&qword_7304AC8, (__int64)&mutex, (void (__fastcall *)(__int64))sub_4FA43BC);
  }
  result = pthread_getspecific(dword_7304AD0);
  if ( result )
  {
    v2 = result;
    if ( *((_BYTE *)result + 408) )
    {
      sub_25C6F84(&mutex, (pthread_mutex_t *)((char *)result + 48));
      if ( v2[409] )
      {
        v2[409] = 0;
        v4 = sub_6861FD0(1LL);
        sub_6862048(v4, (__int64)&`typeinfo for'boost::thread_interrupted, 0LL);
      }
      v3 = mutex;
      do
        result = (void *)pthread_mutex_unlock(v3);
      while ( (_DWORD)result == 4 );
      if ( (_DWORD)result )
      {
        sub_25C5E54(v6, (unsigned int)result, "boost: mutex unlock failed in pthread_mutex_unlock");
        sub_25C5D24((__int64)v6);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67DFD68 (0x67DFD68)
================================================================================

_BYTE *__fastcall sub_67DFD68(_BYTE *a1)
{
  unsigned __int64 v2; // x8
  _BYTE *result; // x0
  int v4; // w8
  unsigned __int64 v5; // x8
  __int64 (__fastcall **v6)(); // [xsp+8h] [xbp-18h] BYREF
  __int64 (__fastcall *v7)(); // [xsp+10h] [xbp-10h] BYREF

  v2 = atomic_load(&qword_7304AC8);
  if ( v2 != -1LL )
  {
    v6 = &v7;
    v7 = sub_67DE834;
    sub_6848B54(&qword_7304AC8, (__int64)&v6, (void (__fastcall *)(__int64))sub_4FA43BC);
  }
  result = pthread_getspecific(dword_7304AD0);
  if ( result )
  {
    v4 = (unsigned __int8)result[408];
    *a1 = v4;
    if ( v4 )
    {
      v5 = atomic_load(&qword_7304AC8);
      if ( v5 != -1LL )
      {
        v6 = &v7;
        v7 = sub_67DE834;
        sub_6848B54(&qword_7304AC8, (__int64)&v6, (void (__fastcall *)(__int64))sub_4FA43BC);
      }
      result = pthread_getspecific(dword_7304AD0);
      result[408] = 0;
    }
  }
  else
  {
    *a1 = 0;
  }
  return result;
}


================================================================================
Function: sub_67DFE60 (0x67DFE60)
================================================================================

_BYTE *__fastcall sub_67DFE60(char *a1)
{
  unsigned __int64 v2; // x8
  _BYTE *result; // x0
  char v4; // w19
  unsigned __int64 v5; // x8
  __int64 (__fastcall **v6)(); // [xsp+8h] [xbp-18h] BYREF
  __int64 (__fastcall *v7)(); // [xsp+10h] [xbp-10h] BYREF

  v2 = atomic_load(&qword_7304AC8);
  if ( v2 != -1LL )
  {
    v6 = &v7;
    v7 = sub_67DE834;
    sub_6848B54(&qword_7304AC8, (__int64)&v6, (void (__fastcall *)(__int64))sub_4FA43BC);
  }
  result = pthread_getspecific(dword_7304AD0);
  if ( result )
  {
    v4 = *a1;
    v5 = atomic_load(&qword_7304AC8);
    if ( v5 != -1LL )
    {
      v6 = &v7;
      v7 = sub_67DE834;
      sub_6848B54(&qword_7304AC8, (__int64)&v6, (void (__fastcall *)(__int64))sub_4FA43BC);
    }
    result = pthread_getspecific(dword_7304AD0);
    result[408] = v4;
  }
  return result;
}


================================================================================
Function: sub_67E05A0 (0x67E05A0)
================================================================================

unsigned __int64 __fastcall sub_67E05A0(int a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  __int64 v7; // x8
  unsigned int v9; // t1
  int v10; // w14
  unsigned __int8 *v11; // x15
  bool v12; // cf
  unsigned __int64 v13; // x9
  __int64 v14; // x8
  unsigned __int64 v15; // x9
  __int64 v16; // x8
  unsigned __int64 v17; // x9
  __int64 v18; // x8
  unsigned __int64 v19; // x9
  __int64 v20; // x8
  unsigned __int64 v21; // x9
  __int64 v22; // x8
  unsigned __int64 v23; // x9
  __int64 v24; // x8
  unsigned __int64 v25; // x9
  __int64 v26; // x8
  unsigned __int64 v27; // x9
  __int64 v28; // x8
  __int64 v29; // x0
  unsigned __int64 v30; // x9
  __int64 v31; // x8
  __int64 v32; // x9
  __int64 v33; // x8
  __int64 v34; // x9
  __int64 v35; // x8
  __int64 v36; // x9
  __int64 v37; // x8
  __int64 v38; // x9
  __int64 v39; // x16
  __int64 v40; // x8
  __int64 v41; // x9
  __int64 v42; // x8
  __int64 v43; // x9
  __int64 v44; // x8
  unsigned __int64 v45; // x9
  __int64 v46; // x8
  unsigned __int64 v47; // x9
  __int64 v48; // x8
  unsigned __int64 v49; // x9
  __int64 v50; // x8
  unsigned __int64 v51; // x9
  __int64 v52; // x8
  unsigned __int64 v53; // x9
  __int64 v54; // x8
  unsigned __int64 v55; // x9
  __int64 v56; // x8
  unsigned __int64 v57; // x9
  __int64 v58; // x8
  unsigned __int64 v59; // x9
  __int64 v60; // x8
  unsigned __int64 v61; // x9
  __int64 v62; // x8
  __int64 v63; // x9
  __int64 v64; // x8
  __int64 v65; // x9
  __int64 v66; // x8
  __int64 v67; // x9
  __int64 v68; // x8
  __int64 v69; // x9
  __int64 v70; // x8
  __int64 v71; // x9
  __int64 v72; // x11
  __int64 v73; // x8
  __int64 v74; // x9
  __int64 v75; // x8
  unsigned int v76; // t1

  a3 = (unsigned int)a3;
  v3 = HIWORD(a1);
  v4 = (unsigned __int16)a1;
  if ( (unsigned int)a3 != 1LL )
  {
    if ( !a2 )
      return 1LL;
    if ( (unsigned int)a3 < 0x10uLL )
    {
      if ( (_DWORD)a3 )
      {
        do
        {
          v9 = *a2++;
          --a3;
          v4 += v9;
          v3 += v4;
        }
        while ( a3 );
      }
      v3 %= 0xFFF1uLL;
      if ( v4 > 0xFFF0 )
        v4 -= 65521LL;
      return v4 | (v3 << 16);
    }
    if ( (unsigned __int64)(unsigned int)a3 >> 4 >= 0x15B )
    {
      do
      {
        a3 -= 5552LL;
        v10 = -347;
        v11 = a2;
        do
        {
          v12 = __CFADD__(v10++, 1);
          v13 = v4 + *v11;
          v14 = v13 + v3;
          v15 = v13 + v11[1];
          v16 = v14 + v15;
          v17 = v15 + v11[2];
          v18 = v16 + v17;
          v19 = v17 + v11[3];
          v20 = v18 + v19;
          v21 = v19 + v11[4];
          v22 = v20 + v21;
          v23 = v21 + v11[5];
          v24 = v22 + v23;
          v25 = v23 + v11[6];
          v26 = v24 + v25;
          v27 = v25 + v11[7];
          v28 = v26 + v27;
          v29 = v11[14];
          v30 = v27 + v11[8];
          v31 = v28 + v30;
          v32 = v30 + v11[9];
          v33 = v31 + v32;
          v34 = v32 + v11[10];
          v35 = v33 + v34;
          v36 = v34 + v11[11];
          v37 = v35 + v36;
          v38 = v36 + v11[12];
          v39 = v11[15];
          v40 = v37 + v38;
          v41 = v38 + v11[13];
          v11 += 16;
          v42 = v40 + v41;
          v43 = v41 + v29;
          v44 = v42 + v43;
          v4 = v43 + v39;
          v3 = v44 + v4;
        }
        while ( !v12 );
        a2 += 5552;
        v4 %= 0xFFF1uLL;
        v3 %= 0xFFF1uLL;
      }
      while ( a3 >> 4 > 0x15A );
      if ( !a3 )
        return v4 | (v3 << 16);
      if ( a3 < 0x10 )
        goto LABEL_29;
    }
    do
    {
      a3 -= 16LL;
      v45 = v4 + *a2;
      v46 = v45 + v3;
      v47 = v45 + a2[1];
      v48 = v46 + v47;
      v49 = v47 + a2[2];
      v50 = v48 + v49;
      v51 = v49 + a2[3];
      v52 = v50 + v51;
      v53 = v51 + a2[4];
      v54 = v52 + v53;
      v55 = v53 + a2[5];
      v56 = v54 + v55;
      v57 = v55 + a2[6];
      v58 = v56 + v57;
      v59 = v57 + a2[7];
      v60 = v58 + v59;
      v61 = v59 + a2[8];
      v62 = v60 + v61;
      v63 = v61 + a2[9];
      v64 = v62 + v63;
      v65 = v63 + a2[10];
      v66 = v64 + v65;
      v67 = v65 + a2[11];
      v68 = v66 + v67;
      v69 = v67 + a2[12];
      v70 = v68 + v69;
      v71 = v69 + a2[13];
      v72 = a2[15];
      v73 = v70 + v71;
      v74 = v71 + a2[14];
      a2 += 16;
      v75 = v73 + v74;
      v4 = v74 + v72;
      v3 = v75 + v4;
    }
    while ( a3 > 0xF );
    if ( a3 )
    {
LABEL_29:
      do
      {
        v76 = *a2++;
        --a3;
        v4 += v76;
        v3 += v4;
      }
      while ( a3 );
    }
    return (v4 % 0xFFF1) | ((v3 % 0xFFF1) << 16);
  }
  v5 = (unsigned __int16)a1 + (unsigned __int64)*a2;
  if ( v5 > 0xFFF0 )
    v5 -= 65521LL;
  v6 = v5 + HIWORD(a1);
  if ( v6 <= 0xFFF0 )
    v7 = v6 << 16;
  else
    v7 = (v6 << 16) - 4293984256u;
  return v7 | v5;
}


================================================================================
Function: sub_67E09C0 (0x67E09C0)
================================================================================

__int64 __fastcall sub_67E09C0(int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3; // w11
  int *v4; // x9
  unsigned __int64 v5; // x10
  unsigned int v7; // w15
  unsigned int v8; // w14
  unsigned int v9; // w14
  unsigned int v10; // w14
  unsigned int v11; // w14
  unsigned int v12; // w14
  unsigned int v13; // w14
  unsigned int v14; // w14
  int *v15; // x12
  int v16; // t1
  int v17; // t1

  if ( !a2 )
    return 0LL;
  v3 = ~a1;
  if ( a3 && ((unsigned __int8)a2 & 3) != 0 )
  {
    v4 = (int *)(a2 + 1);
    v3 = dword_1741CA4[(unsigned __int8)~(_BYTE)a1 ^ *a2] ^ ((unsigned int)~a1 >> 8);
    v5 = a3 - 1LL;
    if ( a3 != 1LL && ((unsigned __int8)v4 & 3) != 0 )
    {
      v4 = (int *)(a2 + 2);
      v3 = dword_1741CA4[(unsigned __int8)v3 ^ a2[1]] ^ (v3 >> 8);
      v5 = a3 - 2LL;
      if ( a3 != 2LL && ((unsigned __int8)v4 & 3) != 0 )
      {
        v4 = (int *)(a2 + 3);
        v3 = dword_1741CA4[(unsigned __int8)v3 ^ a2[2]] ^ (v3 >> 8);
        v5 = a3 - 3LL;
        if ( a3 != 3LL && ((unsigned __int8)v4 & 3) != 0 )
        {
          v4 = (int *)(a2 + 4);
          v3 = dword_1741CA4[(unsigned __int8)v3 ^ a2[3]] ^ (v3 >> 8);
          v5 = a3 - 4LL;
        }
      }
    }
  }
  else
  {
    v4 = (int *)a2;
    v5 = a3;
  }
  if ( v5 >= 0x20 )
  {
    do
    {
      v5 -= 32LL;
      v7 = *v4 ^ v3;
      v8 = dword_1741CA4[BYTE1(v7) + 512] ^ dword_1741CA4[(unsigned __int8)v7 + 768] ^ dword_1741CA4[BYTE2(v7) + 256] ^ dword_1741CA4[HIBYTE(v7)] ^ v4[1];
      v9 = dword_1741CA4[BYTE1(v8) + 512] ^ dword_1741CA4[(unsigned __int8)(LOBYTE(dword_1741CA4[BYTE1(v7) + 512]) ^ LOBYTE(dword_1741CA4[(unsigned __int8)v7 + 768]) ^ LOBYTE(dword_1741CA4[BYTE2(v7) + 256]) ^ LOBYTE(dword_1741CA4[HIBYTE(v7)]) ^ *((_BYTE *)v4 + 4))
                                                        + 768] ^ dword_1741CA4[BYTE2(v8) + 256] ^ dword_1741CA4[HIBYTE(v8)] ^ v4[2];
      v10 = dword_1741CA4[BYTE1(v9) + 512] ^ dword_1741CA4[(unsigned __int8)v9 + 768] ^ dword_1741CA4[BYTE2(v9) + 256] ^ dword_1741CA4[HIBYTE(v9)] ^ v4[3];
      v11 = dword_1741CA4[BYTE1(v10) + 512] ^ dword_1741CA4[(unsigned __int8)v10 + 768] ^ dword_1741CA4[BYTE2(v10) + 256] ^ dword_1741CA4[HIBYTE(v10)] ^ v4[4];
      v12 = dword_1741CA4[BYTE1(v11) + 512] ^ dword_1741CA4[(unsigned __int8)v11 + 768] ^ dword_1741CA4[BYTE2(v11) + 256] ^ dword_1741CA4[HIBYTE(v11)] ^ v4[5];
      v13 = dword_1741CA4[BYTE1(v12) + 512] ^ dword_1741CA4[(unsigned __int8)v12 + 768] ^ dword_1741CA4[BYTE2(v12) + 256] ^ dword_1741CA4[HIBYTE(v12)] ^ v4[6];
      v14 = dword_1741CA4[BYTE1(v13) + 512] ^ dword_1741CA4[(unsigned __int8)v13 + 768] ^ dword_1741CA4[BYTE2(v13) + 256] ^ dword_1741CA4[HIBYTE(v13)] ^ v4[7];
      v15 = v4 + 8;
      v3 = dword_1741CA4[BYTE1(v14) + 512] ^ dword_1741CA4[(unsigned __int8)v14 + 768] ^ dword_1741CA4[BYTE2(v14) + 256] ^ dword_1741CA4[HIBYTE(v14)];
      v4 += 8;
    }
    while ( v5 > 0x1F );
    v4 = v15;
  }
  if ( v5 >= 4 )
  {
    do
    {
      v16 = *v4++;
      v5 -= 4LL;
      v3 = dword_1741CA4[(unsigned __int8)((unsigned __int16)(v16 ^ v3) >> 8) + 512] ^ dword_1741CA4[(unsigned __int8)(v16 ^ v3) + 768] ^ dword_1741CA4[(unsigned __int8)((v16 ^ v3) >> 16) + 256] ^ dword_1741CA4[(v16 ^ v3) >> 24];
    }
    while ( v5 > 3 );
  }
  for ( ; v5; v3 = dword_1741CA4[(unsigned __int8)v3 ^ v17] ^ (v3 >> 8) )
  {
    v17 = *(unsigned __int8 *)v4;
    v4 = (int *)((char *)v4 + 1);
    --v5;
  }
  return ~v3;
}


================================================================================
Function: sub_67E0C84 (0x67E0C84)
================================================================================

__int64 __fastcall sub_67E0C84(_QWORD *a1)
{
  void (__fastcall *v2)(_QWORD, _QWORD); // x9
  __int64 v3; // x1
  __int64 result; // x0
  int v5; // w20

  if ( !a1 )
    return 4294967294LL;
  if ( !a1[8] )
    return 4294967294LL;
  v2 = (void (__fastcall *)(_QWORD, _QWORD))a1[9];
  if ( !v2 )
    return 4294967294LL;
  v3 = a1[7];
  if ( !v3 || *(_QWORD **)v3 != a1 )
    return 4294967294LL;
  v5 = *(_DWORD *)(v3 + 8);
  if ( ((unsigned int)(v5 - 57) > 0x38 || ((1LL << ((unsigned __int8)v5 - 57)) & 0x100400400011001LL) == 0)
    && v5 != 666
    && v5 != 42 )
  {
    return 4294967294LL;
  }
  if ( *(_QWORD *)(v3 + 16) )
  {
    v2(a1[10], *(_QWORD *)(v3 + 16));
    v3 = a1[7];
  }
  if ( *(_QWORD *)(v3 + 120) )
  {
    ((void (__fastcall *)(_QWORD, _QWORD))a1[9])(a1[10], *(_QWORD *)(v3 + 120));
    v3 = a1[7];
  }
  if ( *(_QWORD *)(v3 + 112) )
  {
    ((void (__fastcall *)(_QWORD, _QWORD))a1[9])(a1[10], *(_QWORD *)(v3 + 112));
    v3 = a1[7];
  }
  if ( *(_QWORD *)(v3 + 96) )
  {
    ((void (__fastcall *)(_QWORD, _QWORD))a1[9])(a1[10], *(_QWORD *)(v3 + 96));
    v3 = a1[7];
  }
  ((void (__fastcall *)(_QWORD, __int64))a1[9])(a1[10], v3);
  if ( v5 == 113 )
    result = 4294967293LL;
  else
    result = 0LL;
  a1[7] = 0LL;
  return result;
}


================================================================================
Function: sub_67E0E30 (0x67E0E30)
================================================================================

unsigned __int64 __fastcall sub_67E0E30(unsigned __int64 result)
{
  __int64 v1; // x22
  unsigned __int64 v2; // x19
  unsigned int v3; // w8
  int32x2_t v4; // d9
  int i; // w10
  unsigned int v6; // w9
  size_t v7; // x20
  int8x8_t v8; // d2
  int8x8_t v9; // d3
  __int64 v10; // x8
  __int64 v11; // x13
  unsigned __int64 v12; // d0
  __int64 v13; // x14
  uint32x2_t v14; // d1
  __int64 v15; // x11
  __int64 v16; // x9
  __int64 v17; // x10
  int v18; // w9
  __int64 v19; // x11
  __int64 v20; // x12
  unsigned __int16 *v21; // x13
  __int64 v22; // x14
  _WORD *v23; // x10
  unsigned int v24; // w11
  bool v25; // cf
  __int16 v26; // w11
  __int64 v27; // x13
  __int64 v28; // x9
  __int64 v29; // x10
  int v30; // w9
  __int64 v31; // x11
  __int64 v32; // x12
  __int64 v33; // x14
  unsigned __int16 *v34; // x13
  _WORD *v35; // x10
  unsigned int v36; // w11
  __int16 v37; // w11
  __int64 v38; // x24
  unsigned int v39; // w10
  __int64 v40; // x8
  const void *v41; // x1
  __int64 v42; // x9
  unsigned __int8 *v43; // x21
  int v44; // w8
  size_t v45; // x9
  int v46; // w9
  __int64 v47; // x11
  unsigned int v48; // w10
  int v49; // w14
  int v50; // w12
  unsigned int v51; // w13
  __int64 v52; // x14
  __int64 v53; // x17
  int v54; // w15
  __int64 v55; // x15
  unsigned __int64 v56; // x8
  unsigned __int64 v57; // x10
  unsigned __int64 v58; // x21
  size_t v59; // x20
  size_t v60; // x8
  unsigned __int64 v61; // x20

  v1 = *(unsigned int *)(result + 80);
  v2 = result;
  v3 = *(_DWORD *)(result + 180);
  v4.n64_u64[0] = vdup_n_s32(v1).n64_u64[0];
  for ( i = *(_DWORD *)(result + 80); ; i = *(_DWORD *)(v2 + 80) )
  {
    v6 = *(_DWORD *)(v2 + 172);
    LODWORD(v7) = *(_DWORD *)(v2 + 104) - (v3 + v6);
    if ( v6 < (int)v1 - 262 + i )
      goto LABEL_22;
    result = (unsigned __int64)memcpy(
                                 *(void **)(v2 + 96),
                                 (const void *)(*(_QWORD *)(v2 + 96) + v1),
                                 (unsigned int)(v1 - v7));
    v10 = *(unsigned int *)(v2 + 80);
    v11 = *(unsigned int *)(v2 + 132);
    v12 = vsub_s32(*(int32x2_t *)(v2 + 172), v4).n64_u64[0];
    v13 = *(_QWORD *)(v2 + 120);
    v14.n64_u64[0] = vdup_n_s32(v10).n64_u64[0];
    v15 = *(_QWORD *)(v2 + 152) - v1;
    v16 = (unsigned int)(v11 - 1);
    v17 = v13 + 2LL * (unsigned int)v11;
    *(_QWORD *)(v2 + 172) = v12;
    *(_QWORD *)(v2 + 152) = v15;
    if ( (unsigned int)v16 >= 3 )
    {
      v19 = v16 + 1;
      v20 = (v16 + 1) & 0x1FFFFFFFCLL;
      v18 = v11 - v20;
      v17 -= 2 * v20;
      v21 = (unsigned __int16 *)(v13 + 2 * v11 - 4);
      v22 = v20;
      do
      {
        v22 -= 4LL;
        v8.n64_u16[0] = v21[1];
        v9.n64_u16[0] = *(v21 - 1);
        v8.n64_u16[2] = *v21;
        v9.n64_u16[2] = *(v21 - 2);
        v8.n64_u64[0] = vrev64_s32(vqsub_u32(vand_s8(v8, (int8x8_t)0xFFFF0000FFFFLL), v14)).n64_u64[0];
        v9.n64_u64[0] = vrev64_s32(vqsub_u32(vand_s8(v9, (int8x8_t)0xFFFF0000FFFFLL), v14)).n64_u64[0];
        result = v9.n64_u32[1];
        *v21 = v8.n64_u16[0];
        *(v21 - 2) = v9.n64_u16[0];
        v21[1] = v8.n64_u16[2];
        *(v21 - 1) = v9.n64_u16[2];
        v21 -= 4;
      }
      while ( v22 );
      if ( v19 == v20 )
        goto LABEL_12;
    }
    else
    {
      v18 = v11;
    }
    v23 = (_WORD *)(v17 - 2);
    do
    {
      v24 = (unsigned __int16)*v23;
      v25 = v24 >= (unsigned int)v10;
      v26 = v24 - v10;
      if ( !v25 )
        v26 = 0;
      --v18;
      *v23-- = v26;
    }
    while ( v18 );
LABEL_12:
    v27 = *(_QWORD *)(v2 + 112) + 2 * v10;
    v28 = (unsigned int)(v10 - 1);
    if ( (unsigned int)v28 < 3 )
    {
      v29 = *(_QWORD *)(v2 + 112) + 2 * v10;
      v30 = v10;
LABEL_17:
      v35 = (_WORD *)(v29 - 2);
      do
      {
        v36 = (unsigned __int16)*v35;
        v25 = v36 >= (unsigned int)v10;
        v37 = v36 - v10;
        if ( !v25 )
          v37 = 0;
        --v30;
        *v35-- = v37;
      }
      while ( v30 );
      goto LABEL_21;
    }
    v31 = v28 + 1;
    v32 = (v28 + 1) & 0x1FFFFFFFCLL;
    v30 = v10 - v32;
    v33 = v32;
    v29 = v27 - 2 * v32;
    v34 = (unsigned __int16 *)(v27 - 4);
    do
    {
      v33 -= 4LL;
      v8.n64_u16[0] = v34[1];
      v9.n64_u16[0] = *(v34 - 1);
      v8.n64_u16[2] = *v34;
      v9.n64_u16[2] = *(v34 - 2);
      v8.n64_u64[0] = vrev64_s32(vqsub_u32(vand_s8(v8, (int8x8_t)0xFFFF0000FFFFLL), v14)).n64_u64[0];
      v9.n64_u64[0] = vrev64_s32(vqsub_u32(vand_s8(v9, (int8x8_t)0xFFFF0000FFFFLL), v14)).n64_u64[0];
      result = v9.n64_u32[1];
      *v34 = v8.n64_u16[0];
      *(v34 - 2) = v9.n64_u16[0];
      v34[1] = v8.n64_u16[2];
      *(v34 - 1) = v9.n64_u16[2];
      v34 -= 4;
    }
    while ( v33 );
    if ( v31 != v32 )
      goto LABEL_17;
LABEL_21:
    LODWORD(v7) = v1 + v7;
    v6 = v12;
LABEL_22:
    v38 = *(_QWORD *)v2;
    v39 = *(_DWORD *)(*(_QWORD *)v2 + 8LL);
    if ( !v39 )
      break;
    v40 = *(unsigned int *)(v2 + 180);
    if ( v39 <= (unsigned int)v7 )
      v7 = v39;
    else
      v7 = (unsigned int)v7;
    if ( (_DWORD)v7 )
    {
      v41 = *(const void **)v38;
      v42 = *(_QWORD *)(v2 + 96) + v6;
      *(_DWORD *)(v38 + 8) = v39 - v7;
      v43 = (unsigned __int8 *)(v42 + v40);
      result = (unsigned __int64)memcpy((void *)(v42 + v40), v41, v7);
      v44 = *(_DWORD *)(*(_QWORD *)(v38 + 56) + 48LL);
      if ( v44 == 2 )
      {
        result = sub_67E09C0(*(_QWORD *)(v38 + 96), v43, v7);
LABEL_31:
        *(_QWORD *)(v38 + 96) = result;
      }
      else if ( v44 == 1 )
      {
        result = sub_67E05A0(*(_QWORD *)(v38 + 96), v43, (unsigned int)v7);
        goto LABEL_31;
      }
      LODWORD(v40) = *(_DWORD *)(v2 + 180);
      v45 = *(_QWORD *)(v38 + 16) + v7;
      *(_QWORD *)v38 += v7;
      *(_QWORD *)(v38 + 16) = v45;
    }
    v46 = *(_DWORD *)(v2 + 5932);
    v3 = v40 + v7;
    *(_DWORD *)(v2 + 180) = v3;
    if ( v46 + v3 >= 3 )
    {
      v47 = *(_QWORD *)(v2 + 96);
      v48 = *(_DWORD *)(v2 + 172) - v46;
      v49 = *(unsigned __int8 *)(v47 + v48);
      *(_DWORD *)(v2 + 128) = v49;
      v51 = *(_DWORD *)(v2 + 140);
      v50 = *(_DWORD *)(v2 + 144);
      LODWORD(v52) = ((v49 << v50) ^ *(unsigned __int8 *)(v47 + v48 + 1)) & v51;
      *(_DWORD *)(v2 + 128) = v52;
      do
      {
        if ( !v46 )
          break;
        result = *(_QWORD *)(v2 + 112);
        v53 = *(_QWORD *)(v2 + 120);
        --v46;
        v54 = *(unsigned __int8 *)(v47 + v48 + 2);
        *(_DWORD *)(v2 + 5932) = v46;
        v52 = (((_DWORD)v52 << v50) ^ v54) & v51;
        v55 = *(_DWORD *)(v2 + 88) & v48;
        *(_DWORD *)(v2 + 128) = v52;
        *(_WORD *)(result + 2 * v55) = *(_WORD *)(v53 + 2 * v52);
        *(_WORD *)(v53 + 2 * v52) = v48++;
      }
      while ( v3 + v46 > 2 );
    }
    if ( v3 > 0x105 || !*(_DWORD *)(*(_QWORD *)v2 + 8LL) )
      break;
  }
  v56 = *(_QWORD *)(v2 + 5944);
  v57 = *(_QWORD *)(v2 + 104);
  if ( v57 > v56 )
  {
    v58 = *(unsigned int *)(v2 + 180) + (unsigned __int64)*(unsigned int *)(v2 + 172);
    if ( v56 < v58 )
    {
      if ( v57 - v58 >= 0x102 )
        v59 = 258LL;
      else
        v59 = v57 - v58;
      result = (unsigned __int64)memset((void *)(*(_QWORD *)(v2 + 96) + v58), 0, v59);
      v60 = v59 + v58;
      goto LABEL_51;
    }
    if ( v58 + 258 > v56 )
    {
      if ( v58 + 258 - v56 <= v57 - v56 )
        v61 = v58 + 258 - v56;
      else
        v61 = v57 - v56;
      result = (unsigned __int64)memset((void *)(*(_QWORD *)(v2 + 96) + v56), 0, (unsigned int)v61);
      v60 = *(_QWORD *)(v2 + 5944) + v61;
LABEL_51:
      *(_QWORD *)(v2 + 5944) = v60;
    }
  }
  return result;
}


================================================================================
Function: sub_67E132C (0x67E132C)
================================================================================

__int64 __fastcall sub_67E132C(__int64 a1, unsigned int a2)
{
  __int64 v3; // x19
  int v4; // w9
  __int64 result; // x0
  int v7; // w8
  __int64 v8; // x11
  int v9; // w10
  size_t v10; // x8
  unsigned int v11; // w9
  size_t v12; // x22
  __int64 v13; // x11
  __int64 v14; // x12
  int v15; // w10
  size_t v16; // x13
  int v17; // w10
  int v18; // w10
  unsigned int v19; // w9
  __int64 v20; // x14
  __int64 v21; // x10
  char v22; // w8
  __int64 v23; // x9
  __int64 v24; // x8
  __int64 v25; // x9
  __int64 v26; // x11
  __int64 v27; // x8
  __int64 v28; // x11
  __int64 v29; // x8
  __int64 v30; // x9
  __int64 v31; // x11
  __int64 v32; // x8
  __int64 v33; // x11
  __int64 v34; // x0
  __int64 v35; // x8
  __int64 v36; // x10
  __int64 v37; // x8
  __int64 v38; // x11
  __int64 v39; // x8
  __int64 v40; // x11
  int *v41; // x8
  int v42; // w9
  int v43; // w10
  __int64 v44; // x11
  __int64 v45; // x12
  __int64 v46; // x8
  bool v47; // w9
  bool v48; // zf
  __int64 v49; // x10
  char v50; // w13
  char v51; // w9
  __int64 v52; // x8
  __int64 v53; // x8
  __int64 v54; // x11
  __int64 v55; // x9
  __int64 v56; // x9
  __int64 v57; // x11
  __int64 v58; // x8
  __int64 v59; // x9
  __int64 v60; // x11
  __int64 v61; // x8
  __int64 v62; // x9
  __int64 v63; // x11
  __int64 v64; // x8
  int v65; // w8
  char v66; // w8
  int v67; // w11
  int v68; // w12
  __int64 v69; // x8
  __int64 v70; // x10
  __int64 v71; // x8
  __int64 v72; // x10
  __int64 v73; // x8
  __int64 v74; // x10
  __int64 v75; // x8
  __int64 v76; // x10
  __int64 v77; // x8
  __int64 v78; // x10
  int v79; // w8
  char v80; // w8
  __int64 v82; // x9
  __int64 v83; // x11
  __int64 v84; // x8
  __int64 v85; // x11
  __int64 v86; // x8
  __int64 v87; // x9
  char v88; // w8
  __int64 v89; // x11
  __int64 v90; // x9
  __int64 v91; // x11
  int v92; // w8
  __int64 v94; // x9
  __int64 v95; // x11
  __int64 v96; // x8
  __int64 v97; // x12
  __int64 v98; // x9
  __int64 v99; // x8
  int v100; // w11
  __int64 v101; // x9
  unsigned __int64 v102; // x24
  size_t v103; // x10
  size_t v104; // x22
  int v105; // w25
  size_t v106; // x23
  unsigned __int64 v107; // x8
  int v108; // w9
  size_t v109; // x8
  __int64 v110; // x23
  unsigned int v111; // w8
  unsigned int v112; // w9
  size_t v113; // x24
  __int64 v114; // x11
  __int64 v115; // x12
  int v116; // w10
  size_t v117; // x9
  size_t v118; // x8
  int v119; // w9
  unsigned __int64 v120; // x9
  unsigned __int64 v121; // x8
  bool v122; // cc
  __int64 v123; // x22
  unsigned int v124; // w8
  unsigned int v125; // w9
  size_t v126; // x23
  __int64 v127; // x11
  __int64 v128; // x12
  int v129; // w10
  size_t v130; // x9
  __int64 v131; // x10
  __int64 v132; // x11
  __int64 v133; // x12
  unsigned __int64 v134; // x9
  unsigned __int64 v135; // x9
  unsigned __int64 v136; // x8
  bool v137; // cc
  __int64 v138; // x22
  unsigned int v139; // w8
  unsigned int v140; // w9
  size_t v141; // x23
  __int64 v142; // x11
  __int64 v143; // x12
  int v144; // w10
  size_t v145; // x9
  __int64 v146; // x10
  __int64 v147; // x11
  __int64 v148; // x12
  unsigned __int64 v149; // x9
  __int64 v150; // x8
  __int64 v151; // x10
  __int64 v152; // x11
  __int64 v153; // x8
  __int64 v154; // x11
  __int64 v155; // x9
  __int64 v156; // x8
  int v157; // w9
  int v158; // w0
  char *v159; // x0
  size_t v160; // x2
  int v161; // w9
  __int64 v162; // x8
  __int64 v163; // x9
  __int64 v164; // x11
  __int64 v165; // x8
  __int64 v166; // x11
  __int64 v167; // x9
  __int64 v168; // x8
  __int64 v169; // x11
  __int64 v170; // x9
  __int64 v171; // x8
  __int64 v172; // x11
  __int64 v173; // x9
  __int64 v174; // x8
  __int64 v175; // x10
  __int64 v176; // x11
  __int64 v177; // x8
  __int64 v178; // x11
  __int64 v179; // x9
  __int64 v180; // x8
  __int64 v181; // x11
  __int64 v182; // x9
  __int64 v183; // x8
  __int64 v184; // x11
  __int64 v185; // x10
  __int64 v186; // x9
  __int64 v187; // x9
  __int64 v188; // x12
  __int64 v189; // x9
  __int64 v190; // x11
  __int64 v191; // x8
  __int64 v192; // x11
  int v193; // w8

  if ( !a1 )
    return 4294967294LL;
  if ( !*(_QWORD *)(a1 + 64) )
    return 4294967294LL;
  if ( !*(_QWORD *)(a1 + 72) )
    return 4294967294LL;
  v3 = *(_QWORD *)(a1 + 56);
  if ( !v3 || *(_QWORD *)v3 != a1 )
    return 4294967294LL;
  v4 = *(_DWORD *)(v3 + 8);
  if ( ((unsigned int)(v4 - 57) > 0x38 || ((1LL << ((unsigned __int8)v4 - 57)) & 0x100400400011001LL) == 0)
    && v4 != 666
    && v4 != 42 )
  {
    return 4294967294LL;
  }
  if ( a2 > 5 )
    return 4294967294LL;
  if ( !*(_QWORD *)(a1 + 24) || (v7 = *(_DWORD *)(a1 + 8)) != 0 && !*(_QWORD *)a1 || a2 != 4 && v4 == 666 )
  {
    result = 4294967294LL;
    *(_QWORD *)(a1 + 48) = "stream error";
    return result;
  }
  if ( !*(_DWORD *)(a1 + 32) )
    goto LABEL_59;
  v8 = *(_QWORD *)(v3 + 40);
  v9 = *(_DWORD *)(v3 + 76);
  *(_DWORD *)(v3 + 76) = a2;
  if ( v8 )
  {
    sub_67E72B4(v3);
    v10 = *(_QWORD *)(v3 + 40);
    v11 = *(_DWORD *)(a1 + 32);
    if ( v11 >= (unsigned int)v10 )
      v12 = (unsigned int)v10;
    else
      v12 = v11;
    if ( (_DWORD)v12 )
    {
      memcpy(*(void **)(a1 + 24), *(const void **)(v3 + 32), v12);
      v13 = *(_QWORD *)(v3 + 32);
      v14 = *(_QWORD *)(v3 + 40);
      v15 = *(_DWORD *)(a1 + 32);
      v16 = *(_QWORD *)(a1 + 40) + v12;
      *(_QWORD *)(a1 + 24) += v12;
      v11 = v15 - v12;
      v10 = v14 - v12;
      *(_QWORD *)(a1 + 40) = v16;
      *(_DWORD *)(a1 + 32) = v15 - v12;
      *(_QWORD *)(v3 + 32) = v13 + v12;
      *(_QWORD *)(v3 + 40) = v14 - v12;
      if ( v14 == v12 )
        *(_QWORD *)(v3 + 32) = *(_QWORD *)(v3 + 16);
    }
    if ( !v11 )
      goto LABEL_159;
    v4 = *(_DWORD *)(v3 + 8);
  }
  else if ( v7 )
  {
    v10 = 0LL;
  }
  else
  {
    if ( v9 <= 4 )
      v67 = 0;
    else
      v67 = -9;
    v10 = 0LL;
    if ( a2 <= 4 )
      v68 = 0;
    else
      v68 = -9;
    if ( a2 != 4 && (int)(v68 + 2 * a2) <= v67 + 2 * v9 )
      goto LABEL_59;
  }
  if ( v4 == 42 )
  {
    if ( *(int *)(v3 + 200) <= 1 && (v17 = *(_DWORD *)(v3 + 196), v17 >= 2) )
    {
      if ( (unsigned int)v17 >= 6 )
      {
        if ( v17 == 6 )
          v18 = 128;
        else
          v18 = 192;
      }
      else
      {
        v18 = 64;
      }
    }
    else
    {
      v18 = 0;
    }
    v19 = v18 | ((*(_DWORD *)(v3 + 84) << 12) - 30720);
    v20 = *(_QWORD *)(v3 + 16);
    if ( *(_DWORD *)(v3 + 172) )
      v19 |= 0x20u;
    *(_QWORD *)(v3 + 40) = v10 + 1;
    *(_BYTE *)(v20 + v10) = BYTE1(v19);
    v21 = *(_QWORD *)(v3 + 40);
    v22 = (v19 % 0x1F) | v19;
    v23 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v21 + 1;
    *(_BYTE *)(v23 + v21) = v22 ^ 0x1F;
    if ( *(_DWORD *)(v3 + 172) )
    {
      v24 = *(_QWORD *)(v3 + 40);
      v25 = *(_QWORD *)(a1 + 96);
      v26 = *(_QWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 40) = v24 + 1;
      *(_BYTE *)(v26 + v24) = BYTE3(v25);
      v27 = *(_QWORD *)(v3 + 40);
      v28 = *(_QWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 40) = v27 + 1;
      *(_BYTE *)(v28 + v27) = BYTE2(v25);
      v29 = *(_QWORD *)(v3 + 40);
      v30 = *(_QWORD *)(a1 + 96);
      v31 = *(_QWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 40) = v29 + 1;
      *(_BYTE *)(v31 + v29) = BYTE1(v30);
      v32 = *(_QWORD *)(v3 + 40);
      v33 = *(_QWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 40) = v32 + 1;
      *(_BYTE *)(v33 + v32) = v30;
    }
    *(_QWORD *)(a1 + 96) = sub_67E05A0(0LL, 0LL, 0LL);
    *(_DWORD *)(v3 + 8) = 113;
    sub_67E20AC(a1);
    if ( *(_QWORD *)(v3 + 40) )
      goto LABEL_159;
    v4 = *(_DWORD *)(v3 + 8);
  }
  else if ( v4 == 666 )
  {
    if ( !*(_DWORD *)(a1 + 8) )
    {
LABEL_161:
      if ( !*(_DWORD *)(v3 + 180) && (!a2 || *(_DWORD *)(v3 + 8) == 666) )
        goto LABEL_185;
      goto LABEL_162;
    }
LABEL_59:
    result = 4294967291LL;
    *(_QWORD *)(a1 + 48) = "buffer error";
    return result;
  }
  if ( v4 != 57 )
  {
LABEL_83:
    switch ( v4 )
    {
      case 'E':
        goto LABEL_84;
      case 'I':
        goto LABEL_107;
      case '[':
        goto LABEL_131;
      case 'g':
        goto LABEL_154;
      default:
        goto LABEL_160;
    }
  }
  v34 = sub_67E09C0(0LL, 0LL, 0LL);
  v35 = *(_QWORD *)(v3 + 40);
  v36 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(a1 + 96) = v34;
  *(_QWORD *)(v3 + 40) = v35 + 1;
  *(_BYTE *)(v36 + v35) = 31;
  v37 = *(_QWORD *)(v3 + 40);
  v38 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(v3 + 40) = v37 + 1;
  *(_BYTE *)(v38 + v37) = -117;
  v39 = *(_QWORD *)(v3 + 40);
  v40 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(v3 + 40) = v39 + 1;
  *(_BYTE *)(v40 + v39) = 8;
  v41 = *(int **)(v3 + 56);
  if ( !v41 )
  {
    v69 = *(_QWORD *)(v3 + 40);
    v70 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v69 + 1;
    *(_BYTE *)(v70 + v69) = 0;
    v71 = *(_QWORD *)(v3 + 40);
    v72 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v71 + 1;
    *(_BYTE *)(v72 + v71) = 0;
    v73 = *(_QWORD *)(v3 + 40);
    v74 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v73 + 1;
    *(_BYTE *)(v74 + v73) = 0;
    v75 = *(_QWORD *)(v3 + 40);
    v76 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v75 + 1;
    *(_BYTE *)(v76 + v75) = 0;
    v77 = *(_QWORD *)(v3 + 40);
    v78 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v77 + 1;
    *(_BYTE *)(v78 + v77) = 0;
    v79 = *(_DWORD *)(v3 + 196);
    if ( v79 == 9 )
    {
      v80 = 2;
    }
    else if ( v79 >= 2 && *(_DWORD *)(v3 + 200) <= 1 )
    {
      v80 = 0;
    }
    else
    {
      v80 = 4;
    }
    v94 = *(_QWORD *)(v3 + 40);
    v95 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v94 + 1;
    *(_BYTE *)(v95 + v94) = v80;
    v96 = *(_QWORD *)(v3 + 40);
    v97 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v96 + 1;
    *(_BYTE *)(v97 + v96) = 3;
    *(_DWORD *)(v3 + 8) = 113;
    sub_67E20AC(a1);
    if ( *(_QWORD *)(v3 + 40) )
      goto LABEL_159;
    v4 = *(_DWORD *)(v3 + 8);
    goto LABEL_83;
  }
  v42 = *v41;
  v43 = v41[17];
  v44 = *((_QWORD *)v41 + 3);
  v45 = *((_QWORD *)v41 + 5);
  v46 = *((_QWORD *)v41 + 7);
  v47 = v42 != 0;
  v48 = v43 == 0;
  v49 = *(_QWORD *)(v3 + 40);
  v50 = !v48;
  v51 = v47 & 0xE1 | (2 * (v50 & 1)) & 0xE3 | (4 * (v44 != 0)) & 0xE7 | (8 * (v45 != 0)) & 0xEF | (16 * (v46 != 0));
  v52 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(v3 + 40) = v49 + 1;
  *(_BYTE *)(v52 + v49) = v51;
  v53 = *(_QWORD *)(v3 + 40);
  v54 = *(_QWORD *)(v3 + 16);
  v55 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8LL);
  *(_QWORD *)(v3 + 40) = v53 + 1;
  *(_BYTE *)(v54 + v53) = v55;
  v56 = *(_QWORD *)(v3 + 40);
  v57 = *(_QWORD *)(v3 + 16);
  v58 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8LL) >> 8;
  *(_QWORD *)(v3 + 40) = v56 + 1;
  *(_BYTE *)(v57 + v56) = v58;
  v59 = *(_QWORD *)(v3 + 40);
  v60 = *(_QWORD *)(v3 + 16);
  v61 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8LL);
  *(_QWORD *)(v3 + 40) = v59 + 1;
  *(_BYTE *)(v60 + v59) = BYTE2(v61);
  v62 = *(_QWORD *)(v3 + 40);
  v63 = *(_QWORD *)(v3 + 16);
  v64 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8LL) >> 24;
  *(_QWORD *)(v3 + 40) = v62 + 1;
  *(_BYTE *)(v63 + v62) = v64;
  v65 = *(_DWORD *)(v3 + 196);
  if ( v65 == 9 )
  {
    v66 = 2;
  }
  else if ( v65 >= 2 && *(_DWORD *)(v3 + 200) <= 1 )
  {
    v66 = 0;
  }
  else
  {
    v66 = 4;
  }
  v82 = *(_QWORD *)(v3 + 40);
  v83 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(v3 + 40) = v82 + 1;
  *(_BYTE *)(v83 + v82) = v66;
  v84 = *(_QWORD *)(v3 + 40);
  v85 = *(_QWORD *)(v3 + 16);
  LOBYTE(v82) = *(_DWORD *)(*(_QWORD *)(v3 + 56) + 20LL);
  *(_QWORD *)(v3 + 40) = v84 + 1;
  *(_BYTE *)(v85 + v84) = v82;
  v86 = *(_QWORD *)(v3 + 56);
  if ( *(_QWORD *)(v86 + 24) )
  {
    v87 = *(_QWORD *)(v3 + 40);
    v88 = *(_DWORD *)(v86 + 32);
    v89 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v87 + 1;
    *(_BYTE *)(v89 + v87) = v88;
    v90 = *(_QWORD *)(v3 + 40);
    v91 = *(_QWORD *)(v3 + 16);
    v92 = *(_DWORD *)(*(_QWORD *)(v3 + 56) + 32LL) >> 8;
    *(_QWORD *)(v3 + 40) = v90 + 1;
    *(_BYTE *)(v91 + v90) = v92;
    v86 = *(_QWORD *)(v3 + 56);
  }
  if ( *(_DWORD *)(v86 + 68) )
    *(_QWORD *)(a1 + 96) = sub_67E09C0(*(_QWORD *)(a1 + 96), *(_QWORD *)(v3 + 16), *(unsigned int *)(v3 + 40));
  *(_QWORD *)(v3 + 64) = 0LL;
  *(_DWORD *)(v3 + 8) = 69;
LABEL_84:
  v98 = *(_QWORD *)(v3 + 56);
  v99 = *(_QWORD *)(v98 + 24);
  if ( v99 )
  {
    v100 = *(unsigned __int16 *)(v98 + 32);
    v101 = *(_QWORD *)(v3 + 64);
    v102 = *(_QWORD *)(v3 + 40);
    v103 = *(_QWORD *)(v3 + 24);
    v104 = (unsigned int)(v100 - v101);
    if ( v102 + v104 > v103 )
    {
      while ( 1 )
      {
        v105 = v103 - v102;
        v106 = (unsigned int)(v103 - v102);
        memcpy((void *)(*(_QWORD *)(v3 + 16) + v102), (const void *)(v99 + v101), v106);
        v107 = *(_QWORD *)(v3 + 24);
        v108 = *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL);
        *(_QWORD *)(v3 + 40) = v107;
        if ( v108 && v107 > v102 )
          *(_QWORD *)(a1 + 96) = sub_67E09C0(
                                   *(_QWORD *)(a1 + 96),
                                   *(_QWORD *)(v3 + 16) + v102,
                                   (unsigned int)(v107 - v102));
        v109 = *(_QWORD *)(v3 + 64) + v106;
        v110 = *(_QWORD *)(a1 + 56);
        *(_QWORD *)(v3 + 64) = v109;
        sub_67E72B4(v110);
        v111 = *(_DWORD *)(v110 + 40);
        v112 = *(_DWORD *)(a1 + 32);
        if ( v112 >= v111 )
          v113 = v111;
        else
          v113 = v112;
        if ( (_DWORD)v113 )
        {
          memcpy(*(void **)(a1 + 24), *(const void **)(v110 + 32), v113);
          v114 = *(_QWORD *)(v110 + 32);
          v115 = *(_QWORD *)(v110 + 40);
          v116 = *(_DWORD *)(a1 + 32);
          v117 = *(_QWORD *)(a1 + 40) + v113;
          *(_QWORD *)(a1 + 24) += v113;
          *(_QWORD *)(a1 + 40) = v117;
          *(_DWORD *)(a1 + 32) = v116 - v113;
          *(_QWORD *)(v110 + 32) = v114 + v113;
          *(_QWORD *)(v110 + 40) = v115 - v113;
          if ( v115 == v113 )
            *(_QWORD *)(v110 + 32) = *(_QWORD *)(v110 + 16);
        }
        if ( *(_QWORD *)(v3 + 40) )
          goto LABEL_159;
        v103 = *(_QWORD *)(v3 + 24);
        v104 = (unsigned int)(v104 - v105);
        if ( v103 >= v104 )
        {
          v101 = *(_QWORD *)(v3 + 64);
          v102 = 0LL;
          v99 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 24LL);
          break;
        }
        v101 = *(_QWORD *)(v3 + 64);
        v102 = 0LL;
        v99 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 24LL);
      }
    }
    memcpy((void *)(*(_QWORD *)(v3 + 16) + v102), (const void *)(v99 + v101), v104);
    v118 = *(_QWORD *)(v3 + 40) + v104;
    v119 = *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL);
    *(_QWORD *)(v3 + 40) = v118;
    if ( v119 && v118 > v102 )
      *(_QWORD *)(a1 + 96) = sub_67E09C0(*(_QWORD *)(a1 + 96), *(_QWORD *)(v3 + 16) + v102, (unsigned int)(v118 - v102));
    *(_QWORD *)(v3 + 64) = 0LL;
  }
  *(_DWORD *)(v3 + 8) = 73;
LABEL_107:
  if ( *(_QWORD *)(*(_QWORD *)(v3 + 56) + 40LL) )
  {
    v120 = *(_QWORD *)(v3 + 40);
    v121 = v120;
    while ( 1 )
    {
      if ( v120 == *(_QWORD *)(v3 + 24) )
      {
        if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
          v122 = v120 > v121;
        else
          v122 = 0;
        if ( v122 )
          *(_QWORD *)(a1 + 96) = sub_67E09C0(
                                   *(_QWORD *)(a1 + 96),
                                   *(_QWORD *)(v3 + 16) + v121,
                                   (unsigned int)(v120 - v121));
        v123 = *(_QWORD *)(a1 + 56);
        sub_67E72B4(v123);
        v124 = *(_DWORD *)(v123 + 40);
        v125 = *(_DWORD *)(a1 + 32);
        if ( v125 >= v124 )
          v126 = v124;
        else
          v126 = v125;
        if ( (_DWORD)v126 )
        {
          memcpy(*(void **)(a1 + 24), *(const void **)(v123 + 32), v126);
          v127 = *(_QWORD *)(v123 + 32);
          v128 = *(_QWORD *)(v123 + 40);
          v129 = *(_DWORD *)(a1 + 32);
          v130 = *(_QWORD *)(a1 + 40) + v126;
          *(_QWORD *)(a1 + 24) += v126;
          *(_QWORD *)(a1 + 40) = v130;
          *(_DWORD *)(a1 + 32) = v129 - v126;
          *(_QWORD *)(v123 + 32) = v127 + v126;
          *(_QWORD *)(v123 + 40) = v128 - v126;
          if ( v128 == v126 )
            *(_QWORD *)(v123 + 32) = *(_QWORD *)(v123 + 16);
        }
        v121 = *(_QWORD *)(v3 + 40);
        if ( v121 )
          goto LABEL_159;
        v120 = 0LL;
      }
      v131 = *(_QWORD *)(v3 + 64);
      v132 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 40LL);
      *(_QWORD *)(v3 + 64) = v131 + 1;
      v133 = *(_QWORD *)(v3 + 16);
      LODWORD(v131) = *(unsigned __int8 *)(v132 + v131);
      *(_QWORD *)(v3 + 40) = v120 + 1;
      *(_BYTE *)(v133 + v120) = v131;
      if ( !(_DWORD)v131 )
        break;
      v120 = *(_QWORD *)(v3 + 40);
    }
    if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
    {
      v134 = *(_QWORD *)(v3 + 40);
      if ( v134 > v121 )
        *(_QWORD *)(a1 + 96) = sub_67E09C0(
                                 *(_QWORD *)(a1 + 96),
                                 *(_QWORD *)(v3 + 16) + v121,
                                 (unsigned int)(v134 - v121));
    }
    *(_QWORD *)(v3 + 64) = 0LL;
  }
  *(_DWORD *)(v3 + 8) = 91;
LABEL_131:
  if ( *(_QWORD *)(*(_QWORD *)(v3 + 56) + 56LL) )
  {
    v135 = *(_QWORD *)(v3 + 40);
    v136 = v135;
    while ( 1 )
    {
      if ( v135 == *(_QWORD *)(v3 + 24) )
      {
        if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
          v137 = v135 > v136;
        else
          v137 = 0;
        if ( v137 )
          *(_QWORD *)(a1 + 96) = sub_67E09C0(
                                   *(_QWORD *)(a1 + 96),
                                   *(_QWORD *)(v3 + 16) + v136,
                                   (unsigned int)(v135 - v136));
        v138 = *(_QWORD *)(a1 + 56);
        sub_67E72B4(v138);
        v139 = *(_DWORD *)(v138 + 40);
        v140 = *(_DWORD *)(a1 + 32);
        if ( v140 >= v139 )
          v141 = v139;
        else
          v141 = v140;
        if ( (_DWORD)v141 )
        {
          memcpy(*(void **)(a1 + 24), *(const void **)(v138 + 32), v141);
          v142 = *(_QWORD *)(v138 + 32);
          v143 = *(_QWORD *)(v138 + 40);
          v144 = *(_DWORD *)(a1 + 32);
          v145 = *(_QWORD *)(a1 + 40) + v141;
          *(_QWORD *)(a1 + 24) += v141;
          *(_QWORD *)(a1 + 40) = v145;
          *(_DWORD *)(a1 + 32) = v144 - v141;
          *(_QWORD *)(v138 + 32) = v142 + v141;
          *(_QWORD *)(v138 + 40) = v143 - v141;
          if ( v143 == v141 )
            *(_QWORD *)(v138 + 32) = *(_QWORD *)(v138 + 16);
        }
        v136 = *(_QWORD *)(v3 + 40);
        if ( v136 )
          goto LABEL_159;
        v135 = 0LL;
      }
      v146 = *(_QWORD *)(v3 + 64);
      v147 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 56LL);
      *(_QWORD *)(v3 + 64) = v146 + 1;
      v148 = *(_QWORD *)(v3 + 16);
      LODWORD(v146) = *(unsigned __int8 *)(v147 + v146);
      *(_QWORD *)(v3 + 40) = v135 + 1;
      *(_BYTE *)(v148 + v135) = v146;
      if ( !(_DWORD)v146 )
        break;
      v135 = *(_QWORD *)(v3 + 40);
    }
    if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
    {
      v149 = *(_QWORD *)(v3 + 40);
      if ( v149 > v136 )
        *(_QWORD *)(a1 + 96) = sub_67E09C0(
                                 *(_QWORD *)(a1 + 96),
                                 *(_QWORD *)(v3 + 16) + v136,
                                 (unsigned int)(v149 - v136));
    }
  }
  *(_DWORD *)(v3 + 8) = 103;
LABEL_154:
  if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
  {
    v150 = *(_QWORD *)(v3 + 40);
    if ( (unsigned __int64)(v150 + 2) > *(_QWORD *)(v3 + 24) )
    {
      sub_67E20AC(a1);
      v150 = *(_QWORD *)(v3 + 40);
      if ( v150 )
        goto LABEL_159;
    }
    v151 = *(_QWORD *)(a1 + 96);
    v152 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v150 + 1;
    *(_BYTE *)(v152 + v150) = v151;
    v153 = *(_QWORD *)(v3 + 40);
    v154 = *(_QWORD *)(v3 + 16);
    v155 = *(_QWORD *)(a1 + 96) >> 8;
    *(_QWORD *)(v3 + 40) = v153 + 1;
    *(_BYTE *)(v154 + v153) = v155;
    *(_QWORD *)(a1 + 96) = sub_67E09C0(0LL, 0LL, 0LL);
  }
  *(_DWORD *)(v3 + 8) = 113;
  sub_67E20AC(a1);
  if ( *(_QWORD *)(v3 + 40) )
  {
LABEL_159:
    result = 0LL;
    *(_DWORD *)(v3 + 76) = -1;
    return result;
  }
LABEL_160:
  if ( !*(_DWORD *)(a1 + 8) )
    goto LABEL_161;
LABEL_162:
  v156 = *(int *)(v3 + 196);
  if ( (_DWORD)v156 )
  {
    v157 = *(_DWORD *)(v3 + 200);
    if ( v157 == 3 )
    {
      v158 = sub_67E2AD0(v3, a2);
    }
    else if ( v157 == 2 )
    {
      v158 = sub_67E27D0(v3);
    }
    else
    {
      v158 = (*((__int64 (__fastcall **)(__int64, _QWORD))&unk_6C58378 + 2 * v156 + 1))(v3, a2);
    }
  }
  else
  {
    v158 = sub_67E2140(v3);
  }
  if ( (v158 & 0xFFFFFFFE) == 2 )
    *(_DWORD *)(v3 + 8) = 666;
  if ( (v158 & 0xFFFFFFFD) == 0 )
  {
    if ( *(_DWORD *)(a1 + 32) )
      return 0LL;
    goto LABEL_159;
  }
  if ( v158 == 1 )
  {
    if ( a2 != 5 )
    {
      if ( a2 == 1 )
      {
        sub_67E7344(v3);
      }
      else
      {
        sub_67E7138(v3, 0, 0LL);
        if ( a2 == 3 )
        {
          v159 = *(char **)(v3 + 120);
          v160 = 2LL * (unsigned int)(*(_DWORD *)(v3 + 132) - 1);
          *(_WORD *)&v159[v160] = 0;
          memset(v159, 0, v160);
          if ( !*(_DWORD *)(v3 + 180) )
          {
            *(_DWORD *)(v3 + 172) = 0;
            *(_QWORD *)(v3 + 152) = 0LL;
            *(_DWORD *)(v3 + 5932) = 0;
          }
        }
      }
    }
    sub_67E20AC(a1);
    if ( !*(_DWORD *)(a1 + 32) )
      goto LABEL_159;
  }
LABEL_185:
  if ( a2 != 4 )
    return 0LL;
  v161 = *(_DWORD *)(v3 + 48);
  if ( v161 < 1 )
    return 1LL;
  v162 = *(_QWORD *)(a1 + 96);
  if ( v161 == 2 )
  {
    v163 = *(_QWORD *)(v3 + 40);
    v164 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v163 + 1;
    *(_BYTE *)(v164 + v163) = v162;
    v165 = *(_QWORD *)(v3 + 40);
    v166 = *(_QWORD *)(v3 + 16);
    v167 = *(_QWORD *)(a1 + 96) >> 8;
    *(_QWORD *)(v3 + 40) = v165 + 1;
    *(_BYTE *)(v166 + v165) = v167;
    v168 = *(_QWORD *)(v3 + 40);
    v169 = *(_QWORD *)(v3 + 16);
    v170 = *(_QWORD *)(a1 + 96) >> 16;
    *(_QWORD *)(v3 + 40) = v168 + 1;
    *(_BYTE *)(v169 + v168) = v170;
    v171 = *(_QWORD *)(v3 + 40);
    v172 = *(_QWORD *)(v3 + 16);
    v173 = *(_QWORD *)(a1 + 96) >> 24;
    *(_QWORD *)(v3 + 40) = v171 + 1;
    *(_BYTE *)(v172 + v171) = v173;
    v174 = *(_QWORD *)(v3 + 40);
    v175 = *(_QWORD *)(a1 + 16);
    v176 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v174 + 1;
    *(_BYTE *)(v176 + v174) = v175;
    v177 = *(_QWORD *)(v3 + 40);
    v178 = *(_QWORD *)(v3 + 16);
    v179 = *(_QWORD *)(a1 + 16) >> 8;
    *(_QWORD *)(v3 + 40) = v177 + 1;
    *(_BYTE *)(v178 + v177) = v179;
    v180 = *(_QWORD *)(v3 + 40);
    v181 = *(_QWORD *)(v3 + 16);
    v182 = *(_QWORD *)(a1 + 16) >> 16;
    *(_QWORD *)(v3 + 40) = v180 + 1;
    *(_BYTE *)(v181 + v180) = v182;
    v183 = *(_QWORD *)(v3 + 40);
    v184 = *(_QWORD *)(v3 + 16);
    v185 = v183 + 1;
    v186 = *(_QWORD *)(a1 + 16) >> 24;
  }
  else
  {
    v187 = *(_QWORD *)(v3 + 40);
    v188 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v187 + 1;
    *(_BYTE *)(v188 + v187) = BYTE3(v162);
    v189 = *(_QWORD *)(v3 + 40);
    v190 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v189 + 1;
    *(_BYTE *)(v190 + v189) = BYTE2(v162);
    v191 = *(_QWORD *)(v3 + 40);
    v186 = *(_QWORD *)(a1 + 96);
    v192 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v191 + 1;
    *(_BYTE *)(v192 + v191) = BYTE1(v186);
    v183 = *(_QWORD *)(v3 + 40);
    v184 = *(_QWORD *)(v3 + 16);
    v185 = v183 + 1;
  }
  *(_QWORD *)(v3 + 40) = v185;
  *(_BYTE *)(v184 + v183) = v186;
  sub_67E20AC(a1);
  v193 = *(_DWORD *)(v3 + 48);
  if ( v193 >= 1 )
    *(_DWORD *)(v3 + 48) = -v193;
  return *(_QWORD *)(v3 + 40) == 0LL;
}


================================================================================
Function: sub_67E20AC (0x67E20AC)
================================================================================

void *__fastcall sub_67E20AC(__int64 a1)
{
  __int64 v1; // x19
  void *result; // x0
  unsigned int v4; // w8
  unsigned int v5; // w9
  size_t v6; // x21
  __int64 v7; // x11
  __int64 v8; // x12
  int v9; // w10
  size_t v10; // x9

  v1 = *(_QWORD *)(a1 + 56);
  result = (void *)sub_67E72B4(v1);
  v4 = *(_DWORD *)(v1 + 40);
  v5 = *(_DWORD *)(a1 + 32);
  if ( v5 >= v4 )
    v6 = v4;
  else
    v6 = v5;
  if ( (_DWORD)v6 )
  {
    result = memcpy(*(void **)(a1 + 24), *(const void **)(v1 + 32), v6);
    v7 = *(_QWORD *)(v1 + 32);
    v8 = *(_QWORD *)(v1 + 40);
    v9 = *(_DWORD *)(a1 + 32);
    v10 = *(_QWORD *)(a1 + 40) + v6;
    *(_QWORD *)(a1 + 24) += v6;
    *(_QWORD *)(a1 + 40) = v10;
    *(_DWORD *)(a1 + 32) = v9 - v6;
    *(_QWORD *)(v1 + 32) = v7 + v6;
    *(_QWORD *)(v1 + 40) = v8 - v6;
    if ( v8 == v6 )
      *(_QWORD *)(v1 + 32) = *(_QWORD *)(v1 + 16);
  }
  return result;
}


================================================================================
Function: sub_67E2140 (0x67E2140)
================================================================================

__int64 __fastcall sub_67E2140(_QWORD *a1, int a2)
{
  __int64 v4; // x8
  unsigned int v5; // w26
  unsigned __int64 v6; // x0
  size_t v7; // x9
  __int64 v8; // x28
  unsigned __int8 *v9; // x23
  unsigned int v10; // w8
  __int64 v11; // x9
  unsigned int v12; // w10
  unsigned int v13; // w9
  bool v14; // cf
  unsigned int v15; // w10
  __int64 v16; // x12
  __int64 v17; // x28
  int v18; // w9
  unsigned int v19; // w11
  unsigned int v20; // w27
  _BOOL4 v22; // w21
  __int64 v23; // x24
  __int64 v24; // x22
  unsigned int v25; // w8
  unsigned int v26; // w9
  size_t v27; // x23
  __int64 v28; // x11
  __int64 v29; // x12
  int v30; // w10
  size_t v31; // x9
  size_t v32; // x22
  __int64 v33; // x8
  __int64 v34; // x11
  size_t v35; // x9
  int v36; // w10
  unsigned int v37; // w8
  size_t v38; // x22
  const void *v39; // x1
  void *v40; // x0
  int v41; // w8
  int v42; // w22
  int v43; // w9
  size_t v44; // x21
  size_t v45; // x2
  __int64 v46; // x8
  char *v47; // x0
  char *v48; // x1
  size_t v49; // x2
  unsigned int v50; // w8
  unsigned int v51; // w9
  unsigned int v52; // w8
  unsigned __int64 v53; // x10
  void *v54; // x0
  const void *v55; // x1
  int v56; // w11
  unsigned int v57; // w9
  __int64 v58; // x23
  unsigned int v59; // w9
  __int64 result; // x0
  size_t v61; // x21
  __int64 v62; // x11
  __int64 v63; // x10
  bool v64; // cc
  __int64 v65; // x11
  char *v66; // x0
  size_t v67; // x2
  unsigned int v68; // w8
  __int64 v69; // x8
  __int64 v70; // x10
  const void *v71; // x1
  unsigned __int8 *v72; // x22
  int v73; // w8
  unsigned __int64 v74; // x0
  unsigned int v75; // w8
  size_t v76; // x9
  unsigned int v77; // w10
  unsigned __int64 v78; // x9
  __int64 v79; // x8
  unsigned int v80; // w10
  unsigned int v81; // w11
  size_t v82; // x21
  _BOOL4 v83; // w20
  __int64 v84; // x22
  size_t v85; // x8
  __int64 v86; // x21
  unsigned int v87; // w8
  unsigned int v88; // w9
  size_t v89; // x19
  __int64 v90; // x11
  __int64 v91; // x12
  int v92; // w10
  size_t v93; // x9
  int v94; // [xsp+Ch] [xbp-4h]

  v4 = *a1;
  if ( a1[3] - 5LL <= (unsigned __int64)*((unsigned int *)a1 + 20) )
    v5 = *((_DWORD *)a1 + 6) - 5;
  else
    v5 = *((_DWORD *)a1 + 20);
  v94 = *(_DWORD *)(v4 + 8);
  do
  {
    v12 = *(_DWORD *)(v4 + 32);
    v13 = (*((_DWORD *)a1 + 1485) + 42) >> 3;
    v14 = v12 >= v13;
    v15 = v12 - v13;
    if ( !v14 )
    {
      v42 = 1;
      goto LABEL_46;
    }
    v16 = *(unsigned int *)(v4 + 8);
    v17 = (unsigned int)(*((_DWORD *)a1 + 43) - *((_DWORD *)a1 + 38));
    v18 = v17 + v16;
    if ( (unsigned __int64)(v17 + v16) >= 0xFFFF )
      v19 = 0xFFFF;
    else
      v19 = v17 + v16;
    if ( v19 <= v15 )
      v20 = v19;
    else
      v20 = v15;
    if ( v20 < v5 )
    {
      v42 = 1;
      if ( !a2 )
        goto LABEL_46;
      if ( a2 != 4 && v20 == 0 || v20 != v18 )
        goto LABEL_46;
    }
    v22 = a2 == 4 && v20 == v18;
    sub_67E7138((int)a1, 0, 0LL);
    *(_WORD *)(a1[5] + a1[2] - 4LL) = v20;
    *(_WORD *)(a1[5] + a1[2] - 2LL) = ~(_WORD)v20;
    v23 = *a1;
    v24 = *(_QWORD *)(*a1 + 56LL);
    sub_67E72B4(v24);
    v25 = *(_DWORD *)(v24 + 40);
    v26 = *(_DWORD *)(v23 + 32);
    if ( v26 >= v25 )
      v27 = v25;
    else
      v27 = v26;
    if ( !(_DWORD)v27 )
      goto LABEL_30;
    memcpy(*(void **)(v23 + 24), *(const void **)(v24 + 32), v27);
    v28 = *(_QWORD *)(v24 + 32);
    v29 = *(_QWORD *)(v24 + 40);
    v30 = *(_DWORD *)(v23 + 32);
    v31 = *(_QWORD *)(v23 + 40) + v27;
    *(_QWORD *)(v23 + 24) += v27;
    *(_QWORD *)(v23 + 40) = v31;
    *(_DWORD *)(v23 + 32) = v30 - v27;
    *(_QWORD *)(v24 + 32) = v28 + v27;
    *(_QWORD *)(v24 + 40) = v29 - v27;
    if ( v29 == v27 )
    {
      *(_QWORD *)(v24 + 32) = *(_QWORD *)(v24 + 16);
      if ( !(_DWORD)v17 )
        goto LABEL_35;
    }
    else
    {
LABEL_30:
      if ( !(_DWORD)v17 )
        goto LABEL_35;
    }
    if ( (unsigned int)v17 <= v20 )
      v32 = (unsigned int)v17;
    else
      v32 = v20;
    memcpy(*(void **)(*a1 + 24LL), (const void *)(a1[12] + a1[19]), v32);
    v33 = *a1;
    v20 -= v32;
    v34 = *(_QWORD *)(*a1 + 40LL);
    v35 = *(_QWORD *)(*a1 + 24LL) + v32;
    v36 = *(_DWORD *)(*a1 + 32LL) - v32;
    a1[19] += v32;
    *(_QWORD *)(v33 + 24) = v35;
    *(_DWORD *)(v33 + 32) = v36;
    *(_QWORD *)(v33 + 40) = v34 + v32;
LABEL_35:
    if ( v20 )
    {
      v8 = *a1;
      v37 = *(_DWORD *)(*a1 + 8LL);
      v9 = *(unsigned __int8 **)(*a1 + 24LL);
      if ( v37 <= v20 )
        v38 = v37;
      else
        v38 = v20;
      if ( (_DWORD)v38 )
      {
        v39 = *(const void **)v8;
        v40 = *(void **)(*a1 + 24LL);
        *(_DWORD *)(v8 + 8) = v37 - v38;
        memcpy(v40, v39, v38);
        v41 = *(_DWORD *)(*(_QWORD *)(v8 + 56) + 48LL);
        if ( v41 == 2 )
        {
          v6 = sub_67E09C0(*(_QWORD *)(v8 + 96), v9, v38);
          goto LABEL_6;
        }
        if ( v41 == 1 )
        {
          v6 = sub_67E05A0(*(_QWORD *)(v8 + 96), v9, (unsigned int)v38);
LABEL_6:
          *(_QWORD *)(v8 + 96) = v6;
        }
        v7 = *(_QWORD *)(v8 + 16) + v38;
        *(_QWORD *)v8 += v38;
        *(_QWORD *)(v8 + 16) = v7;
        v8 = *a1;
        v9 = *(unsigned __int8 **)(*a1 + 24LL);
      }
      v10 = *(_DWORD *)(v8 + 32) - v20;
      v11 = *(_QWORD *)(v8 + 40) + v20;
      *(_QWORD *)(v8 + 24) = &v9[v20];
      *(_DWORD *)(v8 + 32) = v10;
      *(_QWORD *)(v8 + 40) = v11;
    }
    v4 = *a1;
  }
  while ( !v22 );
  v42 = 0;
LABEL_46:
  v43 = *(_DWORD *)(v4 + 8);
  v44 = (unsigned int)(v94 - v43);
  if ( v94 == v43 )
  {
    v53 = *((unsigned int *)a1 + 43);
    v52 = *((_DWORD *)a1 + 43);
  }
  else
  {
    v45 = *((unsigned int *)a1 + 20);
    if ( (unsigned int)v44 >= (unsigned int)v45 )
    {
      v54 = (void *)a1[12];
      v55 = (const void *)(*(_QWORD *)v4 - v45);
      *((_DWORD *)a1 + 1482) = 2;
      memcpy(v54, v55, v45);
      v51 = *((_DWORD *)a1 + 20);
      v52 = v51;
      *((_DWORD *)a1 + 43) = v51;
    }
    else
    {
      v46 = *((unsigned int *)a1 + 43);
      if ( a1[13] - v46 <= v44 )
      {
        v47 = (char *)a1[12];
        v48 = &v47[v45];
        v49 = (unsigned int)(v46 - v45);
        *((_DWORD *)a1 + 43) = v49;
        memcpy(v47, v48, v49);
        v50 = *((_DWORD *)a1 + 1482);
        if ( v50 <= 1 )
          *((_DWORD *)a1 + 1482) = v50 + 1;
      }
      memcpy((void *)(a1[12] + *((unsigned int *)a1 + 43)), (const void *)(*(_QWORD *)*a1 - v44), v44);
      v51 = *((_DWORD *)a1 + 20);
      v52 = *((_DWORD *)a1 + 43) + v44;
      *((_DWORD *)a1 + 43) = v52;
    }
    v56 = *((_DWORD *)a1 + 1483);
    v53 = v52;
    v57 = v51 - v56;
    a1[19] = v52;
    if ( (unsigned int)v44 <= v57 )
      v57 = v44;
    *((_DWORD *)a1 + 1483) = v57 + v56;
  }
  if ( a1[743] < v53 )
    a1[743] = v53;
  if ( !v42 )
    return 3LL;
  v58 = *a1;
  v59 = *(_DWORD *)(*a1 + 8LL);
  if ( (a2 & 0xFFFFFFFB) == 0 || v59 )
  {
    LODWORD(v61) = *((_DWORD *)a1 + 26) + ~(_DWORD)v53;
    if ( v59 > (unsigned int)v61 )
    {
      v62 = a1[19];
      v63 = *((unsigned int *)a1 + 20);
      v64 = v62 < v63;
      v65 = v62 - v63;
      if ( !v64 )
      {
        v66 = (char *)a1[12];
        v67 = v52 - (unsigned int)v63;
        a1[19] = v65;
        *((_DWORD *)a1 + 43) = v67;
        memcpy(v66, &v66[v63], v67);
        v68 = *((_DWORD *)a1 + 1482);
        if ( v68 <= 1 )
          *((_DWORD *)a1 + 1482) = v68 + 1;
        v58 = *a1;
        LODWORD(v61) = *((_DWORD *)a1 + 20) + v61;
        v59 = *(_DWORD *)(*a1 + 8LL);
      }
    }
  }
  else
  {
    if ( a1[19] == v53 )
      return 1LL;
    v59 = 0;
    LODWORD(v61) = *((_DWORD *)a1 + 26) + ~(_DWORD)v53;
  }
  if ( (unsigned int)v61 <= v59 )
    v61 = (unsigned int)v61;
  else
    v61 = v59;
  if ( (_DWORD)v61 )
  {
    v69 = a1[12];
    v70 = *((unsigned int *)a1 + 43);
    v71 = *(const void **)v58;
    *(_DWORD *)(v58 + 8) = v59 - v61;
    v72 = (unsigned __int8 *)(v69 + v70);
    memcpy((void *)(v69 + v70), v71, v61);
    v73 = *(_DWORD *)(*(_QWORD *)(v58 + 56) + 48LL);
    if ( v73 == 2 )
    {
      v74 = sub_67E09C0(*(_QWORD *)(v58 + 96), v72, v61);
LABEL_80:
      *(_QWORD *)(v58 + 96) = v74;
    }
    else if ( v73 == 1 )
    {
      v74 = sub_67E05A0(*(_QWORD *)(v58 + 96), v72, (unsigned int)v61);
      goto LABEL_80;
    }
    v76 = *(_QWORD *)(v58 + 16) + v61;
    v75 = *((_DWORD *)a1 + 43) + v61;
    *(_QWORD *)v58 += v61;
    *(_QWORD *)(v58 + 16) = v76;
    *((_DWORD *)a1 + 43) = v75;
  }
  else
  {
    v75 = *((_DWORD *)a1 + 43);
  }
  v77 = v75;
  if ( a1[743] < (unsigned __int64)v75 )
    a1[743] = v75;
  v78 = a1[3] - (unsigned int)((*((_DWORD *)a1 + 1485) + 42) >> 3);
  v79 = a1[19];
  if ( v78 >= 0xFFFF )
    LODWORD(v78) = 0xFFFF;
  v80 = v77 - v79;
  if ( *((_DWORD *)a1 + 20) >= (unsigned int)v78 )
    v81 = v78;
  else
    v81 = *((_DWORD *)a1 + 20);
  if ( v80 >= v81
    || (result = 0LL, a2)
    && (a2 == 4 || v80 != 0)
    && (result = 0LL, !*(_DWORD *)(*a1 + 8LL))
    && v80 <= (unsigned int)v78 )
  {
    if ( v80 <= (unsigned int)v78 )
      v82 = v80;
    else
      v82 = (unsigned int)v78;
    v83 = a2 == 4 && *(_DWORD *)(*a1 + 8LL) == 0 && v80 <= (unsigned int)v78;
    sub_67E7138((int)a1, a1[12] + v79, v82);
    v84 = *a1;
    v85 = a1[19] + v82;
    v86 = *(_QWORD *)(*a1 + 56LL);
    a1[19] = v85;
    sub_67E72B4(v86);
    v87 = *(_DWORD *)(v86 + 40);
    v88 = *(_DWORD *)(v84 + 32);
    if ( v88 >= v87 )
      v89 = v87;
    else
      v89 = v88;
    if ( (_DWORD)v89 )
    {
      memcpy(*(void **)(v84 + 24), *(const void **)(v86 + 32), v89);
      v90 = *(_QWORD *)(v86 + 32);
      v91 = *(_QWORD *)(v86 + 40);
      v92 = *(_DWORD *)(v84 + 32);
      v93 = *(_QWORD *)(v84 + 40) + v89;
      *(_QWORD *)(v84 + 24) += v89;
      *(_QWORD *)(v84 + 40) = v93;
      *(_DWORD *)(v84 + 32) = v92 - v89;
      *(_QWORD *)(v86 + 32) = v90 + v89;
      *(_QWORD *)(v86 + 40) = v91 - v89;
      if ( v91 == v89 )
        *(_QWORD *)(v86 + 32) = *(_QWORD *)(v86 + 16);
    }
    if ( v83 )
      return 2LL;
    else
      return 0LL;
  }
  return result;
}


================================================================================
Function: sub_67E27D0 (0x67E27D0)
================================================================================

__int64 __fastcall sub_67E27D0(__int64 *a1, int a2)
{
  __int64 v4; // x9
  __int64 v5; // x10
  __int64 v6; // x8
  __int64 v7; // x12
  __int64 v8; // x9
  int v9; // w14
  __int64 v10; // x8
  int v11; // w11
  __int64 v12; // x9
  __int64 v13; // x1
  __int64 v14; // x23
  __int64 v15; // x21
  unsigned int v16; // w8
  unsigned int v17; // w9
  size_t v18; // x22
  __int64 v19; // x11
  __int64 v20; // x12
  int v21; // w10
  size_t v22; // x9
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 v25; // x8
  __int64 v26; // x1
  __int64 v27; // x22
  __int64 v28; // x20
  unsigned int v29; // w8
  unsigned int v30; // w9
  size_t v31; // x21
  __int64 v32; // x11
  __int64 v33; // x12
  int v34; // w10
  size_t v35; // x9
  __int64 v37; // x22
  __int64 v38; // x20
  unsigned int v39; // w8
  unsigned int v40; // w9
  size_t v41; // x21
  __int64 v42; // x11
  __int64 v43; // x12
  int v44; // w10
  size_t v45; // x9

  while ( 1 )
  {
    if ( !*((_DWORD *)a1 + 45) )
    {
      sub_67E0E30(a1);
      if ( !*((_DWORD *)a1 + 45) )
        break;
    }
    v4 = *((unsigned int *)a1 + 43);
    *((_DWORD *)a1 + 40) = 0;
    v5 = *((unsigned int *)a1 + 1475);
    v6 = *(unsigned __int8 *)(a1[12] + v4);
    v7 = a1[736];
    *(_WORD *)(a1[738] + 2 * v5) = 0;
    v8 = (__int64)a1 + 4 * v6;
    *((_DWORD *)a1 + 1475) = v5 + 1;
    *(_BYTE *)(v7 + v5) = v6;
    v9 = *((_DWORD *)a1 + 1475);
    LOWORD(v5) = *(_WORD *)(v8 + 212) + 1;
    v10 = (unsigned int)(*((_DWORD *)a1 + 43) + 1);
    v11 = *((_DWORD *)a1 + 1474) - 1;
    --*((_DWORD *)a1 + 45);
    *(_WORD *)(v8 + 212) = v5;
    *((_DWORD *)a1 + 43) = v10;
    if ( v9 == v11 )
    {
      v12 = a1[19];
      if ( v12 < 0 )
        LODWORD(v13) = 0;
      else
        v13 = a1[12] + (unsigned int)v12;
      sub_67E7498((int)a1, v13, v10 - v12);
      v14 = *a1;
      v15 = *(_QWORD *)(*a1 + 56);
      a1[19] = *((unsigned int *)a1 + 43);
      sub_67E72B4(v15);
      v16 = *(_DWORD *)(v15 + 40);
      v17 = *(_DWORD *)(v14 + 32);
      v18 = v17 >= v16 ? v16 : v17;
      if ( (_DWORD)v18 )
      {
        memcpy(*(void **)(v14 + 24), *(const void **)(v15 + 32), v18);
        v19 = *(_QWORD *)(v15 + 32);
        v20 = *(_QWORD *)(v15 + 40);
        v21 = *(_DWORD *)(v14 + 32);
        v22 = *(_QWORD *)(v14 + 40) + v18;
        *(_QWORD *)(v14 + 24) += v18;
        *(_QWORD *)(v14 + 40) = v22;
        *(_DWORD *)(v14 + 32) = v21 - v18;
        *(_QWORD *)(v15 + 32) = v19 + v18;
        *(_QWORD *)(v15 + 40) = v20 - v18;
        if ( v20 == v18 )
          *(_QWORD *)(v15 + 32) = *(_QWORD *)(v15 + 16);
      }
      if ( !*(_DWORD *)(*a1 + 32) )
        return 0LL;
    }
  }
  if ( !a2 )
    return 0LL;
  *((_DWORD *)a1 + 1483) = 0;
  if ( a2 != 4 )
  {
    if ( !*((_DWORD *)a1 + 1475) )
      return 1LL;
    v25 = a1[19];
    if ( v25 < 0 )
      LODWORD(v26) = 0;
    else
      v26 = a1[12] + (unsigned int)v25;
    sub_67E7498((int)a1, v26, *((unsigned int *)a1 + 43) - v25);
    v37 = *a1;
    v38 = *(_QWORD *)(*a1 + 56);
    a1[19] = *((unsigned int *)a1 + 43);
    sub_67E72B4(v38);
    v39 = *(_DWORD *)(v38 + 40);
    v40 = *(_DWORD *)(v37 + 32);
    if ( v40 >= v39 )
      v41 = v39;
    else
      v41 = v40;
    if ( (_DWORD)v41 )
    {
      memcpy(*(void **)(v37 + 24), *(const void **)(v38 + 32), v41);
      v42 = *(_QWORD *)(v38 + 32);
      v43 = *(_QWORD *)(v38 + 40);
      v44 = *(_DWORD *)(v37 + 32);
      v45 = *(_QWORD *)(v37 + 40) + v41;
      *(_QWORD *)(v37 + 24) += v41;
      *(_QWORD *)(v37 + 40) = v45;
      *(_DWORD *)(v37 + 32) = v44 - v41;
      *(_QWORD *)(v38 + 32) = v42 + v41;
      *(_QWORD *)(v38 + 40) = v43 - v41;
      if ( v43 == v41 )
        *(_QWORD *)(v38 + 32) = *(_QWORD *)(v38 + 16);
    }
    return *(_DWORD *)(*a1 + 32) != 0;
  }
  v23 = a1[19];
  if ( v23 < 0 )
    LODWORD(v24) = 0;
  else
    v24 = a1[12] + (unsigned int)v23;
  sub_67E7498((int)a1, v24, *((unsigned int *)a1 + 43) - v23);
  v27 = *a1;
  v28 = *(_QWORD *)(*a1 + 56);
  a1[19] = *((unsigned int *)a1 + 43);
  sub_67E72B4(v28);
  v29 = *(_DWORD *)(v28 + 40);
  v30 = *(_DWORD *)(v27 + 32);
  if ( v30 >= v29 )
    v31 = v29;
  else
    v31 = v30;
  if ( (_DWORD)v31 )
  {
    memcpy(*(void **)(v27 + 24), *(const void **)(v28 + 32), v31);
    v32 = *(_QWORD *)(v28 + 32);
    v33 = *(_QWORD *)(v28 + 40);
    v34 = *(_DWORD *)(v27 + 32);
    v35 = *(_QWORD *)(v27 + 40) + v31;
    *(_QWORD *)(v27 + 24) += v31;
    *(_QWORD *)(v27 + 40) = v35;
    *(_DWORD *)(v27 + 32) = v34 - v31;
    *(_QWORD *)(v28 + 32) = v32 + v31;
    *(_QWORD *)(v28 + 40) = v33 - v31;
    if ( v33 == v31 )
      *(_QWORD *)(v28 + 32) = *(_QWORD *)(v28 + 16);
  }
  if ( *(_DWORD *)(*a1 + 32) )
    return 3LL;
  else
    return 2LL;
}


================================================================================
Function: sub_67E2AD0 (0x67E2AD0)
================================================================================

__int64 __fastcall sub_67E2AD0(__int64 *a1, int a2)
{
  unsigned int v4; // w8
  __int64 v5; // x9
  unsigned __int8 *v6; // x11
  int v7; // w12
  __int64 v8; // x13
  int v9; // w10
  unsigned __int8 *v10; // x14
  unsigned __int8 *v11; // x14
  unsigned __int8 *v12; // x14
  unsigned __int8 *v13; // x14
  int v14; // w15
  int v15; // w14
  unsigned __int64 v16; // x15
  int v17; // w11
  unsigned int v18; // w10
  __int64 v19; // x9
  __int64 v20; // x14
  __int64 v21; // x11
  __int16 v22; // w8
  __int64 v23; // x9
  int v24; // w12
  int v25; // w13
  int v26; // w10
  int v27; // w12
  unsigned int v28; // w8
  __int64 v29; // x10
  __int64 v30; // x8
  __int64 v31; // x12
  __int64 v32; // x9
  int v33; // w14
  int v34; // w11
  __int64 v35; // x9
  __int64 v36; // x1
  __int64 v37; // x26
  __int64 v38; // x21
  unsigned int v39; // w8
  unsigned int v40; // w9
  size_t v41; // x22
  __int64 v42; // x11
  __int64 v43; // x12
  int v44; // w10
  size_t v45; // x9
  __int64 v46; // x8
  __int64 v47; // x1
  __int64 v48; // x8
  __int64 v49; // x1
  __int64 v50; // x22
  __int64 v51; // x20
  unsigned int v52; // w8
  unsigned int v53; // w9
  size_t v54; // x21
  __int64 v55; // x11
  __int64 v56; // x12
  int v57; // w10
  size_t v58; // x9
  __int64 v60; // x22
  __int64 v61; // x20
  unsigned int v62; // w8
  unsigned int v63; // w9
  size_t v64; // x21
  __int64 v65; // x11
  __int64 v66; // x12
  int v67; // w10
  size_t v68; // x9

  while ( 1 )
  {
    while ( 1 )
    {
      v4 = *((_DWORD *)a1 + 45);
      if ( v4 < 0x103 )
        break;
      *((_DWORD *)a1 + 40) = 0;
LABEL_10:
      v5 = *((unsigned int *)a1 + 43);
      if ( !(_DWORD)v5 )
        goto LABEL_37;
      v6 = (unsigned __int8 *)(a1[12] + v5);
      v7 = *(v6 - 1);
      if ( v7 != *v6 || v7 != v6[1] || v7 != v6[2] )
        goto LABEL_37;
      v8 = 0LL;
      v9 = (_DWORD)v6 + 258;
      while ( 1 )
      {
        v10 = &v6[v8];
        if ( v7 != v6[v8 + 3] )
        {
          v17 = (_DWORD)v10 + 3;
          goto LABEL_32;
        }
        if ( v7 != v10[4] )
        {
          v17 = (_DWORD)v6 + v8 + 4;
          goto LABEL_32;
        }
        v11 = &v6[v8];
        if ( v7 != v6[v8 + 5] )
        {
          v17 = (_DWORD)v11 + 5;
          goto LABEL_32;
        }
        if ( v7 != v11[6] )
        {
          v17 = (_DWORD)v6 + v8 + 6;
          goto LABEL_32;
        }
        v12 = &v6[v8];
        if ( v7 != v6[v8 + 7] )
        {
          v17 = (_DWORD)v12 + 7;
          goto LABEL_32;
        }
        if ( v7 != v12[8] )
        {
          v17 = (_DWORD)v6 + v8 + 8;
          goto LABEL_32;
        }
        v13 = &v6[v8];
        if ( v7 != v6[v8 + 9] )
          break;
        v14 = v13[10];
        v15 = v8 + 8;
        if ( v7 == v14 )
        {
          v16 = v8 + 2;
          v8 += 8LL;
          if ( v16 < 0xFA )
            continue;
        }
        v17 = (_DWORD)v6 + v15 + 2;
        goto LABEL_32;
      }
      v17 = (_DWORD)v13 + 9;
LABEL_32:
      v18 = v17 - v9 + 258;
      if ( v18 > v4 )
        v18 = v4;
      *((_DWORD *)a1 + 40) = v18;
      if ( v18 < 3 )
        goto LABEL_37;
      v19 = *((unsigned int *)a1 + 1475);
      v20 = a1[736];
      *(_WORD *)(a1[738] + 2 * v19) = 1;
      v21 = byte_17448CE[(unsigned __int8)(v18 - 3)];
      *((_DWORD *)a1 + 1475) = v19 + 1;
      *(_BYTE *)(v20 + v19) = v18 - 3;
      v22 = *((_WORD *)a1 + 1252);
      v23 = (__int64)a1 + 4 * v21;
      LODWORD(v21) = *((_DWORD *)a1 + 40);
      v24 = *((_DWORD *)a1 + 45);
      *((_DWORD *)a1 + 40) = 0;
      v25 = *((_DWORD *)a1 + 43);
      LOWORD(v20) = *(_WORD *)(v23 + 1240);
      *((_WORD *)a1 + 1252) = v22 + 1;
      v26 = v24 - v21;
      v27 = *((_DWORD *)a1 + 1474);
      v28 = v25 + v21;
      LODWORD(v21) = *((_DWORD *)a1 + 1475);
      *((_DWORD *)a1 + 45) = v26;
      *((_DWORD *)a1 + 43) = v28;
      *(_WORD *)(v23 + 1240) = v20 + 1;
      if ( (_DWORD)v21 == v27 - 1 )
        goto LABEL_38;
    }
    sub_67E0E30(a1);
    v4 = *((_DWORD *)a1 + 45);
    if ( !a2 && v4 < 0x103 )
      return 0LL;
    if ( !v4 )
      break;
    *((_DWORD *)a1 + 40) = 0;
    if ( v4 > 2 )
      goto LABEL_10;
    LODWORD(v5) = *((_DWORD *)a1 + 43);
LABEL_37:
    v29 = *((unsigned int *)a1 + 1475);
    v30 = *(unsigned __int8 *)(a1[12] + (unsigned int)v5);
    v31 = a1[736];
    *(_WORD *)(a1[738] + 2 * v29) = 0;
    v32 = (__int64)a1 + 4 * v30;
    *((_DWORD *)a1 + 1475) = v29 + 1;
    *(_BYTE *)(v31 + v29) = v30;
    v33 = *((_DWORD *)a1 + 1475);
    LOWORD(v29) = *(_WORD *)(v32 + 212) + 1;
    v28 = *((_DWORD *)a1 + 43) + 1;
    v34 = *((_DWORD *)a1 + 1474) - 1;
    --*((_DWORD *)a1 + 45);
    *(_WORD *)(v32 + 212) = v29;
    *((_DWORD *)a1 + 43) = v28;
    if ( v33 == v34 )
    {
LABEL_38:
      v35 = a1[19];
      if ( v35 < 0 )
        LODWORD(v36) = 0;
      else
        v36 = a1[12] + (unsigned int)v35;
      sub_67E7498((int)a1, v36, v28 - v35);
      v37 = *a1;
      v38 = *(_QWORD *)(*a1 + 56);
      a1[19] = *((unsigned int *)a1 + 43);
      sub_67E72B4(v38);
      v39 = *(_DWORD *)(v38 + 40);
      v40 = *(_DWORD *)(v37 + 32);
      if ( v40 >= v39 )
        v41 = v39;
      else
        v41 = v40;
      if ( (_DWORD)v41 )
      {
        memcpy(*(void **)(v37 + 24), *(const void **)(v38 + 32), v41);
        v42 = *(_QWORD *)(v38 + 32);
        v43 = *(_QWORD *)(v38 + 40);
        v44 = *(_DWORD *)(v37 + 32);
        v45 = *(_QWORD *)(v37 + 40) + v41;
        *(_QWORD *)(v37 + 24) += v41;
        *(_QWORD *)(v37 + 40) = v45;
        *(_DWORD *)(v37 + 32) = v44 - v41;
        *(_QWORD *)(v38 + 32) = v42 + v41;
        *(_QWORD *)(v38 + 40) = v43 - v41;
        if ( v43 == v41 )
          *(_QWORD *)(v38 + 32) = *(_QWORD *)(v38 + 16);
      }
      if ( !*(_DWORD *)(*a1 + 32) )
        return 0LL;
    }
  }
  *((_DWORD *)a1 + 1483) = 0;
  if ( a2 != 4 )
  {
    if ( !*((_DWORD *)a1 + 1475) )
      return 1LL;
    v48 = a1[19];
    if ( v48 < 0 )
      LODWORD(v49) = 0;
    else
      v49 = a1[12] + (unsigned int)v48;
    sub_67E7498((int)a1, v49, *((unsigned int *)a1 + 43) - v48);
    v60 = *a1;
    v61 = *(_QWORD *)(*a1 + 56);
    a1[19] = *((unsigned int *)a1 + 43);
    sub_67E72B4(v61);
    v62 = *(_DWORD *)(v61 + 40);
    v63 = *(_DWORD *)(v60 + 32);
    if ( v63 >= v62 )
      v64 = v62;
    else
      v64 = v63;
    if ( (_DWORD)v64 )
    {
      memcpy(*(void **)(v60 + 24), *(const void **)(v61 + 32), v64);
      v65 = *(_QWORD *)(v61 + 32);
      v66 = *(_QWORD *)(v61 + 40);
      v67 = *(_DWORD *)(v60 + 32);
      v68 = *(_QWORD *)(v60 + 40) + v64;
      *(_QWORD *)(v60 + 24) += v64;
      *(_QWORD *)(v60 + 40) = v68;
      *(_DWORD *)(v60 + 32) = v67 - v64;
      *(_QWORD *)(v61 + 32) = v65 + v64;
      *(_QWORD *)(v61 + 40) = v66 - v64;
      if ( v66 == v64 )
        *(_QWORD *)(v61 + 32) = *(_QWORD *)(v61 + 16);
    }
    return *(_DWORD *)(*a1 + 32) != 0;
  }
  v46 = a1[19];
  if ( v46 < 0 )
    LODWORD(v47) = 0;
  else
    v47 = a1[12] + (unsigned int)v46;
  sub_67E7498((int)a1, v47, *((unsigned int *)a1 + 43) - v46);
  v50 = *a1;
  v51 = *(_QWORD *)(*a1 + 56);
  a1[19] = *((unsigned int *)a1 + 43);
  sub_67E72B4(v51);
  v52 = *(_DWORD *)(v51 + 40);
  v53 = *(_DWORD *)(v50 + 32);
  if ( v53 >= v52 )
    v54 = v52;
  else
    v54 = v53;
  if ( (_DWORD)v54 )
  {
    memcpy(*(void **)(v50 + 24), *(const void **)(v51 + 32), v54);
    v55 = *(_QWORD *)(v51 + 32);
    v56 = *(_QWORD *)(v51 + 40);
    v57 = *(_DWORD *)(v50 + 32);
    v58 = *(_QWORD *)(v50 + 40) + v54;
    *(_QWORD *)(v50 + 24) += v54;
    *(_QWORD *)(v50 + 40) = v58;
    *(_DWORD *)(v50 + 32) = v57 - v54;
    *(_QWORD *)(v51 + 32) = v55 + v54;
    *(_QWORD *)(v51 + 40) = v56 - v54;
    if ( v56 == v54 )
      *(_QWORD *)(v51 + 32) = *(_QWORD *)(v51 + 16);
  }
  if ( *(_DWORD *)(*a1 + 32) )
    return 3LL;
  else
    return 2LL;
}


================================================================================
Function: sub_67E7038 (0x67E7038)
================================================================================

long double __fastcall sub_67E7038(__int64 a1)
{
  __int64 i; // x8
  __int64 v2; // x9
  long double result; // q0

  for ( i = 0LL; i != 1144; i += 8LL )
  {
    v2 = a1 + i;
    *(_WORD *)(v2 + 212) = 0;
    *(_WORD *)(v2 + 216) = 0;
  }
  *(_WORD *)(a1 + 2504) = 0;
  *(_OWORD *)&result = 0uLL;
  *(_WORD *)(a1 + 2508) = 0;
  *(_WORD *)(a1 + 2512) = 0;
  *(_WORD *)(a1 + 1236) = 1;
  *(_WORD *)(a1 + 2516) = 0;
  *(_WORD *)(a1 + 2520) = 0;
  *(_WORD *)(a1 + 2524) = 0;
  *(_WORD *)(a1 + 2528) = 0;
  *(_WORD *)(a1 + 2532) = 0;
  *(_WORD *)(a1 + 2536) = 0;
  *(_WORD *)(a1 + 2540) = 0;
  *(_WORD *)(a1 + 2544) = 0;
  *(_WORD *)(a1 + 2548) = 0;
  *(_WORD *)(a1 + 2552) = 0;
  *(_WORD *)(a1 + 2556) = 0;
  *(_WORD *)(a1 + 2560) = 0;
  *(_WORD *)(a1 + 2564) = 0;
  *(_WORD *)(a1 + 2568) = 0;
  *(_WORD *)(a1 + 2572) = 0;
  *(_WORD *)(a1 + 2576) = 0;
  *(_WORD *)(a1 + 2580) = 0;
  *(_WORD *)(a1 + 2584) = 0;
  *(_WORD *)(a1 + 2588) = 0;
  *(_WORD *)(a1 + 2592) = 0;
  *(_WORD *)(a1 + 2596) = 0;
  *(_WORD *)(a1 + 2600) = 0;
  *(_WORD *)(a1 + 2604) = 0;
  *(_WORD *)(a1 + 2608) = 0;
  *(_WORD *)(a1 + 2612) = 0;
  *(_WORD *)(a1 + 2616) = 0;
  *(_WORD *)(a1 + 2620) = 0;
  *(_WORD *)(a1 + 2748) = 0;
  *(_WORD *)(a1 + 2752) = 0;
  *(_WORD *)(a1 + 2756) = 0;
  *(_WORD *)(a1 + 2760) = 0;
  *(_WORD *)(a1 + 2764) = 0;
  *(_WORD *)(a1 + 2768) = 0;
  *(_WORD *)(a1 + 2772) = 0;
  *(_WORD *)(a1 + 2776) = 0;
  *(_WORD *)(a1 + 2780) = 0;
  *(_WORD *)(a1 + 2784) = 0;
  *(_WORD *)(a1 + 2788) = 0;
  *(_WORD *)(a1 + 2792) = 0;
  *(_WORD *)(a1 + 2796) = 0;
  *(_WORD *)(a1 + 2800) = 0;
  *(_WORD *)(a1 + 2804) = 0;
  *(_WORD *)(a1 + 2808) = 0;
  *(_WORD *)(a1 + 2812) = 0;
  *(_WORD *)(a1 + 2816) = 0;
  *(_WORD *)(a1 + 2820) = 0;
  *(_DWORD *)(a1 + 5900) = 0;
  *(_OWORD *)(a1 + 5912) = 0u;
  *(_DWORD *)(a1 + 5928) = 0;
  return result;
}


================================================================================
Function: sub_67E7138 (0x67E7138)
================================================================================

void *__fastcall sub_67E7138(__int64 a1, const void *a2, size_t n, int a4)
{
  int v4; // w9
  __int64 v7; // x10
  __int64 v8; // x11
  __int16 v9; // w8
  __int64 v10; // x9
  __int64 v11; // x11
  int v12; // w9
  int v13; // w8
  int v14; // w10
  __int64 v15; // x9
  __int64 v16; // x11
  __int64 v17; // x8
  __int64 v18; // x11
  __int64 v19; // x9
  __int64 v20; // x11
  __int64 v21; // x8
  __int64 v22; // x10
  __int64 v23; // x8
  __int64 v24; // x11
  __int64 v25; // x8
  __int64 v26; // x11
  __int64 v27; // x8
  __int64 v28; // x11
  void *result; // x0

  v4 = *(_DWORD *)(a1 + 5940);
  if ( v4 < 14 )
  {
    v14 = a4 << v4;
    v12 = v4 + 3;
    LOWORD(v13) = *(_WORD *)(a1 + 5936) | v14;
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 40);
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(_WORD *)(a1 + 5936) | (a4 << v4);
    *(_WORD *)(a1 + 5936) = v9;
    *(_QWORD *)(a1 + 40) = v7 + 1;
    *(_BYTE *)(v8 + v7) = v9;
    v10 = *(_QWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16);
    LOBYTE(v9) = *(_BYTE *)(a1 + 5937);
    *(_QWORD *)(a1 + 40) = v10 + 1;
    *(_BYTE *)(v11 + v10) = v9;
    LODWORD(v10) = *(_DWORD *)(a1 + 5940);
    LOBYTE(v9) = 16 - v10;
    v12 = v10 - 13;
    v13 = (unsigned __int16)a4 >> v9;
  }
  *(_WORD *)(a1 + 5936) = v13;
  if ( v12 < 9 )
  {
    if ( v12 >= 1 )
    {
      v19 = *(_QWORD *)(a1 + 40);
      v20 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 40) = v19 + 1;
      *(_BYTE *)(v20 + v19) = v13;
    }
  }
  else
  {
    v15 = *(_QWORD *)(a1 + 40);
    v16 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 40) = v15 + 1;
    *(_BYTE *)(v16 + v15) = v13;
    v17 = *(_QWORD *)(a1 + 40);
    v18 = *(_QWORD *)(a1 + 16);
    LOBYTE(v15) = *(_BYTE *)(a1 + 5937);
    *(_QWORD *)(a1 + 40) = v17 + 1;
    *(_BYTE *)(v18 + v17) = v15;
  }
  v21 = *(_QWORD *)(a1 + 40);
  *(_WORD *)(a1 + 5936) = 0;
  v22 = *(_QWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 5940) = 0;
  *(_QWORD *)(a1 + 40) = v21 + 1;
  *(_BYTE *)(v22 + v21) = n;
  v23 = *(_QWORD *)(a1 + 40);
  v24 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 40) = v23 + 1;
  *(_BYTE *)(v24 + v23) = BYTE1(n);
  v25 = *(_QWORD *)(a1 + 40);
  v26 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 40) = v25 + 1;
  *(_BYTE *)(v26 + v25) = ~(_BYTE)n;
  v27 = *(_QWORD *)(a1 + 40);
  v28 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 40) = v27 + 1;
  *(_BYTE *)(v28 + v27) = (unsigned __int16)~(_WORD)n >> 8;
  result = memcpy((void *)(*(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 40)), a2, n);
  *(_QWORD *)(a1 + 40) += n;
  return result;
}


================================================================================
Function: sub_67E72B4 (0x67E72B4)
================================================================================

__int64 __fastcall sub_67E72B4(__int64 result)
{
  int v1; // w8
  __int64 v2; // x9
  __int64 v3; // x12
  int v4; // w8
  char v5; // w13
  __int64 v6; // x9
  char v7; // w10
  __int64 v8; // x12
  __int64 v9; // x8
  __int64 v10; // x11
  char v11; // w12

  v1 = *(_DWORD *)(result + 5940);
  if ( v1 == 16 )
  {
    v2 = *(_QWORD *)(result + 40);
    v3 = *(_QWORD *)(result + 16);
    v4 = 0;
    v5 = *(_BYTE *)(result + 5936);
    *(_QWORD *)(result + 40) = v2 + 1;
    *(_BYTE *)(v3 + v2) = v5;
    v6 = *(_QWORD *)(result + 40);
    v7 = *(_BYTE *)(result + 5937);
    v8 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v6 + 1;
    *(_BYTE *)(v8 + v6) = v7;
    *(_WORD *)(result + 5936) = 0;
  }
  else
  {
    if ( v1 < 8 )
      return result;
    v9 = *(_QWORD *)(result + 40);
    v10 = *(_QWORD *)(result + 16);
    v11 = *(_BYTE *)(result + 5936);
    *(_QWORD *)(result + 40) = v9 + 1;
    *(_BYTE *)(v10 + v9) = v11;
    v4 = *(_DWORD *)(result + 5940) - 8;
    *(_WORD *)(result + 5936) = *(unsigned __int8 *)(result + 5937);
  }
  *(_DWORD *)(result + 5940) = v4;
  return result;
}


================================================================================
Function: sub_67E7344 (0x67E7344)
================================================================================

__int64 __fastcall sub_67E7344(__int64 result)
{
  int v1; // w10
  unsigned int v2; // w8
  __int64 v3; // x10
  __int64 v4; // x12
  __int64 v5; // x10
  __int64 v6; // x12
  char v7; // w8
  int v8; // w9
  __int64 v9; // x9
  __int64 v10; // x11
  __int64 v11; // x9
  __int64 v12; // x11
  char v13; // w8
  int v14; // w9
  __int64 v15; // x10
  int v16; // w9
  __int64 v17; // x12
  __int64 v18; // x10
  __int64 v19; // x12
  char v20; // w8
  __int64 v21; // x9
  __int64 v22; // x11

  v1 = *(_DWORD *)(result + 5940);
  LOWORD(v2) = *(_WORD *)(result + 5936) | (2 << v1);
  *(_WORD *)(result + 5936) = v2;
  if ( v1 < 14 )
  {
    v8 = v1 + 3;
  }
  else
  {
    v3 = *(_QWORD *)(result + 40);
    v4 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v3 + 1;
    *(_BYTE *)(v4 + v3) = v2;
    v5 = *(_QWORD *)(result + 40);
    v6 = *(_QWORD *)(result + 16);
    v7 = *(_BYTE *)(result + 5937);
    *(_QWORD *)(result + 40) = v5 + 1;
    *(_BYTE *)(v6 + v5) = v7;
    LODWORD(v5) = *(_DWORD *)(result + 5940);
    v2 = 2u >> (16 - v5);
    v8 = v5 - 13;
    *(_WORD *)(result + 5936) = v2;
  }
  *(_DWORD *)(result + 5940) = v8;
  if ( v8 < 10 )
  {
    v14 = v8 + 7;
  }
  else
  {
    v9 = *(_QWORD *)(result + 40);
    v10 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v9 + 1;
    *(_BYTE *)(v10 + v9) = v2;
    v11 = *(_QWORD *)(result + 40);
    v12 = *(_QWORD *)(result + 16);
    v13 = *(_BYTE *)(result + 5937);
    *(_QWORD *)(result + 40) = v11 + 1;
    *(_BYTE *)(v12 + v11) = v13;
    v2 = *(_DWORD *)(result + 5940);
    *(_WORD *)(result + 5936) = 0;
    v14 = v2 - 9;
    LOBYTE(v2) = 0;
  }
  *(_DWORD *)(result + 5940) = v14;
  if ( v14 == 16 )
  {
    v15 = *(_QWORD *)(result + 40);
    v16 = 0;
    v17 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v15 + 1;
    *(_BYTE *)(v17 + v15) = v2;
    v18 = *(_QWORD *)(result + 40);
    v19 = *(_QWORD *)(result + 16);
    v20 = *(_BYTE *)(result + 5937);
    *(_QWORD *)(result + 40) = v18 + 1;
    *(_BYTE *)(v19 + v18) = v20;
    *(_WORD *)(result + 5936) = 0;
  }
  else
  {
    if ( v14 < 8 )
      return result;
    v21 = *(_QWORD *)(result + 40);
    v22 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v21 + 1;
    *(_BYTE *)(v22 + v21) = v2;
    v16 = *(_DWORD *)(result + 5940) - 8;
    *(_WORD *)(result + 5936) = *(unsigned __int8 *)(result + 5937);
  }
  *(_DWORD *)(result + 5940) = v16;
  return result;
}


================================================================================
Function: sub_67E7498 (0x67E7498)
================================================================================

__int64 __fastcall sub_67E7498(__int64 a1, const void *a2, size_t n, int a4)
{
  __int64 v8; // x9
  unsigned __int64 v9; // x11
  int v10; // w9
  unsigned __int64 v11; // x10
  int v12; // w8
  unsigned __int64 v13; // x11
  int v14; // w11
  unsigned int v15; // w10
  __int64 v16; // x9
  int v17; // w0
  int v18; // w15
  int v19; // w16
  unsigned __int16 *v20; // x12
  int v21; // w1
  unsigned int v22; // w14
  int v23; // w17
  int v24; // w11
  unsigned int v25; // w10
  __int64 v26; // x9
  int v27; // w17
  int v28; // w14
  int v29; // w15
  unsigned __int16 *v30; // x11
  int v31; // w0
  unsigned int v32; // w13
  int v33; // w16
  __int64 v34; // x10
  __int64 v35; // x11
  __int64 v36; // x9
  unsigned __int64 v37; // x11
  int v38; // w9
  int v39; // w10
  __int64 v40; // x12
  __int64 v41; // x13
  __int16 v42; // w9
  __int64 v43; // x11
  __int64 v44; // x13
  int v45; // w9
  int v46; // w9
  int v47; // w10
  int v48; // w8
  __int64 v49; // x11
  __int64 v50; // x12
  __int16 v51; // w9
  __int64 v52; // x10
  __int64 v53; // x12
  int v54; // w9
  int v55; // w10
  int v56; // w8
  int v57; // w10
  int v58; // w2
  int v59; // w21
  int v60; // w11
  __int64 v61; // x12
  __int16 v62; // w9
  __int64 v63; // x13
  __int64 v64; // x10
  __int64 v65; // x13
  int v66; // w9
  int v67; // w9
  int v68; // w10
  void *v69; // x1
  void *v70; // x2
  __int64 v71; // x0
  int v72; // w11
  int v73; // w11
  __int64 v74; // x12
  __int16 v75; // w9
  __int64 v76; // x11
  __int64 v77; // x10
  __int64 v78; // x12
  int v79; // w9
  int v80; // w10
  int v81; // w11
  __int64 v82; // x9
  int v83; // w8
  __int64 v84; // x12
  __int16 v85; // w10
  __int64 v86; // x13
  __int64 v87; // x11
  __int64 v88; // x13
  int v89; // w10
  int v90; // w10
  int v91; // w8
  char *v92; // x13
  unsigned int v93; // w14
  __int64 v94; // x10
  __int64 v95; // x16
  __int64 v96; // x8
  char v97; // w15
  __int64 v98; // x16
  __int64 result; // x0
  int v100; // w8
  __int64 v101; // x8
  __int64 v102; // x11
  char v103; // w12
  __int64 v104; // x8
  char v105; // w9
  __int64 v106; // x11

  if ( *(int *)(a1 + 196) < 1 )
  {
    v11 = n + 5;
    v12 = 0;
    v13 = n + 5;
    if ( !a2 )
      goto LABEL_118;
  }
  else
  {
    if ( *(_DWORD *)(*(_QWORD *)a1 + 88LL) == 2 )
    {
      v8 = 0LL;
      v9 = 4093624447LL;
      do
      {
        if ( (v9 & 1) != 0 && *(_WORD *)(a1 + 212 + v8) )
        {
          v10 = 0;
          goto LABEL_14;
        }
        v9 >>= 1;
        v8 += 4LL;
      }
      while ( v8 != 128 );
      if ( !*(_WORD *)(a1 + 248) && !*(_WORD *)(a1 + 252) && !*(_WORD *)(a1 + 264) )
      {
        v34 = 0LL;
        v35 = a1 + 340;
        while ( 1 )
        {
          v10 = *(unsigned __int16 *)(v35 + v34);
          if ( *(_WORD *)(v35 + v34) )
            break;
          v34 += 4LL;
          if ( v34 == 896 )
            goto LABEL_14;
        }
      }
      v10 = 1;
LABEL_14:
      *(_DWORD *)(*(_QWORD *)a1 + 88LL) = v10;
    }
    sub_67E7D14(a1, a1 + 2904);
    sub_67E7D14(a1, a1 + 2928);
    v14 = *(_DWORD *)(a1 + 2912);
    v15 = *(unsigned __int16 *)(a1 + 214);
    v16 = (unsigned int)(v14 + 1);
    *(_WORD *)(a1 + 4LL * (int)v16 + 214) = -1;
    if ( (v14 & 0x80000000) == 0 )
    {
      v17 = 0;
      if ( v15 )
        v18 = 4;
      else
        v18 = 3;
      if ( v15 )
        v19 = 7;
      else
        v19 = 138;
      v20 = (unsigned __int16 *)(a1 + 218);
      v21 = -1;
      do
      {
        v22 = v15;
        v15 = *v20;
        v23 = v17 + 1;
        if ( v17 + 1 < v19 && v22 == v15 )
        {
          v22 = v21;
        }
        else
        {
          if ( v23 >= v18 )
          {
            if ( v22 )
            {
              if ( v22 != v21 )
                ++*(_WORD *)(a1 + 4LL * v22 + 2748);
              ++*(_WORD *)(a1 + 2812);
              v23 = 0;
              if ( v15 )
              {
LABEL_29:
                if ( v22 == v15 )
                  v19 = 6;
                else
                  v19 = 7;
                if ( v22 == v15 )
                  v18 = 3;
                else
                  v18 = 4;
                goto LABEL_24;
              }
            }
            else if ( v17 > 9 )
            {
              ++*(_WORD *)(a1 + 2820);
              v23 = 0;
              if ( v15 )
                goto LABEL_29;
            }
            else
            {
              ++*(_WORD *)(a1 + 2816);
              v23 = 0;
              if ( v15 )
                goto LABEL_29;
            }
          }
          else
          {
            *(_WORD *)(a1 + 4LL * v22 + 2748) += v23;
            v23 = 0;
            if ( v15 )
              goto LABEL_29;
          }
          v18 = 3;
          v19 = 138;
        }
LABEL_24:
        --v16;
        v20 += 2;
        v17 = v23;
        v21 = v22;
      }
      while ( v16 );
    }
    v24 = *(_DWORD *)(a1 + 2936);
    v25 = *(unsigned __int16 *)(a1 + 2506);
    v26 = (unsigned int)(v24 + 1);
    *(_WORD *)(a1 + 4LL * (int)v26 + 2506) = -1;
    if ( (v24 & 0x80000000) == 0 )
    {
      v27 = 0;
      if ( v25 )
        v28 = 4;
      else
        v28 = 3;
      if ( v25 )
        v29 = 7;
      else
        v29 = 138;
      v30 = (unsigned __int16 *)(a1 + 2510);
      v31 = -1;
      do
      {
        v32 = v25;
        v25 = *v30;
        v33 = v27 + 1;
        if ( v27 + 1 < v29 && v32 == v25 )
        {
          v32 = v31;
        }
        else
        {
          if ( v33 >= v28 )
          {
            if ( v32 )
            {
              if ( v32 != v31 )
                ++*(_WORD *)(a1 + 4LL * v32 + 2748);
              ++*(_WORD *)(a1 + 2812);
              v33 = 0;
              if ( v25 )
              {
LABEL_59:
                if ( v32 == v25 )
                  v29 = 6;
                else
                  v29 = 7;
                if ( v32 == v25 )
                  v28 = 3;
                else
                  v28 = 4;
                goto LABEL_54;
              }
            }
            else if ( v27 > 9 )
            {
              ++*(_WORD *)(a1 + 2820);
              v33 = 0;
              if ( v25 )
                goto LABEL_59;
            }
            else
            {
              ++*(_WORD *)(a1 + 2816);
              v33 = 0;
              if ( v25 )
                goto LABEL_59;
            }
          }
          else
          {
            *(_WORD *)(a1 + 4LL * v32 + 2748) += v33;
            v33 = 0;
            if ( v25 )
              goto LABEL_59;
          }
          v28 = 3;
          v29 = 138;
        }
LABEL_54:
        --v26;
        v30 += 2;
        v27 = v33;
        v31 = v32;
      }
      while ( v26 );
    }
    sub_67E7D14(a1, a1 + 2952);
    if ( *(_WORD *)(a1 + 2810) )
    {
      v12 = 18;
    }
    else if ( *(_WORD *)(a1 + 2754) )
    {
      v12 = 17;
    }
    else if ( *(_WORD *)(a1 + 2806) )
    {
      v12 = 16;
    }
    else if ( *(_WORD *)(a1 + 2758) )
    {
      v12 = 15;
    }
    else if ( *(_WORD *)(a1 + 2802) )
    {
      v12 = 14;
    }
    else if ( *(_WORD *)(a1 + 2762) )
    {
      v12 = 13;
    }
    else if ( *(_WORD *)(a1 + 2798) )
    {
      v12 = 12;
    }
    else if ( *(_WORD *)(a1 + 2766) )
    {
      v12 = 11;
    }
    else if ( *(_WORD *)(a1 + 2794) )
    {
      v12 = 10;
    }
    else if ( *(_WORD *)(a1 + 2770) )
    {
      v12 = 9;
    }
    else if ( *(_WORD *)(a1 + 2790) )
    {
      v12 = 8;
    }
    else if ( *(_WORD *)(a1 + 2774) )
    {
      v12 = 7;
    }
    else if ( *(_WORD *)(a1 + 2786) )
    {
      v12 = 6;
    }
    else if ( *(_WORD *)(a1 + 2778) )
    {
      v12 = 5;
    }
    else if ( *(_WORD *)(a1 + 2782) )
    {
      v12 = 4;
    }
    else if ( *(_WORD *)(a1 + 2750) )
    {
      v12 = 3;
    }
    else
    {
      v12 = 2;
    }
    v36 = *(_QWORD *)(a1 + 5912) + (unsigned int)(3 * v12 + 17);
    v37 = *(_QWORD *)(a1 + 5920) + 10LL;
    v11 = v37 >> 3;
    *(_QWORD *)(a1 + 5912) = v36;
    if ( v37 >> 3 <= (unsigned __int64)(v36 + 10) >> 3 )
      v13 = v37 >> 3;
    else
      v13 = (unsigned __int64)(v36 + 10) >> 3;
    if ( !a2 )
      goto LABEL_118;
  }
  if ( n + 4 <= v13 )
  {
    sub_67E7138(a1, a2, n, a4);
    goto LABEL_143;
  }
LABEL_118:
  v38 = *(_DWORD *)(a1 + 5940);
  if ( *(_DWORD *)(a1 + 200) == 4 || v11 == v13 )
  {
    v48 = a4 + 2;
    if ( v38 < 14 )
    {
      v55 = *(unsigned __int16 *)(a1 + 5936) | (v48 << v38);
      v56 = v38 + 3;
    }
    else
    {
      v49 = *(_QWORD *)(a1 + 40);
      v50 = *(_QWORD *)(a1 + 16);
      v51 = *(_WORD *)(a1 + 5936) | (v48 << v38);
      *(_WORD *)(a1 + 5936) = v51;
      *(_QWORD *)(a1 + 40) = v49 + 1;
      *(_BYTE *)(v50 + v49) = v51;
      v52 = *(_QWORD *)(a1 + 40);
      v53 = *(_QWORD *)(a1 + 16);
      LOBYTE(v51) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v52 + 1;
      *(_BYTE *)(v53 + v52) = v51;
      v54 = *(_DWORD *)(a1 + 5940);
      v55 = (unsigned __int16)(a4 + 2) >> (16 - v54);
      v56 = v54 - 13;
    }
    *(_WORD *)(a1 + 5936) = v55;
    v69 = &unk_17449CE;
    *(_DWORD *)(a1 + 5940) = v56;
    v70 = &unk_1744E4E;
    v71 = a1;
  }
  else
  {
    v39 = a4 + 4;
    if ( v38 < 14 )
    {
      v57 = v39 << v38;
      v46 = v38 + 3;
      v47 = *(unsigned __int16 *)(a1 + 5936) | v57;
    }
    else
    {
      v40 = *(_QWORD *)(a1 + 40);
      v41 = *(_QWORD *)(a1 + 16);
      v42 = *(_WORD *)(a1 + 5936) | (v39 << v38);
      *(_WORD *)(a1 + 5936) = v42;
      *(_QWORD *)(a1 + 40) = v40 + 1;
      *(_BYTE *)(v41 + v40) = v42;
      v43 = *(_QWORD *)(a1 + 40);
      v44 = *(_QWORD *)(a1 + 16);
      LOBYTE(v42) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v43 + 1;
      *(_BYTE *)(v44 + v43) = v42;
      v45 = *(_DWORD *)(a1 + 5940);
      LOBYTE(v43) = 16 - v45;
      v46 = v45 - 13;
      v47 = (unsigned __int16)(a4 + 4) >> v43;
    }
    v58 = *(_DWORD *)(a1 + 2912);
    v59 = *(_DWORD *)(a1 + 2936);
    *(_DWORD *)(a1 + 5940) = v46;
    v60 = v58 + 65280;
    if ( v46 < 12 )
    {
      v72 = v60 << v46;
      v67 = v46 + 5;
      v68 = v47 | v72;
    }
    else
    {
      v61 = *(_QWORD *)(a1 + 40);
      v62 = v47 | (v60 << v46);
      v63 = *(_QWORD *)(a1 + 16);
      *(_WORD *)(a1 + 5936) = v62;
      *(_QWORD *)(a1 + 40) = v61 + 1;
      *(_BYTE *)(v63 + v61) = v62;
      v64 = *(_QWORD *)(a1 + 40);
      v65 = *(_QWORD *)(a1 + 16);
      LOBYTE(v62) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v64 + 1;
      *(_BYTE *)(v65 + v64) = v62;
      v66 = *(_DWORD *)(a1 + 5940);
      LOBYTE(v64) = 16 - v66;
      v67 = v66 - 11;
      v68 = (unsigned __int16)(v58 - 256) >> v64;
    }
    v73 = v59 + 0x10000;
    *(_DWORD *)(a1 + 5940) = v67;
    if ( v67 < 12 )
    {
      v80 = v68 | (v73 << v67);
      v81 = v67 + 5;
    }
    else
    {
      v74 = *(_QWORD *)(a1 + 40);
      v75 = v68 | (v73 << v67);
      v76 = *(_QWORD *)(a1 + 16);
      *(_WORD *)(a1 + 5936) = v75;
      *(_QWORD *)(a1 + 40) = v74 + 1;
      *(_BYTE *)(v76 + v74) = v75;
      v77 = *(_QWORD *)(a1 + 40);
      v78 = *(_QWORD *)(a1 + 16);
      LOBYTE(v75) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v77 + 1;
      *(_BYTE *)(v78 + v77) = v75;
      v79 = *(_DWORD *)(a1 + 5940);
      v80 = (unsigned __int16)v59 >> (16 - v79);
      v81 = v79 - 11;
    }
    v82 = (unsigned int)(v12 + 1);
    v83 = v12 + 65533;
    *(_DWORD *)(a1 + 5940) = v81;
    if ( v81 < 13 )
    {
      v91 = v80 | (v83 << v81);
      v90 = v81 + 4;
    }
    else
    {
      v84 = *(_QWORD *)(a1 + 40);
      v85 = v80 | (v83 << v81);
      v86 = *(_QWORD *)(a1 + 16);
      *(_WORD *)(a1 + 5936) = v85;
      *(_QWORD *)(a1 + 40) = v84 + 1;
      *(_BYTE *)(v86 + v84) = v85;
      v87 = *(_QWORD *)(a1 + 40);
      v88 = *(_QWORD *)(a1 + 16);
      LOBYTE(v85) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v87 + 1;
      *(_BYTE *)(v88 + v87) = v85;
      v89 = *(_DWORD *)(a1 + 5940);
      LOBYTE(v87) = 16 - v89;
      v90 = v89 - 12;
      v91 = (unsigned __int16)v83 >> v87;
    }
    v92 = &byte_1745000;
    *(_DWORD *)(a1 + 5940) = v90;
    do
    {
      v93 = *(unsigned __int16 *)(a1 + 4LL * (unsigned __int8)*v92 + 2750);
      v91 |= v93 << v90;
      *(_WORD *)(a1 + 5936) = v91;
      if ( v90 < 14 )
      {
        v90 += 3;
      }
      else
      {
        v94 = *(_QWORD *)(a1 + 40);
        v95 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 40) = v94 + 1;
        *(_BYTE *)(v95 + v94) = v91;
        v96 = *(_QWORD *)(a1 + 40);
        v97 = *(_BYTE *)(a1 + 5937);
        v98 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 40) = v96 + 1;
        *(_BYTE *)(v98 + v96) = v97;
        LODWORD(v94) = *(_DWORD *)(a1 + 5940);
        LOBYTE(v96) = 16 - v94;
        v90 = v94 - 13;
        v91 = v93 >> v96;
        *(_WORD *)(a1 + 5936) = v91;
      }
      --v82;
      ++v92;
      *(_DWORD *)(a1 + 5940) = v90;
    }
    while ( v82 );
    sub_67E8964(a1, a1 + 212);
    sub_67E8964(a1, a1 + 2504);
    v71 = a1;
    v69 = (void *)(a1 + 212);
    v70 = (void *)(a1 + 2504);
  }
  sub_67E84A8(v71, v69, v70);
LABEL_143:
  result = sub_67E7038(a1);
  if ( !a4 )
    return result;
  v100 = *(_DWORD *)(a1 + 5940);
  if ( v100 >= 9 )
  {
    v101 = *(_QWORD *)(a1 + 40);
    v102 = *(_QWORD *)(a1 + 16);
    v103 = *(_BYTE *)(a1 + 5936);
    *(_QWORD *)(a1 + 40) = v101 + 1;
    *(_BYTE *)(v102 + v101) = v103;
    v104 = *(_QWORD *)(a1 + 40);
    v105 = *(_BYTE *)(a1 + 5937);
LABEL_148:
    v106 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 40) = v104 + 1;
    *(_BYTE *)(v106 + v104) = v105;
    goto LABEL_149;
  }
  if ( v100 >= 1 )
  {
    v104 = *(_QWORD *)(a1 + 40);
    v105 = *(_BYTE *)(a1 + 5936);
    goto LABEL_148;
  }
LABEL_149:
  *(_WORD *)(a1 + 5936) = 0;
  *(_DWORD *)(a1 + 5940) = 0;
  return result;
}


================================================================================
Function: sub_67E7D14 (0x67E7D14)
================================================================================

__int64 __fastcall sub_67E7D14(__int64 a1, __int64 *a2)
{
  __int64 *v4; // x9
  int *v5; // x8
  __int64 v6; // x19
  __int64 v7; // x27
  __int64 v8; // x9
  __int64 v9; // x10
  _WORD *v10; // x11
  int v11; // w24
  __int64 v12; // x13
  int v13; // w10
  __int64 *v14; // x25
  __int64 *v15; // x26
  unsigned int v16; // w22
  __int64 result; // x0
  bool v18; // cf
  int v19; // w12
  __int64 v20; // x9
  __int64 v21; // x10
  int v22; // w17
  __int64 v23; // x11
  int v24; // w10
  __int64 v25; // x12
  int v26; // w14
  int v27; // w15
  __int64 v28; // x17
  __int64 v29; // x16
  __int64 v30; // x1
  unsigned int v31; // w2
  unsigned int v32; // w3
  int v33; // w16
  int v34; // w15
  unsigned int v35; // w17
  unsigned int v36; // w3
  __int64 v37; // x14
  _WORD *v38; // x15
  __int64 v39; // x12
  __int64 v40; // x11
  _WORD *v41; // x16
  __int64 v42; // x10
  _WORD *v43; // x10
  __int64 v44; // x13
  unsigned int v45; // w12
  unsigned __int8 *v46; // x11
  int v47; // w15
  int v48; // w12
  int v49; // w13
  __int64 v50; // x15
  __int64 v51; // x14
  __int64 v52; // x17
  unsigned int v53; // w1
  int v54; // w14
  unsigned int v55; // w16
  int v56; // w13
  unsigned int v57; // w15
  unsigned int v58; // w1
  int v59; // w9
  __int64 v60; // x8
  __int64 *v61; // x10
  __int64 v62; // x15
  __int64 v63; // x8
  int v64; // w9
  __int64 v65; // x12
  __int64 v66; // x13
  int v67; // w14
  __int64 v68; // x10
  __int64 v69; // x15
  __int64 v70; // x16
  int v71; // w11
  int v72; // w15
  int *v73; // x16
  __int64 v74; // x17
  __int64 v75; // x1
  int v76; // w0
  bool v77; // cc
  int v78; // w1
  __int64 v79; // x2
  unsigned __int16 *v80; // x12
  _WORD *v81; // x15
  __int64 v82; // x16
  __int16 v83; // w17
  int v84; // t1
  bool v85; // vf
  unsigned __int16 v86; // w15
  int v87; // w12
  int v88; // w13
  int *v89; // x15
  __int64 v90; // x14
  __int64 v91; // t1
  __int64 v92; // x15
  _WORD *v93; // x15
  __int64 v94; // x16
  unsigned int v95; // t1
  __int16 v96; // w11
  __int16 v97; // w12
  __int16 v98; // w9
  __int16 v99; // w13
  __int16 v100; // w14
  __int16 v101; // w10
  __int16 v102; // w11
  __int16 v103; // w12
  __int16 v104; // w8
  __int16 v105; // w13
  __int16 v106; // w9
  __int16 v107; // w14
  __int16 v108; // w10
  __int16 v109; // w13
  __int16 v110; // w11
  __int16 v111; // w14
  __int16 v112; // w12
  __int16 v113; // w13
  __int16 v114; // w8
  __int16 v115; // w14
  __int16 v116; // w9
  __int16 v117; // w13
  __int16 v118; // w10
  __int16 v119; // w14
  __int64 v120; // x8
  __int64 v121; // x11
  __int64 v122; // x13
  __int64 v123; // x14
  int v124; // w12
  unsigned int v125; // w13
  unsigned int v126; // w11
  int v127; // w14
  int v128; // w14
  __int64 v129; // x10
  int v130; // w13
  _BYTE v131[2]; // [xsp+8h] [xbp-28h]
  __int16 v132; // [xsp+Ah] [xbp-26h]
  __int16 v133; // [xsp+Ch] [xbp-24h]
  __int16 v134; // [xsp+Eh] [xbp-22h]
  __int16 v135; // [xsp+10h] [xbp-20h]
  __int16 v136; // [xsp+12h] [xbp-1Eh]
  __int16 v137; // [xsp+14h] [xbp-1Ch]
  __int16 v138; // [xsp+16h] [xbp-1Ah]
  __int16 v139; // [xsp+18h] [xbp-18h]
  __int16 v140; // [xsp+1Ah] [xbp-16h]
  __int16 v141; // [xsp+1Ch] [xbp-14h]
  __int16 v142; // [xsp+1Eh] [xbp-12h]
  __int16 v143; // [xsp+20h] [xbp-10h]
  __int16 v144; // [xsp+22h] [xbp-Eh]
  __int16 v145; // [xsp+24h] [xbp-Ch]
  __int16 v146; // [xsp+26h] [xbp-Ah]

  v4 = (__int64 *)a2[2];
  v5 = (int *)(a1 + 5300);
  v6 = *a2;
  v7 = *((unsigned int *)v4 + 5);
  v8 = *v4;
  *(_QWORD *)(a1 + 5300) = 0x23D00000000LL;
  if ( (int)v7 <= 0 )
  {
    v13 = 0;
    v14 = (__int64 *)(a1 + 5912);
    v15 = (__int64 *)(a1 + 5920);
    v11 = -1;
    goto LABEL_92;
  }
  v9 = 0LL;
  v10 = (_WORD *)(v6 + 2);
  v11 = -1;
  do
  {
    if ( *(v10 - 1) )
    {
      v11 = v9;
      v12 = *(int *)(a1 + 5300) + 1LL;
      *(_DWORD *)(a1 + 5300) = v12;
      *(_DWORD *)(a1 + 4 * v12 + 3008) = v9;
      *(_BYTE *)(a1 + 5308 + v9) = 0;
    }
    else
    {
      *v10 = 0;
    }
    ++v9;
    v10 += 2;
  }
  while ( v7 != v9 );
  v13 = *(_DWORD *)(a1 + 5300);
  v14 = (__int64 *)(a1 + 5912);
  v15 = (__int64 *)(a1 + 5920);
  if ( v13 <= 1 )
  {
    do
    {
LABEL_92:
      v129 = v13 + 1LL;
      if ( v11 < 2 )
        v130 = v11 + 1;
      else
        v130 = 0;
      if ( v11 < 2 )
        ++v11;
      *(_DWORD *)(a1 + 5300) = v129;
      *(_DWORD *)(a1 + 4 * v129 + 3008) = v130;
      *(_WORD *)(v6 + 4LL * v130) = 1;
      *(_BYTE *)(a1 + v130 + 5308) = 0;
      --*(_QWORD *)(a1 + 5912);
      if ( v8 )
        *v15 -= *(unsigned __int16 *)(v8 + 4LL * v130 + 2);
      v13 = *v5;
    }
    while ( *v5 < 2 );
  }
  v16 = (unsigned int)v13 >> 1;
  *((_DWORD *)a2 + 2) = v11;
  do
  {
    result = sub_67E8858(a1, v6, v16);
    v18 = v16-- != 0;
  }
  while ( v16 != 0 && v18 );
  v19 = *(_DWORD *)(a1 + 5300);
  v20 = (int)v7;
  do
  {
    v22 = v19 - 1;
    *(_DWORD *)(a1 + 5300) = v19 - 1;
    v23 = *(int *)(a1 + 4LL * v19 + 3008);
    v24 = *(_DWORD *)(a1 + 3012);
    *(_DWORD *)(a1 + 3012) = v23;
    if ( v19 <= 2 )
    {
      v25 = 1LL;
      goto LABEL_31;
    }
    v26 = 1;
    v27 = 2;
    while ( 1 )
    {
      if ( v27 >= v22 )
      {
        v33 = v27;
        v28 = v27;
      }
      else
      {
        v28 = v27;
        v29 = *(int *)(a1 + 3008 + 4 * (v27 | 1LL));
        v30 = *(int *)(a1 + 3008 + 4LL * v27);
        v31 = *(unsigned __int16 *)(v6 + 4 * v29);
        v32 = *(unsigned __int16 *)(v6 + 4 * v30);
        if ( v31 >= v32 )
        {
          if ( v31 != v32 )
          {
            v33 = v27;
            goto LABEL_21;
          }
          v36 = *(unsigned __int8 *)(a1 + 5308 + v29);
          v33 = v27;
          if ( v36 > *(unsigned __int8 *)(a1 + 5308 + v30) )
            goto LABEL_21;
        }
        v28 = v27 | 1LL;
        v33 = v27 | 1;
      }
LABEL_21:
      result = *(unsigned __int16 *)(v6 + 4 * v23);
      v34 = *(_DWORD *)(a1 + 4 * v28 + 3008);
      v35 = *(unsigned __int16 *)(v6 + 4LL * v34);
      if ( (unsigned int)result < v35 )
        break;
      if ( (_DWORD)result == v35 )
      {
        result = *(unsigned __int8 *)(a1 + v23 + 5308);
        if ( (unsigned int)result <= *(unsigned __int8 *)(a1 + v34 + 5308) )
          break;
      }
      *(_DWORD *)(a1 + 4LL * v26 + 3008) = v34;
      v27 = 2 * v33;
      v22 = *(_DWORD *)(a1 + 5300);
      v26 = v33;
      if ( 2 * v33 > v22 )
        goto LABEL_30;
    }
    v33 = v26;
LABEL_30:
    v25 = v33;
LABEL_31:
    v37 = v24;
    *(_DWORD *)(a1 + 3008 + 4 * v25) = v23;
    v38 = (_WORD *)(v6 + 4LL * v24);
    v39 = *(int *)(a1 + 3012);
    v40 = *(int *)(a1 + 5304) - 1LL;
    v41 = (_WORD *)(v6 + 4 * v39);
    *(_DWORD *)(a1 + 5304) = v40;
    *(_DWORD *)(a1 + 3008 + 4 * v40) = v24;
    v42 = *(int *)(a1 + 5304) - 1LL;
    *(_DWORD *)(a1 + 5304) = v42;
    *(_DWORD *)(a1 + 3008 + 4 * v42) = v39;
    v43 = (_WORD *)(v6 + 4 * v20);
    v44 = a1 + 5308;
    *v43 = *v41 + *v38;
    v45 = *(unsigned __int8 *)(a1 + 5308 + v39);
    if ( *(unsigned __int8 *)(a1 + 5308 + v37) >= v45 )
      LOBYTE(v45) = *(_BYTE *)(a1 + 5308 + v37);
    v46 = (unsigned __int8 *)(v44 + v20);
    *(_BYTE *)(v44 + v20) = v45 + 1;
    v41[1] = v20;
    v38[1] = v20;
    v47 = *(_DWORD *)(a1 + 5300);
    *(_DWORD *)(a1 + 3012) = v20;
    if ( v47 < 2 )
    {
      v21 = 1LL;
      goto LABEL_12;
    }
    v48 = 1;
    v49 = 2;
    while ( 2 )
    {
      if ( v49 >= v47 )
      {
        v54 = v49;
        v50 = v49;
      }
      else
      {
        v50 = v49;
        v51 = *(int *)(a1 + 3008 + 4 * (v49 | 1LL));
        v52 = *(int *)(a1 + 3008 + 4LL * v49);
        result = *(unsigned __int16 *)(v6 + 4 * v51);
        v53 = *(unsigned __int16 *)(v6 + 4 * v52);
        if ( (unsigned int)result < v53 )
          goto LABEL_38;
        if ( (_DWORD)result == v53 )
        {
          result = a1 + 5308;
          v58 = *(unsigned __int8 *)(a1 + 5308 + v51);
          v54 = v49;
          if ( v58 <= *(unsigned __int8 *)(a1 + 5308 + v52) )
          {
LABEL_38:
            v50 = v49 | 1LL;
            v54 = v49 | 1;
          }
        }
        else
        {
          v54 = v49;
        }
      }
      v55 = (unsigned __int16)*v43;
      v56 = *(_DWORD *)(a1 + 4 * v50 + 3008);
      v57 = *(unsigned __int16 *)(v6 + 4LL * v56);
      if ( v55 >= v57 && (v55 != v57 || *v46 > (unsigned int)*(unsigned __int8 *)(a1 + v56 + 5308)) )
      {
        *(_DWORD *)(a1 + 4LL * v48 + 3008) = v56;
        v49 = 2 * v54;
        v47 = *(_DWORD *)(a1 + 5300);
        v48 = v54;
        if ( 2 * v54 > v47 )
          goto LABEL_49;
        continue;
      }
      break;
    }
    v54 = v48;
LABEL_49:
    v21 = v54;
LABEL_12:
    *(_DWORD *)(a1 + 4 * v21 + 3008) = v20++;
    v19 = *(_DWORD *)(a1 + 5300);
  }
  while ( v19 > 1 );
  v59 = *(_DWORD *)(a1 + 3012);
  v60 = *(int *)(a1 + 5304) - 1LL;
  *(_DWORD *)(a1 + 5304) = v60;
  *(_DWORD *)(a1 + 3008 + 4 * v60) = v59;
  v61 = (__int64 *)a2[2];
  v62 = *(int *)(a1 + 5304);
  v63 = *a2;
  v64 = *((_DWORD *)a2 + 2);
  v65 = *v61;
  v66 = v61[1];
  v67 = *((_DWORD *)v61 + 4);
  v68 = *((int *)v61 + 6);
  *(_OWORD *)(a1 + 2992) = 0u;
  *(_OWORD *)(a1 + 2976) = 0u;
  *(_WORD *)(v63 + 4LL * *(int *)(a1 + 3008 + 4 * v62) + 2) = 0;
  v69 = *(int *)(a1 + 5304);
  if ( (int)v69 <= 571 )
  {
    v70 = a1 + 4 * v69;
    v71 = 0;
    v72 = v69 - 572;
    v73 = (int *)(v70 + 3012);
    do
    {
      v74 = *v73;
      v75 = v63 + 4 * v74;
      v76 = *(unsigned __int16 *)(v63 + 4LL * *(unsigned __int16 *)(v75 + 2) + 2);
      v77 = (int)v68 <= v76;
      if ( (int)v68 > v76 )
        result = (unsigned int)(v76 + 1);
      else
        result = (unsigned int)v68;
      if ( v77 )
        ++v71;
      *(_WORD *)(v75 + 2) = result;
      if ( (int)v74 <= v64 )
      {
        ++*(_WORD *)(a1 + 2LL * (int)result + 2976);
        v78 = (int)v74 >= v67 ? *(_DWORD *)(v66 + 4LL * ((int)v74 - v67)) : 0;
        v79 = *(unsigned __int16 *)(v63 + 4 * v74);
        result = *v14 + v79 * (unsigned int)(v78 + result);
        *v14 = result;
        if ( v65 )
        {
          result = *v15;
          *v15 += (v78 + (unsigned int)*(unsigned __int16 *)(v65 + 4 * v74 + 2)) * v79;
        }
      }
      v18 = __CFADD__(v72++, 1);
      ++v73;
    }
    while ( !v18 );
    if ( v71 )
    {
      v80 = (unsigned __int16 *)(a1 + 2 * v68 + 2976);
      do
      {
        v81 = (_WORD *)(a1 + 2 * v68 + 2976);
        v82 = (v68 << 32) + 0x100000000LL;
        do
        {
          v84 = (unsigned __int16)*--v81;
          v83 = v84;
          v82 -= 0x100000000LL;
        }
        while ( !v84 );
        v85 = __OFSUB__(v71, 2);
        v71 -= 2;
        *v81 = v83 - 1;
        *(_WORD *)(a1 + (v82 >> 31) + 2976) += 2;
        v86 = *v80 - 1;
        *v80 = v86;
      }
      while ( !((v71 < 0) ^ v85 | (v71 == 0)) );
      if ( (_DWORD)v68 )
      {
        v87 = 573;
        if ( v86 )
          goto LABEL_74;
        while ( (_DWORD)--v68 )
        {
          v86 = *(_WORD *)(a1 + 2 * v68 + 2976);
          if ( v86 )
          {
LABEL_74:
            v88 = v86;
            do
            {
              v89 = (int *)(a1 + 3004 + 4LL * v87);
              do
              {
                v91 = *v89--;
                v90 = v91;
                --v87;
              }
              while ( (int)v91 > v64 );
              v92 = v63 + 4 * v90;
              v95 = *(unsigned __int16 *)(v92 + 2);
              v93 = (_WORD *)(v92 + 2);
              v94 = v95;
              if ( (_DWORD)v68 != v95 )
              {
                *v14 += (v68 - v94) * *(unsigned __int16 *)(v63 + 4 * v90);
                *v93 = v68;
              }
              --v88;
            }
            while ( v88 );
          }
        }
      }
    }
  }
  v96 = *(_WORD *)(a1 + 2982);
  v97 = *(_WORD *)(a1 + 2984);
  v98 = 2 * (2 * *(_WORD *)(a1 + 2976) + *(_WORD *)(a1 + 2978));
  v99 = *(_WORD *)(a1 + 2986);
  v100 = *(_WORD *)(a1 + 2988);
  v101 = 2 * (v98 + *(_WORD *)(a1 + 2980));
  v132 = 2 * *(_WORD *)(a1 + 2976);
  v133 = v98;
  v102 = 2 * (v101 + v96);
  v134 = v101;
  v103 = 2 * (v102 + v97);
  v104 = v103 + v99;
  v105 = *(_WORD *)(a1 + 2990);
  v104 *= 2;
  v135 = v102;
  v106 = v104 + v100;
  v107 = *(_WORD *)(a1 + 2992);
  v106 *= 2;
  v136 = v103;
  v108 = v106 + v105;
  v109 = *(_WORD *)(a1 + 2994);
  v108 *= 2;
  v137 = v104;
  v110 = v108 + v107;
  v111 = *(_WORD *)(a1 + 2996);
  v110 *= 2;
  v138 = v106;
  v112 = v110 + v109;
  v113 = *(_WORD *)(a1 + 2998);
  v112 *= 2;
  v139 = v108;
  v114 = v112 + v111;
  v115 = *(_WORD *)(a1 + 3000);
  v114 *= 2;
  v140 = v110;
  v116 = v114 + v113;
  v117 = *(_WORD *)(a1 + 3002);
  v116 *= 2;
  v141 = v112;
  v118 = v115 + v116;
  v119 = *(_WORD *)(a1 + 3004);
  v142 = v114;
  v143 = v116;
  v144 = 2 * v118;
  v145 = 2 * (v117 + 2 * v118);
  v146 = 2 * (v145 + v119);
  if ( (v11 & 0x80000000) == 0 )
  {
    v120 = 0LL;
    do
    {
      v121 = v6 + 4 * v120;
      v122 = *(unsigned __int16 *)(v121 + 2);
      if ( *(_WORD *)(v121 + 2) )
      {
        v123 = 2 * v122;
        v124 = 0;
        v125 = v122 + 1;
        v126 = *(unsigned __int16 *)&v131[v123];
        *(_WORD *)&v131[v123] = v126 + 1;
        do
        {
          v127 = v126 & 1;
          v126 >>= 1;
          v128 = v124 | v127;
          --v125;
          v124 = 2 * v128;
        }
        while ( v125 > 1 );
        *(_WORD *)(v6 + 4 * v120) = v128;
      }
      ++v120;
    }
    while ( v120 != v11 + 1 );
  }
  return result;
}


================================================================================
Function: sub_67E84A8 (0x67E84A8)
================================================================================

__int64 __fastcall sub_67E84A8(__int64 result, __int64 a2, __int64 a3)
{
  __int64 v3; // x8
  __int64 v4; // x5
  __int64 v5; // x19
  __int64 v6; // x5
  char v7; // w7
  __int64 v8; // x19
  int v9; // w3
  int v10; // w4
  int v11; // w3
  __int64 v12; // x6
  __int64 v13; // x7
  int v14; // w20
  __int64 v15; // x4
  unsigned int v16; // w19
  int v17; // w5
  int v18; // w4
  __int64 v19; // x20
  __int64 v20; // x22
  __int64 v21; // x4
  __int64 v22; // x22
  int v23; // w5
  unsigned __int16 *v24; // x3
  int v25; // w5
  unsigned int v26; // w4
  int v27; // w3
  int v28; // w6
  int v29; // w19
  int v30; // w6
  __int64 v31; // x7
  __int16 v32; // w4
  __int64 v33; // x20
  __int64 v34; // x4
  char v35; // w5
  __int64 v36; // x20
  int v37; // w5
  int v38; // w6
  unsigned int v39; // w6
  unsigned int v40; // w3
  __int64 v41; // x7
  unsigned __int16 *v42; // x3
  unsigned int v43; // w19
  int v44; // w3
  __int64 v45; // x5
  __int64 v46; // x21
  __int64 v47; // x4
  __int64 v48; // x21
  int v49; // w5
  unsigned int v50; // w6
  __int64 v51; // x7
  __int16 v52; // w3
  __int64 v53; // x19
  __int64 v54; // x3
  char v55; // w4
  __int64 v56; // x19
  char v57; // w4
  unsigned int v58; // w6
  unsigned int v59; // w9
  int v60; // w8
  int v61; // w11
  __int64 v62; // x12
  __int64 v63; // x14
  __int64 v64; // x12
  __int64 v65; // x14
  char v66; // w11
  int v67; // w11
  int v68; // w8

  if ( *(_DWORD *)(result + 5900) )
  {
    v3 = 0LL;
    while ( 1 )
    {
      v11 = *(unsigned __int16 *)(*(_QWORD *)(result + 5904) + 2 * v3);
      v12 = *(unsigned __int8 *)(*(_QWORD *)(result + 5888) + v3);
      if ( *(_WORD *)(*(_QWORD *)(result + 5904) + 2 * v3) )
      {
        v13 = byte_17448CE[v12];
        v14 = *(_DWORD *)(result + 5940);
        v15 = a2 + 4 * v13;
        v16 = *(unsigned __int16 *)(v15 + 1028);
        v17 = *(unsigned __int16 *)(v15 + 1030);
        v18 = *(unsigned __int16 *)(result + 5936) | (v16 << v14);
        *(_WORD *)(result + 5936) |= (_WORD)v16 << v14;
        if ( v14 <= 16 - v17 )
        {
          v23 = v14 + v17;
        }
        else
        {
          v19 = *(_QWORD *)(result + 40);
          v20 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v19 + 1;
          *(_BYTE *)(v20 + v19) = v18;
          v21 = *(_QWORD *)(result + 40);
          v22 = *(_QWORD *)(result + 16);
          LOBYTE(v19) = *(_BYTE *)(result + 5937);
          *(_QWORD *)(result + 40) = v21 + 1;
          *(_BYTE *)(v22 + v21) = v19;
          LODWORD(v19) = *(_DWORD *)(result + 5940);
          v23 = v17 + v19 - 16;
          v18 = v16 >> (16 - v19);
          *(_WORD *)(result + 5936) = v18;
        }
        *(_DWORD *)(result + 5940) = v23;
        if ( (unsigned __int64)(v13 - 28) >= 0xFFFFFFFFFFFFFFECLL )
        {
          v29 = dword_1744EC8[v13];
          v30 = v12 - dword_1745014[v13];
          if ( v23 <= 16 - v29 )
          {
            v38 = v30 << v23;
            v23 += v29;
            v18 |= v38;
          }
          else
          {
            v31 = *(_QWORD *)(result + 40);
            v32 = v18 | (v30 << v23);
            v33 = *(_QWORD *)(result + 16);
            *(_WORD *)(result + 5936) = v32;
            *(_QWORD *)(result + 40) = v31 + 1;
            *(_BYTE *)(v33 + v31) = v32;
            v34 = *(_QWORD *)(result + 40);
            v35 = *(_BYTE *)(result + 5937);
            v36 = *(_QWORD *)(result + 16);
            *(_QWORD *)(result + 40) = v34 + 1;
            *(_BYTE *)(v36 + v34) = v35;
            v37 = *(_DWORD *)(result + 5940);
            LOBYTE(v34) = 16 - v37;
            v23 = v29 + v37 - 16;
            v18 = (unsigned __int16)v30 >> v34;
          }
          *(_WORD *)(result + 5936) = v18;
          *(_DWORD *)(result + 5940) = v23;
        }
        v39 = v11 - 1;
        v40 = ((unsigned int)(v11 - 1) >> 7) + 256;
        if ( v39 < 0x100 )
          v40 = v39;
        v41 = (unsigned __int8)byte_17446CE[v40];
        v42 = (unsigned __int16 *)(a3 + 4 * v41);
        v43 = *v42;
        v44 = v42[1];
        v10 = v18 | (v43 << v23);
        *(_WORD *)(result + 5936) = v10;
        if ( v23 <= 16 - v44 )
        {
          v9 = v23 + v44;
        }
        else
        {
          v45 = *(_QWORD *)(result + 40);
          v46 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v45 + 1;
          *(_BYTE *)(v46 + v45) = v10;
          v47 = *(_QWORD *)(result + 40);
          v48 = *(_QWORD *)(result + 16);
          LOBYTE(v45) = *(_BYTE *)(result + 5937);
          *(_QWORD *)(result + 40) = v47 + 1;
          *(_BYTE *)(v48 + v47) = v45;
          LODWORD(v45) = *(_DWORD *)(result + 5940);
          v9 = v44 + v45 - 16;
          v10 = v43 >> (16 - v45);
          *(_WORD *)(result + 5936) = v10;
        }
        *(_DWORD *)(result + 5940) = v9;
        if ( (unsigned int)v41 < 4 )
          goto LABEL_6;
        v49 = dword_1744F3C[v41];
        v50 = v39 - dword_1745088[v41];
        if ( v9 <= 16 - v49 )
        {
          v58 = v50 << v9;
          v9 += v49;
          LOWORD(v10) = v10 | v58;
        }
        else
        {
          v51 = *(_QWORD *)(result + 40);
          v52 = v10 | (v50 << v9);
          v53 = *(_QWORD *)(result + 16);
          *(_WORD *)(result + 5936) = v52;
          *(_QWORD *)(result + 40) = v51 + 1;
          *(_BYTE *)(v53 + v51) = v52;
          v54 = *(_QWORD *)(result + 40);
          v55 = *(_BYTE *)(result + 5937);
          v56 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v54 + 1;
          *(_BYTE *)(v56 + v54) = v55;
          LODWORD(v54) = *(_DWORD *)(result + 5940);
          v57 = 16 - v54;
          v9 = v49 + v54 - 16;
          v10 = (unsigned __int16)v50 >> v57;
        }
      }
      else
      {
        v24 = (unsigned __int16 *)(a2 + 4 * v12);
        v25 = *(_DWORD *)(result + 5940);
        v26 = *v24;
        v27 = v24[1];
        v28 = *(unsigned __int16 *)(result + 5936) | (v26 << v25);
        *(_WORD *)(result + 5936) |= (_WORD)v26 << v25;
        if ( v25 <= 16 - v27 )
        {
          v9 = v25 + v27;
          goto LABEL_5;
        }
        v4 = *(_QWORD *)(result + 40);
        v5 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v4 + 1;
        *(_BYTE *)(v5 + v4) = v28;
        v6 = *(_QWORD *)(result + 40);
        v7 = *(_BYTE *)(result + 5937);
        v8 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v6 + 1;
        *(_BYTE *)(v8 + v6) = v7;
        LODWORD(v6) = *(_DWORD *)(result + 5940);
        v9 = v27 + v6 - 16;
        v10 = v26 >> (16 - v6);
      }
      *(_WORD *)(result + 5936) = v10;
LABEL_5:
      *(_DWORD *)(result + 5940) = v9;
LABEL_6:
      if ( ++v3 >= (unsigned __int64)*(unsigned int *)(result + 5900) )
        goto LABEL_28;
    }
  }
  v9 = *(_DWORD *)(result + 5940);
LABEL_28:
  v59 = *(unsigned __int16 *)(a2 + 1024);
  v60 = *(unsigned __int16 *)(a2 + 1026);
  v61 = *(unsigned __int16 *)(result + 5936) | (v59 << v9);
  *(_WORD *)(result + 5936) |= (_WORD)v59 << v9;
  if ( v9 <= 16 - v60 )
  {
    v68 = v9 + v60;
  }
  else
  {
    v62 = *(_QWORD *)(result + 40);
    v63 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v62 + 1;
    *(_BYTE *)(v63 + v62) = v61;
    v64 = *(_QWORD *)(result + 40);
    v65 = *(_QWORD *)(result + 16);
    v66 = *(_BYTE *)(result + 5937);
    *(_QWORD *)(result + 40) = v64 + 1;
    *(_BYTE *)(v65 + v64) = v66;
    v67 = *(_DWORD *)(result + 5940);
    v68 = v60 + v67 - 16;
    *(_WORD *)(result + 5936) = v59 >> (16 - v67);
  }
  *(_DWORD *)(result + 5940) = v68;
  return result;
}


================================================================================
Function: sub_67E8858 (0x67E8858)
================================================================================

__int64 __fastcall sub_67E8858(__int64 result, __int64 a2, int a3)
{
  int v3; // w15
  int v4; // w13
  __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x12
  __int64 v8; // x15
  __int64 v9; // x15
  __int64 v10; // x14
  __int64 v11; // x17
  unsigned int v12; // w3
  unsigned int v13; // w4
  unsigned int v14; // w3
  int v15; // w14
  unsigned int v16; // w16
  int v17; // w13
  unsigned int v18; // w15

  v3 = *(_DWORD *)(result + 5300);
  v4 = 2 * a3;
  v5 = *(int *)(result + 4LL * a3 + 3008);
  if ( 2 * a3 > v3 )
  {
    v6 = a3;
    goto LABEL_17;
  }
  v7 = result + 5308;
  while ( 1 )
  {
    if ( v4 >= v3 )
    {
      v15 = v4;
      v9 = v4;
      goto LABEL_12;
    }
    v9 = v4;
    v10 = *(int *)(result + 3008 + 4 * (v4 | 1LL));
    v11 = *(int *)(result + 3008 + 4LL * v4);
    v12 = *(unsigned __int16 *)(a2 + 4 * v10);
    v13 = *(unsigned __int16 *)(a2 + 4 * v11);
    if ( v12 < v13 )
    {
LABEL_10:
      v9 = v4 | 1LL;
      v15 = v4 | 1;
      goto LABEL_12;
    }
    if ( v12 == v13 )
    {
      v14 = *(unsigned __int8 *)(v7 + v10);
      v15 = v4;
      if ( v14 <= *(unsigned __int8 *)(v7 + v11) )
        goto LABEL_10;
    }
    else
    {
      v15 = v4;
    }
LABEL_12:
    v16 = *(unsigned __int16 *)(a2 + 4 * v5);
    v17 = *(_DWORD *)(result + 4 * v9 + 3008);
    v18 = *(unsigned __int16 *)(a2 + 4LL * v17);
    if ( v16 < v18
      || v16 == v18
      && *(unsigned __int8 *)(result + v5 + 5308) <= (unsigned int)*(unsigned __int8 *)(result + v17 + 5308) )
    {
      break;
    }
    v8 = result + 4LL * a3;
    a3 = v15;
    *(_DWORD *)(v8 + 3008) = v17;
    v4 = 2 * v15;
    v3 = *(_DWORD *)(result + 5300);
    if ( 2 * v15 > v3 )
      goto LABEL_16;
  }
  v15 = a3;
LABEL_16:
  v6 = v15;
LABEL_17:
  *(_DWORD *)(result + 4 * v6 + 3008) = v5;
  return result;
}


================================================================================
Function: sub_67E8964 (0x67E8964)
================================================================================

__int64 __fastcall sub_67E8964(__int64 result, __int64 a2, int a3)
{
  unsigned int v3; // w9
  __int64 v4; // x8
  int v5; // w4
  int v6; // w7
  int v7; // w6
  int v8; // w19
  unsigned int v9; // w3
  int v10; // w5
  __int64 v11; // x6
  int v12; // w7
  unsigned __int16 *v13; // x4
  unsigned __int16 *v14; // x6
  unsigned int v15; // w20
  int v16; // w19
  int v17; // w21
  __int64 v18; // x7
  __int64 v19; // x23
  __int64 v20; // x7
  char v21; // w22
  __int64 v22; // x23
  char v23; // w21
  int v24; // w6
  int v25; // w19
  unsigned int v26; // w7
  int v27; // w6
  int v28; // w5
  __int64 v29; // x19
  __int64 v30; // x21
  __int64 v31; // x5
  __int64 v32; // x21
  int v33; // w6
  __int64 v34; // x5
  int v35; // w7
  unsigned int v36; // w6
  int v37; // w5
  int v38; // w19
  __int64 v39; // x7
  __int64 v40; // x21
  __int64 v41; // x7
  __int64 v42; // x21
  char v43; // w19
  unsigned int v44; // w19
  int v45; // w19
  unsigned int v46; // w7
  int v47; // w6
  __int64 v48; // x19
  __int64 v49; // x21
  __int64 v50; // x5
  __int64 v51; // x21
  int v52; // w6
  unsigned int v53; // w19
  int v54; // w7
  int v55; // w5
  __int64 v56; // x6
  __int64 v57; // x21
  __int64 v58; // x5
  __int64 v59; // x21
  int v60; // w7
  int v61; // w6
  int v62; // w4
  __int64 v63; // x7
  __int16 v64; // w5
  __int64 v65; // x19
  __int64 v66; // x5
  char v67; // w6
  __int64 v68; // x19
  int v69; // w6
  int v70; // w4
  int v71; // w4
  int v72; // w7
  __int64 v73; // x6
  __int16 v74; // w5
  __int64 v75; // x19
  __int64 v76; // x5
  __int64 v77; // x19
  int v78; // w4
  int v79; // w7
  __int64 v80; // x6
  __int16 v81; // w5
  __int64 v82; // x19
  __int64 v83; // x5
  __int64 v84; // x19

  if ( (a3 & 0x80000000) == 0 )
  {
    v3 = *(unsigned __int16 *)(a2 + 2);
    v4 = 0LL;
    v5 = 0;
    if ( *(_WORD *)(a2 + 2) )
      v6 = 7;
    else
      v6 = 138;
    if ( *(_WORD *)(a2 + 2) )
      v7 = 4;
    else
      v7 = 3;
    v8 = -1;
    while ( 1 )
    {
      ++v4;
      v9 = v3;
      v3 = *(unsigned __int16 *)(a2 + 4 * v4 + 2);
      v10 = v5 + 1;
      if ( v5 + 1 >= v6 || v9 != v3 )
        break;
      v9 = v8;
LABEL_10:
      v8 = v9;
      v5 = v10;
      if ( v4 == a3 + 1 )
        return result;
    }
    if ( v10 < v7 )
    {
      v11 = result + 4LL * v9;
      v12 = *(_DWORD *)(result + 5940);
      v13 = (unsigned __int16 *)(v11 + 2750);
      v14 = (unsigned __int16 *)(v11 + 2748);
      do
      {
        v15 = *v14;
        v16 = *v13;
        v17 = *(unsigned __int16 *)(result + 5936) | (v15 << v12);
        *(_WORD *)(result + 5936) |= (_WORD)v15 << v12;
        if ( v12 <= 16 - v16 )
        {
          v12 += v16;
        }
        else
        {
          v18 = *(_QWORD *)(result + 40);
          v19 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v18 + 1;
          *(_BYTE *)(v19 + v18) = v17;
          v20 = *(_QWORD *)(result + 40);
          v21 = *(_BYTE *)(result + 5937);
          v22 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v20 + 1;
          *(_BYTE *)(v22 + v20) = v21;
          LODWORD(v20) = *(_DWORD *)(result + 5940);
          v23 = 16 - v20;
          v12 = v16 + v20 - 16;
          *(_WORD *)(result + 5936) = v15 >> v23;
        }
        --v10;
        *(_DWORD *)(result + 5940) = v12;
      }
      while ( v10 );
      goto LABEL_47;
    }
    if ( v9 )
    {
      if ( v9 == v8 )
      {
        v24 = *(_DWORD *)(result + 5940);
        ++v5;
      }
      else
      {
        v34 = result + 4LL * v9;
        v35 = *(_DWORD *)(result + 5940);
        v36 = *(unsigned __int16 *)(v34 + 2748);
        v37 = *(unsigned __int16 *)(v34 + 2750);
        v38 = *(unsigned __int16 *)(result + 5936) | (v36 << v35);
        *(_WORD *)(result + 5936) |= (_WORD)v36 << v35;
        if ( v35 <= 16 - v37 )
        {
          v24 = v35 + v37;
        }
        else
        {
          v39 = *(_QWORD *)(result + 40);
          v40 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v39 + 1;
          *(_BYTE *)(v40 + v39) = v38;
          v41 = *(_QWORD *)(result + 40);
          v42 = *(_QWORD *)(result + 16);
          v43 = *(_BYTE *)(result + 5937);
          *(_QWORD *)(result + 40) = v41 + 1;
          *(_BYTE *)(v42 + v41) = v43;
          LODWORD(v41) = *(_DWORD *)(result + 5940);
          v44 = v36 >> (16 - v41);
          v24 = v37 + v41 - 16;
          *(_WORD *)(result + 5936) = v44;
        }
        *(_DWORD *)(result + 5940) = v24;
      }
      v53 = *(unsigned __int16 *)(result + 2812);
      v54 = *(unsigned __int16 *)(result + 2814);
      v55 = *(unsigned __int16 *)(result + 5936) | (v53 << v24);
      if ( v24 <= 16 - v54 )
      {
        v61 = v24 + v54;
      }
      else
      {
        v56 = *(_QWORD *)(result + 40);
        *(_WORD *)(result + 5936) = v55;
        v57 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v56 + 1;
        *(_BYTE *)(v57 + v56) = v55;
        v58 = *(_QWORD *)(result + 40);
        v59 = *(_QWORD *)(result + 16);
        LOBYTE(v56) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v58 + 1;
        *(_BYTE *)(v59 + v58) = v56;
        LODWORD(v58) = *(_DWORD *)(result + 5940);
        v60 = v54 + v58;
        v55 = v53 >> (16 - v58);
        v61 = v60 - 16;
      }
      v62 = v5 + 65533;
      *(_DWORD *)(result + 5940) = v61;
      if ( v61 >= 15 )
      {
        v63 = *(_QWORD *)(result + 40);
        v64 = v55 | (v62 << v61);
        v65 = *(_QWORD *)(result + 16);
        *(_WORD *)(result + 5936) = v64;
        *(_QWORD *)(result + 40) = v63 + 1;
        *(_BYTE *)(v65 + v63) = v64;
        v66 = *(_QWORD *)(result + 40);
        v67 = *(_BYTE *)(result + 5937);
        v68 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v66 + 1;
        *(_BYTE *)(v68 + v66) = v67;
        LODWORD(v66) = *(_DWORD *)(result + 5940);
        v69 = (unsigned __int16)v62 >> (16 - v66);
        v70 = v66 - 14;
        *(_WORD *)(result + 5936) = v69;
LABEL_46:
        *(_DWORD *)(result + 5940) = v70;
LABEL_47:
        v10 = 0;
        if ( v3 )
        {
          if ( v9 == v3 )
            v7 = 3;
          else
            v7 = 4;
          if ( v9 == v3 )
            v6 = 6;
          else
            v6 = 7;
        }
        else
        {
          v6 = 138;
          v7 = 3;
        }
        goto LABEL_10;
      }
      v28 = v55 | (v62 << v61);
      v70 = v61 + 2;
    }
    else if ( v5 > 9 )
    {
      v45 = *(_DWORD *)(result + 5940);
      v46 = *(unsigned __int16 *)(result + 2820);
      v47 = *(unsigned __int16 *)(result + 2822);
      v28 = *(unsigned __int16 *)(result + 5936) | (v46 << v45);
      if ( v45 <= 16 - v47 )
      {
        v52 = v45 + v47;
      }
      else
      {
        v48 = *(_QWORD *)(result + 40);
        *(_WORD *)(result + 5936) = v28;
        v49 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v48 + 1;
        *(_BYTE *)(v49 + v48) = v28;
        v50 = *(_QWORD *)(result + 40);
        v51 = *(_QWORD *)(result + 16);
        LOBYTE(v48) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v50 + 1;
        *(_BYTE *)(v51 + v50) = v48;
        LODWORD(v50) = *(_DWORD *)(result + 5940);
        v52 = v47 + v50 - 16;
        v28 = v46 >> (16 - v50);
      }
      v78 = v5 + 65526;
      v79 = v78 << v52;
      *(_DWORD *)(result + 5940) = v52;
      if ( v52 >= 10 )
      {
        v80 = *(_QWORD *)(result + 40);
        v81 = v28 | v79;
        v82 = *(_QWORD *)(result + 16);
        *(_WORD *)(result + 5936) = v81;
        *(_QWORD *)(result + 40) = v80 + 1;
        *(_BYTE *)(v82 + v80) = v81;
        v83 = *(_QWORD *)(result + 40);
        v84 = *(_QWORD *)(result + 16);
        LOBYTE(v80) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v83 + 1;
        *(_BYTE *)(v84 + v83) = v80;
        LODWORD(v83) = *(_DWORD *)(result + 5940);
        LODWORD(v80) = (unsigned __int16)v78 >> (16 - v83);
        v70 = v83 - 9;
        *(_WORD *)(result + 5936) = v80;
        goto LABEL_46;
      }
      LOWORD(v28) = v28 | v79;
      v70 = v52 + 7;
    }
    else
    {
      v25 = *(_DWORD *)(result + 5940);
      v26 = *(unsigned __int16 *)(result + 2816);
      v27 = *(unsigned __int16 *)(result + 2818);
      v28 = *(unsigned __int16 *)(result + 5936) | (v26 << v25);
      if ( v25 <= 16 - v27 )
      {
        v33 = v25 + v27;
      }
      else
      {
        v29 = *(_QWORD *)(result + 40);
        *(_WORD *)(result + 5936) = v28;
        v30 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v29 + 1;
        *(_BYTE *)(v30 + v29) = v28;
        v31 = *(_QWORD *)(result + 40);
        v32 = *(_QWORD *)(result + 16);
        LOBYTE(v29) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v31 + 1;
        *(_BYTE *)(v32 + v31) = v29;
        LODWORD(v31) = *(_DWORD *)(result + 5940);
        v33 = v27 + v31 - 16;
        v28 = v26 >> (16 - v31);
      }
      v71 = v5 + 65534;
      v72 = v71 << v33;
      *(_DWORD *)(result + 5940) = v33;
      if ( v33 >= 14 )
      {
        v73 = *(_QWORD *)(result + 40);
        v74 = v28 | v72;
        v75 = *(_QWORD *)(result + 16);
        *(_WORD *)(result + 5936) = v74;
        *(_QWORD *)(result + 40) = v73 + 1;
        *(_BYTE *)(v75 + v73) = v74;
        v76 = *(_QWORD *)(result + 40);
        v77 = *(_QWORD *)(result + 16);
        LOBYTE(v73) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v76 + 1;
        *(_BYTE *)(v77 + v76) = v73;
        LODWORD(v76) = *(_DWORD *)(result + 5940);
        LODWORD(v73) = (unsigned __int16)v71 >> (16 - v76);
        v70 = v76 - 13;
        *(_WORD *)(result + 5936) = v73;
        goto LABEL_46;
      }
      LOWORD(v28) = v28 | v72;
      v70 = v33 + 3;
    }
    *(_WORD *)(result + 5936) = v28;
    goto LABEL_46;
  }
  return result;
}


================================================================================
Function: sub_67ED414 (0x67ED414)
================================================================================

_DWORD *__fastcall sub_67ED414(_DWORD *result, unsigned int *a2)
{
  unsigned __int64 v2; // x11
  unsigned __int64 v3; // x13
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x15
  unsigned __int64 v6; // x16
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x12
  __int64 v9; // x3
  unsigned __int64 v10; // x4
  unsigned __int64 v11; // x1
  unsigned __int64 v12; // x13
  unsigned __int64 v13; // x15
  unsigned __int64 v14; // x16
  unsigned __int64 v15; // x4

  v2 = (*((unsigned __int8 *)a2 + 4) << 6) & 0x3FFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 5) << 14) & 0xFFFFFFFFC03FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 6) << 22);
  v3 = (32 * *((unsigned __int8 *)a2 + 7)) & 0x1FFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 8) << 13) & 0xFFFFFFFFE01FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 9) << 21);
  v4 = (8 * *((unsigned __int8 *)a2 + 10)) & 0x7FF | ((unsigned __int64)*((unsigned __int8 *)a2 + 11) << 11) & 0xFFFFFFFFF807FFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 12) << 19);
  v5 = (4 * *((unsigned __int8 *)a2 + 13)) & 0x3FF | ((unsigned __int64)*((unsigned __int8 *)a2 + 14) << 10) & 0xFFFFFFFFFC03FFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 15) << 18);
  v6 = (*((unsigned __int8 *)a2 + 20) << 7) & 0x7FFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 21) << 15) & 0xFFFFFFFF807FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 22) << 23);
  v7 = (32 * *((unsigned __int8 *)a2 + 23)) & 0x1FFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 24) << 13) & 0xFFFFFFFFE01FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 25) << 21);
  v8 = (4 * *((unsigned __int8 *)a2 + 29)) & 0x3FF | ((unsigned __int64)*((unsigned __int8 *)a2 + 30) << 10) | (*((unsigned __int8 *)a2 + 31) << 18) & 0x1FC0000;
  v9 = a2[4];
  v10 = (16 * *((unsigned __int8 *)a2 + 26)) & 0xFFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 27) << 12) & 0xFFFFFFFFF00FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 28) << 20);
  v11 = *a2 + 19 * ((v8 + 0x1000000) >> 25);
  v12 = v3 + ((v2 + 0x1000000) >> 25);
  v13 = v5 + ((v4 + 0x1000000) >> 25);
  v14 = v6 + ((unsigned __int64)(v9 + 0x1000000) >> 25);
  v15 = v10 + ((v7 + 0x1000000) >> 25);
  *result = v11 - ((v11 + 0x2000000) & 0xFC000000);
  result[1] = v2 - ((v2 + 0x1000000) & 0x7E000000) + ((v11 + 0x2000000) >> 26);
  result[2] = v12 - ((v12 + 0x2000000) & 0xFC000000);
  result[3] = ((v12 + 0x2000000) >> 26) + v4 - ((v4 + 0x1000000) & 0xE000000);
  result[6] = v14 - ((v14 + 0x2000000) & 0xFC000000);
  result[7] = ((v14 + 0x2000000) >> 26) + v7 - ((v7 + 0x1000000) & 0x3E000000);
  result[4] = v13 - ((v13 + 0x2000000) & 0xFC000000);
  result[5] = v9 + ((v13 + 0x2000000) >> 26) - ((v9 + 0x1000000) & 0xFE000000);
  result[8] = v15 - ((v15 + 0x2000000) & 0xFC000000);
  result[9] = v8 + ((v15 + 0x2000000) >> 26) - ((v8 + 0x1000000) & 0x2000000);
  return result;
}


================================================================================
Function: sub_67ED5C0 (0x67ED5C0)
================================================================================

_BYTE *__fastcall sub_67ED5C0(_BYTE *result, _DWORD *a2)
{
  int v2; // w8
  int v3; // w15
  int v4; // w16
  int v5; // w17
  int v6; // w2
  int v7; // w12
  int v8; // w10
  int v9; // w11
  int v10; // w9
  unsigned int v11; // w13
  unsigned int v12; // w14
  unsigned int v13; // w1
  unsigned int v14; // w15
  unsigned int v15; // w3
  char v16; // w4
  unsigned int v17; // w13
  unsigned int v18; // w5
  int v19; // w6
  unsigned int v20; // w15
  unsigned int v21; // w16
  unsigned int v22; // w1
  int v23; // w7
  unsigned int v24; // w15
  unsigned int v25; // w17
  unsigned int v26; // w4
  unsigned int v27; // w15
  int v28; // w12
  unsigned int v29; // w11
  unsigned int v30; // w10
  unsigned int v31; // w9
  unsigned int v32; // w8

  v2 = a2[9];
  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  v6 = a2[4];
  v7 = a2[5];
  v9 = a2[6];
  v8 = a2[7];
  v10 = a2[8];
  v11 = *a2
      + 19
      * ((v2
        + ((v10
          + ((v8
            + ((v9
              + ((v7
                + ((v6
                  + ((v5 + ((v4 + ((v3 + ((int)(*a2 + ((unsigned int)(19 * v2 + 0x1000000) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25);
  v12 = v11 >> 8;
  v13 = HIWORD(v11);
  v14 = v3 + ((int)v11 >> 26);
  v15 = HIBYTE(v11);
  v16 = v14;
  *result = v11;
  v17 = v14 >> 6;
  v18 = v14 >> 14;
  v19 = (v14 >> 22) & 7;
  v20 = v4 + ((int)v14 >> 25);
  result[1] = v12;
  LOBYTE(v12) = v20;
  result[2] = v13;
  v21 = v20 >> 5;
  v22 = v20 >> 13;
  v23 = (v20 >> 21) & 0x1F;
  v24 = v5 + ((int)v20 >> 26);
  LOBYTE(v15) = v15 & 3 | (4 * v16);
  result[4] = v17;
  LOBYTE(v17) = v24;
  result[5] = v18;
  v25 = v24 >> 3;
  v26 = v24 >> 11;
  LOBYTE(v18) = (v24 >> 19) & 0x3F;
  v27 = v6 + ((int)v24 >> 25);
  result[7] = v21;
  v28 = v7 + ((int)v27 >> 26);
  result[8] = v22;
  v29 = v9 + (v28 >> 25);
  result[10] = v25;
  v30 = v8 + ((int)v29 >> 26);
  result[13] = v27 >> 2;
  result[14] = v27 >> 10;
  result[16] = v28;
  v31 = v10 + ((int)v30 >> 25);
  result[15] = v27 >> 18;
  result[17] = BYTE1(v28);
  v32 = v2 + ((int)v31 >> 26);
  result[18] = BYTE2(v28);
  result[20] = v29 >> 7;
  result[21] = v29 >> 15;
  result[26] = v31 >> 4;
  result[3] = v15;
  result[11] = v26;
  result[6] = v19 & 7 | (8 * v12);
  result[9] = v23 & 0x1F | (32 * v17);
  result[12] = v18 & 0x3F | ((_BYTE)v27 << 6);
  result[23] = v30 >> 5;
  result[24] = v30 >> 13;
  result[19] = HIBYTE(v28) & 1 | (2 * v29);
  result[27] = v31 >> 12;
  result[22] = (v29 >> 23) & 7 | (8 * v30);
  result[29] = v32 >> 2;
  result[30] = v32 >> 10;
  result[25] = (v30 >> 21) & 0xF | (16 * v31);
  result[28] = (v31 >> 20) & 0x3F | ((_BYTE)v32 << 6);
  result[31] = (v32 >> 18) & 0x7F;
  return result;
}


================================================================================
Function: sub_67ED770 (0x67ED770)
================================================================================

__int64 __fastcall sub_67ED770(__int64 a1, __int64 a2)
{
  int v4; // w20
  int v5; // w20
  int v6; // w20
  _BYTE v8[40]; // [xsp+8h] [xbp-A8h] BYREF
  _BYTE v9[40]; // [xsp+30h] [xbp-80h] BYREF
  _BYTE v10[40]; // [xsp+58h] [xbp-58h] BYREF
  _BYTE v11[40]; // [xsp+80h] [xbp-30h] BYREF

  sub_67EDB64(v11, a2);
  sub_67EDB64(v10, v11);
  sub_67EDB64(v10, v10);
  sub_67EDDA8(v10, a2, v10);
  sub_67EDDA8(v11, v11, v10);
  sub_67EDB64(v9, v11);
  sub_67EDDA8(v10, v10, v9);
  sub_67EDB64(v9, v10);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDDA8(v10, v9, v10);
  sub_67EDB64(v9, v10);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDDA8(v9, v9, v10);
  sub_67EDB64(v8, v9);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDDA8(v9, v8, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDDA8(v10, v9, v10);
  sub_67EDB64(v9, v10);
  v4 = 49;
  do
  {
    sub_67EDB64(v9, v9);
    --v4;
  }
  while ( v4 );
  sub_67EDDA8(v9, v9, v10);
  sub_67EDB64(v8, v9);
  v5 = 99;
  do
  {
    sub_67EDB64(v8, v8);
    --v5;
  }
  while ( v5 );
  sub_67EDDA8(v9, v8, v9);
  sub_67EDB64(v9, v9);
  v6 = 49;
  do
  {
    sub_67EDB64(v9, v9);
    --v6;
  }
  while ( v6 );
  sub_67EDDA8(v10, v9, v10);
  sub_67EDB64(v10, v10);
  sub_67EDB64(v10, v10);
  sub_67EDB64(v10, v10);
  sub_67EDB64(v10, v10);
  sub_67EDB64(v10, v10);
  return sub_67EDDA8(a1, v10, v11);
}


================================================================================
Function: sub_67EDB64 (0x67EDB64)
================================================================================

_DWORD *__fastcall sub_67EDB64(_DWORD *result, int *a2)
{
  __int64 v2; // x3
  __int64 v3; // x11
  __int64 v4; // x5
  __int64 v5; // x9
  __int64 v6; // x2
  __int64 v7; // x14
  __int64 v8; // x13
  __int64 v9; // x20
  __int64 v10; // x11
  __int64 v11; // x12
  __int64 v12; // x16
  __int64 v13; // x22
  __int64 v14; // x4
  __int64 v15; // x1
  __int64 v16; // x15
  __int64 v17; // x6
  __int64 v18; // x24
  __int64 v19; // x26
  __int64 v20; // x27
  __int64 v21; // x19
  __int64 v22; // x7
  __int64 v23; // x23
  __int64 v24; // x25
  __int64 v25; // x21
  __int64 v26; // x20
  __int64 v27; // x5
  __int64 v28; // x22
  __int64 v29; // x9
  __int64 v30; // x24
  __int64 v31; // x7
  __int64 v32; // x21
  __int64 v33; // x25
  __int64 v34; // x20
  __int64 v35; // x9
  __int64 v36; // x2
  __int64 v37; // x14
  __int64 v38; // x9
  __int64 v39; // x13
  unsigned __int64 v40; // x8
  __int64 v41; // x15
  __int64 v42; // x10
  unsigned __int64 v43; // x11

  v3 = *a2;
  v2 = a2[1];
  v4 = a2[5];
  v5 = a2[6];
  v6 = a2[7];
  v7 = a2[8];
  v8 = 2 * v3;
  v9 = v3 * v3;
  v10 = a2[4];
  v11 = a2[9];
  v12 = a2[2];
  v13 = a2[3];
  v14 = 2 * v4;
  v15 = 2 * v13;
  v16 = 19 * v7;
  v17 = 2 * v2 * v2 + v12 * v8 + 19 * v5 * v5 + 38 * v6 * 2 * v4 + 19 * v7 * 2 * v10;
  v18 = 2 * v10 * v4;
  v19 = v9 + 38 * v4 * v4 + 19 * v5 * 2 * v10 + 38 * v6 * 2 * v13;
  v20 = v12 * v12 + 2 * v13 * 2 * v2 + v10 * v8 + 38 * v6 * v6;
  v21 = v8 * v2 + 19 * v5 * 2 * v4 + 38 * v6 * v10;
  v22 = 2 * v2 * v12 + v13 * v8 + 38 * v6 * v5;
  v23 = 2 * v6;
  v24 = v5 * 19 * v7;
  v25 = 2 * v12 * v13 + v10 * 2 * v2 + v4 * v8 + 19 * v7 * 2 * v6 + 38 * v11 * v5;
  v26 = v10 * 2 * v12 + 2 * v13 * v13 + 2 * v4 * 2 * v2 + v5 * v8;
  v27 = 2 * v13 * v10 + v4 * 2 * v12 + v5 * 2 * v2;
  v28 = v10 * v10 + v5 * 2 * v12;
  v29 = v18 + v5 * v15;
  v30 = v20 + 2 * v24 + 38 * v11 * v14;
  v31 = v22 + 19 * v7 * v14;
  v32 = v25 + ((v30 + 0x2000000) >> 26);
  v33 = v19 + 19 * v7 * 2 * v12 + 38 * v11 * 2 * v2;
  v34 = v26 + 19 * v7 * v7 + 38 * v11 * 2 * v6 + ((v32 + 0x1000000) >> 25);
  v35 = v29 + v6 * 2 * v12 + v7 * 2 * v2;
  v36 = v27 + v6 * v8 + 38 * v11 * v7 + ((v34 + 0x2000000) >> 26);
  v37 = v28 + v14 * v15 + v23 * 2 * v2 + v7 * v8 + 38 * v11 * v11 + ((v36 + 0x1000000) >> 25);
  v38 = v35 + v11 * v8 + ((v37 + 0x2000000) >> 26);
  v39 = v21 + v16 * v15 + 38 * v11 * v12 + ((v33 + 0x2000000) >> 26);
  v40 = v33 - ((v33 + 0x2000000) & 0xFFFFFFFFFC000000LL) + 19 * ((v38 + 0x1000000) >> 25);
  v41 = v17 + 38 * v11 * v15 + ((v39 + 0x1000000) >> 25);
  v42 = v31 + 38 * v11 * v10 + ((v41 + 0x2000000) >> 26);
  result[6] = v34 - ((v34 + 0x2000000) & 0xFC000000);
  result[7] = v36 - ((v36 + 0x1000000) & 0xFE000000);
  v43 = v30 - ((v30 + 0x2000000) & 0xFFFFFFFFFC000000LL) + ((v42 + 0x1000000) >> 25);
  result[2] = v41 - ((v41 + 0x2000000) & 0xFC000000);
  result[3] = v42 - ((v42 + 0x1000000) & 0xFE000000);
  *result = v40 - ((v40 + 0x2000000) & 0xFC000000);
  result[1] = v39 - ((v39 + 0x1000000) & 0xFE000000) + ((v40 + 0x2000000) >> 26);
  result[4] = v43 - ((v43 + 0x2000000) & 0xFC000000);
  result[5] = v32 - ((v32 + 0x1000000) & 0xFE000000) + ((v43 + 0x2000000) >> 26);
  result[8] = v37 - ((v37 + 0x2000000) & 0xFC000000);
  result[9] = v38 - ((v38 + 0x1000000) & 0xFE000000);
  return result;
}


================================================================================
Function: sub_67EDDA8 (0x67EDDA8)
================================================================================

__int64 __fastcall sub_67EDDA8(_DWORD *a1, int *a2, int *a3)
{
  __int64 v3; // x10
  __int64 v4; // x13
  __int64 v5; // x17
  __int64 v6; // x20
  __int64 v7; // x3
  __int64 v8; // x7
  __int64 v9; // x15
  __int64 v10; // x16
  __int64 v11; // x4
  __int64 v12; // x5
  __int64 result; // x0
  __int64 v14; // x19
  __int64 v15; // x14
  __int64 v16; // x21
  __int64 v17; // x22
  __int64 v18; // x24
  __int64 v19; // x1
  __int64 v20; // x29
  __int64 v21; // x30
  __int64 v22; // x23
  __int64 v23; // x28
  __int64 v24; // x27
  __int64 v25; // x12
  __int64 v26; // x8
  __int64 v27; // x20
  __int64 v28; // x11
  __int64 v29; // x8
  __int64 v30; // x9
  __int64 v31; // x27
  __int64 v32; // x10
  __int64 v33; // x2
  __int64 v34; // x17
  __int64 v35; // x11
  __int64 v36; // x20
  __int64 v37; // x17
  __int64 v38; // x10
  __int64 v39; // x16
  __int64 v40; // x11
  __int64 v41; // x14
  __int64 v42; // x9
  __int64 v43; // x10
  __int64 v44; // x14
  __int64 v45; // x17
  __int64 v46; // x15
  __int64 v47; // x16
  __int64 v48; // x11
  __int64 v49; // x9
  __int64 v50; // x13
  __int64 v51; // x10
  __int64 v52; // x1
  unsigned __int64 v53; // x16
  __int64 v54; // x8
  unsigned __int64 v55; // x14
  __int64 v56; // [xsp+8h] [xbp-A8h]
  __int64 v57; // [xsp+18h] [xbp-98h]
  __int64 v58; // [xsp+20h] [xbp-90h]
  __int64 v59; // [xsp+28h] [xbp-88h]
  __int64 v60; // [xsp+30h] [xbp-80h]
  __int64 v61; // [xsp+38h] [xbp-78h]
  __int64 v62; // [xsp+40h] [xbp-70h]

  v4 = a2[8];
  v3 = a2[9];
  v6 = *a3;
  v5 = a3[1];
  v7 = *a2;
  v8 = a2[1];
  v10 = a3[2];
  v9 = a3[3];
  v11 = a3[4];
  v12 = a3[5];
  result = a2[2];
  v14 = a2[7];
  v62 = 2 * v3;
  v15 = a2[3];
  v56 = v15;
  v16 = a2[4];
  v17 = a2[5];
  v18 = a2[6];
  v19 = 2 * v15;
  v20 = a3[6];
  v21 = a3[7];
  v22 = v6 * v16 + v5 * 2 * v15 + v10 * result + v9 * 2 * v8 + v11 * v7 + 19 * v12 * 2 * v3 + 19 * v20 * v4;
  v23 = v6 * v17 + v5 * v16 + v10 * v15 + v9 * result + v11 * v8 + v12 * v7 + 19 * v20 * v3;
  v59 = v6 * v7
      + 19 * v5 * 2 * v3
      + 19 * v10 * v4
      + 19 * v9 * 2 * v14
      + 19 * v11 * v18
      + 19 * v12 * 2 * v17
      + 19 * v20 * v16;
  v60 = v3;
  v61 = v6 * v8 + v5 * v7 + 19 * v10 * v3 + 19 * v9 * v4 + 19 * v11 * v14 + 19 * v12 * v18 + 19 * v20 * v17;
  v24 = v6 * v18;
  v25 = v6 * v4;
  v57 = v6 * result + v5 * 2 * v8 + v10 * v7 + 19 * v9 * 2 * v3 + 19 * v11 * v4 + 19 * v12 * 2 * v14 + 19 * v20 * v18;
  v58 = v6 * v15 + v5 * result + v10 * v8 + v9 * v7 + 19 * v11 * v3 + 19 * v12 * v4 + 19 * v20 * v14;
  v26 = v6 * v14;
  v27 = v6 * v3;
  v28 = v26 + v5 * v18;
  v30 = a3[8];
  v29 = a3[9];
  v31 = v24 + v5 * 2 * v17;
  v32 = v25 + v5 * 2 * v14;
  v33 = 19 * v30;
  v34 = v27 + v5 * v4;
  v35 = v28 + v10 * v17;
  v36 = v23 + 19 * v21 * v4 + 19 * v30 * v14;
  v37 = v34 + v10 * v14;
  v38 = v32 + v10 * v18;
  v39 = v31 + v10 * v16 + v9 * 2 * v15;
  v40 = v35 + v9 * v16;
  v41 = v37 + v9 * v18 + v11 * v17 + v12 * v16 + v20 * v15 + v21 * result + v30 * v8;
  v42 = v38 + v9 * 2 * v17 + v11 * v16 + v12 * v19 + v20 * result + v21 * 2 * v8 + v30 * v7;
  v43 = v41 + v29 * v7;
  v29 *= 19LL;
  v44 = v22 + 19 * v21 * 2 * v14 + v33 * v18 + v29 * 2 * v17;
  v45 = v36 + v29 * v18 + ((v44 + 0x2000000) >> 26);
  v46 = v39
      + v11 * result
      + v12 * 2 * v8
      + v20 * v7
      + 19 * v21 * v62
      + v33 * v4
      + v29 * 2 * v14
      + ((v45 + 0x1000000) >> 25);
  v47 = v59 + 19 * v21 * v19 + v33 * result + v29 * 2 * v8;
  v48 = v40 + v11 * v56 + v12 * result + v20 * v8 + v21 * v7 + v33 * v60 + v29 * v4 + ((v46 + 0x2000000) >> 26);
  v49 = v42 + v29 * v62 + ((v48 + 0x1000000) >> 25);
  v50 = v61 + 19 * v21 * v16 + v33 * v56 + v29 * result + ((v47 + 0x2000000) >> 26);
  v51 = v43 + ((v49 + 0x2000000) >> 26);
  v52 = v57 + 19 * v21 * 2 * v17 + v33 * v16 + v29 * v19 + ((v50 + 0x1000000) >> 25);
  v53 = v47 - ((v47 + 0x2000000) & 0xFFFFFFFFFC000000LL) + 19 * ((v51 + 0x1000000) >> 25);
  v54 = v58 + 19 * v21 * v18 + v33 * v17 + v29 * v16 + ((v52 + 0x2000000) >> 26);
  v55 = v44 - ((v44 + 0x2000000) & 0xFFFFFFFFFC000000LL) + ((v54 + 0x1000000) >> 25);
  a1[2] = v52 - ((v52 + 0x2000000) & 0xFC000000);
  a1[3] = v54 - ((v54 + 0x1000000) & 0xFE000000);
  *a1 = v53 - ((v53 + 0x2000000) & 0xFC000000);
  a1[1] = v50 - ((v50 + 0x1000000) & 0xFE000000) + ((v53 + 0x2000000) >> 26);
  a1[6] = v46 - ((v46 + 0x2000000) & 0xFC000000);
  a1[7] = v48 - ((v48 + 0x1000000) & 0xFE000000);
  a1[4] = v55 - ((v55 + 0x2000000) & 0xFC000000);
  a1[5] = v45 - ((v45 + 0x1000000) & 0xFE000000) + ((v55 + 0x2000000) >> 26);
  a1[8] = v49 - ((v49 + 0x2000000) & 0xFC000000);
  a1[9] = v51 - ((v51 + 0x1000000) & 0xFE000000);
  return result;
}


================================================================================
Function: sub_67EE140 (0x67EE140)
================================================================================

__int64 __fastcall sub_67EE140(__int64 a1, __int64 a2, int *a3)
{
  __int64 v4; // x22
  int *v5; // x21
  int32x4_t v6; // q1
  unsigned __int64 v7; // d2
  int32x4_t v8; // q3
  int32x4_t v9; // q1
  int32x2_t v10; // d4
  int32x2_t v11; // d5
  int *v12; // x20
  int v13; // w10
  int v14; // w12
  int v15; // w13
  int v16; // w16
  int v17; // w14
  int v18; // w15
  int v19; // w0
  int v20; // w1
  int v21; // w11
  int v22; // w4
  int v23; // w17
  int v24; // w23
  int v25; // w8
  int v26; // w25
  int v27; // w27
  int v28; // w10
  int v29; // w6
  int v30; // w5
  int v31; // w7
  int v32; // w11
  int v33; // w3
  int v34; // w30
  int v35; // w10
  int v36; // w2
  int v37; // w24
  int v38; // w26
  int v39; // w12
  int v40; // w9
  int v41; // w14
  int v42; // w13
  int v43; // w2
  int v44; // w8
  int v45; // w15
  int v46; // w16
  int v47; // w6
  __int64 result; // x0
  int v49; // w5
  int v50; // w7
  int v51; // [xsp+8h] [xbp-8h]
  int v52; // [xsp+Ch] [xbp-4h]

  v4 = a2;
  v5 = a3;
  v6 = vaddq_s32(*(int32x4_t *)(a2 + 16), *(int32x4_t *)(a2 + 56));
  v7 = vadd_s32(*(int32x2_t *)(a2 + 32), *(int32x2_t *)(a2 + 72)).n64_u64[0];
  *(int32x4_t *)a1 = vaddq_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 40));
  *(int32x4_t *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 32) = v7;
  v8 = *(int32x4_t *)(a2 + 16);
  v9 = *(int32x4_t *)(a2 + 56);
  v10.n64_u64[0] = *(unsigned __int64 *)(a2 + 72);
  v11.n64_u64[0] = *(unsigned __int64 *)(a2 + 32);
  *(int32x4_t *)(a1 + 40) = vsubq_s32(*(int32x4_t *)(a2 + 40), *(int32x4_t *)a2);
  v12 = (int *)(a1 + 40);
  *(int32x4_t *)(a1 + 56) = vsubq_s32(v9, v8);
  *(int32x2_t *)(a1 + 72) = vsub_s32(v10, v11);
  sub_67EDDA8((_DWORD *)(a1 + 80), (int *)a1, a3);
  sub_67EDDA8((_DWORD *)(a1 + 40), (int *)(a1 + 40), v5 + 10);
  sub_67EDDA8((_DWORD *)(a1 + 120), v5 + 30, (int *)(v4 + 120));
  sub_67EDDA8((_DWORD *)a1, (int *)(v4 + 80), v5 + 20);
  v13 = *(_DWORD *)(a1 + 80);
  v14 = *(_DWORD *)(a1 + 84);
  v15 = *(_DWORD *)(a1 + 88);
  v16 = *(_DWORD *)(a1 + 92);
  v17 = *(_DWORD *)(a1 + 44);
  v18 = *(_DWORD *)(a1 + 48);
  v19 = *(_DWORD *)(a1 + 52);
  v20 = *(_DWORD *)(a1 + 56);
  v21 = *v12;
  v23 = *(_DWORD *)(a1 + 96);
  v22 = *(_DWORD *)(a1 + 100);
  LODWORD(v5) = *(_DWORD *)(a1 + 60);
  v24 = *(_DWORD *)(a1 + 64);
  v52 = *(_DWORD *)a1;
  v25 = *(_DWORD *)(a1 + 4);
  v26 = *(_DWORD *)(a1 + 8);
  v27 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)a1 = v13 - *v12;
  *(_DWORD *)(a1 + 4) = v14 - v17;
  v28 = v21 + v13;
  *(_DWORD *)(a1 + 8) = v15 - v18;
  *(_DWORD *)(a1 + 12) = v16 - v19;
  v29 = *(_DWORD *)(a1 + 104);
  v30 = *(_DWORD *)(a1 + 108);
  LODWORD(v4) = *(_DWORD *)(a1 + 112);
  v31 = *(_DWORD *)(a1 + 68);
  v32 = *(_DWORD *)(a1 + 72);
  *v12 = v28;
  v34 = *(_DWORD *)(a1 + 16);
  v33 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 16) = v23 - v20;
  *(_DWORD *)(a1 + 20) = v22 - (_DWORD)v5;
  v35 = *(_DWORD *)(a1 + 24);
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  v36 = *(_DWORD *)(a1 + 76);
  v51 = v25;
  *(_DWORD *)(a1 + 24) = v29 - v24;
  *(_DWORD *)(a1 + 28) = v30 - v31;
  v38 = *(_DWORD *)(a1 + 116);
  v37 = *(_DWORD *)(a1 + 120);
  v39 = v17 + v14;
  v33 *= 2;
  v35 *= 2;
  LODWORD(v12) = 2 * (_DWORD)v12;
  v40 = 2 * *(_DWORD *)(a1 + 36);
  v41 = 2 * *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = v4 - v32;
  *(_DWORD *)(a1 + 36) = v38 - v36;
  *(_DWORD *)(a1 + 44) = v39;
  *(_DWORD *)(a1 + 48) = v18 + v15;
  *(_DWORD *)(a1 + 52) = v19 + v16;
  *(_DWORD *)(a1 + 56) = v20 + v23;
  v42 = v36 + v38;
  *(_DWORD *)(a1 + 60) = (_DWORD)v5 + v22;
  *(_DWORD *)(a1 + 64) = v24 + v29;
  *(_DWORD *)(a1 + 68) = v31 + v30;
  *(_DWORD *)(a1 + 72) = v32 + v4;
  v44 = *(_DWORD *)(a1 + 132);
  v43 = *(_DWORD *)(a1 + 136);
  v45 = *(_DWORD *)(a1 + 124);
  v46 = *(_DWORD *)(a1 + 128);
  v47 = *(_DWORD *)(a1 + 140);
  LODWORD(v5) = *(_DWORD *)(a1 + 144);
  result = (unsigned int)(2 * v26);
  *(_DWORD *)(a1 + 76) = v42;
  *(_DWORD *)(a1 + 80) = v37 + 2 * v52;
  *(_DWORD *)(a1 + 92) = v44 + 2 * v27;
  *(_DWORD *)(a1 + 96) = v43 + 2 * v34;
  LODWORD(v4) = *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 84) = v45 + 2 * v51;
  *(_DWORD *)(a1 + 88) = v46 + result;
  v49 = *(_DWORD *)(a1 + 148);
  v50 = *(_DWORD *)(a1 + 152);
  *(_DWORD *)(a1 + 100) = v47 + v33;
  *(_DWORD *)(a1 + 104) = (_DWORD)v5 + v35;
  *(_DWORD *)(a1 + 116) = v4 + v40;
  *(_DWORD *)(a1 + 120) = 2 * v52 - v37;
  *(_DWORD *)(a1 + 156) = v40 - v4;
  *(_DWORD *)(a1 + 108) = v49 + (_DWORD)v12;
  *(_DWORD *)(a1 + 112) = v50 + v41;
  *(_DWORD *)(a1 + 132) = 2 * v27 - v44;
  *(_DWORD *)(a1 + 136) = 2 * v34 - v43;
  *(_DWORD *)(a1 + 140) = v33 - v47;
  *(_DWORD *)(a1 + 144) = v35 - (_DWORD)v5;
  *(_DWORD *)(a1 + 124) = 2 * v51 - v45;
  *(_DWORD *)(a1 + 128) = result - v46;
  *(_DWORD *)(a1 + 148) = (_DWORD)v12 - v49;
  *(_DWORD *)(a1 + 152) = v41 - v50;
  return result;
}


================================================================================
Function: sub_67EE3A8 (0x67EE3A8)
================================================================================

__int64 __fastcall sub_67EE3A8(_DWORD *a1, int *a2)
{
  int v4; // w22
  int v5; // w22
  int v6; // w22
  int v8[10]; // [xsp+0h] [xbp-80h] BYREF
  int v9[10]; // [xsp+28h] [xbp-58h] BYREF
  int v10[10]; // [xsp+50h] [xbp-30h] BYREF

  sub_67EDB64(v10, a2);
  sub_67EDB64(v9, v10);
  sub_67EDB64(v9, v9);
  sub_67EDDA8(v9, a2, v9);
  sub_67EDDA8(v10, v10, v9);
  sub_67EDB64(v10, v10);
  sub_67EDDA8(v10, v9, v10);
  sub_67EDB64(v9, v10);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDDA8(v10, v9, v10);
  sub_67EDB64(v9, v10);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDDA8(v9, v9, v10);
  sub_67EDB64(v8, v9);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDB64(v8, v8);
  sub_67EDDA8(v9, v8, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDB64(v9, v9);
  sub_67EDDA8(v10, v9, v10);
  sub_67EDB64(v9, v10);
  v4 = 49;
  do
  {
    sub_67EDB64(v9, v9);
    --v4;
  }
  while ( v4 );
  sub_67EDDA8(v9, v9, v10);
  sub_67EDB64(v8, v9);
  v5 = 99;
  do
  {
    sub_67EDB64(v8, v8);
    --v5;
  }
  while ( v5 );
  sub_67EDDA8(v9, v8, v9);
  sub_67EDB64(v9, v9);
  v6 = 49;
  do
  {
    sub_67EDB64(v9, v9);
    --v6;
  }
  while ( v6 );
  sub_67EDDA8(v10, v9, v10);
  sub_67EDB64(v10, v10);
  sub_67EDB64(v10, v10);
  return sub_67EDDA8(a1, v10, a2);
}


================================================================================
Function: sub_67EE778 (0x67EE778)
================================================================================

__int64 __fastcall sub_67EE778(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  int32x4_t v5; // q0
  int32x4_t v6; // q1
  int32x2_t v7; // d4
  int32x2_t v8; // d8
  int32x4_t v9; // q0
  int32x2_t v10; // d9
  int32x4_t v11; // q1
  unsigned __int64 v12; // d2
  int32x4_t v14; // [xsp+0h] [xbp-170h]
  int32x4_t v15; // [xsp+10h] [xbp-160h]
  int32x4_t v16; // [xsp+20h] [xbp-150h]
  int32x4_t v17; // [xsp+20h] [xbp-150h]
  _OWORD v18[2]; // [xsp+30h] [xbp-140h] BYREF
  unsigned __int64 v19; // [xsp+50h] [xbp-120h]
  _OWORD v20[2]; // [xsp+60h] [xbp-110h] BYREF
  unsigned __int64 v21; // [xsp+80h] [xbp-F0h]
  int32x4_t v22; // [xsp+90h] [xbp-E0h] BYREF
  int32x4_t v23; // [xsp+A0h] [xbp-D0h]
  int32x2_t v24; // [xsp+B0h] [xbp-C0h]
  _BYTE v25[40]; // [xsp+B8h] [xbp-B8h] BYREF
  int32x4_t v26; // [xsp+E0h] [xbp-90h] BYREF
  int32x4_t v27; // [xsp+F0h] [xbp-80h]
  int32x2_t v28; // [xsp+100h] [xbp-70h]
  int32x4_t v29; // [xsp+110h] [xbp-60h] BYREF
  int32x4_t v30; // [xsp+120h] [xbp-50h]
  int32x2_t v31; // [xsp+130h] [xbp-40h]
  _BYTE v32[32]; // [xsp+138h] [xbp-38h] BYREF

  v2 = a1 + 40;
  sub_67ED414(a1 + 40);
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 80) = 1LL;
  *(_OWORD *)(a1 + 104) = 0u;
  sub_67EDB64(&v29, v2);
  sub_67EDDA8(&v26, &v29, &unk_1745110);
  v5 = *(int32x4_t *)(a1 + 80);
  v6 = *(int32x4_t *)(a1 + 96);
  v7.n64_u64[0] = *(unsigned __int64 *)(a1 + 112);
  v8.n64_u64[0] = vsub_s32(v31, v7).n64_u64[0];
  v15 = vsubq_s32(v30, v6);
  v16 = vsubq_s32(v29, v5);
  v29 = v16;
  v30 = v15;
  v31.n64_u64[0] = v8.n64_u64[0];
  v26 = vaddq_s32(v26, v5);
  v27 = vaddq_s32(v27, v6);
  v28.n64_u64[0] = vadd_s32(v28, v7).n64_u64[0];
  sub_67EDB64(v25, &v26);
  sub_67EDDA8(v25, v25, &v26);
  sub_67EDB64(a1, v25);
  sub_67EDDA8(a1, a1, &v26);
  sub_67EDDA8(a1, a1, &v29);
  sub_67EE3A8(a1, a1);
  sub_67EDDA8(a1, a1, v25);
  sub_67EDDA8(a1, a1, &v29);
  sub_67EDB64(&v22, a1);
  sub_67EDDA8(&v22, &v22, &v26);
  v14 = v22;
  v9 = v16;
  v17 = v23;
  v10.n64_u64[0] = v24.n64_u64[0];
  v20[0] = vsubq_s32(v22, v9);
  v20[1] = vsubq_s32(v23, v15);
  v21 = vsub_s32(v24, v8).n64_u64[0];
  sub_67ED5C0(v18, v20);
  if ( !(unsigned int)sub_67F35EC(v18, 32LL) )
  {
    v19 = vadd_s32(v31, v10).n64_u64[0];
    v18[0] = vaddq_s32(v29, v14);
    v18[1] = vaddq_s32(v30, v17);
    sub_67ED5C0(v32, v18);
    if ( !(unsigned int)sub_67F35EC(v32, 32LL) )
      return 0xFFFFFFFFLL;
    sub_67EDDA8(a1, a1, &unk_1745138);
  }
  sub_67ED5C0(v32, a1);
  if ( (v32[0] & 1) == *(unsigned __int8 *)(a2 + 31) >> 7 )
  {
    v11 = vnegq_s32(*(int32x4_t *)(a1 + 16));
    v12 = vneg_s32(*(int32x2_t *)(a1 + 32)).n64_u64[0];
    *(int32x4_t *)a1 = vnegq_s32(*(int32x4_t *)a1);
    *(int32x4_t *)(a1 + 16) = v11;
    *(_QWORD *)(a1 + 32) = v12;
  }
  sub_67EDDA8(a1 + 120, a1, v2);
  return 0LL;
}


================================================================================
Function: sub_67EE9E8 (0x67EE9E8)
================================================================================

__int64 __fastcall sub_67EE9E8(__int64 a1, __int64 a2)
{
  int32x4_t v2; // q1
  unsigned __int64 v3; // d2
  int32x4_t v4; // q1
  unsigned __int64 v5; // d2
  __int128 v6; // q1
  __int64 v7; // d2

  v2 = vaddq_s32(*(int32x4_t *)(a2 + 16), *(int32x4_t *)(a2 + 56));
  v3 = vadd_s32(*(int32x2_t *)(a2 + 32), *(int32x2_t *)(a2 + 72)).n64_u64[0];
  *(int32x4_t *)a1 = vaddq_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 40));
  *(int32x4_t *)(a1 + 16) = v2;
  *(_QWORD *)(a1 + 32) = v3;
  v4 = vsubq_s32(*(int32x4_t *)(a2 + 56), *(int32x4_t *)(a2 + 16));
  v5 = vsub_s32(*(int32x2_t *)(a2 + 72), *(int32x2_t *)(a2 + 32)).n64_u64[0];
  *(int32x4_t *)(a1 + 40) = vsubq_s32(*(int32x4_t *)(a2 + 40), *(int32x4_t *)a2);
  *(int32x4_t *)(a1 + 56) = v4;
  *(_QWORD *)(a1 + 72) = v5;
  v6 = *(_OWORD *)(a2 + 96);
  v7 = *(_QWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 96) = v6;
  *(_QWORD *)(a1 + 112) = v7;
  return sub_67EDDA8((_DWORD *)(a1 + 120), (int *)(a2 + 120), dword_1745160);
}


================================================================================
Function: sub_67EEA68 (0x67EEA68)
================================================================================

__int64 __fastcall sub_67EEA68(__int64 a1, __int64 a2, int *a3)
{
  int *v4; // x21
  __int64 v5; // x22
  int32x4_t v6; // q1
  unsigned __int64 v7; // d2
  int32x4_t v8; // q3
  int32x4_t v9; // q1
  int32x2_t v10; // d4
  int32x2_t v11; // d5
  int *v12; // x20
  int v13; // w10
  int v14; // w12
  int v15; // w13
  int v16; // w16
  int v17; // w14
  int v18; // w15
  int v19; // w0
  int v20; // w1
  int v21; // w11
  int v22; // w4
  int v23; // w17
  int v24; // w23
  int v25; // w8
  int v26; // w25
  int v27; // w27
  int v28; // w10
  int v29; // w6
  int v30; // w5
  int v31; // w7
  int v32; // w11
  int v33; // w3
  int v34; // w30
  int v35; // w10
  int v36; // w2
  int v37; // w24
  int v38; // w26
  int v39; // w12
  int v40; // w9
  int v41; // w14
  int v42; // w13
  int v43; // w2
  int v44; // w8
  int v45; // w15
  int v46; // w16
  int v47; // w6
  __int64 result; // x0
  int v49; // w5
  int v50; // w7
  int v51; // [xsp+8h] [xbp-8h]
  int v52; // [xsp+Ch] [xbp-4h]

  v4 = a3;
  v5 = a2;
  v6 = vaddq_s32(*(int32x4_t *)(a2 + 16), *(int32x4_t *)(a2 + 56));
  v7 = vadd_s32(*(int32x2_t *)(a2 + 32), *(int32x2_t *)(a2 + 72)).n64_u64[0];
  *(int32x4_t *)a1 = vaddq_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 40));
  *(int32x4_t *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 32) = v7;
  v8 = *(int32x4_t *)(a2 + 16);
  v9 = *(int32x4_t *)(a2 + 56);
  v10.n64_u64[0] = *(unsigned __int64 *)(a2 + 72);
  v11.n64_u64[0] = *(unsigned __int64 *)(a2 + 32);
  *(int32x4_t *)(a1 + 40) = vsubq_s32(*(int32x4_t *)(a2 + 40), *(int32x4_t *)a2);
  v12 = (int *)(a1 + 40);
  *(int32x4_t *)(a1 + 56) = vsubq_s32(v9, v8);
  *(int32x2_t *)(a1 + 72) = vsub_s32(v10, v11);
  sub_67EDDA8((_DWORD *)(a1 + 80), (int *)a1, a3 + 10);
  sub_67EDDA8((_DWORD *)(a1 + 40), (int *)(a1 + 40), v4);
  sub_67EDDA8((_DWORD *)(a1 + 120), v4 + 30, (int *)(v5 + 120));
  sub_67EDDA8((_DWORD *)a1, (int *)(v5 + 80), v4 + 20);
  v13 = *(_DWORD *)(a1 + 80);
  v14 = *(_DWORD *)(a1 + 84);
  v15 = *(_DWORD *)(a1 + 88);
  v16 = *(_DWORD *)(a1 + 92);
  v17 = *(_DWORD *)(a1 + 44);
  v18 = *(_DWORD *)(a1 + 48);
  v19 = *(_DWORD *)(a1 + 52);
  v20 = *(_DWORD *)(a1 + 56);
  v21 = *v12;
  v23 = *(_DWORD *)(a1 + 96);
  v22 = *(_DWORD *)(a1 + 100);
  LODWORD(v4) = *(_DWORD *)(a1 + 60);
  v24 = *(_DWORD *)(a1 + 64);
  v52 = *(_DWORD *)a1;
  v25 = *(_DWORD *)(a1 + 4);
  v26 = *(_DWORD *)(a1 + 8);
  v27 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)a1 = v13 - *v12;
  *(_DWORD *)(a1 + 4) = v14 - v17;
  v28 = v21 + v13;
  *(_DWORD *)(a1 + 8) = v15 - v18;
  *(_DWORD *)(a1 + 12) = v16 - v19;
  v29 = *(_DWORD *)(a1 + 104);
  v30 = *(_DWORD *)(a1 + 108);
  LODWORD(v5) = *(_DWORD *)(a1 + 112);
  v31 = *(_DWORD *)(a1 + 68);
  v32 = *(_DWORD *)(a1 + 72);
  *v12 = v28;
  v34 = *(_DWORD *)(a1 + 16);
  v33 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 16) = v23 - v20;
  *(_DWORD *)(a1 + 20) = v22 - (_DWORD)v4;
  v35 = *(_DWORD *)(a1 + 24);
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  v36 = *(_DWORD *)(a1 + 76);
  v51 = v25;
  *(_DWORD *)(a1 + 24) = v29 - v24;
  *(_DWORD *)(a1 + 28) = v30 - v31;
  v38 = *(_DWORD *)(a1 + 116);
  v37 = *(_DWORD *)(a1 + 120);
  v39 = v17 + v14;
  v33 *= 2;
  v35 *= 2;
  LODWORD(v12) = 2 * (_DWORD)v12;
  v40 = 2 * *(_DWORD *)(a1 + 36);
  v41 = 2 * *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = v5 - v32;
  *(_DWORD *)(a1 + 36) = v38 - v36;
  *(_DWORD *)(a1 + 44) = v39;
  *(_DWORD *)(a1 + 48) = v18 + v15;
  *(_DWORD *)(a1 + 52) = v19 + v16;
  *(_DWORD *)(a1 + 56) = v20 + v23;
  v42 = v36 + v38;
  *(_DWORD *)(a1 + 60) = (_DWORD)v4 + v22;
  *(_DWORD *)(a1 + 64) = v24 + v29;
  *(_DWORD *)(a1 + 68) = v31 + v30;
  *(_DWORD *)(a1 + 72) = v32 + v5;
  v44 = *(_DWORD *)(a1 + 132);
  v43 = *(_DWORD *)(a1 + 136);
  v45 = *(_DWORD *)(a1 + 124);
  v46 = *(_DWORD *)(a1 + 128);
  v47 = *(_DWORD *)(a1 + 140);
  LODWORD(v4) = *(_DWORD *)(a1 + 144);
  result = (unsigned int)(2 * v26);
  *(_DWORD *)(a1 + 76) = v42;
  *(_DWORD *)(a1 + 80) = 2 * v52 - v37;
  *(_DWORD *)(a1 + 92) = 2 * v27 - v44;
  *(_DWORD *)(a1 + 96) = 2 * v34 - v43;
  LODWORD(v5) = *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 84) = 2 * v51 - v45;
  *(_DWORD *)(a1 + 88) = result - v46;
  v49 = *(_DWORD *)(a1 + 148);
  v50 = *(_DWORD *)(a1 + 152);
  *(_DWORD *)(a1 + 100) = v33 - v47;
  *(_DWORD *)(a1 + 104) = v35 - (_DWORD)v4;
  *(_DWORD *)(a1 + 116) = v40 - v5;
  *(_DWORD *)(a1 + 120) = v37 + 2 * v52;
  *(_DWORD *)(a1 + 156) = v5 + v40;
  *(_DWORD *)(a1 + 108) = (_DWORD)v12 - v49;
  *(_DWORD *)(a1 + 112) = v41 - v50;
  *(_DWORD *)(a1 + 132) = v44 + 2 * v27;
  *(_DWORD *)(a1 + 136) = v43 + 2 * v34;
  *(_DWORD *)(a1 + 140) = v47 + v33;
  *(_DWORD *)(a1 + 144) = (_DWORD)v4 + v35;
  *(_DWORD *)(a1 + 124) = v45 + 2 * v51;
  *(_DWORD *)(a1 + 128) = v46 + result;
  *(_DWORD *)(a1 + 148) = v49 + (_DWORD)v12;
  *(_DWORD *)(a1 + 152) = v50 + v41;
  return result;
}


================================================================================
Function: sub_67EECD4 (0x67EECD4)
================================================================================

__int64 __fastcall sub_67EECD4(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  _BYTE v5[40]; // [xsp+0h] [xbp-A0h] BYREF
  _BYTE v6[40]; // [xsp+28h] [xbp-78h] BYREF
  _BYTE v7[40]; // [xsp+50h] [xbp-50h] BYREF
  _BYTE v8[32]; // [xsp+78h] [xbp-28h] BYREF

  sub_67ED770(v7, a2 + 80);
  sub_67EDDA8(v6, a2, v7);
  sub_67EDDA8(v5, a2 + 40, v7);
  sub_67ED5C0(a1, v5);
  result = sub_67ED5C0(v8, v6);
  *(_BYTE *)(a1 + 31) ^= v8[0] << 7;
  return result;
}


================================================================================
Function: sub_67EED7C (0x67EED7C)
================================================================================

__int64 __fastcall sub_67EED7C(__int64 a1, __int64 a2, __int128 *a3, __int64 a4)
{
  __int64 v6; // x8
  __int64 v7; // x10
  char v8; // w12
  char v9; // w11
  _BYTE *v10; // x13
  unsigned __int64 v11; // x8
  __int64 v12; // x12
  unsigned __int64 v13; // x13
  unsigned __int64 v14; // x14
  __int64 v15; // x15
  int v16; // w16
  int v17; // w17
  int v18; // w0
  int v19; // w16
  int v20; // w17
  unsigned __int64 v21; // x16
  __int64 v22; // x8
  __int64 v23; // x10
  char v24; // w12
  char v25; // w11
  _BYTE *v26; // x13
  unsigned __int64 v27; // x8
  __int64 v28; // x12
  unsigned __int64 v29; // x13
  unsigned __int64 v30; // x14
  __int64 v31; // x15
  int v32; // w16
  int v33; // w17
  int v34; // w0
  int v35; // w16
  int v36; // w17
  unsigned __int64 v37; // x16
  __int128 v38; // q1
  __int128 v39; // q2
  __int128 v40; // q3
  __int128 v41; // q0
  __int128 v42; // q1
  __int128 v43; // q2
  __int64 result; // x0
  __int64 v45; // x8
  __int64 v46; // x26
  __int64 v47; // x11
  __int64 v48; // x19
  unsigned __int64 v50; // x28
  int v51; // w28
  char *v52; // x28
  int v53; // w8
  int v54; // w24
  int v55; // w24
  __int64 v56; // [xsp+0h] [xbp-920h]
  __int64 v57; // [xsp+20h] [xbp-900h]
  __int64 v58; // [xsp+28h] [xbp-8F8h]
  _BYTE v59[40]; // [xsp+30h] [xbp-8F0h] BYREF
  __int64 v60; // [xsp+58h] [xbp-8C8h] BYREF
  __int64 v61; // [xsp+80h] [xbp-8A0h] BYREF
  __int64 v62; // [xsp+A8h] [xbp-878h] BYREF
  __int128 v63; // [xsp+D0h] [xbp-850h] BYREF
  __int128 v64; // [xsp+E0h] [xbp-840h]
  __int128 v65; // [xsp+F0h] [xbp-830h] BYREF
  __int128 v66; // [xsp+100h] [xbp-820h]
  __int128 v67; // [xsp+110h] [xbp-810h]
  __int128 v68; // [xsp+120h] [xbp-800h] BYREF
  __int128 v69; // [xsp+130h] [xbp-7F0h]
  __int64 v70; // [xsp+140h] [xbp-7E0h]
  _BYTE v71[40]; // [xsp+148h] [xbp-7D8h] BYREF
  int v72; // [xsp+170h] [xbp-7B0h] BYREF
  int v73; // [xsp+174h] [xbp-7ACh]
  int v74; // [xsp+178h] [xbp-7A8h]
  int v75; // [xsp+17Ch] [xbp-7A4h]
  int v76; // [xsp+180h] [xbp-7A0h]
  int v77; // [xsp+184h] [xbp-79Ch]
  int v78; // [xsp+188h] [xbp-798h]
  int v79; // [xsp+18Ch] [xbp-794h]
  int v80; // [xsp+190h] [xbp-790h]
  int v81; // [xsp+194h] [xbp-78Ch]
  int v82; // [xsp+198h] [xbp-788h] BYREF
  int v83; // [xsp+19Ch] [xbp-784h]
  int v84; // [xsp+1A0h] [xbp-780h]
  int v85; // [xsp+1A4h] [xbp-77Ch]
  int v86; // [xsp+1A8h] [xbp-778h]
  int v87; // [xsp+1ACh] [xbp-774h]
  int v88; // [xsp+1B0h] [xbp-770h]
  int v89; // [xsp+1B4h] [xbp-76Ch]
  int v90; // [xsp+1B8h] [xbp-768h]
  int v91; // [xsp+1BCh] [xbp-764h]
  int v92; // [xsp+1C0h] [xbp-760h] BYREF
  int v93; // [xsp+1C4h] [xbp-75Ch]
  int v94; // [xsp+1C8h] [xbp-758h]
  int v95; // [xsp+1CCh] [xbp-754h]
  int v96; // [xsp+1D0h] [xbp-750h]
  int v97; // [xsp+1D4h] [xbp-74Ch]
  int v98; // [xsp+1D8h] [xbp-748h]
  int v99; // [xsp+1DCh] [xbp-744h]
  int v100; // [xsp+1E0h] [xbp-740h]
  int v101; // [xsp+1E4h] [xbp-73Ch]
  int v102; // [xsp+1E8h] [xbp-738h] BYREF
  int v103; // [xsp+1ECh] [xbp-734h]
  int v104; // [xsp+1F0h] [xbp-730h]
  int v105; // [xsp+1F4h] [xbp-72Ch]
  int v106; // [xsp+1F8h] [xbp-728h]
  int v107; // [xsp+1FCh] [xbp-724h]
  int v108; // [xsp+200h] [xbp-720h]
  int v109; // [xsp+204h] [xbp-71Ch]
  int v110; // [xsp+208h] [xbp-718h]
  int v111; // [xsp+20Ch] [xbp-714h]
  _OWORD v112[10]; // [xsp+210h] [xbp-710h] BYREF
  _BYTE v113[160]; // [xsp+2B0h] [xbp-670h] BYREF
  _BYTE v114[160]; // [xsp+350h] [xbp-5D0h] BYREF
  _BYTE v115[160]; // [xsp+3F0h] [xbp-530h] BYREF
  _BYTE v116[160]; // [xsp+490h] [xbp-490h] BYREF
  _BYTE v117[160]; // [xsp+530h] [xbp-3F0h] BYREF
  _BYTE v118[160]; // [xsp+5D0h] [xbp-350h] BYREF
  _BYTE v119[672]; // [xsp+670h] [xbp-2B0h] BYREF

  v6 = 0LL;
  do
  {
    v7 = (unsigned int)v6 >> 3;
    v8 = v6 & 6;
    v9 = v6 & 6 | 1;
    v10 = &v119[v6 + 416];
    v6 += 2LL;
    LODWORD(v7) = *(unsigned __int8 *)(a2 + v7);
    *v10 = ((unsigned int)v7 >> v8) & 1;
    v10[1] = ((unsigned int)v7 >> v9) & 1;
  }
  while ( v6 != 256 );
  v11 = 0LL;
  v12 = 1LL;
  do
  {
    if ( v119[v11 + 416] && v11 <= 0xFE )
    {
      v13 = v11;
      v14 = 1LL;
      v15 = v12;
      do
      {
        v16 = (char)v119[v15 + 416];
        if ( v119[v15 + 416] )
        {
          v17 = (char)v119[v11 + 416];
          v18 = v16 << v14;
          v19 = (v16 << v14) + v17;
          if ( v19 > 15 )
          {
            v20 = v17 - v18;
            if ( v20 < -15 )
              break;
            v21 = v13;
            v119[v11 + 416] = v20;
            while ( v119[v21 + 417] )
            {
              v119[v21++ + 417] = 0;
              if ( v21 >= 0xFF )
                goto LABEL_17;
            }
            v119[v21 + 417] = 1;
          }
          else
          {
            v119[v11 + 416] = v19;
            v119[v15 + 416] = 0;
          }
        }
LABEL_17:
        if ( v14 > 5 )
          break;
        ++v14;
        ++v15;
        ++v13;
      }
      while ( v14 + v11 < 0x100 );
    }
    ++v11;
    ++v12;
  }
  while ( v11 != 256 );
  v22 = 0LL;
  do
  {
    v23 = (unsigned int)v22 >> 3;
    v24 = v22 & 6;
    v25 = v22 & 6 | 1;
    v26 = &v119[v22 + 160];
    v22 += 2LL;
    LODWORD(v23) = *(unsigned __int8 *)(a4 + v23);
    *v26 = ((unsigned int)v23 >> v24) & 1;
    v26[1] = ((unsigned int)v23 >> v25) & 1;
  }
  while ( v22 != 256 );
  v27 = 0LL;
  v28 = 1LL;
  do
  {
    if ( v119[v27 + 160] && v27 <= 0xFE )
    {
      v29 = v27;
      v30 = 1LL;
      v31 = v28;
      do
      {
        v32 = (char)v119[v31 + 160];
        if ( v119[v31 + 160] )
        {
          v33 = (char)v119[v27 + 160];
          v34 = v32 << v30;
          v35 = (v32 << v30) + v33;
          if ( v35 > 15 )
          {
            v36 = v33 - v34;
            if ( v36 < -15 )
              break;
            v37 = v29;
            v119[v27 + 160] = v36;
            while ( v119[v37 + 161] )
            {
              v119[v37++ + 161] = 0;
              if ( v37 >= 0xFF )
                goto LABEL_36;
            }
            v119[v37 + 161] = 1;
          }
          else
          {
            v119[v27 + 160] = v35;
            v119[v31 + 160] = 0;
          }
        }
LABEL_36:
        if ( v30 > 5 )
          break;
        ++v30;
        ++v31;
        ++v29;
      }
      while ( v30 + v27 < 0x100 );
    }
    ++v27;
    ++v28;
  }
  while ( v27 != 256 );
  sub_67EE9E8(v112, a3);
  v38 = a3[1];
  v39 = a3[2];
  v40 = a3[3];
  v63 = *a3;
  v64 = v38;
  v41 = a3[4];
  v42 = a3[5];
  v65 = v39;
  v66 = v40;
  v43 = a3[6];
  v67 = v41;
  v68 = v42;
  *(_QWORD *)&v40 = *((_QWORD *)a3 + 14);
  v69 = v43;
  v70 = v40;
  sub_67EF8D8(&v72, &v63);
  sub_67EDDA8(v59, &v72, &v102);
  sub_67EDDA8(&v60, &v82, &v92);
  sub_67EDDA8(&v61, &v92, &v102);
  sub_67EDDA8(&v62, &v72, &v82);
  sub_67EE140(&v72, v59, v112);
  sub_67EDDA8(&v63, &v72, &v102);
  sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
  sub_67EDDA8(&v68, &v92, &v102);
  sub_67EDDA8(v71, &v72, &v82);
  sub_67EE9E8(v113, &v63);
  sub_67EE140(&v72, v59, v113);
  sub_67EDDA8(&v63, &v72, &v102);
  sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
  sub_67EDDA8(&v68, &v92, &v102);
  sub_67EDDA8(v71, &v72, &v82);
  sub_67EE9E8(v114, &v63);
  sub_67EE140(&v72, v59, v114);
  sub_67EDDA8(&v63, &v72, &v102);
  sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
  sub_67EDDA8(&v68, &v92, &v102);
  sub_67EDDA8(v71, &v72, &v82);
  sub_67EE9E8(v115, &v63);
  sub_67EE140(&v72, v59, v115);
  sub_67EDDA8(&v63, &v72, &v102);
  sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
  sub_67EDDA8(&v68, &v92, &v102);
  sub_67EDDA8(v71, &v72, &v82);
  sub_67EE9E8(v116, &v63);
  sub_67EE140(&v72, v59, v116);
  sub_67EDDA8(&v63, &v72, &v102);
  sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
  sub_67EDDA8(&v68, &v92, &v102);
  sub_67EDDA8(v71, &v72, &v82);
  sub_67EE9E8(v117, &v63);
  sub_67EE140(&v72, v59, v117);
  sub_67EDDA8(&v63, &v72, &v102);
  sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
  sub_67EDDA8(&v68, &v92, &v102);
  sub_67EDDA8(v71, &v72, &v82);
  sub_67EE9E8(v118, &v63);
  sub_67EE140(&v72, v59, v118);
  sub_67EDDA8(&v63, &v72, &v102);
  sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
  sub_67EDDA8(&v68, &v92, &v102);
  sub_67EDDA8(v71, &v72, &v82);
  result = sub_67EE9E8(v119, &v63);
  v45 = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 80) = 1LL;
  v58 = a1 + 80;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 40) = 1LL;
  v46 = a1 + 40;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  while ( 1 )
  {
    v47 = (unsigned int)(v45 + 255);
    if ( v119[v47 + 416] || v119[v47 + 160] )
      break;
    if ( (_DWORD)--v45 == -256 )
      return result;
  }
  if ( (int)v45 + 255 >= 0 )
  {
    v48 = v45 + 255;
    v57 = a1;
    v56 = a1 + 40;
    do
    {
      sub_67EF8D8(&v72, a1);
      v50 = (unsigned __int8)v119[v48 + 416];
      if ( (char)v119[v48 + 416] < 1 )
      {
        if ( (v50 & 0x80) != 0 )
        {
          sub_67EDDA8(&v63, &v72, &v102);
          sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
          sub_67EDDA8(&v68, &v92, &v102);
          sub_67EDDA8(v71, &v72, &v82);
          sub_67EEA68(&v72, &v63, &v112[10 * ((unsigned __int8)-(char)v50 >> 1)]);
        }
      }
      else
      {
        sub_67EDDA8(&v63, &v72, &v102);
        sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
        sub_67EDDA8(&v68, &v92, &v102);
        sub_67EDDA8(v71, &v72, &v82);
        sub_67EE140(&v72, &v63, &v112[10 * (v50 >> 1)]);
      }
      v51 = (char)v119[v48 + 160];
      if ( v51 >= 1 )
      {
        sub_67EDDA8(&v63, &v72, &v102);
        sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
        sub_67EDDA8(&v68, &v92, &v102);
        sub_67EDDA8(v71, &v72, &v82);
        sub_67EFAD0(&v72, &v63, (char *)&unk_1745188 + 120 * ((unsigned __int8)v51 >> 1));
      }
      else if ( v51 < 0 )
      {
        sub_67EDDA8(&v63, &v72, &v102);
        sub_67EDDA8((char *)&v65 + 8, &v82, &v92);
        sub_67EDDA8(&v68, &v92, &v102);
        sub_67EDDA8(v71, &v72, &v82);
        v83 = HIDWORD(v65) - DWORD1(v63);
        v72 = v63 + DWORD2(v65);
        v75 = HIDWORD(v63) + DWORD1(v66);
        v85 = DWORD1(v66) - HIDWORD(v63);
        v86 = DWORD2(v66) - v64;
        v73 = DWORD1(v63) + HIDWORD(v65);
        v74 = DWORD2(v63) + v66;
        v76 = v64 + DWORD2(v66);
        v52 = (char *)&unk_1745188 + 120 * ((unsigned __int8)-(char)v51 >> 1);
        v77 = DWORD1(v64) + HIDWORD(v66);
        v78 = DWORD2(v64) + v67;
        v82 = DWORD2(v65) - v63;
        v84 = v66 - DWORD2(v63);
        v79 = HIDWORD(v64) + DWORD1(v67);
        v80 = v65 + DWORD2(v67);
        v81 = DWORD1(v65) + HIDWORD(v67);
        v87 = HIDWORD(v66) - DWORD1(v64);
        v88 = v67 - DWORD2(v64);
        v89 = DWORD1(v67) - HIDWORD(v64);
        v90 = DWORD2(v67) - v65;
        v91 = HIDWORD(v67) - DWORD1(v65);
        sub_67EDDA8(&v92, &v72, v52 + 40);
        sub_67EDDA8(&v82, &v82, v52);
        sub_67EDDA8(&v102, v52 + 80, v71);
        v53 = v92;
        v72 = v92 - v82;
        v73 = v93 - v83;
        v54 = v96 - v86;
        v74 = v94 - v84;
        v75 = v95 - v85;
        v77 = v97 - v87;
        v83 += v93;
        v84 += v94;
        v85 += v95;
        v86 += v96;
        v79 = v99 - v89;
        v76 = v54;
        v55 = v101 - v91;
        v78 = v98 - v88;
        v80 = v100 - v90;
        v89 += v99;
        v87 += v97;
        v90 += v100;
        v91 += v101;
        v81 = v55;
        v88 += v98;
        v92 = 2 * v68 - v102;
        v82 += v53;
        v94 = 2 * DWORD2(v68) - v104;
        v93 = 2 * DWORD1(v68) - v103;
        v95 = 2 * HIDWORD(v68) - v105;
        v96 = 2 * v69 - v106;
        v97 = 2 * DWORD1(v69) - v107;
        v102 += 2 * v68;
        v98 = 2 * DWORD2(v69) - v108;
        v99 = 2 * HIDWORD(v69) - v109;
        v104 += 2 * DWORD2(v68);
        v46 = v56;
        v100 = 2 * v70 - v110;
        a1 = v57;
        v106 += 2 * v69;
        v101 = 2 * HIDWORD(v70) - v111;
        v103 += 2 * DWORD1(v68);
        v105 += 2 * HIDWORD(v68);
        v107 += 2 * DWORD1(v69);
        v108 += 2 * DWORD2(v69);
        v109 += 2 * HIDWORD(v69);
        v110 += 2 * v70;
        v111 += 2 * HIDWORD(v70);
      }
      sub_67EDDA8(a1, &v72, &v102);
      sub_67EDDA8(v46, &v82, &v92);
      result = sub_67EDDA8(v58, &v92, &v102);
    }
    while ( v48-- > 0 );
  }
  return result;
}


================================================================================
Function: sub_67EF8D8 (0x67EF8D8)
================================================================================

__int64 __fastcall sub_67EF8D8(int *a1, int *a2)
{
  int *v2; // x20
  int32x4_t v4; // q1
  unsigned __int64 v5; // d2
  int v6; // w15
  int v7; // w16
  int v8; // w0
  int v9; // w17
  int v10; // w1
  int v11; // w2
  int v12; // w3
  int v13; // w5
  int v14; // w11
  int v15; // w12
  int v16; // w13
  int v17; // w14
  int v18; // w7
  int v19; // w22
  int v20; // w23
  int v21; // w9
  int v22; // w15
  int v23; // w16
  int v24; // w0
  int v25; // w17
  int v26; // w1
  int v27; // w2
  int v28; // w3
  int v29; // w5
  int v30; // w4
  int v31; // w17
  int v32; // w11
  int v33; // w5
  int v34; // w4
  int v35; // w22
  int v36; // w10
  int v37; // w13
  int v38; // w8
  int v39; // w3
  int v40; // w6
  int v41; // w7
  int v42; // w4
  int v43; // w17
  int v44; // w23
  int v45; // w24
  int v46; // w0
  int v47; // w3
  int v48; // w12
  int v49; // w14
  int v50; // w8
  int v51; // w13
  int v52; // w14
  int v53; // w3
  int v54; // w5
  __int64 result; // x0
  int v56; // w17
  int v57; // w9
  int v58; // w10
  int v59; // w9
  int v60; // w10
  int v61; // w11
  int v62; // w12
  int v63; // w9
  int v64; // w10
  int v65; // w11
  int v66; // w12
  int v67; // w9
  int v68; // w10
  _DWORD v69[10]; // [xsp+0h] [xbp-30h] BYREF

  v2 = a2;
  sub_67EDB64(a1, a2);
  sub_67EDB64(a1 + 20, v2 + 10);
  sub_67F10C8(a1 + 30, v2 + 20);
  v4 = vaddq_s32(*(int32x4_t *)(v2 + 14), *((int32x4_t *)v2 + 1));
  v5 = vadd_s32(*(int32x2_t *)(v2 + 18), *(int32x2_t *)(v2 + 8)).n64_u64[0];
  *(int32x4_t *)(a1 + 10) = vaddq_s32(*(int32x4_t *)(v2 + 10), *(int32x4_t *)v2);
  *(int32x4_t *)(a1 + 14) = v4;
  *((_QWORD *)a1 + 9) = v5;
  sub_67EDB64(v69, a1 + 10);
  v6 = a1[22];
  v7 = a1[23];
  v9 = a1[2];
  v8 = a1[3];
  v10 = a1[24];
  v11 = a1[25];
  v12 = a1[4];
  v13 = a1[5];
  v14 = a1[20];
  v15 = a1[21];
  v16 = *a1;
  v17 = a1[1];
  v18 = v9 + v6;
  v19 = v8 + v7;
  v20 = v12 + v10;
  v21 = v13 + v11;
  v22 = v6 - v9;
  v23 = v7 - v8;
  v25 = v69[0];
  v24 = v69[1];
  v26 = v10 - v12;
  v27 = v11 - v13;
  v28 = v69[2];
  v29 = v69[3];
  v30 = *a1 + v14;
  a1[13] = v19;
  a1[14] = v20;
  v31 = v25 - v30;
  v32 = v14 - v16;
  a1[10] = v30;
  v33 = v29 - v19;
  v34 = v69[4];
  v35 = v69[5];
  v36 = a1[26];
  v37 = a1[27];
  v38 = a1[6];
  LODWORD(v2) = a1[7];
  a1[11] = v17 + v15;
  a1[12] = v18;
  v39 = v28 - v18;
  v40 = a1[28];
  v41 = a1[29];
  v42 = v34 - v20;
  *a1 = v31;
  a1[1] = v24 - (v17 + v15);
  v44 = a1[8];
  v43 = a1[9];
  v45 = v38 + v36;
  a1[2] = v39;
  a1[3] = v33;
  v46 = v69[6];
  v47 = v69[7];
  v48 = v15 - v17;
  v49 = (_DWORD)v2 + v37;
  a1[15] = v21;
  a1[16] = v38 + v36;
  v50 = v36 - v38;
  a1[21] = v48;
  a1[22] = v22;
  v51 = v37 - (_DWORD)v2;
  a1[4] = v42;
  a1[5] = v35 - v21;
  a1[17] = v49;
  a1[18] = v44 + v40;
  v52 = v47 - v49;
  v54 = v69[8];
  v53 = v69[9];
  a1[25] = v27;
  a1[26] = v50;
  a1[6] = v46 - v45;
  a1[7] = v52;
  result = (unsigned int)(v43 + v41);
  v56 = v41 - v43;
  a1[19] = result;
  a1[20] = v32;
  a1[23] = v23;
  a1[24] = v26;
  a1[8] = v54 - (v44 + v40);
  a1[9] = v53 - result;
  v57 = a1[30];
  v58 = a1[31];
  a1[27] = v51;
  a1[28] = v40 - v44;
  a1[29] = v56;
  v59 = v57 - v32;
  v60 = v58 - v48;
  v61 = a1[32];
  v62 = a1[33];
  a1[30] = v59;
  a1[31] = v60;
  v63 = a1[34] - v26;
  v64 = a1[35] - v27;
  a1[32] = v61 - v22;
  a1[33] = v62 - v23;
  v65 = a1[36];
  v66 = a1[37];
  a1[34] = v63;
  a1[35] = v64;
  v67 = a1[38] - (v40 - v44);
  v68 = a1[39] - v56;
  a1[36] = v65 - v50;
  a1[37] = v66 - v51;
  a1[38] = v67;
  a1[39] = v68;
  return result;
}


================================================================================
Function: sub_67EFAD0 (0x67EFAD0)
================================================================================

__int64 __fastcall sub_67EFAD0(__int64 a1, __int64 a2, int *a3)
{
  _DWORD *v4; // x21
  int *v5; // x22
  int32x4_t v6; // q1
  unsigned __int64 v7; // d2
  int32x4_t v8; // q3
  int32x4_t v9; // q1
  int32x2_t v10; // d4
  int32x2_t v11; // d5
  _DWORD *v12; // x20
  int v13; // w5
  int v14; // w6
  int v15; // w13
  int v16; // w14
  int v17; // w17
  int v18; // w8
  int v19; // w12
  int v20; // w15
  int v21; // w16
  int v22; // w0
  int v23; // w1
  int v24; // w2
  int v25; // w3
  int v26; // w7
  int v27; // w4
  int v28; // w5
  int v29; // w24
  int v30; // w26
  int v31; // w30
  int v32; // w4
  int v33; // w28
  int v34; // w23
  int v35; // w25
  int v36; // w9
  int v37; // w27
  int v38; // w11
  int v39; // w8
  int v40; // w10
  int v41; // w1
  int v42; // w2
  int v43; // w4
  int v44; // w8
  int v45; // w6
  int v46; // w23
  __int64 result; // x0
  int v48; // [xsp+0h] [xbp-10h]
  int v49; // [xsp+4h] [xbp-Ch]
  int v50; // [xsp+8h] [xbp-8h]
  int v51; // [xsp+Ch] [xbp-4h]

  v4 = (_DWORD *)a2;
  v5 = a3;
  v6 = vaddq_s32(*(int32x4_t *)(a2 + 16), *(int32x4_t *)(a2 + 56));
  v7 = vadd_s32(*(int32x2_t *)(a2 + 32), *(int32x2_t *)(a2 + 72)).n64_u64[0];
  *(int32x4_t *)a1 = vaddq_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 40));
  *(int32x4_t *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 32) = v7;
  v8 = *(int32x4_t *)(a2 + 16);
  v9 = *(int32x4_t *)(a2 + 56);
  v10.n64_u64[0] = *(unsigned __int64 *)(a2 + 72);
  v11.n64_u64[0] = *(unsigned __int64 *)(a2 + 32);
  *(int32x4_t *)(a1 + 40) = vsubq_s32(*(int32x4_t *)(a2 + 40), *(int32x4_t *)a2);
  v12 = (_DWORD *)(a1 + 40);
  *(int32x4_t *)(a1 + 56) = vsubq_s32(v9, v8);
  *(int32x2_t *)(a1 + 72) = vsub_s32(v10, v11);
  sub_67EDDA8((_DWORD *)(a1 + 80), (int *)a1, a3);
  sub_67EDDA8((_DWORD *)(a1 + 40), (int *)(a1 + 40), v5 + 10);
  sub_67EDDA8((_DWORD *)(a1 + 120), v5 + 20, v4 + 30);
  v14 = *(_DWORD *)(a1 + 76);
  v13 = *(_DWORD *)(a1 + 80);
  v51 = v4[20];
  v15 = v4[25];
  v16 = v4[26];
  v49 = v4[22];
  v50 = v4[21];
  v17 = v4[29];
  v18 = v4[23];
  v19 = v4[24];
  v20 = v4[27];
  v21 = v4[28];
  v22 = *(_DWORD *)(a1 + 84);
  v23 = *(_DWORD *)(a1 + 88);
  v25 = *(_DWORD *)(a1 + 44);
  v24 = *(_DWORD *)(a1 + 48);
  v26 = *(_DWORD *)(a1 + 92);
  LODWORD(v5) = *(_DWORD *)(a1 + 96);
  LODWORD(v4) = v13 - *v12;
  v27 = *v12 + v13;
  v29 = *(_DWORD *)(a1 + 52);
  v28 = *(_DWORD *)(a1 + 56);
  v30 = *(_DWORD *)(a1 + 60);
  v31 = *(_DWORD *)(a1 + 64);
  *v12 = v27;
  v33 = *(_DWORD *)(a1 + 100);
  v32 = *(_DWORD *)(a1 + 104);
  *(_DWORD *)a1 = (_DWORD)v4;
  *(_DWORD *)(a1 + 4) = v22 - v25;
  v48 = v18;
  *(_DWORD *)(a1 + 8) = v23 - v24;
  *(_DWORD *)(a1 + 12) = v26 - v29;
  v34 = *(_DWORD *)(a1 + 108);
  v35 = *(_DWORD *)(a1 + 112);
  v37 = *(_DWORD *)(a1 + 68);
  v36 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 16) = (_DWORD)v5 - v28;
  *(_DWORD *)(a1 + 20) = v33 - v30;
  LODWORD(v12) = *(_DWORD *)(a1 + 116);
  v38 = *(_DWORD *)(a1 + 120);
  v19 *= 2;
  v15 *= 2;
  v16 *= 2;
  v20 *= 2;
  *(_DWORD *)(a1 + 24) = v32 - v31;
  *(_DWORD *)(a1 + 28) = v34 - v37;
  v21 *= 2;
  v17 *= 2;
  *(_DWORD *)(a1 + 32) = v35 - v36;
  *(_DWORD *)(a1 + 36) = (_DWORD)v12 - v14;
  v39 = v24 + v23;
  *(_DWORD *)(a1 + 52) = v29 + v26;
  *(_DWORD *)(a1 + 56) = v28 + (_DWORD)v5;
  v40 = v14 + (_DWORD)v12;
  *(_DWORD *)(a1 + 60) = v30 + v33;
  *(_DWORD *)(a1 + 64) = v31 + v32;
  v41 = *(_DWORD *)(a1 + 124);
  v42 = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 44) = v25 + v22;
  *(_DWORD *)(a1 + 48) = v39;
  *(_DWORD *)(a1 + 68) = v37 + v34;
  *(_DWORD *)(a1 + 72) = v36 + v35;
  v44 = *(_DWORD *)(a1 + 132);
  v43 = *(_DWORD *)(a1 + 136);
  LODWORD(v12) = *(_DWORD *)(a1 + 140);
  LODWORD(v5) = *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a1 + 84) = v41 + 2 * v50;
  *(_DWORD *)(a1 + 88) = v42 + 2 * v49;
  v45 = *(_DWORD *)(a1 + 148);
  LODWORD(v4) = *(_DWORD *)(a1 + 152);
  *(_DWORD *)(a1 + 76) = v40;
  *(_DWORD *)(a1 + 80) = v38 + 2 * v51;
  *(_DWORD *)(a1 + 92) = v44 + 2 * v48;
  *(_DWORD *)(a1 + 96) = v43 + v19;
  v46 = *(_DWORD *)(a1 + 156);
  result = (unsigned int)(2 * v49 - v42);
  *(_DWORD *)(a1 + 100) = (_DWORD)v12 + v15;
  *(_DWORD *)(a1 + 104) = (_DWORD)v5 + v16;
  *(_DWORD *)(a1 + 108) = v45 + v20;
  *(_DWORD *)(a1 + 112) = (_DWORD)v4 + v21;
  *(_DWORD *)(a1 + 116) = v46 + v17;
  *(_DWORD *)(a1 + 120) = 2 * v51 - v38;
  *(_DWORD *)(a1 + 124) = 2 * v50 - v41;
  *(_DWORD *)(a1 + 128) = result;
  *(_DWORD *)(a1 + 132) = 2 * v48 - v44;
  *(_DWORD *)(a1 + 136) = v19 - v43;
  *(_DWORD *)(a1 + 140) = v15 - (_DWORD)v12;
  *(_DWORD *)(a1 + 144) = v16 - (_DWORD)v5;
  *(_DWORD *)(a1 + 148) = v20 - v45;
  *(_DWORD *)(a1 + 152) = v21 - (_DWORD)v4;
  *(_DWORD *)(a1 + 156) = v17 - v46;
  return result;
}


================================================================================
Function: sub_67F0268 (0x67F0268)
================================================================================

bool __fastcall sub_67F0268(unsigned __int8 *a1)
{
  unsigned __int64 v1; // d0

  v1 = vand_s8(
         *(int8x8_t *)(a1 + 15),
         (int8x8_t)vextq_s8(*(int8x16_t *)(a1 + 15), *(int8x16_t *)(a1 + 15), 8uLL).n128_u64[0]).n64_u64[0];
  return ((((236 - *a1) & ((~a1[31] & 0x7F | v1 & BYTE1(v1) & BYTE2(v1) & BYTE3(v1) & BYTE4(v1) & BYTE5(v1) & BYTE6(v1) & HIBYTE(v1) & a1[14] & a1[13] & a1[12] & a1[11] & a1[10] & a1[9] & a1[8] & a1[7] & a1[6] & a1[5] & a1[4] & a1[3] & a1[2] & a1[1] ^ 0xFF)
                         - 1)) >> 8) & 1) == 0;
}


================================================================================
Function: sub_67F0354 (0x67F0354)
================================================================================

__int64 __fastcall sub_67F0354(int8x16_t *a1)
{
  int8x8_t v1; // d2
  unsigned __int64 v2; // d5
  int8x16_t v3; // q4
  int8x8_t v4; // d0
  unsigned __int64 v5; // d2
  char v6; // w2
  char v7; // w3
  char v8; // w4
  char v9; // w5
  char v10; // w6
  unsigned __int64 v11; // d3
  char v12; // w9
  int8x16_t v13; // q2
  char v14; // w11
  char v15; // w12
  char v16; // w13
  char v17; // w14
  char v18; // w10
  int8x8_t v19; // d3
  unsigned __int8 v20; // w8
  unsigned __int8 v21; // w9
  unsigned __int8 v22; // w12
  int8x8_t v23; // d5
  int8x16_t v24; // q3
  unsigned __int8 v25; // w5
  unsigned __int8 v26; // w6
  char v27; // w3
  unsigned __int8 v28; // w4
  char v29; // w11
  unsigned __int8 v30; // w1
  char v31; // w10
  unsigned __int8 v32; // w12
  unsigned __int8 v33; // w13
  unsigned __int8 v34; // w16
  unsigned __int8 v35; // w17
  unsigned __int8 v36; // w6
  unsigned __int8 v37; // w19
  unsigned __int8 v38; // w20
  int8x16_t v39; // q3
  int8x16_t v40; // q1
  char v41; // w8
  unsigned __int8 v42; // w2
  unsigned __int8 v43; // w15
  unsigned __int8 v44; // w3
  char v45; // w14
  unsigned __int8 v46; // w4
  char v47; // w14
  char v48; // w15
  char v49; // w9
  char v50; // w16
  char v51; // w9
  char v52; // w12
  unsigned __int8 v53; // w15
  unsigned __int8 v54; // w17
  char v55; // w8
  char v56; // w9
  unsigned __int8 v57; // w16
  char v58; // w10
  char v59; // w11
  char v60; // w1
  char v61; // w2
  char v62; // w15
  unsigned __int8 v63; // w17
  char v64; // w8
  char v65; // w9
  unsigned __int8 v66; // w2
  char v67; // w15
  unsigned __int8 v68; // w1
  char v69; // w8
  char v70; // w10
  char v71; // w11
  char v72; // w16
  char v73; // w9
  char v74; // w15
  unsigned __int8 v75; // w2
  unsigned __int8 v76; // w17
  char v77; // w15

  v1.n64_u64[0] = vextq_s8(*a1, *a1, 8uLL).n128_u64[0];
  v2 = vorr_s8((int8x8_t)a1->n128_u64[0], v1).n64_u64[0];
  v3 = veorq_s8(*a1, (int8x16_t)xmmword_AFC480);
  v4.n64_u64[0] = a1[1].n128_u64[0];
  v5 = vorr_s8(veor_s8((int8x8_t)a1->n128_u64[0], (int8x8_t)1LL), v1).n64_u64[0];
  v6 = BYTE3(v5);
  v7 = BYTE4(v5);
  v8 = BYTE5(v5);
  v9 = BYTE6(v5);
  v10 = HIBYTE(v5);
  v11 = vorr_s8((int8x8_t)v3.n128_u64[0], (int8x8_t)vextq_s8(v3, v3, 8uLL).n128_u64[0]).n64_u64[0];
  v12 = v5 | BYTE1(v5) | BYTE2(v5);
  v13 = veorq_s8(*a1, (int8x16_t)xmmword_B027A0);
  v14 = BYTE4(v11);
  v15 = BYTE5(v11);
  v16 = BYTE6(v11);
  v17 = HIBYTE(v11);
  v18 = v11 | BYTE1(v11) | BYTE2(v11) | BYTE3(v11);
  v19.n64_u64[0] = (unsigned __int8)(v12 | v6 | v7 | v8 | v9 | v10);
  v13.n128_u64[0] = vorr_s8((int8x8_t)v13.n128_u64[0], (int8x8_t)vextq_s8(v13, v13, 8uLL).n128_u64[0]).n64_u64[0];
  v20 = vorr_s8(
          (int8x8_t)(unsigned __int8)(v2 | BYTE1(v2) | BYTE2(v2) | BYTE3(v2) | BYTE4(v2) | BYTE5(v2) | BYTE6(v2) | HIBYTE(v2)),
          v4).n64_u8[0];
  v21 = v18 | v14 | v15 | v16 | v17;
  v22 = vorr_s8(v19, v4).n64_u8[0];
  v23.n64_u64[0] = veor_s8(v4, (int8x8_t)0x3933C6D305ACDFD5LL).n64_u64[0];
  v24 = veorq_s8(*a1, (int8x16_t)xmmword_B003F0);
  v25 = v13.n128_u8[5];
  v26 = v13.n128_u8[6];
  v27 = v13.n128_u8[0] | v13.n128_u8[1] | v13.n128_u8[2] | v13.n128_u8[3] | v13.n128_u8[4];
  v28 = v13.n128_u8[7];
  v13.n128_u64[0] = vorr_s8((int8x8_t)v24.n128_u64[0], (int8x8_t)vextq_s8(v24, v24, 8uLL).n128_u64[0]).n64_u64[0];
  v24.n128_u64[0] = veor_s8(v4, (int8x8_t)0xC6CC392CFA53202ALL).n64_u64[0];
  v29 = v22 | v4.n64_u8[1] | v4.n64_u8[2] | v4.n64_u8[3] | v4.n64_u8[5];
  v30 = vorr_s8((int8x8_t)(unsigned __int8)(v27 | v25 | v26 | v28), (int8x8_t)v24.n128_u64[0]).n64_u8[0];
  v31 = v20 | v4.n64_u8[1] | v4.n64_u8[2] | v4.n64_u8[3] | v4.n64_u8[5] | v4.n64_u8[7];
  v32 = v24.n128_u8[7];
  v33 = v24.n128_u8[6];
  v34 = v24.n128_u8[5];
  v35 = v24.n128_u8[4];
  v36 = v24.n128_u8[3];
  v37 = v24.n128_u8[2];
  v38 = v24.n128_u8[1];
  v39 = veorq_s8(*a1, (int8x16_t)xmmword_B03E90);
  v40 = veorq_s8(*a1, (int8x16_t)xmmword_B03080);
  v39.n128_u64[0] = vorr_s8((int8x8_t)v39.n128_u64[0], (int8x8_t)vextq_s8(v39, v39, 8uLL).n128_u64[0]).n64_u64[0];
  v40.n128_u64[0] = vorr_s8((int8x8_t)v40.n128_u64[0], (int8x8_t)vextq_s8(v40, v40, 8uLL).n128_u64[0]).n64_u64[0];
  v41 = vorr_s8((int8x8_t)v21, v23).n64_u8[0] | v23.n64_u8[1] | v23.n64_u8[2] | v23.n64_u8[3] | v23.n64_u8[4] | v23.n64_u8[5] | v23.n64_u8[6] | v23.n64_u8[7];
  v42 = v39.n128_u8[5];
  v43 = v39.n128_u8[4];
  v44 = v39.n128_u8[6];
  v45 = v39.n128_u8[0] | v39.n128_u8[1] | v39.n128_u8[2] | v39.n128_u8[3];
  v46 = v39.n128_u8[7];
  v39.n128_u64[0] = vmvn_s8(v4).n64_u64[0];
  v47 = v45 | v43 | v42;
  v48 = v40.n128_u8[0] | v40.n128_u8[1] | v40.n128_u8[2] | v40.n128_u8[3] | v40.n128_u8[4];
  v49 = v30 | v38 | v37 | v36 | v35 | v34;
  v50 = vorn_s8(
          (int8x8_t)(unsigned __int8)(v13.n128_u8[0] | v13.n128_u8[1] | v13.n128_u8[2] | v13.n128_u8[3] | v13.n128_u8[4] | v13.n128_u8[5] | v13.n128_u8[6] | v13.n128_u8[7]),
          v4).n64_u8[0] | v39.n128_u8[1];
  v40.n128_u8[0] = vorn_s8((int8x8_t)(unsigned __int8)(v47 | v44 | v46), v4).n64_u8[0];
  v4.n64_u8[0] = vorn_s8((int8x8_t)(unsigned __int8)(v48 | v40.n128_u8[5] | v40.n128_u8[6] | v40.n128_u8[7]), v4).n64_u8[0];
  v51 = v49 | v33 | v32;
  v52 = v50 | v39.n128_u8[2] | v39.n128_u8[3] | v39.n128_u8[4] | v39.n128_u8[5] | v39.n128_u8[6] | v39.n128_u8[7];
  v53 = a1[1].n128_u8[8];
  v54 = a1[1].n128_u8[9];
  v55 = v41 | v53 ^ 0xB1;
  v56 = v51 | v53 ^ 0x4E;
  v57 = a1[1].n128_u8[10];
  v58 = v31 | v53 | v54;
  v59 = v29 | HIWORD(a1[1].n128_u64[0]) | v4.n64_u8[7] | v53 | v54;
  v60 = v54 ^ 0x38;
  v61 = v54 ^ 0xC7;
  v62 = v53 & v54;
  v63 = a1[1].n128_u8[11];
  v64 = v55 | v60 | v57 ^ 2;
  v65 = v56 | v61 | v57 ^ 0xFD;
  v66 = a1[1].n128_u8[12];
  v67 = v62 & v57;
  v68 = a1[1].n128_u8[13];
  v69 = v64 | v63 ^ 0x88;
  v70 = v58 | v57 | v63 | v66;
  v71 = v59 | v57 | v63 | v66;
  v72 = v66 ^ 0x6D;
  v73 = v65 | v63 ^ 0x77 | v66 ^ 0x92;
  v74 = v67 & v63 & v66;
  v75 = a1[1].n128_u8[14];
  v76 = a1[1].n128_u8[15];
  v77 = v74 & v68 & v75;
  return ((((unsigned __int8)(v4.n64_u8[0] | v39.n128_u8[1] | v39.n128_u8[2] | v39.n128_u8[3] | v39.n128_u8[4] | v39.n128_u8[5] | v39.n128_u8[6] | v39.n128_u8[7] | ~v77 | v76 & 0x7F ^ 0x7F)
          - 1) | ((unsigned __int8)(v40.n128_u8[0] | v39.n128_u8[1] | v39.n128_u8[2] | v39.n128_u8[3] | v39.n128_u8[4] | v39.n128_u8[5] | v39.n128_u8[6] | v39.n128_u8[7] | ~v77 | v76 & 0x7F ^ 0x7F)
                - 1) | ((unsigned __int8)(v52 | ~v77 | v76 & 0x7F ^ 0x7F) - 1) | ((unsigned __int8)(v73 | v68 ^ 0xAC | v75 ^ 3 | v76 & 0x7F ^ 0x7A)
                                                                                - 1) | ((unsigned __int8)(v69 | v72 | v68 ^ 0x53 | v75 ^ 0xFC | v76 & 0x7F ^ 5)
                                                                                      - 1) | ((unsigned __int8)(v71 | v68 | v75 | v76 & 0x7F)
                                                                                            - 1) | (((unsigned __int8)(v70 | v68 | v75) | v76 & 0x7Fu)
                                                                                                  - 1)) >> 8) & 1;
}


================================================================================
Function: sub_67F08E4 (0x67F08E4)
================================================================================

unsigned __int16 *__fastcall sub_67F08E4(unsigned __int16 *result)
{
  int v1; // w9
  int v2; // w14
  unsigned __int8 v3; // w2
  unsigned __int64 v4; // x4
  unsigned __int64 v5; // x17
  int v6; // w15
  int v7; // w5
  int v8; // w23
  unsigned __int64 v9; // x21
  unsigned __int64 v10; // x24
  int v11; // w25
  unsigned __int8 v12; // w2
  unsigned __int64 v13; // x28
  unsigned __int8 v14; // w10
  unsigned __int64 v15; // x27
  unsigned __int64 v16; // x23
  unsigned __int64 v17; // x20
  unsigned __int64 v18; // x25
  unsigned __int64 v19; // x7
  unsigned __int64 v20; // x4
  unsigned __int64 v21; // x22
  __int64 v22; // x21
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x30
  unsigned __int64 v25; // x3
  unsigned __int64 v26; // x26
  unsigned __int64 v27; // x19
  unsigned __int64 v28; // x9
  unsigned __int64 v29; // x10
  unsigned __int64 v30; // x6
  unsigned __int64 v31; // x13
  unsigned __int64 v32; // x10
  unsigned __int64 v33; // x22
  unsigned __int64 v34; // x5
  unsigned __int64 v35; // x12
  unsigned __int64 v36; // x14
  __int64 v37; // x4
  unsigned __int64 v38; // x3
  unsigned __int64 v39; // x11
  unsigned __int64 v40; // x8
  unsigned __int64 v41; // x5
  unsigned __int64 v42; // x6
  unsigned __int64 v43; // x20
  __int64 v44; // x19
  __int64 v45; // x4
  unsigned __int64 v46; // x9
  __int64 v47; // x7
  __int64 v48; // x21
  unsigned __int64 v49; // x6
  unsigned __int64 v50; // x10
  __int64 v51; // x8
  __int64 v52; // x5
  unsigned __int64 v53; // x10
  unsigned __int64 v54; // x3
  signed __int64 v55; // x20
  signed __int64 v56; // x4
  signed __int64 v57; // x25
  __int64 v58; // x8
  unsigned __int64 v59; // x14
  signed __int64 v60; // x21
  __int64 v61; // x19
  __int64 v62; // x8
  __int64 v63; // x5
  signed __int64 v64; // x8
  __int64 v65; // x7
  __int64 v66; // x14
  unsigned __int64 v67; // x3
  unsigned __int64 v68; // x6
  unsigned __int64 v69; // x10
  __int64 v70; // x11
  __int64 v71; // x3
  __int64 v72; // x12
  unsigned __int64 v73; // x10
  unsigned __int64 v74; // x6
  __int64 v75; // x13
  __int64 v76; // x10
  signed __int64 v77; // x9
  __int64 v78; // x2
  __int64 v79; // x16
  __int64 v80; // x15
  __int64 v81; // x17
  __int64 v82; // x1
  __int64 v83; // x8
  __int64 v84; // x14
  __int64 v85; // x8
  __int64 v86; // x11
  __int64 v87; // x13
  __int64 v88; // x10
  unsigned __int64 v89; // x9
  unsigned __int64 v90; // [xsp+8h] [xbp-78h]
  unsigned __int64 v91; // [xsp+18h] [xbp-68h]

  v1 = *((unsigned __int8 *)result + 5);
  v2 = *((unsigned __int8 *)result + 13);
  v3 = *((_BYTE *)result + 18);
  v4 = ((unsigned __int64)(*((unsigned __int8 *)result + 15) | (unsigned __int16)(*((unsigned __int8 *)result + 16) << 8) | (*((unsigned __int8 *)result + 17) << 16) & 0xFFFFFF | (v3 << 24)) >> 6) & 0x1FFFFF;
  v5 = v3 & 0xF8 | (unsigned __int64)(unsigned __int16)(*((unsigned __int8 *)result + 19) << 8) | ((unsigned __int64)*((unsigned __int8 *)result + 20) << 16);
  v6 = *((unsigned __int8 *)result + 26);
  v91 = *((unsigned __int8 *)result + 2) | (unsigned __int16)(*((unsigned __int8 *)result + 3) << 8) | (*((unsigned __int8 *)result + 4) << 16) & 0xFFFFFF | ((unsigned __int8)v1 << 24);
  v7 = *((unsigned __int8 *)result + 34);
  v8 = *((unsigned __int8 *)result + 47);
  v9 = *((unsigned __int8 *)result + 44) | (unsigned __int16)(*((unsigned __int8 *)result + 45) << 8) | (*((unsigned __int8 *)result + 46) << 16) & 0xFFFFFF | ((unsigned __int8)v8 << 24);
  v10 = ((unsigned __int64)(v8 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 48) << 8) | (*((unsigned __int8 *)result + 49) << 16)) >> 2) & 0x1FFFFF;
  v11 = *((unsigned __int8 *)result + 55);
  v12 = *((_BYTE *)result + 60);
  v13 = ((unsigned __int64)(*((unsigned __int8 *)result + 49) | (unsigned __int16)(*((unsigned __int8 *)result + 50) << 8) | (*((unsigned __int8 *)result + 51) << 16) & 0xFFFFFF | (*((unsigned __int8 *)result + 52) << 24)) >> 7) & 0x1FFFFF;
  v90 = v1 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 6) << 8) | (*((unsigned __int8 *)result + 7) << 16);
  v14 = *((_BYTE *)result + 39);
  v15 = v12 & 0xF8 | (unsigned __int64)(unsigned __int16)(*((unsigned __int8 *)result + 61) << 8) | ((unsigned __int64)*((unsigned __int8 *)result + 62) << 16) & 0xFFFFFFFF00FFFFFFLL | ((unsigned __int64)*((unsigned __int8 *)result + 63) << 24);
  v16 = ((unsigned __int64)(*((unsigned __int8 *)result + 52) | (unsigned __int16)(*((unsigned __int8 *)result + 53) << 8) | (*((unsigned __int8 *)result + 54) << 16) & 0xFFFFFF | ((unsigned __int8)v11 << 24)) >> 4) & 0x1FFFFF;
  v17 = ((unsigned __int64)(v11 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 56) << 8) | (*((unsigned __int8 *)result + 57) << 16)) >> 1) & 0x1FFFFF;
  v18 = ((unsigned __int64)(*((unsigned __int8 *)result + 57) | (unsigned __int16)(*((unsigned __int8 *)result + 58) << 8) | (*((unsigned __int8 *)result + 59) << 16) & 0xFFFFFF | (v12 << 24)) >> 6) & 0x1FFFFF;
  v19 = ((*((unsigned __int8 *)result + 23) << 16) & 0x1F0000 | (unsigned __int64)*(unsigned __int16 *)((char *)result + 21))
      + 654183 * v10
      + 470296 * v13
      + 666643 * v16;
  v20 = v4 + 666643 * v10;
  v21 = (result[21] | (unsigned __int64)((*((unsigned __int8 *)result + 44) << 16) & 0x1F0000)) - 683901 * (v15 >> 3);
  v22 = ((v9 >> 5) & 0x1FFFFF) + ((__int64)(v21 + 0x100000) >> 21);
  v23 = (((unsigned __int64)(*((unsigned __int8 *)result + 23) | (unsigned __int16)(*((unsigned __int8 *)result + 24) << 8) | (*((unsigned __int8 *)result + 25) << 16) & 0xFFFFFF | ((unsigned __int8)v6 << 24)) >> 5) & 0x1FFFFF)
      - 997805 * v10
      + 654183 * v13
      + 470296 * v16
      + 666643 * v17
      + ((v19 + 0x100000) >> 21);
  v24 = 470296 * v10 + (v5 >> 3) + ((v20 + 0x100000) >> 21) + 666643 * v13;
  v25 = (((unsigned __int64)(*((unsigned __int8 *)result + 36) | (unsigned __int16)(*((unsigned __int8 *)result + 37) << 8) | (*((unsigned __int8 *)result + 38) << 16) & 0xFFFFFF | (v14 << 24)) >> 6) & 0x1FFFFF)
      - 683901 * v17
      + 136657 * v18
      - 997805 * (v15 >> 3);
  v26 = (((unsigned __int64)(*((unsigned __int8 *)result + 31) | (unsigned __int16)(*((unsigned __int8 *)result + 32) << 8) | (*((unsigned __int8 *)result + 33) << 16) & 0xFFFFFF | ((unsigned __int8)v7 << 24)) >> 4) & 0x1FFFFF)
      - 683901 * v13
      + 136657 * v16
      - 997805 * v17
      + 654183 * v18
      + 470296 * (v15 >> 3);
  v27 = (((unsigned __int64)(v6 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 27) << 8) | (*((unsigned __int8 *)result + 28) << 16)) >> 2) & 0x1FFFFF)
      + 136657 * v10
      - 997805 * v13
      + 654183 * v16
      + 470296 * v17
      + 666643 * v18;
  v28 = (((unsigned __int64)(*((unsigned __int8 *)result + 28) | (unsigned __int16)(*((unsigned __int8 *)result + 29) << 8) | (*((unsigned __int8 *)result + 30) << 16) & 0xFFFFFF | (*((unsigned __int8 *)result + 31) << 24)) >> 7) & 0x1FFFFF)
      - 683901 * v10
      + 136657 * v13
      - 997805 * v16
      + 654183 * v17
      + 470296 * v18
      + 666643 * (v15 >> 3)
      + ((__int64)(v27 + 0x100000) >> 21);
  v29 = -683901LL * v18
      + ((v14 & 0xF8 | (unsigned __int64)(unsigned __int16)(*((unsigned __int8 *)result + 40) << 8) | ((unsigned __int64)*((unsigned __int8 *)result + 41) << 16)) >> 3)
      + 136657 * (v15 >> 3)
      + ((__int64)(v25 + 0x100000) >> 21);
  v30 = v21 - ((v21 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((__int64)(v29 + 0x100000) >> 21);
  v31 = v27 + ((__int64)(v23 + 0x100000) >> 21) - ((v27 + 0x100000) & 0xFFFFFFFFFFE00000LL) - 683901 * v22;
  v32 = v29 - ((v29 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v33 = (((unsigned __int64)(*((unsigned __int8 *)result + 10) | (unsigned __int16)(*((unsigned __int8 *)result + 11) << 8) | (*((unsigned __int8 *)result + 12) << 16) & 0xFFFFFF | ((unsigned __int8)v2 << 24)) >> 4) & 0x1FFFFF)
      + 666643 * v30;
  v34 = (((unsigned __int64)(v7 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 35) << 8) | (*((unsigned __int8 *)result + 36) << 16)) >> 1) & 0x1FFFFF)
      - 683901 * v16
      + 136657 * v17
      - 997805 * v18
      + 654183 * (v15 >> 3)
      + ((__int64)(v26 + 0x100000) >> 21);
  v35 = v23 - ((v23 + 0x100000) & 0xFFFFFFFFFFE00000LL) + 136657 * v22 - 683901 * v30;
  v36 = (((unsigned __int64)(v2 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 14) << 8) | (*((unsigned __int8 *)result + 15) << 16)) >> 1) & 0x1FFFFF)
      + 666643 * v22
      + 470296 * v30
      + 654183 * v32;
  v37 = v20 - ((v20 + 0x100000) & 0x7FFFFE00000LL) + 470296 * v22 + 654183 * v30 - 997805 * v32;
  v38 = v25 - ((v25 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((__int64)(v34 + 0x100000) >> 21);
  v39 = v19
      + ((v24 + 0x100000) >> 21)
      - ((v19 + 0x100000) & 0x1FFFFFE00000LL)
      - 997805 * v22
      + 136657 * v30
      - 683901 * v32;
  v40 = v26 - ((v26 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((__int64)(v28 + 0x100000) >> 21);
  v41 = v34 - ((v34 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v42 = v24 - ((v24 + 0x100000) & 0xFFFFFFFFFFE00000LL) + 654183 * v22 - 997805 * v30 + 136657 * v32 - 683901 * v38;
  v43 = (*result | (unsigned __int64)((*((unsigned __int8 *)result + 2) << 16) & 0x1F0000)) + 666643 * v40;
  v44 = ((v91 >> 5) & 0x1FFFFF) + 470296 * v40 + 666643 * v41 + ((__int64)(v43 + 0x100000) >> 21);
  v45 = v37 + 136657 * v38 - 683901 * v41;
  v46 = v28 - ((v28 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((__int64)(v31 + 0x100000) >> 21);
  v47 = ((v90 >> 2) & 0x1FFFFF) + 654183 * v40 + 666643 * v38 + 470296 * v41;
  v48 = v33 + 470296 * v32 + 136657 * v40 + 654183 * v38 - 997805 * v41;
  v49 = v42 + ((v45 + 0x100000) >> 21);
  v50 = (((unsigned __int64)(*((unsigned __int8 *)result + 7) | (unsigned __int16)(*((unsigned __int8 *)result + 8) << 8) | (*((unsigned __int8 *)result + 9) << 16) & 0xFFFFFF | (*((unsigned __int8 *)result + 10) << 24)) >> 7) & 0x1FFFFF)
      + 666643 * v32
      - 997805 * v40
      + 470296 * v38
      + 654183 * v41;
  v51 = v36 - 683901 * v40 - 997805 * v38 + 136657 * v41;
  v52 = (__int64)(v46 + 0x100000) >> 21;
  v53 = v50 + ((v47 + 0x100000) >> 21);
  v54 = v45 - ((v45 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v55 = v43 - ((v43 + 0x100000) & 0xFFFFFFFFFFE00000LL) + 666643 * v52;
  v56 = v44 + 470296 * v52 - ((v44 + 0x100000) & 0xFFFFFFFFFFE00000LL) + (v55 >> 21);
  v57 = v47 + 654183 * v52 - ((v47 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((v44 + 0x100000) >> 21) + (v56 >> 21);
  v58 = v51 + ((v48 + 0x100000) >> 21);
  v59 = v48 + 136657 * v52 - ((v48 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v60 = v53 - 997805 * v52 - ((v53 + 0x100000) & 0xFFFFFFFFFFE00000LL) + (v57 >> 21);
  v61 = v58 + 0x100000;
  v62 = v58 - 683901 * v52;
  v63 = v59 + ((__int64)(v53 + 0x100000) >> 21) + (v60 >> 21);
  v64 = v62 - (v61 & 0xFFFFFFFFFFE00000LL) + (v63 >> 21);
  v65 = v49 + 0x100000;
  v66 = v54 + (v61 >> 21) + (v64 >> 21);
  v67 = v49 - ((v49 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v68 = v35 + ((__int64)(v39 + 0x100000) >> 21);
  v69 = v39 - ((v39 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v70 = v67 + (v66 >> 21);
  v71 = v68 + 0x100000;
  v72 = v69 + (v65 >> 21) + (v70 >> 21);
  v73 = v68 - ((v68 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v74 = v31 - ((v31 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v75 = v73 + (v72 >> 21);
  v76 = v74 + (v71 >> 21) + (v75 >> 21);
  v77 = v46 - ((v46 + 0x100000) & 0xFFFFFFFFFFE00000LL) + (v76 >> 21);
  v78 = (v55 & 0x1FFFFF) + 666643 * (v77 >> 21);
  v79 = (v56 & 0x1FFFFF) + 470296 * (v77 >> 21) + (v78 >> 21);
  *(_BYTE *)result = v55 + 19 * (v77 >> 21);
  v80 = (v57 & 0x1FFFFF) + 654183 * (v77 >> 21) + (v79 >> 21);
  *((_BYTE *)result + 3) = (unsigned __int64)v79 >> 3;
  v81 = (v60 & 0x1FFFFF) - 997805 * (v77 >> 21) + (v80 >> 21);
  *((_BYTE *)result + 4) = (unsigned __int64)v79 >> 11;
  v82 = (v63 & 0x1FFFFF) + 136657 * (v77 >> 21) + (v81 >> 21);
  LODWORD(v74) = WORD1(v78) & 0x1F | (32 * (v79 & 0x1FFFFF));
  v83 = (v64 & 0x1FFFFF) - 683901 * (v77 >> 21) + (v82 >> 21);
  *((_BYTE *)result + 6) = (unsigned __int64)v80 >> 6;
  *((_BYTE *)result + 5) = ((unsigned int)v79 >> 19) & 3 | (4 * (v57 + 103 * (v77 >> 21) + (v79 >> 21)));
  *((_BYTE *)result + 7) = ((unsigned int)v80 >> 14) & 0x7F | (((_BYTE)v60
                                                              - -83 * (unsigned __int8)(v77 >> 21)
                                                              + (unsigned __int8)(v80 >> 21)) << 7);
  v84 = (v66 & 0x1FFFFF) + (v83 >> 21);
  *((_BYTE *)result + 9) = (unsigned __int64)v81 >> 9;
  *((_BYTE *)result + 8) = (unsigned __int64)v81 >> 1;
  *((_BYTE *)result + 1) = (unsigned __int16)(v55 + 11283 * (v77 >> 21)) >> 8;
  LOBYTE(v79) = v83;
  *((_BYTE *)result + 11) = (unsigned __int64)v82 >> 4;
  *((_BYTE *)result + 2) = v74;
  *((_BYTE *)result + 10) = ((unsigned int)v81 >> 17) & 0xF | (16 * (v63 - 47 * (v77 >> 21) + (v81 >> 21)));
  *((_BYTE *)result + 14) = (unsigned __int64)v83 >> 7;
  *((_BYTE *)result + 15) = ((unsigned int)v83 >> 15) & 0x3F | ((_BYTE)v84 << 6);
  v85 = (v70 & 0x1FFFFF) + (v84 >> 21);
  v86 = (v72 & 0x1FFFFF) + (v85 >> 21);
  *((_BYTE *)result + 12) = (unsigned __int64)v82 >> 12;
  *((_BYTE *)result + 17) = (unsigned __int64)v84 >> 10;
  v87 = (v75 & 0x1FFFFF) + (v86 >> 21);
  *((_BYTE *)result + 18) = ((unsigned int)v84 >> 18) & 7 | (8 * v85);
  *((_BYTE *)result + 19) = (unsigned __int64)v85 >> 5;
  *((_BYTE *)result + 20) = (unsigned __int64)v85 >> 13;
  v88 = (v76 & 0x1FFFFF) + (v87 >> 21);
  *(unsigned __int16 *)((char *)result + 21) = v72 + (v85 >> 21);
  *((_BYTE *)result + 23) = BYTE2(v86) & 0x1F | (32 * v87);
  v89 = (v77 & 0x1FFFFF) + (v88 >> 21);
  *((_BYTE *)result + 25) = (unsigned __int64)v87 >> 11;
  *((_BYTE *)result + 27) = (unsigned __int64)v88 >> 6;
  *((_BYTE *)result + 13) = ((v82 & 0x100000) != 0) | (2 * v79);
  *((_BYTE *)result + 16) = (unsigned __int64)v84 >> 2;
  *((_BYTE *)result + 24) = (unsigned __int64)v87 >> 3;
  *((_BYTE *)result + 26) = ((unsigned int)v87 >> 19) & 3 | (4 * v88);
  *((_BYTE *)result + 28) = ((unsigned int)v88 >> 14) & 0x7F | ((_BYTE)v89 << 7);
  *((_BYTE *)result + 29) = v89 >> 1;
  *((_BYTE *)result + 30) = v89 >> 9;
  *((_BYTE *)result + 31) = v89 >> 17;
  return result;
}


================================================================================
Function: sub_67F1074 (0x67F1074)
================================================================================

bool __fastcall sub_67F1074(__int64 a1)
{
  int v1; // w9
  int v2; // w8
  __int64 i; // x10
  unsigned int v4; // w13
  int v5; // w14

  LOBYTE(v1) = 0;
  v2 = 1;
  for ( i = 31LL; i != -1; --i )
  {
    v4 = *(unsigned __int8 *)(a1 + i);
    v5 = byte_D1C470[i];
    v1 = v2 & ((int)(v4 - v5) >> 8) | (unsigned __int8)v1;
    v2 &= ((v5 ^ v4) + 0xFFFF) >> 8;
  }
  return v1 != 0;
}


================================================================================
Function: sub_67F10C8 (0x67F10C8)
================================================================================

_DWORD *__fastcall sub_67F10C8(_DWORD *result, int *a2)
{
  __int64 v2; // x11
  __int64 v3; // x13
  __int64 v4; // x9
  __int64 v5; // x21
  __int64 v6; // x5
  __int64 v7; // x22
  __int64 v8; // x2
  __int64 v9; // x3
  __int64 v10; // x19
  __int64 v11; // x11
  __int64 v12; // x1
  __int64 v13; // x16
  __int64 v14; // x10
  __int64 v15; // x15
  __int64 v16; // x12
  __int64 v17; // x4
  __int64 v18; // x20
  __int64 v19; // x7
  __int64 v20; // x19
  __int64 v21; // x26
  __int64 v22; // x27
  __int64 v23; // x28
  __int64 v24; // x21
  __int64 v25; // x23
  __int64 v26; // x8
  __int64 v27; // x26
  __int64 v28; // x6
  __int64 v29; // x5
  __int64 v30; // x8
  __int64 v31; // x3
  __int64 v32; // x2
  __int64 v33; // x9
  __int64 v34; // x8
  __int64 v35; // x13
  __int64 v36; // x12
  unsigned __int64 v37; // x14
  __int64 v38; // x13
  __int64 v39; // x9
  unsigned __int64 v40; // x11
  __int64 v41; // [xsp+8h] [xbp-68h]

  v2 = *a2;
  v3 = a2[1];
  v5 = a2[5];
  v4 = a2[6];
  v7 = a2[7];
  v6 = a2[8];
  v8 = a2[9];
  v9 = 2 * v2;
  v10 = v2 * v2;
  v11 = a2[4];
  v13 = a2[2];
  v12 = a2[3];
  v14 = 38 * v8;
  v15 = 2 * v5;
  v16 = 19 * v6;
  v17 = v9 * v3 + 19 * v4 * 2 * v5;
  v41 = 2 * v3 * v3 + v13 * v9 + 19 * v4 * v4;
  v18 = 2 * v3 * v13 + v12 * v9;
  v19 = 2 * (v10 + 38 * v5 * v5 + 19 * v4 * 2 * v11 + 38 * v7 * 2 * v12 + 19 * v6 * 2 * v13 + 38 * v8 * 2 * v3);
  v20 = 2 * v11 * v5;
  v21 = 2 * v13 * v12 + v11 * 2 * v3 + v5 * v9 + 19 * v6 * 2 * v7 + 38 * v8 * v4;
  v22 = v11 * 2 * v13 + 2 * v12 * v12 + 2 * v5 * 2 * v3 + v4 * v9 + 19 * v6 * v6 + 38 * v8 * 2 * v7;
  v23 = 2 * v12 * v11 + v5 * 2 * v13 + v4 * 2 * v3;
  v24 = 2 * (v13 * v13 + 2 * v12 * 2 * v3 + v11 * v9 + 38 * v7 * v7 + 2 * v4 * 19 * v6 + 38 * v8 * 2 * v5);
  v25 = ((v24 + 0x2000000) >> 26) + 2 * v21;
  v26 = v20 + v4 * 2 * v12 + v7 * 2 * v13 + v6 * 2 * v3;
  v27 = v23 + v7 * v9 + 38 * v8 * v6;
  v28 = ((v25 + 0x1000000) >> 25) + 2 * v22;
  v29 = v11 * v11 + v4 * 2 * v13 + v15 * 2 * v12 + 2 * v7 * 2 * v3 + v6 * v9;
  v30 = v26 + v8 * v9;
  v31 = ((v28 + 0x2000000) >> 26) + 2 * v27;
  v32 = ((v31 + 0x1000000) >> 25) + 2 * (v29 + 38 * v8 * v8);
  v33 = v18 + 38 * v7 * v4 + v16 * v15;
  v34 = ((v32 + 0x2000000) >> 26) + 2 * v30;
  v35 = v41 + 38 * v7 * v15 + v16 * 2 * v11 + v14 * 2 * v12;
  v36 = ((v19 + 0x2000000) >> 26) + 2 * (v17 + 38 * v7 * v11 + v16 * 2 * v12 + v14 * v13);
  v37 = v19 - ((v19 + 0x2000000) & 0xFFFFFFFFFC000000LL) + 19 * ((v34 + 0x1000000) >> 25);
  v38 = ((v36 + 0x1000000) >> 25) + 2 * v35;
  v39 = ((v38 + 0x2000000) >> 26) + 2 * (v33 + v14 * v11);
  v40 = v24 - ((v24 + 0x2000000) & 0xFFFFFFFFFC000000LL) + ((v39 + 0x1000000) >> 25);
  *result = v37 - ((v37 + 0x2000000) & 0xFC000000);
  result[1] = v36 - ((v36 + 0x1000000) & 0xFE000000) + ((v37 + 0x2000000) >> 26);
  result[2] = v38 - ((v38 + 0x2000000) & 0xFC000000);
  result[3] = v39 - ((v39 + 0x1000000) & 0xFE000000);
  result[4] = v40 - ((v40 + 0x2000000) & 0xFC000000);
  result[5] = v25 - ((v25 + 0x1000000) & 0xFE000000) + ((v40 + 0x2000000) >> 26);
  result[6] = v28 - ((v28 + 0x2000000) & 0xFC000000);
  result[7] = v31 - ((v31 + 0x1000000) & 0xFE000000);
  result[8] = v32 - ((v32 + 0x2000000) & 0xFC000000);
  result[9] = v34 - ((v34 + 0x1000000) & 0xFE000000);
  return result;
}


================================================================================
Function: sub_67F18D8 (0x67F18D8)
================================================================================

// attributes: thunk
__int64 __fastcall sub_67F18D8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_67F2924(a1, a2, a3, a4);
}


================================================================================
Function: sub_67F18DC (0x67F18DC)
================================================================================

__int64 __fastcall sub_67F18DC(__int64 a1)
{
  __int64 result; // x0

  result = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_OWORD *)(a1 + 32) = xmmword_174CD78;
  *(_OWORD *)(a1 + 48) = unk_174CD88;
  *(_OWORD *)a1 = xmmword_174CD58;
  *(_OWORD *)(a1 + 16) = unk_174CD68;
  return result;
}


================================================================================
Function: sub_67F1904 (0x67F1904)
================================================================================

__int64 __fastcall sub_67F1904(__int64 a1, _OWORD *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  __int64 v4; // x9
  bool v8; // cf
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x24
  unsigned __int64 v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x8
  char *v15; // x9
  _BYTE *v16; // x10
  char v17; // t1
  __int64 v18; // x9
  __int64 v19; // x8
  char *v20; // x9
  char v21; // t1
  unsigned __int64 v22; // x20
  unsigned __int64 v23; // x21
  unsigned __int64 v24; // x8
  __int64 v25; // x10
  unsigned __int64 v26; // x9
  char *v27; // x8
  _BYTE *v28; // x10
  char v29; // t1
  __int128 v31; // q1
  __int64 v32; // x10
  __int128 v33; // q1
  _OWORD *v34; // x10
  __int128 v35; // q1
  unsigned __int64 v36; // x12
  __int64 *v37; // x10
  __int64 v38; // x11
  unsigned __int64 v39; // x12
  _QWORD *v40; // x11
  __int64 v41; // t1
  __int128 v42; // q1
  __int64 v43; // x10
  __int128 v44; // q1
  _OWORD *v45; // x10
  __int128 v46; // q1
  __int128 v47; // q1
  __int64 v48; // x10
  __int64 v49; // x12
  __int64 *v50; // x10
  __int64 v51; // x11
  __int64 v52; // x12
  _QWORD *v53; // x11
  __int64 v54; // t1
  __int128 *v55; // x9
  _OWORD *v56; // x10
  unsigned __int64 v57; // x11
  __int128 v58; // q0
  __int128 v59; // q1
  unsigned __int64 v60; // x11
  __int64 *v61; // x9
  _QWORD *v62; // x10
  unsigned __int64 v63; // x11
  __int64 v64; // t1
  _BYTE v65[640]; // [xsp+8h] [xbp-2C8h] BYREF
  _BYTE v66[64]; // [xsp+288h] [xbp-48h] BYREF

  if ( !a3 )
    return 0LL;
  v4 = *(_QWORD *)(a1 + 64);
  v3 = *(_QWORD *)(a1 + 72);
  v8 = __CFADD__(v3, 8 * a3);
  v9 = v3 + 8 * a3;
  v10 = (v3 >> 3) & 0x7F;
  if ( v8 )
    ++v4;
  v11 = 128 - v10;
  *(_QWORD *)(a1 + 64) = v4 + (a3 >> 61);
  *(_QWORD *)(a1 + 72) = v9;
  if ( 128 - v10 <= a3 )
  {
    if ( v10 > 0x78 || a1 + v10 + 80 < (unsigned __int64)a2 + v11 && a1 + 208 > (unsigned __int64)a2 )
    {
      v18 = 0LL;
      goto LABEL_16;
    }
    if ( v10 <= 0x60 )
    {
      v42 = a2[1];
      v43 = a1 + v10;
      v18 = (unsigned __int8)v11 & 0xE0;
      *(_OWORD *)(v43 + 80) = *a2;
      *(_OWORD *)(v43 + 96) = v42;
      if ( v18 != 32 )
      {
        v44 = a2[3];
        v45 = (_OWORD *)(v10 + a1);
        v45[7] = a2[2];
        v45[8] = v44;
        if ( v18 != 64 )
        {
          v46 = a2[5];
          v45[9] = a2[4];
          v45[10] = v46;
          if ( v18 != 96 )
          {
            v47 = a2[7];
            v48 = v10 + a1;
            *(_OWORD *)(v48 + 176) = a2[6];
            *(_OWORD *)(v48 + 192) = v47;
          }
        }
      }
      if ( v11 == v18 )
        goto LABEL_18;
      if ( (v11 & 0x18) == 0 )
      {
LABEL_16:
        v19 = v18 + v10;
        v20 = (char *)a2 + v18;
        do
        {
          v21 = *v20++;
          *(_BYTE *)(a1 + 80 + v19++) = v21;
        }
        while ( v19 != 128 );
        goto LABEL_18;
      }
    }
    else
    {
      v18 = 0LL;
    }
    v49 = v18;
    v18 = (unsigned __int8)v11 & 0xF8;
    v50 = (__int64 *)((char *)a2 + v49);
    v51 = a1 + v49 + v10;
    v52 = v49 - v18;
    v53 = (_QWORD *)(v51 + 80);
    do
    {
      v54 = *v50++;
      v52 += 8LL;
      *v53++ = v54;
    }
    while ( v52 );
    if ( v11 != v18 )
      goto LABEL_16;
LABEL_18:
    sub_67F1C90(a1, a1 + 80, v65, v66);
    v22 = (unsigned __int64)a2 + v11;
    v23 = a3 - v11;
    if ( v23 >= 0x80 )
    {
      do
      {
        sub_67F1C90(a1, v22, v65, v66);
        v22 += 128LL;
        v23 -= 128LL;
      }
      while ( v23 > 0x7F );
    }
    if ( !v23 )
      goto LABEL_27;
    if ( v23 < 8 || a1 + 80 < v22 + v23 && v22 < a1 + 80 + v23 )
    {
      v24 = 0LL;
LABEL_25:
      v25 = a1 + v24;
      v26 = v23 - v24;
      v27 = (char *)(v22 + v24);
      v28 = (_BYTE *)(v25 + 80);
      do
      {
        v29 = *v27++;
        --v26;
        *v28++ = v29;
      }
      while ( v26 );
LABEL_27:
      sub_67F3560(v65, 704LL);
      return 0LL;
    }
    if ( v23 >= 0x20 )
    {
      v24 = v23 & 0x60;
      v55 = (__int128 *)(v22 + 16);
      v56 = (_OWORD *)(a1 + 96);
      v57 = v23 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v58 = *(v55 - 1);
        v59 = *v55;
        v55 += 2;
        v57 -= 32LL;
        *(v56 - 1) = v58;
        *v56 = v59;
        v56 += 2;
      }
      while ( v57 );
      if ( v23 == v24 )
        goto LABEL_27;
      if ( (v23 & 0x18) == 0 )
        goto LABEL_25;
    }
    else
    {
      v24 = 0LL;
    }
    v60 = v24;
    v24 = v23 & 0xFFFFFFFFFFFFFFF8LL;
    v61 = (__int64 *)(v22 + v60);
    v62 = (_QWORD *)(a1 + v60 + 80);
    v63 = v60 - (v23 & 0xFFFFFFFFFFFFFFF8LL);
    do
    {
      v64 = *v61++;
      v63 += 8LL;
      *v62++ = v64;
    }
    while ( v63 );
    if ( v23 == v24 )
      goto LABEL_27;
    goto LABEL_25;
  }
  if ( a3 < 8 || a1 + 80 + v10 < (unsigned __int64)a2 + a3 && a1 + 80 + v10 + a3 > (unsigned __int64)a2 )
  {
    v12 = 0LL;
    goto LABEL_9;
  }
  if ( a3 >= 0x20 )
  {
    v31 = a2[1];
    v32 = a1 + v10;
    v12 = a3 & 0xFFFFFFFFFFFFFFE0LL;
    *(_OWORD *)(v32 + 80) = *a2;
    *(_OWORD *)(v32 + 96) = v31;
    if ( (a3 & 0xFFFFFFFFFFFFFFE0LL) != 0x20 )
    {
      v33 = a2[3];
      v34 = (_OWORD *)(v10 + a1);
      v34[7] = a2[2];
      v34[8] = v33;
      if ( v12 != 64 )
      {
        v35 = a2[5];
        v34[9] = a2[4];
        v34[10] = v35;
      }
    }
    if ( v12 == a3 )
      return 0LL;
    if ( (a3 & 0x18) == 0 )
    {
LABEL_9:
      v13 = v12 + v10;
      v14 = a3 - v12;
      v15 = (char *)a2 + v12;
      v16 = (_BYTE *)(a1 + v13 + 80);
      do
      {
        v17 = *v15++;
        --v14;
        *v16++ = v17;
      }
      while ( v14 );
      return 0LL;
    }
  }
  else
  {
    v12 = 0LL;
  }
  v36 = v12;
  v12 = a3 & 0xFFFFFFFFFFFFFFF8LL;
  v37 = (__int64 *)((char *)a2 + v36);
  v38 = a1 + v36 + v10;
  v39 = v36 - (a3 & 0xFFFFFFFFFFFFFFF8LL);
  v40 = (_QWORD *)(v38 + 80);
  do
  {
    v41 = *v37++;
    v39 += 8LL;
    *v40++ = v41;
  }
  while ( v39 );
  if ( v12 != a3 )
    goto LABEL_9;
  return 0LL;
}


================================================================================
Function: sub_67F1C90 (0x67F1C90)
================================================================================

__int128 *__fastcall sub_67F1C90(__int128 *result, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 i; // x8
  __int128 v5; // q0
  __int64 v6; // x8
  __int128 v7; // q2
  __int128 v8; // q3
  __int64 v9; // x4
  __int64 v10; // x12
  _QWORD *v11; // x10
  __int64 v12; // x13
  __int64 v13; // x19
  __int64 v14; // x14
  __int64 v15; // x17
  __int64 v16; // x5
  __int64 v17; // x15
  __int64 v18; // x1
  __int64 v19; // x15
  __int64 v20; // x13
  __int64 v21; // x16
  __int64 v22; // x13
  __int64 v23; // x7
  __int64 v24; // x5
  __int64 v25; // x4
  __int64 v26; // x14
  __int64 v27; // x12
  __int64 v28; // x17
  __int64 v29; // x12
  __int64 v30; // x7
  __int64 v31; // x1
  __int64 v32; // x6
  __int64 v33; // x15
  __int64 v34; // x16
  __int64 v35; // x1
  __int64 v36; // x13
  __int64 v37; // x19
  __int64 v38; // x16
  __int64 v39; // x7
  __int64 v40; // x14
  __int64 v41; // x16
  __int64 v42; // x5
  __int64 v43; // x16
  __int64 v44; // x4
  __int64 v45; // x6
  __int64 v46; // x12
  __int64 v47; // x17
  __int64 v48; // x12
  __int64 v49; // x15
  __int64 v50; // x4
  __int64 v51; // x13
  __int64 v52; // x6
  __int64 v53; // x7
  __int64 v54; // x15
  __int64 v55; // x1
  __int64 v56; // x14
  __int64 v57; // x15
  __int64 v58; // x16
  __int64 v59; // x15
  __int64 v60; // x7
  __int64 v61; // x20
  __int64 v62; // x17
  __int64 v63; // x12
  __int64 v64; // x17
  __int64 v65; // x4
  __int64 v66; // x13
  __int64 v67; // x4
  __int64 v68; // x7
  __int64 v69; // x11
  __int64 v70; // x1
  __int64 v71; // x14
  __int64 v72; // x1
  __int64 v73; // x11
  __int64 v74; // x14
  __int64 v75; // x11
  unsigned __int64 v76; // x11
  unsigned __int64 v77; // x12
  unsigned __int64 v78; // x13
  unsigned __int64 v79; // x6
  unsigned __int64 v80; // x7
  unsigned __int64 v81; // x17
  unsigned __int64 v82; // x16
  unsigned __int64 v83; // x1
  unsigned __int64 v84; // x14
  unsigned __int64 v85; // x15
  unsigned __int64 v86; // x13
  __int64 v87; // x4
  unsigned __int64 v88; // x20
  unsigned __int64 v89; // x4
  unsigned __int64 v90; // x7
  unsigned __int64 v91; // x21
  unsigned __int64 v92; // x4
  unsigned __int64 v93; // x23
  unsigned __int64 v94; // x24
  unsigned __int64 v95; // x17
  unsigned __int64 v96; // x5
  unsigned __int64 v97; // x5
  unsigned __int64 v98; // x19
  unsigned __int64 v99; // x25
  unsigned __int64 v100; // x11
  unsigned __int64 v101; // x12
  unsigned __int64 v102; // x7
  unsigned __int64 v103; // x6
  unsigned __int64 v104; // x13
  unsigned __int64 v105; // x17
  unsigned __int64 v106; // x1
  unsigned __int64 v107; // x11
  unsigned __int64 v108; // x5
  unsigned __int64 v109; // x12
  __int64 v110; // x9
  __int64 v111; // x8
  __int64 v112; // x9
  __int64 v113; // x10
  __int64 v114; // x8
  __int64 v115; // x9
  __int64 v116; // x10
  __int64 v117; // x8
  __int64 v118; // x9
  __int64 v119; // x10

  for ( i = 0LL; i != 128; i += 8LL )
    *(_QWORD *)(a3 + i) = bswap64(*(_QWORD *)(a2 + i));
  v5 = result[3];
  v6 = 0LL;
  v8 = *result;
  v7 = result[1];
  *((_OWORD *)a4 + 2) = result[2];
  *((_OWORD *)a4 + 3) = v5;
  *(_OWORD *)a4 = v8;
  *((_OWORD *)a4 + 1) = v7;
  while ( 1 )
  {
    v10 = a4[4];
    v9 = a4[5];
    v11 = (_QWORD *)(a3 + v6);
    v12 = a4[6];
    v13 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 8);
    v15 = *a4;
    v14 = a4[1];
    v16 = a4[2];
    v17 = *(_QWORD *)(a3 + v6)
        + (__ROR8__(v10, 14) ^ __ROR8__(v10, 18) ^ __ROR8__(v10, 41))
        + *(_QWORD *)((char *)&unk_174CD98 + v6)
        + (v9 & v10 | v12 & ~v10)
        + a4[7];
    v18 = v17 + a4[3];
    v19 = (__ROR8__(*a4, 28) ^ __ROR8__(*a4, 34) ^ __ROR8__(*a4, 39)) + v17 + ((v16 | v14) & *a4 | v16 & v14);
    a4[3] = v18;
    a4[7] = v19;
    v20 = (v10 & v18 | v9 & ~v18)
        + v12
        + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41))
        + *(_QWORD *)(a3 + v6 + 8)
        + v13;
    v21 = v20 + v16;
    a4[2] = v20 + v16;
    v22 = (v19 & (v14 | v15) | v14 & v15) + v20 + (__ROR8__(v19, 28) ^ __ROR8__(v19, 34) ^ __ROR8__(v19, 39));
    a4[6] = v22;
    v23 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 24);
    v24 = *(_QWORD *)(a3 + v6 + 16)
        + v9
        + *(_QWORD *)((char *)&unk_174CD98 + v6 + 16)
        + (v18 & v21 | v10 & ~v21)
        + (__ROR8__(v21, 14) ^ __ROR8__(v21, 18) ^ __ROR8__(v21, 41));
    v25 = v24 + v14;
    v26 = (__ROR8__(v22, 28) ^ __ROR8__(v22, 34) ^ __ROR8__(v22, 39)) + (v22 & (v19 | v15) | v19 & v15) + v24;
    a4[1] = v25;
    a4[5] = v26;
    v27 = *(_QWORD *)(a3 + v6 + 24)
        + v10
        + v23
        + (v21 & v25 | v18 & ~v25)
        + (__ROR8__(v25, 14) ^ __ROR8__(v25, 18) ^ __ROR8__(v25, 41));
    v28 = v27 + v15;
    v29 = (__ROR8__(v26, 28) ^ __ROR8__(v26, 34) ^ __ROR8__(v26, 39)) + (v26 & (v22 | v19) | v22 & v19) + v27;
    *a4 = v28;
    a4[4] = v29;
    v30 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 40);
    v31 = *(_QWORD *)(a3 + v6 + 32)
        + v18
        + *(_QWORD *)((char *)&unk_174CD98 + v6 + 32)
        + (v25 & v28 | v21 & ~v28)
        + (__ROR8__(v28, 14) ^ __ROR8__(v28, 18) ^ __ROR8__(v28, 41));
    v32 = v31 + v19;
    v33 = (__ROR8__(v29, 28) ^ __ROR8__(v29, 34) ^ __ROR8__(v29, 39)) + (v29 & (v26 | v22) | v26 & v22) + v31;
    a4[7] = v32;
    a4[3] = v33;
    v34 = *(_QWORD *)(a3 + v6 + 40)
        + v21
        + v30
        + (v28 & v32 | v25 & ~v32)
        + (__ROR8__(v32, 14) ^ __ROR8__(v32, 18) ^ __ROR8__(v32, 41));
    v35 = v34 + v22;
    v36 = (__ROR8__(v33, 28) ^ __ROR8__(v33, 34) ^ __ROR8__(v33, 39)) + (v33 & (v29 | v26) | v29 & v26) + v34;
    a4[6] = v35;
    a4[2] = v36;
    v37 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 56);
    v38 = *(_QWORD *)(a3 + v6 + 48)
        + v25
        + *(_QWORD *)((char *)&unk_174CD98 + v6 + 48)
        + (v32 & v35 | v28 & ~v35)
        + (__ROR8__(v35, 14) ^ __ROR8__(v35, 18) ^ __ROR8__(v35, 41));
    v39 = v38 + v26;
    v40 = (__ROR8__(v36, 28) ^ __ROR8__(v36, 34) ^ __ROR8__(v36, 39)) + (v36 & (v33 | v29) | v33 & v29) + v38;
    a4[5] = v39;
    a4[1] = v40;
    v41 = *(_QWORD *)(a3 + v6 + 56)
        + v28
        + v37
        + (v35 & v39 | v32 & ~v39)
        + (__ROR8__(v39, 14) ^ __ROR8__(v39, 18) ^ __ROR8__(v39, 41));
    v42 = v41 + v29;
    v43 = (__ROR8__(v40, 28) ^ __ROR8__(v40, 34) ^ __ROR8__(v40, 39)) + (v40 & (v36 | v33) | v36 & v33) + v41;
    a4[4] = v42;
    *a4 = v43;
    v44 = *(_QWORD *)(a3 + v6 + 64) + v32;
    v45 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 72);
    v46 = v44
        + *(_QWORD *)((char *)&unk_174CD98 + v6 + 64)
        + (v39 & v42 | v35 & ~v42)
        + (__ROR8__(v42, 14) ^ __ROR8__(v42, 18) ^ __ROR8__(v42, 41));
    v47 = v46 + v33;
    v48 = (__ROR8__(v43, 28) ^ __ROR8__(v43, 34) ^ __ROR8__(v43, 39)) + (v43 & (v40 | v36) | v40 & v36) + v46;
    a4[3] = v47;
    a4[7] = v48;
    v49 = *(_QWORD *)(a3 + v6 + 72)
        + v35
        + v45
        + (v42 & v47 | v39 & ~v47)
        + (__ROR8__(v47, 14) ^ __ROR8__(v47, 18) ^ __ROR8__(v47, 41));
    v50 = v49 + v36;
    v51 = (__ROR8__(v48, 28) ^ __ROR8__(v48, 34) ^ __ROR8__(v48, 39)) + (v48 & (v43 | v40) | v43 & v40) + v49;
    a4[2] = v50;
    a4[6] = v51;
    v52 = v39 + *(_QWORD *)(a3 + v6 + 80);
    v53 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 88);
    v54 = v52
        + *(_QWORD *)((char *)&unk_174CD98 + v6 + 80)
        + (v47 & v50 | v42 & ~v50)
        + (__ROR8__(v50, 14) ^ __ROR8__(v50, 18) ^ __ROR8__(v50, 41));
    v55 = v54 + v40;
    v56 = (__ROR8__(v51, 28) ^ __ROR8__(v51, 34) ^ __ROR8__(v51, 39)) + (v51 & (v48 | v43) | v48 & v43) + v54;
    a4[1] = v55;
    a4[5] = v56;
    v57 = v53
        + *(_QWORD *)(a3 + v6 + 88)
        + v42
        + (v50 & v55 | v47 & ~v55)
        + (__ROR8__(v55, 14) ^ __ROR8__(v55, 18) ^ __ROR8__(v55, 41));
    v58 = v57 + v43;
    v59 = (__ROR8__(v56, 28) ^ __ROR8__(v56, 34) ^ __ROR8__(v56, 39)) + (v56 & (v51 | v48) | v51 & v48) + v57;
    *a4 = v58;
    v60 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 96);
    v61 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 104);
    a4[4] = v59;
    v62 = v60
        + *(_QWORD *)(a3 + v6 + 96)
        + v47
        + (v55 & v58 | v50 & ~v58)
        + (__ROR8__(v58, 14) ^ __ROR8__(v58, 18) ^ __ROR8__(v58, 41));
    v63 = v62 + v48;
    v64 = (__ROR8__(v59, 28) ^ __ROR8__(v59, 34) ^ __ROR8__(v59, 39)) + (v59 & (v56 | v51) | v56 & v51) + v62;
    a4[7] = v63;
    a4[3] = v64;
    v65 = v61
        + *(_QWORD *)(a3 + v6 + 104)
        + v50
        + (v58 & v63 | v55 & ~v63)
        + (__ROR8__(v63, 14) ^ __ROR8__(v63, 18) ^ __ROR8__(v63, 41));
    v66 = v65 + v51;
    v67 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v59 | v56) | v59 & v56) + v65;
    a4[6] = v66;
    v68 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 112);
    v69 = *(_QWORD *)((char *)&unk_174CD98 + v6 + 120);
    a4[2] = v67;
    v70 = v68
        + *(_QWORD *)(a3 + v6 + 112)
        + v55
        + (v63 & v66 | v58 & ~v66)
        + (__ROR8__(v66, 14) ^ __ROR8__(v66, 18) ^ __ROR8__(v66, 41));
    v71 = v70 + v56;
    v72 = (__ROR8__(v67, 28) ^ __ROR8__(v67, 34) ^ __ROR8__(v67, 39)) + (v67 & (v64 | v59) | v64 & v59) + v70;
    a4[5] = v71;
    a4[1] = v72;
    v73 = v69
        + *(_QWORD *)(a3 + v6 + 120)
        + v58
        + (v66 & v71 | v63 & ~v71)
        + (__ROR8__(v71, 14) ^ __ROR8__(v71, 18) ^ __ROR8__(v71, 41));
    v74 = v73 + v59;
    v75 = (__ROR8__(v72, 28) ^ __ROR8__(v72, 34) ^ __ROR8__(v72, 39)) + (v72 & (v67 | v64) | v67 & v64) + v73;
    a4[4] = v74;
    *a4 = v75;
    if ( v6 == 512 )
      break;
    v76 = v11[14];
    v77 = v11[15];
    v6 += 128LL;
    v78 = v11[1];
    v79 = v11[8];
    v80 = v11[2];
    v81 = v11[3];
    v82 = (__ROR8__(v76, 19) ^ __ROR8__(v76, 61) ^ (v76 >> 6))
        + v11[9]
        + *v11
        + (__ROR8__(v78, 1) ^ __ROR8__(v78, 8) ^ (v78 >> 7));
    v83 = v11[9];
    v84 = v11[13];
    v85 = v76;
    v86 = v11[10]
        + v78
        + (__ROR8__(v77, 19) ^ __ROR8__(v77, 61) ^ (v77 >> 6))
        + (__ROR8__(v80, 1) ^ __ROR8__(v80, 8) ^ (v80 >> 7));
    v88 = v11[10];
    v87 = v11[11];
    v11[16] = v82;
    v11[17] = v86;
    v89 = (__ROR8__(v82, 19) ^ __ROR8__(v82, 61) ^ (v82 >> 6)) + v87 + v80;
    v90 = v11[4];
    v91 = v11[5];
    v92 = v89 + (__ROR8__(v81, 1) ^ __ROR8__(v81, 8) ^ (v81 >> 7));
    v93 = v11[11];
    v94 = v11[12];
    v95 = (__ROR8__(v86, 19) ^ __ROR8__(v86, 61) ^ (v86 >> 6))
        + v94
        + v81
        + (__ROR8__(v90, 1) ^ __ROR8__(v90, 8) ^ (v90 >> 7));
    v96 = (__ROR8__(v92, 19) ^ __ROR8__(v92, 61) ^ (v92 >> 6)) + v11[13] + v90;
    v11[18] = v92;
    v11[19] = v95;
    v97 = v96 + (__ROR8__(v91, 1) ^ __ROR8__(v91, 8) ^ (v91 >> 7));
    v99 = v11[6];
    v98 = v11[7];
    v100 = (__ROR8__(v95, 19) ^ __ROR8__(v95, 61) ^ (v95 >> 6))
         + v76
         + v91
         + (__ROR8__(v99, 1) ^ __ROR8__(v99, 8) ^ (v99 >> 7));
    v101 = (__ROR8__(v97, 19) ^ __ROR8__(v97, 61) ^ (v97 >> 6))
         + v77
         + v99
         + (__ROR8__(v98, 1) ^ __ROR8__(v98, 8) ^ (v98 >> 7));
    v102 = (__ROR8__(v100, 19) ^ __ROR8__(v100, 61) ^ (v100 >> 6))
         + v82
         + v98
         + (__ROR8__(v79, 1) ^ __ROR8__(v79, 8) ^ (v79 >> 7));
    v103 = v79
         + v86
         + (__ROR8__(v101, 19) ^ __ROR8__(v101, 61) ^ (v101 >> 6))
         + (__ROR8__(v83, 1) ^ __ROR8__(v83, 8) ^ (v83 >> 7));
    v11[20] = v97;
    v11[21] = v100;
    v11[22] = v101;
    v11[23] = v102;
    v104 = v83
         + v92
         + (__ROR8__(v102, 19) ^ __ROR8__(v102, 61) ^ (v102 >> 6))
         + (__ROR8__(v88, 1) ^ __ROR8__(v88, 8) ^ (v88 >> 7));
    v105 = v88
         + v95
         + (__ROR8__(v103, 19) ^ __ROR8__(v103, 61) ^ (v103 >> 6))
         + (__ROR8__(v93, 1) ^ __ROR8__(v93, 8) ^ (v93 >> 7));
    v11[24] = v103;
    v11[25] = v104;
    v106 = v93
         + v97
         + (__ROR8__(v104, 19) ^ __ROR8__(v104, 61) ^ (v104 >> 6))
         + (__ROR8__(v94, 1) ^ __ROR8__(v94, 8) ^ (v94 >> 7));
    v11[26] = v105;
    v11[27] = v106;
    v107 = v94
         + v100
         + (__ROR8__(v105, 19) ^ __ROR8__(v105, 61) ^ (v105 >> 6))
         + (__ROR8__(v84, 1) ^ __ROR8__(v84, 8) ^ (v84 >> 7));
    v108 = v11[15];
    v109 = v84
         + v101
         + (__ROR8__(v106, 19) ^ __ROR8__(v106, 61) ^ (v106 >> 6))
         + (__ROR8__(v85, 1) ^ __ROR8__(v85, 8) ^ (v85 >> 7));
    v11[28] = v107;
    v11[29] = v109;
    v11[30] = v85
            + v102
            + (__ROR8__(v107, 19) ^ __ROR8__(v107, 61) ^ (v107 >> 6))
            + (__ROR8__(v108, 1) ^ __ROR8__(v108, 8) ^ (v108 >> 7));
    v11[31] = v103
            + (__ROR8__(v82, 1) ^ __ROR8__(v82, 8) ^ (v82 >> 7))
            + v108
            + (__ROR8__(v109, 19) ^ __ROR8__(v109, 61) ^ (v109 >> 6));
  }
  v110 = *((_QWORD *)result + 1);
  *(_QWORD *)result += v75;
  v111 = v110 + a4[1];
  v112 = *((_QWORD *)result + 2);
  v113 = *((_QWORD *)result + 3);
  *((_QWORD *)result + 1) = v111;
  *((_QWORD *)result + 2) = v112 + a4[2];
  v114 = v113 + a4[3];
  v115 = *((_QWORD *)result + 4);
  v116 = *((_QWORD *)result + 5);
  *((_QWORD *)result + 3) = v114;
  *((_QWORD *)result + 4) = v115 + a4[4];
  v117 = v116 + a4[5];
  v118 = *((_QWORD *)result + 6);
  v119 = *((_QWORD *)result + 7);
  *((_QWORD *)result + 5) = v117;
  *((_QWORD *)result + 6) = v118 + a4[6];
  *((_QWORD *)result + 7) = v119 + a4[7];
  return result;
}


================================================================================
Function: sub_67F25F8 (0x67F25F8)
================================================================================

__int64 __fastcall sub_67F25F8(__int64 a1, _QWORD *a2)
{
  __int64 v4; // x21
  __int64 v5; // x8
  __int64 v6; // x8
  _BYTE v8[640]; // [xsp+8h] [xbp-2C8h] BYREF
  _BYTE v9[64]; // [xsp+288h] [xbp-48h] BYREF

  v4 = *(_QWORD *)(a1 + 72);
  v5 = ((unsigned int)v4 >> 3) & 0x7F;
  if ( (unsigned int)v5 > 0x6F )
  {
    memcpy((void *)(a1 + 80 + (unsigned int)v5), &unk_174D018, (unsigned int)(128 - v5));
    sub_67F1C90(a1, a1 + 80, v8, v9);
    v4 = *(_QWORD *)(a1 + 72);
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
  }
  else
  {
    memcpy((void *)(a1 + v5 + 80), &unk_174D018, (unsigned int)(112 - v5));
  }
  v6 = *(_QWORD *)(a1 + 64);
  *(_BYTE *)(a1 + 207) = v4;
  *(_BYTE *)(a1 + 195) = BYTE4(v6);
  *(_DWORD *)(a1 + 196) = bswap32(v6);
  *(_BYTE *)(a1 + 193) = BYTE6(v6);
  *(_BYTE *)(a1 + 194) = BYTE5(v6);
  *(_BYTE *)(a1 + 192) = HIBYTE(v6);
  *(_BYTE *)(a1 + 205) = BYTE2(v4);
  *(_BYTE *)(a1 + 206) = BYTE1(v4);
  *(_BYTE *)(a1 + 204) = BYTE3(v4);
  *(_BYTE *)(a1 + 202) = BYTE5(v4);
  *(_BYTE *)(a1 + 203) = BYTE4(v4);
  *(_BYTE *)(a1 + 201) = BYTE6(v4);
  *(_BYTE *)(a1 + 200) = HIBYTE(v4);
  sub_67F1C90(a1, a1 + 80, v8, v9);
  *a2 = bswap64(*(_QWORD *)a1);
  a2[1] = bswap64(*(_QWORD *)(a1 + 8));
  a2[2] = bswap64(*(_QWORD *)(a1 + 16));
  a2[3] = bswap64(*(_QWORD *)(a1 + 24));
  a2[4] = bswap64(*(_QWORD *)(a1 + 32));
  a2[5] = bswap64(*(_QWORD *)(a1 + 40));
  a2[6] = bswap64(*(_QWORD *)(a1 + 48));
  a2[7] = bswap64(*(_QWORD *)(a1 + 56));
  sub_67F3560(v8, 704LL);
  sub_67F3560(a1, 208LL);
  return 0LL;
}


================================================================================
Function: sub_67F27CC (0x67F27CC)
================================================================================

__int64 __fastcall sub_67F27CC(_BYTE *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  _BYTE *v5; // x20
  int v12; // w0
  int v13; // w20
  _BYTE v14[120]; // [xsp+0h] [xbp-250h] BYREF
  _BYTE v15[160]; // [xsp+78h] [xbp-1D8h] BYREF
  _BYTE v16[32]; // [xsp+118h] [xbp-138h] BYREF
  _BYTE v17[64]; // [xsp+138h] [xbp-118h] BYREF
  _BYTE v18[208]; // [xsp+178h] [xbp-D8h] BYREF

  v5 = a1 + 32;
  if ( !(unsigned int)sub_67F1074(a1 + 32)
    || (unsigned int)sub_67F0354(a1)
    || !(unsigned int)sub_67F0268(a4)
    || (unsigned int)sub_67F0354(a4)
    || (unsigned int)sub_67EE778(v15, a4) )
  {
    return 0xFFFFFFFFLL;
  }
  sub_67F292C(v18, a5);
  sub_67F1904(v18, a1, 32LL);
  sub_67F1904(v18, a4, 32LL);
  sub_67F1904(v18, a2, a3);
  sub_67F25F8(v18, v17);
  sub_67F08E4(v17);
  sub_67EED7C(v14, v17, v15, v5);
  sub_67EECD4(v16, v14);
  v12 = sub_67F33B8(v16, a1);
  if ( v16 == a1 )
    v13 = -1;
  else
    v13 = v12;
  return v13 | (unsigned int)sub_67F3590(a1, v16, 32LL);
}


================================================================================
Function: sub_67F2924 (0x67F2924)
================================================================================

__int64 __fastcall sub_67F2924(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_67F27CC(a1, a2, a3, a4, 0LL);
}


================================================================================
Function: sub_67F292C (0x67F292C)
================================================================================

__int64 __fastcall sub_67F292C(__int64 a1, int a2)
{
  __int64 result; // x0

  result = sub_67F18DC();
  if ( a2 )
    return sub_67F1904(a1, xmmword_174D098, 0x22uLL);
  return result;
}


================================================================================
Function: sub_67F33B8 (0x67F33B8)
================================================================================

__int64 __fastcall sub_67F33B8(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  char v3; // w9
  char v4; // w10
  int v6; // [xsp+8h] [xbp-18h]

  v2 = 0LL;
  v6 = 0;
  do
  {
    v3 = *(_BYTE *)(a1 + v2);
    v4 = *(_BYTE *)(a2 + v2++);
    v6 |= (unsigned __int8)(v4 ^ v3);
  }
  while ( v2 != 32 );
  return (((unsigned int)(v6 - 1) >> 8) & 1) - 1;
}


================================================================================
Function: sub_67F3560 (0x67F3560)
================================================================================

__int64 __fastcall sub_67F3560(__int64 result, __int64 a2)
{
  __int64 v2; // x8
  bool v3; // zf

  if ( a2 )
  {
    v2 = 0LL;
    do
    {
      v3 = a2 == v2 + 1;
      *(_BYTE *)(result + v2++) = 0;
    }
    while ( !v3 );
  }
  return result;
}


================================================================================
Function: sub_67F3590 (0x67F3590)
================================================================================

__int64 __fastcall sub_67F3590(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // x8
  char v4; // w9
  char v5; // w10
  unsigned __int8 v7; // [xsp+Ch] [xbp-14h]

  v7 = 0;
  if ( a3 )
  {
    for ( i = 0LL; i != a3; ++i )
    {
      v4 = *(_BYTE *)(a1 + i);
      v5 = *(_BYTE *)(a2 + i);
      v7 |= v5 ^ v4;
    }
  }
  return ((((unsigned int)v7 - 1) >> 8) & 1) - 1;
}


================================================================================
Function: sub_67F35EC (0x67F35EC)
================================================================================

__int64 __fastcall sub_67F35EC(char *a1, __int64 a2)
{
  char v2; // t1
  unsigned __int8 i; // [xsp+Ch] [xbp-4h]

  for ( i = 0; a2; i |= v2 )
  {
    v2 = *a1++;
    --a2;
  }
  return (((unsigned int)i - 1) >> 8) & 1;
}


================================================================================
Function: sub_67F3A24 (0x67F3A24)
================================================================================

__int64 __fastcall sub_67F3A24(unsigned __int64 a1)
{
  char *v2; // x0
  __int64 v3; // x9
  _QWORD *v4; // x8
  __int64 result; // x0
  int v6; // w10

  if ( dword_6CAF9C0 == -1 )
    v2 = (char *)sub_67F6ED0();
  else
    v2 = (char *)pthread_getspecific(dword_6CAF9C0);
  if ( !v2 )
    v2 = (char *)&unk_6C58500;
  if ( a1 > 0x400 )
    return sub_67FB640();
  v3 = *(_QWORD *)&v2[((a1 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v4 = *(_QWORD **)(v3 + 16);
  if ( !v4 )
    return sub_67FB640();
  result = *(_QWORD *)(v3 + 16);
  v6 = *(_DWORD *)(v3 + 24) + 1;
  *(_QWORD *)(v3 + 16) = *v4;
  *(_DWORD *)(v3 + 24) = v6;
  return result;
}


================================================================================
Function: sub_67F3BA8 (0x67F3BA8)
================================================================================

__int64 __fastcall sub_67F3BA8(__int64 a1, __int64 a2)
{
  void *v4; // x0

  if ( dword_6CAF9C0 == -1 )
    v4 = (void *)sub_67F6ED0();
  else
    v4 = pthread_getspecific(dword_6CAF9C0);
  if ( !v4 )
    v4 = &unk_6C58500;
  return sub_67F40D0(v4, a1, a2, 0LL);
}


================================================================================
Function: sub_67F3C08 (0x67F3C08)
================================================================================

unsigned __int64 __fastcall sub_67F3C08(unsigned __int64 result)
{
  _QWORD *v1; // x3
  __int64 v2; // x9
  __int64 v3; // x1
  int v4; // w8
  __int64 v5; // x9

  if ( result )
  {
    v1 = (_QWORD *)result;
    result = (result - 1) & 0xFFFFFFFFFE000000LL;
    v2 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    v3 = result
       + 80 * (((unsigned __int64)v1 - result) >> 16)
       - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
       + 264;
    if ( *(_QWORD *)(result + 256) != v2
      || *(_BYTE *)(result
                  + 80 * (((unsigned __int64)v1 - result) >> 16)
                  - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
                  + 278) )
    {
      return sub_67F3F24();
    }
    else
    {
      v4 = *(_DWORD *)(result
                     + 80 * (((unsigned __int64)v1 - result) >> 16)
                     - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
                     + 288);
      v5 = *(_QWORD *)(result
                     + 80 * (((unsigned __int64)v1 - result) >> 16)
                     - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
                     + 296);
      *(_QWORD *)(result
                + 80 * (((unsigned __int64)v1 - result) >> 16)
                - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
                + 296) = v1;
      --v4;
      *v1 = v5;
      *(_DWORD *)(v3 + 24) = v4;
      if ( !v4 )
        return sub_67FB334(v3);
    }
  }
  return result;
}


================================================================================
Function: sub_67F3C88 (0x67F3C88)
================================================================================

__int64 __fastcall sub_67F3C88(__int64 result)
{
  unsigned __int64 v1; // x8
  __int64 v2; // [xsp+0h] [xbp-10h]

  if ( result )
  {
    v1 = ((result - 1) & 0xFFFFFFFFFE000000LL)
       + 80 * ((result - ((result - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
       - *(unsigned int *)((char *)&qword_108[10 * ((result - ((result - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                         + ((result - 1) & 0xFFFFFFFFFE000000LL)
                         + 4);
    if ( (*((_BYTE *)&qword_110 + v1 + 6) & 2) != 0 )
    {
      return sub_67F43D4();
    }
    else
    {
      result = *(unsigned int *)((char *)&dword_124
                               + ((result - 1) & 0xFFFFFFFFFE000000LL)
                               + 80 * ((result - ((result - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
                               - *(unsigned int *)((char *)&qword_108[10
                                                                    * ((result - ((result - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                                                 + ((result - 1) & 0xFFFFFFFFFE000000LL)
                                                 + 4));
      if ( (result & 0x80000000) != 0 )
      {
        sub_67FC8B4((v1 + 263) & 0xFFFFFFFFFE000000LL);
        return v2;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67F3D40 (0x67F3D40)
================================================================================

// attributes: thunk
__int64 __fastcall sub_67F3D40(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_67F49D8(a1, a2, a3);
}


================================================================================
Function: sub_67F3D44 (0x67F3D44)
================================================================================

__int64 __fastcall sub_67F3D44(void *a1, __int64 a2, __int64 a3, char a4)
{
  _QWORD *v4; // x19
  int v5; // w8

  v4 = *(_QWORD **)(a2 + 16);
  if ( !v4 )
    return sub_67FB640(a1, a3, a4 & 1, 0LL);
  v5 = *(_DWORD *)(a2 + 24) + 1;
  *(_QWORD *)(a2 + 16) = *v4;
  *(_DWORD *)(a2 + 24) = v5;
  if ( (a4 & 1) != 0 )
  {
    if ( (*(_BYTE *)(a2 + 15) & 1) != 0 )
      *v4 = 0LL;
    else
      memset(v4, 0, *(unsigned int *)(a2 + 28));
  }
  return (__int64)v4;
}


================================================================================
Function: sub_67F3E00 (0x67F3E00)
================================================================================

__int64 __fastcall sub_67F3E00(char *a1, unsigned __int64 a2, char a3, __int64 a4)
{
  __int64 v4; // x8
  _QWORD *v5; // x19
  int v6; // w9
  char v8; // w2

  if ( a2 > 0x400 )
  {
    v8 = a3 & 1;
    return sub_67FB640(a1, a2, v8, a4);
  }
  v4 = *(_QWORD *)&a1[((a2 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v5 = *(_QWORD **)(v4 + 16);
  if ( !v5 )
  {
    v8 = a3 & 1;
    a4 = 0LL;
    return sub_67FB640(a1, a2, v8, a4);
  }
  v6 = *(_DWORD *)(v4 + 24) + 1;
  *(_QWORD *)(v4 + 16) = *v5;
  *(_DWORD *)(v4 + 24) = v6;
  if ( (a3 & 1) != 0 )
  {
    if ( (*(_BYTE *)(v4 + 15) & 1) != 0 )
      *v5 = 0LL;
    else
      memset(v5, 0, *(unsigned int *)(v4 + 28));
  }
  return (__int64)v5;
}


================================================================================
Function: sub_67F3E94 (0x67F3E94)
================================================================================

__int64 __fastcall sub_67F3E94(char *a1, unsigned __int64 a2, char a3)
{
  __int64 v3; // x8
  _QWORD *v4; // x19
  int v5; // w9

  if ( a2 > 0x400 )
    return sub_67FB640(a1, a2, a3 & 1, 0LL);
  v3 = *(_QWORD *)&a1[((a2 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v4 = *(_QWORD **)(v3 + 16);
  if ( !v4 )
    return sub_67FB640(a1, a2, a3 & 1, 0LL);
  v5 = *(_DWORD *)(v3 + 24) + 1;
  *(_QWORD *)(v3 + 16) = *v4;
  *(_DWORD *)(v3 + 24) = v5;
  if ( (a3 & 1) != 0 )
  {
    if ( (*(_BYTE *)(v3 + 15) & 1) != 0 )
      *v4 = 0LL;
    else
      memset(v4, 0, *(unsigned int *)(v3 + 28));
  }
  return (__int64)v4;
}


================================================================================
Function: nullsub_283 (0x67F3F20)
================================================================================

void nullsub_283()
{
  ;
}


================================================================================
Function: sub_67F3F24 (0x67F3F24)
================================================================================

__int64 __fastcall sub_67F3F24(__int64 result, __int64 a2, char a3, _QWORD *a4)
{
  unsigned __int64 v7; // x8
  __int64 v8; // x22
  int v9; // w8
  unsigned __int64 v10; // [xsp+0h] [xbp-10h]

  if ( (*(_BYTE *)(a2 + 14) & 2) != 0 )
  {
    result = sub_67FC8B4(result);
    v7 = *(unsigned int *)(a2 + 28);
    v8 = result;
    if ( (v7 & 0x80000000) != 0 )
    {
      result = sub_67FC8B4((a2 - 1) & 0xFFFFFFFFFE000000LL);
      v7 = v10;
    }
    a4 = (_QWORD *)(v8 + ((unsigned __int64)a4 - v8) / v7 * v7);
  }
  if ( (a3 & 1) == 0 )
    return sub_67F42EC(a2, a4);
  *a4 = *(_QWORD *)(a2 + 32);
  v9 = *(_DWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 32) = a4;
  *(_DWORD *)(a2 + 24) = --v9;
  if ( !v9 )
    return sub_67FB334(a2);
  if ( (*(_BYTE *)(a2 + 14) & 1) != 0 )
    return sub_67FAC8C(a2);
  return result;
}


================================================================================
Function: sub_67F4024 (0x67F4024)
================================================================================

__int64 __fastcall sub_67F4024(_QWORD *a1)
{
  __int64 v2; // x19
  char v3; // w20
  int v4; // w8
  __int64 v5; // x9

  v2 = (((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL)
     + 80 * (((unsigned __int64)a1 - (((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
     - *(unsigned int *)((char *)&qword_108[10
                                          * (((unsigned __int64)a1 - (((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                       + (((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL)
                       + 4)
     + 264;
  v3 = sub_67FA564(v2, 0LL, 0LL);
  if ( (v3 & 1) != 0 )
  {
    sub_67FA750(v2, 0LL);
    v4 = *(_DWORD *)(v2 + 24);
    v5 = *(_QWORD *)(v2 + 32);
    *(_QWORD *)(v2 + 32) = a1;
    --v4;
    *a1 = v5;
    *(_DWORD *)(v2 + 24) = v4;
    if ( v4 )
    {
      if ( (*(_BYTE *)(v2 + 14) & 1) != 0 )
        sub_67FAC8C(v2);
    }
    else
    {
      sub_67FB334(v2);
    }
  }
  return v3 & 1;
}


================================================================================
Function: sub_67F40D0 (0x67F40D0)
================================================================================

_QWORD *__fastcall sub_67F40D0(char *a1, _QWORD *a2, unsigned __int64 a3, char a4)
{
  unsigned __int64 v8; // x23
  __int64 v10; // x8
  unsigned __int64 v11; // x8
  size_t v12; // x2
  __int64 v13; // x9
  __int64 v14; // x1
  int v15; // w8
  char v17; // w2
  _QWORD *v18; // x21
  unsigned __int64 v19; // [xsp+0h] [xbp-10h]

  if ( a2 )
  {
    if ( (*((_BYTE *)&qword_110
          + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
          + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
          - *(unsigned int *)((char *)&qword_108[10
                                               * (((unsigned __int64)a2
                                                 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                            + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                            + 4)
          + 6) & 2) != 0 )
    {
      v8 = sub_67F43D4();
    }
    else
    {
      v8 = *(unsigned int *)((char *)&dword_124
                           + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                           + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
                           - *(unsigned int *)((char *)&qword_108[10
                                                                * (((unsigned __int64)a2
                                                                  - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                                             + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                                             + 4));
      if ( (v8 & 0x80000000) != 0 )
      {
        sub_67FC8B4(((((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                   + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
                   - *(unsigned int *)((char *)&qword_108[10
                                                        * (((unsigned __int64)a2
                                                          - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                                     + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                                     + 4)
                   + 263) & 0xFFFFFFFFFE000000LL);
        v8 = v19;
      }
    }
    if ( a3 - 1 < v8 && v8 >> 1 <= a3 )
      return a2;
    if ( a3 > 0x400 )
      goto LABEL_31;
  }
  else
  {
    v8 = 0LL;
    if ( a3 > 0x400 )
      goto LABEL_31;
  }
  v10 = *(_QWORD *)&a1[((a3 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v18 = *(_QWORD **)(v10 + 16);
  if ( v18 )
  {
    ++*(_DWORD *)(v10 + 24);
    *(_QWORD *)(v10 + 16) = *v18;
    goto LABEL_15;
  }
LABEL_31:
  v18 = (_QWORD *)sub_67FB640(a1, a3, 0, 0LL);
  if ( !v18 )
    return v18;
LABEL_15:
  if ( (a4 & 1) != 0 && v8 < a3 )
  {
    v11 = v8 - 8;
    if ( v8 <= 7 )
      v11 = 0LL;
    memset((char *)v18 + v11, 0, a3 - v11);
  }
  else if ( !a3 )
  {
    *(_BYTE *)v18 = 0;
  }
  if ( a2 )
  {
    if ( v8 >= a3 )
      v12 = a3;
    else
      v12 = v8;
    memcpy(v18, a2, v12);
    v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    v14 = (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
        + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
        - *(unsigned int *)((char *)&qword_108[10
                                             * (((unsigned __int64)a2
                                               - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                          + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                          + 4)
        + 264;
    if ( *(__int64 *)((char *)&qword_100 + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) == v13 )
    {
      if ( !*((_BYTE *)&qword_110
            + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
            + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
            - *(unsigned int *)((char *)&qword_108[10
                                                 * (((unsigned __int64)a2
                                                   - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                              + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                              + 4)
            + 6) )
      {
        *a2 = *(__int64 *)((char *)&qword_128
                         + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                         + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
                         - *(unsigned int *)((char *)&qword_108[10
                                                              * (((unsigned __int64)a2
                                                                - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                                           + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                                           + 4));
        v15 = *(_DWORD *)(v14 + 24);
        *(_QWORD *)(v14 + 32) = a2;
        *(_DWORD *)(v14 + 24) = --v15;
        if ( !v15 )
          sub_67FB334(v14);
        return v18;
      }
      v17 = 1;
    }
    else
    {
      v17 = 0;
    }
    sub_67F3F24(((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL, v14, v17, a2);
  }
  return v18;
}


================================================================================
Function: sub_67F42EC (0x67F42EC)
================================================================================

unsigned __int64 __fastcall sub_67F42EC(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 i; // x21
  unsigned __int64 v5; // x8
  unsigned __int64 result; // x0
  unsigned __int64 v7; // x22
  unsigned __int64 v8; // x21
  unsigned __int64 v9; // x0
  bool v10; // zf
  unsigned __int64 v11; // x20

  if ( *(_DWORD *)((char *)&qword_F0 + ((a1 - 1) & 0xFFFFFFFFFE000000LL)) == 1 )
    sub_67FD960();
  for ( i = *(_QWORD *)(a1 + 40); ; i = result )
  {
    v5 = i & 0xFFFFFFFFFFFFFFFCLL;
    if ( (i & 3) == 0 )
      break;
    *(_QWORD *)a2 = v5;
    result = sub_6866FE0(i, i & 3 | a2, (atomic_ullong *)(a1 + 40));
    if ( result == i )
      return result;
LABEL_6:
    ;
  }
  result = sub_6866FE0(i, v5 | 1, (atomic_ullong *)(a1 + 40));
  if ( result != i )
    goto LABEL_6;
  v7 = atomic_load((unsigned __int64 *)(a1 + 48));
  if ( v7 )
  {
    v8 = *(_QWORD *)(v7 + 2840);
    do
    {
      *(_QWORD *)a2 = v8;
      v9 = sub_6866FE0(v8, a2, (atomic_ullong *)(v7 + 2840));
      v10 = v9 == v8;
      v8 = v9;
    }
    while ( !v10 );
  }
  v11 = *(_QWORD *)(a1 + 40);
  do
  {
    result = sub_6866FE0(v11, v11 & 0xFFFFFFFFFFFFFFFCLL | 2, (atomic_ullong *)(a1 + 40));
    v10 = result == v11;
    v11 = result;
  }
  while ( !v10 );
  return result;
}


================================================================================
Function: sub_67F43D4 (0x67F43D4)
================================================================================

unsigned __int64 __fastcall sub_67F43D4(__int64 a1, unsigned int *a2, __int64 a3)
{
  __int64 v5; // x0
  unsigned __int64 v6; // x8
  __int64 v7; // x22
  unsigned __int64 v8; // x20
  unsigned __int64 v10; // [xsp+0h] [xbp-10h] BYREF

  v5 = sub_67FC8B4(a1, a2, 0LL);
  v6 = a2[7];
  v7 = v5;
  if ( (v6 & 0x80000000) != 0 )
  {
    sub_67FC8B4(((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL, a2, &v10);
    v6 = a2[7];
    v8 = (a3 - v7) % v10;
    if ( (v6 & 0x80000000) != 0 )
    {
      sub_67FC8B4(((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL, a2, &v10);
      v6 = v10;
    }
  }
  else
  {
    v8 = (a3 - v5) % v6;
  }
  return v6 - v8;
}


================================================================================
Function: sub_67F449C (0x67F449C)
================================================================================

__int64 __fastcall sub_67F449C(unsigned __int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x9
  _QWORD *v3; // x8
  int v4; // w10
  char *v7; // x0
  uint8x8_t v8; // d0
  uint8x8_t v9; // d0
  __int64 v10; // x1
  __int64 v11; // x8
  __int64 result; // x0

  if ( dword_6CAF9C0 == -1 )
    v7 = (char *)sub_67F6ED0();
  else
    v7 = (char *)pthread_getspecific(dword_6CAF9C0);
  v8.n64_u64[0] = vcnt_s8((int8x8_t)a2).n64_u64[0];
  if ( !v7 )
    v7 = (char *)&unk_6C58500;
  v8.n64_u16[0] = vaddlv_u8(v8);
  if ( v8.n64_u32[0] != 1LL )
    return 0LL;
  if ( a1 <= 0x400 )
  {
    v9.n64_u64[0] = vcnt_s8((int8x8_t)a1).n64_u64[0];
    v9.n64_u16[0] = vaddlv_u8(v9);
    if ( v9.n64_u32[0] <= 1uLL && a1 >= a2 )
    {
      v2 = *(_QWORD *)&v7[((a1 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
      v3 = *(_QWORD **)(v2 + 16);
      if ( !v3 )
        return sub_67FB640(v7, a1, 0, 0LL);
      result = *(_QWORD *)(v2 + 16);
      v4 = *(_DWORD *)(v2 + 24) + 1;
      *(_QWORD *)(v2 + 16) = *v3;
      *(_DWORD *)(v2 + 24) = v4;
      return result;
    }
  }
  if ( (a1 & 0x8000000000000000LL) != 0 || !a2 )
    return 0LL;
  if ( a1 > 0x400 )
    return sub_67F4884(v7, a1, a2, 0LL, 0LL);
  if ( a1 < a2 )
    return sub_67F4884(v7, a1, a2, 0LL, 0LL);
  v10 = *(_QWORD *)&v7[((a1 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v11 = *(_QWORD *)(v10 + 16);
  if ( !v11 || ((a2 - 1) & v11) != 0 )
    return sub_67F4884(v7, a1, a2, 0LL, 0LL);
  else
    return sub_67F3D44(v7, v10, a1, 0);
}


================================================================================
Function: sub_67F4884 (0x67F4884)
================================================================================

__int64 __fastcall sub_67F4884(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, char a5)
{
  unsigned __int64 v8; // x23
  __int64 v10; // x0
  __int64 v11; // x1
  char v12; // w24
  unsigned __int64 v13; // x8
  void *v14; // x21
  unsigned __int64 v15; // x9
  size_t v16; // x0
  __int64 v17; // x0

  v8 = a3 - 1;
  if ( a4 )
  {
    if ( a3 > 0x1000000 )
      return 0LL;
  }
  else
  {
    if ( a2 <= 0x80 && a3 <= a2 && (v8 & a2) == 0 )
      return sub_67F3E94(a1, a2, a5 & 1);
    if ( a3 > 0x1000000 )
    {
      if ( a2 <= 0x401 )
        a2 = 1025LL;
      v17 = sub_67F3E00(a1, a2, 0LL, a3);
      if ( !v17 )
        return 0LL;
      v11 = v17;
      v12 = 0;
LABEL_11:
      if ( ((v11 + a4) & v8) != 0 )
        v13 = a3 - ((v11 + a4) & v8);
      else
        v13 = 0LL;
      v14 = (void *)(v13 + v11);
      if ( v13 )
      {
        v15 = ((v11 - 1) & 0xFFFFFFFFFE000000LL)
            + 80 * ((v11 - ((v11 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
            - *(unsigned int *)((char *)&qword_108[10 * ((v11 - ((v11 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                              + ((v11 - 1) & 0xFFFFFFFFFE000000LL)
                              + 4);
        *(_BYTE *)(v15 + 278) = *((_BYTE *)&qword_110 + v15 + 6) | 2;
        nullsub_283(v15 + 264);
      }
      if ( !(v12 & 1 | ((a5 & 1) == 0)) )
      {
        v16 = sub_67F3C88((__int64)v14);
        memset(v14, 0, v16);
      }
      return (__int64)v14;
    }
  }
  v10 = sub_67F3E94(a1, v8 + a2, a5 & 1);
  if ( v10 )
  {
    v11 = v10;
    v12 = 1;
    goto LABEL_11;
  }
  return 0LL;
}


================================================================================
Function: sub_67F49D4 (0x67F49D4)
================================================================================

// attributes: thunk
__int64 __fastcall sub_67F49D4(__int64 a1)
{
  return sub_67F3C88(a1);
}


================================================================================
Function: sub_67F49D8 (0x67F49D8)
================================================================================

__int64 __fastcall sub_67F49D8(__int64 *a1, __int64 a2, __int64 a3)
{
  uint8x8_t v3; // d0
  __int64 result; // x0
  __int64 v9; // x0
  __int64 v10; // x8

  v3.n64_u64[0] = vcnt_s8((int8x8_t)a2).n64_u64[0];
  v3.n64_u16[0] = vaddlv_u8(v3);
  if ( v3.n64_u32[0] != 1LL || a1 == 0LL || (a2 & 7) != 0 )
    return 22LL;
  v9 = sub_67F449C(a3);
  v10 = v9;
  if ( a3 && !v9 )
    return 12LL;
  result = 0LL;
  *a1 = v10;
  return result;
}


================================================================================
Function: sub_67F4A50 (0x67F4A50)
================================================================================

__int64 __fastcall sub_67F4A50(__int64 result, int a2)
{
  __int64 v2; // x19
  __int64 v4; // x0
  int v5; // w23
  __int64 i; // x21
  __int64 v7; // x0
  __int64 v8; // x23
  __int64 j; // x24
  __int64 v10; // x8
  unsigned __int64 v11; // x26
  __int64 v12; // x21
  unsigned __int64 v13; // x22
  unsigned __int64 v14; // x0
  __int64 v15; // x0

  if ( !result )
    return result;
  v2 = result;
  if ( (_UNKNOWN *)result == &unk_6C58500 )
    return result;
  v4 = sub_67FB5D8(result, a2 != 0);
  if ( a2 != 1 )
  {
    if ( a2 == 2 )
    {
      if ( *(_QWORD *)(v2 + 3024) )
      {
        for ( i = 0LL; i != 75; ++i )
        {
          v7 = *(_QWORD *)(v2 + 24 * i + 1040);
          if ( v7 )
          {
            do
            {
              v8 = *(_QWORD *)(v7 + 56);
              sub_67FA514();
              v7 = v8;
            }
            while ( v8 );
          }
        }
      }
      v5 = 1;
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  if ( (sub_67F7000(v4) & 1) == 0 || *(_QWORD *)(*(_QWORD *)v2 + 16LL) != v2 || *(_BYTE *)(v2 + 3056) )
  {
LABEL_15:
    v5 = 0;
    goto LABEL_17;
  }
  sub_67FCF50(v2, *(_QWORD *)v2 + 32LL);
  v5 = 0;
LABEL_17:
  sub_67FAB24(v2);
  sub_67FB4BC(v2, a2 != 0);
  if ( *(_QWORD *)(v2 + 3024) )
  {
    for ( j = 0LL; j != 75; ++j )
    {
      v10 = v2 + 24 * j;
      v11 = *(_QWORD *)(v10 + 1040);
      if ( v11 )
      {
        v12 = v10 + 1040;
        do
        {
          v13 = v11;
          v14 = v11;
          v11 = *(_QWORD *)(v11 + 56);
          sub_67FA750(v14, a2 != 0);
          if ( *(_DWORD *)(v13 + 24) )
          {
            if ( v5 )
              sub_67FB09C(v13, v12);
          }
          else
          {
            sub_67FB2D4(v13, v12, a2 != 0);
          }
        }
        while ( v11 );
      }
    }
  }
  result = sub_67FD328(v2, a2 == 1, *(_QWORD *)v2 + 32LL);
  if ( a2 )
  {
    v15 = nullsub_284(*(_QWORD *)v2 + 32LL);
    result = sub_67F7000(v15);
    if ( (result & 1) != 0 && *(_QWORD *)(*(_QWORD *)v2 + 16LL) == v2 )
    {
      sub_67F6F44();
      return sub_67F5870(1LL, 1LL, *(_QWORD *)v2 + 960LL);
    }
  }
  return result;
}


================================================================================
Function: sub_67F4C48 (0x67F4C48)
================================================================================

__int64 __fastcall sub_67F4C48(__int64 a1, char a2)
{
  return sub_67F4A50(a1, a2 & 1);
}


================================================================================
Function: sub_67F4CA4 (0x67F4CA4)
================================================================================

void *sub_67F4CA4()
{
  void *result; // x0

  sub_67F7034();
  if ( dword_6CAF9C0 == -1 )
    result = sub_67F6ED0();
  else
    result = pthread_getspecific(dword_6CAF9C0);
  if ( !result )
    return &unk_6C58500;
  return result;
}


================================================================================
Function: sub_67F4CE8 (0x67F4CE8)
================================================================================

__int64 __fastcall sub_67F4CE8(__int64 a1)
{
  return sub_67FC084(a1 + 2888);
}


================================================================================
Function: sub_67F4CF0 (0x67F4CF0)
================================================================================

__int64 __fastcall sub_67F4CF0(__int64 a1, __int128 *a2)
{
  __int128 v2; // q0
  __int64 v3; // x8
  __int64 v4; // x1
  __int128 v6; // [xsp+0h] [xbp-20h] BYREF
  __int64 v7; // [xsp+10h] [xbp-10h]

  v2 = *a2;
  v3 = *((_QWORD *)a2 + 2);
  v4 = *(unsigned int *)(a1 + 2856);
  v6 = v2;
  v7 = v3;
  return sub_67F50D0(&v6, v4) & 1;
}


================================================================================
Function: sub_67F50D0 (0x67F50D0)
================================================================================

bool __fastcall sub_67F50D0(__int64 a1, int a2)
{
  if ( *(_DWORD *)(a1 + 20) == 6 )
    return *(_DWORD *)(a1 + 8) == a2 || (a2 | *(unsigned __int8 *)(a1 + 12)) == 0;
  else
    return a2 == 0;
}


================================================================================
Function: sub_67F510C (0x67F510C)
================================================================================

const void *__fastcall sub_67F510C(
        unsigned __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        char a4,
        char a5,
        unsigned int a6,
        _QWORD *a7,
        __int64 a8)
{
  unsigned int v16; // w26
  const void *result; // x0
  _BOOL8 v18; // x0
  unsigned __int64 v19; // x27
  __int64 v20; // x0
  char v21; // w0
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x27
  char v26; // w0
  int v27; // w8
  unsigned __int64 v28; // x0
  int v29; // w8
  _DWORD *v30; // x8
  unsigned __int64 v31; // [xsp+8h] [xbp-18h]
  int v32; // [xsp+14h] [xbp-Ch] BYREF

  *a7 = 0LL;
  a7[1] = 0LL;
  a7[2] = 0LL;
  if ( qword_730D288 == 1 )
  {
    v16 = 0;
    if ( !(a1 >> 24) )
      goto LABEL_35;
  }
  else
  {
    v16 = sub_67FA258(a8);
    if ( !(a1 >> 24) )
      goto LABEL_35;
  }
  if ( a2 > 0x2000000 || a3 )
  {
LABEL_35:
    v18 = sub_67F8510(0x11u);
    if ( a6 || v18 )
      goto LABEL_39;
LABEL_37:
    if ( a3 )
      return (const void *)sub_67F99C4(a1, a2, a3, a4 & 1, a5 & 1, a7, *(_QWORD *)(a8 + 8));
    else
      return sub_67F94D8(a1, a2, a4 & 1, a5 & 1, (__int64)a7);
  }
  result = (const void *)sub_67F53B0(v16, a1, a4 & 1, a5 & 1, a6, a7, a8);
  if ( result )
    return result;
  if ( a6 )
  {
    v18 = sub_67F8510(0x11u);
LABEL_39:
    v30 = (_DWORD *)__errno(v18);
    result = 0LL;
    *v30 = 12;
    return result;
  }
  v32 = 0;
  if ( sub_67F7B2C() )
    goto LABEL_20;
  v19 = atomic_load((unsigned __int64 *)&qword_7304EC0);
  if ( v19 > 0x6C )
    goto LABEL_20;
  v20 = sub_67F848C(23LL);
  if ( !v20 )
    goto LABEL_20;
  v31 = v20;
  v21 = sub_67F8F18();
  v22 = v31 >> 2;
  if ( (v21 & 1) != 0 )
    v22 = v31;
  v23 = v19 >> 3;
  v24 = v22 + 0x1FFFFFF;
  if ( v19 <= 7 )
    LOBYTE(v23) = 0;
  v25 = (v24 & 0xFFFFFFFFFE000000LL) << v23;
  if ( v25 < a1 )
    goto LABEL_20;
  v26 = sub_67F7E08(4u) == 2 ? sub_67F8F0C() : sub_67F7E08(4u) == 1;
  if ( (unsigned int)sub_67F5FE8(v25, v26 & 1, a5 & 1, 0, &v32) )
    goto LABEL_20;
  v27 = v32 - 1;
  if ( v32 < 1 )
    v27 = 112;
  if ( (v28 = atomic_load(&qword_7304B40[v27])) == 0
    || (a5 & 1) == 0 && *(_BYTE *)(v28 + 93)
    || *(_DWORD *)v28 && *(_BYTE *)(v28 + 92)
    || (v16 & 0x80000000) == 0 && (v29 = *(_DWORD *)(v28 + 88), (v29 & 0x80000000) == 0) && v29 != v16
    || (result = (const void *)sub_67F6374()) == 0LL )
  {
LABEL_20:
    v18 = sub_67F8510(0x11u);
    if ( v18 )
      goto LABEL_39;
    goto LABEL_37;
  }
  return result;
}


================================================================================
Function: sub_67F53B0 (0x67F53B0)
================================================================================

__int64 __fastcall sub_67F53B0(unsigned int a1, __int64 a2, char a3, char a4, int a5, __int64 a6, __int64 a7)
{
  unsigned __int64 v7; // x26
  __int64 result; // x0
  unsigned __int64 v15; // x8
  __int64 v16; // x25
  __int64 v17; // x25

  v7 = qword_7304EC0;
  if ( !qword_7304EC0 )
    return 0LL;
  if ( a5 )
  {
    LODWORD(v15) = a5 - 1;
    if ( a5 >= 1 )
      v15 = (unsigned int)v15;
    else
      v15 = 112LL;
    if ( qword_7304EC0 <= v15 )
      return 0LL;
    result = sub_67F54E0((unsigned int)a5, 1LL, a1, a2, a3 & 1, a4 & 1, (unsigned int)a5, a6, a7);
    if ( !result )
      return 0LL;
  }
  else
  {
    v16 = 0LL;
    while ( 1 )
    {
      result = sub_67F54E0((unsigned int)++v16, 1LL, a1, a2, a3 & 1, a4 & 1, 0LL, a6, a7);
      if ( result )
        break;
      if ( v7 == v16 )
      {
        if ( (a1 & 0x80000000) != 0 )
          return 0LL;
        v17 = 0LL;
        if ( v7 <= 1 )
          v7 = 1LL;
        while ( 1 )
        {
          result = sub_67F54E0((unsigned int)++v17, 0LL, a1, a2, a3 & 1, a4 & 1, 0LL, a6, a7);
          if ( result )
            break;
          if ( v7 == v17 )
            return 0LL;
        }
        return result;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67F54E0 (0x67F54E0)
================================================================================

unsigned __int64 __fastcall sub_67F54E0(int a1, char a2, int a3, __int64 a4, char a5, char a6, int a7, __int64 a8)
{
  int v8; // w8
  unsigned __int64 v9; // x0

  v8 = a1 - 1;
  if ( a1 < 1 )
    v8 = 112;
  v9 = atomic_load(&qword_7304B40[v8]);
  if ( v9
    && ((a6 & 1) != 0 || !*(_BYTE *)(v9 + 93))
    && (*(_DWORD *)v9 == a7 || (a7 | *(unsigned __int8 *)(v9 + 92)) == 0) )
  {
    if ( a7 )
      return sub_67F6374((int *)v9, (unsigned __int64)(a4 + 0x1FFFFFF) >> 25, a5 & 1, a8);
    if ( a3 < 0 )
    {
      if ( (a2 & 1) != 0 )
        return sub_67F6374((int *)v9, (unsigned __int64)(a4 + 0x1FFFFFF) >> 25, a5 & 1, a8);
    }
    else if ( (a2 & 1) != 0 )
    {
      if ( *(int *)(v9 + 88) < 0 || *(_DWORD *)(v9 + 88) == a3 )
        return sub_67F6374((int *)v9, (unsigned __int64)(a4 + 0x1FFFFFF) >> 25, a5 & 1, a8);
    }
    else if ( *(int *)(v9 + 88) >= 0 && *(_DWORD *)(v9 + 88) != a3 )
    {
      return sub_67F6374((int *)v9, (unsigned __int64)(a4 + 0x1FFFFFF) >> 25, a5 & 1, a8);
    }
  }
  return 0LL;
}


================================================================================
Function: sub_67F558C (0x67F558C)
================================================================================

__int64 __fastcall sub_67F558C(
        __int64 result,
        __int64 a2,
        unsigned __int64 a3,
        __int64 *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  int v10; // w8
  __int64 v13; // x19
  __int64 v15; // x8
  int v16; // w8
  unsigned __int64 v17; // x23
  bool v18; // vf
  int v19; // w8
  unsigned __int64 v20; // x24
  unsigned __int64 v21; // x1
  __int64 v22; // x4
  __int64 v23; // x5
  __int64 v24; // x6
  __int64 v25; // x7
  __int128 v26; // q0
  __int64 v27; // x8
  const char *v28; // x1
  __int128 v29; // [xsp+0h] [xbp-20h] BYREF
  __int64 v30; // [xsp+10h] [xbp-10h]

  if ( result && a2 )
  {
    v10 = *((_DWORD *)a4 + 5);
    v13 = result;
    if ( (unsigned int)(v10 - 3) > 2 )
    {
      if ( v10 == 6 )
      {
        v16 = *((_DWORD *)a4 + 2);
        v17 = *a4;
        v18 = __OFSUB__(v16, 1);
        v19 = v16 - 1;
        if ( v19 < 0 != v18 )
          v19 = 112;
        v20 = atomic_load(&qword_7304B40[v19]);
        if ( v20 )
        {
          v21 = *(_QWORD *)(v20 + 48);
          if ( v21 > v17 >> 6 )
          {
            if ( !*(_BYTE *)(v20 + 24) && *(_QWORD *)(v20 + 120) )
            {
              if ( a3 != a2 )
              {
                ((void (*)(void))sub_67F6BA4)();
                if ( a3 )
                  sub_67FF704(a5 + 96, a3);
              }
              sub_67F5790(v20, v17, (unsigned __int64)(a2 + 0x1FFFFFF) >> 25, a5);
              v21 = *(_QWORD *)(v20 + 48);
            }
            if ( (sub_67F6BA4(v20 + 136, v21, (unsigned __int64)(a2 + 0x1FFFFFF) >> 25, v17) & 1) == 0 )
              return sub_67F8A74(
                       11LL,
                       "trying to free an already freed arena block: %p, size %zu\n",
                       v13,
                       a2,
                       v22,
                       v23,
                       v24,
                       v25,
                       a9);
            return sub_67F5870(0, 0, a5);
          }
          v26 = *(_OWORD *)a4;
          v27 = a4[2];
          v28 = "trying to free from non-existent arena block: %p, size %zu, memid: 0x%zx\n";
        }
        else
        {
          v26 = *(_OWORD *)a4;
          v27 = a4[2];
          v28 = "trying to free from non-existent arena: %p, size %zu, memid: 0x%zx\n";
        }
        *((_QWORD *)&v29 + 1) = *((_QWORD *)&v26 + 1);
        v30 = v27;
        return sub_67F8A74(22LL, v28, result, a2, (__int64)&v29, a6, a7, a8, v26);
      }
    }
    else
    {
      if ( a3 != a2 )
      {
        if ( a3 )
          sub_67FF704(a5 + 96, a3);
      }
      v15 = a4[2];
      v29 = *(_OWORD *)a4;
      v30 = v15;
      sub_67F92D4(v13, a2, &v29);
    }
    return sub_67F5870(0, 0, a5);
  }
  return result;
}


================================================================================
Function: sub_67F5790 (0x67F5790)
================================================================================

__int64 __fastcall sub_67F5790(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v8; // x23
  __int64 result; // x0
  unsigned __int64 v10; // x23

  v8 = sub_67F7E08(0xFu);
  result = sub_67F7E08(0x18u);
  v10 = result * v8;
  if ( (v10 & 0x8000000000000000LL) == 0 )
  {
    if ( sub_67F7B2C() || !v10 )
    {
      return sub_67F6514((unsigned __int64 *)a1, a2, a3, a4);
    }
    else
    {
      if ( *(_QWORD *)(a1 + 104) )
        sub_68674B0(v10 / 0xA, (atomic_ullong *)(a1 + 104));
      else
        atomic_store(sub_6800364() + v10, (unsigned __int64 *)(a1 + 104));
      return sub_67F6CB0(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 48), a3, a2, 0LL);
    }
  }
  return result;
}


================================================================================
Function: sub_67F5870 (0x67F5870)
================================================================================

__int64 __fastcall sub_67F5870(int a1, char a2, __int64 a3)
{
  __int64 result; // x0
  __int64 v6; // x20
  unsigned __int64 v7; // x19
  bool v8; // zf
  int v9; // w21
  __int64 v10; // x23
  __int64 v11; // x24
  __int64 v12; // x25
  unsigned __int64 v13; // x22
  unsigned __int64 v14; // x8
  char v15; // w26
  unsigned __int64 v16; // x28
  unsigned __int64 v17; // x23
  unsigned __int64 v18; // x20
  unsigned __int64 v19; // x19
  int v20; // w12
  unsigned __int64 v21; // x24
  unsigned __int64 v22; // x21
  unsigned __int64 v23; // x25
  unsigned __int64 v24; // x27
  unsigned __int64 v25; // x28
  unsigned __int64 v26; // x26
  char v27; // w10
  unsigned __int64 v28; // x0
  unsigned __int64 v29; // x25
  unsigned __int64 v30; // x22
  int v31; // w23
  int v32; // w12
  __int64 v33; // x23
  __int64 v34; // x24
  __int64 v35; // x0
  unsigned __int64 v36; // [xsp+0h] [xbp-50h]
  int v37; // [xsp+Ch] [xbp-44h]
  unsigned __int64 v38; // [xsp+10h] [xbp-40h]
  __int64 v39; // [xsp+18h] [xbp-38h]
  __int64 v40; // [xsp+20h] [xbp-30h]
  unsigned __int64 v41; // [xsp+28h] [xbp-28h]
  char v42; // [xsp+34h] [xbp-1Ch]
  __int64 v44; // [xsp+48h] [xbp-8h]

  result = sub_67F7B2C();
  if ( (result & 1) == 0 )
  {
    v6 = sub_67F7E08(15LL);
    result = sub_67F7E08(24LL);
    if ( result * v6 >= 1 )
    {
      v7 = atomic_load((unsigned __int64 *)&qword_7304EC0);
      if ( v7 )
      {
        result = sub_6867020(0LL, 1uLL, (atomic_ullong *)&qword_7304EC8);
        if ( !result )
        {
          v8 = (a2 & 1) == 0;
          v9 = a1 ^ 1;
          if ( v8 )
            v10 = 1LL;
          else
            v10 = v7;
          result = sub_6800364();
          v11 = result;
          v12 = 0LL;
          while ( 1 )
          {
            v13 = atomic_load(&qword_7304B40[v12]);
            if ( v13 )
            {
              if ( !*(_BYTE *)(v13 + 24) )
              {
                if ( *(_QWORD *)(v13 + 128) )
                {
                  result = *(_QWORD *)(v13 + 104);
                  if ( result )
                  {
                    if ( ((unsigned __int8)v9 & (result > v11)) == 0 )
                    {
                      result = sub_6867020(result, 0LL, (atomic_ullong *)(v13 + 104));
                      v14 = *(_QWORD *)(v13 + 48);
                      if ( v14 )
                      {
                        v36 = v10;
                        v15 = 0;
                        v16 = 0LL;
                        v17 = v13 + 136;
                        v39 = v12;
                        v40 = v11;
                        v37 = v9;
                        v38 = v7;
                        v42 = 1;
                        do
                        {
                          v18 = *(_QWORD *)(*(_QWORD *)(v13 + 128) + 8 * v16);
                          if ( v18 )
                          {
                            v19 = 0LL;
                            v41 = v16;
                            v44 = v16 << 6;
                            do
                            {
                              v21 = 0LL;
                              while ( ((v18 >> ((unsigned __int8)v19 + (unsigned __int8)v21)) & 1) != 0 )
                              {
                                ++v21;
                                if ( v19 + v21 == 64 )
                                {
                                  v21 = 64 - v19;
                                  break;
                                }
                              }
                              if ( v21 )
                              {
                                v22 = v21 + v19;
                                v23 = v19 + v44;
                                while ( 1 )
                                {
                                  result = sub_67F66C0(v17, *(_QWORD *)(v13 + 48), v21, v23);
                                  if ( (result & 1) != 0 )
                                    break;
                                  --v21;
                                  --v22;
                                  if ( !v21 )
                                    goto LABEL_24;
                                }
                                v24 = v19 + v21;
                                v18 = atomic_load((unsigned __int64 *)(*(_QWORD *)(v13 + 128) + 8 * v16));
                                if ( v19 + v21 <= v19 )
                                {
                                  LOBYTE(v20) = 0;
                                }
                                else
                                {
                                  v20 = 0;
                                  v25 = v19;
                                  do
                                  {
                                    v26 = 0LL;
                                    if ( v24 > v25 )
                                    {
                                      v27 = v25;
                                      while ( ((v18 >> v27) & 1) != 0 )
                                      {
                                        ++v26;
                                        ++v27;
                                        if ( v22 - v25 == v26 )
                                        {
                                          v26 = v24 - v25;
                                          break;
                                        }
                                      }
                                      if ( v26 )
                                      {
                                        v28 = v13;
                                        v29 = v13;
                                        v30 = v17;
                                        v31 = v20;
                                        sub_67F6514(v28, v25 + v44, v26, a3);
                                        v32 = v31;
                                        v17 = v30;
                                        v13 = v29;
                                        v23 = v19 + v44;
                                        v20 = (v26 == v21) | v32;
                                      }
                                    }
                                    v25 += v26 + 1;
                                  }
                                  while ( v25 < v24 );
                                }
                                v42 &= v20;
                                result = sub_67F65FC(v17, *(_QWORD *)(v13 + 48), v21, v23);
                                v15 = 1;
                                v16 = v41;
                              }
LABEL_24:
                              v19 += v21 + 1;
                            }
                            while ( v19 < 0x40 );
                            v14 = *(_QWORD *)(v13 + 48);
                          }
                          ++v16;
                        }
                        while ( v16 < v14 );
                        if ( (v42 & 1) == 0 )
                        {
                          v33 = sub_67F7E08(15LL);
                          v34 = sub_67F7E08(24LL);
                          v35 = sub_6800364();
                          result = sub_6867020(0LL, v35 + v34 * v33, (atomic_ullong *)(v13 + 104));
                        }
                        v7 = v38;
                        v9 = v37;
                        v10 = v36;
                        if ( (v15 & 1) != 0 )
                        {
                          v12 = v39;
                          v11 = v40;
                          if ( v36 < 2 )
                          {
LABEL_49:
                            atomic_store(0LL, &qword_7304EC8);
                            return result;
                          }
                          v10 = v36 - 1;
                        }
                        else
                        {
                          v12 = v39;
                          v11 = v40;
                        }
                      }
                    }
                  }
                }
              }
            }
            if ( ++v12 == v7 )
              goto LABEL_49;
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67F5FE8 (0x67F5FE8)
================================================================================

__int64 __fastcall sub_67F5FE8(__int64 a1, char a2, char a3, char a4, _DWORD *a5)
{
  unsigned __int64 v8; // x19
  __int64 v9; // x0
  int v10; // w24
  __int64 v11; // x23
  const char *v12; // x2
  __int128 v14; // [xsp+0h] [xbp-40h] BYREF
  __int64 v15; // [xsp+10h] [xbp-30h]
  __int128 v16; // [xsp+20h] [xbp-20h] BYREF
  __int64 v17; // [xsp+30h] [xbp-10h]

  if ( a5 )
    *a5 = 0;
  v8 = (a1 + 0x1FFFFFF) & 0xFFFFFFFFFE000000LL;
  v9 = sub_67F94D8(v8, 0x2000000LL, a2 & 1, a3 & 1, &v16, &unk_7304F00);
  if ( !v9 )
    return 12LL;
  v10 = (unsigned __int8)v17;
  v11 = v9;
  v14 = v16;
  v15 = v17;
  if ( (((__int64 (__fastcall *)(__int64, unsigned __int64, _QWORD, __int64, _QWORD, __int128 *, _DWORD *))sub_67F5D9C)(
          v9,
          v8,
          (unsigned __int8)v17,
          0xFFFFFFFFLL,
          a4 & 1,
          &v14,
          a5) & 1) == 0 )
  {
    v14 = v16;
    v15 = v17;
    sub_67F9118(v11, v8, a2 & 1, &v14, &unk_7304F00);
    sub_67F7E58("failed to reserve %zu k memory\n", v8 >> 10);
    return 12LL;
  }
  if ( v10 )
    v12 = " (in large os pages)";
  else
    v12 = &byte_CC4FFC;
  sub_67F7E58("reserved %zu KiB memory%s\n", v8 >> 10, v12);
  return 0LL;
}


================================================================================
Function: sub_67F6140 (0x67F6140)
================================================================================

__int64 __fastcall sub_67F6140(__int64 a1, unsigned int a2, __int64 a3, char a4, _DWORD *a5)
{
  unsigned __int64 v9; // x23
  unsigned __int64 v10; // x0
  unsigned int v11; // w23
  __int64 v12; // x0
  __int64 v13; // x22
  __int64 v14; // x7
  __int64 v15; // x4
  __int128 v17; // [xsp+0h] [xbp-50h] BYREF
  __int64 v18; // [xsp+10h] [xbp-40h]
  __int128 v19; // [xsp+20h] [xbp-30h] BYREF
  __int64 v20; // [xsp+30h] [xbp-20h]
  size_t v21; // [xsp+38h] [xbp-18h] BYREF
  __int64 v22; // [xsp+40h] [xbp-10h] BYREF

  if ( a5 )
    *a5 = -1;
  if ( !a1 )
    return 0LL;
  if ( (a2 & 0x80000000) != 0 )
  {
    v11 = -1;
  }
  else
  {
    v9 = a2;
    v10 = qword_730D288;
    if ( !qword_730D288 )
      v10 = sub_67FA1F8();
    v11 = v9 % v10;
  }
  v21 = 0LL;
  v22 = 0LL;
  v12 = sub_67F9F04(a1, v11, a3, &v21, &v22, &v19);
  if ( v12 && v21 )
  {
    v13 = v12;
    sub_67F7E58((__int64)"numa node %i: reserved %zu GiB huge pages (of the %zu GiB requested)\n", v11, v21, a1);
    v17 = v19;
    v18 = v20;
    if ( (((__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD, _QWORD, __int128 *, _DWORD *, __int64))sub_67F5D9C)(
            v13,
            v22,
            1LL,
            v11,
            a4 & 1,
            &v17,
            a5,
            v14) & 1) != 0 )
      return 0LL;
    v17 = v19;
    v18 = v20;
    sub_67F92D4(v13, v22, &v17, (__int64)&unk_7304F00, v15);
  }
  else
  {
    sub_67F8944((signed __int64)"failed to reserve %zu GiB huge pages\n", a1);
  }
  return 12LL;
}


================================================================================
Function: sub_67F62A4 (0x67F62A4)
================================================================================

__int64 __fastcall sub_67F62A4(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_67F6140(a1, a2, a3, 0LL, 0LL);
}


================================================================================
Function: sub_67F62B0 (0x67F62B0)
================================================================================

__int64 __fastcall sub_67F62B0(__int64 result, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // x19
  unsigned __int64 v5; // x20
  unsigned __int64 v6; // x23
  unsigned __int64 v7; // x24
  unsigned __int64 v8; // x25
  __int64 v9; // x21
  unsigned __int64 v10; // x22
  unsigned __int64 v11; // x8
  bool v12; // cc

  if ( result )
  {
    v4 = result;
    if ( !a2 )
    {
      a2 = qword_730D288;
      if ( !qword_730D288 )
        a2 = sub_67FA1F8();
    }
    v5 = 0LL;
    if ( a2 )
      v6 = a2;
    else
      v6 = 1LL;
    v7 = v4 / v6;
    v8 = v4 % v6;
    if ( a3 )
      v9 = a3 / v6 + 50;
    else
      v9 = 0LL;
    do
    {
      if ( v5 >= v8 )
        v10 = v7;
      else
        v10 = v7 + 1;
      result = sub_67F6140(v10, (unsigned int)v5, v9, 0LL, 0LL);
      if ( (_DWORD)result )
        break;
      v11 = v4 - v10;
      ++v5;
      if ( v4 < v10 )
        v11 = 0LL;
      if ( v5 >= v6 )
        break;
      v12 = v4 > v10;
      v4 = v11;
    }
    while ( v12 );
  }
  return result;
}


================================================================================
Function: sub_67F6374 (0x67F6374)
================================================================================

unsigned __int64 __fastcall sub_67F6374(int *a1, unsigned __int64 a2, char a3, __int64 a4)
{
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x26
  int v11; // w8
  unsigned __int64 v12; // x3
  char v13; // w9
  __int64 v14; // x0
  __int64 v15; // x0
  __int64 v16; // x0
  unsigned __int64 v17; // x3
  bool v18; // w8
  _BYTE v20[4]; // [xsp+8h] [xbp-18h] BYREF
  _BYTE v21[4]; // [xsp+Ch] [xbp-14h] BYREF
  unsigned __int64 v22; // [xsp+10h] [xbp-10h] BYREF

  v8 = 0LL;
  if ( (sub_67F6744(a1 + 34, *((_QWORD *)a1 + 6), 0LL, a2, &v22) & 1) == 0 )
    return v8;
  v9 = v22;
  *((_QWORD *)a1 + 12) = v22 >> 6;
  v10 = atomic_load((unsigned __int64 *)a1 + 4);
  v11 = *a1;
  v12 = v22;
  v13 = *((_BYTE *)a1 + 92);
  *(_DWORD *)(a4 + 13) = 0;
  *(_DWORD *)(a4 + 8) = v11;
  *(_QWORD *)a4 = v12;
  *(_BYTE *)(a4 + 12) = v13;
  *(_QWORD *)(a4 + 16) = 0x600000000LL;
  *(_BYTE *)(a4 + 16) = *((_BYTE *)a1 + 24);
  v14 = *((_QWORD *)a1 + 16);
  if ( v14 )
    sub_67F6BA4(v14, *((_QWORD *)a1 + 6), a2, v12);
  v8 = v10 + (v9 << 25);
  if ( *((_BYTE *)a1 + 26) )
  {
    v15 = *((_QWORD *)a1 + 14);
    if ( v15 )
      *(_BYTE *)(a4 + 18) = sub_67F6CB0(v15, *((_QWORD *)a1 + 6), a2, v22, 0LL) & 1;
  }
  v16 = *((_QWORD *)a1 + 15);
  if ( !v16 )
  {
    v18 = 1;
LABEL_15:
    *(_BYTE *)(a4 + 17) = v18;
    return v8;
  }
  if ( (a3 & 1) == 0 )
  {
    v18 = sub_67F6DFC(v16, *((_QWORD *)a1 + 6), a2, v22);
    goto LABEL_15;
  }
  v17 = v22;
  *(_BYTE *)(a4 + 17) = 1;
  sub_67F6CB0(v16, *((_QWORD *)a1 + 6), a2, v17, v21);
  if ( v21[0] )
  {
    v20[0] = 0;
    if ( sub_67F9B68(v8, a2 << 25, v20) )
    {
      if ( v20[0] )
        *(_BYTE *)(a4 + 18) = 1;
    }
    else
    {
      *(_BYTE *)(a4 + 17) = 0;
    }
  }
  return v8;
}


================================================================================
Function: sub_67F6514 (0x67F6514)
================================================================================

__int64 __fastcall sub_67F6514(unsigned __int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v8; // x8
  signed __int64 v9; // x23
  unsigned __int64 v10; // x24
  char v11; // w22
  __int64 result; // x0
  char v13; // w24

  v8 = atomic_load(a1 + 4);
  v9 = a3 << 25;
  v10 = v8 + (a2 << 25);
  if ( (sub_67F6DFC(a1[15], a1[6]) & 1) != 0 )
  {
    v11 = sub_67F9EF8(v10, v9, a4);
    result = sub_67F6BA4(a1[16], a1[6], a3, a2);
    if ( (v11 & 1) == 0 )
      return result;
    return sub_67F6BA4(a1[15], a1[6], a3, a2);
  }
  v13 = sub_67F9D88(v10, v9, 0LL, a4);
  sub_67FF620(a4 + 96, v9);
  result = sub_67F6BA4(a1[16], a1[6], a3, a2);
  if ( (v13 & 1) != 0 )
    return sub_67F6BA4(a1[15], a1[6], a3, a2);
  return result;
}


================================================================================
Function: sub_67F65FC (0x67F65FC)
================================================================================

bool __fastcall sub_67F65FC(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // x19

  v4 = -1LL;
  if ( a3 <= 0x3F )
  {
    if ( a3 )
      v4 = ~(-1LL << a3) << (a4 & 0x3F);
    else
      v4 = 0LL;
  }
  return (v4 & ~sub_6867540(v4, a1 + ((a4 >> 3) & 0x1FFFFFFFFFFFFFF8LL))) == 0;
}


================================================================================
Function: sub_67F66C0 (0x67F66C0)
================================================================================

bool __fastcall sub_67F66C0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v5; // x21
  __int64 v6; // x22
  unsigned __int64 v7; // x20
  unsigned __int64 v8; // x23
  unsigned __int64 v9; // x0
  bool v10; // zf

  v5 = a4 >> 6;
  v6 = -1LL;
  if ( a3 <= 0x3F )
  {
    if ( a3 )
      v6 = ~(-1LL << a3) << (a4 & 0x3F);
    else
      v6 = 0LL;
  }
  v7 = *(_QWORD *)(a1 + 8 * v5);
  do
  {
    v8 = v7 & v6;
    if ( (v7 & v6) != 0 )
      break;
    v9 = sub_6867020(v7, v7 | v6, (atomic_ullong *)(a1 + 8 * v5));
    v10 = v9 == v7;
    v7 = v9;
  }
  while ( !v10 );
  return v8 == 0;
}


================================================================================
Function: sub_67F6744 (0x67F6744)
================================================================================

bool __fastcall sub_67F6744(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, _QWORD *a5)
{
  unsigned __int64 v6; // x22
  unsigned __int64 v7; // x24
  __int64 v8; // x25
  bool v9; // w21
  __int64 v10; // x26
  unsigned __int64 v11; // x23
  unsigned __int64 v12; // x19
  __int64 v14; // x28
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x0
  bool v17; // zf
  unsigned __int64 v18; // x25
  __int64 v19; // x8
  __int64 v20; // x24
  unsigned __int64 v21; // x23
  unsigned __int64 *v23; // x23
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x9
  __int64 v26; // x14
  unsigned __int64 v27; // x15
  unsigned __int64 v28; // x16
  unsigned __int64 v29; // x25
  unsigned __int64 v30; // x10
  unsigned __int64 v31; // x11
  __int64 v32; // x13
  __int64 v33; // x27
  __int64 v34; // x9
  __int64 v35; // x22
  unsigned __int64 v36; // x24
  unsigned __int64 v37; // x0
  atomic_ullong *v38; // x8
  atomic_ullong *v39; // x24
  unsigned __int64 v40; // x0
  unsigned __int64 *v41; // x8
  unsigned __int64 v42; // x24
  unsigned __int64 v43; // x0
  unsigned __int64 v44; // x25
  unsigned __int64 v45; // x0
  __int64 v46; // x22
  unsigned __int64 v47; // x8
  unsigned __int64 v48; // x0
  unsigned __int64 v49; // x24
  __int64 v50; // x22
  unsigned __int64 v51; // x8
  unsigned __int64 v52; // x0
  __int64 v54; // [xsp+8h] [xbp-68h]
  _QWORD *v55; // [xsp+10h] [xbp-60h]
  __int64 v56; // [xsp+18h] [xbp-58h]
  __int64 v57; // [xsp+20h] [xbp-50h]
  unsigned __int64 v58; // [xsp+30h] [xbp-40h]
  unsigned __int64 v59; // [xsp+38h] [xbp-38h]
  __int64 v60; // [xsp+40h] [xbp-30h]
  unsigned __int64 v61; // [xsp+48h] [xbp-28h]
  unsigned __int64 v62; // [xsp+50h] [xbp-20h]
  __int64 v63; // [xsp+58h] [xbp-18h]
  unsigned __int64 v64; // [xsp+60h] [xbp-10h]

  v64 = a2;
  if ( a4 < 3 )
  {
    if ( a2 )
    {
      v6 = 0LL;
      v7 = 64 - a4;
      if ( a4 )
        v8 = ~(-1LL << a4);
      else
        v8 = 0LL;
      v9 = 1;
      v55 = a5;
      do
      {
        if ( a3 >= a2 )
          v10 = 0LL;
        else
          v10 = a3;
        v11 = *(_QWORD *)(a1 + 8 * v10);
        v12 = __clz(__rbit64(~v11));
        if ( v11 != -1LL && v12 <= v7 )
        {
          v14 = v8 << v12;
          do
          {
            if ( (v14 & v11) != 0 )
            {
              v15 = 64 - (v12 + __clz(v14 & v11));
              if ( a4 == 1 )
                v15 = 1LL;
              v12 += v15;
              v14 <<= v15;
            }
            else
            {
              v16 = sub_6867020(v11, v14 | v11, (atomic_ullong *)(a1 + 8 * v10));
              v17 = v16 == v11;
              v11 = v16;
              if ( v17 )
                goto LABEL_94;
            }
          }
          while ( v12 <= v7 );
        }
        a2 = v64;
        ++v6;
        a3 = v10 + 1;
        v9 = v6 < v64;
      }
      while ( v6 != v64 );
      return v9;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  v18 = 64 - a4;
  v19 = ~(-1LL << a4);
  if ( a4 > 0x3F )
    v19 = -1LL;
  v20 = 0LL;
  v55 = a5;
  v54 = v19;
  v61 = a4 + 63;
  v62 = 64 - a4;
  v56 = a1 + 8;
  v57 = a1 - 8;
  while ( 1 )
  {
    v10 = a3 >= a2 ? 0LL : a3;
    if ( a4 <= 0x40 )
    {
      v21 = *(_QWORD *)(a1 + 8 * v10);
      v12 = __clz(__rbit64(~v21));
      if ( v21 != -1LL && v12 <= v18 )
        break;
    }
LABEL_38:
    v63 = v20;
    v23 = (unsigned __int64 *)(a1 + 8 * v10);
    v24 = *v23;
    v25 = __clz(*v23);
    if ( v25 )
    {
      v26 = 0LL;
      v27 = v64 - v10;
      v28 = v57 + 8 * v10;
LABEL_40:
      if ( v25 >= a4 )
      {
        v49 = *v23;
        if ( *v23 != -1LL )
        {
          v12 = __clz(__rbit64(~v49));
          if ( v12 <= v62 )
          {
            v50 = v54 << v12;
            do
            {
              if ( (v50 & v49) != 0 )
              {
                v51 = v12 + __clz(v50 & v49);
                v12 += 64 - v51;
                v50 <<= -(char)v51;
              }
              else
              {
                v52 = sub_6867020(v49, v50 | v49, (atomic_ullong *)v23);
                if ( v52 == v49 )
                  goto LABEL_93;
                v49 = v52;
              }
            }
            while ( v12 <= v62 );
          }
        }
      }
      else
      {
        v29 = v28;
        v30 = v25;
        if ( v27 > (v61 - v25) >> 6 )
        {
          while ( 1 )
          {
            v31 = v30 + 64 <= a4 ? 64LL : a4 - v30;
            v32 = v31 ? ~(-1LL << v31) : 0LL;
            v33 = v31 <= 0x3F ? v32 : -1LL;
            if ( (v33 & *(_QWORD *)(v29 + 16)) != 0 )
              break;
            v30 += v31;
            v29 += 8LL;
            if ( v30 >= a4 )
            {
              v12 = 64 - v25;
              v58 = v28;
              v59 = v27;
              v60 = v26;
              v34 = ~(-1LL << v25) << -(char)v25;
              if ( v24 )
                v35 = v34;
              else
                v35 = -1LL;
              v36 = *v23;
              do
              {
                if ( (v36 & v35) != 0 )
                {
                  v41 = v23 - 1;
                  goto LABEL_66;
                }
                v37 = sub_6867020(v36, v36 | v35, (atomic_ullong *)v23);
                v17 = v37 == v36;
                v36 = v37;
              }
              while ( !v17 );
              v38 = (atomic_ullong *)(v56 + 8 * v10);
              while ( 1 )
              {
                v39 = v38;
                if ( (unsigned __int64)v38 - 8 >= v29 )
                  break;
                v40 = sub_6867020(0LL, 0xFFFFFFFFFFFFFFFFLL, v38);
                v38 = (atomic_ullong *)((char *)v39 + 8);
                if ( v40 )
                  goto LABEL_63;
              }
              v44 = *(_QWORD *)v38;
              while ( (v44 & v33) == 0 )
              {
                v45 = sub_6867020(v44, v44 | v33, v39);
                v17 = v45 == v44;
                v44 = v45;
                if ( v17 )
                  goto LABEL_93;
              }
LABEL_63:
              v41 = (unsigned __int64 *)((char *)v39 - 8);
LABEL_66:
              while ( v41 > v23 )
                atomic_store(0LL, v41--);
              if ( v41 == v23 )
              {
                v42 = *v23;
                do
                {
                  v43 = sub_6867020(v42, v42 & ~v35, (atomic_ullong *)v23);
                  v17 = v43 == v42;
                  v42 = v43;
                }
                while ( !v17 );
              }
              v28 = v58;
              v27 = v59;
              if ( v60 != 3 )
              {
                v24 = *v23;
                v26 = v60 + 1;
                v25 = __clz(*v23);
                if ( v25 )
                  goto LABEL_40;
              }
              break;
            }
          }
        }
      }
    }
    a2 = v64;
    a3 = v10 + 1;
    v18 = v62;
    v20 = v63 + 1;
    if ( v63 + 1 == v64 )
      return 0;
  }
  v46 = v54 << v12;
  while ( 1 )
  {
    while ( (v46 & v21) != 0 )
    {
      v47 = v12 + __clz(v46 & v21);
      v12 += 64 - v47;
      v46 <<= -(char)v47;
      if ( v12 > v18 )
        goto LABEL_38;
    }
    v48 = sub_6867020(v21, v46 | v21, (atomic_ullong *)(a1 + 8 * v10));
    if ( v48 == v21 )
      break;
    v21 = v48;
    if ( v12 > v18 )
      goto LABEL_38;
  }
LABEL_93:
  v9 = 1;
LABEL_94:
  *v55 = v12 + (v10 << 6);
  return v9;
}


================================================================================
Function: sub_67F6BA4 (0x67F6BA4)
================================================================================

__int64 __fastcall sub_67F6BA4(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // x9
  unsigned __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x19
  unsigned int v8; // w19
  bool v10; // zf
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x19
  __int64 v14; // x20
  atomic_ullong *v15; // x21
  unsigned __int64 v16; // x22
  unsigned __int64 v17; // x0

  v4 = a4 & 0x3F;
  v5 = a4 >> 6;
  if ( v4 + a3 > 0x40 )
  {
    v10 = v4 == 0;
    v11 = a3 - (64 - v4);
    v12 = ~(-1LL << -(char)v4) << v4;
    if ( v10 )
      v13 = -1LL;
    else
      v13 = v12;
    if ( (v11 & 0x3F) != 0 )
      v14 = ~(-1LL << v11);
    else
      v14 = 0LL;
    v15 = (atomic_ullong *)(a1 + 8 * v5 + 8);
    v8 = (v13 & ~sub_6867540(v13, a1 + 8 * v5)) == 0;
    if ( v11 >= 0x40 )
    {
      v16 = v11 >> 6;
      do
      {
        --v16;
        v17 = sub_6867270(0LL, v15);
        v15 = (atomic_ullong *)((char *)v15 + 8);
        v8 = (v17 == -1LL) & (unsigned __int8)v8;
      }
      while ( v16 );
    }
    if ( v14 )
      return ((v14 & ~sub_6867540(v14, v15)) == 0) & (unsigned __int8)v8;
  }
  else
  {
    v6 = ~(-1LL << a3) << v4;
    if ( !a3 )
      v6 = 0LL;
    if ( a3 <= 0x3F )
      v7 = v6;
    else
      v7 = -1LL;
    return (v7 & ~sub_6867540(v7, a1 + 8 * v5)) == 0;
  }
  return v8;
}


================================================================================
Function: sub_67F6CB0 (0x67F6CB0)
================================================================================

__int64 __fastcall sub_67F6CB0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, _BYTE *a5)
{
  __int64 v6; // x9
  unsigned __int64 v7; // x8
  __int64 v8; // x9
  __int64 v9; // x21
  __int64 v10; // x8
  unsigned int v11; // w20
  char v12; // w23
  bool v14; // zf
  __int64 v15; // x20
  unsigned __int64 v16; // x24
  __int64 v17; // x9
  __int64 v18; // x23
  __int64 v19; // x21
  __int64 v20; // x8
  atomic_ullong *v21; // x22
  unsigned __int64 v22; // x24
  unsigned __int64 v23; // x0
  __int64 v24; // x8

  v6 = a4 & 0x3F;
  v7 = a4 >> 6;
  if ( v6 + a3 > 0x40 )
  {
    v14 = v6 == 0;
    v15 = a1 + 8 * v7;
    v16 = a3 - (64 - v6);
    v17 = ~(-1LL << -(char)v6) << v6;
    if ( v14 )
      v18 = -1LL;
    else
      v18 = v17;
    if ( (v16 & 0x3F) != 0 )
      v19 = ~(-1LL << v16);
    else
      v19 = 0LL;
    v20 = sub_6867630(v18, a1 + 8 * v7) & v18;
    v21 = (atomic_ullong *)(v15 + 8);
    v11 = v20 == 0;
    v12 = v20 != v18;
    if ( v16 >= 0x40 )
    {
      v22 = v16 >> 6;
      do
      {
        --v22;
        v23 = sub_6867270(0xFFFFFFFFFFFFFFFFLL, v21);
        v21 = (atomic_ullong *)((char *)v21 + 8);
        v11 = (v23 == 0) & (unsigned __int8)v11;
        v12 |= v23 != -1LL;
      }
      while ( v22 );
    }
    if ( v19 )
    {
      v24 = sub_6867630(v19, v21) & v19;
      v11 = (v24 == 0) & (unsigned __int8)v11;
      v12 |= v24 != v19;
    }
  }
  else
  {
    v8 = ~(-1LL << a3) << v6;
    if ( !a3 )
      v8 = 0LL;
    if ( a3 <= 0x3F )
      v9 = v8;
    else
      v9 = -1LL;
    v10 = sub_6867630(v9, a1 + 8 * v7) & v9;
    v11 = v10 == 0;
    v12 = v10 != v9;
  }
  if ( a5 )
    *a5 = v12 & 1;
  return v11;
}


================================================================================
Function: sub_67F6DFC (0x67F6DFC)
================================================================================

bool __fastcall sub_67F6DFC(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // x9
  unsigned __int64 v5; // x8
  __int64 v6; // x8
  __int64 v7; // x9
  _BOOL8 result; // x0
  _QWORD *v9; // x13
  unsigned __int64 v10; // x10
  __int64 v11; // x9
  __int64 v12; // x8
  __int64 *v13; // x9
  unsigned __int64 v14; // x10
  __int64 v15; // t1

  v4 = a4 & 0x3F;
  v5 = a4 >> 6;
  if ( v4 + a3 > 0x40 )
  {
    v9 = (_QWORD *)(a1 + 8 * v5);
    v10 = a3 - (64 - v4);
    if ( (a4 & 0x3F) != 0 )
      v11 = ~(-1LL << -(char)v4) << v4;
    else
      v11 = -1LL;
    if ( (v10 & 0x3F) != 0 )
      v12 = ~(-1LL << v10);
    else
      v12 = 0LL;
    result = (v11 & ~*v9) == 0;
    v13 = v9 + 1;
    if ( v10 >= 0x40 )
    {
      v14 = v10 >> 6;
      do
      {
        v15 = *v13++;
        --v14;
        result = (v15 == -1) & (unsigned __int8)result;
      }
      while ( v14 );
    }
    if ( v12 )
      return (v12 & ~*v13) == 0 && result;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 8 * v5);
    v7 = ~(-1LL << a3) << v4;
    if ( !a3 )
      v7 = 0LL;
    if ( a3 > 0x3F )
      v7 = -1LL;
    return (v7 & ~v6) == 0;
  }
  return result;
}


================================================================================
Function: sub_67F6EC4 (0x67F6EC4)
================================================================================

__int64 sub_67F6EC4()
{
  return *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
}


================================================================================
Function: sub_67F6ED0 (0x67F6ED0)
================================================================================

_UNKNOWN **sub_67F6ED0()
{
  if ( !qword_6CAF558 )
  {
    qword_6CAF548 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    qword_6CAF558 = 1LL;
    sub_67FC19C(&unk_6CAF570);
    qword_6CAF558 = sub_67F4CE8(&off_6CAEA28);
    qword_6CAF560 = sub_67F4CE8(&off_6CAEA28);
    qword_6CAF568 = sub_67F4CE8(&off_6CAEA28);
  }
  return &off_6CAEA28;
}


================================================================================
Function: sub_67F6F44 (0x67F6F44)
================================================================================

void sub_67F6F44()
{
  __int64 i; // x21
  unsigned __int64 v1; // x0
  __int64 v2; // x8
  __int128 v3; // [xsp+0h] [xbp-20h] BYREF
  __int64 v4; // [xsp+10h] [xbp-10h]

  for ( i = 0LL; i != 16; ++i )
  {
    if ( qword_7305180[i] )
    {
      v1 = sub_6867270(0LL, (atomic_ullong *)&qword_7305180[i]);
      if ( v1 )
      {
        v2 = *(_QWORD *)(v1 + 4680);
        v3 = *(_OWORD *)(v1 + 4664);
        v4 = v2;
        sub_67F92D4(v1, 4688LL, &v3);
      }
    }
  }
}


================================================================================
Function: sub_67F7000 (0x67F7000)
================================================================================

bool sub_67F7000()
{
  __int64 v0; // x8

  v0 = qword_6CAF548;
  return !qword_6CAF548 || v0 == *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
}


================================================================================
Function: sub_67F7028 (0x67F7028)
================================================================================

__int64 sub_67F7028()
{
  return qword_6CAF620;
}


================================================================================
Function: sub_67F7034 (0x67F7034)
================================================================================

_UNKNOWN **sub_67F7034()
{
  _UNKNOWN **result; // x0
  __int64 v1; // x8
  _UNKNOWN **v2; // x0
  _QWORD *v3; // x19
  bool v4; // w8
  __int64 v5; // x3
  __int64 v6; // x4
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  __int64 v10; // x10
  __int128 v11; // [xsp+0h] [xbp-20h] BYREF
  __int64 v12; // [xsp+10h] [xbp-10h]

  sub_67F74CC();
  if ( dword_6CAF9C0 == -1 )
  {
    sub_67F6ED0();
    result = &off_6CAEA28;
    if ( !&off_6CAEA28 )
      goto LABEL_4;
  }
  else
  {
    result = (_UNKNOWN **)pthread_getspecific(dword_6CAF9C0);
    if ( !result )
      goto LABEL_4;
  }
  if ( result != (_UNKNOWN **)&unk_6C58500 )
    return result;
LABEL_4:
  v1 = qword_6CAF548;
  if ( !qword_6CAF548 || v1 == *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8) )
  {
    if ( !qword_6CAF558 )
    {
      qword_6CAF548 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
      qword_6CAF558 = 1LL;
      sub_67FC19C((__int64)&unk_6CAF570);
      qword_6CAF558 = sub_67F4CE8((__int64)&off_6CAEA28);
      qword_6CAF560 = sub_67F4CE8((__int64)&off_6CAEA28);
      qword_6CAF568 = sub_67F4CE8((__int64)&off_6CAEA28);
    }
    v2 = &off_6CAEA28;
    goto LABEL_46;
  }
  if ( qword_7305180 )
  {
    v3 = (_QWORD *)sub_6867270(0LL, &qword_7305180);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_7305188 )
  {
    v3 = (_QWORD *)sub_6867270(0LL, &qword_7305188);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_7305190 )
  {
    v3 = (_QWORD *)sub_6867270(0LL, &qword_7305190);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_7305198 )
  {
    v3 = (_QWORD *)sub_6867270(0LL, &qword_7305198);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_73051A0 )
  {
    v3 = (_QWORD *)sub_6867270(0LL, &qword_73051A0);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_73051A8 )
  {
    v3 = (_QWORD *)sub_6867270(0LL, &qword_73051A8);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_73051B0 )
  {
    v3 = (_QWORD *)sub_6867270(0LL, &qword_73051B0);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_73051B8 )
  {
    v3 = (_QWORD *)sub_6867270(0LL, &qword_73051B8);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_73051C0 )
  {
    v3 = (_QWORD *)sub_6867270(0LL, &qword_73051C0);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_73051C8 && (v3 = (_QWORD *)sub_6867270(0LL, &qword_73051C8)) != 0LL
    || qword_73051D0 && (v3 = (_QWORD *)sub_6867270(0LL, &qword_73051D0)) != 0LL
    || qword_73051D8 && (v3 = (_QWORD *)sub_6867270(0LL, &qword_73051D8)) != 0LL
    || qword_73051E0 && (v3 = (_QWORD *)sub_6867270(0LL, &qword_73051E0)) != 0LL
    || qword_73051E8 && (v3 = (_QWORD *)sub_6867270(0LL, &qword_73051E8)) != 0LL
    || qword_73051F0 && (v3 = (_QWORD *)sub_6867270(0LL, &qword_73051F0)) != 0LL
    || qword_73051F8 && (v3 = (_QWORD *)sub_6867270(0LL, &qword_73051F8)) != 0LL )
  {
LABEL_41:
    v4 = 0;
    if ( !v3 )
      goto LABEL_44;
    goto LABEL_42;
  }
  v3 = (_QWORD *)sub_67F9334(4688LL, &v11, &unk_7304F00);
  if ( !v3 )
  {
    v3 = (_QWORD *)sub_67F9334(4688LL, &v11, &unk_7304F00);
    if ( !v3 )
    {
      sub_67F8A74(12LL, "unable to allocate thread local heap metadata (%zu bytes)\n", 4688LL, v5, v6, v7, v8, v9, v11);
      goto LABEL_41;
    }
  }
  v10 = v12;
  v4 = BYTE2(v12) != 0;
  *(_OWORD *)(v3 + 583) = v11;
  v3[585] = v10;
LABEL_42:
  if ( !v4 )
    memset(v3, 0, 0x1250uLL);
LABEL_44:
  if ( v3 )
  {
    memcpy(v3 + 383, &unk_6C59100, 0x640uLL);
    memcpy(v3, &unk_6C58500, 0xBF8uLL);
    v3[356] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    sub_67FC19C((__int64)(v3 + 361));
    v3[358] = sub_67F4CE8((__int64)v3) | 1;
    v3[359] = sub_67F4CE8((__int64)v3);
    v3[360] = sub_67F4CE8((__int64)v3);
    v2 = (_UNKNOWN **)v3;
    *v3 = v3 + 383;
    v3[385] = v3;
    v3[386] = v3;
    v3[499] = v3 + 503;
    v3[500] = v3 + 501;
    v3[502] = v3 + 503;
LABEL_46:
    sub_6801224(v2);
  }
  sub_67FF620(&unk_7305020, 1LL);
  return (_UNKNOWN **)sub_6867420(1uLL, (atomic_ullong *)&qword_6CAF620);
}


================================================================================
Function: sub_67F74CC (0x67F74CC)
================================================================================

void sub_67F74CC()
{
  const void *v0; // x0
  _UNKNOWN **v1; // x0
  __int64 v2; // x19
  __int64 v3; // x0
  __int64 v4; // x0

  if ( !qword_6CAF558 )
  {
    qword_6CAF548 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    qword_6CAF558 = 1LL;
    sub_67FC19C((__int64)&unk_6CAF570);
    qword_6CAF558 = sub_67F4CE8((__int64)&off_6CAEA28);
    qword_6CAF560 = sub_67F4CE8((__int64)&off_6CAEA28);
    qword_6CAF568 = sub_67F4CE8((__int64)&off_6CAEA28);
  }
  if ( !qword_7305208 && !sub_6867020(0LL, 1uLL, (atomic_ullong *)&qword_7305208) )
  {
    byte_7304ED0 = 1;
    v0 = (const void *)sub_67F7E58(
                         "process init: 0x%zx\n",
                         *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8));
    if ( (byte_7305210 & 1) == 0 )
    {
      byte_7305210 = 1;
      sub_6801200(v0);
      v0 = sub_6801224(&off_6CAEA28);
    }
    sub_67F9018(v0);
    if ( !qword_6CAF558 )
    {
      qword_6CAF548 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
      qword_6CAF558 = 1LL;
      sub_67FC19C((__int64)&unk_6CAF570);
      qword_6CAF558 = sub_67F4CE8((__int64)&off_6CAEA28);
      qword_6CAF560 = sub_67F4CE8((__int64)&off_6CAEA28);
      qword_6CAF568 = sub_67F4CE8((__int64)&off_6CAEA28);
    }
    sub_67F7E58("secure level: %d\n", 0);
    sub_67F7E58("mem tracking: %s\n", "none");
    v1 = sub_67F7034();
    sub_67FF7EC(v1);
    if ( (sub_67F8510(7LL) & 1) != 0 )
    {
      v2 = sub_67F841C(7LL, 0LL, 0x20000LL);
      v3 = sub_67F7E08(8LL);
      if ( v3 == -1 )
        sub_67F62B0(v2, 0LL, 500 * v2);
      else
        sub_67F62A4(v2, v3, 500 * v2);
    }
    if ( (sub_67F8510(9LL) & 1) != 0 )
    {
      v4 = sub_67F7E08(9LL);
      if ( v4 >= 1 )
        sub_67F5FE8(v4 << 10, 1LL, 1LL, 0LL, 0LL);
    }
  }
}


================================================================================
Function: sub_67F7B2C (0x67F7B2C)
================================================================================

bool sub_67F7B2C()
{
  return (byte_7305200 & 1) == 0;
}


================================================================================
Function: sub_67F7E08 (0x67F7E08)
================================================================================

__int64 __fastcall sub_67F7E08(unsigned int a1)
{
  __int64 *v2; // x19

  if ( a1 > 0x19 )
    return 0LL;
  v2 = &qword_6CAF628[4 * a1];
  if ( !*((_DWORD *)v2 + 2) )
    sub_67F7F94((__int64)&qword_6CAF628[4 * a1]);
  return *v2;
}


================================================================================
Function: sub_67F7E58 (0x67F7E58)
================================================================================

__int64 sub_67F7E58(__int64 result, ...)
{
  const char *v1; // x19
  unsigned __int64 v2; // x19
  __int64 (__fastcall *v3)(); // x21
  gcc_va_list va1; // [xsp+C0h] [xbp-270h] BYREF
  gcc_va_list va; // [xsp+E0h] [xbp-250h] BYREF
  gcc_va_list arg; // [xsp+100h] [xbp-230h] BYREF
  char s[512]; // [xsp+128h] [xbp-208h] BYREF

  v1 = (const char *)result;
  if ( !dword_6CAF670 )
    result = sub_67F7F94((__int64)&qword_6CAF668);
  if ( qword_6CAF668 )
  {
    va_start(va, result);
    va_copy(va1, va);
    if ( v1 )
    {
      result = sub_67F8E04();
      if ( (result & 1) != 0 )
      {
        va_copy(arg, va1);
        vsnprintf(s, 0x1FFuLL, v1, arg);
        sub_67F8E48();
        result = sub_67F8E04();
        if ( (result & 1) != 0 )
        {
          v2 = atomic_load(&qword_7305220);
          if ( qword_7305218 )
          {
            v3 = (__int64 (__fastcall *)())qword_7305218;
            ((void (__fastcall *)(const char *, unsigned __int64))qword_7305218)("mimalloc: ", v2);
          }
          else
          {
            v3 = sub_67F8D60;
            ((void (__fastcall *)(const char *, unsigned __int64))sub_67F8D60)("mimalloc: ", v2);
          }
          ((void (__fastcall *)(char *, unsigned __int64))v3)(s, v2);
          return (__int64)sub_67F8E48();
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67F7F94 (0x67F7F94)
================================================================================

signed __int64 __fastcall sub_67F7F94(__int64 a1)
{
  char *v2; // x21
  _BYTE *v3; // x8
  char *v4; // x9
  unsigned __int64 v5; // x12
  __int64 v6; // x13
  char *v7; // x11
  unsigned __int64 v8; // x10
  int v9; // w13
  int v10; // w12
  __int64 v11; // x11
  bool v12; // cc
  signed __int64 result; // x0
  _BYTE *v14; // x8
  char *v15; // x9
  unsigned __int64 v16; // x11
  __int64 v17; // x12
  unsigned __int64 v18; // x10
  int v19; // w12
  int v20; // w11
  __int64 v21; // x12
  bool v22; // cc
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x8
  unsigned __int64 v26; // x9
  __int64 v27; // x10
  int v28; // w8
  int8x16_t v29; // q0
  uint8x16_t v30; // q1
  int8x16_t v31; // q2
  int8x16_t v32; // q0
  uint8x16_t v33; // q1
  int8x16_t v34; // q2
  int8x8_t *v35; // x11
  int8x8_t *v36; // x12
  unsigned __int64 v37; // x13
  int8x8_t v38; // t1
  int v39; // w13
  int v40; // w8
  char *v41; // x9
  int v42; // w10
  const char *v43; // x1
  char *endptr; // [xsp+8h] [xbp-B8h] BYREF
  char needle[16]; // [xsp+10h] [xbp-B0h] BYREF
  int8x16_t v46; // [xsp+20h] [xbp-A0h]
  int8x16_t v47; // [xsp+30h] [xbp-90h]
  int8x16_t v48; // [xsp+40h] [xbp-80h]
  int8x16_t v49; // [xsp+60h] [xbp-60h] BYREF
  int8x16_t v50; // [xsp+70h] [xbp-50h]
  int8x16_t v51; // [xsp+80h] [xbp-40h]
  int8x16_t v52; // [xsp+90h] [xbp-30h]

  v2 = &needle[1];
  v3 = *(_BYTE **)(a1 + 16);
  strcpy(needle, "mimalloc_");
  if ( v3 )
  {
    v4 = needle;
    v5 = 64LL;
    v6 = 62LL;
    v7 = &needle[1];
    do
    {
      v8 = v6;
      v9 = (unsigned __int8)v4[2];
      ++v7;
      --v5;
      ++v4;
      if ( !v9 )
        break;
      v6 = v8 - 1;
    }
    while ( v5 > 1 );
    if ( v5 >= 2 )
    {
      LOBYTE(v10) = *v3;
      if ( *v3 )
      {
        v11 = 1LL;
        do
        {
          v4[v11] = v10;
          v10 = (unsigned __int8)v3[v11++];
          if ( v10 )
            v12 = v8 > 1;
          else
            v12 = 0;
          --v8;
        }
        while ( v12 );
        v7 = &v4[v11];
      }
    }
    *v7 = 0;
  }
  result = sub_6801130(needle, &v49, 65LL);
  if ( (result & 1) == 0 )
  {
    v14 = *(_BYTE **)(a1 + 24);
    if ( !v14 )
      goto LABEL_36;
    v15 = needle;
    v16 = 64LL;
    v17 = 62LL;
    strcpy(needle, "mimalloc_");
    do
    {
      v18 = v17;
      v19 = (unsigned __int8)v15[2];
      ++v2;
      --v16;
      ++v15;
      if ( !v19 )
        break;
      v17 = v18 - 1;
    }
    while ( v16 > 1 );
    if ( v16 >= 2 )
    {
      LOBYTE(v20) = *v14;
      if ( *v14 )
      {
        v21 = 1LL;
        do
        {
          v15[v21] = v20;
          v20 = (unsigned __int8)v14[v21++];
          if ( v20 )
            v22 = v18 > 1;
          else
            v22 = 0;
          --v18;
        }
        while ( v22 );
        v2 = &v15[v21];
      }
    }
    *v2 = 0;
    if ( (sub_6801130(needle, &v49, 65LL) & 1) == 0 )
    {
LABEL_36:
      result = sub_67F7B2C();
      if ( (result & 1) != 0 )
        return result;
      v28 = 1;
      goto LABEL_57;
    }
    result = sub_67F8944(
               (signed __int64)"environment option \"mimalloc_%s\" is deprecated -- use \"mimalloc_%s\" instead.\n",
               *(const char **)(a1 + 24),
               *(const char **)(a1 + 16));
  }
  v23 = 0LL;
  do
  {
    v24 = v23 + 1;
    if ( !v49.n128_u8[v23] )
      break;
  }
  while ( v23++ < 0x40 );
  v26 = v24 - 1;
  if ( v24 != 1 )
  {
    if ( v26 < 8 )
    {
      v27 = 0LL;
      goto LABEL_49;
    }
    if ( v26 < 0x10 )
    {
      v27 = 0LL;
      goto LABEL_46;
    }
    v29.n128_u64[0] = 0x9F9F9F9F9F9F9F9FLL;
    v29.n128_u64[1] = 0x9F9F9F9F9F9F9F9FLL;
    v30.n128_u64[0] = 0x1A1A1A1A1A1A1A1ALL;
    v30.n128_u64[1] = 0x1A1A1A1A1A1A1A1ALL;
    v27 = v26 & 0x7FFFFFFFFFFFFFF0LL;
    v31.n128_u64[0] = 0xE0E0E0E0E0E0E0E0LL;
    v31.n128_u64[1] = 0xE0E0E0E0E0E0E0E0LL;
    *(int8x16_t *)needle = vbslq_s8(vcgtq_u8(v30, vaddq_s8(v49, v29)), vaddq_s8(v49, v31), v49);
    if ( (v26 & 0x7FFFFFFFFFFFFFF0LL) != 0x10 )
    {
      v46 = vbslq_s8(vcgtq_u8(v30, vaddq_s8(v50, v29)), vaddq_s8(v50, v31), v50);
      if ( v27 != 32 )
      {
        v32.n128_u64[0] = 0x9F9F9F9F9F9F9F9FLL;
        v32.n128_u64[1] = 0x9F9F9F9F9F9F9F9FLL;
        v33.n128_u64[0] = 0x1A1A1A1A1A1A1A1ALL;
        v33.n128_u64[1] = 0x1A1A1A1A1A1A1A1ALL;
        v34.n128_u64[0] = 0xE0E0E0E0E0E0E0E0LL;
        v34.n128_u64[1] = 0xE0E0E0E0E0E0E0E0LL;
        v47 = vbslq_s8(vcgtq_u8(v33, vaddq_s8(v51, v32)), vaddq_s8(v51, v34), v51);
        if ( v27 != 48 )
          v48 = vbslq_s8(vcgtq_u8(v33, vaddq_s8(v52, v32)), vaddq_s8(v52, v34), v52);
      }
    }
    if ( v26 != v27 )
    {
      if ( (v26 & 8) == 0 )
      {
        do
        {
LABEL_49:
          v39 = v49.n128_u8[v27];
          if ( (unsigned int)(v39 - 97) < 0x1A )
            LOBYTE(v39) = v39 - 32;
          needle[v27++] = v39;
        }
        while ( v26 != v27 );
        goto LABEL_52;
      }
LABEL_46:
      v35 = (int8x8_t *)((char *)&v49 + v27);
      v36 = (int8x8_t *)&needle[v27];
      v37 = v27 - (v26 & 0xFFFFFFFFFFFFFFF8LL);
      v27 = v26 & 0x7FFFFFFFFFFFFFF8LL;
      do
      {
        v38.n64_u64[0] = v35->n64_u64[0];
        ++v35;
        v37 += 8LL;
        v36->n64_u64[0] = vbsl_s8(
                            vcgt_u8((uint8x8_t)0x1A1A1A1A1A1A1A1ALL, vadd_s8(v38, (int8x8_t)0x9F9F9F9F9F9F9F9FLL)),
                            vadd_s8(v38, (int8x8_t)0xE0E0E0E0E0E0E0E0LL),
                            v38).n64_u64[0];
        ++v36;
      }
      while ( v37 );
      if ( v26 == v27 )
        goto LABEL_52;
      goto LABEL_49;
    }
  }
LABEL_52:
  needle[v24 - 1] = 0;
  if ( !needle[0] || (result = (signed __int64)strstr("1;TRUE;YES;ON", needle)) != 0 )
  {
    *(_QWORD *)a1 = 1LL;
    *(_DWORD *)(a1 + 8) = 2;
    return result;
  }
  result = (signed __int64)strstr("0;FALSE;NO;OFF", needle);
  if ( result )
  {
    v28 = 2;
    *(_QWORD *)a1 = 0LL;
LABEL_57:
    *(_DWORD *)(a1 + 8) = v28;
    return result;
  }
  endptr = needle;
  result = strtol(needle, &endptr, 10);
  v40 = *(_DWORD *)(a1 + 12);
  if ( v40 != 9 && v40 != 23 )
  {
    v41 = endptr;
    goto LABEL_75;
  }
  v41 = endptr;
  v42 = (unsigned __int8)*endptr;
  switch ( v42 )
  {
    case 'G':
      v41 = endptr + 1;
      result <<= 20;
      break;
    case 'M':
      v41 = endptr + 1;
      result <<= 10;
      break;
    case 'K':
      v41 = endptr + 1;
      break;
    default:
      result = (unsigned __int64)(result + 1023) >> 10;
      if ( v42 != 66 )
        goto LABEL_69;
LABEL_73:
      ++v41;
      goto LABEL_74;
  }
  v42 = (unsigned __int8)*v41;
  endptr = v41;
  if ( v42 == 66 )
    goto LABEL_73;
LABEL_69:
  if ( v42 == 73 && v41[1] == 66 )
  {
    v41 += 2;
LABEL_74:
    endptr = v41;
  }
LABEL_75:
  if ( !*v41 )
  {
    v28 = 2;
    *(_QWORD *)a1 = result;
    goto LABEL_57;
  }
  *(_DWORD *)(a1 + 8) = 1;
  if ( v40 != 2 || *(_QWORD *)a1 )
    return sub_67F8944(
             (signed __int64)"environment option mimalloc_%s has an invalid value.\n",
             *(const char **)(a1 + 16));
  v43 = *(const char **)(a1 + 16);
  *(_QWORD *)a1 = 1LL;
  result = sub_67F8944((signed __int64)"environment option mimalloc_%s has an invalid value.\n", v43);
  *(_QWORD *)a1 = 0LL;
  return result;
}


================================================================================
Function: sub_67F841C (0x67F841C)
================================================================================

__int64 __fastcall sub_67F841C(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x8
  __int64 *v6; // x21
  __int64 v7; // x9

  if ( a1 <= 0x19 )
  {
    v6 = &qword_6CAF628[4 * a1];
    if ( !*((_DWORD *)v6 + 2) )
      sub_67F7F94((__int64)&qword_6CAF628[4 * a1]);
    v5 = *v6;
  }
  else
  {
    v5 = 0LL;
  }
  if ( v5 <= a3 )
    v7 = v5;
  else
    v7 = a3;
  if ( v5 >= a2 )
    return v7;
  else
    return a2;
}


================================================================================
Function: sub_67F848C (0x67F848C)
================================================================================

__int64 __fastcall sub_67F848C(unsigned int a1)
{
  __int64 *v2; // x19

  if ( a1 > 0x19 )
    return 0LL;
  v2 = &qword_6CAF628[4 * a1];
  if ( !*((_DWORD *)v2 + 2) )
    sub_67F7F94((__int64)&qword_6CAF628[4 * a1]);
  if ( *v2 >= 0 )
    return *v2 << 10;
  else
    return 0LL;
}


================================================================================
Function: sub_67F8510 (0x67F8510)
================================================================================

bool __fastcall sub_67F8510(unsigned int a1)
{
  __int64 *v2; // x19

  if ( a1 > 0x19 )
    return 0LL;
  v2 = &qword_6CAF628[4 * a1];
  if ( !*((_DWORD *)v2 + 2) )
    sub_67F7F94((__int64)&qword_6CAF628[4 * a1]);
  return *v2 != 0;
}


================================================================================
Function: sub_67F87A0 (0x67F87A0)
================================================================================

__int64 __fastcall sub_67F87A0(__int64 result, const char *a2, __int128 *a3)
{
  __int64 v4; // x20
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x8
  __int128 v8; // q1
  __int64 v9; // x0
  __int64 v10; // x0
  unsigned __int64 v11; // x19
  __int64 (__fastcall *v12)(); // x21
  __int64 v13; // x0
  __int64 v14; // x0
  __int64 v15; // x0
  unsigned __int64 v16; // x19
  __int64 (__fastcall *v17)(); // x20
  __int128 v18; // [xsp+0h] [xbp-290h]
  __int128 v19; // [xsp+10h] [xbp-280h]
  __int128 v20; // [xsp+20h] [xbp-270h] BYREF
  __int128 v21; // [xsp+30h] [xbp-260h]
  _OWORD arg[4]; // [xsp+40h] [xbp-250h] BYREF
  char s[512]; // [xsp+88h] [xbp-208h] BYREF

  v4 = result;
  if ( !result )
    goto LABEL_7;
  v6 = 0LL;
  do
  {
    v7 = v6;
    if ( !*(_BYTE *)(result + v6) )
      break;
    ++v6;
  }
  while ( v7 < 0x21 );
  if ( v7 <= 0x20 && (result = sub_67F7000(result), (result & 1) == 0) )
  {
    sub_67F6EC4();
    result = sub_67F8E68(arg);
    v18 = *a3;
    v19 = a3[1];
    if ( a2 )
    {
      result = sub_67F8E04(result);
      if ( (result & 1) != 0 )
      {
        v20 = v18;
        v21 = v19;
        v14 = vsnprintf(s, 0x1FFuLL, a2, &v20);
        v15 = sub_67F8E48(v14);
        result = sub_67F8E04(v15);
        if ( (result & 1) != 0 )
        {
          v16 = atomic_load(&qword_7305220);
          if ( qword_7305218 )
          {
            v17 = (__int64 (__fastcall *)())qword_7305218;
            ((void (__fastcall *)(_OWORD *, unsigned __int64))qword_7305218)(arg, v16);
          }
          else
          {
            v17 = sub_67F8D60;
            ((void (__fastcall *)(_OWORD *, unsigned __int64))sub_67F8D60)(arg, v16);
          }
          v13 = ((__int64 (__fastcall *)(char *, unsigned __int64))v17)(s, v16);
          return sub_67F8E48(v13);
        }
      }
    }
  }
  else
  {
LABEL_7:
    v8 = a3[1];
    v20 = *a3;
    v21 = v8;
    if ( a2 )
    {
      result = sub_67F8E04(result);
      if ( (result & 1) != 0 )
      {
        arg[0] = v20;
        arg[1] = v21;
        v9 = vsnprintf(s, 0x1FFuLL, a2, arg);
        v10 = sub_67F8E48(v9);
        result = sub_67F8E04(v10);
        if ( (result & 1) != 0 )
        {
          v11 = atomic_load(&qword_7305220);
          if ( qword_7305218 )
            v12 = (__int64 (__fastcall *)())qword_7305218;
          else
            v12 = sub_67F8D60;
          if ( v4 )
            ((void (__fastcall *)(__int64, unsigned __int64))v12)(v4, v11);
          v13 = ((__int64 (__fastcall *)(char *, unsigned __int64))v12)(s, v11);
          return sub_67F8E48(v13);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67F8944 (0x67F8944)
================================================================================

signed __int64 sub_67F8944(signed __int64 result, ...)
{
  signed __int64 v1; // x19
  gcc_va_list va1; // [xsp+C0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-28h] BYREF

  v1 = result;
  if ( !dword_6CAF670 )
    result = sub_67F7F94(&qword_6CAF668);
  if ( qword_6CAF668 )
    goto LABEL_4;
  if ( !dword_6CAF630 )
    result = sub_67F7F94(&qword_6CAF628);
  if ( qword_6CAF628 )
  {
    if ( qword_6CAF970 < 0 || (result = sub_68674B0(1uLL, (atomic_ullong *)&unk_7305228), result <= qword_6CAF970) )
    {
LABEL_4:
      va_start(va, result);
      va_copy(va1, va);
      return sub_67F87A0("mimalloc: warning: ", v1, va1);
    }
  }
  return result;
}


================================================================================
Function: sub_67F8A74 (0x67F8A74)
================================================================================

__int64 __fastcall sub_67F8A74(
        __int64 result,
        const char *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  unsigned int v10; // w19
  __int64 (__fastcall *v11)(_QWORD, unsigned __int64); // x8
  unsigned __int64 v12; // x1
  _QWORD v13[6]; // [xsp+80h] [xbp-A0h] BYREF
  __int128 v14; // [xsp+B0h] [xbp-70h] BYREF
  __int128 v15; // [xsp+C0h] [xbp-60h]
  __int128 v16; // [xsp+D0h] [xbp-50h]
  __int128 v17; // [xsp+E0h] [xbp-40h]
  _OWORD v18[2]; // [xsp+F0h] [xbp-30h] BYREF

  v13[1] = a4;
  v13[2] = a5;
  v13[0] = a3;
  v13[3] = a6;
  v13[4] = a7;
  v13[5] = a8;
  v10 = result;
  *(_QWORD *)&v17 = v13;
  *((_QWORD *)&v17 + 1) = 0xFFFFFF80FFFFFFD0LL;
  *(_QWORD *)&v16 = &a9;
  *((_QWORD *)&v16 + 1) = &v14;
  v14 = v16;
  v15 = v17;
  if ( !dword_6CAF670 )
    result = sub_67F7F94(&qword_6CAF668);
  if ( qword_6CAF668 )
    goto LABEL_4;
  if ( !dword_6CAF630 )
    result = sub_67F7F94(&qword_6CAF628);
  if ( qword_6CAF628 )
  {
    if ( qword_6CAF968 < 0 || (result = sub_68674B0(1uLL, (atomic_ullong *)&unk_730D250), result <= qword_6CAF968) )
    {
LABEL_4:
      v18[0] = v14;
      v18[1] = v15;
      result = sub_67F87A0("mimalloc: error: ", a2, v18);
    }
  }
  if ( off_7305230 )
  {
    v11 = (__int64 (__fastcall *)(_QWORD, unsigned __int64))off_7305230;
    v12 = atomic_load(&qword_7305238);
    return v11(v10, v12);
  }
  return result;
}


================================================================================
Function: sub_67F8BD8 (0x67F8BD8)
================================================================================

__int64 __fastcall sub_67F8BD8(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 v3; // w8
  unsigned __int8 *v4; // x9
  int v5; // w10
  unsigned __int8 v6; // w12
  int v7; // w11
  unsigned __int8 v8; // w12
  int v9; // t1

  if ( !a3 )
    return 0LL;
  v3 = *a1;
  if ( *a1 )
  {
    v4 = a1 + 1;
    do
    {
      v5 = *a2;
      if ( !*a2 || !a3 )
        break;
      v6 = v3 - 32;
      if ( (unsigned __int8)(v3 - 97) >= 0x1Au )
        v6 = v3;
      v7 = v6;
      if ( (unsigned int)(v5 - 97) >= 0x1A )
        v8 = *a2;
      else
        v8 = v5 - 32;
      if ( v7 != v8 )
        return (unsigned int)((char)v3 - (char)v5);
      v9 = *v4++;
      v3 = v9;
      ++a2;
      --a3;
    }
    while ( v9 );
    if ( !a3 )
      return 0LL;
  }
  LOBYTE(v5) = *a2;
  return (unsigned int)((char)v3 - (char)v5);
}


================================================================================
Function: sub_67F8C50 (0x67F8C50)
================================================================================

_BYTE *__fastcall sub_67F8C50(_BYTE *result, _BYTE *a2, unsigned __int64 a3)
{
  char v3; // w8
  unsigned __int64 v4; // x9
  unsigned __int8 *v5; // x10
  int v6; // t1
  bool v7; // cf

  if ( result && a2 && a3 )
  {
    v3 = *a2;
    if ( *a2 && a3 >= 2 )
    {
      v4 = a3 - 1;
      v5 = a2 + 1;
      do
      {
        *result++ = v3;
        v6 = *v5++;
        v3 = v6;
        v7 = v4-- != 0;
      }
      while ( v6 && v4 != 0 && v7 );
    }
    *result = 0;
  }
  return result;
}


================================================================================
Function: sub_67F8C90 (0x67F8C90)
================================================================================

__int64 __fastcall sub_67F8C90(__int64 result)
{
  __int64 v1; // x8

  if ( result )
  {
    v1 = 0LL;
    while ( *(unsigned __int8 *)(result + v1++) )
      ;
    return v1 - 1;
  }
  return result;
}


================================================================================
Function: sub_67F8E04 (0x67F8E04)
================================================================================

__int64 sub_67F8E04()
{
  int v0; // w19

  v0 = *(unsigned __int8 *)sub_6866980(qword_6CAF978);
  if ( (v0 & 1) == 0 )
    *(_BYTE *)sub_6866980(qword_6CAF978) = 1;
  return v0 ^ 1u;
}


================================================================================
Function: sub_67F8E48 (0x67F8E48)
================================================================================

_QWORD *sub_67F8E48()
{
  _QWORD *result; // x0

  result = sub_6866980(qword_6CAF978);
  *(_BYTE *)result = 0;
  return result;
}


================================================================================
Function: sub_67F8E68 (0x67F8E68)
================================================================================

__int64 sub_67F8E68(char *a1, __int64 a2, __int64 a3, __int64 a4, ...)
{
  gcc_va_list arg; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, a4);
  va_copy(arg, va);
  return vsnprintf(a1, 0x40uLL, "%sthread 0x%llx: ", arg);
}


================================================================================
Function: sub_67F8F0C (0x67F8F0C)
================================================================================

__int64 sub_67F8F0C()
{
  return (unsigned __int8)byte_6CAF9B0;
}


================================================================================
Function: sub_67F8F18 (0x67F8F18)
================================================================================

__int64 sub_67F8F18()
{
  return (unsigned __int8)byte_6CAF9B2;
}


================================================================================
Function: sub_67F8F24 (0x67F8F24)
================================================================================

__int64 sub_67F8F24()
{
  return qword_6CAF998;
}


================================================================================
Function: sub_67F8F30 (0x67F8F30)
================================================================================

bool __fastcall sub_67F8F30(unsigned __int64 a1, unsigned __int64 a2)
{
  return qword_6CAF9A0 && sub_67F8510(6u) && !(a1 % qword_6CAF9A0) && a2 % qword_6CAF9A0 == 0;
}


================================================================================
Function: sub_67F8F98 (0x67F8F98)
================================================================================

unsigned __int64 __fastcall sub_67F8F98(unsigned __int64 result)
{
  unsigned __int64 v1; // x8
  unsigned __int64 v2; // x9

  if ( result >> 19 )
  {
    if ( result >= 0x200000 )
    {
      if ( result >= 0x800000 )
      {
        v1 = 0x400000LL;
        if ( !(result >> 25) )
          v1 = 0x100000LL;
      }
      else
      {
        v1 = 0x40000LL;
      }
    }
    else
    {
      v1 = 0x10000LL;
    }
  }
  else
  {
    v1 = qword_6CAF998;
  }
  if ( ~v1 > result )
  {
    v2 = result + v1 - 1;
    if ( (v1 & (v1 - 1)) != 0 )
      return v2 / v1 * v1;
    else
      return v2 & -(__int64)v1;
  }
  return result;
}


================================================================================
Function: sub_67F9018 (0x67F9018)
================================================================================

__int64 sub_67F9018()
{
  return sub_6800990(&qword_6CAF998);
}


================================================================================
Function: sub_67F9024 (0x67F9024)
================================================================================

unsigned __int64 __fastcall sub_67F9024(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // x20
  unsigned __int64 v5; // x21
  void *v6; // x0
  __int64 v7; // x0

  if ( a1 - 33554433 < 0xFFFFFFFFFE000001LL )
    return 0LL;
  v2 = (a2 + 0x1FFFFFF) & 0xFFFFFFFFFE000000LL;
  if ( v2 > 0x40000000 )
    return 0LL;
  v5 = sub_68674B0(v2, (atomic_ullong *)&unk_730D280);
  if ( v5 - 0x1E0000000001LL <= 0xFFFFE1FFFFFFFFFFLL )
  {
    if ( dword_6CAF9C0 == -1 )
      v6 = sub_67F6ED0();
    else
      v6 = pthread_getspecific(dword_6CAF9C0);
    if ( !v6 )
      v6 = &unk_6C58500;
    v7 = sub_67F4CE8((__int64)v6);
    sub_6867020(v5 + v2, ((v7 << 8) & 0x3FFFE000000LL) + 0x20000000000LL, (atomic_ullong *)&unk_730D280);
    v5 = sub_68674B0(v2, (atomic_ullong *)&unk_730D280);
  }
  if ( v5 % a1 )
    return 0LL;
  else
    return v5;
}


================================================================================
Function: sub_67F9118 (0x67F9118)
================================================================================

unsigned __int64 __fastcall sub_67F9118(unsigned __int64 result, unsigned __int64 a2, char a3, char **a4)
{
  int v4; // w8
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x10
  char *v9; // x21
  unsigned __int64 v10; // x20
  int v11; // w0
  int v12; // w0

  v4 = *((_DWORD *)a4 + 5);
  if ( (unsigned int)(v4 - 3) <= 2 )
  {
    if ( a2 >> 19 )
    {
      if ( a2 >= 0x200000 )
      {
        if ( a2 >= 0x800000 )
        {
          v6 = 0x400000LL;
          if ( !(a2 >> 25) )
            v6 = 0x100000LL;
        }
        else
        {
          v6 = 0x40000LL;
        }
      }
      else
      {
        v6 = 0x10000LL;
      }
    }
    else
    {
      v6 = qword_6CAF998;
    }
    if ( ~v6 > a2 )
    {
      v7 = a2 + v6 - 1;
      if ( (v6 & (v6 - 1)) != 0 )
        a2 = v7 / v6 * v6;
      else
        a2 = v7 & -(__int64)v6;
    }
    v8 = result - (_QWORD)*a4;
    if ( *a4 )
    {
      v9 = *a4;
    }
    else
    {
      v8 = 0LL;
      v9 = (char *)result;
    }
    v10 = v8 + a2;
    if ( v4 == 4 )
    {
      if ( v9 && v10 >> 30 )
      {
        do
        {
          v11 = sub_6800A5C(v9, 0x40000000LL);
          if ( v11 )
            sub_67F8944(
              (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
              v11,
              v11,
              0x40000000uLL,
              v9);
          sub_67FF704((unsigned __int64)&unk_7304F60, 0x40000000uLL);
          result = sub_67FF704((unsigned __int64)&unk_7304F40, 0x40000000uLL);
          v10 -= 0x40000000LL;
          v9 += 0x40000000;
        }
        while ( v10 >> 30 );
      }
    }
    else if ( v9 && v10 )
    {
      v12 = sub_6800A5C(v9, v8 + a2);
      if ( v12 )
        sub_67F8944(
          (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
          v12,
          v12,
          v10,
          v9);
      if ( (a3 & 1) != 0 )
        sub_67FF704((unsigned __int64)&unk_7304F60, v10);
      return sub_67FF704((unsigned __int64)&unk_7304F40, v10);
    }
  }
  return result;
}


================================================================================
Function: sub_67F92D4 (0x67F92D4)
================================================================================

__int64 __fastcall sub_67F92D4(__int64 a1, __int64 a2, __int128 *a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x8
  __int128 v7; // [xsp+0h] [xbp-20h] BYREF
  __int64 v8; // [xsp+10h] [xbp-10h]

  v5 = *((_QWORD *)a3 + 2);
  v7 = *a3;
  v8 = v5;
  return sub_67F9118(a1, a2, 1LL, &v7, a5);
}


================================================================================
Function: sub_67F9334 (0x67F9334)
================================================================================

unsigned __int64 __fastcall sub_67F9334(unsigned __int64 result, __int64 a2)
{
  signed __int64 v3; // x20
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x9
  int v6; // w0
  char v7; // w8
  char v8; // w10
  _BYTE v9[4]; // [xsp+8h] [xbp-18h] BYREF
  _BYTE v10[4]; // [xsp+Ch] [xbp-14h] BYREF
  unsigned __int64 v11; // [xsp+10h] [xbp-10h] BYREF

  *(_QWORD *)a2 = 0LL;
  *(_QWORD *)(a2 + 8) = 0LL;
  *(_QWORD *)(a2 + 16) = 0LL;
  if ( result )
  {
    v3 = result;
    if ( result >> 19 )
    {
      if ( result >= 0x200000 )
      {
        if ( result >= 0x800000 )
        {
          v4 = 0x400000LL;
          if ( !(result >> 25) )
            v4 = 0x100000LL;
        }
        else
        {
          v4 = 0x40000LL;
        }
      }
      else
      {
        v4 = 0x10000LL;
      }
    }
    else
    {
      v4 = qword_6CAF998;
    }
    if ( ~v4 <= result )
    {
      v10[0] = 0;
    }
    else
    {
      v5 = result + v4 - 1;
      if ( (v4 & (v4 - 1)) != 0 )
      {
        v3 = v5 / v4 * v4;
        v10[0] = 0;
        if ( !v3 )
          return 0LL;
      }
      else
      {
        v3 = v5 & -(__int64)v4;
        v10[0] = 0;
        if ( !v3 )
          return 0LL;
      }
    }
    v9[0] = 0;
    v11 = 0LL;
    v6 = sub_6800A8C(v3, 1LL, 1LL, 0LL, v10, v9, &v11);
    if ( v6 )
      sub_67F8944(
        (signed __int64)"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, align: 0x%zx, commit: %d, allow large: %d)\n",
        v6,
        v6,
        v3,
        1uLL,
        1,
        0);
    if ( !v11 )
      return 0LL;
    sub_67FF620((unsigned __int64)&unk_7304F40, v3);
    sub_67FF620((unsigned __int64)&unk_7304F60, v3);
    result = v11;
    if ( v11 )
    {
      v7 = v10[0];
      v8 = v9[0];
      *(_QWORD *)a2 = 0LL;
      *(_QWORD *)(a2 + 8) = 0LL;
      *(_BYTE *)(a2 + 19) = 0;
      *(_BYTE *)(a2 + 16) = v7;
      *(_BYTE *)(a2 + 17) = 1;
      *(_BYTE *)(a2 + 18) = v8;
      *(_DWORD *)(a2 + 20) = 3;
    }
  }
  return result;
}


================================================================================
Function: sub_67F94D8 (0x67F94D8)
================================================================================

const void *__fastcall sub_67F94D8(unsigned __int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4, __int64 a5)
{
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  const void *v9; // x23
  unsigned __int64 v10; // x11
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x12
  __int64 v13; // x11
  __int64 v14; // x12
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x21
  uint8x8_t v17; // d0
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x22
  __int64 v20; // x23
  int v21; // w24
  unsigned int v22; // w25
  int v23; // w0
  int v24; // w0
  int v25; // w0
  __int64 v26; // x3
  unsigned __int64 v27; // x27
  unsigned __int64 v28; // x8
  char v29; // w8
  char v30; // w10
  int v31; // w0
  const void *v32; // x25
  unsigned __int64 v33; // x24
  unsigned __int64 v34; // x9
  __int64 v35; // x9
  unsigned __int64 v37; // x22
  __int64 v38; // x23
  int v39; // w0
  const void *v40; // x23
  int v41; // w0
  _BYTE v42[4]; // [xsp+8h] [xbp-18h] BYREF
  _BYTE v43[4]; // [xsp+Ch] [xbp-14h] BYREF
  unsigned __int64 v44; // [xsp+10h] [xbp-10h] BYREF

  *(_QWORD *)a5 = 0LL;
  *(_QWORD *)(a5 + 8) = 0LL;
  *(_QWORD *)(a5 + 16) = 0LL;
  if ( !a1 )
    return 0LL;
  if ( a1 >> 19 )
  {
    if ( a1 >= 0x200000 )
    {
      if ( a1 >= 0x800000 )
      {
        v7 = 0x400000LL;
        if ( !(a1 >> 25) )
          v7 = 0x100000LL;
      }
      else
      {
        v7 = 0x40000LL;
      }
    }
    else
    {
      v7 = 0x10000LL;
    }
  }
  else
  {
    v7 = qword_6CAF998;
  }
  if ( ~v7 > a1 )
  {
    v8 = a1 + v7 - 1;
    if ( (v7 & (v7 - 1)) != 0 )
      a1 = v8 / v7 * v7;
    else
      a1 = v8 & -(__int64)v7;
  }
  v9 = 0LL;
  v43[0] = 0;
  v10 = qword_6CAF998 - 1 + a2;
  v11.n64_u64[0] = vcnt_s8((int8x8_t)qword_6CAF998).n64_u64[0];
  v12 = v10 / qword_6CAF998;
  v13 = v10 & -qword_6CAF998;
  v11.n64_u16[0] = vaddlv_u8(v11);
  v14 = v12 * qword_6CAF998;
  v15 = v11.n64_u32[0];
  if ( v11.n64_u32[0] <= 1uLL )
    v16 = v13;
  else
    v16 = v14;
  if ( qword_6CAF998 <= v16 )
  {
    v17.n64_u64[0] = vcnt_s8((int8x8_t)v16).n64_u64[0];
    v17.n64_u16[0] = vaddlv_u8(v17);
    if ( v17.n64_u32[0] <= 1uLL )
    {
      v18 = qword_6CAF998 - 1 + a1;
      if ( v15 > 1 )
      {
        v19 = v18 / qword_6CAF998 * qword_6CAF998;
        if ( !v19 )
          return 0LL;
      }
      else
      {
        v19 = v18 & -qword_6CAF998;
        if ( !v19 )
          return 0LL;
      }
      if ( v16 )
        v20 = v16;
      else
        v20 = 1LL;
      v21 = a3 & 1;
      v22 = a3 & a4 & 1;
      v42[0] = 0;
      v44 = 0LL;
      v23 = sub_6800A8C(v19, v20, a3 & 1, v22, (__int64)v43, v42, (__int64 *)&v44);
      if ( v23 )
        sub_67F8944(
          (signed __int64)"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, align: 0x%zx, commit: %d, a"
                          "llow large: %d)\n",
          v23,
          v23,
          v19,
          v20,
          v21,
          v22);
      if ( !v44 )
        return 0LL;
      sub_67FF620((unsigned __int64)&unk_7304F40, v19);
      if ( (a3 & 1) != 0 )
        sub_67FF620((unsigned __int64)&unk_7304F60, v19);
      v9 = (const void *)v44;
      if ( v44 )
      {
        if ( !(v44 % v16) )
        {
          v27 = v44;
LABEL_47:
          v29 = v43[0];
          v30 = v42[0];
          *(_BYTE *)(a5 + 19) = 0;
          *(_BYTE *)(a5 + 16) = v29;
          *(_BYTE *)(a5 + 17) = a3 & 1;
          *(_BYTE *)(a5 + 18) = v30;
          *(_DWORD *)(a5 + 20) = 3;
          *(_QWORD *)a5 = v27;
          *(_QWORD *)(a5 + 8) = v16;
          return v9;
        }
        sub_67F8944(
          (signed __int64)"unable to allocate aligned OS memory directly, fall back to over-allocation (size: 0x%zx bytes"
                          ", address: %p, alignment: 0x%zx, commit: %d)\n",
          v19,
          (const void *)v44,
          v16,
          a3 & 1);
        v24 = sub_6800A5C(v9, v19);
        if ( v24 )
          sub_67F8944(
            (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
            v24,
            v24,
            v19,
            v9);
        if ( (a3 & 1) != 0 )
          sub_67FF704((unsigned __int64)&unk_7304F60, v19);
        sub_67FF704((unsigned __int64)&unk_7304F40, v19);
        if ( v19 >= ~v16 )
          return 0LL;
        v9 = (const void *)(v19 + v16);
        if ( !byte_6CAF9B1 )
        {
          if ( !v9 )
            return v9;
          v42[0] = 0;
          v44 = 0LL;
          v31 = sub_6800A8C(v19 + v16, 1LL, a3 & 1, 0, (__int64)v43, v42, (__int64 *)&v44);
          if ( v31 )
            sub_67F8944(
              (signed __int64)"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, align: 0x%zx, commit: %"
                              "d, allow large: %d)\n",
              v31,
              v31,
              v19 + v16,
              1uLL,
              a3 & 1,
              0);
          if ( !v44 )
            return 0LL;
          sub_67FF620((unsigned __int64)&unk_7304F40, v19 + v16);
          if ( (a3 & 1) != 0 )
            sub_67FF620((unsigned __int64)&unk_7304F60, v19 + v16);
          v32 = (const void *)v44;
          if ( !v44 )
            return 0LL;
          v27 = (v16 + v44 - 1) & -(__int64)v16;
          v33 = v27 - v44;
          v34 = v19 + qword_6CAF998 - 1;
          if ( (qword_6CAF998 & (qword_6CAF998 - 1)) != 0 )
            v35 = v34 / qword_6CAF998 * qword_6CAF998;
          else
            v35 = v34 & -qword_6CAF998;
          v37 = (unsigned __int64)v9 - v33 - v35;
          if ( v33 )
          {
            v38 = v35;
            v39 = sub_6800A5C(v44, v27 - v44);
            if ( v39 )
              sub_67F8944(
                (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
                v39,
                v39,
                v27 - (_QWORD)v32,
                v32);
            if ( (a3 & 1) != 0 )
              sub_67FF704((unsigned __int64)&unk_7304F60, v27 - (_QWORD)v32);
            sub_67FF704((unsigned __int64)&unk_7304F40, v27 - (_QWORD)v32);
            v35 = v38;
          }
          if ( v37 && v27 )
          {
            v40 = (const void *)(v27 + v35);
            v41 = sub_6800A5C(v27 + v35, v37);
            if ( v41 )
              sub_67F8944(
                (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
                v41,
                v41,
                v37,
                v40);
            if ( (a3 & 1) != 0 )
              sub_67FF704((unsigned __int64)&unk_7304F60, v37);
            sub_67FF704((unsigned __int64)&unk_7304F40, v37);
          }
          v9 = (const void *)(((unsigned __int64)v32 + v16 - 1) & -(__int64)v16);
          goto LABEL_74;
        }
        if ( v9 )
        {
          v42[0] = 0;
          v44 = 0LL;
          v25 = sub_6800A8C(v19 + v16, 1LL, 0, 0, (__int64)v43, v42, (__int64 *)&v44);
          if ( v25 )
            sub_67F8944(
              (signed __int64)"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, align: 0x%zx, commit: %"
                              "d, allow large: %d)\n",
              v25,
              v25,
              v19 + v16,
              1uLL,
              0,
              0);
          if ( !v44 )
            return 0LL;
          sub_67FF620((unsigned __int64)&unk_7304F40, v19 + v16);
          v27 = v44;
          if ( !v44 )
            return 0LL;
          v28 = v16 + v44 - 1;
          v9 = (const void *)(v28 & -(__int64)v16);
          if ( (a3 & 1) != 0 )
            sub_67F9B68(v28 & -(__int64)v16, v19, 0LL, v26);
LABEL_74:
          if ( !v9 )
            return v9;
          goto LABEL_47;
        }
      }
    }
  }
  return v9;
}


================================================================================
Function: sub_67F99C4 (0x67F99C4)
================================================================================

const void *__fastcall sub_67F99C4(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        char a4,
        char a5,
        _QWORD *a6)
{
  unsigned __int64 v6; // x19
  unsigned __int64 v9; // x8
  __int64 v10; // x8
  unsigned __int64 v11; // x21
  char *v12; // x0
  char *v13; // x22
  __int64 v14; // x8
  unsigned __int64 v15; // x9
  bool v16; // zf
  unsigned __int64 v17; // x10
  __int64 v18; // x9
  __int64 v19; // x10
  __int64 v20; // x8
  const void *v21; // x20
  __int64 v22; // x21
  int v23; // w0
  char v24[4]; // [xsp+4h] [xbp-Ch] BYREF

  v6 = 0LL;
  *a6 = 0LL;
  a6[1] = 0LL;
  a6[2] = 0LL;
  if ( a3 > 0x2000000 )
    return (const void *)v6;
  if ( a3 )
  {
    v9 = a2 - 1 + a3;
    if ( (a2 & (a2 - 1)) != 0 )
      v10 = v9 / a2 * a2;
    else
      v10 = v9 & -(__int64)a2;
    v11 = v10 - a3;
    v12 = (char *)sub_67F94D8(v10 - a3 + a1, a2, a4 & 1, a5 & 1, (__int64)a6);
    if ( !v12 )
      return 0LL;
    v13 = v12;
    v6 = (unsigned __int64)&v12[v11];
    if ( (a4 & 1) != 0 && v11 > qword_6CAF998 )
    {
      sub_67FF704((unsigned __int64)&unk_7304F60, v11);
      v14 = qword_6CAF998;
      v15 = (unsigned __int64)&v13[qword_6CAF998 - 1];
      v16 = (v14 & (v14 - 1)) == 0;
      v17 = v15 / qword_6CAF998;
      v18 = v15 & -qword_6CAF998;
      v19 = v17 * qword_6CAF998;
      if ( (v14 & (v14 - 1)) != 0 )
        v20 = v6 / qword_6CAF998 * qword_6CAF998;
      else
        v20 = -qword_6CAF998 & v6;
      if ( v16 )
        v21 = (const void *)v18;
      else
        v21 = (const void *)v19;
      v22 = v20 - (_QWORD)v21;
      if ( v20 - (__int64)v21 >= 1 )
      {
        v24[0] = 1;
        v23 = sub_6800D00(v21, v22, v24);
        if ( v23 )
          sub_67F8944(
            (signed __int64)"cannot decommit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\n",
            v23,
            v23,
            v21,
            v22);
      }
    }
    return (const void *)v6;
  }
  return sub_67F94D8(a1, a2, a4 & 1, a5 & 1, (__int64)a6);
}


================================================================================
Function: sub_67F9B68 (0x67F9B68)
================================================================================

bool __fastcall sub_67F9B68(unsigned __int64 a1, signed __int64 a2, _BYTE *a3)
{
  _BOOL4 v6; // w20
  __int64 v7; // x9
  __int64 v8; // x21
  __int64 v9; // x8
  unsigned __int64 v10; // x10
  __int64 v11; // x22
  int v12; // w0
  _BYTE v14[4]; // [xsp+4h] [xbp-Ch] BYREF

  if ( a3 )
    *a3 = 0;
  sub_67FF620((unsigned __int64)&unk_7304F60, a2);
  v6 = 1;
  sub_67FF5B4((unsigned __int64)&unk_7305100, 1uLL);
  if ( a1 && a2 )
  {
    if ( (qword_6CAF998 & (qword_6CAF998 - 1)) != 0 )
    {
      v10 = qword_6CAF998 + a1 + a2 - 1;
      v8 = a1 / qword_6CAF998 * qword_6CAF998;
      v9 = v10 / qword_6CAF998 * qword_6CAF998;
    }
    else
    {
      v7 = qword_6CAF998 + a1 + a2 - 1;
      v8 = -qword_6CAF998 & a1;
      v9 = v7 & -qword_6CAF998;
    }
    v11 = v9 - v8;
    if ( v9 - v8 < 1 )
    {
      return 1;
    }
    else
    {
      v14[0] = 0;
      v12 = sub_6800CD8(v8, v9 - v8, v14);
      v6 = v12 == 0;
      if ( v12 )
      {
        sub_67F8944(
          (signed __int64)"cannot commit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\n",
          v12,
          v12,
          (const void *)v8,
          v11);
      }
      else if ( a3 && v14[0] )
      {
        *a3 = 1;
      }
    }
  }
  return v6;
}


================================================================================
Function: sub_67F9CB4 (0x67F9CB4)
================================================================================

__int64 __fastcall sub_67F9CB4(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // w22
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x10
  __int64 v6; // x9
  __int64 v7; // x10
  __int64 v8; // x8
  const void *v9; // x20
  __int64 v10; // x21
  int v12; // w0

  v3 = 1;
  if ( a1 && a2 )
  {
    v4 = a1 + qword_6CAF998 - 1;
    v5 = v4 / qword_6CAF998;
    v6 = v4 & -qword_6CAF998;
    v7 = v5 * qword_6CAF998;
    if ( (qword_6CAF998 & (qword_6CAF998 - 1)) != 0 )
      v8 = (a1 + a2) / (unsigned __int64)qword_6CAF998 * qword_6CAF998;
    else
      v8 = -qword_6CAF998 & (a1 + a2);
    if ( (qword_6CAF998 & (qword_6CAF998 - 1)) != 0 )
      v9 = (const void *)v7;
    else
      v9 = (const void *)v6;
    v10 = v8 - (_QWORD)v9;
    if ( v8 - (__int64)v9 < 1 )
    {
      return 1;
    }
    else
    {
      sub_67FF620(a3 + 128, v8 - (_QWORD)v9);
      v3 = 1;
      sub_67FF5B4(a3 + 528, 1LL);
      v12 = sub_6800D28(v9, v10);
      if ( v12 )
      {
        sub_67F8944(
          (signed __int64)"cannot reset OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\n",
          v12,
          v12,
          v9,
          v10);
        return 0;
      }
    }
  }
  return v3;
}


================================================================================
Function: sub_67F9D88 (0x67F9D88)
================================================================================

bool __fastcall sub_67F9D88(__int64 a1, unsigned __int64 a2, char a3, __int64 a4)
{
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x10
  __int64 v11; // x19
  __int64 v12; // x8
  __int64 v13; // x20
  int v14; // w0
  char v15[4]; // [xsp+4h] [xbp-Ch] BYREF

  if ( sub_67F7E08(0xFu) < 0 )
    return 0LL;
  sub_67FF5B4(a4 + 544, 1uLL);
  sub_67FF620(a4 + 160, a2);
  if ( !sub_67F8510(5u) || sub_67F7B2C() )
  {
    if ( (a3 & 1) != 0 )
      sub_67F9CB4(a1, a2, a4);
    return 0LL;
  }
  v15[0] = 1;
  sub_67FF704((unsigned __int64)&unk_7304F60, a2);
  if ( a1 && a2 )
  {
    v9 = a1 + qword_6CAF998 - 1;
    v10 = a1 + a2;
    if ( (qword_6CAF998 & (qword_6CAF998 - 1)) != 0 )
    {
      v11 = v9 / qword_6CAF998 * qword_6CAF998;
      v12 = v10 / qword_6CAF998 * qword_6CAF998;
    }
    else
    {
      v11 = v9 & -qword_6CAF998;
      v12 = -qword_6CAF998 & v10;
    }
    v13 = v12 - v11;
    if ( v12 - v11 >= 1 )
    {
      v15[0] = 1;
      v14 = sub_6800D00(v11, v13, v15);
      if ( v14 )
        sub_67F8944(
          (signed __int64)"cannot decommit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\n",
          v14,
          v14,
          (const void *)v11,
          v13);
    }
  }
  return v15[0] != 0;
}


================================================================================
Function: sub_67F9EF8 (0x67F9EF8)
================================================================================

bool __fastcall sub_67F9EF8(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  return sub_67F9D88(a1, a2, 1, a3);
}


================================================================================
Function: sub_67F9F04 (0x67F9F04)
================================================================================

unsigned __int64 __fastcall sub_67F9F04(__int64 a1, unsigned int a2, __int64 a3, _QWORD *a4, _QWORD *a5, __int64 a6)
{
  unsigned __int64 v8; // x26
  void *v9; // x0
  unsigned __int64 v10; // x22
  unsigned __int64 v11; // x0
  bool v12; // zf
  __int64 v13; // x0
  __int64 v14; // x28
  __int64 v15; // x26
  char v16; // w20
  char *v17; // x27
  int v18; // w0
  unsigned __int64 v19; // x0
  __int64 v20; // x8
  _QWORD *v21; // x19
  _QWORD *v22; // x24
  char *v23; // x23
  int v24; // w0
  char *v30; // [xsp+28h] [xbp-18h] BYREF
  char v31[4]; // [xsp+34h] [xbp-Ch] BYREF

  *(_QWORD *)a6 = 0LL;
  *(_QWORD *)(a6 + 8) = 0LL;
  *(_QWORD *)(a6 + 16) = 0LL;
  if ( a5 )
    *a5 = 0LL;
  if ( a4 )
    *a4 = 0LL;
  v8 = qword_730D2C0;
  do
  {
    v10 = v8;
    if ( !v8 )
    {
      if ( dword_6CAF9C0 == -1 )
        v9 = sub_67F6ED0();
      else
        v9 = pthread_getspecific(dword_6CAF9C0);
      if ( !v9 )
        v9 = &unk_6C58500;
      v10 = ((((unsigned __int64)sub_67F4CE8((__int64)v9) >> 17) & 0xFFF) << 30) | 0x200000000000LL;
    }
    v11 = sub_6867020(v8, v10 + (a1 << 30), (atomic_ullong *)&qword_730D2C0);
    v12 = v11 == v8;
    v8 = v11;
  }
  while ( !v12 );
  v13 = sub_67FF87C();
  if ( a1 )
  {
    v14 = v13;
    v15 = 0LL;
    v16 = 1;
    v17 = (char *)v10;
    while ( 1 )
    {
      v31[0] = 0;
      v30 = 0LL;
      v18 = sub_6800DF0(v17, 0x40000000LL, a2, v31, &v30);
      v16 &= v31[0] != 0;
      if ( v18 )
        break;
      if ( v17 != v30 )
      {
        if ( v30 )
        {
          sub_67F8944((signed __int64)"could not allocate contiguous huge OS page %zu at %p\n", v15, v17);
          v23 = v30;
          v21 = a5;
          if ( v30 )
          {
            v24 = sub_6800A5C(v30, 0x40000000LL);
            v22 = a4;
            if ( v24 )
              sub_67F8944(
                (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
                v24,
                v24,
                0x40000000uLL,
                v23);
            sub_67FF704((unsigned __int64)&unk_7304F60, 0x40000000uLL);
            sub_67FF704((unsigned __int64)&unk_7304F40, 0x40000000uLL);
            a1 = v15;
            goto LABEL_35;
          }
LABEL_28:
          v22 = a4;
          a1 = v15;
          goto LABEL_35;
        }
LABEL_27:
        v21 = a5;
        goto LABEL_28;
      }
      sub_67FF620((unsigned __int64)&unk_7304F60, 0x40000000LL);
      sub_67FF620((unsigned __int64)&unk_7304F40, 0x40000000LL);
      if ( a3 >= 1 )
      {
        v19 = sub_6800368(v14);
        v20 = (__int64)(v19 / (v15 + 2) * a1) <= 2 * a3 ? v19 : a3 + 1;
        if ( v20 > a3 )
        {
          sub_67F8944((signed __int64)"huge OS page allocation timed out (after allocating %zu page(s))\n", ++v15);
          goto LABEL_27;
        }
      }
      ++v15;
      v17 += 0x40000000;
      if ( a1 == v15 )
        goto LABEL_34;
    }
    sub_67F8944(
      (signed __int64)"unable to allocate huge OS page (error: %d (0x%x), address: %p, size: %zx bytes)\n",
      v18,
      v18,
      v17,
      0x40000000uLL);
    goto LABEL_27;
  }
  v16 = 1;
LABEL_34:
  v22 = a4;
  v21 = a5;
LABEL_35:
  if ( v22 )
    *v22 = a1;
  if ( v21 )
    *v21 = a1 << 30;
  if ( !a1 )
    return 0LL;
  *(_QWORD *)a6 = 0LL;
  *(_QWORD *)(a6 + 8) = 0LL;
  *(_BYTE *)(a6 + 18) = v16;
  *(_WORD *)(a6 + 16) = 257;
  *(_BYTE *)(a6 + 19) = 0;
  *(_DWORD *)(a6 + 20) = 4;
  return v10;
}


================================================================================
Function: sub_67FA1F8 (0x67FA1F8)
================================================================================

signed __int64 sub_67FA1F8()
{
  signed __int64 v0; // x19
  __int64 v1; // x0

  v0 = atomic_load((unsigned __int64 *)&qword_730D288);
  if ( !v0 )
  {
    v0 = sub_67F7E08(0x10u);
    if ( v0 <= 0 )
    {
      v1 = sub_6800EE4();
      if ( v1 )
        v0 = v1;
      else
        v0 = 1LL;
    }
    atomic_store(v0, (unsigned __int64 *)&qword_730D288);
    sub_67F7E58((__int64)"using %zd numa regions\n", v0);
  }
  return v0;
}


================================================================================
Function: sub_67FA258 (0x67FA258)
================================================================================

unsigned __int64 sub_67FA258()
{
  unsigned __int64 v0; // x19
  unsigned __int64 result; // x0
  __int64 v2; // x0
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v5; // x3
  __int64 v6; // x0

  v0 = qword_730D288;
  if ( !qword_730D288 )
  {
    v0 = atomic_load((unsigned __int64 *)&qword_730D288);
    if ( !v0 )
    {
      v2 = sub_67F7E08(0x10u);
      v0 = v2;
      if ( v2 <= 0 )
      {
        v6 = sub_6800EE4(v2, v3, v4, v5);
        if ( v6 )
          v0 = v6;
        else
          v0 = 1LL;
      }
      atomic_store(v0, (unsigned __int64 *)&qword_730D288);
      sub_67F7E58((__int64)"using %zd numa regions\n", v0);
    }
  }
  if ( v0 < 2 )
    return 0LL;
  result = sub_6800EDC();
  if ( result >= v0 )
    result %= v0;
  return result;
}


================================================================================
Function: sub_67FA514 (0x67FA514)
================================================================================

__int64 __fastcall sub_67FA514(__int64 a1, unsigned int a2, char a3)
{
  __int64 result; // x0
  char v7; // w21

  result = sub_67FA564(a1, a2, a3);
  if ( (result & 1) == 0 )
  {
    v7 = a3 & 1;
    do
    {
      __wfe();
      result = sub_67FA564(a1, a2, v7);
    }
    while ( (result & 1) == 0 );
  }
  return result;
}


================================================================================
Function: sub_67FA564 (0x67FA564)
================================================================================

__int64 __fastcall sub_67FA564(__int64 a1, unsigned int a2, char a3)
{
  __int64 v5; // x22
  unsigned __int8 v6; // w23
  unsigned __int64 v7; // x21
  int v8; // w8
  __int64 result; // x0
  unsigned __int64 v10; // x21
  int v11; // w8
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x21
  int v14; // w8
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x21
  int v17; // w8
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x21
  int v20; // w8
  unsigned __int64 v21; // x8

  v5 = a2;
  v6 = a3 ^ 1;
  while ( 1 )
  {
    v7 = atomic_load((unsigned __int64 *)(a1 + 40));
    v8 = v7 & 3;
    if ( v8 == 1 )
      break;
    if ( v8 == a2
      || (v6 & (v8 == 3)) != 0
      || sub_6866FE0(v7, v7 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40)) == v7 )
    {
      return 1LL;
    }
  }
  __wfe();
  while ( 1 )
  {
    v10 = atomic_load((unsigned __int64 *)(a1 + 40));
    v11 = v10 & 3;
    if ( v11 == 1 )
      break;
    if ( v11 == a2 || (v6 & (v11 == 3)) != 0 )
      return 1LL;
    v12 = sub_6866FE0(v10, v10 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40));
    result = 1LL;
    if ( v12 == v10 )
      return result;
  }
  __wfe();
  while ( 1 )
  {
    v13 = atomic_load((unsigned __int64 *)(a1 + 40));
    v14 = v13 & 3;
    if ( v14 == 1 )
      break;
    if ( v14 == a2 || (v6 & (v14 == 3)) != 0 )
      return 1LL;
    v15 = sub_6866FE0(v13, v13 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40));
    result = 1LL;
    if ( v15 == v13 )
      return result;
  }
  __wfe();
  while ( 1 )
  {
    v16 = atomic_load((unsigned __int64 *)(a1 + 40));
    v17 = v16 & 3;
    if ( v17 == 1 )
      break;
    if ( v17 == a2 || (v6 & (v17 == 3)) != 0 )
      return 1LL;
    v18 = sub_6866FE0(v16, v16 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40));
    result = 1LL;
    if ( v18 == v16 )
      return result;
  }
  __wfe();
  while ( 1 )
  {
    v19 = atomic_load((unsigned __int64 *)(a1 + 40));
    v20 = v19 & 3;
    if ( v20 == 1 )
      break;
    if ( v20 == a2 || (v6 & (v20 == 3)) != 0 )
      return 1LL;
    v21 = sub_6866FE0(v19, v19 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40));
    result = 1LL;
    if ( v21 == v19 )
      return result;
  }
  return 0LL;
}


================================================================================
Function: sub_67FA750 (0x67FA750)
================================================================================

unsigned __int64 __fastcall sub_67FA750(unsigned __int64 result, char a2)
{
  unsigned __int64 v3; // x19
  unsigned __int64 v4; // x21
  __int64 v5; // x2
  __int64 v6; // x3
  __int64 v7; // x4
  __int64 v8; // x5
  __int64 v9; // x6
  __int64 v10; // x7
  _QWORD **v11; // x8
  _QWORD *v12; // x12
  unsigned int v13; // w10
  unsigned int v14; // w9
  _QWORD *v15; // x11
  unsigned int v16; // w13
  _QWORD *v18; // x8
  __int64 v19; // x9
  char v20; // w9
  int v21; // w9
  __int64 v22; // x12
  _QWORD *v23; // x11
  _QWORD *v24; // x10
  __int64 v25; // [xsp+0h] [xbp+0h]

  v3 = result;
  if ( (a2 & 1) != 0 || *(_QWORD *)(result + 40) >= 4uLL )
  {
    result = *(_QWORD *)(result + 40);
    do
    {
      v4 = result;
      result = sub_6867020(result, result & 3, (atomic_ullong *)(v3 + 40));
    }
    while ( result != v4 );
    v11 = (_QWORD **)(v4 & 0xFFFFFFFFFFFFFFFCLL);
    if ( (v4 & 0xFFFFFFFFFFFFFFFCLL) != 0 )
    {
      v12 = *v11;
      v13 = 1;
      v14 = *(unsigned __int16 *)(v3 + 10);
      v15 = (_QWORD *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
      if ( *v11 && *(_WORD *)(v3 + 10) )
      {
        v16 = 1;
        do
        {
          v15 = v12;
          v12 = (_QWORD *)*v12;
          v13 = v16 + 1;
          if ( !v12 )
            break;
        }
        while ( v16++ < v14 );
      }
      if ( v13 <= v14 )
      {
        v21 = *(_DWORD *)(v3 + 24);
        v22 = *(_QWORD *)(v3 + 32);
        *(_QWORD *)(v3 + 32) = v11;
        *v15 = v22;
        *(_DWORD *)(v3 + 24) = v21 - v13;
        v18 = *(_QWORD **)(v3 + 32);
        if ( !v18 )
          return result;
        goto LABEL_15;
      }
      result = sub_67F8A74(14LL, "corrupted thread-free list\n", v5, v6, v7, v8, v9, v10, v25);
    }
  }
  v18 = *(_QWORD **)(v3 + 32);
  if ( !v18 )
    return result;
LABEL_15:
  v19 = *(_QWORD *)(v3 + 16);
  if ( !v19 )
  {
LABEL_16:
    v20 = *(_BYTE *)(v3 + 15);
    *(_QWORD *)(v3 + 16) = v18;
    *(_QWORD *)(v3 + 32) = 0LL;
    *(_BYTE *)(v3 + 15) = v20 & 0xFE;
    return result;
  }
  if ( (a2 & 1) != 0 )
  {
    v23 = v18;
    do
    {
      v24 = v23;
      v23 = (_QWORD *)*v23;
    }
    while ( v23 );
    *v24 = v19;
    goto LABEL_16;
  }
  return result;
}


================================================================================
Function: sub_67FA860 (0x67FA860)
================================================================================

__int64 __fastcall sub_67FA860(__int64 a1, unsigned int *a2)
{
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  unsigned __int8 v7; // w9
  __int64 v9; // [xsp+0h] [xbp-10h] BYREF

  v4 = a2[7];
  if ( (v4 & 0x80000000) != 0 )
  {
    sub_67FC8B4(((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL, a2, &v9);
    v4 = v9;
  }
  v5 = v4 + 7;
  if ( (unsigned __int64)(v4 + 7) >= 0x10 )
  {
    v6 = v5 >> 3;
    if ( v5 > 0x47 )
    {
      if ( v5 <= 0x20007 )
      {
        v7 = 63 - __clz(--v6);
        LODWORD(v6) = ((v6 >> (v7 - 2)) & 3 | (4 * v7)) + 253;
      }
      else
      {
        LOBYTE(v6) = 73;
      }
    }
    else
    {
      LOBYTE(v6) = (v6 + 1) & 0xFE;
    }
  }
  else
  {
    LOBYTE(v6) = 1;
  }
  return sub_67FA960(a1, (unsigned __int64 *)(a1 + 24LL * (unsigned __int8)v6 + 1040), (unsigned __int64)a2);
}


================================================================================
Function: sub_67FA960 (0x67FA960)
================================================================================

__int64 __fastcall sub_67FA960(__int64 result, unsigned __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 *v3; // x11
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x12
  int v7; // w12
  unsigned __int8 v8; // w11
  unsigned __int64 v9; // x11
  unsigned __int64 v10; // x15
  unsigned __int64 v11; // x14
  int v12; // w15
  unsigned __int8 v13; // w16
  bool v14; // cc
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x9
  int64x2_t v17; // q0
  int64x2_t *v18; // x12
  unsigned __int64 v19; // x13
  __int64 v20; // x8
  unsigned __int64 *v21; // x9

  *(_BYTE *)(a3 + 14) = *(_BYTE *)(a3 + 14) & 0xFE | (a2[2] == 131088);
  v3 = (unsigned __int64 *)(*a2 + 64);
  if ( !*a2 )
    v3 = a2 + 1;
  v4 = a2[2];
  *(_QWORD *)(a3 + 56) = *a2;
  *(_QWORD *)(a3 + 64) = 0LL;
  *v3 = a3;
  *a2 = a3;
  if ( v4 <= 0x400 )
  {
    v5 = (v4 + 7) >> 3;
    if ( *(_QWORD *)(result + 8 * v5 + 8) != a3 )
    {
      if ( v4 >= 9 )
      {
        if ( v4 > 0x40 )
        {
          v8 = 63 - __clz(v5 - 1);
          v7 = (((v5 - 1) >> (v8 - 2)) & 3 | (4 * v8)) - 3;
        }
        else
        {
          LOBYTE(v7) = (v5 + 1) & 0xFE;
        }
        v9 = (unsigned __int64)(a2 - 3);
        do
        {
          v10 = *(_QWORD *)(v9 + 16) + 7LL;
          v11 = v10 >> 3;
          if ( v10 >= 0x10 )
          {
            if ( v10 > 0x47 )
            {
              if ( v10 <= 0x20007 )
              {
                v13 = 63 - __clz(v11 - 1);
                v12 = (((v11 - 1) >> (v13 - 2)) & 3 | (4 * v13)) - 3;
              }
              else
              {
                LOBYTE(v12) = 73;
              }
            }
            else
            {
              LOBYTE(v12) = (v11 + 1) & 0xFE;
            }
          }
          else
          {
            LOBYTE(v12) = 1;
          }
          if ( (unsigned __int8)v7 != (unsigned __int8)v12 )
            break;
          v14 = v9 > result + 1040;
          v9 -= 24LL;
        }
        while ( v14 );
        if ( v11 + 1 <= v5 )
          v6 = v11 + 1;
        else
          v6 = (v4 + 7) >> 3;
      }
      else
      {
        v6 = 0LL;
      }
      v15 = v5 - v6 + 1;
      if ( v15 < 4 )
      {
        v16 = v6;
LABEL_28:
        v20 = v5 - v16 + 1;
        v21 = (unsigned __int64 *)(result + 8 * v16 + 8);
        do
        {
          --v20;
          *v21++ = a3;
        }
        while ( v20 );
        goto LABEL_30;
      }
      v17 = vdupq_n_s64(a3);
      v16 = v6 + (v15 & 0xFFFFFFFFFFFFFFFCLL);
      v18 = (int64x2_t *)(result + 8 * v6 + 24);
      v19 = v15 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v18[-1] = v17;
        *v18 = v17;
        v19 -= 4LL;
        v18 += 2;
      }
      while ( v19 );
      if ( v15 != (v15 & 0xFFFFFFFFFFFFFFFCLL) )
        goto LABEL_28;
    }
  }
LABEL_30:
  ++*(_QWORD *)(result + 3024);
  return result;
}


================================================================================
Function: sub_67FAB24 (0x67FAB24)
================================================================================

unsigned __int64 __fastcall sub_67FAB24(unsigned __int64 result)
{
  _QWORD *v1; // x20
  unsigned __int64 v2; // x19
  _BOOL4 v3; // w8
  bool v4; // zf
  char v5; // w21
  _QWORD *v6; // x22
  unsigned __int64 v7; // x21

  v1 = *(_QWORD **)(result + 2840);
  if ( v1 )
  {
    v2 = result;
    do
    {
      do
      {
        result = sub_6867020((unsigned __int64)v1, 0LL, (atomic_ullong *)(v2 + 2840));
        v3 = result == (_QWORD)v1;
        if ( (_QWORD *)result != v1 )
          v1 = (_QWORD *)result;
        v4 = v3 || v1 == 0LL;
      }
      while ( !v4 );
      if ( !v1 )
        break;
      v5 = 1;
      do
      {
        while ( 1 )
        {
          v6 = (_QWORD *)*v1;
          result = sub_67F4024(v1);
          if ( (result & 1) != 0 )
            break;
          v7 = *(_QWORD *)(v2 + 2840);
          do
          {
            *v1 = v7;
            result = sub_6866FE0(v7, (unsigned __int64)v1, (atomic_ullong *)(v2 + 2840));
            v4 = result == v7;
            v7 = result;
          }
          while ( !v4 );
          v5 = 0;
          v1 = v6;
          if ( !v6 )
            goto LABEL_21;
        }
        v1 = v6;
      }
      while ( v6 );
      if ( (v5 & 1) != 0 )
        return result;
LABEL_21:
      __wfe();
      v1 = *(_QWORD **)(v2 + 2840);
    }
    while ( v1 );
  }
  return result;
}


================================================================================
Function: sub_67FAC8C (0x67FAC8C)
================================================================================

__int64 __fastcall sub_67FAC8C(__int64 result)
{
  __int64 v1; // x9
  __int64 v2; // x10
  int v3; // w10
  unsigned __int64 v4; // x11
  unsigned __int64 v5; // x10
  unsigned __int8 v6; // w11

  if ( (*(_BYTE *)(result + 14) & 1) != 0 )
  {
    v1 = *(_QWORD *)(result + 48);
    v2 = *(unsigned int *)(result + 28);
    if ( (unsigned int)v2 >= 9 )
    {
      v4 = (unsigned __int64)(v2 + 7) >> 3;
      if ( (unsigned int)v2 > 0x40 )
      {
        if ( (unsigned int)v2 <= 0x20000 )
        {
          v5 = v4 - 1;
          v6 = 63 - __clz(v4 - 1);
          v3 = ((v5 >> (v6 - 2)) & 3 | (4 * v6)) + 253;
        }
        else
        {
          LOBYTE(v3) = 73;
        }
      }
      else
      {
        LOBYTE(v3) = (v4 + 1) & 0xFE;
      }
    }
    else
    {
      LOBYTE(v3) = 1;
    }
    *(_BYTE *)(result + 14) |= 1u;
    return sub_67FAD28(v1 + 24LL * (unsigned __int8)v3 + 1040, v1 + 2816, result);
  }
  return result;
}


================================================================================
Function: sub_67FAD28 (0x67FAD28)
================================================================================

unsigned __int64 *__fastcall sub_67FAD28(unsigned __int64 *result, _QWORD *a2, unsigned __int64 a3)
{
  __int64 v3; // x9
  __int64 v4; // x8
  _QWORD *v5; // x10
  unsigned __int64 v6; // x12
  unsigned __int64 v7; // x11
  unsigned __int64 v8; // x15
  int v9; // w14
  unsigned __int8 v10; // w13
  unsigned __int64 v11; // x13
  unsigned __int64 v12; // x17
  unsigned __int64 v13; // x16
  int v14; // w17
  unsigned __int8 v15; // w1
  bool v16; // cc
  unsigned __int64 v17; // x13
  unsigned __int64 v18; // x12
  int64x2_t v19; // q0
  int64x2_t *v20; // x15
  unsigned __int64 v21; // x16
  __int64 v22; // x11
  _QWORD *v23; // x12
  unsigned __int64 v24; // x11
  unsigned __int64 v25; // x10
  unsigned __int64 v26; // x11
  unsigned __int64 v27; // x15
  int v28; // w14
  unsigned __int8 v29; // w13
  unsigned __int64 v30; // x13
  unsigned __int64 v31; // x17
  unsigned __int64 v32; // x16
  int v33; // w17
  unsigned __int64 v34; // x13
  unsigned __int64 v35; // x12
  int64x2_t v36; // q0
  int64x2_t *v37; // x15
  unsigned __int64 v38; // x16
  unsigned __int64 v39; // x11
  __int64 v40; // x12
  unsigned __int64 v41; // x9
  unsigned __int64 *v42; // x11

  v3 = *(_QWORD *)(a3 + 48);
  v4 = *(_QWORD *)(a3 + 64);
  if ( v4 )
    *(_QWORD *)(v4 + 56) = *(_QWORD *)(a3 + 56);
  v5 = *(_QWORD **)(a3 + 56);
  if ( v5 )
    v5[8] = v4;
  if ( a2[1] == a3 )
    a2[1] = *(_QWORD *)(a3 + 64);
  if ( *a2 == a3 )
  {
    v6 = a2[2];
    *a2 = v5;
    if ( v6 <= 0x400 )
    {
      v7 = (v6 + 7) >> 3;
      if ( !v5 )
        v5 = &unk_174D0C0;
      if ( *(_QWORD **)(v3 + 8 * v7 + 8) != v5 )
      {
        if ( v6 >= 9 )
        {
          if ( v6 > 0x40 )
          {
            v10 = 63 - __clz(v7 - 1);
            v9 = (((v7 - 1) >> (v10 - 2)) & 3 | (4 * v10)) - 3;
          }
          else
          {
            LOBYTE(v9) = (v7 + 1) & 0xFE;
          }
          v11 = (unsigned __int64)(a2 - 3);
          do
          {
            v12 = *(_QWORD *)(v11 + 16) + 7LL;
            v13 = v12 >> 3;
            if ( v12 >= 0x10 )
            {
              if ( v12 > 0x47 )
              {
                if ( v12 <= 0x20007 )
                {
                  v15 = 63 - __clz(v13 - 1);
                  v14 = (((v13 - 1) >> (v15 - 2)) & 3 | (4 * v15)) - 3;
                }
                else
                {
                  LOBYTE(v14) = 73;
                }
              }
              else
              {
                LOBYTE(v14) = (v13 + 1) & 0xFE;
              }
            }
            else
            {
              LOBYTE(v14) = 1;
            }
            if ( (unsigned __int8)v9 != (unsigned __int8)v14 )
              break;
            v16 = v11 > v3 + 1040;
            v11 -= 24LL;
          }
          while ( v16 );
          if ( v13 + 1 <= v7 )
            v8 = v13 + 1;
          else
            v8 = (v6 + 7) >> 3;
        }
        else
        {
          v8 = 0LL;
        }
        v17 = v7 - v8 + 1;
        if ( v17 < 4 )
        {
          v18 = v8;
LABEL_35:
          v22 = v7 - v18 + 1;
          v23 = (_QWORD *)(v3 + 8 * v18 + 8);
          do
          {
            --v22;
            *v23++ = v5;
          }
          while ( v22 );
          goto LABEL_37;
        }
        v19 = vdupq_n_s64((unsigned __int64)v5);
        v18 = v8 + (v17 & 0xFFFFFFFFFFFFFFFCLL);
        v20 = (int64x2_t *)(v3 + 8 * v8 + 24);
        v21 = v17 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v20[-1] = v19;
          *v20 = v19;
          v21 -= 4LL;
          v20 += 2;
        }
        while ( v21 );
        if ( v17 != (v17 & 0xFFFFFFFFFFFFFFFCLL) )
          goto LABEL_35;
      }
    }
  }
LABEL_37:
  v24 = result[1];
  *(_QWORD *)(a3 + 56) = 0LL;
  *(_QWORD *)(a3 + 64) = v24;
  if ( v24 )
  {
    v25 = result[2];
    *(_QWORD *)(v24 + 56) = a3;
    result[1] = a3;
    goto LABEL_66;
  }
  v25 = result[2];
  *result = a3;
  result[1] = a3;
  if ( v25 <= 0x400 )
  {
    v26 = (v25 + 7) >> 3;
    if ( *(_QWORD *)(v3 + 8 * v26 + 8) != a3 )
    {
      if ( v25 >= 9 )
      {
        if ( v25 > 0x40 )
        {
          v29 = 63 - __clz(v26 - 1);
          v28 = (((v26 - 1) >> (v29 - 2)) & 3 | (4 * v29)) - 3;
        }
        else
        {
          LOBYTE(v28) = (v26 + 1) & 0xFE;
        }
        v30 = (unsigned __int64)(result - 3);
        do
        {
          v31 = *(_QWORD *)(v30 + 16) + 7LL;
          v32 = v31 >> 3;
          if ( v31 >= 0x10 )
          {
            if ( v31 > 0x47 )
            {
              if ( v31 <= 0x20007 )
              {
                result = (unsigned __int64 *)(unsigned __int8)(63 - __clz(v32 - 1));
                v33 = (((v32 - 1) >> ((unsigned __int8)result - 2)) & 3 | (4 * (unsigned __int8)result)) - 3;
              }
              else
              {
                LOBYTE(v33) = 73;
              }
            }
            else
            {
              LOBYTE(v33) = (v32 + 1) & 0xFE;
            }
          }
          else
          {
            LOBYTE(v33) = 1;
          }
          if ( (unsigned __int8)v28 != (unsigned __int8)v33 )
            break;
          v16 = v30 > v3 + 1040;
          v30 -= 24LL;
        }
        while ( v16 );
        if ( v32 + 1 <= v26 )
          v27 = v32 + 1;
        else
          v27 = (v25 + 7) >> 3;
      }
      else
      {
        v27 = 0LL;
      }
      v34 = v26 - v27 + 1;
      if ( v34 < 4 )
      {
        v35 = v27;
LABEL_64:
        v39 = v26 - v35;
        v40 = v3 + 8 * v35;
        v41 = v39 + 1;
        v42 = (unsigned __int64 *)(v40 + 8);
        do
        {
          --v41;
          *v42++ = a3;
        }
        while ( v41 );
        goto LABEL_66;
      }
      v36 = vdupq_n_s64(a3);
      v35 = v27 + (v34 & 0xFFFFFFFFFFFFFFFCLL);
      v37 = (int64x2_t *)(v3 + 8 * v27 + 24);
      v38 = v34 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v37[-1] = v36;
        *v37 = v36;
        v38 -= 4LL;
        v37 += 2;
      }
      while ( v38 );
      if ( v34 != (v34 & 0xFFFFFFFFFFFFFFFCLL) )
        goto LABEL_64;
    }
  }
LABEL_66:
  *(_BYTE *)(a3 + 14) = *(_BYTE *)(a3 + 14) & 0xFE | (v25 == 131088);
  return result;
}


================================================================================
Function: sub_67FB09C (0x67FB09C)
================================================================================

__int64 __fastcall sub_67FB09C(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 *v3; // x21
  __int64 v4; // x20

  v3 = (unsigned __int64 *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 48) + 32LL;
  sub_67FB0E8(a2, a1);
  atomic_store(0LL, v3);
  return sub_67FCEEC(a1, v4);
}


================================================================================
Function: sub_67FB0E8 (0x67FB0E8)
================================================================================

unsigned __int64 __fastcall sub_67FB0E8(unsigned __int64 result, __int64 a2)
{
  __int64 v2; // x8
  __int64 v3; // x11
  _QWORD *v4; // x10
  unsigned __int64 v5; // x12
  unsigned __int64 v6; // x11
  unsigned __int64 v7; // x15
  int v8; // w14
  unsigned __int8 v9; // w13
  unsigned __int64 v10; // x13
  unsigned __int64 v11; // x0
  unsigned __int64 v12; // x17
  unsigned __int8 v13; // w2
  bool v14; // cc
  unsigned __int64 v15; // x13
  unsigned __int64 v16; // x12
  int64x2_t v17; // q0
  int64x2_t *v18; // x15
  unsigned __int64 v19; // x16
  __int64 v20; // x11
  _QWORD *v21; // x12
  char v22; // w8

  v2 = *(_QWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 64);
  if ( v3 )
    *(_QWORD *)(v3 + 56) = *(_QWORD *)(a2 + 56);
  v4 = *(_QWORD **)(a2 + 56);
  if ( v4 )
    v4[8] = v3;
  if ( *(_QWORD *)(result + 8) == a2 )
    *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 64);
  if ( *(_QWORD *)result == a2 )
  {
    v5 = *(_QWORD *)(result + 16);
    *(_QWORD *)result = v4;
    if ( v5 <= 0x400 )
    {
      v6 = (v5 + 7) >> 3;
      if ( !v4 )
        v4 = &unk_174D0C0;
      if ( *(_QWORD **)(v2 + 8 * v6 + 8) != v4 )
      {
        if ( v5 >= 9 )
        {
          if ( v5 > 0x40 )
          {
            v9 = 63 - __clz(v6 - 1);
            v8 = (((v6 - 1) >> (v9 - 2)) & 3 | (4 * v9)) - 3;
          }
          else
          {
            LOBYTE(v8) = (v6 + 1) & 0xFE;
          }
          v10 = result - 24;
          do
          {
            v11 = *(_QWORD *)(v10 + 16) + 7LL;
            v12 = v11 >> 3;
            if ( v11 >= 0x10 )
            {
              if ( v11 > 0x47 )
              {
                if ( v11 <= 0x20007 )
                {
                  v13 = 63 - __clz(v12 - 1);
                  result = (((v12 - 1) >> (v13 - 2)) & 3 | (4 * (unsigned int)v13)) - 3;
                }
                else
                {
                  result = 73LL;
                }
              }
              else
              {
                result = ((_DWORD)v12 + 1) & 0xFFFFFFFE;
              }
            }
            else
            {
              result = 1LL;
            }
            if ( (unsigned __int8)v8 != (unsigned __int8)result )
              break;
            result = v10 - 24;
            v14 = v10 > v2 + 1040;
            v10 -= 24LL;
          }
          while ( v14 );
          if ( v12 + 1 <= v6 )
            v7 = v12 + 1;
          else
            v7 = (v5 + 7) >> 3;
        }
        else
        {
          v7 = 0LL;
        }
        v15 = v6 - v7 + 1;
        if ( v15 < 4 )
        {
          v16 = v7;
LABEL_35:
          v20 = v6 - v16 + 1;
          v21 = (_QWORD *)(v2 + 8 * v16 + 8);
          do
          {
            --v20;
            *v21++ = v4;
          }
          while ( v20 );
          goto LABEL_37;
        }
        v17 = vdupq_n_s64((unsigned __int64)v4);
        v16 = v7 + (v15 & 0xFFFFFFFFFFFFFFFCLL);
        v18 = (int64x2_t *)(v2 + 8 * v7 + 24);
        v19 = v15 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v18[-1] = v17;
          *v18 = v17;
          v19 -= 4LL;
          v18 += 2;
        }
        while ( v19 );
        if ( v15 != (v15 & 0xFFFFFFFFFFFFFFFCLL) )
          goto LABEL_35;
      }
    }
  }
LABEL_37:
  --*(_QWORD *)(v2 + 3024);
  v22 = *(_BYTE *)(a2 + 14);
  *(_QWORD *)(a2 + 56) = 0LL;
  *(_QWORD *)(a2 + 64) = 0LL;
  *(_BYTE *)(a2 + 14) = v22 & 0xFE;
  return result;
}


================================================================================
Function: sub_67FB2D4 (0x67FB2D4)
================================================================================

__int64 __fastcall sub_67FB2D4(__int64 a1, unsigned __int64 a2, char a3)
{
  unsigned __int64 *v4; // x22
  __int64 v6; // x21

  v4 = (unsigned __int64 *)(a1 + 48);
  *(_BYTE *)(a1 + 14) &= ~2u;
  v6 = **(_QWORD **)(a1 + 48) + 32LL;
  sub_67FB0E8(a2, a1);
  atomic_store(0LL, v4);
  return sub_67FC91C(a1, a3, v6);
}


================================================================================
Function: sub_67FB334 (0x67FB334)
================================================================================

_QWORD *__fastcall sub_67FB334(__int64 a1)
{
  char v1; // w10
  __int64 v3; // x9
  char v4; // w8
  unsigned __int64 v5; // x10
  unsigned __int8 v6; // w11
  __int64 v7; // x11
  _QWORD *result; // x0
  __int64 v9; // x20
  char v10; // w9
  __int64 v11; // x8
  unsigned __int64 v12; // x9

  v1 = *(_BYTE *)(a1 + 14);
  v3 = *(unsigned int *)(a1 + 28);
  v4 = v1 & 0xFD;
  *(_BYTE *)(a1 + 14) = v1 & 0xFD;
  if ( (v1 & 1) != 0 )
  {
    v5 = 74LL;
  }
  else
  {
    if ( (unsigned int)v3 >= 9 )
    {
      v5 = (unsigned __int64)(v3 + 7) >> 3;
      if ( (unsigned int)v3 > 0x40 )
      {
        if ( (unsigned int)v3 <= 0x20000 )
        {
          v6 = 63 - __clz(--v5);
          LODWORD(v5) = ((v5 >> (v6 - 2)) & 3 | (4 * v6)) + 253;
        }
        else
        {
          LOBYTE(v5) = 73;
        }
      }
      else
      {
        LOBYTE(v5) = (v5 + 1) & 0xFE;
      }
    }
    else
    {
      LOBYTE(v5) = 1;
    }
    v5 = (unsigned __int8)v5;
  }
  v7 = *(_QWORD *)(a1 + 48);
  result = (_QWORD *)(v7 + 24 * v5 + 1040);
  if ( (unsigned int)v3 <= 0x20000
    && *(_QWORD *)(v7 + 24 * v5 + 1056) <= 0x20000uLL
    && *(_QWORD *)(v7 + 24 * v5 + 1048) == a1
    && *result == a1 )
  {
    if ( (unsigned int)v3 > 0x4000 )
      v10 = 10;
    else
      v10 = 34;
    *(_BYTE *)(a1 + 15) = v10 & 0xFE | *(_BYTE *)(a1 + 15) & 1;
    v11 = *(_QWORD *)(a1 + 48);
    v12 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v7 + 24 * v5 - v11) >> 3);
    if ( v12 < *(_QWORD *)(v11 + 3032) )
      *(_QWORD *)(v11 + 3032) = v12;
    if ( v12 > *(_QWORD *)(v11 + 3040) )
      *(_QWORD *)(v11 + 3040) = v12;
  }
  else
  {
    *(_BYTE *)(a1 + 14) = v4;
    v9 = **(_QWORD **)(a1 + 48) + 32LL;
    sub_67FB0E8(result, a1);
    atomic_store(0LL, (unsigned __int64 *)(a1 + 48));
    return (_QWORD *)sub_67FC91C(a1, 0LL, v9);
  }
  return result;
}


================================================================================
Function: sub_67FB4BC (0x67FB4BC)
================================================================================

__int64 __fastcall sub_67FB4BC(__int64 result, char a2)
{
  unsigned __int64 v2; // x25
  __int64 v3; // x19
  unsigned __int64 v4; // x24
  unsigned __int64 v5; // x26
  unsigned __int64 v7; // x21
  __int64 v8; // x8
  unsigned int v9; // w10
  __int64 v10; // x22
  unsigned __int64 *v11; // x27
  __int64 v12; // x23

  v2 = *(_QWORD *)(result + 3032);
  v3 = result;
  if ( v2 <= *(_QWORD *)(result + 3040) )
  {
    v4 = 0LL;
    v5 = 74LL;
    v7 = result + 24 * v2 + 1040;
    do
    {
      v8 = *(_QWORD *)v7;
      if ( *(_QWORD *)v7 )
      {
        v9 = *(unsigned __int8 *)(v8 + 15);
        if ( v9 >= 2 )
        {
          if ( *(_DWORD *)(v8 + 24) )
          {
            *(_BYTE *)(v8 + 15) = v9 & 1;
          }
          else
          {
            *(_BYTE *)(v8 + 15) = v9 - 2;
            if ( (a2 & 1) != 0 || (unsigned __int8)(v9 - 2) <= 1u )
            {
              v10 = *(_QWORD *)v7;
              v11 = (unsigned __int64 *)(*(_QWORD *)v7 + 48LL);
              *(_BYTE *)(v10 + 14) = *(_BYTE *)(*(_QWORD *)v7 + 14LL) & 0xFD;
              v12 = **(_QWORD **)(v10 + 48) + 32LL;
              sub_67FB0E8(v7, v10);
              atomic_store(0LL, v11);
              result = sub_67FC91C(v10, a2 & 1, v12);
            }
            else
            {
              if ( v2 < v5 )
                v5 = v2;
              if ( v2 > v4 )
                v4 = v2;
            }
          }
        }
      }
      ++v2;
      v7 += 24LL;
    }
    while ( v2 <= *(_QWORD *)(v3 + 3040) );
  }
  else
  {
    v4 = 0LL;
    v5 = 74LL;
  }
  *(_QWORD *)(v3 + 3032) = v5;
  *(_QWORD *)(v3 + 3040) = v4;
  return result;
}


================================================================================
Function: sub_67FB5D8 (0x67FB5D8)
================================================================================

_QWORD *__fastcall sub_67FB5D8(_QWORD *result, char a2)
{
  _QWORD *v2; // x9
  _QWORD *v3; // x19

  v2 = (_QWORD *)*result;
  ++*(_QWORD *)*result;
  if ( off_730D2C8 )
  {
    if ( !*((_BYTE *)v2 + 8) )
    {
      v3 = result;
      *((_BYTE *)v2 + 8) = 1;
      result = (_QWORD *)off_730D2C8(a2 & 1);
      *(_BYTE *)(*v3 + 8LL) = 0;
    }
  }
  return result;
}


================================================================================
Function: sub_67FB640 (0x67FB640)
================================================================================

__int64 __fastcall sub_67FB640(void *a1, __int64 a2, char a3, __int64 a4)
{
  __int64 v7; // x21
  __int64 v8; // x8
  _QWORD *v9; // x23
  __int64 v10; // x0
  _BOOL4 v11; // w8
  bool v12; // zf
  __int64 v13; // x23
  _QWORD *v15; // x25
  __int64 v16; // x24
  __int64 v17; // x0
  void *v18; // x19
  size_t v19; // x0

  v7 = (__int64)a1;
  if ( a1 == &unk_6C58500 )
  {
    v7 = sub_67F4CA4();
    if ( (_UNKNOWN *)v7 == &unk_6C58500 )
      return 0LL;
  }
  v8 = *(_QWORD *)v7;
  ++**(_QWORD **)v7;
  if ( off_730D2C8 && !*(_BYTE *)(v8 + 8) )
  {
    *(_BYTE *)(v8 + 8) = 1;
    off_730D2C8(0LL);
    *(_BYTE *)(*(_QWORD *)v7 + 8LL) = 0;
  }
  v9 = *(_QWORD **)(v7 + 2840);
  if ( v9 )
  {
    do
    {
      v10 = sub_6867020(v9, 0LL, v7 + 2840);
      v11 = v10 == (_QWORD)v9;
      if ( (_QWORD *)v10 != v9 )
        v9 = (_QWORD *)v10;
      v12 = v11 || v9 == 0LL;
    }
    while ( !v12 );
    if ( v9 )
    {
      do
      {
        v15 = (_QWORD *)*v9;
        if ( (sub_67F4024(v9) & 1) == 0 )
        {
          v16 = *(_QWORD *)(v7 + 2840);
          do
          {
            *v9 = v16;
            v17 = sub_6866FE0(v16, v9, v7 + 2840);
            v12 = v17 == v16;
            v16 = v17;
          }
          while ( !v12 );
        }
        v9 = v15;
      }
      while ( v15 );
    }
  }
  v13 = sub_67FB824(v7, a2, a4);
  if ( v13 || (sub_67F4C48(v7, 1LL), (v13 = sub_67FB824(v7, a2, a4)) != 0) )
  {
    if ( (a3 & 1) == 0 || *(_DWORD *)(v13 + 28) )
      return sub_67F3D44(v7, v13, a2, a3 & 1);
    v18 = (void *)sub_67F3D44(v7, v13, a2, 0LL);
    v19 = sub_67FBCB0(v13);
    memset(v18, 0, v19);
  }
  else
  {
    sub_67F8A74(12LL, "unable to allocate memory (%zu bytes)\n", a2);
    return 0LL;
  }
  return (__int64)v18;
}


================================================================================
Function: sub_67FB824 (0x67FB824)
================================================================================

__int64 __fastcall sub_67FB824(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  int v4; // w8
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  unsigned __int8 v7; // w9
  __int64 v8; // x22
  __int64 v9; // x23
  __int64 v10; // x19
  unsigned __int64 v11; // x0
  unsigned __int64 v12; // x21
  _QWORD **v13; // x8
  _QWORD *v14; // x12
  unsigned int v15; // w10
  unsigned int v16; // w9
  _QWORD *v17; // x11
  unsigned int v18; // w13
  bool v19; // cf
  int v20; // w9
  __int64 v21; // x8
  __int64 v22; // x9
  __int64 v23; // x9
  __int64 *v24; // x21
  char i; // w26
  __int64 v26; // x27
  char v27; // w8
  unsigned __int64 v28; // x0
  unsigned __int64 v29; // x23
  _QWORD **v30; // x8
  _QWORD *v31; // x12
  unsigned int v32; // w10
  unsigned int v33; // w9
  _QWORD *v34; // x11
  unsigned int v35; // w13
  int v36; // w9
  unsigned __int64 v37; // x0
  unsigned __int64 v38; // x23
  _QWORD **v39; // x8
  _QWORD *v40; // x12
  unsigned int v41; // w10
  unsigned int v42; // w9
  _QWORD *v43; // x11
  unsigned int v44; // w13
  char v45; // w9
  int v46; // w9
  unsigned __int64 v47; // x1
  unsigned __int64 v48; // x9
  __int16 v49; // w20
  unsigned __int64 v51; // [xsp+0h] [xbp-10h]

  if ( a2 <= 0x20000 && !a3 )
  {
    if ( a2 >= 9 )
    {
      v5 = (a2 + 7) >> 3;
      if ( a2 > 0x40 )
      {
        v6 = v5 - 1;
        v7 = 63 - __clz(v5 - 1);
        v4 = ((v6 >> (v7 - 2)) & 3 | (4 * v7)) + 253;
      }
      else
      {
        LOBYTE(v4) = (v5 + 1) & 0xFE;
      }
    }
    else
    {
      LOBYTE(v4) = 1;
    }
    v8 = (unsigned __int8)v4;
    v9 = a1 + 24LL * (unsigned __int8)v4;
    v10 = *(_QWORD *)(v9 + 1040);
    if ( v10 )
    {
      if ( *(_QWORD *)(v10 + 40) >= 4uLL )
      {
        v11 = *(_QWORD *)(v10 + 40);
        do
        {
          v12 = v11;
          v11 = sub_6867020(v11, v11 & 3, (atomic_ullong *)(v10 + 40));
        }
        while ( v11 != v12 );
        v13 = (_QWORD **)(v12 & 0xFFFFFFFFFFFFFFFCLL);
        if ( (v12 & 0xFFFFFFFFFFFFFFFCLL) != 0 )
        {
          v14 = *v13;
          v15 = 1;
          v16 = *(unsigned __int16 *)(v10 + 10);
          v17 = (_QWORD *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
          if ( *v13 && *(_WORD *)(v10 + 10) )
          {
            v18 = 1;
            do
            {
              v17 = v14;
              v14 = (_QWORD *)*v14;
              v15 = v18 + 1;
              if ( !v14 )
                break;
              v19 = v18++ >= v16;
            }
            while ( !v19 );
          }
          if ( v15 <= v16 )
          {
            *v17 = *(_QWORD *)(v10 + 32);
            v20 = *(_DWORD *)(v10 + 24);
            *(_QWORD *)(v10 + 32) = v13;
            *(_DWORD *)(v10 + 24) = v20 - v15;
          }
          else
          {
            sub_67F8A74(14LL, "corrupted thread-free list\n");
          }
        }
      }
      v21 = *(_QWORD *)(v10 + 32);
      v22 = *(_QWORD *)(v10 + 16);
      if ( v21 )
      {
LABEL_23:
        if ( !v22 )
        {
          v23 = *(unsigned __int8 *)(v10 + 15);
          *(_QWORD *)(v10 + 16) = v21;
          *(_QWORD *)(v10 + 32) = 0LL;
          *(_BYTE *)(v10 + 15) = v23 & 0xFE;
        }
        goto LABEL_76;
      }
      if ( v22 )
      {
LABEL_76:
        *(_BYTE *)(v10 + 15) &= 1u;
        return v10;
      }
    }
    v24 = (__int64 *)(v9 + 1040);
    for ( i = 1; ; i = 0 )
    {
      v26 = *v24;
      if ( *v24 )
        break;
LABEL_28:
      sub_67FB4BC(a1, 0LL);
      v10 = sub_67FBE40(a1, v24, *(_QWORD *)(a1 + 24 * v8 + 1056), 0LL);
      v27 = i & (v10 == 0);
      if ( (v27 & 1) == 0 )
        return v10;
    }
    while ( 1 )
    {
      v10 = v26;
      v26 = *(_QWORD *)(v26 + 56);
      if ( *(_QWORD *)(v10 + 40) >= 4uLL )
      {
        v28 = *(_QWORD *)(v10 + 40);
        do
        {
          v29 = v28;
          v28 = sub_6867020(v28, v28 & 3, (atomic_ullong *)(v10 + 40));
        }
        while ( v28 != v29 );
        v30 = (_QWORD **)(v29 & 0xFFFFFFFFFFFFFFFCLL);
        if ( (v29 & 0xFFFFFFFFFFFFFFFCLL) != 0 )
        {
          v31 = *v30;
          v32 = 1;
          v33 = *(unsigned __int16 *)(v10 + 10);
          v34 = (_QWORD *)(v29 & 0xFFFFFFFFFFFFFFFCLL);
          if ( *v30 && *(_WORD *)(v10 + 10) )
          {
            v35 = 1;
            do
            {
              v34 = v31;
              v31 = (_QWORD *)*v31;
              v32 = v35 + 1;
              if ( !v31 )
                break;
              v19 = v35++ >= v33;
            }
            while ( !v19 );
          }
          if ( v32 <= v33 )
          {
            *v34 = *(_QWORD *)(v10 + 32);
            v36 = *(_DWORD *)(v10 + 24);
            *(_QWORD *)(v10 + 32) = v30;
            *(_DWORD *)(v10 + 24) = v36 - v32;
          }
          else
          {
            sub_67F8A74(14LL, "corrupted thread-free list\n");
          }
        }
      }
      v21 = *(_QWORD *)(v10 + 32);
      v22 = *(_QWORD *)(v10 + 16);
      if ( v21 )
        goto LABEL_23;
      if ( v22 )
        goto LABEL_76;
      if ( *(unsigned __int16 *)(v10 + 10) < (unsigned int)*(unsigned __int16 *)(v10 + 12) )
      {
        sub_67FC8B4((v10 - 1) & 0xFFFFFFFFFE000000LL);
        if ( *(int *)(v10 + 28) < 0 )
          v47 = v51;
        else
          v47 = *(unsigned int *)(v10 + 28);
        if ( v47 <= 0xFFF )
        {
          v48 = 0x1000u / (unsigned __int16)v47;
          if ( (unsigned int)v48 <= 4 )
            v48 = 4LL;
        }
        else
        {
          v48 = 4LL;
        }
        if ( *(unsigned __int16 *)(v10 + 12) - (unsigned __int64)*(unsigned __int16 *)(v10 + 10) <= v48 )
          v49 = *(_WORD *)(v10 + 12) - *(_WORD *)(v10 + 10);
        else
          v49 = v48;
        sub_67FBFF0(v10);
        *(_WORD *)(v10 + 10) += v49;
        goto LABEL_76;
      }
      if ( (*(_BYTE *)(v10 + 14) & 1) != 0 )
        goto LABEL_30;
      sub_67FAD28(*(_QWORD *)(v10 + 48) + 2816LL, v24, v10);
      if ( *(_QWORD *)(v10 + 40) < 4uLL )
        goto LABEL_60;
      v37 = *(_QWORD *)(v10 + 40);
      do
      {
        v38 = v37;
        v37 = sub_6867020(v37, v37 & 3, (atomic_ullong *)(v10 + 40));
      }
      while ( v37 != v38 );
      v39 = (_QWORD **)(v38 & 0xFFFFFFFFFFFFFFFCLL);
      if ( (v38 & 0xFFFFFFFFFFFFFFFCLL) == 0 )
        goto LABEL_60;
      v40 = *v39;
      v41 = 1;
      v42 = *(unsigned __int16 *)(v10 + 10);
      v43 = (_QWORD *)(v38 & 0xFFFFFFFFFFFFFFFCLL);
      if ( *v39 && *(_WORD *)(v10 + 10) )
      {
        v44 = 1;
        do
        {
          v43 = v40;
          v40 = (_QWORD *)*v40;
          v41 = v44 + 1;
          if ( !v40 )
            break;
          v19 = v44++ >= v42;
        }
        while ( !v19 );
      }
      if ( v41 > v42 )
        break;
      *v43 = *(_QWORD *)(v10 + 32);
      v46 = *(_DWORD *)(v10 + 24);
      *(_QWORD *)(v10 + 32) = v39;
      *(_DWORD *)(v10 + 24) = v46 - v41;
      if ( v39 )
      {
LABEL_61:
        if ( !*(_QWORD *)(v10 + 16) )
        {
          v45 = *(_BYTE *)(v10 + 15);
          *(_QWORD *)(v10 + 16) = v39;
          *(_QWORD *)(v10 + 32) = 0LL;
          *(_BYTE *)(v10 + 15) = v45 & 0xFE;
        }
      }
LABEL_30:
      if ( !v26 )
        goto LABEL_28;
    }
    sub_67F8A74(14LL, "corrupted thread-free list\n");
LABEL_60:
    v39 = *(_QWORD ***)(v10 + 32);
    if ( v39 )
      goto LABEL_61;
    goto LABEL_30;
  }
  if ( (a2 & 0x8000000000000000LL) != 0 )
  {
    sub_67F8A74(75LL, "allocation request is too large (%zu bytes)\n", a2);
    return 0LL;
  }
  return sub_67FBD18(a1, a2);
}


================================================================================
Function: sub_67FBCB0 (0x67FBCB0)
================================================================================

__int64 __fastcall sub_67FBCB0(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // [xsp+0h] [xbp-10h]

  result = *(unsigned int *)(a1 + 28);
  if ( (result & 0x80000000) != 0 )
  {
    sub_67FC8B4((a1 - 1) & 0xFFFFFFFFFE000000LL);
    return v3;
  }
  return result;
}


================================================================================
Function: sub_67FBD18 (0x67FBD18)
================================================================================

unsigned int *__fastcall sub_67FBD18(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // x0
  unsigned __int64 v6; // x9
  unsigned __int64 v8; // x8
  unsigned __int8 v9; // w9
  unsigned int *v10; // x0
  unsigned int *v11; // x19
  __int64 v13; // [xsp+0h] [xbp-10h] BYREF

  v5 = sub_67F8F98(a2);
  v6 = 2147483655LL;
  if ( v5 <= 0x1000000 && a3 == 0 )
    v6 = v5 + 7;
  if ( v6 >= 0x10 )
  {
    v8 = v6 >> 3;
    if ( v6 > 0x47 )
    {
      if ( v6 <= 0x20007 )
      {
        v9 = 63 - __clz(--v8);
        LODWORD(v8) = ((v8 >> (v9 - 2)) & 3 | (4 * v9)) + 253;
      }
      else
      {
        LOBYTE(v8) = 73;
      }
    }
    else
    {
      LOBYTE(v8) = (v8 + 1) & 0xFE;
    }
  }
  else
  {
    LOBYTE(v8) = 1;
  }
  v10 = sub_67FBE40(a1, a1 + 24LL * (unsigned __int8)v8 + 1040, v5);
  v11 = v10;
  if ( v10 && (v10[7] & 0x80000000) != 0 )
    sub_67FC8B4(((unsigned __int64)v10 - 1) & 0xFFFFFFFFFE000000LL, v10, &v13);
  return v11;
}


================================================================================
Function: sub_67FBE40 (0x67FBE40)
================================================================================

unsigned int *__fastcall sub_67FBE40(unsigned __int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned int *v6; // x0
  unsigned int *v7; // x21
  unsigned int v8; // w9
  unsigned __int64 v9; // x8
  __int64 v10; // x11
  unsigned __int64 v11; // x1
  unsigned __int64 v12; // x9
  __int16 v13; // w22
  unsigned __int64 v15; // [xsp+8h] [xbp-18h] BYREF
  unsigned __int64 v16; // [xsp+10h] [xbp-10h] BYREF

  v6 = (unsigned int *)sub_67FD9B0();
  v7 = v6;
  if ( v6 )
  {
    if ( !a2 || *(_QWORD *)(a2 + 16) == 131080LL )
    {
      a3 = v6[7];
      if ( (a3 & 0x80000000) != 0 )
      {
        sub_67FC8B4(((unsigned __int64)v6 - 1) & 0xFFFFFFFFFE000000LL, v6, &v16);
        a3 = v16;
      }
    }
    v8 = 0x80000000;
    if ( !(a3 >> 31) )
      v8 = a3;
    atomic_store(a1, (unsigned __int64 *)v7 + 6);
    v7[7] = v8;
    sub_67FC8B4(((unsigned __int64)v7 - 1) & 0xFFFFFFFFFE000000LL, v7, &v15);
    v9 = v15 / a3;
    v10 = *((_QWORD *)v7 + 2);
    *((_BYTE *)v7 + 15) = *((_BYTE *)v7 + 15) & 0xFE | ((v7[2] & 2) != 0);
    *((_WORD *)v7 + 6) = v9;
    if ( !v10 && *((unsigned __int16 *)v7 + 5) < (unsigned int)(unsigned __int16)v9 )
    {
      sub_67FC8B4(((unsigned __int64)v7 - 1) & 0xFFFFFFFFFE000000LL, v7, &v16);
      if ( (v7[7] & 0x80000000) != 0 )
        v11 = v16;
      else
        v11 = v7[7];
      if ( v11 <= 0xFFF )
      {
        v12 = 0x1000u / (unsigned __int16)v11;
        if ( (unsigned int)v12 <= 4 )
          v12 = 4LL;
      }
      else
      {
        v12 = 4LL;
      }
      if ( *((unsigned __int16 *)v7 + 6) - (unsigned __int64)*((unsigned __int16 *)v7 + 5) <= v12 )
        v13 = *((_WORD *)v7 + 6) - *((_WORD *)v7 + 5);
      else
        v13 = v12;
      sub_67FBFF0(v7);
      *((_WORD *)v7 + 5) += v13;
    }
    if ( a2 )
      sub_67FA960(a1, a2, v7);
  }
  return v7;
}


================================================================================
Function: sub_67FBFF0 (0x67FBFF0)
================================================================================

__int64 __fastcall sub_67FBFF0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // x0
  __int64 v7; // x11
  __int64 v8; // x12
  __int64 v9; // x8
  _QWORD *v10; // x9
  __int64 v11; // x10
  __int64 v12; // x11
  __int64 v13; // x10

  result = sub_67FC8B4((a1 - 1) & 0xFFFFFFFFFE000000LL, (unsigned int *)a1, 0LL);
  v7 = *(unsigned __int16 *)(a1 + 10);
  v8 = (a3 + v7 - 1) * a2;
  v9 = result + v7 * a2;
  v10 = (_QWORD *)(result + v8);
  if ( v7 * a2 <= v8 )
  {
    v11 = 0LL;
    v12 = result + a2 + a2 * v7;
    do
    {
      *(_QWORD *)(v9 + v11) = v12 + v11;
      v11 += a2;
    }
    while ( v9 + v11 <= (unsigned __int64)v10 );
  }
  v13 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v9;
  *v10 = v13;
  return result;
}


================================================================================
Function: sub_67FC084 (0x67FC084)
================================================================================

unsigned __int64 __fastcall sub_67FC084(__int64 a1)
{
  int v1; // w8
  __int64 v3; // x8
  unsigned int v4; // w20
  bool v5; // vf
  int v6; // w8
  __int64 v7; // x8
  unsigned int v8; // w0
  unsigned __int64 result; // x0

  v1 = *(_DWORD *)(a1 + 128);
  if ( v1 <= 0 )
  {
    sub_67FC4B8(a1);
    v1 = 16;
    *(_DWORD *)(a1 + 128) = 16;
  }
  v3 = a1 + 4 * (16LL - v1);
  v4 = *(_DWORD *)(v3 + 64);
  *(_DWORD *)(v3 + 64) = 0;
  LODWORD(v3) = *(_DWORD *)(a1 + 128);
  v5 = __OFSUB__((_DWORD)v3, 1);
  v6 = v3 - 1;
  *(_DWORD *)(a1 + 128) = v6;
  if ( (v6 < 0) ^ v5 | (v6 == 0) )
  {
    sub_67FC4B8(a1);
    v6 = 16;
    *(_DWORD *)(a1 + 128) = 16;
  }
  v7 = a1 + 4 * (16LL - v6);
  v8 = *(_DWORD *)(v7 + 64);
  *(_DWORD *)(v7 + 64) = 0;
  result = v8 | ((unsigned __int64)v4 << 32);
  --*(_DWORD *)(a1 + 128);
  return result;
}


================================================================================
Function: sub_67FC19C (0x67FC19C)
================================================================================

long double __fastcall sub_67FC19C(__int64 a1)
{
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x14
  unsigned __int64 v4; // x16
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x15
  unsigned __int64 v7; // x0
  unsigned __int64 v8; // x13
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x2
  unsigned __int64 v11; // x3
  unsigned __int64 v12; // x17
  unsigned __int64 v13; // x11
  unsigned __int64 v14; // x4
  unsigned __int64 v15; // x5
  unsigned __int64 v16; // x1
  unsigned __int64 v17; // x12
  unsigned __int64 v18; // x6
  __int64 v19; // x0
  unsigned __int64 v20; // x9
  __int64 v21; // x10
  unsigned __int64 v22; // x9
  unsigned __int64 v23; // x13
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x8
  unsigned __int64 v26; // x9
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x10
  unsigned __int64 v30; // x11
  unsigned __int64 v31; // x11
  unsigned __int64 v32; // x12
  unsigned __int64 v33; // x12
  unsigned __int64 v34; // x14
  unsigned __int64 v35; // x14
  unsigned __int64 v36; // x1
  unsigned __int64 v37; // x14
  unsigned __int64 v38; // x14
  unsigned __int64 v39; // x6
  unsigned __int64 v40; // x17
  unsigned __int64 v41; // x5
  int v42; // w7
  long double result; // q0
  int v44; // w9
  int v45; // w8
  unsigned __int8 v46; // w13
  unsigned __int8 v47; // w14
  int v48; // w8
  int v49; // w9
  int v50; // w10
  int v51; // [xsp+8h] [xbp-28h] BYREF
  int v52; // [xsp+Ch] [xbp-24h]
  int v53; // [xsp+10h] [xbp-20h]
  int v54; // [xsp+14h] [xbp-1Ch]
  int v55; // [xsp+18h] [xbp-18h]
  int v56; // [xsp+1Ch] [xbp-14h]
  int v57; // [xsp+20h] [xbp-10h]
  int v58; // [xsp+24h] [xbp-Ch]

  if ( (sub_68011E8(&v51, 32LL) & 1) != 0 )
  {
    LOBYTE(v2) = v51;
    *(_BYTE *)(a1 + 132) = 0;
    LOBYTE(v3) = BYTE1(v51);
    LOBYTE(v4) = BYTE2(v51);
    LOBYTE(v5) = v52;
    LOBYTE(v6) = BYTE1(v52);
    LOBYTE(v7) = BYTE2(v52);
    LOBYTE(v8) = HIBYTE(v52);
    LOBYTE(v9) = v53;
    LOBYTE(v10) = BYTE1(v53);
    LOBYTE(v11) = BYTE2(v53);
    LOBYTE(v12) = HIBYTE(v53);
    LOBYTE(v13) = v54;
    LOBYTE(v14) = BYTE1(v54);
    LOBYTE(v15) = BYTE2(v54);
    LOBYTE(v16) = HIBYTE(v54);
    LOBYTE(v17) = v55;
    LOBYTE(v18) = BYTE1(v55);
  }
  else
  {
    v19 = sub_67F8944("unable to use secure randomness\n");
    v20 = sub_6801000(v19) ^ (unsigned __int64)sub_67FC11C;
    v21 = (((unsigned __int8)v20 ^ (unsigned __int8)((unsigned int)v20 >> 17)) & 0xF) + 1LL;
    do
    {
      if ( !v20 )
        v20 = 17LL;
      --v21;
      v22 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9LL * (v20 ^ (v20 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v20 ^ (v20 >> 30))) >> 27));
      v20 = v22 ^ (v22 >> 31);
    }
    while ( v21 );
    v23 = 17LL;
    if ( v20 )
      v24 = v20;
    else
      v24 = 17LL;
    v25 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v24 ^ (v24 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v24 ^ (v24 >> 30))) >> 27));
    v2 = v25 ^ (v25 >> 31);
    v4 = v2 >> 16;
    if ( v2 )
      v26 = v2;
    else
      v26 = 17LL;
    v27 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v26 ^ (v26 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v26 ^ (v26 >> 30))) >> 27));
    v5 = v27 ^ (v27 >> 31);
    v6 = v5 >> 8;
    if ( v5 )
      v28 = v5;
    else
      v28 = 17LL;
    v7 = v5 >> 16;
    v51 = v2;
    v52 = v5;
    v29 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v28 ^ (v28 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v28 ^ (v28 >> 30))) >> 27));
    v9 = v29 ^ (v29 >> 31);
    v10 = v9 >> 8;
    if ( v9 )
      v30 = v9;
    else
      v30 = 17LL;
    v11 = v9 >> 16;
    v31 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v30 ^ (v30 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v30 ^ (v30 >> 30))) >> 27));
    v13 = v31 ^ (v31 >> 31);
    v14 = v13 >> 8;
    if ( v13 )
      v32 = v13;
    else
      v32 = 17LL;
    v53 = v9;
    v54 = v13;
    v33 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v32 ^ (v32 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v32 ^ (v32 >> 30))) >> 27));
    v17 = v33 ^ (v33 >> 31);
    if ( v17 )
      v34 = v17;
    else
      v34 = 17LL;
    v35 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v34 ^ (v34 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v34 ^ (v34 >> 30))) >> 27));
    v36 = v35 ^ (v35 >> 31);
    if ( v36 )
      v37 = v35 ^ (v35 >> 31);
    else
      v37 = 17LL;
    v55 = v17;
    v56 = v36;
    v16 = v13 >> 24;
    v38 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v37 ^ (v37 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v37 ^ (v37 >> 30))) >> 27));
    v39 = v38 ^ (v38 >> 31);
    if ( v39 )
      v23 = v38 ^ (v38 >> 31);
    *(_BYTE *)(a1 + 132) = 1;
    v3 = v2 >> 8;
    v40 = (0xBF58476D1CE4E5B9LL * (v23 ^ (v23 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v23 ^ (v23 >> 30))) >> 27);
    v8 = v5 >> 24;
    v41 = 0x94D049BB133111EBLL * v40;
    v12 = v9 >> 24;
    v42 = (v41 >> 31) ^ v41;
    v15 = v13 >> 16;
    v57 = v39;
    v58 = v42;
    v18 = v17 >> 8;
  }
  *(_QWORD *)(a1 + 128) = 0LL;
  *(_OWORD *)&result = 0uLL;
  v44 = (unsigned __int16)((unsigned __int8)v5 | ((unsigned __int8)v6 << 8)) | ((unsigned __int8)v7 << 16) & 0xFFFFFF | ((unsigned __int8)v8 << 24);
  v45 = (unsigned __int16)((unsigned __int8)v2 | ((unsigned __int8)v3 << 8)) | ((unsigned __int8)v4 << 16) & 0xFFFFFF | (HIBYTE(v51) << 24);
  v46 = BYTE2(v55);
  v47 = HIBYTE(v55);
  *(_OWORD *)a1 = xmmword_B014F0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 16) = v45;
  *(_DWORD *)(a1 + 20) = v44;
  v48 = v56;
  v49 = v57;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 24) = (unsigned __int8)v9 | (unsigned __int16)((unsigned __int8)v10 << 8) | ((unsigned __int8)v11 << 16) & 0xFFFFFF | ((unsigned __int8)v12 << 24);
  *(_DWORD *)(a1 + 28) = (unsigned __int8)v13 | (unsigned __int16)((unsigned __int8)v14 << 8) | ((unsigned __int8)v15 << 16) & 0xFFFFFF | ((unsigned __int8)v16 << 24);
  v50 = v58;
  *(_DWORD *)(a1 + 32) = (unsigned __int8)v17 | (unsigned __int16)((unsigned __int8)v18 << 8) | (v46 << 16) & 0xFFFFFF | (v47 << 24);
  *(_DWORD *)(a1 + 36) = v48;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 40) = v49;
  *(_DWORD *)(a1 + 44) = v50;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 56) = a1;
  return result;
}


================================================================================
Function: sub_67FC4B8 (0x67FC4B8)
================================================================================

int *__fastcall sub_67FC4B8(int *result)
{
  int v1; // w6
  int v2; // w7
  int v3; // w1
  int v4; // w3
  int v5; // w16
  int v6; // w17
  int v7; // w13
  int v8; // w14
  int v9; // w12
  int v10; // w15
  int v11; // w9
  int v12; // w10
  int v13; // w4
  int v14; // w5
  int v15; // w2
  int v16; // w11
  unsigned __int64 v17; // x8
  int v18; // w7
  int v19; // w6
  int v20; // w3
  int v21; // w1
  int v22; // w5
  unsigned __int64 v23; // t2
  int v24; // w4
  int v25; // w2
  int v26; // w11
  int v27; // w12
  int v28; // w15
  int v29; // w10
  int v30; // w9
  int v31; // w17
  int v32; // w16
  int v33; // w14
  int v34; // w13
  int v35; // w7
  int v36; // w6
  int v37; // w3
  int v38; // w1
  int v39; // w5
  int v40; // w4
  int v41; // w2
  int v42; // w11
  int v43; // w12
  int v44; // w15
  int v45; // w10
  int v46; // w9
  int v47; // w16
  int v48; // w14
  int v49; // w13
  int v50; // w17
  int v51; // w7
  int v52; // w6
  int v53; // w3
  int v54; // w1
  int v55; // w11
  int v56; // w5
  int v57; // w4
  int v58; // w2
  int v59; // w10
  int v60; // w9
  int v61; // w12
  int v62; // w15
  int v63; // w16
  int v64; // w14
  int v65; // w13
  int v66; // w17
  int v67; // w19
  int v68; // w8
  int v69; // w7
  int v70; // w20
  int v71; // w6
  int v72; // w8
  int v73; // w8
  int v74; // w17
  int v75; // w14
  int v76; // w1
  int v77; // w3
  int v78; // w13
  int v79; // w14
  int v80; // w13
  int v81; // w10
  int v82; // w12
  int v83; // w8
  int v84; // w15

  v2 = *result;
  v1 = result[1];
  v4 = result[2];
  v3 = result[3];
  v6 = result[4];
  v5 = result[5];
  v8 = result[6];
  v7 = result[7];
  v9 = result[8];
  v10 = result[9];
  v12 = result[10];
  v11 = result[11];
  v14 = result[12];
  v13 = result[13];
  v15 = result[14];
  v16 = result[15];
  v17 = -2LL;
  do
  {
    v18 = v2 + v6;
    v19 = v1 + v5;
    v20 = v4 + v8;
    v21 = v3 + v7;
    v17 += 2LL;
    HIDWORD(v23) = v14 ^ v18;
    LODWORD(v23) = v14 ^ v18;
    v22 = v23 >> 16;
    HIDWORD(v23) = v13 ^ v19;
    LODWORD(v23) = v13 ^ v19;
    v24 = v23 >> 16;
    HIDWORD(v23) = v15 ^ v20;
    LODWORD(v23) = v15 ^ v20;
    v25 = v23 >> 16;
    HIDWORD(v23) = v16 ^ v21;
    LODWORD(v23) = v16 ^ v21;
    v26 = v23 >> 16;
    v27 = v9 + v22;
    v28 = v10 + v24;
    v29 = v12 + v25;
    v30 = v11 + v26;
    HIDWORD(v23) = v27 ^ v6;
    LODWORD(v23) = v27 ^ v6;
    v31 = v23 >> 20;
    HIDWORD(v23) = v28 ^ v5;
    LODWORD(v23) = v28 ^ v5;
    v32 = v23 >> 20;
    HIDWORD(v23) = v29 ^ v8;
    LODWORD(v23) = v29 ^ v8;
    v33 = v23 >> 20;
    HIDWORD(v23) = v30 ^ v7;
    LODWORD(v23) = v30 ^ v7;
    v34 = v23 >> 20;
    v35 = v31 + v18;
    v36 = v32 + v19;
    v37 = v33 + v20;
    v38 = v34 + v21;
    HIDWORD(v23) = v35 ^ v22;
    LODWORD(v23) = v35 ^ v22;
    v39 = v23 >> 24;
    HIDWORD(v23) = v36 ^ v24;
    LODWORD(v23) = v36 ^ v24;
    v40 = v23 >> 24;
    HIDWORD(v23) = v37 ^ v25;
    LODWORD(v23) = v37 ^ v25;
    v41 = v23 >> 24;
    HIDWORD(v23) = v38 ^ v26;
    LODWORD(v23) = v38 ^ v26;
    v42 = v23 >> 24;
    v43 = v39 + v27;
    v44 = v40 + v28;
    v45 = v41 + v29;
    v46 = v42 + v30;
    HIDWORD(v23) = v44 ^ v32;
    LODWORD(v23) = v44 ^ v32;
    v47 = v23 >> 25;
    HIDWORD(v23) = v45 ^ v33;
    LODWORD(v23) = v45 ^ v33;
    v48 = v23 >> 25;
    HIDWORD(v23) = v46 ^ v34;
    LODWORD(v23) = v46 ^ v34;
    v49 = v23 >> 25;
    HIDWORD(v23) = v43 ^ v31;
    LODWORD(v23) = v43 ^ v31;
    v50 = v23 >> 25;
    v51 = v47 + v35;
    v52 = v48 + v36;
    v53 = v49 + v37;
    v54 = v38 + v50;
    HIDWORD(v23) = v42 ^ v51;
    LODWORD(v23) = v42 ^ v51;
    v55 = v23 >> 16;
    HIDWORD(v23) = v52 ^ v39;
    LODWORD(v23) = v52 ^ v39;
    v56 = v23 >> 16;
    HIDWORD(v23) = v53 ^ v40;
    LODWORD(v23) = v53 ^ v40;
    v57 = v23 >> 16;
    HIDWORD(v23) = v54 ^ v41;
    LODWORD(v23) = v54 ^ v41;
    v58 = v23 >> 16;
    v59 = v55 + v45;
    v60 = v46 + v56;
    v61 = v57 + v43;
    v62 = v58 + v44;
    HIDWORD(v23) = v59 ^ v47;
    LODWORD(v23) = v59 ^ v47;
    v63 = v23 >> 20;
    HIDWORD(v23) = v60 ^ v48;
    LODWORD(v23) = v60 ^ v48;
    v64 = v23 >> 20;
    HIDWORD(v23) = v61 ^ v49;
    LODWORD(v23) = v61 ^ v49;
    v65 = v23 >> 20;
    HIDWORD(v23) = v62 ^ v50;
    LODWORD(v23) = v62 ^ v50;
    v66 = v23 >> 20;
    v2 = v63 + v51;
    v1 = v64 + v52;
    v4 = v65 + v53;
    v3 = v66 + v54;
    HIDWORD(v23) = v2 ^ v55;
    LODWORD(v23) = v2 ^ v55;
    v16 = v23 >> 24;
    HIDWORD(v23) = v1 ^ v56;
    LODWORD(v23) = v1 ^ v56;
    v14 = v23 >> 24;
    HIDWORD(v23) = v4 ^ v57;
    LODWORD(v23) = v4 ^ v57;
    v13 = v23 >> 24;
    HIDWORD(v23) = v3 ^ v58;
    LODWORD(v23) = v3 ^ v58;
    v15 = v23 >> 24;
    v12 = v16 + v59;
    v11 = v14 + v60;
    v9 = v13 + v61;
    v10 = v15 + v62;
    HIDWORD(v23) = v12 ^ v63;
    LODWORD(v23) = v12 ^ v63;
    v5 = v23 >> 25;
    HIDWORD(v23) = v11 ^ v64;
    LODWORD(v23) = v11 ^ v64;
    v8 = v23 >> 25;
    HIDWORD(v23) = v9 ^ v65;
    LODWORD(v23) = v9 ^ v65;
    v7 = v23 >> 25;
    HIDWORD(v23) = v10 ^ v66;
    LODWORD(v23) = v10 ^ v66;
    v6 = v23 >> 25;
  }
  while ( v17 < 0x12 );
  v67 = result[1];
  v68 = *result + v2;
  v70 = result[2];
  v69 = result[3];
  result[16] = v68;
  result[17] = v67 + v1;
  v72 = result[4];
  v71 = result[5];
  result[18] = v70 + v4;
  result[19] = v69 + v3;
  v73 = v72 + v6;
  v74 = result[7];
  v75 = result[6] + v8;
  v77 = result[8];
  v76 = result[9];
  result[20] = v73;
  result[21] = v71 + v5;
  result[22] = v75;
  result[23] = v74 + v7;
  v78 = result[10];
  v79 = result[11];
  result[24] = v77 + v9;
  result[25] = v76 + v10;
  v80 = v78 + v12;
  v82 = result[12];
  v81 = result[13];
  v83 = result[14];
  v84 = result[15];
  result[26] = v80;
  result[27] = v79 + v11;
  result[28] = v82 + v14;
  result[29] = v81 + v13;
  result[30] = v83 + v15;
  result[31] = v84 + v16;
  result[32] = 16;
  result[12] = v82 + 1;
  if ( v82 == -1 )
  {
    result[13] = v81 + 1;
    if ( v81 == -1 )
      result[14] = v83 + 1;
  }
  return result;
}


================================================================================
Function: sub_67FC71C (0x67FC71C)
================================================================================

__int64 __fastcall sub_67FC71C(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x9
  __int64 v3; // x8
  bool v4; // cc
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x9

  v2 = *a1;
  if ( *a1 == -1LL )
  {
    v3 = 64LL;
  }
  else if ( v2 )
  {
    v3 = 0LL;
    do
    {
      v4 = v2 > 1;
      v3 += v2 & 1;
      v2 >>= 1;
    }
    while ( v4 );
  }
  else
  {
    v3 = 0LL;
  }
  v5 = a1[1];
  if ( v5 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v5 )
  {
    do
    {
      v4 = v5 > 1;
      v3 += v5 & 1;
      v5 >>= 1;
    }
    while ( v4 );
  }
  v6 = a1[2];
  if ( v6 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v6 )
  {
    do
    {
      v4 = v6 > 1;
      v3 += v6 & 1;
      v6 >>= 1;
    }
    while ( v4 );
  }
  v7 = a1[3];
  if ( v7 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v7 )
  {
    do
    {
      v4 = v7 > 1;
      v3 += v7 & 1;
      v7 >>= 1;
    }
    while ( v4 );
  }
  v8 = a1[4];
  if ( v8 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v8 )
  {
    do
    {
      v4 = v8 > 1;
      v3 += v8 & 1;
      v8 >>= 1;
    }
    while ( v4 );
  }
  v9 = a1[5];
  if ( v9 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v9 )
  {
    do
    {
      v4 = v9 > 1;
      v3 += v9 & 1;
      v9 >>= 1;
    }
    while ( v4 );
  }
  v10 = a1[6];
  if ( v10 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v10 )
  {
    do
    {
      v4 = v10 > 1;
      v3 += v10 & 1;
      v10 >>= 1;
    }
    while ( v4 );
  }
  v11 = a1[7];
  if ( v11 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v11 )
  {
    do
    {
      v4 = v11 > 1;
      v3 += v11 & 1;
      v11 >>= 1;
    }
    while ( v4 );
  }
  return v3 * (a2 >> 9);
}


================================================================================
Function: sub_67FC8B4 (0x67FC8B4)
================================================================================

__int64 __fastcall sub_67FC8B4(__int64 a1, unsigned int *a2, _QWORD *a3)
{
  __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x8

  v3 = a2[7];
  if ( (unsigned int)v3 < 8 )
  {
    v5 = 0LL;
    if ( !a3 )
      return a1 + v5 - 0x3333333333330000LL * (((unsigned __int64)a2 - a1 - 264) >> 4);
LABEL_11:
    *a3 = ((unsigned __int64)*a2 << 16) - v5;
    return a1 + v5 - 0x3333333333330000LL * (((unsigned __int64)a2 - a1 - 264) >> 4);
  }
  if ( (unsigned int)v3 >= 0x201 )
    v4 = 0LL;
  else
    v4 = a2[7];
  if ( (unsigned int)v3 <= 0x40 )
    v5 = 3 * v3;
  else
    v5 = v4;
  if ( a3 )
    goto LABEL_11;
  return a1 + v5 - 0x3333333333330000LL * (((unsigned __int64)a2 - a1 - 264) >> 4);
}


================================================================================
Function: nullsub_284 (0x67FC918)
================================================================================

void nullsub_284()
{
  ;
}


================================================================================
Function: sub_67FC91C (0x67FC91C)
================================================================================

__int64 __fastcall sub_67FC91C(__int64 a1, char a2, __int64 a3)
{
  unsigned __int64 v5; // x20
  __int64 result; // x0
  __int64 v7; // x8

  v5 = (a1 - 1) & 0xFFFFFFFFFE000000LL;
  result = sub_67FC99C();
  v7 = *(_QWORD *)(v5 + 208);
  if ( !v7 )
    return sub_67FCAC4(v5, a2 & 1, a3);
  if ( v7 == *(_QWORD *)(v5 + 192) )
    return sub_67FCCF0(v5, a3);
  return result;
}


================================================================================
Function: sub_67FC99C (0x67FC99C)
================================================================================

__int64 __fastcall sub_67FC99C(unsigned int *a1, __int64 a2)
{
  char *v4; // x22
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x21
  __int64 v7; // x9
  char v8; // w8
  __int64 result; // x0

  v4 = (char *)a1 + 10;
  v5 = a1[7];
  v6 = ((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL;
  if ( (v5 & 0x80000000) != 0 )
    v5 = (unsigned __int64)*a1 << 16;
  sub_67FF704(*(_QWORD *)(a2 + 896) + 192LL, v5 * *((unsigned __int16 *)a1 + 5));
  sub_67FF704(*(_QWORD *)(a2 + 896) + 32LL, 1LL);
  if ( *(_BYTE *)(v6 + 24) && (sub_67F8510(11LL) & 1) != 0 )
  {
    v7 = a1[7];
    if ( (unsigned int)v7 < 8 )
    {
      v7 = 0LL;
    }
    else if ( (unsigned int)v7 > 0x40 )
    {
      if ( (unsigned int)v7 >= 0x201 )
        v7 = 0LL;
    }
    else
    {
      v7 *= 3LL;
    }
    sub_67F9CB4(
      v6 + v7 - 0x3333333333330000LL * (((unsigned __int64)a1 - v6 - 264) >> 4),
      ((unsigned __int64)*a1 << 16) - v7,
      *(_QWORD *)(a2 + 896));
  }
  v8 = a1[2] & 0xFD;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *(_QWORD *)(v4 + 62) = 0LL;
  *(_OWORD *)v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *((_BYTE *)a1 + 8) = v8;
  a1[7] = 1;
  result = sub_67FE16C(a1, a2);
  --*(_QWORD *)(v6 + 208);
  return result;
}


================================================================================
Function: sub_67FCAC4 (0x67FCAC4)
================================================================================

__int64 __fastcall sub_67FCAC4(__int128 *a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // x9
  unsigned int *v6; // x8
  unsigned __int64 v7; // x12
  unsigned __int64 v8; // x15
  unsigned __int64 v9; // x0
  __int64 v10; // x17
  unsigned int **v11; // x1
  __int64 v12; // x0
  _QWORD *v13; // x15
  _QWORD *v14; // x15
  unsigned int *v15; // t1
  __int64 v16; // x0
  __int64 v17; // x22
  __int64 v18; // x23
  unsigned __int64 v19; // x9
  unsigned __int64 v20; // x8
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // x8
  __int64 v23; // x2
  __int64 v26; // x9
  __int64 v27; // x1
  __int64 v28; // x4
  __int128 v30; // [xsp+0h] [xbp-20h] BYREF
  __int64 v31; // [xsp+10h] [xbp-10h]

  v5 = *((_QWORD *)a1 + 31);
  if ( v5 >= 1 )
  {
    v6 = (unsigned int *)a1 + 66;
    v7 = (unsigned __int64)&a1[5 * v5 + 16] + 8;
    while ( v6[7] || *((_DWORD *)a1 + 60) == 1 )
    {
LABEL_4:
      v6 += 20 * *v6;
      if ( (unsigned __int64)v6 >= v7 )
        goto LABEL_19;
    }
    v8 = *v6;
    if ( (unsigned int)v8 >= 2 )
    {
      v9 = __clz(v8 - 1);
      if ( 63 - v9 >= 3 )
        v8 = (((v8 - 1) >> (61 - (unsigned __int8)v9)) & 3 | (4 * (63 - v9))) - 4;
    }
    v10 = *((_QWORD *)v6 + 8);
    if ( v10 )
      *(_QWORD *)(v10 + 56) = *((_QWORD *)v6 + 7);
    v11 = (unsigned int **)&a3[3 * v8];
    v12 = *((_QWORD *)v6 + 7);
    if ( *v11 == v6 )
    {
      *v11 = (unsigned int *)v12;
      if ( !v12 )
        goto LABEL_15;
    }
    else if ( !v12 )
    {
LABEL_15:
      v13 = &a3[3 * v8];
      v15 = (unsigned int *)v13[1];
      v14 = v13 + 1;
      if ( v15 == v6 )
        *v14 = *((_QWORD *)v6 + 8);
      *((_QWORD *)v6 + 7) = 0LL;
      *((_QWORD *)v6 + 8) = 0LL;
      v6[7] = 1;
      goto LABEL_4;
    }
    *(_QWORD *)(v12 + 64) = v10;
    goto LABEL_15;
  }
LABEL_19:
  sub_67FF704(a3[112] + 192LL, *((_QWORD *)a1 + 29) << 16);
  atomic_store(0LL, (unsigned __int64 *)a1 + 32);
  sub_67FF45C(a1);
  v16 = a3[112];
  v17 = -65536LL * *((_QWORD *)a1 + 28);
  if ( v17 < 0 )
  {
    sub_67FF704(v16, 1LL);
    v18 = -1LL;
  }
  else
  {
    v18 = 1LL;
    sub_67FF620(v16, 1LL);
  }
  v19 = a3[109];
  v20 = a3[108] + v18;
  a3[108] = v20;
  if ( v20 > v19 )
    a3[109] = v20;
  v21 = a3[111];
  v22 = a3[110] + v17;
  a3[110] = v22;
  if ( v22 > v21 )
    a3[111] = v22;
  v23 = sub_67FC71C(a1 + 7, *((_QWORD *)a1 + 28) << 16);
  while ( atomic_load(qword_730D300) )
    __wfe();
  v26 = *((_QWORD *)a1 + 2);
  v27 = *((_QWORD *)a1 + 28) << 16;
  v28 = a3[112];
  v30 = *a1;
  v31 = v26;
  return sub_67F558C(a1, v27, v23, &v30, v28);
}


================================================================================
Function: sub_67FCCF0 (0x67FCCF0)
================================================================================

unsigned __int64 __fastcall sub_67FCCF0(unsigned __int64 a1, _QWORD *a2)
{
  __int64 v2; // x8
  unsigned __int64 *v5; // x11
  unsigned int *v6; // x8
  unsigned __int64 v7; // x11
  __int64 v8; // x14
  unsigned __int64 v9; // x15
  unsigned __int64 v10; // x0
  __int64 v11; // x17
  unsigned int **v12; // x1
  __int64 v13; // x0
  _QWORD *v14; // x15
  _QWORD *v15; // x15
  unsigned int *v16; // t1
  char v17; // w0
  __int64 v18; // x0
  __int64 v19; // x21
  __int64 v20; // x22
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x21
  unsigned __int64 v26; // x0
  bool v27; // zf

  v2 = *(_QWORD *)(a1 + 248);
  if ( v2 >= 1 )
  {
    v5 = (unsigned __int64 *)(a1 + 80 * v2);
    v6 = (unsigned int *)(a1 + 264);
    v7 = (unsigned __int64)(v5 + 33);
    while ( 1 )
    {
      v8 = *v6;
      if ( !v6[7] )
        break;
LABEL_4:
      v6 += 20 * v8;
      if ( (unsigned __int64)v6 >= v7 )
        goto LABEL_18;
    }
    v9 = *v6;
    if ( (unsigned int)v8 >= 2 )
    {
      v9 = *v6;
      v10 = __clz(v8 - 1);
      if ( 63 - v10 >= 3 )
        v9 = (((unsigned __int64)(v8 - 1) >> (61 - (unsigned __int8)v10)) & 3 | (4 * (63 - v10))) - 4;
    }
    v11 = *((_QWORD *)v6 + 8);
    if ( v11 )
      *(_QWORD *)(v11 + 56) = *((_QWORD *)v6 + 7);
    v12 = (unsigned int **)&a2[3 * v9];
    v13 = *((_QWORD *)v6 + 7);
    if ( *v12 == v6 )
    {
      *v12 = (unsigned int *)v13;
      if ( !v13 )
        goto LABEL_14;
    }
    else if ( !v13 )
    {
LABEL_14:
      v14 = &a2[3 * v9];
      v16 = (unsigned int *)v14[1];
      v15 = v14 + 1;
      if ( v16 == v6 )
        *v15 = *((_QWORD *)v6 + 8);
      *((_QWORD *)v6 + 7) = 0LL;
      *((_QWORD *)v6 + 8) = 0LL;
      v6[7] = 0;
      goto LABEL_4;
    }
    *(_QWORD *)(v13 + 64) = v11;
    goto LABEL_14;
  }
LABEL_18:
  v17 = sub_67F8510(12LL);
  sub_67FD794(a1, v17 & 1, a2[112]);
  sub_67FF620(a2[112] + 224LL, 1LL);
  v18 = a2[112];
  v19 = -65536LL * *(_QWORD *)(a1 + 224);
  if ( v19 < 0 )
  {
    sub_67FF704(v18, 1LL);
    v20 = -1LL;
  }
  else
  {
    v20 = 1LL;
    sub_67FF620(v18, 1LL);
  }
  v21 = a2[109];
  v22 = a2[108] + v20;
  a2[108] = v22;
  if ( v22 > v21 )
    a2[109] = v22;
  v23 = a2[111];
  v24 = a2[110] + v19;
  a2[110] = v24;
  if ( v24 > v23 )
    a2[111] = v24;
  atomic_store(0LL, (unsigned __int64 *)(a1 + 256));
  atomic_store(0LL, (unsigned __int64 *)(a1 + 176));
  *(_QWORD *)(a1 + 200) = 1LL;
  v25 = qword_730D340;
  do
  {
    atomic_store(v25 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(a1 + 176));
    v26 = sub_6866FE0(v25, ((_DWORD)v25 + 1) & 0x1FFFFFF | a1, (atomic_ullong *)&qword_730D340);
    v27 = v26 == v25;
    v25 = v26;
  }
  while ( !v27 );
  return sub_6867420(1uLL, (atomic_ullong *)&unk_730D380);
}


================================================================================
Function: sub_67FCEEC (0x67FCEEC)
================================================================================

unsigned __int64 __fastcall sub_67FCEEC(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x9
  unsigned __int64 v3; // x20
  unsigned __int64 result; // x0

  v2 = a2[112];
  v3 = (a1 - 1) & 0xFFFFFFFFFE000000LL;
  *(_UNKNOWN ***)((char *)off_C0 + v3) = (_UNKNOWN **)(*(char **)((char *)off_C0 + v3) + 1);
  result = sub_67FF620(v2 + 256, 1LL);
  if ( *(_QWORD *)(v3 + 208) == *(_QWORD *)(v3 + 192) )
    return sub_67FCCF0(v3, a2);
  return result;
}


================================================================================
Function: sub_67FCF50 (0x67FCF50)
================================================================================

__int64 __fastcall sub_67FCF50(__int64 result, __int64 a2)
{
  atomic_ullong *v2; // x19
  _QWORD *v3; // x20
  atomic_ullong *v4; // x23
  __int64 v5; // x28
  __int64 v6; // x26
  unsigned __int64 v7; // x27
  atomic_ullong *v8; // x25
  _QWORD *v9; // x23
  atomic_ullong *v10; // x20
  __int64 v11; // x8
  __int64 v12; // x19
  unsigned __int64 v13; // x28
  unsigned __int64 v14; // x0
  bool v15; // zf
  unsigned __int64 v16; // x27
  unsigned __int64 v17; // x26
  unsigned __int64 v18; // x0
  __int64 v19; // [xsp+0h] [xbp-10h]

  v2 = (atomic_ullong *)&qword_730D3C0;
  v3 = &unk_730D000;
  v4 = (atomic_ullong *)&unk_730D380;
  v19 = result;
LABEL_2:
  if ( !((unsigned __int64)qword_730D340 >> 25) )
  {
    if ( !v3[120] )
      return result;
    result = sub_6867270(0LL, v2);
    if ( !result )
      return result;
    v5 = qword_730D340;
    v6 = result;
    if ( (unsigned __int64)qword_730D340 >> 25
      || (v7 = qword_730D400,
          sub_6867020(
            qword_730D340,
            ((_DWORD)qword_730D340 + 1) & 0x1FFFFFF | (unsigned __int64)result,
            (atomic_ullong *)&qword_730D340) != v5) )
    {
      v8 = v4;
      v9 = v3;
      v10 = v2;
      v11 = v6;
      do
      {
        v12 = v11;
        v11 = *(_QWORD *)(v11 + 176);
      }
      while ( v11 );
      v13 = qword_730D340;
      do
      {
        v7 = qword_730D400;
        atomic_store(v13 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(v12 + 176));
        v14 = sub_6866FE0(v13, ((_DWORD)v13 + 1) & 0x1FFFFFF | (unsigned __int64)v6, (atomic_ullong *)&qword_730D340);
        v15 = v14 == v13;
        v13 = v14;
      }
      while ( !v15 );
      v2 = v10;
      v3 = v9;
      v4 = v8;
    }
    sub_6867420(v7, v4);
    sub_6867420(-(__int64)v7, (atomic_ullong *)&qword_730D400);
  }
  sub_6867420(1uLL, (atomic_ullong *)qword_730D300);
  v16 = atomic_load((unsigned __int64 *)&qword_730D340);
  while ( 1 )
  {
    v17 = v16 & 0xFFFFFFFFFE000000LL;
    if ( (v16 & 0xFFFFFFFFFE000000LL) == 0 )
      return sub_6867420(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_730D300);
    v18 = sub_6867020(
            v16,
            *(_QWORD *)((char *)&dword_B0 + (v16 & 0xFFFFFFFFFE000000LL)) | ((_DWORD)v16 + 1) & 0x1FFFFFF,
            (atomic_ullong *)&qword_730D340);
    v15 = v18 == v16;
    v16 = v18;
    if ( v15 )
    {
      sub_6867420(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_730D300);
      atomic_store(0LL, (unsigned __int64 *)(v17 + 176));
      sub_6867420(0xFFFFFFFFFFFFFFFFLL, v4);
      result = sub_67FD130(v17, v19, 0LL, 0LL, a2);
      goto LABEL_2;
    }
  }
}


================================================================================
Function: sub_67FD130 (0x67FD130)
================================================================================

__int64 __fastcall sub_67FD130(__int64 a1, unsigned __int64 a2, __int64 a3, _BYTE *a4, _QWORD *a5)
{
  __int64 v9; // x20
  __int64 v10; // x8
  unsigned __int64 v11; // x0
  __int64 v12; // x24
  __int64 v13; // x25
  unsigned __int64 v14; // x9
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x8
  __int64 v18; // x8
  __int64 v19; // x9
  unsigned __int64 v20; // x27
  unsigned __int64 *v21; // x24
  __int64 v22; // x0
  _BOOL4 v23; // w8

  v9 = a1;
  if ( a4 )
    *a4 = 0;
  atomic_store(sub_67F6EC4(), (unsigned __int64 *)(a1 + 256));
  v10 = *(_QWORD *)(v9 + 224);
  *(_QWORD *)(v9 + 200) = 0LL;
  v11 = a5[112];
  v12 = v10 << 16;
  if ( v10 << 16 < 0 )
  {
    sub_67FF704(v11, 1uLL);
    v13 = -1LL;
  }
  else
  {
    v13 = 1LL;
    sub_67FF620(v11, 1LL);
  }
  v14 = a5[109];
  v15 = a5[108] + v13;
  a5[108] = v15;
  if ( v15 > v14 )
    a5[109] = v15;
  v16 = a5[111];
  v17 = a5[110] + v12;
  a5[110] = v17;
  if ( v17 > v16 )
    a5[111] = v17;
  sub_67FF704(a5[112] + 224LL, 1uLL);
  v18 = *(_QWORD *)(v9 + 248);
  v19 = *(unsigned int *)(v9 + 264);
  if ( v18 > v19 )
  {
    v20 = v9 + 264 + 80 * v18;
    v21 = (unsigned __int64 *)(v9 + 80 * v19 + 264);
    while ( *((_DWORD *)v21 + 7) )
    {
      sub_67FF704(a5[112] + 256LL, 1uLL);
      --*(_QWORD *)(v9 + 192);
      atomic_store(a2, v21 + 6);
      sub_67FA514((__int64)v21, 0, 1);
      sub_67FA750((unsigned __int64)v21, 0);
      if ( !*((_DWORD *)v21 + 6) )
      {
        v22 = sub_67FC99C((unsigned int *)v21, (__int64)a5);
        goto LABEL_13;
      }
      sub_67FA860(a2, v21);
      if ( *((_DWORD *)v21 + 7) == a3 )
      {
        if ( *((_DWORD *)v21 + 6) >= (unsigned int)*((unsigned __int16 *)v21 + 6) )
        {
          v23 = v21[5] > 3;
          if ( a4 )
          {
LABEL_23:
            if ( v23 )
              *a4 = 1;
          }
        }
        else
        {
          v23 = 1;
          if ( a4 )
            goto LABEL_23;
        }
      }
LABEL_14:
      v21 += 10 * *(unsigned int *)v21;
      if ( (unsigned __int64)v21 >= v20 )
        goto LABEL_25;
    }
    v22 = (__int64)sub_67FE16C((unsigned int *)v21, (__int64)a5);
LABEL_13:
    v21 = (unsigned __int64 *)v22;
    goto LABEL_14;
  }
LABEL_25:
  if ( !*(_QWORD *)(v9 + 208) )
  {
    sub_67FCAC4((__int128 *)v9, 0LL, a5);
    return 0LL;
  }
  return v9;
}


================================================================================
Function: sub_67FD328 (0x67FD328)
================================================================================

__int64 __fastcall sub_67FD328(__int64 result, char a2, __int64 a3)
{
  _QWORD *v5; // x20
  __int64 v6; // x20
  __int64 v7; // x21
  unsigned __int64 v8; // x22
  __int64 v9; // x8
  __int64 v10; // x20
  unsigned __int64 v11; // x25
  unsigned __int64 v12; // x0
  bool v13; // zf
  int v14; // w25
  int v15; // w8
  atomic_ullong *v16; // x24
  __int64 v17; // x20
  __int64 v18; // x27
  unsigned __int64 v19; // x28
  atomic_ullong *v20; // x25
  __int64 v21; // x24
  __int64 v22; // x8
  __int64 v23; // x23
  unsigned __int64 v24; // x20
  unsigned __int64 v25; // x0
  unsigned __int64 v26; // x28
  unsigned __int64 v27; // x27
  unsigned __int64 v28; // x0
  unsigned __int64 v29; // x20
  unsigned __int64 v30; // x0
  __int64 v32; // [xsp+0h] [xbp-10h]
  unsigned int v33; // [xsp+8h] [xbp-8h]
  int v34; // [xsp+Ch] [xbp-4h]

  v5 = &unk_730D000;
  v32 = result;
  if ( (a2 & 1) != 0 )
  {
    if ( qword_730D3C0 && (result = sub_6867270(0LL, (atomic_ullong *)&qword_730D3C0)) != 0 )
    {
      v6 = qword_730D340;
      v7 = result;
      if ( (unsigned __int64)qword_730D340 >> 25
        || (v8 = qword_730D400,
            sub_6867020(
              qword_730D340,
              ((_DWORD)qword_730D340 + 1) & 0x1FFFFFF | (unsigned __int64)result,
              (atomic_ullong *)&qword_730D340) != v6) )
      {
        v9 = v7;
        do
        {
          v10 = v9;
          v9 = *(_QWORD *)(v9 + 176);
        }
        while ( v9 );
        v11 = qword_730D340;
        do
        {
          v8 = qword_730D400;
          atomic_store(v11 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(v10 + 176));
          v12 = sub_6866FE0(v11, ((_DWORD)v11 + 1) & 0x1FFFFFF | (unsigned __int64)v7, (atomic_ullong *)&qword_730D340);
          v13 = v12 == v11;
          v11 = v12;
        }
        while ( !v13 );
      }
      sub_6867420(v8, (atomic_ullong *)&unk_730D380);
      result = sub_6867420(-(__int64)v8, (atomic_ullong *)&qword_730D400);
      v14 = 0x3FFF;
      v5 = (_QWORD *)&unk_730D000;
    }
    else
    {
      v14 = 0x3FFF;
    }
  }
  else
  {
    v14 = 1023;
  }
  v15 = a2 & 1;
  v16 = (atomic_ullong *)&qword_730D400;
  v33 = v15;
  do
  {
    if ( !((unsigned __int64)qword_730D340 >> 25) )
    {
      if ( !v5[120] )
        return result;
      result = sub_6867270(0LL, (atomic_ullong *)&qword_730D3C0);
      if ( !result )
        return result;
      v17 = qword_730D340;
      v18 = result;
      if ( (unsigned __int64)qword_730D340 >> 25
        || (v19 = qword_730D400,
            sub_6867020(
              qword_730D340,
              ((_DWORD)qword_730D340 + 1) & 0x1FFFFFF | (unsigned __int64)result,
              (atomic_ullong *)&qword_730D340) != v17) )
      {
        v34 = v14;
        v20 = v16;
        v21 = a3;
        v22 = v18;
        do
        {
          v23 = v22;
          v22 = *(_QWORD *)(v22 + 176);
        }
        while ( v22 );
        v24 = qword_730D340;
        do
        {
          v19 = qword_730D400;
          atomic_store(v24 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(v23 + 176));
          v25 = sub_6866FE0(v24, ((_DWORD)v24 + 1) & 0x1FFFFFF | (unsigned __int64)v18, (atomic_ullong *)&qword_730D340);
          v13 = v25 == v24;
          v24 = v25;
        }
        while ( !v13 );
        a3 = v21;
        v5 = &unk_730D000;
        v16 = v20;
        v14 = v34;
      }
      else
      {
        v5 = (_QWORD *)&unk_730D000;
      }
      sub_6867420(v19, (atomic_ullong *)&unk_730D380);
      sub_6867420(-(__int64)v19, v16);
    }
    sub_6867420(1uLL, (atomic_ullong *)qword_730D300);
    v26 = atomic_load((unsigned __int64 *)&qword_730D340);
    do
    {
      v27 = v26 & 0xFFFFFFFFFE000000LL;
      if ( (v26 & 0xFFFFFFFFFE000000LL) == 0 )
        return sub_6867420(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_730D300);
      v28 = sub_6867020(
              v26,
              *(_QWORD *)((char *)&dword_B0 + (v26 & 0xFFFFFFFFFE000000LL)) | ((_DWORD)v26 + 1) & 0x1FFFFFF,
              (atomic_ullong *)&qword_730D340);
      v13 = v28 == v26;
      v26 = v28;
    }
    while ( !v13 );
    sub_6867420(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_730D300);
    atomic_store(0LL, (unsigned __int64 *)(v27 + 176));
    sub_6867420(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)&unk_730D380);
    sub_67FD678(v27, 0LL, 0LL, a3);
    if ( *(_QWORD *)(v27 + 208) )
    {
      sub_67FD794(v27, v33, *(_QWORD *)(a3 + 896));
      v29 = v5[120];
      do
      {
        atomic_store(v29, (unsigned __int64 *)(v27 + 176));
        v30 = sub_6866FE0(v29, v27, (atomic_ullong *)&qword_730D3C0);
        v13 = v30 == v29;
        v29 = v30;
      }
      while ( !v13 );
      result = sub_6867420(1uLL, v16);
      v5 = (_QWORD *)&unk_730D000;
    }
    else
    {
      result = sub_67FD130(v27, v32, 0LL, 0LL, a3);
    }
  }
  while ( v14-- > 0 );
  return result;
}


================================================================================
Function: sub_67FD678 (0x67FD678)
================================================================================

__int64 __fastcall sub_67FD678(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x8
  __int64 v5; // x9
  unsigned __int64 v8; // x26
  char v11; // w24
  unsigned int *v12; // x23
  unsigned __int64 v13; // x8
  bool v14; // w8
  unsigned int v15; // w8
  unsigned int *v16; // x0

  v4 = *(_QWORD *)(a1 + 248);
  v5 = *(unsigned int *)(a1 + 264);
  if ( v4 > v5 )
  {
    v8 = a1 + 264 + 80 * v4;
    v11 = 0;
    v12 = (unsigned int *)(a1 + 80 * v5 + 264);
    while ( v12[7] )
    {
      sub_67FA750((unsigned __int64)v12, 0);
      v15 = v12[6];
      if ( !v15 )
      {
        sub_67FF704(*(_QWORD *)(a4 + 896) + 256LL, 1uLL);
        --*(_QWORD *)(a1 + 192);
        v16 = (unsigned int *)sub_67FC99C(v12, a4);
        v13 = *v16;
        v12 = v16;
        goto LABEL_4;
      }
      if ( v12[7] != a3 )
        goto LABEL_6;
      v14 = v15 < *((unsigned __int16 *)v12 + 6) || *((_QWORD *)v12 + 5) > 3uLL;
LABEL_5:
      v11 |= v14;
LABEL_6:
      v12 += 20 * *v12;
      if ( (unsigned __int64)v12 >= v8 )
        return v11 & 1;
    }
    v13 = *v12;
LABEL_4:
    v14 = v13 >= a2;
    goto LABEL_5;
  }
  v11 = 0;
  return v11 & 1;
}


================================================================================
Function: sub_67FD794 (0x67FD794)
================================================================================

__int64 __fastcall sub_67FD794(__int64 result, char a2, __int64 a3)
{
  __int64 v4; // x20
  _OWORD *v6; // x23
  __int128 v7; // q1
  unsigned __int64 v8; // x24
  __int128 v9; // q2
  __int128 v10; // q3
  unsigned __int64 v11; // x10
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x9
  __int64 v14; // x11
  __int64 v15; // x12
  __int64 v16; // x13
  unsigned __int64 v17; // x11
  char v18; // w13
  __int64 v19; // x15
  unsigned __int64 v20; // x12
  __int64 v21; // x14
  __int64 v22; // x2
  char v23; // w15
  _OWORD v24[4]; // [xsp+0h] [xbp-50h]

  if ( *(_BYTE *)(result + 25) )
  {
    v4 = result;
    v6 = (_OWORD *)(result + 48);
    if ( *(_QWORD *)(result + 48)
      || *(_QWORD *)(result + 56)
      || *(_QWORD *)(result + 64)
      || *(_QWORD *)(result + 72)
      || *(_QWORD *)(result + 80)
      || *(_QWORD *)(result + 88)
      || *(_QWORD *)(result + 96)
      || *(_QWORD *)(result + 104) )
    {
      result = sub_6800364();
      if ( (a2 & 1) != 0 || result >= *(_QWORD *)(v4 + 40) )
      {
        v7 = v6[1];
        v8 = 0LL;
        v9 = v6[2];
        v10 = v6[3];
        v24[0] = *v6;
        v24[1] = v7;
        *(_OWORD *)(v4 + 40) = 0u;
        *(_OWORD *)(v4 + 56) = 0u;
        *(_OWORD *)(v4 + 72) = 0u;
        *(_OWORD *)(v4 + 88) = 0u;
        v24[2] = v9;
        v24[3] = v10;
        *(_QWORD *)(v4 + 104) = 0LL;
        while ( 1 )
        {
          v11 = v8 >> 6;
          v12 = v8 & 0x3F;
          v13 = v8 >> 6 << 6;
          if ( v8 >> 6 <= 7 )
            v14 = 7LL;
          else
            v14 = v8 >> 6;
          v15 = -64LL * (v8 >> 6);
          v16 = v14 + 1;
          while ( 1 )
          {
            v17 = *((_QWORD *)v24 + v11) >> v12;
            if ( v17 )
              break;
            v12 = 0LL;
            ++v11;
            v15 -= 64LL;
            v13 += 64LL;
            if ( v16 == v11 )
              return result;
          }
          if ( (v17 & 1) == 0 )
          {
            do
            {
              v18 = v17;
              v17 >>= 1;
              ++v12;
            }
            while ( (v18 & 2) == 0 );
            if ( v11 > 7 )
              return result;
          }
          v19 = 0LL;
          v20 = v12 - v15;
          do
          {
            v21 = -v19;
            v22 = v19 << 16;
            do
            {
              v23 = v17;
              v17 >>= 1;
              --v21;
              v22 += 0x10000LL;
            }
            while ( (v23 & 2) != 0 );
            if ( (((_BYTE)v12 + (_BYTE)v13 - (_BYTE)v21) & 0x3F) != 0 )
              goto LABEL_26;
            if ( ++v11 > 7 )
              break;
            v17 = *((_QWORD *)v24 + v11);
LABEL_26:
            v19 = -v21;
          }
          while ( (v17 & 1) != 0 );
          if ( v21 )
          {
            v8 = v12 + v13 - v21;
            result = sub_67FE654(v4, v4 + (v20 << 16), v22, a3);
            if ( v8 < 0x200 )
              continue;
          }
          return result;
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67FD960 (0x67FD960)
================================================================================

unsigned __int64 __fastcall sub_67FD960(unsigned __int64 result, __int64 a2, __int64 a3)
{
  if ( *(_BYTE *)(result + 24) )
  {
    result = sub_67F3C88(a3);
    if ( result >= 9 )
      return sub_67F9CB4(a3 + 8, result - 8, &unk_7304F00);
  }
  return result;
}


================================================================================
Function: sub_67FD9B0 (0x67FD9B0)
================================================================================

__int64 __fastcall sub_67FD9B0(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x29
  __int64 v6; // x30
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x2
  unsigned int v10; // w9
  unsigned __int64 v11; // x0
  __int64 v12; // x1
  __int64 v13; // x2
  unsigned int v14; // w9
  unsigned __int64 v15; // x19
  __int64 v16; // x0
  __int64 v17; // x1
  __int64 v18; // x21
  __int64 v19; // x8
  unsigned __int64 v20; // x9
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x9
  __int64 v23; // x9
  _QWORD v24[4]; // [xsp+0h] [xbp-40h] BYREF

  v7 = a2;
  if ( a3 >= 0x1000001 )
  {
    v14 = *(_DWORD *)(a1 + 2856);
    v11 = a2;
    if ( a3 <= 0x2000000 )
      v12 = 0x2000000LL;
    else
      v12 = a3;
    v13 = v14;
  }
  else
  {
    if ( a2 <= 0x4000 )
      goto LABEL_3;
    if ( a2 <= 0x20000 )
    {
      a2 = 0x80000LL;
      v8 = v7;
      return sub_67FDB54(a1, a2, v8);
    }
    if ( a2 < 0x1000001 )
    {
LABEL_3:
      v8 = a2;
      return sub_67FDB54(a1, a2, v8);
    }
    v10 = *(_DWORD *)(a1 + 2856);
    v11 = a2;
    v12 = a3;
    v13 = v10;
  }
  v24[2] = v5;
  v24[3] = v6;
  v15 = v12;
  v24[0] = 0LL;
  v16 = sub_67FEA14(v11, v12, v13, a4, a5, v24);
  v17 = 0LL;
  if ( v16 )
  {
    v18 = v24[0];
    if ( v24[0] )
    {
      v19 = *(unsigned int *)(v24[0] + 28LL);
      if ( (unsigned int)v19 < 8 )
      {
        v19 = 0LL;
      }
      else if ( (unsigned int)v19 > 0x40 )
      {
        if ( (unsigned int)v19 >= 0x201 )
          v19 = 0LL;
      }
      else
      {
        v19 *= 3LL;
      }
      v20 = ((unsigned __int64)*(unsigned int *)v24[0] << 16) - v19;
      if ( v20 >> 31 )
        LODWORD(v20) = 0x80000000;
      *(_DWORD *)(v24[0] + 28LL) = v20;
      if ( v15 && *(_BYTE *)(v16 + 24) )
      {
        v21 = v16 + v19 - 0x3333333333330000LL * ((unsigned __int64)(v18 - v16 - 264) >> 4);
        v22 = v15 - 1 + v21;
        if ( (v15 & (v15 - 1)) != 0 )
          v23 = v22 / v15 * v15;
        else
          v23 = v22 & -(__int64)v15;
        sub_67F9CB4(v21 + 8, v23 - (v21 + 8), &unk_7304F00);
      }
      return v18;
    }
  }
  return v17;
}


================================================================================
Function: sub_67FDB54 (0x67FDB54)
================================================================================

__int64 __fastcall sub_67FDB54(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x8
  __int64 v6; // x10
  void *v7; // x22
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x8
  __int64 v11; // x19
  unsigned __int64 v12; // x12
  unsigned int v14; // w20
  unsigned __int64 v15; // x21
  signed __int64 v16; // x8
  unsigned __int64 v17; // x10
  unsigned __int64 v18; // x27
  unsigned int **v19; // x23
  unsigned int *v20; // x25
  unsigned __int64 v21; // x26
  __int128 v22; // q0
  __int64 v23; // x9
  unsigned int *v24; // x10
  unsigned __int64 v25; // x2
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x9
  __int64 *v28; // x10
  unsigned __int64 v29; // x11
  unsigned __int64 v30; // x12
  unsigned __int64 v31; // x11
  _DWORD *v32; // x12
  unsigned __int64 v33; // x11
  unsigned __int64 v34; // x9
  __int64 v35; // x12
  unsigned __int64 *v36; // x9
  unsigned __int64 *v37; // x10
  __int64 v38; // x0
  __int64 v39; // x20
  __int64 v40; // x0
  __int64 v41; // x23
  __int64 v42; // x27
  unsigned __int64 v43; // x0
  __int64 v44; // x28
  unsigned __int64 v45; // x20
  unsigned __int64 v46; // x27
  __int64 v47; // x19
  __int64 v48; // x23
  void *v49; // x24
  unsigned __int64 v50; // x8
  unsigned __int64 v51; // x22
  unsigned __int64 v52; // x28
  unsigned __int64 v53; // x0
  bool v54; // zf
  unsigned __int64 v55; // x28
  unsigned __int64 v56; // x20
  unsigned __int64 v57; // x0
  __int128 v58; // q0
  __int64 v59; // x8
  int v60; // w28
  int v61; // w0
  unsigned __int64 v62; // x28
  unsigned __int64 v63; // x0
  __int64 v65; // [xsp+10h] [xbp-50h]
  unsigned __int64 v67; // [xsp+20h] [xbp-40h]
  __int64 v68; // [xsp+28h] [xbp-38h]
  char v70[4]; // [xsp+3Ch] [xbp-24h] BYREF
  __int128 v71; // [xsp+40h] [xbp-20h] BYREF
  __int64 v72; // [xsp+50h] [xbp-10h]

  v5 = 0x10000LL;
  v6 = -65536LL;
  v7 = &_stack_chk_guard;
  if ( a2 > 0x80000 )
    v5 = 0x80000LL;
  v8 = a2 + v5;
  if ( a2 > 0x80000 )
    v6 = -524288LL;
  v9 = v6 & (v8 - 1);
  v11 = a4;
  v12 = v9 >> 16;
  v14 = *(_DWORD *)(a1 + 2856);
  v67 = v9 >> 16;
  if ( v9 >= 0x20000 )
  {
    v17 = __clz(v12 - 1);
    v16 = v9 >> 16;
    if ( 63 - v17 >= 3 )
      v16 = (((v12 - 1) >> (61 - (unsigned __int8)v17)) & 3 | (4 * (63 - v17))) - 4;
    v15 = v12;
    if ( v16 > 35 )
    {
LABEL_46:
      v70[0] = 0;
      v40 = sub_67F841C(0x15u, 8LL, 1024LL);
      v41 = a1;
      if ( v40 < 1 )
      {
LABEL_79:
        if ( sub_67FEA14(0LL, 0LL, *(unsigned int *)(v41 + 2856), v11, a5, 0LL) )
          return sub_67FDB54(v41, a2, a3);
        return 0LL;
      }
      v42 = v40;
      v65 = v11;
      while ( 2 )
      {
        v68 = v42;
        if ( !((unsigned __int64)qword_730D340 >> 25) )
        {
          if ( !qword_730D3C0 )
          {
LABEL_76:
            v43 = 0LL;
LABEL_77:
            if ( v70[0] )
              return 0LL;
            goto LABEL_78;
          }
          v43 = sub_6867270(0LL, (atomic_ullong *)&qword_730D3C0);
          if ( !v43 )
            goto LABEL_77;
          v44 = qword_730D340;
          v45 = v43;
          if ( (unsigned __int64)qword_730D340 >> 25
            || (v46 = qword_730D400,
                sub_6867020(
                  qword_730D340,
                  ((_DWORD)qword_730D340 + 1) & 0x1FFFFFF | v43,
                  (atomic_ullong *)&qword_730D340) != v44) )
          {
            v47 = v41;
            v48 = a5;
            v49 = v7;
            v50 = v45;
            do
            {
              v51 = v50;
              v50 = *(_QWORD *)(v50 + 176);
            }
            while ( v50 );
            v52 = qword_730D340;
            do
            {
              v46 = qword_730D400;
              atomic_store(v52 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(v51 + 176));
              v53 = sub_6866FE0(v52, ((_DWORD)v52 + 1) & 0x1FFFFFF | v45, (atomic_ullong *)&qword_730D340);
              v54 = v53 == v52;
              v52 = v53;
            }
            while ( !v54 );
            v7 = v49;
            a5 = v48;
            v41 = v47;
            v11 = v65;
          }
          sub_6867420(v46, (atomic_ullong *)&unk_730D380);
          sub_6867420(-(__int64)v46, (atomic_ullong *)&qword_730D400);
        }
        v42 = v68 - 1;
        sub_6867420(1uLL, (atomic_ullong *)qword_730D300);
        v55 = atomic_load((unsigned __int64 *)&qword_730D340);
        do
        {
          v56 = v55 & 0xFFFFFFFFFE000000LL;
          if ( (v55 & 0xFFFFFFFFFE000000LL) == 0 )
          {
            sub_6867420(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_730D300);
            goto LABEL_76;
          }
          v57 = sub_6867020(
                  v55,
                  *(_QWORD *)((char *)&dword_B0 + (v55 & 0xFFFFFFFFFE000000LL)) | ((_DWORD)v55 + 1) & 0x1FFFFFF,
                  (atomic_ullong *)&qword_730D340);
          v54 = v57 == v55;
          v55 = v57;
        }
        while ( !v54 );
        sub_6867420(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_730D300);
        atomic_store(0LL, (unsigned __int64 *)(v56 + 176));
        sub_6867420(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)&unk_730D380);
        v58 = *(_OWORD *)v56;
        v59 = *(_QWORD *)(v56 + 200) + 1LL;
        v72 = *(_QWORD *)(v56 + 16);
        v71 = v58;
        *(_QWORD *)(v56 + 200) = v59;
        v60 = sub_67F4CF0(v41, &v71);
        v61 = sub_67FD678(v56, v67, a3, v11);
        if ( !*(_QWORD *)(v56 + 208) )
          goto LABEL_68;
        if ( (v61 & v60 & 1) != 0 )
        {
          v43 = sub_67FD130(v56, v41, a3, v70, v11);
          if ( v70[0] )
            return 0LL;
LABEL_78:
          if ( v43 )
            return sub_67FDB54(v41, a2, a3);
          goto LABEL_79;
        }
        if ( *(_QWORD *)(v56 + 200) < 4uLL || ((v60 ^ 1) & 1) != 0 )
        {
          sub_67FD794(v56, 1, *(_QWORD *)(v11 + 896));
          v62 = qword_730D3C0;
          do
          {
            atomic_store(v62, (unsigned __int64 *)(v56 + 176));
            v63 = sub_6866FE0(v62, v56, (atomic_ullong *)&qword_730D3C0);
            v54 = v63 == v62;
            v62 = v63;
          }
          while ( !v54 );
          sub_6867420(1uLL, (atomic_ullong *)&qword_730D400);
        }
        else
        {
LABEL_68:
          sub_67FD130(v56, v41, 0LL, 0LL, v11);
        }
        if ( v68 > 1 )
          continue;
        goto LABEL_76;
      }
    }
  }
  else
  {
    v15 = 1LL;
    v16 = v9 >> 16;
  }
  v18 = a4 + 840;
  v19 = (unsigned int **)(a4 + 24 * v16);
  while ( 1 )
  {
    v20 = *v19;
    if ( *v19 )
      break;
LABEL_11:
    v19 += 3;
    if ( (unsigned __int64)v19 > v18 )
      goto LABEL_46;
  }
  while ( 1 )
  {
    if ( v15 <= *v20 )
    {
      v21 = ((unsigned __int64)v20 - 1) & 0xFFFFFFFFFE000000LL;
      v22 = *(_OWORD *)v21;
      v72 = *(_QWORD *)((char *)&word_10 + v21);
      v71 = v22;
      if ( (sub_67F50D0(&v71, v14) & 1) != 0 )
        break;
    }
    v20 = (unsigned int *)*((_QWORD *)v20 + 7);
    if ( !v20 )
      goto LABEL_11;
  }
  v23 = *((_QWORD *)v20 + 8);
  if ( v23 )
    *(_QWORD *)(v23 + 56) = *((_QWORD *)v20 + 7);
  v24 = (unsigned int *)*((_QWORD *)v20 + 7);
  if ( *v19 == v20 )
    *v19 = v24;
  if ( v24 )
    *((_QWORD *)v24 + 8) = v23;
  if ( v19[1] == v20 )
    v19[1] = (unsigned int *)*((_QWORD *)v20 + 8);
  v25 = *v20;
  *((_QWORD *)v20 + 7) = 0LL;
  *((_QWORD *)v20 + 8) = 0LL;
  v20[7] = 1;
  if ( v15 < v25 )
  {
    v26 = v15 - 0x3333333333333333LL * ((__int64)((__int64)v20 - v21 - 264) >> 4);
    v27 = v25 - v15;
    if ( *(_DWORD *)((char *)&qword_F0 + (((unsigned __int64)v20 - 1) & 0xFFFFFFFFFE000000LL)) == 1 )
    {
      v28 = 0LL;
    }
    else
    {
      v28 = (__int64 *)atomic_load((unsigned __int64 *)(v21 + 256));
      if ( v28 )
      {
        if ( v27 >= 2 )
        {
          v30 = __clz(v27 - 1);
          v29 = v25 - v15;
          if ( 63 - v30 >= 3 )
            v29 = (((v27 - 1) >> (61 - (unsigned __int8)v30)) & 3 | (4 * (63 - v30))) - 4;
        }
        else
        {
          v29 = v25 - v15;
        }
        v28 = (__int64 *)(v11 + 24 * v29);
      }
    }
    if ( !v27 )
      v27 = 1LL;
    v31 = v21 + 80 * v26;
    *(_DWORD *)(v31 + 264) = v27;
    *(_DWORD *)(v31 + 268) = 0;
    if ( v27 >= 2 )
    {
      v32 = (_DWORD *)(v21 + 80 * (v26 + v27));
      v32[46] = 0;
      v32[47] = 80 * v27 - 80;
      v32[53] = 0;
    }
    if ( v28 )
    {
      v33 = v31 + 264;
      v34 = v21 + 80 * v26;
      *(_QWORD *)(v34 + 328) = 0LL;
      v35 = *v28;
      *(_QWORD *)(v34 + 320) = *v28;
      v36 = (unsigned __int64 *)(v35 + 64);
      *v28 = v33;
      v37 = (unsigned __int64 *)(v28 + 1);
      if ( !v35 )
        v36 = v37;
      *v36 = v33;
    }
    v25 = (unsigned int)v15;
    *(int *)((char *)&dword_124[20 * v26] + (((unsigned __int64)v20 - 1) & 0xFFFFFFFFFE000000LL)) = 0;
    *v20 = v15;
  }
  v38 = sub_67FEF4C(
          ((unsigned __int64)v20 - 1) & 0xFFFFFFFFFE000000LL,
          0xCCCCCCCCCCCCCCCDLL * ((__int64)((__int64)v20 - v21 - 264) >> 4),
          v25,
          v11);
  if ( !v38 )
  {
    sub_67FE16C(v20, v11);
    goto LABEL_46;
  }
  v39 = v38;
  sub_67FD794((v38 - 1) & 0xFFFFFFFFFE000000LL, 0, *(_QWORD *)(v11 + 896));
  return v39;
}


================================================================================
Function: sub_67FE16C (0x67FE16C)
================================================================================

unsigned int *__fastcall sub_67FE16C(unsigned int *a1, __int64 a2)
{
  unsigned int *v2; // x19
  unsigned __int64 v3; // x0
  unsigned __int64 v4; // x8
  __int64 v5; // x11
  unsigned int *v6; // x10
  unsigned int *v7; // x9
  _DWORD *v8; // x9
  unsigned int v9; // t1
  char *v10; // x9
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x10
  __int64 v13; // x10
  unsigned int **v14; // x12
  __int64 v15; // x11
  __int64 v16; // x9
  _QWORD *v17; // x9
  unsigned int *v18; // t1
  unsigned __int64 v20; // x12
  unsigned __int64 v21; // x14
  unsigned int *v22; // x13
  _QWORD *v23; // x13
  __int64 v24; // x14
  __int64 v25; // t1
  unsigned int **v26; // x15
  unsigned int *v27; // x11
  _QWORD *v28; // x11
  __int64 v29; // x16
  __int64 v30; // t1
  __int64 v31; // x12
  _QWORD *v32; // x12
  unsigned int *v33; // t1

  v2 = a1;
  v3 = ((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL;
  v4 = atomic_load((unsigned __int64 *)(v3 | 0x100));
  if ( *(_DWORD *)(v3 + 240) == 1 )
  {
    v2[7] = 0;
  }
  else
  {
    v5 = *v2;
    v6 = &v2[20 * v5];
    if ( (unsigned __int64)v6 < v3 + 80LL * *(_QWORD *)(v3 + 248) + 264 )
    {
      v7 = &v2[20 * v5];
      v9 = v7[7];
      v8 = v7 + 7;
      if ( !v9 )
      {
        v20 = *v6;
        if ( v4 )
        {
          if ( (unsigned int)v20 >= 2 )
          {
            v21 = __clz(v20 - 1);
            if ( 63 - v21 >= 3 )
              v20 = (((v20 - 1) >> (61 - (unsigned __int8)v21)) & 3 | (4 * (63 - v21))) - 4;
          }
          v22 = &v2[20 * v5];
          v25 = *((_QWORD *)v22 + 8);
          v23 = v22 + 16;
          v24 = v25;
          if ( v25 )
            *(_QWORD *)(v24 + 56) = *(_QWORD *)&v2[20 * v5 + 14];
          v26 = (unsigned int **)(a2 + 24 * v20);
          v27 = &v2[20 * v5];
          v30 = *((_QWORD *)v27 + 7);
          v28 = v27 + 14;
          v29 = v30;
          if ( *v26 == v6 )
            *v26 = (unsigned int *)v29;
          if ( v29 )
            *(_QWORD *)(v29 + 64) = v24;
          v31 = a2 + 24 * v20;
          v33 = *(unsigned int **)(v31 + 8);
          v32 = (_QWORD *)(v31 + 8);
          if ( v33 == v6 )
            *v32 = *v23;
          *v28 = 0LL;
          v28[1] = 0LL;
          *v8 = 1;
        }
      }
    }
    if ( v3 + 264 < (unsigned __int64)v2 )
    {
      v10 = (char *)v2 - *(v2 - 19);
      if ( !*((_DWORD *)v10 - 13) )
      {
        v2 = (unsigned int *)(v10 - 80);
        v11 = *((unsigned int *)v10 - 20);
        if ( v4 )
        {
          if ( (unsigned int)v11 >= 2 )
          {
            v12 = __clz(v11 - 1);
            if ( 63 - v12 >= 3 )
              v11 = (((v11 - 1) >> (61 - (unsigned __int8)v12)) & 3 | (4 * (63 - v12))) - 4;
          }
          v13 = *((_QWORD *)v2 + 8);
          if ( v13 )
            *(_QWORD *)(v13 + 56) = *((_QWORD *)v2 + 7);
          v14 = (unsigned int **)(a2 + 24 * v11);
          v15 = *((_QWORD *)v2 + 7);
          if ( *v14 == v2 )
            *v14 = (unsigned int *)v15;
          if ( v15 )
            *(_QWORD *)(v15 + 64) = v13;
          v16 = a2 + 24 * v11;
          v18 = *(unsigned int **)(v16 + 8);
          v17 = (_QWORD *)(v16 + 8);
          if ( v18 == v2 )
            *v17 = *((_QWORD *)v2 + 8);
          *((_QWORD *)v2 + 7) = 0LL;
          *((_QWORD *)v2 + 8) = 0LL;
          v2[7] = 1;
        }
      }
    }
    sub_67FE388();
  }
  return v2;
}


================================================================================
Function: sub_67FE388 (0x67FE388)
================================================================================

void __fastcall sub_67FE388(__int64 a1, __int64 a2, unsigned __int64 a3, char a4, __int64 a5)
{
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x10
  __int64 *v10; // x25
  unsigned __int64 v11; // x8
  __int64 v12; // x9
  _DWORD *v13; // x10
  __int64 v14; // x26
  __int64 v15; // x21
  unsigned __int64 v16; // x23
  bool v17; // w9
  int8x16_t v18; // q3
  int8x16_t v19; // q5
  int8x16_t v20; // q2
  int8x16_t v21; // q1
  __int64 v22; // x0
  __int64 v23; // x23
  __int64 v24; // x22
  __int64 v25; // x0
  __int64 v26; // x8
  unsigned int v27; // w0
  __int64 v28; // x8
  __int64 v29; // x9
  __int64 *v30; // x8
  __int64 *v31; // x25
  __int64 v32; // [xsp+0h] [xbp-60h] BYREF
  char v33[8]; // [xsp+8h] [xbp-58h] BYREF
  int8x16_t v34; // [xsp+10h] [xbp-50h] BYREF
  int8x16_t v35; // [xsp+20h] [xbp-40h]
  int8x16_t v36; // [xsp+30h] [xbp-30h]
  int8x16_t v37; // [xsp+40h] [xbp-20h]

  if ( *(_DWORD *)(a1 + 240) == 1 || (v7 = atomic_load((unsigned __int64 *)(a1 + 256))) == 0 )
  {
    v10 = 0LL;
  }
  else
  {
    v8 = a3;
    if ( a3 >= 2 )
    {
      v9 = __clz(a3 - 1);
      v8 = a3;
      if ( 63 - v9 >= 3 )
        v8 = (((a3 - 1) >> (61 - (unsigned __int8)v9)) & 3 | (4 * (63 - v9))) - 4;
    }
    v10 = (__int64 *)(a5 + 24 * v8);
  }
  if ( a3 )
    v11 = a3;
  else
    v11 = 1LL;
  v12 = a1 + 80 * a2;
  *(_DWORD *)(v12 + 264) = v11;
  *(_DWORD *)(v12 + 268) = 0;
  if ( v11 >= 2 )
  {
    v13 = (_DWORD *)(a1 + 80 * (a2 + v11));
    v13[46] = 0;
    v13[47] = 80 * v11 - 80;
    v13[53] = 0;
  }
  v14 = v12 + 264;
  if ( (a4 & 1) == 0 || !*(_BYTE *)(a1 + 25) )
    goto LABEL_33;
  v15 = *(_QWORD *)(a5 + 896);
  v16 = v11 << 16;
  if ( !sub_67F7E08(0xFu) )
  {
    sub_67FE654(a1);
    if ( !v10 )
      goto LABEL_37;
    goto LABEL_34;
  }
  v32 = 0LL;
  sub_67FE880(
    a1,
    1LL,
    ((v14 - 1) & 0xFFFFFFFFFE000000LL) - 0x3333333333330000LL * ((v14 - ((v14 - 1) & 0xFFFFFFFFFE000000LL) - 264) >> 4),
    v16,
    v33,
    &v32,
    &v34);
  v17 = 0;
  if ( !v34.n128_u64[0]
    && __PAIR128__(v34.n128_u64[1], 0LL) == v35.n128_u64[0]
    && __PAIR128__(v35.n128_u64[1], 0LL) == v36.n128_u64[0]
    && __PAIR128__(v36.n128_u64[1], 0LL) == v37.n128_u64[0] )
  {
    v17 = v37.n128_u64[1] == 0;
  }
  if ( v17 || !v32 )
  {
LABEL_33:
    if ( !v10 )
      goto LABEL_37;
    goto LABEL_34;
  }
  v18 = vandq_s8(*(int8x16_t *)(a1 + 160), v37);
  v19 = *(int8x16_t *)(a1 + 96);
  v20 = vorrq_s8(*(int8x16_t *)(a1 + 64), vandq_s8(*(int8x16_t *)(a1 + 128), v35));
  v21 = vorrq_s8(*(int8x16_t *)(a1 + 80), vandq_s8(*(int8x16_t *)(a1 + 144), v36));
  *(int8x16_t *)(a1 + 48) = vorrq_s8(*(int8x16_t *)(a1 + 48), vandq_s8(*(int8x16_t *)(a1 + 112), v34));
  *(int8x16_t *)(a1 + 64) = v20;
  *(int8x16_t *)(a1 + 80) = v21;
  *(int8x16_t *)(a1 + 96) = vorrq_s8(v19, v18);
  v22 = sub_6800364();
  v23 = *(_QWORD *)(a1 + 40);
  v24 = v22;
  if ( !v23 )
  {
    v27 = 15;
LABEL_31:
    v26 = sub_67F7E08(v27) + v24;
    goto LABEL_32;
  }
  v25 = sub_67F7E08(0x19u);
  if ( v23 > v24 )
  {
    v26 = *(_QWORD *)(a1 + 40) + v25;
LABEL_32:
    *(_QWORD *)(a1 + 40) = v26;
    goto LABEL_33;
  }
  if ( v25 + v23 > v24 )
  {
    v27 = 25;
    goto LABEL_31;
  }
  sub_67FD794(a1, 1, v15);
  if ( !v10 )
    goto LABEL_37;
LABEL_34:
  v28 = a1 + 80 * a2;
  *(_QWORD *)(v28 + 328) = 0LL;
  v29 = *v10;
  *(_QWORD *)(v28 + 320) = *v10;
  v30 = (__int64 *)(v29 + 64);
  *v10 = v14;
  v31 = v10 + 1;
  if ( !v29 )
    v30 = v31;
  *v30 = v14;
LABEL_37:
  *(_DWORD *)(a1 + 80 * a2 + 292) = 0;
}


================================================================================
Function: sub_67FE654 (0x67FE654)
================================================================================

long double __fastcall sub_67FE654(__int64 a1)
{
  long double result; // q0

  if ( *(_BYTE *)(a1 + 25) )
    sub_67FE880();
  return result;
}


================================================================================
Function: sub_67FE880 (0x67FE880)
================================================================================

signed __int64 __fastcall sub_67FE880(
        signed __int64 result,
        char a2,
        char *a3,
        __int64 a4,
        _QWORD *a5,
        unsigned __int64 *a6,
        _OWORD *a7)
{
  unsigned __int64 v8; // x9
  __int64 v9; // x13
  char *v10; // x10
  __int64 v11; // x12
  unsigned __int64 v12; // x13
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x7
  unsigned __int64 v16; // x21
  __int128 v17; // q0
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x9
  __int64 v20; // x11
  unsigned __int64 v21; // x9
  __int64 *v22; // x10
  unsigned __int64 v23; // x12
  __int64 v24; // x13

  a7[2] = 0u;
  a7[3] = 0u;
  *a7 = 0u;
  a7[1] = 0u;
  if ( (unsigned __int64)(a4 - 33554433) >= 0xFFFFFFFFFE000000LL && *(_DWORD *)(result + 240) != 1 )
  {
    v8 = *(_QWORD *)(result + 224) << 16;
    if ( result + v8 > (unsigned __int64)a3 )
    {
      v9 = (__int64)&a3[-result + 0xFFFF];
      if ( (a2 & 1) == 0 )
        v9 = (__int64)&a3[-result];
      v10 = (char *)(*(_QWORD *)(result + 232) << 16);
      v11 = (__int64)&a3[a4 - result + 0xFFFF];
      v12 = v9 & 0xFFFFFFFFFFFF0000LL;
      if ( (a2 & 1) != 0 )
        v11 = (__int64)&a3[a4 - result];
      if ( v12 < (unsigned __int64)v10 && &a3[-result] >= v10 )
        v14 = *(_QWORD *)(result + 232) << 16;
      else
        v14 = v12;
      if ( (v11 & 0xFFFFFFFFFFFF0000LL) <= v8 )
        v8 = v11 & 0xFFFFFFFFFFFF0000LL;
      v15 = v8 >= v14 ? v8 - v14 : 0LL;
      *a5 = result + v14;
      *a6 = v15;
      if ( v8 > v14 )
      {
        v16 = v15 >> 16;
        if ( (v15 >> 16) + (v14 >> 16) >= 0x201 )
          result = sub_67F8944(
                     (signed __int64)"commit mask overflow: idx=%zu count=%zu start=%zx end=%zx p=0x%p size=%zu fullsize=%zu\n",
                     v14 >> 16,
                     v15 >> 16,
                     v14,
                     v8,
                     a3,
                     a4,
                     v15);
        if ( !v16 )
        {
          v17 = 0uLL;
          goto LABEL_26;
        }
        if ( v16 == 512 )
        {
          *(_QWORD *)&v17 = -1LL;
          *((_QWORD *)&v17 + 1) = -1LL;
LABEL_26:
          a7[2] = v17;
          a7[3] = v17;
          *a7 = v17;
          a7[1] = v17;
          return result;
        }
        v18 = v14 >> 22;
        if ( 64 - ((v14 >> 16) & 0x3F) >= v16 )
          v19 = v16;
        else
          v19 = 64 - ((v14 >> 16) & 0x3F);
        v20 = ~(-1LL << v19) << SBYTE2(v14);
        a7[2] = 0u;
        a7[3] = 0u;
        if ( v19 > 0x3F )
          v20 = -1LL;
        v21 = v16 - v19;
        *a7 = 0uLL;
        a7[1] = 0uLL;
        *((_QWORD *)a7 + v18) = v20;
        if ( v21 )
        {
          v22 = (__int64 *)a7 + v18 + 1;
          do
          {
            if ( v21 >= 0x40 )
              v23 = 64LL;
            else
              v23 = v21;
            if ( v23 <= 0x3F )
              v24 = ~(-1LL << v23);
            else
              v24 = -1LL;
            v21 -= v23;
            *v22++ = v24;
          }
          while ( v21 );
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67FEA14 (0x67FEA14)
================================================================================

__int64 __fastcall sub_67FEA14(__int64 a1, __int64 a2, unsigned int a3, _QWORD *a4, __int64 a5, _QWORD *a6)
{
  unsigned __int64 v10; // x0
  unsigned __int64 v11; // x8
  __int64 v12; // x8
  unsigned __int64 v13; // x20
  unsigned __int64 v14; // x24
  unsigned __int64 v15; // x28
  unsigned __int64 v16; // x21
  unsigned int v17; // w26
  bool v18; // w0
  bool v19; // w21
  unsigned __int64 v20; // x27
  __int64 v21; // x24
  unsigned __int64 v22; // x0
  unsigned __int64 v23; // x8
  __int64 v24; // x8
  unsigned __int64 v25; // x8
  unsigned __int64 v26; // x24
  __int64 v27; // x0
  __int64 v28; // x21
  unsigned __int64 v29; // x23
  __int128 v30; // q0
  __int128 v31; // q0
  unsigned __int64 v32; // x9
  __int64 v33; // x10
  unsigned __int64 v34; // x9
  __int64 *v35; // x10
  unsigned __int64 v36; // x12
  __int64 v37; // x13
  __int64 v38; // x5
  __int64 v39; // x6
  __int64 v40; // x7
  __int128 v41; // q0
  int v42; // w8
  bool v43; // w8
  __int128 v44; // q0
  __int128 v45; // q1
  __int128 v46; // q2
  __int128 v47; // q3
  unsigned __int64 v48; // x0
  __int64 v49; // x20
  unsigned __int64 v50; // x9
  unsigned __int64 v51; // x8
  unsigned __int64 v52; // x9
  unsigned __int64 v53; // x8
  _BOOL4 v54; // w20
  __int64 v55; // x22
  __int64 v56; // x8
  signed __int64 v57; // x1
  int v58; // w8
  __int64 v59; // x9
  unsigned __int64 v60; // x10
  unsigned __int64 v61; // x8
  unsigned __int64 v62; // x10
  __int64 v63; // x4
  unsigned __int64 *v64; // x9
  unsigned __int64 v65; // x11
  unsigned __int64 v66; // x10
  _DWORD *v67; // x11
  unsigned __int64 v68; // x10
  unsigned __int64 v69; // x8
  unsigned __int64 v70; // x11
  unsigned __int64 *v71; // x8
  unsigned __int64 *v72; // x9
  __int128 v76; // [xsp+10h] [xbp-80h] BYREF
  __int64 v77; // [xsp+20h] [xbp-70h]
  __int128 v78; // [xsp+28h] [xbp-68h] BYREF
  __int64 v79; // [xsp+38h] [xbp-58h]
  _OWORD v80[4]; // [xsp+40h] [xbp-50h] BYREF

  v10 = sub_67F8F24();
  v11 = v10 + 41303;
  if ( (v10 & (v10 - 1)) != 0 )
    v12 = v11 / v10 * v10;
  else
    v12 = v11 & -(__int64)v10;
  v13 = v12 + 0xFFFF;
  v14 = (v12 + 0xFFFF) & 0xFFFFFFFFFFFF0000LL;
  if ( a1 )
    v15 = (a1 + v14 + 0xFFFF) >> 16;
  else
    v15 = 512LL;
  if ( (unsigned __int64)sub_67F7028() < 2 || (v16 = a4[108], v16 >= sub_67F7E08(0xEu)) )
  {
    v18 = sub_67F8510(3u);
    v17 = 1;
  }
  else
  {
    v17 = 0;
    v18 = 0;
  }
  v19 = a1 != 0 || v18;
  if ( a2 )
  {
    v20 = (v14 + 0x1FFFFFF) & 0xFFFFFFFFFE000000LL;
    v21 = v20 - v14 + a1;
    v22 = sub_67F8F24();
    v23 = v22 + 41303;
    if ( (v22 & (v22 - 1)) != 0 )
      v24 = v23 / v22 * v22;
    else
      v24 = v23 & -(__int64)v22;
    v13 = v24 + 0xFFFF;
    v25 = (v21 + ((v24 + 0xFFFF) & 0xFFFFFFFFFFFF0000LL) + 0xFFFF) >> 16;
    if ( v21 )
      v15 = v25;
    else
      v15 = 512LL;
  }
  else
  {
    v20 = 0LL;
    a2 = 0x2000000LL;
  }
  v26 = v15 << 16;
  v27 = sub_67F510C(v15 << 16, a2, v20, v19, v17, a3, &v78, a5);
  v28 = v27;
  if ( v27 )
  {
    v29 = v13 >> 16;
    if ( BYTE1(v79) )
    {
      *(_QWORD *)&v30 = -1LL;
      *((_QWORD *)&v30 + 1) = -1LL;
      v80[2] = v30;
      v80[3] = v30;
      v80[0] = v30;
      v80[1] = v30;
    }
    else
    {
      if ( v29 )
      {
        if ( v29 == 512 )
        {
          *(_QWORD *)&v31 = -1LL;
          *((_QWORD *)&v31 + 1) = -1LL;
          v80[2] = v31;
          v80[3] = v31;
          v80[0] = v31;
          v80[1] = v31;
        }
        else
        {
          if ( v29 >= 0x40 )
            v32 = 64LL;
          else
            v32 = v13 >> 16;
          *((_QWORD *)&v80[3] + 1) = 0LL;
          if ( v32 <= 0x3F )
            v33 = ~(-1LL << v32);
          else
            v33 = -1LL;
          v34 = v29 - v32;
          *(_OWORD *)((char *)&v80[2] + 8) = 0uLL;
          *(_OWORD *)((char *)&v80[1] + 8) = 0uLL;
          *(_OWORD *)((char *)v80 + 8) = 0uLL;
          *(_QWORD *)&v80[0] = v33;
          if ( v34 )
          {
            v35 = (__int64 *)v80 + 1;
            do
            {
              if ( v34 >= 0x40 )
                v36 = 64LL;
              else
                v36 = v34;
              if ( v36 <= 0x3F )
                v37 = ~(-1LL << v36);
              else
                v37 = -1LL;
              v34 -= v36;
              *v35++ = v37;
            }
            while ( v34 );
          }
        }
      }
      else
      {
        memset(v80, 0, sizeof(v80));
      }
      if ( (sub_67F9B68(v27, v13 & 0xFFFFFFFFFFFF0000LL, 0LL, a4[112]) & 1) == 0 )
      {
        v63 = a4[112];
        v76 = v78;
        v77 = v79;
        sub_67F558C(v28, v15 << 16, 0LL, (__int64 *)&v76, v63, v38, v39, v40, (__int64)a6);
        return 0LL;
      }
    }
    v41 = v78;
    *(_QWORD *)(v28 + 16) = v79;
    *(_OWORD *)v28 = v41;
    v42 = (unsigned __int8)v79;
    *(_BYTE *)(v28 + 24) = v79 ^ 1;
    if ( v42 )
      v43 = 0;
    else
      v43 = sub_67F7E08(0xFu) >= 0;
    v44 = v80[0];
    v45 = v80[1];
    *(_BYTE *)(v28 + 25) = v43;
    *(_QWORD *)(v28 + 32) = v26;
    *(_QWORD *)(v28 + 104) = 0LL;
    v46 = v80[2];
    v47 = v80[3];
    *(_OWORD *)(v28 + 112) = v44;
    *(_OWORD *)(v28 + 128) = v45;
    *(_OWORD *)(v28 + 144) = v46;
    *(_OWORD *)(v28 + 160) = v47;
    *(_OWORD *)(v28 + 40) = 0u;
    *(_OWORD *)(v28 + 56) = 0u;
    *(_OWORD *)(v28 + 72) = 0u;
    *(_OWORD *)(v28 + 88) = 0u;
    atomic_store(0LL, (unsigned __int64 *)(v28 + 176));
    v48 = a4[112];
    if ( (v26 & 0x8000000000000000LL) != 0 )
    {
      sub_67FF704(v48, 1uLL);
      v49 = -1LL;
    }
    else
    {
      v49 = 1LL;
      sub_67FF620(v48, 1LL);
    }
    v50 = a4[109];
    v51 = a4[108] + v49;
    a4[108] = v51;
    if ( v51 > v50 )
      a4[109] = v51;
    v52 = a4[111];
    v53 = a4[110] + v26;
    a4[110] = v53;
    if ( v53 > v52 )
      a4[111] = v53;
    sub_67FF3F0(v28);
    if ( !*(_BYTE *)(v28 + 18) )
      memset((void *)(v28 + 184), 0, 80 * v15 + 160);
    v54 = a1 != 0;
    if ( v15 >= 0x200 )
      v55 = 512LL;
    else
      v55 = v15;
    *(_QWORD *)(v28 + 224) = v15;
    *(_QWORD *)(v28 + 232) = v29;
    atomic_store(sub_67F6EC4(), (unsigned __int64 *)(v28 + 256));
    v56 = qword_6CAF558;
    *(_QWORD *)(v28 + 248) = v55;
    *(_DWORD *)(v28 + 240) = v54;
    v57 = *(_QWORD *)(v28 + 232) << 16;
    *(_QWORD *)(v28 + 216) = v56 ^ v28;
    sub_67FF620(a4[112] + 192LL, v57);
    if ( sub_67FEF4C(v28, 0LL, v29, a4) )
    {
      v58 = *(_DWORD *)(v28 + 240);
      *(_QWORD *)(v28 + 208) = 0LL;
      if ( v58 )
      {
        *a6 = sub_67FEF4C(v28, v29, v15 - v29, a4);
      }
      else
      {
        v59 = *(_QWORD *)(v28 + 248);
        v60 = atomic_load((unsigned __int64 *)(v28 + 256));
        v61 = v59 - v29;
        if ( v60 )
        {
          if ( v61 >= 2 )
          {
            v65 = __clz(v61 - 1);
            v62 = v59 - v29;
            if ( 63 - v65 >= 3 )
              v62 = (((v61 - 1) >> (61 - (unsigned __int8)v65)) & 3 | (4 * (63 - v65))) - 4;
          }
          else
          {
            v62 = v59 - v29;
          }
          v64 = &a4[3 * v62];
        }
        else
        {
          v64 = 0LL;
        }
        if ( !v61 )
          v61 = 1LL;
        v66 = v28 + 80 * v29;
        *(_DWORD *)(v66 + 264) = v61;
        *(_DWORD *)(v66 + 268) = 0;
        if ( v61 >= 2 )
        {
          v67 = (_DWORD *)(v28 + 80 * (v29 + v61));
          v67[46] = 0;
          v67[47] = 80 * v61 - 80;
          v67[53] = 0;
        }
        if ( v64 )
        {
          v68 = v66 + 264;
          v69 = v28 + 80 * v29;
          *(_QWORD *)(v69 + 328) = 0LL;
          v70 = *v64;
          *(_QWORD *)(v69 + 320) = *v64;
          v71 = (unsigned __int64 *)(v70 + 64);
          *v64 = v68;
          v72 = v64 + 1;
          if ( !v70 )
            v71 = v72;
          *v71 = v68;
        }
        *(_DWORD *)(v28 + 80 * v29 + 292) = 0;
      }
    }
    else
    {
      return 0LL;
    }
  }
  return v28;
}


================================================================================
Function: sub_67FEF4C (0x67FEF4C)
================================================================================

_DWORD *__fastcall sub_67FEF4C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v7; // x22
  __int64 v8; // x25
  bool v9; // w8
  unsigned __int64 v10; // x27
  __int64 v11; // x26
  __int64 v12; // x28
  __int64 v13; // x24
  int64x2_t v14; // q0
  int64x2_t v15; // q1
  unsigned __int64 v16; // d2
  unsigned __int64 v17; // d2
  __int64 v18; // x8
  __int64 v19; // x9
  int8x16_t v20; // q2
  __int64 v21; // x23
  unsigned __int64 v22; // x0
  int8x16_t v23; // q3
  __int64 v24; // x8
  int8x16_t v25; // q1
  __int64 v26; // x9
  int8x16_t v27; // q2
  __int64 v28; // x8
  __int64 v29; // x9
  __int64 v30; // x10
  __int64 v31; // x11
  __int64 v32; // x12
  __int64 v33; // x13
  __int64 v34; // x14
  __int64 v35; // x15
  __int64 v36; // x23
  __int64 v37; // x0
  unsigned __int64 v38; // x11
  unsigned int v39; // w12
  unsigned __int64 v40; // x8
  _DWORD *v41; // x10
  _DWORD *result; // x0
  unsigned __int64 v43; // x9
  __int64 v44; // x13
  unsigned __int64 v45; // x12
  _DWORD *v46; // x14
  _DWORD *v47; // x8
  __int64 v48; // x8
  char v49; // w9
  int8x16_t v50; // [xsp+0h] [xbp-110h]
  int8x16_t v51; // [xsp+10h] [xbp-100h]
  __int64 v52; // [xsp+20h] [xbp-F0h]
  int8x16_t v53; // [xsp+20h] [xbp-F0h]
  unsigned __int64 v54; // [xsp+38h] [xbp-D8h]
  unsigned __int64 v55; // [xsp+40h] [xbp-D0h]
  unsigned __int64 v56; // [xsp+48h] [xbp-C8h]
  __int64 v57; // [xsp+50h] [xbp-C0h]
  _BYTE v58[4]; // [xsp+5Ch] [xbp-B4h] BYREF
  __int64 v59; // [xsp+60h] [xbp-B0h] BYREF
  __int64 v60; // [xsp+68h] [xbp-A8h] BYREF
  _OWORD v61[3]; // [xsp+70h] [xbp-A0h] BYREF
  __int64 v62; // [xsp+A0h] [xbp-70h]
  __int64 v63; // [xsp+A8h] [xbp-68h]
  int8x16_t v64; // [xsp+B0h] [xbp-60h] BYREF
  int8x16_t v65; // [xsp+C0h] [xbp-50h]
  _BYTE v66[24]; // [xsp+D0h] [xbp-40h]
  __int64 v67; // [xsp+E8h] [xbp-28h]

  v7 = a3 << 16;
  v8 = *(_QWORD *)(a4 + 896);
  if ( *(_QWORD *)(a1 + 112) != -1LL
    || *(_QWORD *)(a1 + 120) != -1LL
    || *(_QWORD *)(a1 + 128) != -1LL
    || *(_QWORD *)(a1 + 136) != -1LL
    || *(_QWORD *)(a1 + 144) != -1LL
    || *(_QWORD *)(a1 + 152) != -1LL
    || *(_QWORD *)(a1 + 160) != -1LL
    || *(_QWORD *)(a1 + 168) != -1LL
    || *(_QWORD *)(a1 + 48)
    || *(_QWORD *)(a1 + 56)
    || *(_QWORD *)(a1 + 64)
    || *(_QWORD *)(a1 + 72)
    || *(_QWORD *)(a1 + 80)
    || *(_QWORD *)(a1 + 88)
    || *(_QWORD *)(a1 + 96)
    || *(_QWORD *)(a1 + 104) )
  {
    v59 = 0LL;
    v60 = 0LL;
    sub_67FE880(a1, 0LL, a1 + (a2 << 16), v7, &v60, &v59, &v64);
    v9 = 0;
    v10 = v64.n128_u64[0];
    v11 = *(_QWORD *)&v66[16];
    v12 = *(_QWORD *)v66;
    if ( *(_OWORD *)&v64 == 0LL
      && *(_OWORD *)&v65 == 0LL
      && !*(_QWORD *)v66
      && __PAIR128__(*(unsigned __int64 *)&v66[8], 0LL) == *(unsigned __int64 *)&v66[16] )
    {
      v9 = v67 == 0;
    }
    if ( !v9 )
    {
      v13 = v59;
      if ( v59 )
      {
        v55 = v65.n128_u64[0];
        v56 = v64.n128_u64[1];
        v54 = v65.n128_u64[1];
        v57 = *(_QWORD *)&v66[8];
        v14 = vandq_s8(*(int8x16_t *)(a1 + 112), v64);
        v15 = vandq_s8(*(int8x16_t *)(a1 + 128), v65);
        v16 = vmovn_s64(vceqq_s64(v14, v64)).n64_u64[0];
        if ( (v16 & 1) == 0
          || (v16 & 0x100000000LL) == 0
          || (v17 = vmovn_s64(vceqq_s64(v15, v65)).n64_u64[0], (v17 & 1) == 0)
          || (v17 & 0x100000000LL) == 0
          || (*(_QWORD *)v66 & ~*(_QWORD *)(a1 + 144)) != 0LL
          || (*(_OWORD *)&v66[8] & ~*(_OWORD *)(a1 + 152)) != 0LL
          || (v52 = v67, (v67 & ~*(_QWORD *)(a1 + 168)) != 0) )
        {
          v18 = *(_QWORD *)(a1 + 160);
          v19 = *(_QWORD *)(a1 + 168);
          v20 = *(int8x16_t *)(a1 + 144);
          v51 = v64;
          v53 = v65;
          v21 = v67;
          v58[0] = 0;
          v61[0] = v14;
          v61[1] = v15;
          v50 = *(int8x16_t *)v66;
          v61[2] = vandq_s8(v20, *(int8x16_t *)v66);
          v62 = v18 & *(_QWORD *)&v66[16];
          v63 = v67 & v19;
          v22 = sub_67FC71C((unsigned __int64 *)v61, 0x2000000uLL);
          sub_67FF704((unsigned __int64)&unk_7304F60, v22);
          if ( (sub_67F9B68(v60, v13, v58, v8) & 1) == 0 )
            return 0LL;
          v23 = v53;
          v52 = v21;
          v24 = *(_QWORD *)(a1 + 160) | v11;
          v25 = vorrq_s8(*(int8x16_t *)(a1 + 128), v23);
          v26 = *(_QWORD *)(a1 + 168) | v21;
          v27 = vorrq_s8(*(int8x16_t *)(a1 + 144), v50);
          *(int8x16_t *)(a1 + 112) = vorrq_s8(*(int8x16_t *)(a1 + 112), v51);
          *(int8x16_t *)(a1 + 128) = v25;
          *(_QWORD *)(a1 + 160) = v24;
          *(_QWORD *)(a1 + 168) = v26;
          *(int8x16_t *)(a1 + 144) = v27;
        }
        v28 = *(_QWORD *)(a1 + 48);
        if ( (v28 & v10) != 0
          || (v29 = *(_QWORD *)(a1 + 56), (v29 & v56) != 0)
          || (v30 = *(_QWORD *)(a1 + 64), (v30 & v55) != 0)
          || (v31 = *(_QWORD *)(a1 + 72), (v31 & v54) != 0)
          || (v32 = *(_QWORD *)(a1 + 80), (v32 & v12) != 0)
          || (v33 = *(_QWORD *)(a1 + 88), (v33 & v57) != 0)
          || (v34 = *(_QWORD *)(a1 + 96), (v34 & v11) != 0)
          || (v35 = *(_QWORD *)(a1 + 104), (v35 & v52) != 0) )
        {
          v36 = sub_6800364();
          v37 = sub_67F7E08(0xFu);
          v28 = *(_QWORD *)(a1 + 48);
          v29 = *(_QWORD *)(a1 + 56);
          v30 = *(_QWORD *)(a1 + 64);
          v31 = *(_QWORD *)(a1 + 72);
          v32 = *(_QWORD *)(a1 + 80);
          v33 = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 40) = v37 + v36;
          v34 = *(_QWORD *)(a1 + 96);
          v35 = *(_QWORD *)(a1 + 104);
        }
        *(_QWORD *)(a1 + 48) = v28 & ~v10;
        *(_QWORD *)(a1 + 56) = v29 & ~v56;
        *(_QWORD *)(a1 + 64) = v30 & ~v55;
        *(_QWORD *)(a1 + 72) = v31 & ~v54;
        *(_QWORD *)(a1 + 80) = v32 & ~v12;
        *(_QWORD *)(a1 + 88) = v33 & ~v57;
        *(_QWORD *)(a1 + 96) = v34 & ~v11;
        *(_QWORD *)(a1 + 104) = v35 & ~v52;
      }
    }
  }
  v38 = a3 - 1;
  if ( v7 >> 31 )
    v39 = 0x80000000;
  else
    v39 = v7;
  v40 = *(_QWORD *)(a1 + 248);
  if ( v38 >= 0xFF )
    v38 = 255LL;
  v41 = (_DWORD *)(a1 + 80 * a2);
  result = v41 + 66;
  v43 = v40 + ~a2;
  if ( v38 + a2 < v40 )
    v43 = v38;
  *result = a3;
  v41[67] = 0;
  v41[73] = v39;
  if ( v43 )
  {
    v44 = 0LL;
    v45 = 1LL;
    do
    {
      v46 = (_DWORD *)(a1 + 80 * a2 + v44);
      v44 += 80LL;
      ++v45;
      v46[87] = v44;
      v46[86] = 0;
      v46[93] = 1;
    }
    while ( v45 <= v43 );
  }
  v47 = (_DWORD *)(a1 + 80 * v40 + 264);
  if ( &result[20 * a3 - 20] <= v47 )
    v47 = &result[20 * a3 - 20];
  if ( v47 > result )
  {
    *v47 = 0;
    v47[1] = (_DWORD)v47 - (_DWORD)result;
    v47[7] = 1;
  }
  v48 = a1 + 80 * a2;
  v49 = *(_BYTE *)(v48 + 272);
  ++*(_QWORD *)(a1 + 208);
  *(_BYTE *)(v48 + 272) = v49 | 1;
  return result;
}


================================================================================
Function: sub_67FF3F0 (0x67FF3F0)
================================================================================

unsigned __int64 __fastcall sub_67FF3F0(unsigned __int64 result)
{
  unsigned __int64 v1; // x20
  unsigned __int64 v2; // x19
  __int64 v3; // x22
  bool v4; // zf

  if ( result >> 43 <= 4 )
  {
    v1 = result >> 31;
    if ( result >> 31 != 20480 )
    {
      v2 = qword_730D408[v1];
      v3 = 1LL << (result >> 25);
      do
      {
        result = sub_6866FE0(v2, v2 | v3, (atomic_ullong *)&qword_730D408[v1]);
        v4 = result == v2;
        v2 = result;
      }
      while ( !v4 );
    }
  }
  return result;
}


================================================================================
Function: sub_67FF45C (0x67FF45C)
================================================================================

unsigned __int64 __fastcall sub_67FF45C(unsigned __int64 result)
{
  unsigned __int64 v1; // x20
  unsigned __int64 v2; // x19
  __int64 v3; // x22
  bool v4; // zf

  if ( result >> 43 <= 4 )
  {
    v1 = result >> 31;
    if ( result >> 31 != 20480 )
    {
      v2 = qword_730D408[v1];
      v3 = ~(1LL << (result >> 25));
      do
      {
        result = sub_6866FE0(v2, v2 & v3, (atomic_ullong *)&qword_730D408[v1]);
        v4 = result == v2;
        v2 = result;
      }
      while ( !v4 );
    }
  }
  return result;
}


================================================================================
Function: sub_67FF5B4 (0x67FF5B4)
================================================================================

unsigned __int64 __fastcall sub_67FF5B4(unsigned __int64 result, unsigned __int64 a2)
{
  atomic_ullong *v2; // x19
  int64x2_t v5; // q0

  v2 = (atomic_ullong *)result;
  if ( result < (unsigned __int64)&unk_7304F00 || result >= (unsigned __int64)qword_7305180 )
  {
    v5 = vdupq_n_s64(1uLL);
    v5.n128_u64[0] = a2;
    *(int64x2_t *)result = vaddq_s64(*(int64x2_t *)result, v5);
  }
  else
  {
    sub_6867420(1uLL, (atomic_ullong *)(result + 8));
    return sub_6867420(a2, v2);
  }
  return result;
}


================================================================================
Function: sub_67FF620 (0x67FF620)
================================================================================

unsigned __int64 __fastcall sub_67FF620(unsigned __int64 result, signed __int64 a2)
{
  unsigned __int64 v3; // x19
  unsigned __int64 v4; // x0
  signed __int64 v5; // x22
  signed __int64 v6; // x21
  unsigned __int64 v7; // x0
  bool v8; // zf
  signed __int64 v9; // x9
  signed __int64 v10; // x8

  if ( a2 )
  {
    v3 = result;
    if ( result < (unsigned __int64)&unk_7304F00 || result >= (unsigned __int64)&qword_7305180 )
    {
      v9 = *(_QWORD *)(result + 16);
      v10 = *(_QWORD *)(result + 24) + a2;
      *(_QWORD *)(result + 24) = v10;
      if ( v10 > v9 )
        *(_QWORD *)(result + 16) = v10;
      if ( a2 < 1 )
        *(_QWORD *)(result + 8) -= a2;
      else
        *(_QWORD *)result += a2;
    }
    else
    {
      v4 = sub_6867420(a2, (atomic_ullong *)(result + 24));
      v5 = *(_QWORD *)(v3 + 16);
      v6 = v4 + a2;
      do
      {
        if ( v5 >= v6 )
          break;
        v7 = sub_6866FE0(v5, v6, (atomic_ullong *)(v3 + 16));
        v8 = v7 == v5;
        v5 = v7;
      }
      while ( !v8 );
      if ( a2 < 1 )
        return sub_6867420(-a2, (atomic_ullong *)(v3 + 8));
      else
        return sub_6867420(a2, (atomic_ullong *)v3);
    }
  }
  return result;
}


================================================================================
Function: sub_67FF704 (0x67FF704)
================================================================================

unsigned __int64 __fastcall sub_67FF704(unsigned __int64 result, unsigned __int64 a2)
{
  unsigned __int64 v3; // x19
  unsigned __int64 v4; // x0
  signed __int64 v5; // x23
  signed __int64 v6; // x22
  unsigned __int64 v7; // x0
  bool v8; // zf
  signed __int64 v9; // x9
  signed __int64 v10; // x8

  if ( a2 )
  {
    v3 = result;
    if ( result < (unsigned __int64)&unk_7304F00 || result >= (unsigned __int64)qword_7305180 )
    {
      v9 = *(_QWORD *)(result + 16);
      v10 = *(_QWORD *)(result + 24) - a2;
      *(_QWORD *)(result + 24) = v10;
      if ( v10 > v9 )
        *(_QWORD *)(result + 16) = v10;
      if ( (a2 & 0x8000000000000000LL) != 0 )
        *(_QWORD *)result -= a2;
      else
        *(_QWORD *)(result + 8) += a2;
    }
    else
    {
      v4 = sub_6867420(-(__int64)a2, (atomic_ullong *)(result + 24));
      v5 = *(_QWORD *)(v3 + 16);
      v6 = v4 - a2;
      do
      {
        if ( v5 >= v6 )
          break;
        v7 = sub_6866FE0(v5, v6, (atomic_ullong *)(v3 + 16));
        v8 = v7 == v5;
        v5 = v7;
      }
      while ( !v8 );
      if ( (a2 & 0x8000000000000000LL) != 0 )
        return sub_6867420(-(__int64)a2, (atomic_ullong *)v3);
      else
        return sub_6867420(a2, (atomic_ullong *)(v3 + 8));
    }
  }
  return result;
}


================================================================================
Function: sub_67FF7EC (0x67FF7EC)
================================================================================

__int64 sub_67FF7EC()
{
  void *v0; // x0
  __int64 result; // x0
  __int64 v2; // x19

  v0 = (void *)(*(_QWORD *)sub_67F4CA4() + 960LL);
  if ( v0 != &unk_7304F00 )
    memset(v0, 0, 0x280uLL);
  result = (__int64)memset(&unk_7304F00, 0, 0x280uLL);
  if ( !qword_7335410 )
  {
    if ( !qword_7335418 )
    {
      v2 = sub_6801000();
      qword_7335418 = sub_6801000() - v2;
    }
    result = sub_6801000();
    qword_7335410 = result;
  }
  return result;
}


================================================================================
Function: sub_67FF87C (0x67FF87C)
================================================================================

__int64 sub_67FF87C()
{
  __int64 v0; // x19

  if ( !qword_7335418 )
  {
    v0 = sub_6801000();
    qword_7335418 = sub_6801000() - v0;
  }
  return sub_6801000();
}


================================================================================
Function: sub_6800364 (0x6800364)
================================================================================

// attributes: thunk
__int64 sub_6800364()
{
  return sub_6801000();
}


================================================================================
Function: sub_6800368 (0x6800368)
================================================================================

__int64 __fastcall sub_6800368(__int64 a1)
{
  return sub_6801000() - (qword_7335418 + a1);
}


================================================================================
Function: sub_6800990 (0x6800990)
================================================================================

__int64 __fastcall sub_6800990(__int64 a1)
{
  __int64 v2; // x0
  __int64 result; // x0
  int v4; // w20
  bool v5; // w22
  char v6; // w8
  _BYTE buf[32]; // [xsp+8h] [xbp-28h] BYREF

  v2 = sysconf(39);
  if ( v2 >= 1 )
  {
    *(_QWORD *)a1 = v2;
    *(_QWORD *)(a1 + 16) = v2;
  }
  *(_QWORD *)(a1 + 8) = 0x200000LL;
  result = __open_2("/proc/sys/vm/overcommit_memory", 0LL);
  if ( (result & 0x80000000) != 0 )
  {
    v6 = 1;
  }
  else
  {
    v4 = result;
    v5 = read(result, buf, 0x20uLL) < 1;
    result = close(v4);
    v6 = v5 || (buf[0] & 0xFE) == 48;
  }
  *(_BYTE *)(a1 + 24) = v6;
  *(_WORD *)(a1 + 25) = 256;
  return result;
}


================================================================================
Function: sub_6800A5C (0x6800A5C)
================================================================================

__int64 __fastcall sub_6800A5C(void *a1, size_t a2)
{
  __int64 v2; // x0

  v2 = munmap(a1, a2);
  if ( (_DWORD)v2 == -1 )
    return *(unsigned int *)__errno(v2);
  else
    return 0LL;
}


================================================================================
Function: sub_6800A8C (0x6800A8C)
================================================================================

__int64 __fastcall sub_6800A8C(__int64 a1, __int64 a2, char a3, unsigned int a4, __int64 a5, _BYTE *a6, __int64 *a7)
{
  __int64 v9; // x3
  __int64 v10; // x8
  __int64 result; // x0

  if ( (a3 & 1) != 0 )
    v9 = 3LL;
  else
    v9 = 0LL;
  *a6 = 1;
  v10 = sub_6800AF8(0LL, a1, a2, v9, 0LL, a4, a5);
  result = 0LL;
  *a7 = v10;
  if ( !v10 )
    return *(unsigned int *)__errno(0LL);
  return result;
}


================================================================================
Function: sub_6800AF8 (0x6800AF8)
================================================================================

void *__fastcall sub_6800AF8(void *a1, size_t a2, __int64 a3, int a4, int a5, char a6, _BYTE *a7)
{
  int v14; // w25
  unsigned __int64 v15; // x0
  int v16; // w4
  void *v17; // x27
  _DWORD *v18; // x0

  if ( (sub_67F8F0C() & 1) != 0 )
    v14 = 16418;
  else
    v14 = 34;
  if ( (a5 & 1) != 0 )
  {
    if ( (a6 & 1) != 0 )
    {
      atomic_load(&qword_7335420);
      goto LABEL_11;
    }
LABEL_20:
    *a7 = 0;
    v17 = (void *)sub_6801244(a1, a2, a3, a4, v14);
    if ( v17 && (a6 & 1) != 0 && (sub_67F8F30(a2, a3) & 1) != 0 && !madvise(v17, a2, 14) )
      *a7 = 1;
    return v17;
  }
  if ( (sub_67F8F30(a2, a3) & 1) == 0 || (a6 & 1) == 0 )
    goto LABEL_20;
  v15 = atomic_load(&qword_7335420);
  if ( v15 )
  {
    sub_6867020(v15, v15 - 1, (atomic_ullong *)&qword_7335420);
    goto LABEL_20;
  }
LABEL_11:
  if ( (a2 & 0x3FFFFFFF) != 0 || byte_7335428 == 1 )
    v16 = 1409548322;
  else
    v16 = 2013528098;
  *a7 = 1;
  v17 = (void *)sub_6801244(a1, a2, a3, a4, v16);
  if ( !v17 )
  {
    byte_7335428 = 1;
    v18 = (_DWORD *)__errno(0LL);
    sub_67F8944(
      (signed __int64)"unable to allocate huge (1GiB) page, trying large (2MiB) pages instead (errno: %i)\n",
      *v18);
    v17 = (void *)sub_6801244(a1, a2, a3, a4, 1409548322);
    if ( ((a5 ^ 1) & (v17 == 0LL)) == 1 )
    {
      v17 = 0LL;
      atomic_store(8uLL, &qword_7335420);
    }
    if ( (a5 & 1) == 0 && !v17 )
      goto LABEL_20;
  }
  return v17;
}


================================================================================
Function: sub_6800CD8 (0x6800CD8)
================================================================================

__int64 __fastcall sub_6800CD8(void *a1, size_t a2, _BYTE *a3)
{
  __int64 result; // x0

  *a3 = 0;
  result = mprotect(a1, a2, 3);
  if ( (_DWORD)result )
    return *(unsigned int *)__errno(result);
  return result;
}


================================================================================
Function: sub_6800D00 (0x6800D00)
================================================================================

__int64 __fastcall sub_6800D00(void *a1, size_t a2, _BYTE *a3)
{
  __int64 result; // x0

  result = madvise(a1, a2, 4);
  *a3 = 0;
  return result;
}


================================================================================
Function: sub_6800D28 (0x6800D28)
================================================================================

__int64 __fastcall sub_6800D28(void *a1, size_t a2)
{
  int v4; // w21
  __int64 v5; // x0
  unsigned int v6; // w22
  int *v7; // x0
  int v8; // w8
  int *v9; // x23

  v4 = qword_6CAF9B8;
  v5 = madvise(a1, a2, qword_6CAF9B8);
  v6 = v5;
  if ( (_DWORD)v5 )
  {
    v7 = (int *)__errno(v5);
    v8 = *v7;
    if ( *v7 == 11 )
    {
      v9 = v7;
      while ( 1 )
      {
        *v9 = 0;
        v6 = madvise(a1, a2, v4);
        if ( !v6 )
          break;
        v8 = *v9;
        if ( *v9 != 11 )
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      if ( v8 == 22 && v4 == 8 )
      {
        atomic_store(4uLL, (unsigned __int64 *)&qword_6CAF9B8);
        return madvise(a1, a2, 4);
      }
    }
  }
  return v6;
}


================================================================================
Function: sub_6800DF0 (0x6800DF0)
================================================================================

__int64 __fastcall sub_6800DF0(void *a1, size_t a2, __int64 a3, _BYTE *a4, _QWORD *a5)
{
  int v8; // w4
  void *v9; // x0
  void *v10; // x8
  __int64 result; // x0
  _DWORD *v12; // x0
  void *v13; // x0

  *a4 = 1;
  sub_67F8F0C();
  atomic_load(&qword_7335420);
  if ( (a2 & 0x3FFFFFFF) != 0 || byte_7335428 == 1 )
    v8 = 1409548322;
  else
    v8 = 2013528098;
  v9 = sub_6801244(a1, a2, 0x2000000uLL, 3, v8);
  if ( v9 )
  {
    v10 = v9;
    result = 0LL;
    *a5 = v10;
  }
  else
  {
    byte_7335428 = 1;
    v12 = (_DWORD *)__errno(0LL);
    sub_67F8944(
      (signed __int64)"unable to allocate huge (1GiB) page, trying large (2MiB) pages instead (errno: %i)\n",
      *v12);
    v13 = sub_6801244(a1, a2, 0x2000000uLL, 3, 1409548322);
    *a5 = v13;
    if ( v13 )
      return 0LL;
    else
      return *(unsigned int *)__errno(0LL);
  }
  return result;
}


================================================================================
Function: sub_6800EDC (0x6800EDC)
================================================================================

__int64 sub_6800EDC()
{
  return 0LL;
}


================================================================================
Function: sub_6800EE4 (0x6800EE4)
================================================================================

__int64 __fastcall sub_6800EE4(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x8
  __int64 v5; // x19
  int v6; // w0
  char name[128]; // [xsp+8h] [xbp-88h] BYREF

  v4 = 1LL;
  do
  {
    v5 = v4;
    if ( (_DWORD)v4 == 257 )
      break;
    sub_6800F5C(name, a2, a3, a4, (unsigned int)v4);
    v6 = access(name, 4);
    v4 = v5 + 1;
  }
  while ( !v6 );
  return v5;
}


================================================================================
Function: sub_6800F5C (0x6800F5C)
================================================================================

__int64 sub_6800F5C(char *a1, __int64 a2, __int64 a3, __int64 a4, ...)
{
  gcc_va_list arg; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, a4);
  va_copy(arg, va);
  return vsnprintf(a1, 0x7FuLL, "/sys/devices/system/node/node%u", arg);
}


================================================================================
Function: sub_6801000 (0x6801000)
================================================================================

__int64 sub_6801000()
{
  __int64 v1; // [xsp+8h] [xbp-18h] BYREF
  __int64 v2; // [xsp+10h] [xbp-10h]

  clock_gettime(1, (struct timespec *)&v1);
  return v2 / 1000000 + 1000 * v1;
}


================================================================================
Function: sub_6801130 (0x6801130)
================================================================================

__int64 __fastcall sub_6801130(__int64 result, __int64 a2, __int64 a3)
{
  __int64 v4; // x21
  char **v6; // x24
  __int64 v7; // x22
  __int64 i; // x25
  char *v9; // x23

  if ( result )
  {
    v4 = result;
    result = sub_67F8C90();
    if ( result )
    {
      v6 = environ;
      if ( environ )
      {
        v7 = result;
        for ( i = 10000LL; i; --i )
        {
          v9 = *v6;
          if ( !*v6 )
            break;
          if ( !(unsigned int)sub_67F8BD8(v4, *v6, v7) && v9[v7] == 61 )
          {
            sub_67F8C50(a2, &v9[v7 + 1], a3);
            return 1LL;
          }
          ++v6;
        }
      }
      return 0LL;
    }
  }
  return result;
}


================================================================================
Function: sub_68011E8 (0x68011E8)
================================================================================

__int64 __fastcall sub_68011E8(void *a1, size_t a2)
{
  arc4random_buf(a1, a2);
  return 1LL;
}


================================================================================
Function: sub_6801200 (0x6801200)
================================================================================

__int64 sub_6801200()
{
  return pthread_key_create((pthread_key_t *)&dword_6CAF9C0, (void (*)(void *))sub_6801214);
}


================================================================================
Function: sub_6801224 (0x6801224)
================================================================================

const void *__fastcall sub_6801224(const void *pointer)
{
  if ( dword_6CAF9C0 != -1 )
    return (const void *)pthread_setspecific(dword_6CAF9C0, pointer);
  return pointer;
}


================================================================================
Function: sub_6801244 (0x6801244)
================================================================================

void *__fastcall sub_6801244(void *addr, size_t len, unsigned __int64 a3, int prot, int flags)
{
  void *v9; // x0
  unsigned __int64 v10; // x25
  void *v13; // x0
  const void *v14; // x24
  unsigned __int64 v15; // x0
  _DWORD *v16; // x0
  _DWORD *v17; // x0

  if ( addr )
    goto LABEL_2;
  v13 = (void *)sub_67F9024(a3, len);
  if ( !v13 )
    goto LABEL_2;
  v14 = v13;
  v15 = (unsigned __int64)mmap(v13, len, prot, flags, -1, 0LL);
  if ( v15 == -1LL )
  {
    v17 = (_DWORD *)__errno(-1LL);
    sub_67F8944(
      (signed __int64)"unable to directly request hinted aligned OS memory (error: %d (0x%x), size: 0x%zx bytes, alignmen"
                      "t: 0x%zx, hint address: %p)\n",
      *v17,
      *v17,
      len,
      a3,
      v14);
LABEL_2:
    v9 = mmap(addr, len, prot, flags, -1, 0LL);
    if ( v9 == (void *)-1LL )
      return 0LL;
    else
      return v9;
  }
  v10 = v15;
  if ( v15 % a3 )
  {
    v16 = (_DWORD *)__errno(v15);
    sub_67F8944(
      (signed __int64)"unable to directly request hinted aligned OS memory (error: %d (0x%x), size: 0x%zx bytes, alignmen"
                      "t: 0x%zx, hint address: %p)\n",
      *v16,
      *v16,
      len,
      a3,
      v14);
  }
  return (void *)v10;
}


================================================================================
Function: sub_6801348 (0x6801348)
================================================================================

long double __fastcall sub_6801348(__int64 a1)
{
  long double result; // q0

  *(_QWORD *)(a1 + 64) = 0LL;
  *(_WORD *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 138) = 0;
  *(_BYTE *)(a1 + 144) = 0;
  result = byte_174D120;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)a1 = xmmword_174D110;
  *(long double *)(a1 + 16) = byte_174D120;
  *(_OWORD *)(a1 + 32) = xmmword_174D110;
  *(long double *)(a1 + 48) = byte_174D120;
  return result;
}


================================================================================
Function: sub_680599C (0x680599C)
================================================================================

__int64 sub_680599C()
{
  unsigned __int8 v0; // w9
  _QWORD *v1; // x8
  int v3; // w0

  v0 = atomic_load(byte_7335438);
  v1 = &unk_7335000;
  if ( (v0 & 1) == 0 )
  {
    v3 = sub_68626F8((__int64)byte_7335438);
    v1 = &unk_7335000;
    if ( v3 )
    {
      qword_7335430 = (__int64)&qword_7335440;
      qword_7335440 = (__int64)off_6C59788;
      sub_6862850(byte_7335438);
      v1 = (_QWORD *)&unk_7335000;
    }
  }
  return v1[134];
}


================================================================================
Function: sub_6806D24 (0x6806D24)
================================================================================

__int64 __fastcall sub_6806D24(time_t *a1, __int64 a2)
{
  __int128 v3; // q1
  int tm_isdst; // w8
  struct tm v6; // [xsp+0h] [xbp-50h] BYREF
  time_t timer; // [xsp+40h] [xbp-10h] BYREF

  timer = *a1;
  if ( !gmtime_r(&timer, &v6) )
    return 0LL;
  v3 = *(_OWORD *)&v6.tm_mon;
  tm_isdst = v6.tm_isdst;
  *(_OWORD *)a2 = *(_OWORD *)&v6.tm_sec;
  *(_OWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 32) = tm_isdst;
  return a2;
}


================================================================================
Function: sub_6806F24 (0x6806F24)
================================================================================

void __fastcall __noreturn sub_6806F24(__int64 a1)
{
  __int64 v2; // x19

  v2 = sub_6861FD0(16LL);
  sub_6806F74(v2, a1);
  sub_6862048(v2, (__int64)&`typeinfo for'fmt::v8::format_error, (__int64)sub_6806FA0);
}


================================================================================
Function: sub_6806F74 (0x6806F74)
================================================================================

__int64 __fastcall sub_6806F74(_QWORD *a1, char *a2)
{
  __int64 result; // x0

  result = sub_684956C((int)a1, a2);
  *a1 = off_6C59970;
  return result;
}


================================================================================
Function: sub_6806FC8 (0x6806FC8)
================================================================================

_BYTE *__usercall sub_6806FC8@<X0>(
        _WORD *a1@<X0>,
        __int64 a2@<X1>,
        unsigned __int64 a3@<X2>,
        unsigned int *a4@<X3>,
        unsigned __int64 *a5@<X8>)
{
  size_t v6; // x20
  const void *v7; // x21
  void *v8; // x19
  unsigned __int64 v9; // x22
  __int64 v10; // x0
  _BYTE *result; // x0
  _UNKNOWN **v12; // [xsp+0h] [xbp-220h] BYREF
  _BYTE *v13; // [xsp+8h] [xbp-218h]
  __int128 v14; // [xsp+10h] [xbp-210h]
  _BYTE v15[504]; // [xsp+20h] [xbp-200h] BYREF

  v12 = &off_6C599D8;
  v13 = v15;
  v14 = xmmword_B03780;
  sub_68070F4((__int64)&v12, a1, a2, a3, a4, 0LL);
  v7 = v13;
  v6 = v14;
  if ( (unsigned __int64)v14 >= 0x17 )
  {
    v9 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v10 = sub_65ECAAC();
    a5[1] = v6;
    a5[2] = v10;
    *a5 = v9 | 1;
    v8 = (void *)v10;
    goto LABEL_5;
  }
  *(_BYTE *)a5 = 2 * v14;
  v8 = (char *)a5 + 1;
  if ( v6 )
LABEL_5:
    memcpy(v8, v7, v6);
  result = v13;
  *((_BYTE *)v8 + v6) = 0;
  if ( result != v15 )
    return (_BYTE *)sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_68070E4 (0x68070E4)
================================================================================

void __fastcall __noreturn sub_68070E4(__int64 a1, __int64 a2)
{
  sub_6806F24(a2);
}


================================================================================
Function: sub_68070F4 (0x68070F4)
================================================================================

__int64 __fastcall sub_68070F4(__int64 result, _WORD *s, __int64 a3, unsigned __int64 a4, unsigned int *a5, __int64 a6)
{
  _BYTE *v6; // x21
  __int64 v7; // x19
  char *v8; // x20
  _WORD *v9; // x19
  int v10; // w8
  int v11; // t1
  __int64 v12; // x0
  void *v13; // x19
  unsigned int v14; // w8
  unsigned int v15; // w10
  __int64 (__fastcall *v16)(unsigned __int64, __int64 **, __int64 *); // x8
  unsigned int v17; // w9
  float v18; // w20
  const char *v19; // x8
  __int64 v20; // x2
  __int64 v21; // x8
  __int64 v22; // x1
  __int64 v23; // x9
  const char *v24; // x20
  const char *v25; // x1
  unsigned __int64 v26; // x20
  __int64 v27; // x2
  unsigned __int64 v28; // x8
  bool v29; // cc
  long double v30; // [xsp+0h] [xbp-70h]
  __int64 *v31; // [xsp+10h] [xbp-60h] BYREF
  __int64 v32; // [xsp+18h] [xbp-58h]
  int v33; // [xsp+20h] [xbp-50h]
  __int64 v34; // [xsp+28h] [xbp-48h] BYREF
  _WORD *v35; // [xsp+30h] [xbp-40h]
  unsigned int *v36; // [xsp+38h] [xbp-38h]
  __int64 v37; // [xsp+40h] [xbp-30h]
  __int64 v38; // [xsp+48h] [xbp-28h]
  unsigned __int64 v39; // [xsp+50h] [xbp-20h]
  unsigned int *v40; // [xsp+58h] [xbp-18h]
  __int64 v41; // [xsp+60h] [xbp-10h]

  v6 = s;
  v7 = result;
  if ( a3 == 2 && *s == 32123 )
  {
    if ( (a4 & 0x8000000000000000LL) != 0 )
    {
      if ( (int)a4 <= 0 || (v14 = a5[4]) == 0 )
LABEL_52:
        sub_6806F24("argument not found");
    }
    else
    {
      v14 = a4 & 0xF;
      if ( (a4 & 0xF) == 0 )
        goto LABEL_52;
    }
    v15 = v14 - 1;
    v16 = (__int64 (__fastcall *)(unsigned __int64, __int64 **, __int64 *))*((_QWORD *)a5 + 1);
    v18 = *(float *)a5;
    v17 = a5[1];
    switch ( v15 )
    {
      case 0u:
        result = sub_680A850(result, LODWORD(v18));
        break;
      case 1u:
        result = sub_68093A8(result, LODWORD(v18));
        break;
      case 2u:
        result = sub_680AA3C(result, *a5 | ((unsigned __int64)v17 << 32));
        break;
      case 3u:
        result = sub_680AC4C(result, *a5 | ((unsigned __int64)v17 << 32));
        break;
      case 4u:
        result = sub_680AE00(result, s, *a5 | ((unsigned __int64)v17 << 32), *((_QWORD *)a5 + 1));
        break;
      case 5u:
        result = sub_680B128(result, s, *a5 | ((unsigned __int64)v17 << 32), *((_QWORD *)a5 + 1));
        break;
      case 6u:
        *(_DWORD *)((char *)&v32 + 3) = 32;
        v19 = "true";
        if ( LOBYTE(v18) )
        {
          v20 = 4LL;
        }
        else
        {
          v19 = "false";
          v20 = 5LL;
        }
        LOBYTE(v32) = 0;
        v31 = (__int64 *)0xFFFFFFFF00000000LL;
        *(_WORD *)((char *)&v32 + 1) = 0;
        HIBYTE(v32) = 1;
        v34 = (__int64)v19;
        v35 = (_WORD *)v20;
        result = sub_680B3F4(result, &v31);
        break;
      case 7u:
        v21 = *(_QWORD *)(result + 16);
        v22 = v21 + 1;
        if ( *(_QWORD *)(result + 24) < (unsigned __int64)(v21 + 1) )
        {
          result = (**(__int64 (__fastcall ***)(__int64))result)(result);
          v21 = *(_QWORD *)(v7 + 16);
          v22 = v21 + 1;
        }
        v23 = *(_QWORD *)(v7 + 8);
        *(_QWORD *)(v7 + 16) = v22;
        *(_BYTE *)(v23 + v21) = LOBYTE(v18);
        break;
      case 8u:
        result = sub_680B5F8(result, v18);
        break;
      case 9u:
        result = sub_680CC80(result, COERCE_DOUBLE(*a5 | ((unsigned __int64)v17 << 32)));
        break;
      case 0xAu:
        *(_QWORD *)&v30 = *a5 | ((unsigned __int64)v17 << 32);
        *((_QWORD *)&v30 + 1) = *((_QWORD *)a5 + 1);
        result = sub_680DF58(result, 0xFFFFFFFF00000000LL, 0x100000020000000LL, 0LL, v30);
        break;
      case 0xBu:
        v24 = (const char *)(*a5 | ((unsigned __int64)v17 << 32));
        if ( !v24 )
          sub_6806F24("string pointer is null");
        v25 = &v24[strlen(v24)];
        goto LABEL_47;
      case 0xCu:
        v24 = (const char *)(*a5 | ((unsigned __int64)v17 << 32));
        v25 = (char *)v16 + (_QWORD)v24;
LABEL_47:
        result = sub_680ECFC(v24, v25, v7);
        break;
      case 0xDu:
        v26 = *a5 | ((unsigned __int64)v17 << 32);
        v27 = 2LL;
        v28 = v26;
        v32 = 0x100000020000000LL;
        v31 = (__int64 *)0xFFFFFFFF00000000LL;
        do
        {
          v29 = v28 > 0xF;
          ++v27;
          v28 >>= 4;
        }
        while ( v29 );
        v34 = v26;
        LODWORD(v35) = v27 - 2;
        result = sub_680F9F8(result, &v31, v27, v27, &v34);
        break;
      case 0xEu:
        v31 = 0LL;
        v32 = 0LL;
        v33 = 0;
        v34 = result;
        v35 = (_WORD *)a4;
        v36 = a5;
        v37 = a6;
        result = v16(LODWORD(v18) | ((unsigned __int64)v17 << 32), &v31, &v34);
        break;
      default:
        return result;
    }
    return result;
  }
  v8 = (char *)s + a3;
  v35 = s;
  v36 = (unsigned int *)a3;
  LODWORD(v37) = 0;
  v38 = result;
  v39 = a4;
  v40 = a5;
  v41 = a6;
  if ( a3 > 31 )
  {
    v31 = &v34;
    while ( 1 )
    {
      v13 = v6;
      if ( *v6 != 123 )
      {
        v13 = memchr(v6 + 1, 123, v8 - (v6 + 1));
        if ( !v13 )
          break;
      }
      sub_68100A8((int)&v31, v6);
      result = sub_680FBC4(v13, v8, &v34);
      v6 = (_BYTE *)result;
      if ( (char *)result == v8 )
        return result;
    }
    return sub_68100A8((int)&v31, v6);
  }
  else
  {
    if ( a3 )
    {
      v9 = s;
      do
      {
        v11 = *(unsigned __int8 *)s;
        s = (_WORD *)((char *)s + 1);
        v10 = v11;
        if ( v11 == 125 )
        {
          if ( s == (_WORD *)v8 || *(_BYTE *)s != 125 )
            sub_6806F24("unmatched '}' in format string");
          v12 = sub_680ECFC(v6, s, v38);
          s = v9 + 1;
          v38 = v12;
          v6 = v9 + 1;
        }
        else if ( v10 == 123 )
        {
          v38 = sub_680ECFC(v6, v9, v38);
          s = (_WORD *)sub_680FBC4(v9, v8, &v34);
          v6 = s;
        }
        v9 = s;
      }
      while ( s != (_WORD *)v8 );
      v7 = v38;
    }
    return sub_680ECFC(v6, v8, v7);
  }
}


================================================================================
Function: sub_6807640 (0x6807640)
================================================================================

unsigned __int64 __fastcall sub_6807640(float a1)
{
  int v1; // w16
  signed int v2; // w9
  unsigned int v3; // w8
  int v4; // w0
  unsigned __int64 v5; // x13
  int v6; // w14
  __int64 v7; // x12
  __int64 v8; // x10
  __int64 v9; // x15
  unsigned __int64 v10; // x11
  unsigned int v11; // w17
  unsigned __int64 v12; // x15
  unsigned int v13; // w15
  unsigned int v14; // w16
  int v15; // w11
  unsigned int v16; // w16
  unsigned int v17; // w11
  bool v18; // cc
  unsigned __int64 v19; // x10
  char v20; // w13
  unsigned int v21; // kr00_4
  unsigned __int64 v22; // x13
  unsigned int v23; // w12
  unsigned int v24; // w10
  __int64 v25; // x0
  unsigned int v26; // w9
  int v27; // w10
  unsigned int v28; // w11
  int v29; // w9
  unsigned int v30; // w8
  _BOOL4 v31; // w12
  unsigned int v32; // w9
  int v33; // w10
  unsigned int v34; // w12
  _BOOL4 v35; // w11
  unsigned int v37; // w14
  unsigned int v38; // w11

  v1 = LODWORD(a1) & 0x7FFFFF;
  if ( (LODWORD(a1) & 0x7F800000) != 0 )
  {
    v2 = ((LODWORD(a1) & 0x7F800000u) >> 23) - 150;
    if ( !v1 )
    {
      v3 = (1262611 * v2 - 524031) >> 22;
      v19 = qword_174D2A0[31 - v3];
      v20 = 40 - (((LODWORD(a1) & 0x7F800000u) >> 23) + 106 + ((int)(-1741647 * v3) >> 19));
      v21 = (v19 + (v19 >> 24)) >> v20;
      v22 = (v19 - (v19 >> 25)) >> v20;
      v23 = v21 / 0xA;
      if ( (v2 & 0xFFFFFFFE) != 2 )
        LODWORD(v22) = v22 + 1;
      if ( 10 * v23 < (unsigned int)v22 )
      {
        v24 = ((unsigned int)(v19 >> (39
                                    - ((unsigned __int8)((LODWORD(a1) & 0x7F800000u) >> 23)
                                     + 106
                                     + ((int)(-1741647 * v3) >> 19))))
             + 1) >> 1;
        if ( (LODWORD(a1) & 0x7F800000u) >> 23 == 115 )
        {
          v17 = v24 & 0x7FFFFFFE;
        }
        else if ( v24 >= (unsigned int)v22 )
        {
          v17 = v24;
        }
        else
        {
          v17 = v24 + 1;
        }
        return v17 | ((unsigned __int64)v3 << 32);
      }
      v26 = __clz(__rbit32(v23));
      if ( v26 >= 7 )
        v27 = 7;
      else
        v27 = v26;
      if ( (unsigned int)v27 >= 2 && (v28 = -1030792151 * v23, -1030792151 * v23 <= 0xA3D70A3) )
      {
        v29 = v27 & 6;
        if ( v27 >= 4 )
        {
          if ( 989560465 * v23 <= 0xA3D70A3 )
          {
            v28 = 989560465 * v23;
            if ( v27 >= 6 )
            {
              v28 = 1757569337 * v23;
              if ( 1757569337 * v23 > 0xA3D70A3 )
              {
                v28 = 989560465 * v23;
                v29 = 4;
              }
            }
          }
          else
          {
            v29 = 2;
          }
        }
      }
      else
      {
        v29 = 0;
        v28 = v21 / 0xA;
      }
      v30 = v3 + 1;
      if ( v29 < v27 )
      {
        v31 = -858993459 * v28 < 0x33333334;
        if ( -858993459 * v28 < 0x33333334 )
          v28 *= -858993459;
        v29 |= v31;
      }
      v17 = v28 >> v29;
LABEL_64:
      v3 = v30 + v29;
      return v17 | ((unsigned __int64)v3 << 32);
    }
    v1 |= 0x800000u;
  }
  else
  {
    if ( !v1 )
    {
      v17 = 0;
      v3 = 0;
      return v17 | ((unsigned __int64)v3 << 32);
    }
    v2 = -149;
  }
  v3 = (1262611 * v2) >> 22;
  v4 = (2 * (v1 & 0xFFFFFF)) | 1;
  v5 = qword_174D2A0[32 - v3];
  v6 = v2 + ((int)(1741647 - 1741647 * v3) >> 19);
  v7 = ((__int64)(1262611 * v2) >> 22) - 1;
  v8 = (unsigned int)(2 * v1);
  v9 = ((unsigned int)(v4 << (v2 + ((int)(1741647 - 1741647 * v3) >> 19))) * (unsigned __int128)v5) >> 64;
  v10 = (unsigned __int64)(1374389535 * v9) >> 37;
  v11 = (unsigned int)v9 % 0x64;
  v12 = v5 >> (63 - ((unsigned __int8)v2 + (unsigned __int8)((int)(1741647 - 1741647 * v3) >> 19)));
  if ( v11 > (unsigned int)v12 )
    goto LABEL_7;
  if ( v11 >= (unsigned int)v12 )
  {
    v25 = (unsigned int)(v8 - 1);
    if ( (v1 & 1) == 0
      && v2 >= -1
      && (v2 < 7
       || (unsigned int)v2 <= 0x27 && (unsigned int)(dword_174DCAC[2 * (int)v7] * v25) <= dword_174DCAC[2 * (int)v7 + 1])
      || (((v5 * v25) >> -(char)v6) & 1) != 0 )
    {
      goto LABEL_53;
    }
  }
  else
  {
    if ( (v1 & 1) == 0
      || (!v11 ? (v18 = v2 < -1) : (v18 = 1),
          v18
       || v2 >= 7 && ((unsigned int)v2 > 0x27 || (unsigned int)(dword_174DCAC[2 * v7] * v4) > dword_174DCAC[2 * v7 + 1])) )
    {
LABEL_53:
      v32 = __clz(__rbit32(v10));
      if ( v32 >= 7 )
        v33 = 7;
      else
        v33 = v32;
      if ( (unsigned int)v33 >= 2 && (v34 = -1030792151 * v10, (unsigned int)(-1030792151 * v10) <= 0xA3D70A3) )
      {
        v29 = v33 & 6;
        if ( v33 >= 4 )
        {
          v37 = 989560465 * v10;
          if ( (unsigned int)(989560465 * v10) <= 0xA3D70A3 )
          {
            v34 = 989560465 * v10;
            if ( v33 >= 6 )
            {
              v38 = 1757569337 * v10;
              v34 = v38 <= 0xA3D70A3 ? v38 : v37;
              if ( v38 > 0xA3D70A3 )
                v29 = 4;
            }
          }
          else
          {
            v29 = 2;
          }
        }
      }
      else
      {
        v29 = 0;
        v34 = v10;
      }
      v30 = v3 + 1;
      if ( v29 < v33 )
      {
        v35 = -858993459 * v34 < 0x33333334;
        if ( -858993459 * v34 < 0x33333334 )
          v34 *= -858993459;
        v29 |= v35;
      }
      v17 = v34 >> v29;
      goto LABEL_64;
    }
    LODWORD(v10) = v10 - 1;
    v11 = 100;
  }
LABEL_7:
  v13 = v11 - ((unsigned int)v12 >> 1);
  v14 = v13 + 5;
  v15 = 10 * v10;
  if ( ((v13 + 5) & 1) != 0 )
  {
    v17 = v15 + ((52429 * v14) >> 19);
  }
  else
  {
    v16 = 52429 * (v14 >> 1);
    v17 = v15 + (v16 >> 18);
    if ( (unsigned __int16)((unsigned __int16)v16 >> 2) <= 0xCCCu )
    {
      if ( (((unsigned int)((v5 * v8) >> -(char)v6) ^ ((v13 & 1) == 0)) & 1) != 0 )
      {
        if ( v2 <= 39 )
        {
          if ( v2 < 7 )
          {
            if ( v2 > -3 || (int)__clz(__rbit32(v8)) > (int)v7 - v2 )
              goto LABEL_81;
          }
          else if ( (unsigned int)(dword_174DCAC[2 * (int)v7] * v8) <= dword_174DCAC[2 * (int)v7 + 1] )
          {
LABEL_81:
            v17 &= ~1u;
          }
        }
      }
      else
      {
        --v17;
      }
    }
  }
  return v17 | ((unsigned __int64)v3 << 32);
}


================================================================================
Function: sub_6807AA0 (0x6807AA0)
================================================================================

unsigned __int64 __fastcall sub_6807AA0(double a1)
{
  __int64 v1; // x8
  __int64 v2; // x13
  int v3; // w9
  int v4; // w8
  __int64 v5; // x10
  unsigned int v6; // w11
  unsigned int v7; // w17
  unsigned __int64 *v8; // x15
  int v9; // w1
  int v10; // w0
  unsigned __int64 v11; // x11
  unsigned __int64 v12; // x12
  int v13; // w15
  _BOOL8 v14; // x17
  unsigned __int64 v15; // x2
  unsigned __int64 v16; // x12
  int v17; // w16
  __int64 v18; // x1
  unsigned __int64 v19; // x11
  unsigned __int64 v20; // x12
  char v21; // w15
  __int64 v22; // x1
  unsigned __int64 v23; // x14
  unsigned __int64 result; // x0
  unsigned int v25; // w17
  unsigned __int64 v26; // x16
  unsigned __int64 v27; // x14
  unsigned int v28; // w13
  __int64 v29; // x16
  unsigned int v30; // w17
  bool v31; // cc
  int v32; // w8
  int v33; // w12
  unsigned int v34; // w10
  unsigned int v35; // w14
  __int64 *v36; // x16
  char v37; // w10
  signed int v38; // w13
  unsigned __int64 v39; // x11
  __int64 v40; // x16
  bool v41; // cf
  int v42; // w14
  unsigned __int64 v43; // x15
  __int64 v44; // x17
  unsigned __int64 v45; // x16
  int v46; // w12
  unsigned __int64 v47; // x12
  unsigned __int64 v48; // x13
  unsigned __int64 v49; // x10
  unsigned __int64 v50; // x1
  unsigned int v51; // w9
  unsigned __int64 v52; // x11
  int v53; // w10
  int v54; // w14
  unsigned int v55; // w17
  unsigned __int64 v56; // x10
  int v57; // w11
  int v58; // w11
  unsigned int v59; // w14
  unsigned int v61; // w13
  unsigned int v63; // w9

  v1 = (*(_QWORD *)&a1 >> 52) & 0x7FFLL;
  v2 = *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL;
  if ( (_DWORD)v1 )
  {
    v3 = v1 - 1075;
    if ( !v2 )
    {
      v32 = (1262611 * v3 - 524031) >> 22;
      v33 = (-1741647 * v32) >> 19;
      v34 = (((12137 * (unsigned int)(unsigned __int16)(292 - v32)) >> 16)
           + ((unsigned __int16)((292 - v32 - ((12137 * (unsigned int)(unsigned __int16)(292 - v32)) >> 16)) & 0xFFFE) >> 1)) >> 4;
      v35 = 27 * v34;
      v36 = (__int64 *)((char *)&unk_174D510 + 16 * v34);
      v37 = v33 + v3;
      v38 = v35 - 292 + v32;
      v39 = v36[1];
      if ( v38 )
      {
        v40 = *v36;
        v41 = v35 >= 0x124;
        v42 = 1741647 * (v35 - 292);
        v44 = !v41;
        v45 = v40 - v44;
        v46 = v38 - (v42 >> 19) + v33;
        v43 = qword_174D680[-v38];
        v39 = (((v39 * (unsigned __int128)v43 + ((v43 * (unsigned __int128)v45) >> 64)) >> 64 << -(char)v46) | ((unsigned __int64)(v39 * v43 + ((v43 * (unsigned __int128)v45) >> 64)) >> v46))
            + __CFADD__(
                ((((v43 * (unsigned __int128)v45) >> 64) + v39 * v43) << -(char)v46) | ((v43 * v45) >> v46),
                v44);
      }
      v47 = (v39 + (v39 >> 53)) >> (11 - v37);
      v48 = (v39 - (v39 >> 54)) >> (11 - v37);
      result = v47 / 0xA;
      if ( (v3 & 0xFFFFFFFE) != 2 )
        ++v48;
      if ( 10 * (v47 / 0xA) < v48 )
      {
        v49 = ((v39 >> (10 - v37)) + 1) >> 1;
        if ( v3 == -77 )
          return v49 & 0x7FFFFFFFFFFFFFFELL;
        if ( v49 >= v48 )
          return v49;
        return v49 + 1;
      }
      v51 = __clz(__rbit64(result));
      if ( v51 >= 0x10 )
        v51 = 16;
      if ( v51 < 8 )
      {
        if ( !v51 )
          return result;
      }
      else if ( 0xC767074B22E90E21LL * result < 0x2AF31DC46119LL )
      {
        v52 = (0xC767074B22E90E21LL * result) >> 8;
        if ( v51 >= 9 )
        {
          v53 = 8;
          while ( 1 )
          {
            v54 = -858993459 * v52;
            if ( (unsigned int)(-858993459 * v52) > 0x33333333 )
              break;
            ++v53;
            LODWORD(v52) = -858993459 * v52;
            if ( v51 == v53 )
            {
LABEL_62:
              LODWORD(v52) = v54;
              LOBYTE(v53) = v51;
              return (unsigned int)v52 >> (v53 - 8);
            }
          }
          return (unsigned int)v52 >> (v53 - 8);
        }
        goto LABEL_74;
      }
      v58 = result - 100000000 * (v47 / 0x3B9ACA00);
      if ( (unsigned int)(-858993459 * v58) > 0x33333333 )
        return result;
      v59 = -1030792151 * v58;
      if ( v51 == 1 || v59 > 0x33333333 )
        return ((unsigned int)(-858993459 * v58) >> 1) + 10000000LL * (unsigned int)(v47 / 0x3B9ACA00);
      v61 = 652835029 * v58;
      if ( v51 == 2 || v61 > 0x33333333 )
        return (v59 >> 2) + 1000000LL * (unsigned int)(v47 / 0x3B9ACA00);
      if ( v51 == 3 || (unsigned int)(989560465 * v58) > 0x33333333 )
        return (v61 >> 3) + 100000LL * (unsigned int)(v47 / 0x3B9ACA00);
      if ( v51 == 4 || (unsigned int)(197912093 * v58) > 0x33333333 )
        return ((unsigned int)(989560465 * v58) >> 4) + 10000LL * (unsigned int)(v47 / 0x3B9ACA00);
      if ( v51 == 5 || (unsigned int)(1757569337 * v58) > 0x33333333 )
        return ((unsigned int)(197912093 * v58) >> 5) + 1000LL * (unsigned int)(v47 / 0x3B9ACA00);
      if ( v51 == 6 )
        return ((unsigned int)(1757569337 * v58) >> 6) + 100LL * (unsigned int)(v47 / 0x3B9ACA00);
      v63 = -1366473051 * v58;
      if ( (unsigned int)(-1366473051 * v58) > 0x33333333 )
        return ((unsigned int)(1757569337 * v58) >> 6) + 100LL * (unsigned int)(v47 / 0x3B9ACA00);
      v56 = (unsigned int)(v47 / 0x3B9ACA00);
      return (v63 >> 7) + 10 * v56;
    }
    v2 |= 0x10000000000000uLL;
  }
  else
  {
    if ( !v2 )
      return 0LL;
    v3 = -1074;
  }
  v4 = (1262611 * v3) >> 22;
  v5 = ((__int64)(1262611 * v3) >> 22) - 2;
  v6 = (((12137 * (unsigned int)(unsigned __int16)(294 - ((__int16)((unsigned int)(1262611 * v3) >> 16) >> 6))) >> 16)
      + ((unsigned __int16)((294
                           - ((__int16)((unsigned int)(1262611 * v3) >> 16) >> 6)
                           - ((12137
                             * (unsigned int)(unsigned __int16)(294
                                                              - ((__int16)((unsigned int)(1262611 * v3) >> 16) >> 6))) >> 16)) & 0xFFFE) >> 1)) >> 4;
  v7 = 27 * v6;
  v8 = (unsigned __int64 *)((char *)&unk_174D510 + 16 * v6);
  v9 = 27 * v6 - 292;
  v10 = 2 - v4 - v9;
  v12 = *v8;
  v11 = v8[1];
  v13 = (1741647 * (2 - v4)) >> 19;
  if ( 2 - v4 != v9 )
  {
    v14 = v7 < 0x124;
    v15 = qword_174D680[v10];
    v16 = v12 - v14;
    v17 = v13 - (v10 + ((1741647 * v9) >> 19));
    v18 = (v11 * (unsigned __int128)v15 + ((v15 * (unsigned __int128)v16) >> 64)) >> 64;
    v19 = (__PAIR128__(v11, v16) * v15) >> 64;
    v20 = (v19 << -(char)v17) | ((v15 * v16) >> v17);
    v11 = __CFADD__(v20, v14) + ((v18 << -(char)v17) | (v19 >> v17));
    v12 = v20 + v14 + (((unsigned __int64)dword_174D758[(unsigned int)(294 - v4) >> 4] >> ((2 * (38 - v4)) & 0x1E)) & 3);
  }
  v21 = v13 + v3;
  v22 = (2 * (v2 & 0x1FFFFFFFFFFFFFLL)) | 1;
  v23 = __CFADD__((v12 * (unsigned __int128)(unsigned __int64)(v22 << v21)) >> 64, v11 * (v22 << v21))
      + ((v11 * (unsigned __int128)(unsigned __int64)(v22 << v21)) >> 64);
  result = (unsigned __int64)((v23 * (unsigned __int128)0x83126E978D4FDF3CLL) >> 64) >> 9;
  v25 = v23 - 1000 * result;
  v26 = v11 >> (63 - v21);
  v27 = 2 * v2;
  if ( (unsigned int)v26 >= v25 )
  {
    if ( (unsigned int)v26 <= v25 )
    {
      v50 = v27 - 1;
      if ( ((v2 & 1) != 0
         || v3 < -2
         || v3 >= 10 && ((unsigned int)v3 > 0x56 || qword_174DD08[2 * (int)v5] * v50 > qword_174DD08[2 * (int)v5 + 1]))
        && (((unsigned __int64)((__PAIR128__(v11, v12) * v50) >> 64) >> -v21) & 1) == 0 )
      {
        goto LABEL_9;
      }
    }
    else if ( (v2 & 1) != 0 )
    {
      v31 = v25 || v3 < -2;
      if ( !v31
        && (v3 < 10
         || (unsigned int)v3 <= 0x56 && (unsigned __int64)(qword_174DD08[2 * v5] * v22) <= qword_174DD08[2 * v5 + 1]) )
      {
        --result;
        v25 = 1000;
        goto LABEL_9;
      }
    }
    v51 = __clz(__rbit64(result));
    if ( v51 >= 0x10 )
      v51 = 16;
    if ( v51 < 8 )
    {
      if ( !v51 )
        return result;
    }
    else if ( 0xC767074B22E90E21LL * result < 0x2AF31DC46119LL )
    {
      v52 = (0xC767074B22E90E21LL * result) >> 8;
      if ( v51 >= 9 )
      {
        v53 = 8;
        while ( 1 )
        {
          v54 = -858993459 * v52;
          if ( (unsigned int)(-858993459 * v52) > 0x33333333 )
            return (unsigned int)v52 >> (v53 - 8);
          ++v53;
          LODWORD(v52) = -858993459 * v52;
          if ( v51 == v53 )
            goto LABEL_62;
        }
      }
LABEL_74:
      LOBYTE(v53) = 8;
      return (unsigned int)v52 >> (v53 - 8);
    }
    v56 = result / 0x5F5E100;
    v57 = result % 0x5F5E100;
    if ( (unsigned int)(-858993459 * v57) > 0x33333333 )
      return result;
    if ( v51 == 1 || (unsigned int)(-1030792151 * v57) > 0x33333333 )
      return ((unsigned int)(-858993459 * v57) >> 1) + 10000000 * v56;
    if ( v51 == 2 || (unsigned int)(652835029 * v57) > 0x33333333 )
      return ((unsigned int)(-1030792151 * v57) >> 2) + 1000000 * v56;
    if ( v51 == 3 || (unsigned int)(989560465 * v57) > 0x33333333 )
      return ((unsigned int)(652835029 * v57) >> 3) + 100000 * v56;
    if ( v51 == 4 || (unsigned int)(197912093 * v57) > 0x33333333 )
      return ((unsigned int)(989560465 * v57) >> 4) + 10000 * v56;
    if ( v51 == 5 || (unsigned int)(1757569337 * v57) > 0x33333333 )
      return ((unsigned int)(197912093 * v57) >> 5) + 1000 * v56;
    if ( v51 == 6 )
      return ((unsigned int)(1757569337 * v57) >> 6) + 100 * v56;
    v63 = -1366473051 * v57;
    if ( (unsigned int)(-1366473051 * v57) > 0x33333333 )
      return ((unsigned int)(1757569337 * v57) >> 6) + 100 * v56;
    return (v63 >> 7) + 10 * v56;
  }
LABEL_9:
  v28 = v25 - ((unsigned int)v26 >> 1);
  v29 = 10 * result;
  v30 = v28 + 50;
  if ( ((v28 + 50) & 3) != 0 )
    return v29 + ((41944 * v30) >> 22);
  v55 = 42025 * (v30 >> 2);
  result = v29 + (v55 >> 20);
  if ( (unsigned __int8)v55 <= 0xAu )
  {
    if ( (((unsigned int)((unsigned __int64)((__PAIR128__(v11, v12) * v27) >> 64) >> -v21) ^ ((v28 & 1) == 0)) & 1) == 0 )
      return --result;
    if ( v3 <= 86 )
    {
      if ( v3 >= 10 )
      {
        if ( qword_174DD08[2 * (int)v5] * v27 > qword_174DD08[2 * (int)v5 + 1] )
          return result;
LABEL_88:
        result &= ~1uLL;
        return result;
      }
      if ( v3 > -5 || (int)v5 - v3 < (int)__clz(__rbit64(v27)) )
        goto LABEL_88;
    }
  }
  return result;
}


================================================================================
Function: sub_680833C (0x680833C)
================================================================================

long double __usercall sub_680833C@<Q0>(__int64 *a1@<X0>, __int64 a2@<X8>)
{
  __int64 v3; // x2
  __int64 *v4; // x20
  unsigned __int64 v5; // x8
  char v6; // w0
  long double result; // q0
  __int64 v8; // x8
  long double v9; // [xsp+0h] [xbp-20h] BYREF
  __int64 v10; // [xsp+10h] [xbp-10h]

  if ( a1 )
    sub_683B82C((__int64 *)&v9, a1);
  else
    sub_683B7A0(&v9);
  v4 = sub_683BBD0((__int64 *)&v9, (__int64)&qword_79D7EA8, v3);
  sub_683B844(&v9);
  (*(void (__fastcall **)(long double *__return_ptr, __int64 *))(*v4 + 40))(&v9, v4);
  if ( (LOBYTE(v9) & 1) != 0 )
    v5 = *((_QWORD *)&v9 + 1);
  else
    v5 = (unsigned __int64)LOBYTE(v9) >> 1;
  if ( v5 )
    v6 = (*(__int64 (__fastcall **)(__int64 *))(*v4 + 32))(v4);
  else
    v6 = 0;
  result = v9;
  *(_BYTE *)(a2 + 24) = v6;
  v8 = v10;
  *(long double *)a2 = result;
  *(_QWORD *)(a2 + 16) = v8;
  return result;
}


================================================================================
Function: sub_680844C (0x680844C)
================================================================================

__int64 __fastcall sub_680844C(int a1, __int64 a2, __int64 a3, double a4)
{
  int v4; // w27
  int v7; // w9
  unsigned int v8; // w20
  char *v9; // x9
  char v10; // w8
  __int64 v11; // x28
  __int64 v12; // x26
  __int64 v13; // x8
  unsigned __int64 v14; // x1
  __int64 v15; // x25
  __int64 v16; // x21
  size_t v17; // x24
  char *v18; // x0
  unsigned int v19; // w23
  unsigned __int64 v20; // x8
  __int64 v21; // x24
  __int64 v22; // x8
  __int64 v23; // x9
  unsigned __int64 v24; // x20
  __int64 result; // x0
  __int64 v26; // x10
  __int64 v27; // x8
  __int64 v28; // x11
  __int64 v29; // x9
  int v30; // w11
  int v31; // w10
  int v32; // w14
  int v33; // w22
  unsigned int v34; // w23
  __int64 v35; // x10
  int v36; // w9
  int v37; // w11
  unsigned __int64 v38; // x20
  char v39; // [xsp+0h] [xbp-20h] BYREF
  char v40; // [xsp+1h] [xbp-1Fh] BYREF
  _BYTE v41[6]; // [xsp+2h] [xbp-1Eh] BYREF

  v4 = BYTE4(a2);
  v7 = a1 - 1;
  if ( a1 < 0 )
    v7 = 5;
  if ( BYTE4(a2) >= 2u )
    v8 = a1;
  else
    v8 = v7;
  v9 = &v40;
  v39 = 37;
  if ( (a2 & 0x10000000000000LL) != 0 && BYTE4(a2) == 3 )
  {
    v9 = v41;
    v40 = 35;
  }
  if ( (v8 & 0x80000000) == 0 )
  {
    *(_WORD *)v9 = 10798;
    v9 += 2;
  }
  if ( BYTE4(a2) == 3 )
  {
    if ( (a2 & 0x1000000000000LL) != 0 )
      v10 = 65;
    else
      v10 = 97;
  }
  else if ( BYTE4(a2) == 2 )
  {
    v10 = 102;
  }
  else
  {
    v10 = 101;
  }
  *v9 = v10;
  v9[1] = 0;
  v11 = *(_QWORD *)(a3 + 16);
  v12 = v11 + 1;
  while ( 1 )
  {
    while ( 1 )
    {
      v15 = *(_QWORD *)(a3 + 8);
      v16 = v15 + v11;
      v17 = *(_QWORD *)(a3 + 24) - v11;
      v18 = (char *)(v15 + v11);
      if ( (v8 & 0x80000000) == 0 )
        break;
      v19 = snprintf(v18, v17, &v39, a4);
      if ( (v19 & 0x80000000) == 0 )
        goto LABEL_26;
LABEL_19:
      v13 = *(_QWORD *)(a3 + 24);
      if ( v13 != -1 )
      {
        v14 = v13 + 1;
        goto LABEL_21;
      }
    }
    v19 = snprintf(v18, v17, &v39, v8, a4);
    if ( (v19 & 0x80000000) != 0 )
      goto LABEL_19;
LABEL_26:
    if ( v17 > v19 )
      break;
    v14 = v12 + v19;
    if ( *(_QWORD *)(a3 + 24) < v14 )
LABEL_21:
      (**(void (__fastcall ***)(__int64, unsigned __int64))a3)(a3, v14);
  }
  if ( v4 == 2 )
  {
    if ( v8 )
    {
      v21 = 0LL;
      v22 = v16 + v19;
      do
        v23 = v22 + v21--;
      while ( (unsigned int)*(unsigned __int8 *)(v23 - 1) - 48 < 0xA );
      memmove((void *)(v22 + v21), (const void *)(v22 + v21 + 1), (unsigned int)~(_DWORD)v21);
      v20 = *(_QWORD *)(a3 + 24);
      v24 = v19 - 1;
      if ( v20 < v24 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a3)(a3, v19 - 1);
        v20 = *(_QWORD *)(a3 + 24);
      }
      result = (unsigned int)(v21 + 1);
      if ( v20 >= v24 )
        v20 = v19 - 1;
    }
    else
    {
      v20 = *(_QWORD *)(a3 + 24);
      if ( v20 < v19 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a3)(a3, v19);
        v20 = *(_QWORD *)(a3 + 24);
      }
      if ( v20 >= v19 )
        v20 = v19;
LABEL_65:
      result = 0LL;
    }
  }
  else
  {
    if ( v4 == 3 )
    {
      v20 = *(_QWORD *)(a3 + 24);
      if ( v20 < v11 + (unsigned __int64)v19 )
      {
        (**(void (__fastcall ***)(__int64, __int64))a3)(a3, v11 + v19);
        v20 = *(_QWORD *)(a3 + 24);
      }
      if ( v20 >= v11 + (unsigned __int64)v19 )
        v20 = v11 + v19;
      goto LABEL_65;
    }
    v26 = 1LL;
    v27 = v19;
    do
    {
      v28 = v27--;
      v29 = v26--;
    }
    while ( *(_BYTE *)(v16 + v27) != 101 );
    v30 = *(unsigned __int8 *)(v16 + v28);
    v31 = 0;
    do
    {
      v32 = *(char *)(v16 + v19 + v29++);
      v31 = v32 + 10 * v31 - 48;
    }
    while ( v29 );
    if ( v30 == 45 )
      v33 = -v31;
    else
      v33 = v31;
    if ( v27 == 1 )
    {
      v34 = 0;
    }
    else
    {
      v35 = v11 + v15 - 1;
      v36 = -1;
      do
      {
        v37 = *(unsigned __int8 *)(v35 + v27);
        --v36;
        --v35;
      }
      while ( v37 == 48 );
      v34 = v27 + v36;
      memmove((void *)(v16 + 1), (const void *)(v16 + 2), (unsigned int)(v27 + v36));
    }
    v20 = *(_QWORD *)(a3 + 24);
    v38 = v12 + v34;
    if ( v20 < v38 )
    {
      (**(void (__fastcall ***)(__int64, __int64))a3)(a3, v12 + v34);
      v20 = *(_QWORD *)(a3 + 24);
    }
    result = v33 - v34;
    if ( v20 >= v38 )
      v20 = v12 + v34;
  }
  *(_QWORD *)(a3 + 16) = v20;
  return result;
}


================================================================================
Function: sub_6808794 (0x6808794)
================================================================================

__int64 __fastcall sub_6808794(int a1, __int64 a2, __int64 a3, double a4)
{
  int v4; // w27
  int v6; // w9
  unsigned int v7; // w20
  char *v8; // x9
  char v9; // w8
  __int64 v10; // x28
  __int64 v11; // x26
  __int64 v12; // x8
  unsigned __int64 v13; // x1
  __int64 v14; // x25
  __int64 v15; // x21
  size_t v16; // x24
  char *v17; // x0
  unsigned int v18; // w23
  unsigned __int64 v19; // x8
  __int64 v20; // x24
  __int64 v21; // x8
  __int64 v22; // x9
  unsigned __int64 v23; // x20
  __int64 result; // x0
  __int64 v25; // x10
  __int64 v26; // x8
  __int64 v27; // x11
  __int64 v28; // x9
  int v29; // w11
  int v30; // w10
  int v31; // w14
  int v32; // w22
  unsigned int v33; // w23
  __int64 v34; // x10
  int v35; // w9
  int v36; // w11
  unsigned __int64 v37; // x20
  char format; // [xsp+10h] [xbp-10h] BYREF
  char v40; // [xsp+11h] [xbp-Fh] BYREF
  _BYTE v41[6]; // [xsp+12h] [xbp-Eh] BYREF

  v4 = BYTE4(a2);
  v6 = a1 - 1;
  if ( a1 < 0 )
    v6 = 5;
  if ( BYTE4(a2) >= 2u )
    v7 = a1;
  else
    v7 = v6;
  v8 = &v40;
  format = 37;
  if ( (a2 & 0x10000000000000LL) != 0 && BYTE4(a2) == 3 )
  {
    v8 = v41;
    v40 = 35;
  }
  if ( (v7 & 0x80000000) == 0 )
  {
    *(_WORD *)v8 = 10798;
    v8 += 2;
  }
  *v8 = 76;
  if ( BYTE4(a2) == 3 )
  {
    if ( (a2 & 0x1000000000000LL) != 0 )
      v9 = 65;
    else
      v9 = 97;
  }
  else if ( BYTE4(a2) == 2 )
  {
    v9 = 102;
  }
  else
  {
    v9 = 101;
  }
  v8[1] = v9;
  v8[2] = 0;
  v10 = *(_QWORD *)(a3 + 16);
  v11 = v10 + 1;
  while ( 1 )
  {
    while ( 1 )
    {
      v14 = *(_QWORD *)(a3 + 8);
      v15 = v14 + v10;
      v16 = *(_QWORD *)(a3 + 24) - v10;
      v17 = (char *)(v14 + v10);
      if ( (v7 & 0x80000000) == 0 )
        break;
      v18 = snprintf(v17, v16, &format, a4);
      if ( (v18 & 0x80000000) == 0 )
        goto LABEL_26;
LABEL_19:
      v12 = *(_QWORD *)(a3 + 24);
      if ( v12 != -1 )
      {
        v13 = v12 + 1;
        goto LABEL_21;
      }
    }
    v18 = snprintf(v17, v16, &format, v7, a4);
    if ( (v18 & 0x80000000) != 0 )
      goto LABEL_19;
LABEL_26:
    if ( v16 > v18 )
      break;
    v13 = v11 + v18;
    if ( *(_QWORD *)(a3 + 24) < v13 )
LABEL_21:
      (**(void (__fastcall ***)(__int64, unsigned __int64))a3)(a3, v13);
  }
  if ( v4 == 2 )
  {
    if ( v7 )
    {
      v20 = 0LL;
      v21 = v15 + v18;
      do
        v22 = v21 + v20--;
      while ( (unsigned int)*(unsigned __int8 *)(v22 - 1) - 48 < 0xA );
      memmove((void *)(v21 + v20), (const void *)(v21 + v20 + 1), (unsigned int)~(_DWORD)v20);
      v19 = *(_QWORD *)(a3 + 24);
      v23 = v18 - 1;
      if ( v19 < v23 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a3)(a3, v18 - 1);
        v19 = *(_QWORD *)(a3 + 24);
      }
      result = (unsigned int)(v20 + 1);
      if ( v19 >= v23 )
        v19 = v18 - 1;
    }
    else
    {
      v19 = *(_QWORD *)(a3 + 24);
      if ( v19 < v18 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a3)(a3, v18);
        v19 = *(_QWORD *)(a3 + 24);
      }
      if ( v19 >= v18 )
        v19 = v18;
LABEL_65:
      result = 0LL;
    }
  }
  else
  {
    if ( v4 == 3 )
    {
      v19 = *(_QWORD *)(a3 + 24);
      if ( v19 < v10 + (unsigned __int64)v18 )
      {
        (**(void (__fastcall ***)(__int64, __int64))a3)(a3, v10 + v18);
        v19 = *(_QWORD *)(a3 + 24);
      }
      if ( v19 >= v10 + (unsigned __int64)v18 )
        v19 = v10 + v18;
      goto LABEL_65;
    }
    v25 = 1LL;
    v26 = v18;
    do
    {
      v27 = v26--;
      v28 = v25--;
    }
    while ( *(_BYTE *)(v15 + v26) != 101 );
    v29 = *(unsigned __int8 *)(v15 + v27);
    v30 = 0;
    do
    {
      v31 = *(char *)(v15 + v18 + v28++);
      v30 = v31 + 10 * v30 - 48;
    }
    while ( v28 );
    if ( v29 == 45 )
      v32 = -v30;
    else
      v32 = v30;
    if ( v26 == 1 )
    {
      v33 = 0;
    }
    else
    {
      v34 = v10 + v14 - 1;
      v35 = -1;
      do
      {
        v36 = *(unsigned __int8 *)(v34 + v26);
        --v35;
        --v34;
      }
      while ( v36 == 48 );
      v33 = v26 + v35;
      memmove((void *)(v15 + 1), (const void *)(v15 + 2), (unsigned int)(v26 + v35));
    }
    v19 = *(_QWORD *)(a3 + 24);
    v37 = v11 + v33;
    if ( v19 < v37 )
    {
      (**(void (__fastcall ***)(__int64, __int64))a3)(a3, v11 + v33);
      v19 = *(_QWORD *)(a3 + 24);
    }
    result = v32 - v33;
    if ( v19 >= v37 )
      v19 = v11 + v33;
  }
  *(_QWORD *)(a3 + 16) = v19;
  return result;
}


================================================================================
Function: sub_6808ADC (0x6808ADC)
================================================================================

__int64 __fastcall sub_6808ADC(size_t n, unsigned __int64 a2, _QWORD *a3, double a4)
{
  int v5; // w20
  unsigned __int64 v6; // x21
  __int64 v7; // x0
  __int64 v8; // x16
  __int64 v9; // x10
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x10
  unsigned __int64 v12; // x11
  __int64 v13; // x10
  int v14; // w23
  unsigned __int64 v15; // x11
  int v16; // w12
  int v17; // w11
  __int64 v18; // x11
  __int16 v19; // w14
  int v20; // w13
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // x26
  char *v23; // x12
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x3
  unsigned __int64 v27; // x15
  __int64 v28; // x17
  int v29; // w16
  __int64 v30; // x13
  unsigned __int64 v31; // x4
  __int64 v32; // x2
  unsigned int v33; // w27
  unsigned int v34; // w1
  int v35; // w9
  __int64 v36; // x3
  unsigned int v37; // w16
  unsigned __int64 v38; // x9
  unsigned __int64 v39; // x8
  unsigned __int64 v40; // x10
  __int64 v41; // x11
  unsigned __int64 v42; // x8
  unsigned __int64 v43; // x8
  void *v44; // x0
  unsigned __int64 v45; // x20
  __int64 v47; // x8
  __int64 v48; // x1
  __int64 v49; // x9
  unsigned __int64 v50; // x0
  int v51; // w1
  unsigned __int64 v52; // x10
  __int64 v53; // x9
  unsigned int v54; // w8
  float v55; // s0
  unsigned __int64 v56; // x0
  __int64 v57; // x8
  unsigned __int64 v58; // x10
  __int64 v59; // x10
  unsigned __int64 v60; // x17
  char *v61; // x8
  bool v62; // cf
  unsigned __int64 v63; // x8
  __int64 v64; // x8
  __int64 v65; // x10
  __int64 v66; // x13
  __int64 v67; // x11
  __int64 v68; // x14
  __int64 v69; // x15
  unsigned int v70; // w1
  char v71; // w2
  float v72; // s0
  int v73; // w3
  char v74; // w8
  unsigned __int64 v75; // x20
  unsigned __int64 v76; // x8
  unsigned __int64 v77; // x20
  __int64 v78; // x8
  unsigned __int64 v79; // x8
  _QWORD *v80; // x19
  int v81; // [xsp+4h] [xbp-2Ch]
  unsigned int v82; // [xsp+8h] [xbp-28h]
  int v83; // [xsp+20h] [xbp-10h]
  int v84; // [xsp+24h] [xbp-Ch] BYREF

  v5 = n;
  v6 = HIDWORD(a2);
  if ( a4 <= 0.0 )
  {
    if ( (int)n >= 1 && BYTE4(a2) == 2 )
    {
      v43 = a3[3];
      if ( v43 < (unsigned int)n )
      {
        (*(void (__fastcall **)(_QWORD *, _QWORD))*a3)(a3, (unsigned int)n);
        v43 = a3[3];
      }
      v44 = (void *)a3[1];
      if ( v43 >= (unsigned int)v5 )
        v43 = (unsigned int)v5;
      a3[2] = v43;
      memset(v44, 48, (unsigned int)v5);
      LODWORD(v45) = -v5;
    }
    else
    {
      v47 = a3[2];
      v48 = v47 + 1;
      if ( a3[3] < (unsigned __int64)(v47 + 1) )
      {
        (*(void (__fastcall **)(_QWORD *))*a3)(a3);
        v47 = a3[2];
        v48 = v47 + 1;
      }
      v49 = a3[1];
      LODWORD(v45) = 0;
      a3[2] = v48;
      *(_BYTE *)(v49 + v47) = 48;
    }
  }
  else
  {
    if ( (a2 & 0x8000000000000LL) != 0 )
      return sub_680844C(n, a2, (__int64)a3, a4);
    if ( (n & 0x80000000) == 0 )
    {
      if ( ((*(_QWORD *)&a4 >> 52) & 0x7FF) != 0 )
        v7 = *(_QWORD *)&a4 & 0xFFFFFFFFFFFFFLL | 0x10000000000000LL;
      else
        v7 = *(_QWORD *)&a4 & 0xFFFFFFFFFFFFFLL;
      if ( ((*(_QWORD *)&a4 >> 52) & 0x7FF) != 0 )
        v8 = (unsigned int)((*(_QWORD *)&a4 >> 52) & 0x7FF) - 1075;
      else
        v8 = 4294966222LL;
      v9 = v7;
      v10 = v8;
      if ( (v7 & 0x10000000000000LL) == 0 )
      {
        v11 = __clz(*(_QWORD *)&a4 & 0xFFFFFFFFFFFFFLL) - 11;
        v10 = v8;
        v12 = v11;
        do
        {
          v10 = (unsigned int)(v10 - 1) | v10 & 0xFFFFFFFF00000000LL;
          --v12;
        }
        while ( v12 );
        v9 = v7 << v11;
      }
      v13 = v9 << 11;
      v14 = BYTE4(a2);
      v15 = (unsigned __int64)(1292913986 * ((__int64)(0xFFFFFFCE00000000LL - (v10 << 32)) >> 32) + 0xFFFFFFFFLL) >> 32;
      v16 = v15 + 347;
      v17 = v15 + 354;
      if ( v16 >= 0 )
        v17 = v16;
      v18 = ((__int64)v17 >> 3) + 1;
      LODWORD(a2) = 8 * v18;
      v19 = -53 - (v10 + word_174DAC0[v18]);
      v20 = 348 - 8 * v18;
      v21 = ((qword_174D808[v18] * (unsigned __int128)(unsigned __int64)v13) >> 64) + ((qword_174D808[v18] * v13) >> 63);
      v22 = v21 >> v19;
      v23 = (char *)a3[1];
      v24 = qword_10275E8[__clz((v21 >> v19) | 1) ^ 0x1F] + (unsigned int)(v21 >> v19);
      v25 = HIDWORD(v24);
      v84 = HIDWORD(v24);
      if ( BYTE4(a2) == 2 )
      {
        if ( v20 + HIDWORD(v24) >= 1 && 0x7FFFFFFF - (v20 + HIDWORD(v24)) < v5 )
        {
          v80 = (_QWORD *)sub_6861FD0(16LL);
          sub_6806F74(v80, "number is too big");
          sub_6862048((__int64)v80, (__int64)&`typeinfo for'fmt::v8::format_error, (__int64)sub_6806FA0);
        }
        v5 += v20 + HIDWORD(v24);
        if ( v5 <= 0 )
        {
          if ( v5 < 0 )
          {
            v37 = 0;
          }
          else
          {
            v57 = qword_174DB70[(__int64)(v24 - 0x100000000LL) >> 32] << v19;
            v58 = v21 / 0xA;
            if ( v57 - v21 / 0xA >= v21 / 0xA && v57 - 2 * v58 > 0x13 )
            {
              v74 = 48;
            }
            else
            {
              if ( v21 < 0x64 || v58 - 10 < v57 - (v58 - 10) )
              {
                v82 = v8;
                v37 = 0;
                v5 = 0;
                goto LABEL_96;
              }
              v74 = 49;
            }
            v37 = 1;
            *v23 = v74;
          }
          goto LABEL_115;
        }
      }
      v27 = 1LL << v19;
      v83 = 8 * v18;
      v82 = v8;
      v28 = (1LL << v19) - 1;
      if ( v5 <= 1 )
        v29 = 1;
      else
        v29 = v5;
      v81 = 348 - 8 * v18;
      v30 = 0LL;
      v31 = v28 & v21;
      v32 = (unsigned int)(v29 - 1);
      while ( 1 )
      {
        v33 = 0;
        LOBYTE(v34) = v22;
        switch ( (int)v25 )
        {
          case 1:
            break;
          case 2:
            v34 = (unsigned int)v22 / 0xA;
            v35 = 10;
            goto LABEL_31;
          case 3:
            v34 = (unsigned int)v22 / 0x64;
            v35 = 100;
            goto LABEL_31;
          case 4:
            v34 = (unsigned int)v22 / 0x3E8;
            v35 = 1000;
LABEL_31:
            v33 = v22 - v34 * v35;
            break;
          case 5:
            v34 = (unsigned int)v22 / 0x2710;
            v33 = (unsigned int)v22 % 0x2710;
            break;
          case 6:
            v34 = (unsigned int)v22 / 0x186A0;
            v33 = (unsigned int)v22 % 0x186A0;
            break;
          case 7:
            v34 = (unsigned int)v22 / 0xF4240;
            v33 = (unsigned int)v22 % 0xF4240;
            break;
          case 8:
            v34 = (unsigned int)v22 / 0x989680;
            v33 = (unsigned int)v22 % 0x989680;
            break;
          case 9:
            v34 = (unsigned int)v22 / 0x5F5E100;
            v33 = (unsigned int)v22 % 0x5F5E100;
            break;
          case 10:
            v34 = (unsigned int)v22 / 0x3B9ACA00;
            v33 = (unsigned int)v22 % 0x3B9ACA00;
            break;
          default:
            LOBYTE(v34) = 0;
            v33 = v22;
            break;
        }
        v36 = (int)v25 - 1LL;
        v84 = v36;
        v23[v30] = v34 + 48;
        if ( v32 == v30 )
          break;
        LODWORD(v25) = v84;
        ++v30;
        LODWORD(v22) = v33;
        if ( v84 <= 0 )
        {
          v37 = v30 + 1;
          v38 = (10 * v31) >> v19;
          v39 = (10 * v31) & v28;
          --v84;
          v23[v30] = v38 + 48;
          if ( v39 <= 0xA )
            goto LABEL_95;
          if ( v5 > (int)v37 )
          {
            v40 = 10LL;
            while ( 1 )
            {
              v41 = v40;
              v42 = 10 * v39;
              v38 = v42 >> v19;
              v39 = v42 & v28;
              v40 *= 10LL;
              --v84;
              v23[v30 + 1] = v38 + 48;
              if ( v39 <= v40 )
                break;
              if ( v5 <= (int)++v30 + 1 )
              {
                v37 = v30 + 1;
                goto LABEL_80;
              }
            }
            v37 = v30 + 2;
LABEL_95:
            LODWORD(a2) = v83;
LABEL_96:
            v84 += v37 - a2 + 347;
            if ( (v6 & 0x40000) != 0 )
            {
              v72 = a4;
              if ( LODWORD(v72) >= 0x800000 )
                v7 = LODWORD(v72) & 0x7FFFFF | 0x800000LL;
              else
                v7 = LODWORD(v72) & 0x7FFFFF;
              if ( LODWORD(v72) >= 0x800000 )
                v70 = (LODWORD(v72) >> 23) - 150;
              else
                v70 = -149;
              v71 = HIBYTE(LODWORD(v72)) != 0 && (LODWORD(v72) & 0x7FFFFF) == 0;
            }
            else
            {
              v70 = v82;
              v71 = (*(_QWORD *)&a4 & 0xFFFFFFFFFFFFFLL) == 0 && ((unsigned __int16)(*(_QWORD *)&a4 >> 52) & 0x7FFu) > 1;
            }
            if ( v5 >= 767 )
              v73 = 767;
            else
              v73 = v5;
            sub_68096E8(v7, v70, v71, v73, (__int64)a3, (unsigned int *)&v84);
            if ( v14 == 2 )
            {
LABEL_130:
              LODWORD(v45) = v84;
              return (unsigned int)v45;
            }
LABEL_120:
            if ( (v6 & 0x100000) != 0 )
              goto LABEL_130;
            v77 = a3[2];
            if ( v77 )
            {
              v78 = a3[1] - 1LL;
              while ( *(_BYTE *)(v78 + v77) == 48 )
              {
                --v77;
                ++v84;
                if ( !v77 )
                  goto LABEL_125;
              }
              v79 = a3[3];
              if ( v79 < v77 )
              {
                (*(void (__fastcall **)(_QWORD *, unsigned __int64))*a3)(a3, v77);
LABEL_126:
                v79 = a3[3];
              }
              if ( v79 >= v77 )
                v79 = v77;
              a3[2] = v79;
              goto LABEL_130;
            }
LABEL_125:
            v77 = 0LL;
            goto LABEL_126;
          }
          v41 = 1LL;
          v40 = 10LL;
LABEL_80:
          LODWORD(a2) = v83;
          if ( v27 <= v40 || v27 - v40 <= v40 )
            goto LABEL_96;
          if ( v27 - v39 >= v39 && 20 * v41 <= v27 - 2 * v39 )
            goto LABEL_112;
          v62 = v39 >= v40;
          v63 = v39 - v40;
          if ( !v62 || v63 < v27 - v63 )
            goto LABEL_96;
          v64 = v37;
          v65 = (unsigned int)v30;
          v66 = v37;
          v23[v65] = v38 + 49;
          do
          {
            v67 = v66 - 1;
            v68 = (unsigned int)(v66 - 1);
            if ( v23[v68] <= 57 )
              break;
            v69 = (unsigned int)(v66 - 2);
            v23[v68] = 48;
            --v66;
            ++v23[v69];
          }
          while ( (unsigned __int64)(v67 + 1) > 2 );
          if ( *v23 <= 57 )
          {
LABEL_112:
            v20 = v81;
          }
          else
          {
            v20 = v81;
            *v23 = 49;
            if ( BYTE4(a2) == 2 )
            {
              v37 = v65 + 2;
              v23[v64] = 48;
            }
            else
            {
              v20 = 349 - v83;
            }
          }
LABEL_115:
          v75 = v37;
          v76 = a3[3];
          v84 += v20;
          if ( v76 < v37 )
          {
            (*(void (__fastcall **)(_QWORD *, _QWORD))*a3)(a3, v37);
            v76 = a3[3];
          }
          if ( v76 >= v75 )
            v76 = v75;
          a3[2] = v76;
          if ( v14 == 2 )
            goto LABEL_130;
          goto LABEL_120;
        }
      }
      v52 = ((unsigned __int64)v33 << v19) + v31;
      v53 = qword_174DB70[v36] << v19;
      v54 = v30 + 1;
      if ( v53 - v52 >= v52 )
      {
        if ( v53 - 2 * v52 >= 2 )
          goto LABEL_78;
        if ( !v52 )
        {
LABEL_63:
          LODWORD(a2) = 8 * v18;
          v37 = v30 + 1;
          goto LABEL_96;
        }
      }
      if ( v52 - 1 < v53 - (v52 - 1) )
        goto LABEL_63;
      v23[v32] = v34 + 49;
      if ( v29 != 1 )
      {
        v59 = v30;
        do
        {
          if ( v23[(unsigned int)v59] <= 57 )
            break;
          v23[(unsigned int)v59] = 48;
          v60 = v59-- + 1;
          ++v23[(unsigned int)v59];
        }
        while ( v60 > 2 );
      }
      if ( *v23 > 57 )
      {
        *v23 = 49;
        if ( BYTE4(a2) == 2 )
        {
          v61 = &v23[v30];
          v20 = 348 - 8 * v18;
          v37 = v29 + 1;
          v61[1] = 48;
        }
        else
        {
          v37 = v30 + 1;
          v20 = 349 - v83;
        }
        goto LABEL_115;
      }
LABEL_78:
      v20 = 348 - 8 * v18;
      v37 = v54;
      goto LABEL_115;
    }
    if ( (a2 & 0x4000000000000LL) != 0 )
    {
      v55 = a4;
      v56 = sub_6807640(v55);
      v45 = HIDWORD(v56);
      sub_68093A8(a3, v56);
    }
    else
    {
      v50 = sub_6807AA0(a4);
      LODWORD(v45) = v51;
      sub_6809534(a3, v50);
    }
  }
  return (unsigned int)v45;
}


================================================================================
Function: sub_68093A8 (0x68093A8)
================================================================================

__int64 __fastcall sub_68093A8(_QWORD *a1, unsigned int a2)
{
  _QWORD *v2; // x2
  __int64 v3; // x9
  __int64 v4; // x8
  __int64 v5; // x11
  __int64 v6; // x8
  unsigned int v7; // w14
  unsigned int v8; // w10
  unsigned int v9; // w13
  _BYTE *v10; // x8
  _BYTE *v11; // x9
  unsigned int v12; // w15
  unsigned int v13; // w10
  unsigned int v14; // w14
  _BYTE v16[12]; // [xsp+Ch] [xbp-14h] BYREF

  v2 = a1;
  v3 = a1[2];
  v4 = (__int64)(qword_10275E8[__clz(a2 | 1) ^ 0x1F] + a2) >> 32;
  if ( a1[3] < (unsigned __int64)(v4 + v3) || (v5 = a1[1], a1[2] = v4 + v3, !v5) )
  {
    v10 = &v16[v4];
    if ( a2 < 0x64 )
    {
      v11 = v10;
      v13 = a2;
      if ( a2 <= 9 )
      {
LABEL_11:
        *(v11 - 1) = v13 + 48;
        return sub_53DDE58(v16, v10, a1);
      }
    }
    else
    {
      v11 = v10;
      do
      {
        v12 = a2 >> 4;
        v13 = a2 / 0x64;
        v14 = a2 % 0x64;
        a2 /= 0x64u;
        *((_WORD *)v11 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
        v11 -= 2;
      }
      while ( v12 > 0x270 );
      if ( v13 <= 9 )
        goto LABEL_11;
    }
    *((_WORD *)v11 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
    return sub_53DDE58(v16, v10, a1);
  }
  v6 = v5 + v3 + v4;
  if ( a2 >= 0x64 )
  {
    do
    {
      v7 = a2 >> 4;
      v8 = a2 / 0x64;
      v9 = a2 % 0x64;
      a2 /= 0x64u;
      *(_WORD *)(v6 - 2) = *(_WORD *)&a00010203040506_1[2 * v9];
      v6 -= 2LL;
    }
    while ( v7 > 0x270 );
    if ( v8 <= 9 )
      goto LABEL_6;
LABEL_17:
    *(_WORD *)(v6 - 2) = *(_WORD *)&a00010203040506_1[2 * v8];
    return (__int64)v2;
  }
  v8 = a2;
  if ( a2 > 9 )
    goto LABEL_17;
LABEL_6:
  *(_BYTE *)(v6 - 1) = v8 + 48;
  return (__int64)v2;
}


================================================================================
Function: sub_6809534 (0x6809534)
================================================================================

__int64 __fastcall sub_6809534(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // x2
  unsigned __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x8
  __int64 v6; // x11
  __int64 v7; // x8
  bool v8; // cc
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x13
  _BYTE *v11; // x8
  _BYTE *v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x14
  _BYTE v16[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v2 = a1;
  v3 = byte_102749E[__clz(a2 | 1) ^ 0x3F];
  v4 = a1[2];
  v5 = (__PAIR128__(v3, a2) - qword_10274E0[v3]) >> 64;
  if ( a1[3] < (unsigned __int64)(v5 + v4) || (v6 = a1[1], a1[2] = v5 + v4, !v6) )
  {
    v11 = &v16[v5];
    if ( a2 < 0x64 )
    {
      v12 = v11;
      v13 = a2;
      if ( a2 <= 9 )
      {
LABEL_11:
        *(v12 - 1) = v13 + 48;
        return sub_53DDE58((unsigned __int64)v16, (__int64)v11, (__int64)a1);
      }
    }
    else
    {
      v12 = v11;
      do
      {
        v8 = a2 >> 4 > 0x270;
        v13 = a2 / 0x64;
        v14 = a2 % 0x64;
        a2 /= 0x64uLL;
        *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
        v12 -= 2;
      }
      while ( v8 );
      if ( v13 <= 9 )
        goto LABEL_11;
    }
    *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
    return sub_53DDE58((unsigned __int64)v16, (__int64)v11, (__int64)a1);
  }
  v7 = v6 + v4 + v5;
  if ( a2 >= 0x64 )
  {
    do
    {
      v8 = a2 >> 4 > 0x270;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64uLL;
      *(_WORD *)(v7 - 2) = *(_WORD *)&a00010203040506_1[2 * v10];
      v7 -= 2LL;
    }
    while ( v8 );
    if ( v9 <= 9 )
      goto LABEL_6;
LABEL_17:
    *(_WORD *)(v7 - 2) = *(_WORD *)&a00010203040506_1[2 * v9];
    return (__int64)v2;
  }
  v9 = a2;
  if ( a2 > 9 )
    goto LABEL_17;
LABEL_6:
  *(_BYTE *)(v7 - 1) = v9 + 48;
  return (__int64)v2;
}


================================================================================
Function: sub_68096E8 (0x68096E8)
================================================================================

const void *__fastcall sub_68096E8(__int64 a1, unsigned int a2, char a3, int a4, __int64 a5, unsigned int *a6)
{
  long double v6; // q0
  unsigned int v7; // w25
  __int64 v8; // x21
  char v11; // w23
  unsigned __int64 v12; // x19
  unsigned __int64 v13; // x20
  char *v14; // x9
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x19
  unsigned int v17; // w26
  unsigned __int64 v18; // x20
  unsigned __int64 v19; // x8
  unsigned __int64 v20; // x19
  unsigned __int64 v21; // x8
  __int64 v22; // x8
  long double v23; // q0
  __int64 v24; // x8
  __int64 (__fastcall ***v25)(); // x22
  __int64 v26; // x19
  __int64 v27; // x0
  unsigned __int64 v28; // x8
  __int64 v29; // x20
  __int64 v30; // x8
  __int64 v31; // x10
  unsigned __int64 v32; // x24
  _DWORD *v33; // x9
  __int64 v34; // x11
  unsigned __int64 v35; // x12
  __int64 v36; // x1
  int v37; // w0
  int v38; // w10
  int v39; // w11
  __int64 v40; // x5
  __int64 (__fastcall ***v41)(); // x24
  __int64 v42; // x21
  int v43; // w23
  __int64 *v44; // x25
  __int128 *v45; // x27
  void **p_dest; // x8
  __int64 v47; // x20
  char v48; // w0
  int v49; // w10
  int v50; // w9
  bool v51; // cc
  int v52; // w11
  unsigned int v53; // w12
  int v54; // w13
  int v55; // w11
  int v56; // w15
  unsigned int v57; // w1
  unsigned int v58; // w17
  int v59; // w10
  int v60; // w11
  int v61; // w12
  int v62; // w15
  int v63; // w14
  int v64; // w8
  int v65; // w15
  unsigned __int64 v66; // x1
  int v67; // w5
  int v68; // w6
  unsigned int v69; // w7
  unsigned int v70; // w19
  unsigned int v71; // w26
  unsigned __int64 v72; // x7
  unsigned __int64 v73; // x1
  bool v74; // cf
  unsigned __int64 v75; // x1
  int v76; // w8
  __int64 v77; // x19
  __int64 v78; // x8
  __int64 v79; // x10
  unsigned __int64 v80; // x20
  _DWORD *v81; // x9
  __int64 v82; // x11
  unsigned __int64 v83; // x12
  __int64 v84; // x1
  __int64 v85; // x8
  __int64 v86; // x10
  unsigned __int64 v87; // x20
  _DWORD *v88; // x9
  __int64 v89; // x11
  unsigned __int64 v90; // x12
  __int64 v91; // x1
  __int64 v92; // x8
  __int64 v93; // x10
  unsigned __int64 v94; // x26
  __int64 v95; // x9
  __int64 v96; // x11
  unsigned __int64 v97; // x12
  __int64 v98; // x1
  int v99; // w10
  int v100; // w11
  int v101; // w12
  unsigned __int64 v102; // x17
  int v103; // w15
  int v104; // w16
  int v105; // w1
  unsigned int v106; // w3
  __int64 v107; // x2
  unsigned int v108; // w4
  unsigned __int64 v109; // x2
  unsigned __int64 v110; // x17
  unsigned __int64 v111; // x2
  bool v112; // w8
  __int64 v113; // x12
  __int64 v114; // x20
  __int64 v115; // x9
  unsigned __int64 v116; // x19
  _BYTE *v117; // x8
  __int64 v118; // x11
  unsigned __int64 v119; // x13
  __int64 v120; // x1
  int v121; // w10
  int v122; // w11
  char v123; // w19
  int v124; // w12
  unsigned __int64 v125; // x17
  int v126; // w15
  int v127; // w16
  int v128; // w1
  unsigned int v129; // w3
  __int64 v130; // x2
  unsigned int v131; // w4
  unsigned __int64 v132; // x2
  unsigned __int64 v133; // x17
  unsigned __int64 v134; // x2
  bool v135; // w8
  unsigned __int64 v136; // x26
  unsigned __int64 v137; // x8
  __int64 v138; // x8
  __int64 v139; // x1
  __int64 v140; // x9
  int v141; // w8
  unsigned __int64 v142; // x22
  unsigned __int64 v143; // x8
  unsigned __int64 v144; // x8
  __int64 v145; // x8
  __int64 v146; // x8
  int v147; // w13
  unsigned __int64 v148; // x17
  int v149; // w16
  int v150; // w12
  int v151; // w0
  unsigned int v152; // w2
  __int64 v153; // x1
  unsigned int v154; // w3
  unsigned __int64 v155; // x1
  unsigned __int64 v156; // x17
  unsigned __int64 v157; // x17
  __int64 v158; // x8
  __int64 v159; // x10
  _BYTE *v160; // x8
  __int64 v161; // x8
  unsigned __int64 v162; // x20
  __int64 v163; // x10
  _DWORD *v164; // x9
  __int64 v165; // x13
  __int64 v166; // x14
  unsigned __int64 v167; // x15
  __int64 v168; // x8
  __int64 v169; // x1
  unsigned __int64 v170; // x8
  const void *result; // x0
  void **v172; // [xsp+8h] [xbp-308h]
  __int64 *v174; // [xsp+30h] [xbp-2E0h]
  __int64 (__fastcall **v176)(); // [xsp+40h] [xbp-2D0h] BYREF
  void *v177; // [xsp+48h] [xbp-2C8h]
  __int128 v178; // [xsp+50h] [xbp-2C0h]
  _BYTE v179[136]; // [xsp+60h] [xbp-2B0h] BYREF
  int v180; // [xsp+E8h] [xbp-228h]
  __int64 (__fastcall **v181)(); // [xsp+F0h] [xbp-220h] BYREF
  void *dest; // [xsp+F8h] [xbp-218h] BYREF
  __int128 v183; // [xsp+100h] [xbp-210h] BYREF
  _BYTE v184[136]; // [xsp+110h] [xbp-200h] BYREF
  int v185; // [xsp+198h] [xbp-178h]
  __int64 (__fastcall **v186)(); // [xsp+1A0h] [xbp-170h] BYREF
  _BYTE *v187; // [xsp+1A8h] [xbp-168h]
  __int128 v188; // [xsp+1B0h] [xbp-160h]
  _BYTE v189[136]; // [xsp+1C0h] [xbp-150h] BYREF
  int v190; // [xsp+248h] [xbp-C8h]
  __int64 (__fastcall **v191)(); // [xsp+250h] [xbp-C0h] BYREF
  unsigned int *v192; // [xsp+258h] [xbp-B8h]
  __int128 v193; // [xsp+260h] [xbp-B0h]
  _DWORD v194[34]; // [xsp+270h] [xbp-A0h] BYREF
  int v195; // [xsp+2F8h] [xbp-18h]

  v6 = *(long double *)&xmmword_AFFA20;
  if ( (a3 & 1) != 0 )
    v7 = 2;
  else
    v7 = 1;
  LODWORD(v8) = a4;
  v11 = a1;
  v12 = a1 << v7;
  v191 = off_6C59998;
  v192 = v194;
  v193 = xmmword_AFFA20;
  v186 = off_6C59998;
  v187 = v189;
  v195 = 0;
  v188 = xmmword_AFFA20;
  v181 = off_6C59998;
  dest = v184;
  v190 = 0;
  v183 = xmmword_AFFA20;
  v185 = 0;
  v176 = off_6C59998;
  v177 = v179;
  v178 = xmmword_AFFA20;
  v180 = 0;
  if ( (a2 & 0x80000000) != 0 )
  {
    v17 = *a6;
    if ( (*a6 & 0x80000000) == 0 )
    {
      v18 = 0LL;
      do
      {
        v194[v18] = v12;
        v12 >>= 32;
        ++v18;
      }
      while ( v12 );
      v19 = v18 - 1;
      if ( v18 - 1 >= 0x20 )
      {
        if ( v19 >= 0x30 )
        {
          v20 = v18;
          if ( v19 >= 0x3FFFFFFFFFFFFFFFLL )
            sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        }
        else
        {
          v20 = 48LL;
        }
        v192 = (unsigned int *)sub_65ECAAC();
        *((_QWORD *)&v193 + 1) = v20;
      }
      else
      {
        v20 = 32LL;
      }
      v195 = 0;
      if ( v20 >= v18 )
        v144 = v18;
      else
        v144 = v20;
      *(_QWORD *)&v193 = v144;
      sub_6814054(&v186, v17, v6);
      sub_6813F28(&v186, v7 - a2);
      *(_DWORD *)dest = 1;
      v145 = *((_QWORD *)&v183 + 1);
      if ( !*((_QWORD *)&v183 + 1) )
      {
        ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v181)(&v181, 1LL);
        v145 = *((_QWORD *)&v183 + 1);
      }
      v185 = 0;
      *(_QWORD *)&v183 = v145 != 0;
      if ( (a3 & 1) != 0 )
      {
        *(_DWORD *)v177 = 2;
        v146 = *((_QWORD *)&v178 + 1);
        if ( !*((_QWORD *)&v178 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v176)(&v176, 1LL);
          v146 = *((_QWORD *)&v178 + 1);
        }
        v25 = &v176;
        v180 = 0;
        *(_QWORD *)&v178 = v146 != 0;
      }
      else
      {
        v25 = 0LL;
      }
      goto LABEL_29;
    }
    sub_6814054(&v191, -v17, *(long double *)&xmmword_AFFA20);
    v136 = v193;
    if ( *((_QWORD *)&v183 + 1) >= (unsigned __int64)v193 )
    {
      *(_QWORD *)&v183 = v193;
      if ( !(_QWORD)v193 )
        goto LABEL_187;
    }
    else
    {
      ((void (__fastcall *)(__int64 (__fastcall ***)(), _QWORD))*v181)(&v181, v193);
      v137 = *((_QWORD *)&v183 + 1);
      if ( *((_QWORD *)&v183 + 1) >= v136 )
        v137 = v136;
      *(_QWORD *)&v183 = v137;
    }
    memmove(dest, v192, 4 * v136);
LABEL_187:
    v141 = v195;
    v185 = v195;
    if ( (a3 & 1) == 0 )
    {
      v25 = 0LL;
      goto LABEL_235;
    }
    v142 = v193;
    if ( *((_QWORD *)&v178 + 1) >= (unsigned __int64)v193 )
    {
      *(_QWORD *)&v178 = v193;
      if ( !(_QWORD)v193 )
      {
LABEL_234:
        v25 = &v176;
        v180 = v141;
        sub_6813F28(&v176, 1LL);
LABEL_235:
        v161 = v193;
        if ( (_QWORD)v193 )
        {
          v162 = 0LL;
          v163 = 0LL;
          v164 = v192;
          do
          {
            v165 = v163++;
            v166 = (unsigned int)v164[v165];
            v167 = ((unsigned int)v12 & 0xFFFFFFFE) * v166 + (unsigned int)v162;
            v162 = HIDWORD(v12) * v166 + HIDWORD(v162) + HIDWORD(v167);
            v164[v165] = v167;
          }
          while ( v161 != v163 );
          for ( ; v162; v161 = v169 )
          {
            v169 = v161 + 1;
            if ( *((_QWORD *)&v193 + 1) < (unsigned __int64)(v161 + 1) )
            {
              ((void (__fastcall *)(__int64 (__fastcall ***)()))*v191)(&v191);
              v164 = v192;
              v161 = v193;
              v169 = v193 + 1;
            }
            *(_QWORD *)&v193 = v169;
            v164[v161] = v162;
            v162 >>= 32;
          }
        }
        *(_DWORD *)v187 = 1;
        v168 = *((_QWORD *)&v188 + 1);
        if ( !*((_QWORD *)&v188 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v186)(&v186, 1LL);
          v168 = *((_QWORD *)&v188 + 1);
        }
        v190 = 0;
        *(_QWORD *)&v188 = v168 != 0;
        sub_6813F28(&v186, v7 - a2);
        goto LABEL_29;
      }
    }
    else
    {
      ((void (__fastcall *)(__int64 (__fastcall ***)(), _QWORD))*v176)(&v176, v193);
      v143 = *((_QWORD *)&v178 + 1);
      if ( *((_QWORD *)&v178 + 1) >= v142 )
        v143 = v142;
      *(_QWORD *)&v178 = v143;
    }
    memmove(v177, v192, 4 * v142);
    v141 = v195;
    goto LABEL_234;
  }
  v13 = 0LL;
  do
  {
    v14 = (char *)&v191 + 4 * v13++;
    *((_DWORD *)v14 + 8) = v12;
    v12 >>= 32;
  }
  while ( v12 );
  v15 = v13 - 1;
  if ( v13 - 1 >= 0x20 )
  {
    if ( v15 >= 0x30 )
    {
      v16 = v13;
      if ( v15 >= 0x3FFFFFFFFFFFFFFFLL )
        sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    }
    else
    {
      v16 = 48LL;
    }
    v192 = (unsigned int *)sub_65ECAAC();
    *((_QWORD *)&v193 + 1) = v16;
  }
  else
  {
    v16 = 32LL;
  }
  v195 = 0;
  if ( v16 >= v13 )
    v21 = v13;
  else
    v21 = v16;
  *(_QWORD *)&v193 = v21;
  sub_6813F28(&v191, a2);
  *(_DWORD *)dest = 1;
  v22 = *((_QWORD *)&v183 + 1);
  if ( !*((_QWORD *)&v183 + 1) )
  {
    ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v181)(&v181, 1LL);
    v22 = *((_QWORD *)&v183 + 1);
  }
  v185 = 0;
  *(_QWORD *)&v183 = v22 != 0;
  sub_6813F28(&v181, a2);
  if ( (a3 & 1) != 0 )
  {
    *(_DWORD *)v177 = 1;
    v24 = *((_QWORD *)&v178 + 1);
    if ( !*((_QWORD *)&v178 + 1) )
    {
      ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v176)(&v176, 1LL);
      v24 = *((_QWORD *)&v178 + 1);
    }
    v25 = &v176;
    v180 = 0;
    *(_QWORD *)&v178 = v24 != 0;
    sub_6813F28(&v176, a2 + 1);
  }
  else
  {
    v25 = 0LL;
  }
  sub_6814054(&v186, *a6, v23);
  sub_6813F28(&v186, v7);
LABEL_29:
  if ( (v8 & 0x80000000) == 0 )
  {
    v26 = (int)v8 - 1LL;
    *a6 -= v26;
    if ( (_DWORD)v8 )
    {
      v27 = a5;
      v28 = *(_QWORD *)(a5 + 24);
      if ( v28 < (unsigned int)v8 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a5)(a5, (unsigned int)v8);
        v27 = a5;
        v28 = *(_QWORD *)(a5 + 24);
      }
      if ( v28 >= (unsigned int)v8 )
        v28 = (unsigned int)v8;
      *(_QWORD *)(v27 + 16) = v28;
      if ( (unsigned int)v8 >= 2 )
      {
        v29 = 0LL;
        do
        {
          *(_BYTE *)(*(_QWORD *)(a5 + 8) + v29) = sub_68141C4(&v191, &v186) + 48;
          v30 = v193;
          if ( (_QWORD)v193 )
          {
            v31 = 0LL;
            v32 = 0LL;
            v33 = v192;
            do
            {
              v34 = v31++;
              v35 = v32 + 10LL * (unsigned int)v33[v34];
              v32 = HIDWORD(v35);
              v33[v34] = v35;
            }
            while ( v30 != v31 );
            if ( HIDWORD(v35) )
            {
              v36 = v30 + 1;
              if ( *((_QWORD *)&v193 + 1) < (unsigned __int64)(v30 + 1) )
              {
                ((void (__fastcall *)(__int64 (__fastcall ***)()))*v191)(&v191);
                v33 = v192;
                v30 = v193;
                v36 = v193 + 1;
              }
              *(_QWORD *)&v193 = v36;
              v33[v30] = v32;
            }
          }
          ++v29;
        }
        while ( v29 != (unsigned int)v26 );
      }
      v37 = sub_68141C4(&v191, &v186);
      v38 = v195 + v193;
      v39 = v190 + v188;
      if ( v195 + (int)v193 + 1 >= v190 + (int)v188 )
      {
        v40 = a5;
        if ( v38 <= v39 )
        {
          if ( v190 >= v195 )
            v124 = v195;
          else
            v124 = v190;
          if ( v39 <= v124 )
          {
            v135 = 0;
LABEL_222:
            if ( (v37 & 1) == 0 || v135 )
              goto LABEL_231;
          }
          else
          {
            v125 = 0LL;
            v126 = ~v195;
            v127 = v188 - 1;
            v128 = v190 + v188;
            while ( 1 )
            {
              v129 = 0;
              v130 = 0LL;
              if ( v128 > v195 && v38 >= v128 )
              {
                v130 = v192[v126 + v128];
                v129 = v192[v126 + v128];
              }
              v131 = 0;
              if ( v128 > v190 && v39 >= v128 )
                v131 = *(_DWORD *)&v187[4 * v127];
              v132 = v130 + v129;
              v133 = v125 | v131;
              v74 = v133 >= v132;
              v134 = v133 - v132;
              if ( !v74 )
                break;
              if ( v134 > 1 )
                goto LABEL_231;
              --v128;
              v125 = v134 << 32;
              --v127;
              if ( v128 <= v124 )
              {
                v135 = v134 != 0;
                goto LABEL_222;
              }
            }
          }
        }
        if ( v37 == 9 )
        {
          v158 = (unsigned int)(v8 - 2);
          *(_BYTE *)(*(_QWORD *)(a5 + 8) + v26) = 58;
          if ( (unsigned int)v8 >= 2 )
          {
            do
            {
              v8 = (unsigned int)(v8 - 1);
              v159 = *(_QWORD *)(a5 + 8);
              if ( *(_BYTE *)(v159 + v8) != 58 )
                break;
              *(_BYTE *)(v159 + v8) = 48;
              ++*(_BYTE *)(*(_QWORD *)(a5 + 8) + v158--);
            }
            while ( (int)v8 > 1 );
          }
          v160 = *(_BYTE **)(a5 + 8);
          if ( *v160 == 58 )
          {
            *v160 = 49;
            ++*a6;
          }
          goto LABEL_254;
        }
        LOBYTE(v37) = v37 + 1;
      }
      else
      {
        v40 = a5;
      }
LABEL_231:
      *(_BYTE *)(*(_QWORD *)(v40 + 8) + v26) = v37 + 48;
      goto LABEL_254;
    }
    v113 = v188;
    v114 = a5;
    if ( (_QWORD)v188 )
    {
      v115 = 0LL;
      v116 = 0LL;
      v117 = v187;
      do
      {
        v118 = 4 * v115++;
        v119 = v116 + 10LL * *(unsigned int *)&v117[v118];
        v116 = HIDWORD(v119);
        *(_DWORD *)&v117[v118] = v119;
      }
      while ( v113 != v115 );
      if ( HIDWORD(v119) )
      {
        v120 = v113 + 1;
        if ( *((_QWORD *)&v188 + 1) < (unsigned __int64)(v113 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)()))*v186)(&v186);
          v117 = v187;
          v113 = v188;
          v120 = v188 + 1;
        }
        *(_QWORD *)&v188 = v120;
        *(_DWORD *)&v117[4 * v113] = v116;
        LODWORD(v113) = v120;
      }
      v114 = a5;
    }
    v121 = v195 + v193;
    v122 = v190 + v113;
    if ( v195 + (int)v193 + 1 < v190 + (int)v113 )
      goto LABEL_156;
    if ( v121 <= v122 )
    {
      if ( v190 >= v195 )
        v147 = v195;
      else
        v147 = v190;
      if ( v122 <= v147 )
      {
LABEL_156:
        v123 = 48;
LABEL_182:
        v138 = *(_QWORD *)(v114 + 16);
        v139 = v138 + 1;
        if ( *(_QWORD *)(v114 + 24) < (unsigned __int64)(v138 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v114)(v114);
          v138 = *(_QWORD *)(v114 + 16);
          v139 = v138 + 1;
        }
        v140 = *(_QWORD *)(v114 + 8);
        *(_QWORD *)(v114 + 16) = v139;
        *(_BYTE *)(v140 + v138) = v123;
        goto LABEL_254;
      }
      v148 = 0LL;
      v149 = ~v195;
      v150 = v113 - 1;
      v151 = v122;
      v123 = 48;
      while ( 1 )
      {
        v152 = 0;
        v153 = 0LL;
        if ( v151 > v195 && v121 >= v151 )
        {
          v153 = v192[v149 + v151];
          v152 = v192[v149 + v151];
        }
        v154 = 0;
        if ( v151 > v190 && v122 >= v151 )
          v154 = *(_DWORD *)&v187[4 * v150];
        v155 = v153 + v152;
        v156 = v148 | v154;
        v74 = v156 >= v155;
        v157 = v156 - v155;
        if ( !v74 )
          break;
        if ( v157 <= 1 )
        {
          --v151;
          v148 = v157 << 32;
          --v150;
          if ( v151 > v147 )
            continue;
        }
        goto LABEL_182;
      }
    }
    v123 = 49;
    goto LABEL_182;
  }
  if ( v25 )
    v41 = v25;
  else
    v41 = &v181;
  v42 = *(_QWORD *)(a5 + 8);
  v43 = (v11 & 1) == 0;
  v44 = (__int64 *)(v25 + 2);
  if ( v25 )
    v45 = (__int128 *)(v25 + 2);
  else
    v45 = &v183;
  if ( v25 )
    p_dest = (void **)(v25 + 1);
  else
    p_dest = &dest;
  v47 = 0LL;
  v174 = (__int64 *)(v25 + 1);
  v172 = p_dest;
  while ( 1 )
  {
    v48 = sub_68141C4(&v191, &v186);
    v49 = v193;
    v50 = v195 + v193;
    v51 = v195 + (int)v193 <= v185 + (int)v183;
    if ( v195 + (_DWORD)v193 != v185 + (_DWORD)v183 )
    {
LABEL_66:
      if ( v51 )
        v59 = -1;
      else
        v59 = 1;
      goto LABEL_69;
    }
    v52 = v193 - 1;
    v53 = v183 - 1;
    v54 = (v52 - v53) & ~((int)(v52 - v53) >> 31);
    if ( v54 >= (int)v193 )
    {
      v51 = v52 <= (int)v53;
      if ( v52 != v53 )
        goto LABEL_66;
    }
    else
    {
      v55 = v54 - 1;
      v56 = v183 + ~(_DWORD)v193 + v54;
      do
      {
        --v49;
        v57 = *((_DWORD *)dest + v53);
        v58 = v192[v49];
        if ( v58 != v57 )
        {
          if ( v58 > v57 )
            v59 = 1;
          else
            v59 = -1;
          goto LABEL_69;
        }
        --v53;
      }
      while ( v49 > v54 );
      v51 = v55 <= v56;
      if ( v55 != v56 )
        goto LABEL_66;
    }
    v59 = 0;
LABEL_69:
    v60 = *((_DWORD *)v41 + 42);
    v61 = v60 + *(_DWORD *)v45;
    v62 = v50 >= v61 ? v195 + v193 : v60 + *(_DWORD *)v45;
    v63 = v190 + v188;
    if ( v62 + 1 >= v190 + (int)v188 )
    {
      if ( v62 > v63 )
        goto LABEL_75;
      if ( v60 >= v195 )
        v65 = v195;
      else
        v65 = *((_DWORD *)v41 + 42);
      if ( v190 < v65 )
        v65 = v190;
      if ( v63 > v65 )
      {
        v66 = 0LL;
        v67 = v188 - 1;
        v68 = v190 + v188;
        while ( 1 )
        {
          v69 = 0;
          if ( v68 > v195 && v50 >= v68 )
            v69 = v192[~v195 + v68];
          v70 = 0;
          if ( v68 > v60 && v61 >= v68 )
            v70 = *((_DWORD *)*v172 + (unsigned int)(~v60 + v68));
          v71 = 0;
          if ( v68 > v190 && v63 >= v68 )
            v71 = *(_DWORD *)&v187[4 * v67];
          v72 = v69 + (unsigned __int64)v70;
          v73 = v66 | v71;
          v74 = v73 >= v72;
          v75 = v73 - v72;
          if ( !v74 )
            break;
          if ( v75 > 1 )
            goto LABEL_73;
          --v68;
          v66 = v75 << 32;
          --v67;
          if ( v68 <= v65 )
            goto LABEL_101;
        }
LABEL_75:
        v64 = 1;
        goto LABEL_104;
      }
      v66 = 0LL;
LABEL_101:
      v64 = v66 ? -1 : 0;
    }
    else
    {
LABEL_73:
      v64 = -1;
    }
LABEL_104:
    v76 = v64 + v43;
    v77 = v47 + 1;
    *(_BYTE *)(v42 + v47) = v48 + 48;
    if ( v59 < v43 || v76 >= 1 )
      break;
    v78 = v193;
    if ( (_QWORD)v193 )
    {
      v79 = 0LL;
      v80 = 0LL;
      v81 = v192;
      do
      {
        v82 = v79++;
        v83 = v80 + 10LL * (unsigned int)v81[v82];
        v80 = HIDWORD(v83);
        v81[v82] = v83;
      }
      while ( v78 != v79 );
      if ( HIDWORD(v83) )
      {
        v84 = v78 + 1;
        if ( *((_QWORD *)&v193 + 1) < (unsigned __int64)(v78 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)()))*v191)(&v191);
          v81 = v192;
          v78 = v193;
          v84 = v193 + 1;
        }
        *(_QWORD *)&v193 = v84;
        v81[v78] = v80;
      }
    }
    v85 = v183;
    if ( (_QWORD)v183 )
    {
      v86 = 0LL;
      v87 = 0LL;
      v88 = dest;
      do
      {
        v89 = v86++;
        v90 = v87 + 10LL * (unsigned int)v88[v89];
        v87 = HIDWORD(v90);
        v88[v89] = v90;
      }
      while ( v85 != v86 );
      if ( HIDWORD(v90) )
      {
        v91 = v85 + 1;
        if ( *((_QWORD *)&v183 + 1) < (unsigned __int64)(v85 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)()))*v181)(&v181);
          v88 = dest;
          v85 = v183;
          v91 = v183 + 1;
        }
        *(_QWORD *)&v183 = v91;
        v88[v85] = v87;
      }
    }
    v47 = v77;
    if ( v25 )
    {
      v92 = *v44;
      v47 = v77;
      if ( *v44 )
      {
        v93 = 0LL;
        v94 = 0LL;
        v95 = *v174;
        do
        {
          v96 = 4 * v93++;
          v97 = v94 + 10LL * *(unsigned int *)(v95 + v96);
          v94 = HIDWORD(v97);
          *(_DWORD *)(v95 + v96) = v97;
        }
        while ( v92 != v93 );
        v47 = v77;
        if ( HIDWORD(v97) )
        {
          v98 = v92 + 1;
          if ( (unsigned __int64)v25[3] < v92 + 1 )
          {
            ((void (__fastcall *)(__int64 (__fastcall ***)()))**v41)(v25);
            v92 = *v44;
            v98 = *v44 + 1;
            v95 = *v174;
          }
          v47 = v77;
          *v44 = v98;
          *(_DWORD *)(v95 + 4 * v92) = v94;
        }
      }
    }
  }
  if ( v59 >= v43 )
    goto LABEL_248;
  if ( v76 >= 1 )
  {
    v99 = v195 + v193;
    v100 = v190 + v188;
    if ( v195 + (int)v193 + 1 >= v190 + (int)v188 )
    {
      if ( v99 > v100 )
        goto LABEL_248;
      if ( v190 >= v195 )
        v101 = v195;
      else
        v101 = v190;
      if ( v100 > v101 )
      {
        v102 = 0LL;
        v103 = ~v195;
        v104 = v188 - 1;
        v105 = v190 + v188;
        while ( 1 )
        {
          v106 = 0;
          v107 = 0LL;
          if ( v105 > v195 && v99 >= v105 )
          {
            v107 = v192[v103 + v105];
            v106 = v192[v103 + v105];
          }
          v108 = 0;
          if ( v105 > v190 && v100 >= v105 )
            v108 = *(_DWORD *)&v187[4 * v104];
          v109 = v107 + v106;
          v110 = v102 | v108;
          v74 = v110 >= v109;
          v111 = v110 - v109;
          if ( !v74 )
            goto LABEL_248;
          if ( v111 > 1 )
            goto LABEL_249;
          --v105;
          v102 = v111 << 32;
          --v104;
          if ( v105 <= v101 )
          {
            v112 = v111 != 0;
            goto LABEL_246;
          }
        }
      }
      v112 = 0;
LABEL_246:
      if ( (v48 & 1) != 0 && !v112 )
LABEL_248:
        *(_BYTE *)(v42 + (unsigned int)v47) = v48 + 49;
    }
  }
LABEL_249:
  v170 = *(_QWORD *)(a5 + 24);
  if ( v170 < (unsigned int)(v47 + 1) )
  {
    (**(void (__fastcall ***)(__int64, _QWORD))a5)(a5, (unsigned int)(v47 + 1));
    v170 = *(_QWORD *)(a5 + 24);
  }
  if ( v170 >= (unsigned int)(v47 + 1) )
    v170 = (unsigned int)(v47 + 1);
  *(_QWORD *)(a5 + 16) = v170;
  *a6 -= v47;
LABEL_254:
  if ( v177 != v179 )
    sub_65ECAF4();
  if ( dest != v184 )
    sub_65ECAF4();
  if ( v187 != v189 )
    sub_65ECAF4();
  result = v192;
  if ( v192 != v194 )
    return (const void *)sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_680A5BC (0x680A5BC)
================================================================================

__int64 __fastcall sub_680A5BC(unsigned int a1, unsigned __int64 a2, _QWORD *a3, long double a4)
{
  unsigned __int64 v7; // x23
  __int64 v8; // x1
  __int64 v9; // x0
  __int64 v10; // x2
  unsigned __int64 v11; // x8
  void *v12; // x0
  unsigned __int64 v13; // x20
  __int64 v15; // x8
  __int64 v16; // x1
  __int64 v17; // x9
  double v18; // d0
  unsigned __int64 v19; // x0
  int v20; // w1
  long double v21; // q0
  __int64 v22; // x3
  unsigned __int64 v23; // x20
  __int64 v24; // x8
  unsigned __int64 v25; // x8
  long double v26; // q0
  unsigned __int64 v27; // x0
  int v29; // [xsp+14h] [xbp-Ch] BYREF

  v7 = HIDWORD(a2);
  if ( (int)sub_6865770() <= 0 )
  {
    if ( (int)a1 >= 1 && (unsigned __int8)v7 == 2 )
    {
      v11 = a3[3];
      if ( v11 < a1 )
      {
        (*(void (__fastcall **)(_QWORD *, _QWORD))*a3)(a3, a1);
        v11 = a3[3];
      }
      v12 = (void *)a3[1];
      if ( v11 >= a1 )
        v11 = a1;
      a3[2] = v11;
      memset(v12, 48, a1);
      LODWORD(v13) = -a1;
    }
    else
    {
      v15 = a3[2];
      v16 = v15 + 1;
      if ( a3[3] < (unsigned __int64)(v15 + 1) )
      {
        (*(void (__fastcall **)(_QWORD *))*a3)(a3);
        v15 = a3[2];
        v16 = v15 + 1;
      }
      v17 = a3[1];
      LODWORD(v13) = 0;
      a3[2] = v16;
      *(_BYTE *)(v17 + v15) = 48;
    }
    return (unsigned int)v13;
  }
  if ( (v7 & 0x80000) != 0 )
    return sub_6808794(a1, a2, (__int64)a3, *(double *)&a4);
  if ( (a1 & 0x80000000) != 0 )
  {
    if ( (v7 & 0x40000) != 0 )
    {
      v26 = sub_68664F4(a4);
      v27 = sub_6807640(v26);
      v13 = HIDWORD(v27);
      sub_68093A8(a3, v27);
    }
    else
    {
      v18 = sub_6866330(a4);
      v19 = sub_6807AA0(v18);
      LODWORD(v13) = v20;
      sub_6809534(a3, v19);
    }
    return (unsigned int)v13;
  }
  v29 = 0;
  if ( (v7 & 0x40000) != 0 )
  {
    v21 = sub_68664F4(a4);
    if ( LODWORD(v21) >= 0x800000 )
      v9 = LODWORD(v21) & 0x7FFFFF | 0x800000LL;
    else
      v9 = LODWORD(v21) & 0x7FFFFF;
    if ( LODWORD(v21) >= 0x800000 )
      v8 = (unsigned int)((LODWORD(v21) >> 23) - 150);
    else
      v8 = 4294967147LL;
    v10 = (HIBYTE(LODWORD(v21)) != 0) & (unsigned __int8)((LODWORD(v21) & 0x7FFFFF) == 0);
  }
  else
  {
    v8 = 0LL;
    v9 = 0LL;
    v10 = 0LL;
  }
  if ( a1 >= 0x2FF )
    v22 = 767LL;
  else
    v22 = a1;
  sub_68096E8(v9, v8, v10, v22, a3, &v29);
  if ( BYTE4(a2) != 2 && (v7 & 0x100000) == 0 )
  {
    v23 = a3[2];
    if ( v23 )
    {
      v24 = a3[1] - 1LL;
      while ( *(_BYTE *)(v24 + v23) == 48 )
      {
        --v23;
        ++v29;
        if ( !v23 )
          goto LABEL_35;
      }
      v25 = a3[3];
      if ( v25 >= v23 )
        goto LABEL_37;
      (*(void (__fastcall **)(_QWORD *, unsigned __int64))*a3)(a3, v23);
    }
    else
    {
LABEL_35:
      v23 = 0LL;
    }
    v25 = a3[3];
LABEL_37:
    if ( v25 >= v23 )
      v25 = v23;
    a3[2] = v25;
  }
  LODWORD(v13) = v29;
  return (unsigned int)v13;
}


================================================================================
Function: sub_680A850 (0x680A850)
================================================================================

__int64 __fastcall sub_680A850(__int64 a1, int a2)
{
  __int64 v2; // x21
  __int64 v3; // x19
  __int64 v4; // x8
  __int64 v5; // x22
  unsigned __int64 v6; // x9
  __int64 v7; // x10
  _BYTE *v8; // x8
  _BYTE *v9; // x8
  unsigned int v10; // w14
  unsigned int v11; // w10
  unsigned int v12; // w13
  __int64 v13; // x8
  __int64 v14; // x1
  __int64 v15; // x9
  _BYTE *v16; // x8
  unsigned int v17; // w14
  unsigned int v18; // w9
  unsigned int v19; // w13
  _BYTE v21[12]; // [xsp+Ch] [xbp-14h] BYREF

  if ( a2 >= 0 )
    v2 = (unsigned int)a2;
  else
    v2 = (unsigned int)-a2;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 16);
  v5 = (qword_10275E8[__clz(v2 | 1) ^ 0x1F] + v2) >> 32;
  v6 = v4 + ((unsigned int)a2 >> 31) + v5;
  if ( *(_QWORD *)(a1 + 24) < v6 || (v7 = *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16) = v6, !v7) )
  {
    if ( a2 < 0 )
    {
      v13 = *(_QWORD *)(a1 + 16);
      v14 = v13 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v13 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v13 = *(_QWORD *)(v3 + 16);
        v14 = v13 + 1;
      }
      v15 = *(_QWORD *)(v3 + 8);
      *(_QWORD *)(v3 + 16) = v14;
      *(_BYTE *)(v15 + v13) = 45;
    }
    if ( (unsigned int)v2 < 0x64 )
    {
      v16 = &v21[v5];
      v18 = v2;
      if ( (unsigned int)v2 <= 9 )
      {
LABEL_20:
        *(v16 - 1) = v18 + 48;
        return sub_53DDE58(v21, &v21[v5], v3);
      }
    }
    else
    {
      v16 = &v21[v5];
      do
      {
        v17 = (unsigned int)v2 >> 4;
        v18 = (unsigned int)v2 / 0x64;
        v19 = (unsigned int)v2 % 0x64;
        LODWORD(v2) = (unsigned int)v2 / 0x64;
        *((_WORD *)v16 - 1) = *(_WORD *)&a00010203040506_1[2 * v19];
        v16 -= 2;
      }
      while ( v17 > 0x270 );
      if ( v18 <= 9 )
        goto LABEL_20;
    }
    *((_WORD *)v16 - 1) = *(_WORD *)&a00010203040506_1[2 * v18];
    return sub_53DDE58(v21, &v21[v5], v3);
  }
  v8 = (_BYTE *)(v7 + v4);
  if ( a2 < 0 )
    *v8++ = 45;
  v9 = &v8[v5];
  if ( (unsigned int)v2 >= 0x64 )
  {
    do
    {
      v10 = (unsigned int)v2 >> 4;
      v11 = (unsigned int)v2 / 0x64;
      v12 = (unsigned int)v2 % 0x64;
      LODWORD(v2) = (unsigned int)v2 / 0x64;
      *((_WORD *)v9 - 1) = *(_WORD *)&a00010203040506_1[2 * v12];
      v9 -= 2;
    }
    while ( v10 > 0x270 );
    if ( v11 <= 9 )
      goto LABEL_11;
LABEL_26:
    *((_WORD *)v9 - 1) = *(_WORD *)&a00010203040506_1[2 * v11];
    return v3;
  }
  v11 = v2;
  if ( (unsigned int)v2 > 9 )
    goto LABEL_26;
LABEL_11:
  *(v9 - 1) = v11 + 48;
  return v3;
}


================================================================================
Function: sub_680AA3C (0x680AA3C)
================================================================================

__int64 __fastcall sub_680AA3C(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // x21
  __int64 v3; // x19
  unsigned __int64 v4; // x9
  __int64 v5; // x8
  __int64 v6; // x22
  unsigned __int64 v7; // x9
  __int64 v8; // x10
  _BYTE *v9; // x8
  _BYTE *v10; // x8
  bool v11; // cc
  unsigned __int64 v12; // x10
  unsigned __int64 v13; // x13
  __int64 v14; // x8
  __int64 v15; // x1
  __int64 v16; // x9
  _BYTE *v17; // x8
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x13
  _BYTE v21[20]; // [xsp+4h] [xbp-1Ch] BYREF

  if ( a2 >= 0 )
    v2 = a2;
  else
    v2 = -a2;
  v3 = a1;
  v4 = byte_102749E[__clz(v2 | 1) ^ 0x3F];
  v5 = *(_QWORD *)(a1 + 16);
  v6 = (__PAIR128__(v4, v2) - qword_10274E0[v4]) >> 64;
  v7 = v5 + ((unsigned __int64)a2 >> 63) + v6;
  if ( *(_QWORD *)(a1 + 24) < v7 || (v8 = *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16) = v7, !v8) )
  {
    if ( a2 < 0 )
    {
      v14 = *(_QWORD *)(a1 + 16);
      v15 = v14 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v14 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v14 = *(_QWORD *)(v3 + 16);
        v15 = v14 + 1;
      }
      v16 = *(_QWORD *)(v3 + 8);
      *(_QWORD *)(v3 + 16) = v15;
      *(_BYTE *)(v16 + v14) = 45;
    }
    if ( v2 < 0x64 )
    {
      v17 = &v21[v6];
      v18 = v2;
      if ( v2 <= 9 )
      {
LABEL_20:
        *(v17 - 1) = v18 + 48;
        return sub_53DDE58(v21, &v21[v6], v3);
      }
    }
    else
    {
      v17 = &v21[v6];
      do
      {
        v11 = v2 >> 4 > 0x270;
        v18 = v2 / 0x64;
        v19 = v2 % 0x64;
        v2 /= 0x64uLL;
        *((_WORD *)v17 - 1) = *(_WORD *)&a00010203040506_1[2 * v19];
        v17 -= 2;
      }
      while ( v11 );
      if ( v18 <= 9 )
        goto LABEL_20;
    }
    *((_WORD *)v17 - 1) = *(_WORD *)&a00010203040506_1[2 * v18];
    return sub_53DDE58(v21, &v21[v6], v3);
  }
  v9 = (_BYTE *)(v8 + v5);
  if ( a2 < 0 )
    *v9++ = 45;
  v10 = &v9[v6];
  if ( v2 >= 0x64 )
  {
    do
    {
      v11 = v2 >> 4 > 0x270;
      v12 = v2 / 0x64;
      v13 = v2 % 0x64;
      v2 /= 0x64uLL;
      *((_WORD *)v10 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
      v10 -= 2;
    }
    while ( v11 );
    if ( v12 <= 9 )
      goto LABEL_11;
LABEL_26:
    *((_WORD *)v10 - 1) = *(_WORD *)&a00010203040506_1[2 * v12];
    return v3;
  }
  v12 = v2;
  if ( v2 > 9 )
    goto LABEL_26;
LABEL_11:
  *(v10 - 1) = v12 + 48;
  return v3;
}


================================================================================
Function: sub_680AC4C (0x680AC4C)
================================================================================

__int64 __fastcall sub_680AC4C(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // x2
  unsigned __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x8
  __int64 v6; // x11
  __int64 v7; // x8
  bool v8; // cc
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x13
  _BYTE *v11; // x8
  _BYTE *v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x14
  _BYTE v16[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v2 = a1;
  v3 = byte_102749E[__clz(a2 | 1) ^ 0x3F];
  v4 = a1[2];
  v5 = (__PAIR128__(v3, a2) - qword_10274E0[v3]) >> 64;
  if ( a1[3] < (unsigned __int64)(v5 + v4) || (v6 = a1[1], a1[2] = v5 + v4, !v6) )
  {
    v11 = &v16[v5];
    if ( a2 < 0x64 )
    {
      v12 = v11;
      v13 = a2;
      if ( a2 <= 9 )
      {
LABEL_11:
        *(v12 - 1) = v13 + 48;
        return sub_53DDE58(v16, v11, a1);
      }
    }
    else
    {
      v12 = v11;
      do
      {
        v8 = a2 >> 4 > 0x270;
        v13 = a2 / 0x64;
        v14 = a2 % 0x64;
        a2 /= 0x64uLL;
        *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
        v12 -= 2;
      }
      while ( v8 );
      if ( v13 <= 9 )
        goto LABEL_11;
    }
    *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
    return sub_53DDE58(v16, v11, a1);
  }
  v7 = v6 + v4 + v5;
  if ( a2 >= 0x64 )
  {
    do
    {
      v8 = a2 >> 4 > 0x270;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64uLL;
      *(_WORD *)(v7 - 2) = *(_WORD *)&a00010203040506_1[2 * v10];
      v7 -= 2LL;
    }
    while ( v8 );
    if ( v9 <= 9 )
      goto LABEL_6;
LABEL_17:
    *(_WORD *)(v7 - 2) = *(_WORD *)&a00010203040506_1[2 * v9];
    return (__int64)v2;
  }
  v9 = a2;
  if ( a2 > 9 )
    goto LABEL_17;
LABEL_6:
  *(_BYTE *)(v7 - 1) = v9 + 48;
  return (__int64)v2;
}


================================================================================
Function: sub_680AE00 (0x680AE00)
================================================================================

__int64 __fastcall sub_680AE00(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x9
  unsigned __int64 v8; // x21
  unsigned __int64 v9; // x20
  bool v10; // w8
  int v11; // w26
  unsigned __int64 v12; // x24
  unsigned __int64 v13; // x23
  bool v14; // w8
  bool v15; // w8
  __int128 v16; // t2
  bool v17; // w9
  bool v18; // w8
  __int64 v19; // x0
  __int128 v20; // t2
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // x1
  bool v23; // w8
  bool v24; // zf
  bool v25; // w9
  __int64 v26; // x8
  unsigned __int64 v27; // x9
  __int64 v28; // x10
  _BYTE *v29; // x8
  _BYTE *v30; // x22
  bool v31; // w9
  unsigned __int64 v32; // x0
  unsigned __int64 v33; // x1
  __int128 v34; // t2
  unsigned __int64 v35; // x9
  bool v36; // w10
  __int16 v37; // w8
  bool v38; // w9
  __int64 v39; // x8
  __int64 v40; // x1
  __int64 v41; // x9
  bool v42; // w8
  _BYTE *v43; // x23
  unsigned __int64 v44; // x0
  unsigned __int64 v45; // x1
  __int128 v46; // t2
  unsigned __int64 v47; // x9
  bool v48; // w10
  __int16 v49; // w8
  bool v50; // w9
  bool v51; // w8
  bool v53; // w8
  _BYTE v54[40]; // [xsp+0h] [xbp-30h] BYREF

  v5 = (unsigned __int128)-(__int128)__PAIR128__(v4, a3) >> 64;
  if ( a4 >= 0 )
    v8 = a3;
  else
    v8 = -(__int64)a3;
  if ( a4 >= 0 )
    v9 = a4;
  else
    v9 = v5;
  v10 = v8 < 0xA;
  if ( v9 )
    v10 = 0;
  if ( v10 )
  {
    v11 = 1;
  }
  else
  {
    v11 = 4;
    v12 = v8;
    v13 = v9;
    while ( 1 )
    {
      v14 = v12 > 0x63;
      if ( v13 )
        v14 = 1;
      if ( !v14 )
      {
        v11 -= 2;
        goto LABEL_28;
      }
      v15 = v12 > 0x3E7;
      if ( v13 )
        v15 = 1;
      if ( !v15 )
        break;
      *((_QWORD *)&v16 + 1) = v13;
      *(_QWORD *)&v16 = v12;
      v17 = (unsigned __int64)(v16 >> 4) < 0x271;
      if ( v13 >> 4 )
        v18 = 0;
      else
        v18 = v17;
      if ( v18 )
        goto LABEL_28;
      v19 = sub_6866974(v12, v13, 10000LL, 0LL);
      *((_QWORD *)&v20 + 1) = v13;
      *(_QWORD *)&v20 = v12;
      v21 = v13 >> 5;
      v11 += 4;
      v12 = v19;
      v13 = v22;
      v23 = (unsigned __int64)(v20 >> 5) > 0xC34;
      v24 = v21 == 0;
      v25 = v21 != 0;
      if ( !v24 )
        v23 = v25;
      if ( !v23 )
      {
        v11 -= 3;
        goto LABEL_28;
      }
    }
    --v11;
  }
LABEL_28:
  v26 = *(_QWORD *)(a1 + 16);
  v27 = v11 + ((unsigned __int64)a4 >> 63) + v26;
  if ( *(_QWORD *)(a1 + 24) >= v27 && (v28 = *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16) = v27, v28) )
  {
    v29 = (_BYTE *)(v28 + v26);
    if ( a4 < 0 )
      *v29++ = 45;
    v30 = &v29[v11];
    v31 = v8 < 0x64;
    if ( v9 )
      v31 = 0;
    if ( v31 )
    {
      v32 = v8;
      v33 = v9;
    }
    else
    {
      do
      {
        v32 = sub_6866974(v8, v9, 100LL, 0LL);
        *((_QWORD *)&v34 + 1) = v9;
        *(_QWORD *)&v34 = v8;
        v35 = v8 - 100 * v32;
        v8 = v32;
        v36 = (unsigned __int64)(v34 >> 4) > 0x270;
        v37 = *(_WORD *)&a00010203040506_1[2 * v35];
        v38 = v9 >> 4 != 0;
        if ( !(v9 >> 4) )
          v38 = v36;
        v9 = v33;
        *((_WORD *)v30 - 1) = v37;
        v30 -= 2;
      }
      while ( v38 );
    }
    v53 = v32 > 9;
    if ( v33 )
      v53 = 1;
    if ( v53 )
      *((_WORD *)v30 - 1) = *(_WORD *)&a00010203040506_1[2 * v32];
    else
      *(v30 - 1) = v32 + 48;
  }
  else
  {
    if ( a4 < 0 )
    {
      v39 = *(_QWORD *)(a1 + 16);
      v40 = v39 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v39 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v39 = *(_QWORD *)(a1 + 16);
        v40 = v39 + 1;
      }
      v41 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v40;
      *(_BYTE *)(v41 + v39) = 45;
    }
    if ( v9 )
      v42 = 0;
    else
      v42 = v8 < 0x64;
    if ( v42 )
    {
      v43 = &v54[v11];
      v44 = v8;
      v45 = v9;
    }
    else
    {
      v43 = &v54[v11];
      do
      {
        v44 = sub_6866974(v8, v9, 100LL, 0LL);
        *((_QWORD *)&v46 + 1) = v9;
        *(_QWORD *)&v46 = v8;
        v47 = v8 - 100 * v44;
        v8 = v44;
        v48 = (unsigned __int64)(v46 >> 4) > 0x270;
        v49 = *(_WORD *)&a00010203040506_1[2 * v47];
        v50 = v9 >> 4 != 0;
        if ( !(v9 >> 4) )
          v50 = v48;
        v9 = v45;
        *((_WORD *)v43 - 1) = v49;
        v43 -= 2;
      }
      while ( v50 );
    }
    v51 = v44 > 9;
    if ( v45 )
      v51 = 1;
    if ( v51 )
      *((_WORD *)v43 - 1) = *(_WORD *)&a00010203040506_1[2 * v44];
    else
      *(v43 - 1) = v44 + 48;
    return sub_53DDE58(v54, &v54[v11], a1);
  }
  return a1;
}


================================================================================
Function: sub_680B128 (0x680B128)
================================================================================

__int64 __fastcall sub_680B128(_QWORD *a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  bool v4; // w8
  unsigned __int64 v5; // x20
  unsigned __int64 v6; // x21
  int v8; // w25
  unsigned __int64 v9; // x23
  unsigned __int64 v10; // x22
  bool v11; // w8
  bool v12; // w8
  __int128 v13; // t2
  bool v14; // w9
  bool v15; // w8
  __int64 v16; // x0
  __int128 v17; // t2
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x1
  bool v20; // w8
  bool v21; // zf
  bool v22; // w9
  __int64 v23; // x9
  unsigned __int64 v24; // x11
  __int64 v25; // x10
  __int64 v26; // x9
  bool v27; // w10
  __int64 v28; // x22
  unsigned __int64 v29; // x0
  unsigned __int64 v30; // x1
  __int128 v31; // t2
  unsigned __int64 v32; // x9
  bool v33; // w10
  __int16 v34; // w8
  bool v35; // w9
  bool v36; // w9
  _BYTE *v37; // x23
  unsigned __int64 v38; // x0
  unsigned __int64 v39; // x1
  __int128 v40; // t2
  unsigned __int64 v41; // x9
  bool v42; // w10
  __int16 v43; // w8
  bool v44; // w9
  bool v45; // w8
  bool v47; // w8
  _BYTE v48[40]; // [xsp+0h] [xbp-30h] BYREF

  v4 = a3 < 0xA;
  v5 = a4;
  v6 = a3;
  if ( a4 )
    v4 = 0;
  if ( v4 )
  {
    v8 = 1;
  }
  else
  {
    v8 = 4;
    v9 = a3;
    v10 = a4;
    while ( 1 )
    {
      v11 = v9 > 0x63;
      if ( v10 )
        v11 = 1;
      if ( !v11 )
      {
        v8 -= 2;
        goto LABEL_22;
      }
      v12 = v9 > 0x3E7;
      if ( v10 )
        v12 = 1;
      if ( !v12 )
        break;
      *((_QWORD *)&v13 + 1) = v10;
      *(_QWORD *)&v13 = v9;
      v14 = (unsigned __int64)(v13 >> 4) < 0x271;
      if ( v10 >> 4 )
        v15 = 0;
      else
        v15 = v14;
      if ( v15 )
        goto LABEL_22;
      v16 = sub_6866974(v9, v10, 10000LL, 0LL);
      *((_QWORD *)&v17 + 1) = v10;
      *(_QWORD *)&v17 = v9;
      v18 = v10 >> 5;
      v8 += 4;
      v9 = v16;
      v10 = v19;
      v20 = (unsigned __int64)(v17 >> 5) > 0xC34;
      v21 = v18 == 0;
      v22 = v18 != 0;
      if ( !v21 )
        v20 = v22;
      if ( !v20 )
      {
        v8 -= 3;
        goto LABEL_22;
      }
    }
    --v8;
  }
LABEL_22:
  v23 = a1[2];
  v24 = v23 + v8;
  if ( a1[3] >= v24 && (v25 = a1[1], a1[2] = v24, v25) )
  {
    v26 = v25 + v23;
    if ( v5 )
      v27 = 0;
    else
      v27 = v6 < 0x64;
    v28 = v26 + v8;
    if ( v27 )
    {
      v29 = v6;
      v30 = v5;
    }
    else
    {
      do
      {
        v29 = sub_6866974(v6, v5, 100LL, 0LL);
        *((_QWORD *)&v31 + 1) = v5;
        *(_QWORD *)&v31 = v6;
        v32 = v6 - 100 * v29;
        v6 = v29;
        v33 = (unsigned __int64)(v31 >> 4) > 0x270;
        v34 = *(_WORD *)&a00010203040506_1[2 * v32];
        v35 = v5 >> 4 != 0;
        if ( !(v5 >> 4) )
          v35 = v33;
        v5 = v30;
        *(_WORD *)(v28 - 2) = v34;
        v28 -= 2LL;
      }
      while ( v35 );
    }
    v47 = v29 > 9;
    if ( v30 )
      v47 = 1;
    if ( v47 )
      *(_WORD *)(v28 - 2) = *(_WORD *)&a00010203040506_1[2 * v29];
    else
      *(_BYTE *)(v28 - 1) = v29 + 48;
  }
  else
  {
    v36 = v6 < 0x64;
    if ( v5 )
      v36 = 0;
    if ( v36 )
    {
      v37 = &v48[v8];
      v38 = v6;
      v39 = v5;
    }
    else
    {
      v37 = &v48[v8];
      do
      {
        v38 = sub_6866974(v6, v5, 100LL, 0LL);
        *((_QWORD *)&v40 + 1) = v5;
        *(_QWORD *)&v40 = v6;
        v41 = v6 - 100 * v38;
        v6 = v38;
        v42 = (unsigned __int64)(v40 >> 4) > 0x270;
        v43 = *(_WORD *)&a00010203040506_1[2 * v41];
        v44 = v5 >> 4 != 0;
        if ( !(v5 >> 4) )
          v44 = v42;
        v5 = v39;
        *((_WORD *)v37 - 1) = v43;
        v37 -= 2;
      }
      while ( v44 );
    }
    v45 = v38 > 9;
    if ( v39 )
      v45 = 1;
    if ( v45 )
      *((_WORD *)v37 - 1) = *(_WORD *)&a00010203040506_1[2 * v38];
    else
      *(v37 - 1) = v38 + 48;
    return sub_53DDE58(v48, &v48[v8], a1);
  }
  return (__int64)a1;
}


================================================================================
Function: sub_680B3F4 (0x680B3F4)
================================================================================

__int64 __fastcall sub_680B3F4(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 *a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x19
  char *v8; // x20
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x21
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x21
  unsigned __int64 v14; // x22
  __int64 v15; // x10
  __int64 v16; // x23
  __int64 v17; // x24
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x12
  unsigned __int64 v20; // x8
  __int64 v21; // x11
  _BYTE *v22; // x9
  char *v23; // x13
  unsigned __int64 v24; // x14
  __int64 v25; // x15
  _OWORD *v26; // x13
  __int128 *v27; // x14
  unsigned __int64 v28; // x16
  __int128 v29; // q0
  __int128 v30; // q1
  __int64 *v31; // x16
  _QWORD *v32; // x11
  __int64 v33; // x15
  __int64 v34; // t1
  char v35; // t1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_174D7F9[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_250EF44(a1, v10 >> v9, v8);
  v12 = a5[1];
  v13 = v10 - v11;
  if ( v12 )
  {
    v14 = *a5;
    v15 = *(_QWORD *)(v7 + 16);
    v16 = v14 + v12;
    v17 = v12 + v14;
    do
    {
      v18 = *(_QWORD *)(v7 + 24);
      if ( v18 < v16 - v14 + v15 )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v15 = *(_QWORD *)(v7 + 16);
        v18 = *(_QWORD *)(v7 + 24);
      }
      v19 = v18 - v15;
      if ( v18 - v15 >= v16 - v14 )
        v20 = v16 - v14;
      else
        v20 = v18 - v15;
      if ( !v20 )
        goto LABEL_9;
      v21 = *(_QWORD *)(v7 + 8);
      v22 = (_BYTE *)(v21 + v15);
      if ( v20 >= 8 )
      {
        if ( (unsigned __int64)v22 >= v14 + v20 || (v24 = v20, v23 = (char *)v14, v14 >= v21 + v15 + v20) )
        {
          if ( v20 < 0x20 )
          {
            v25 = 0LL;
LABEL_26:
            v31 = (__int64 *)(v14 + v25);
            if ( v17 - v14 < v19 )
              v19 = v17 - v14;
            v32 = (_QWORD *)(v21 + v15 + v25);
            v23 = (char *)(v14 + (v19 & 0xFFFFFFFFFFFFFFF8LL));
            v22 += v19 & 0xFFFFFFFFFFFFFFF8LL;
            v24 = v20 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            v33 = v25 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v34 = *v31++;
              v33 += 8LL;
              *v32++ = v34;
            }
            while ( v33 );
            if ( v19 == (v19 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_8;
            goto LABEL_33;
          }
          v25 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          v26 = (_OWORD *)(v21 + v15 + 16);
          v27 = (__int128 *)(v14 + 16);
          v28 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v29 = *(v27 - 1);
            v30 = *v27;
            v27 += 2;
            v28 -= 32LL;
            *(v26 - 1) = v29;
            *v26 = v30;
            v26 += 2;
          }
          while ( v28 );
          if ( v20 == v25 )
            goto LABEL_8;
          if ( (v20 & 0x18) != 0 )
            goto LABEL_26;
          v24 = v20 & 0x1F;
          v22 += v25;
          v23 = (char *)(v14 + v25);
        }
      }
      else
      {
        v23 = (char *)v14;
        v24 = v20;
      }
      do
      {
LABEL_33:
        v35 = *v23++;
        --v24;
        *v22++ = v35;
      }
      while ( v24 );
LABEL_8:
      v15 = *(_QWORD *)(v7 + 16);
LABEL_9:
      v15 += v20;
      v14 += v20;
      *(_QWORD *)(v7 + 16) = v15;
    }
    while ( v14 != v16 );
  }
  result = v7;
  if ( v13 )
    return sub_250EF44(v7, v13, v8);
  return result;
}


================================================================================
Function: sub_680B5F8 (0x680B5F8)
================================================================================

__int64 __fastcall sub_680B5F8(__int64 a1, long double a2)
{
  int v3; // w8
  float v4; // s0
  __int64 v5; // x2
  unsigned int v6; // w8
  const char *v7; // x9
  __int64 v9; // x21
  unsigned int v10; // [xsp+0h] [xbp-40h] BYREF
  const char *v11; // [xsp+8h] [xbp-38h]
  __int128 v12; // [xsp+10h] [xbp-30h] BYREF
  __int128 v13; // [xsp+20h] [xbp-20h] BYREF

  v3 = LODWORD(a2);
  v13 = xmmword_AFF2B0;
  if ( (~LODWORD(a2) & 0x7F800000) != 0 )
  {
    v9 = (LODWORD(a2) >> 23) & 0x100;
    if ( SLODWORD(a2) < 0 )
      *(float *)&a2 = -*(float *)&a2;
    *(_QWORD *)&v12 = sub_6807640(a2);
    return sub_680B948(a1, &v12, &v13, v9 << 32, 0LL);
  }
  else
  {
    v4 = fabsf(*(float *)&a2);
    if ( v3 >= 0 )
      v5 = 3LL;
    else
      v5 = 4LL;
    v6 = (unsigned int)v3 >> 31;
    v7 = "nan";
    if ( v4 == INFINITY )
      v7 = "inf";
    v12 = xmmword_AFF2B0;
    v10 = v6;
    v11 = v7;
    return sub_680B6FC(a1, &v12, v5, v5, &v10);
  }
}


================================================================================
Function: sub_680B6FC (0x680B6FC)
================================================================================

__int64 __fastcall sub_680B6FC(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned int *a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x19
  char *v8; // x20
  char v9; // w8
  unsigned __int64 v10; // x25
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x8
  char v14; // w23
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x24
  __int64 v18; // x23
  unsigned __int64 v19; // x21
  __int64 v20; // x11
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x12
  unsigned __int64 v23; // x8
  __int64 v24; // x13
  char *v25; // x9
  _BYTE *v26; // x10
  unsigned __int64 v27; // x14
  unsigned __int64 v28; // x15
  _OWORD *v29; // x14
  __int128 *v30; // x16
  unsigned __int64 v31; // x17
  __int128 v32; // q0
  __int128 v33; // q1
  __int64 v34; // x16
  unsigned __int64 v35; // x11
  _QWORD *v36; // x13
  __int64 *v37; // x16
  unsigned __int64 v38; // x15
  __int64 v39; // t1
  char v40; // t1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_174D7F9[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_250EF44(a1, v10 >> v9, v8);
  v12 = *a5;
  if ( (_DWORD)v12 )
  {
    v13 = *(_QWORD *)(v7 + 16);
    v14 = byte_174D7FE[v12];
    v15 = v13 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v13 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v13 = *(_QWORD *)(v7 + 16);
      v15 = v13 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v13) = v14;
  }
  v17 = *((_QWORD *)a5 + 1);
  v18 = 0LL;
  v19 = v10 - v11;
  v20 = *(_QWORD *)(v7 + 16);
  do
  {
    v21 = *(_QWORD *)(v7 + 24);
    if ( v21 < 3 - v18 + v20 )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v20 = *(_QWORD *)(v7 + 16);
      v21 = *(_QWORD *)(v7 + 24);
    }
    v22 = v21 - v20;
    if ( v21 - v20 >= 3 - v18 )
      v23 = 3 - v18;
    else
      v23 = v21 - v20;
    if ( v23 )
    {
      v24 = *(_QWORD *)(v7 + 8);
      v25 = (char *)(v17 + v18);
      v26 = (_BYTE *)(v24 + v20);
      if ( v23 < 8 )
      {
        v27 = v23;
        goto LABEL_37;
      }
      if ( (unsigned __int64)v26 < v17 + v18 + v23 )
      {
        v27 = v23;
        if ( (unsigned __int64)v25 < v24 + v20 + v23 )
          goto LABEL_37;
      }
      if ( v23 >= 0x20 )
      {
        v28 = v23 & 0xFFFFFFFFFFFFFFE0LL;
        v29 = (_OWORD *)(v24 + v20 + 16);
        v30 = (__int128 *)(v17 + 16 + v18);
        v31 = v23 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v32 = *(v30 - 1);
          v33 = *v30;
          v30 += 2;
          v31 -= 32LL;
          *(v29 - 1) = v32;
          *v29 = v33;
          v29 += 2;
        }
        while ( v31 );
        if ( v23 == v28 )
          goto LABEL_11;
        if ( (v23 & 0x18) == 0 )
        {
          v27 = v23 & 0x1F;
          v26 += v28;
          v25 += v28;
          do
          {
LABEL_37:
            v40 = *v25++;
            --v27;
            *v26++ = v40;
          }
          while ( v27 );
LABEL_11:
          v20 = *(_QWORD *)(v7 + 16);
          goto LABEL_12;
        }
      }
      else
      {
        v28 = 0LL;
      }
      v34 = v20 + v28;
      if ( v22 >= 3 - v18 )
        v35 = 3 - v18;
      else
        v35 = v22;
      v36 = (_QWORD *)(v24 + v34);
      v37 = (__int64 *)(v17 + v28 + v18);
      v25 += v35 & 0xFFFFFFFFFFFFFFF8LL;
      v26 += v35 & 0xFFFFFFFFFFFFFFF8LL;
      v27 = v23 - (v35 & 0xFFFFFFFFFFFFFFF8LL);
      v38 = v28 - (v35 & 0xFFFFFFFFFFFFFFF8LL);
      do
      {
        v39 = *v37++;
        v38 += 8LL;
        *v36++ = v39;
      }
      while ( v38 );
      if ( v35 == (v35 & 0xFFFFFFFFFFFFFFF8LL) )
        goto LABEL_11;
      goto LABEL_37;
    }
LABEL_12:
    v20 += v23;
    v18 += v23;
    *(_QWORD *)(v7 + 16) = v20;
  }
  while ( v18 != 3 );
  result = v7;
  if ( v19 )
    return sub_250EF44(v7, v19, v8);
  return result;
}


================================================================================
Function: sub_680B948 (0x680B948)
================================================================================

__int64 __fastcall sub_680B948(__int64 a1, unsigned int *a2, unsigned int *a3, unsigned __int64 a4, __int64 *a5)
{
  unsigned int v5; // w19
  unsigned int *v7; // x21
  __int64 v9; // x15
  unsigned __int64 v10; // x28
  __int64 v11; // x25
  __int64 v12; // x8
  unsigned __int64 v13; // x26
  __int64 v14; // x22
  char v15; // w24
  __int64 *v17; // x21
  __int64 v18; // x2
  __int64 *v19; // x0
  __int64 v20; // x9
  int v21; // w8
  int v22; // w10
  int v23; // w8
  __int64 v24; // x23
  __int64 v25; // x24
  int v26; // w9
  __int64 v27; // x10
  __int64 v28; // x20
  __int64 v29; // x19
  unsigned __int8 *v30; // x9
  unsigned __int64 v31; // x11
  unsigned int v32; // w8
  int v33; // w10
  unsigned __int8 *v34; // x11
  __int64 v35; // x0
  unsigned int *v36; // x1
  int v37; // w12
  int v38; // w8
  char v39; // w12
  unsigned __int64 v40; // x11
  __int64 v41; // x9
  __int64 v42; // x13
  __int64 v43; // x12
  _BYTE *v44; // x20
  char v45; // w8
  unsigned __int64 v46; // x9
  bool v47; // cf
  unsigned __int64 v48; // x9
  __int64 v49; // x21
  __int64 v50; // x19
  unsigned __int8 *v52; // x9
  unsigned __int64 v53; // x11
  unsigned int v54; // w8
  int v55; // w10
  unsigned __int8 *v56; // x11
  __int64 v57; // x1
  int v58; // w12
  char v59; // w12
  unsigned __int64 v60; // x8
  unsigned __int64 v61; // x11
  char v62; // w9
  unsigned __int64 v63; // x8
  unsigned __int64 v64; // x22
  unsigned __int64 v65; // x21
  __int64 v66; // x0
  __int64 v67; // x0
  bool v68; // cc
  int v70; // w8
  int v72; // w9
  unsigned __int64 v73; // x13
  unsigned __int64 v74; // x8
  unsigned __int64 v75; // x8
  char v76; // w10
  int *v78; // [xsp+8h] [xbp-98h] BYREF
  int *v79; // [xsp+10h] [xbp-90h]
  int *v80; // [xsp+18h] [xbp-88h]
  int *v81; // [xsp+20h] [xbp-80h]
  int *v82; // [xsp+28h] [xbp-78h]
  int *v83; // [xsp+30h] [xbp-70h]
  int *v84; // [xsp+38h] [xbp-68h]
  int *v85; // [xsp+40h] [xbp-60h]
  _BYTE *v86; // [xsp+48h] [xbp-58h]
  int v87; // [xsp+54h] [xbp-4Ch] BYREF
  int v88; // [xsp+58h] [xbp-48h] BYREF
  _BYTE v89[4]; // [xsp+5Ch] [xbp-44h] BYREF
  int v90; // [xsp+60h] [xbp-40h] BYREF
  _BYTE v91[4]; // [xsp+64h] [xbp-3Ch] BYREF
  int v92; // [xsp+68h] [xbp-38h] BYREF
  int v93; // [xsp+6Ch] [xbp-34h] BYREF
  unsigned __int64 v94; // [xsp+70h] [xbp-30h] BYREF
  int v95; // [xsp+78h] [xbp-28h] BYREF
  unsigned __int64 v96; // [xsp+80h] [xbp-20h]
  unsigned __int8 *v97; // [xsp+88h] [xbp-18h]
  char v98; // [xsp+90h] [xbp-10h]

  v5 = BYTE5(a4);
  v7 = a2;
  v9 = a1;
  v10 = HIDWORD(a4);
  v11 = *a2;
  v94 = a4;
  v90 = BYTE5(a4);
  v12 = qword_10275E8[__clz(v11 | 1) ^ 0x1F];
  v91[0] = 48;
  v13 = (unsigned __int64)(v12 + v11) >> 32;
  if ( BYTE5(a4) )
    v14 = (unsigned int)(v13 + 1);
  else
    v14 = (unsigned int)v13;
  v92 = (unsigned __int64)(v12 + v11) >> 32;
  v93 = v11;
  if ( (a4 & 0x2000000000000LL) != 0 )
  {
    if ( a5 )
    {
      v17 = a5;
      sub_683B82C((__int64 *)&v78, a5);
    }
    else
    {
      v17 = 0LL;
      sub_683B7A0(&v78);
    }
    v19 = sub_683BBD0((__int64 *)&v78, (__int64)&unk_79D7EA8, v18);
    v15 = (*(__int64 (__fastcall **)(__int64 *))(*v19 + 24))(v19);
    sub_683B844(&v78);
    v9 = a1;
    a5 = v17;
    v7 = a2;
  }
  else
  {
    v15 = 46;
  }
  v20 = v7[1];
  v89[0] = v15;
  v21 = v20 + v13;
  if ( BYTE4(a4) != 1 )
  {
    if ( BYTE4(a4) || ((int)a4 <= 0 ? (v22 = 16) : (v22 = a4), v21 >= -3 && v21 <= v22) )
    {
      v88 = v20 + v13;
      if ( (v20 & 0x80000000) == 0 )
      {
        v23 = a4 - v21;
        v24 = v14 + v20;
        v87 = v23;
        if ( (v10 & 0x100000) == 0 )
        {
          v25 = v9;
LABEL_63:
          sub_53DD748(&v95, a5, ((unsigned int)v10 >> 17) & 1);
          v52 = v97;
          if ( (v95 & 1) != 0 )
          {
            v53 = v96;
          }
          else
          {
            v52 = (unsigned __int8 *)&v95 + 1;
            v53 = (unsigned __int64)(unsigned __int8)v95 >> 1;
          }
          v54 = 0;
          if ( v98 )
          {
            v55 = 0;
            v56 = &v52[v53];
            v57 = v25;
            if ( v56 == v52 )
              goto LABEL_70;
LABEL_68:
            v58 = *v52;
            if ( (unsigned int)(v58 - 127) >= 0xFFFFFF82 )
            {
              ++v52;
              while ( 1 )
              {
                v55 += v58;
                if ( v55 >= (int)v13 )
                  break;
                ++v54;
                if ( v56 != v52 )
                  goto LABEL_68;
LABEL_70:
                v58 = (char)*(v56 - 1);
              }
            }
          }
          else
          {
            v57 = v25;
          }
          v59 = *(_WORD *)((char *)a3 + 9);
          v60 = v24 + v54;
          v78 = &v90;
          v79 = &v93;
          v80 = &v92;
          v81 = (int *)v7;
          v61 = *a3;
          v82 = &v95;
          v83 = (int *)&v94;
          v62 = byte_174D7F4[v59 & 0xF];
          v47 = v61 >= v60;
          v63 = v61 - v60;
          if ( v47 )
            v64 = v63;
          else
            v64 = 0LL;
          v65 = v64 >> v62;
          v84 = (int *)v89;
          v85 = &v87;
          v86 = v91;
          if ( v64 >> v62 )
            v57 = sub_250EF44(v57, v64 >> v62, (_BYTE *)a3 + 11);
          v66 = sub_680C3F4(&v78, v57);
          v50 = v66;
          if ( v64 == v65 )
            goto LABEL_96;
          v67 = sub_250EF44(v66, v64 - v65, (_BYTE *)a3 + 11);
LABEL_95:
          v50 = v67;
LABEL_96:
          if ( (v95 & 1) != 0 )
            sub_65ECAF4();
          return v50;
        }
        if ( v23 > 0 || (unsigned __int8)v10 == 2 )
        {
          v25 = v9;
          if ( v23 < 1 )
            goto LABEL_63;
        }
        else
        {
          v23 = 1;
          v25 = v9;
          v87 = 1;
        }
        v24 += (unsigned int)(v23 + 1);
        goto LABEL_63;
      }
      if ( v21 >= 1 )
      {
        v28 = v9;
        v87 = (a4 - v13) & ((int)((_DWORD)v10 << 11) >> 31);
        v29 = v14 + (v87 & (unsigned int)~(v87 >> 31)) + 1;
        sub_53DD748(&v95, a5, ((unsigned int)v10 >> 17) & 1);
        v30 = v97;
        if ( (v95 & 1) != 0 )
        {
          v31 = v96;
        }
        else
        {
          v30 = (unsigned __int8 *)&v95 + 1;
          v31 = (unsigned __int64)(unsigned __int8)v95 >> 1;
        }
        v32 = 0;
        if ( v98 )
        {
          v33 = 0;
          v34 = &v30[v31];
          v35 = v28;
          v36 = a3;
          if ( v34 == v30 )
            goto LABEL_32;
LABEL_30:
          v37 = *v30;
          if ( (unsigned int)(v37 - 127) >= 0xFFFFFF82 )
          {
            ++v30;
            while ( 1 )
            {
              v33 += v37;
              if ( v33 >= (int)v13 )
                break;
              ++v32;
              if ( v34 != v30 )
                goto LABEL_30;
LABEL_32:
              v37 = (char)*(v34 - 1);
            }
          }
        }
        else
        {
          v35 = v28;
          v36 = a3;
        }
        v78 = &v90;
        v79 = &v93;
        v80 = &v92;
        v81 = &v88;
        v82 = (int *)v89;
        v83 = &v95;
        v84 = &v87;
        v85 = (int *)v91;
        v67 = sub_680C7D0(v35, v36, v29 + v32, v29 + v32, &v78);
        goto LABEL_95;
      }
      v68 = (int)a4 >= -v21 || (int)a4 <= -1;
      if ( !v68 && (_DWORD)v13 == 0 )
        v70 = a4;
      else
        v70 = -v21;
      v95 = v70;
      if ( v70 | (unsigned int)v13 )
      {
        LOBYTE(v87) = 1;
      }
      else
      {
        LOBYTE(v87) = (v10 & 0x100000) != 0;
        if ( (v10 & 0x100000) == 0 )
        {
          v72 = 1;
          goto LABEL_102;
        }
      }
      v72 = 2;
LABEL_102:
      v73 = *a3;
      v74 = v14 + (unsigned int)(v72 + v70);
      v47 = v73 >= v74;
      v75 = v73 - v74;
      if ( !v47 )
        v75 = 0LL;
      v76 = byte_174D7F4[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v78 = &v90;
      v79 = (int *)v91;
      v44 = (char *)a3 + 11;
      v80 = &v87;
      v81 = (int *)v89;
      v49 = v75 - (v75 >> v76);
      v82 = &v95;
      v83 = &v93;
      v84 = &v92;
      if ( v75 >> v76 )
        v9 = sub_250EF44(v9, v75 >> v76, (_BYTE *)a3 + 11);
      v50 = sub_680CA60(&v78, v9);
      if ( !v49 )
        return v50;
      return sub_250EF44(v50, v49, v44);
    }
  }
  v26 = v21 - 1;
  if ( (v10 & 0x100000) != 0 )
  {
    v27 = ((_DWORD)a4 - (_DWORD)v13) & (unsigned int)~(((int)a4 - (int)v13) >> 31);
    v14 += v27;
  }
  else if ( (_DWORD)v13 == 1 )
  {
    v15 = 0;
    LODWORD(v27) = 0;
    v89[0] = 0;
  }
  else
  {
    LODWORD(v27) = 0;
  }
  v68 = v21 <= 0;
  v38 = 1 - v21;
  if ( !v68 )
    v38 = v26;
  if ( (v10 & 0x10000) != 0 )
    v39 = 69;
  else
    v39 = 101;
  v40 = *a3;
  v78 = (int *)__PAIR64__(v11, v5);
  LODWORD(v79) = v13;
  BYTE4(v79) = v15;
  LODWORD(v80) = v27;
  BYTE4(v80) = 48;
  BYTE5(v80) = v39;
  LODWORD(v81) = v26;
  if ( (int)v40 < 1 )
    return sub_680BF64(&v78, v9);
  v41 = 2LL;
  v42 = 3LL;
  if ( v15 )
    v43 = 3LL;
  else
    v43 = 2LL;
  if ( v38 > 999 )
    v42 = 4LL;
  if ( v38 > 99 )
    v41 = v42;
  v44 = (char *)a3 + 11;
  v45 = byte_174D7F4[*(_WORD *)((_BYTE *)a3 + 9) & 0xFLL];
  v46 = v14 + v41 + v43;
  v47 = v40 >= v46;
  v48 = v40 - v46;
  if ( !v47 )
    v48 = 0LL;
  v49 = v48 - (v48 >> v45);
  if ( v48 >> v45 )
    v9 = sub_250EF44(v9, v48 >> v45, (_BYTE *)a3 + 11);
  v50 = sub_680BF64(&v78, v9);
  if ( v49 )
    return sub_250EF44(v50, v49, v44);
  return v50;
}


================================================================================
Function: sub_680BF64 (0x680BF64)
================================================================================

__int64 __fastcall sub_680BF64(unsigned int *a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w22
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x0
  int v12; // w22
  __int64 v13; // x20
  __int64 v14; // x8
  char v15; // w22
  __int64 v16; // x1
  __int64 v17; // x9
  char v19; // w9
  __int64 v20; // x10
  __int64 v21; // x8
  __int64 v22; // x1
  _BYTE v23[12]; // [xsp+Ch] [xbp-14h] BYREF

  v4 = *a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_174D7FE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_680C274(v23, a1[1], a1[2], 1LL, *((unsigned __int8 *)a1 + 12));
  v11 = sub_53DDE58((unsigned __int64)v23, v10, a2);
  v12 = a1[4];
  v13 = v11;
  if ( v12 >= 1 )
  {
    do
    {
      v21 = *(_QWORD *)(v13 + 16);
      v22 = v21 + 1;
      if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v21 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v13)(v13);
        v21 = *(_QWORD *)(v13 + 16);
        v22 = v21 + 1;
      }
      --v12;
      v19 = *((_BYTE *)a1 + 20);
      v20 = *(_QWORD *)(v13 + 8);
      *(_QWORD *)(v13 + 16) = v22;
      *(_BYTE *)(v20 + v21) = v19;
    }
    while ( v12 );
  }
  v14 = *(_QWORD *)(v13 + 16);
  v15 = *((_BYTE *)a1 + 21);
  v16 = v14 + 1;
  if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v14 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v13)(v13);
    v14 = *(_QWORD *)(v13 + 16);
    v16 = v14 + 1;
  }
  v17 = *(_QWORD *)(v13 + 8);
  *(_QWORD *)(v13 + 16) = v16;
  *(_BYTE *)(v17 + v14) = v15;
  return sub_680C0BC(a1[6], v13);
}


================================================================================
Function: sub_680C0BC (0x680C0BC)
================================================================================

__int64 __fastcall sub_680C0BC(unsigned int a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  unsigned int v5; // w20
  __int64 v6; // x1
  __int64 v7; // x9
  char v8; // w10
  char *v9; // x23
  __int64 v10; // x8
  char v11; // w24
  __int64 v12; // x1
  __int64 v13; // x9
  __int64 v14; // x8
  char v15; // w23
  __int64 v16; // x1
  __int64 v17; // x8
  char *v18; // x20
  char v19; // w21
  __int64 v20; // x1
  __int64 v21; // x9
  char v22; // w20
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 v25; // x9
  __int64 result; // x0

  v2 = *(_QWORD *)(a2 + 16);
  v3 = *(_QWORD *)(a2 + 24);
  v5 = a1;
  v6 = v2 + 1;
  if ( (a1 & 0x80000000) != 0 )
  {
    if ( v3 < v2 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v2 = *(_QWORD *)(a2 + 16);
      v6 = v2 + 1;
    }
    v7 = *(_QWORD *)(a2 + 8);
    v8 = 45;
    v5 = -v5;
  }
  else
  {
    if ( v3 < v2 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v2 = *(_QWORD *)(a2 + 16);
      v6 = v2 + 1;
    }
    v7 = *(_QWORD *)(a2 + 8);
    v8 = 43;
  }
  *(_QWORD *)(a2 + 16) = v6;
  *(_BYTE *)(v7 + v2) = v8;
  if ( v5 >= 0x64 )
  {
    v9 = &a00010203040506_1[2 * (v5 / 0x64)];
    if ( v5 >= 0x3E8 )
    {
      v10 = *(_QWORD *)(a2 + 16);
      v11 = *v9;
      v12 = v10 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v10 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v10 = *(_QWORD *)(a2 + 16);
        v12 = v10 + 1;
      }
      v13 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v12;
      *(_BYTE *)(v13 + v10) = v11;
    }
    v14 = *(_QWORD *)(a2 + 16);
    v15 = v9[1];
    v16 = v14 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v14 = *(_QWORD *)(a2 + 16);
      v16 = v14 + 1;
    }
    *(_QWORD *)(a2 + 16) = v16;
    v5 %= 0x64u;
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + v14) = v15;
  }
  v17 = *(_QWORD *)(a2 + 16);
  v18 = &a00010203040506_1[2 * v5];
  v19 = *v18;
  v20 = v17 + 1;
  if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v17 + 1) )
  {
    (**(void (__fastcall ***)(__int64))a2)(a2);
    v17 = *(_QWORD *)(a2 + 16);
    v20 = v17 + 1;
  }
  v21 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 16) = v20;
  v22 = v18[1];
  *(_BYTE *)(v21 + v17) = v19;
  v23 = *(_QWORD *)(a2 + 16);
  v24 = v23 + 1;
  if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v23 + 1) )
  {
    (**(void (__fastcall ***)(__int64))a2)(a2);
    v23 = *(_QWORD *)(a2 + 16);
    v24 = v23 + 1;
  }
  v25 = *(_QWORD *)(a2 + 8);
  result = a2;
  *(_QWORD *)(a2 + 16) = v24;
  *(_BYTE *)(v25 + v23) = v22;
  return result;
}


================================================================================
Function: sub_680C274 (0x680C274)
================================================================================

__int64 __fastcall sub_680C274(__int64 a1, unsigned int a2, int a3, int a4, char a5)
{
  unsigned int v5; // w11
  __int64 result; // x0
  unsigned int v7; // w13
  __int64 v8; // x9
  unsigned int v9; // w10
  unsigned int v10; // w15
  unsigned int v11; // w12
  __int64 v12; // x9
  unsigned int v13; // w15
  unsigned int v14; // w11
  unsigned int v15; // w14
  __int64 v16; // x8
  unsigned int v17; // w14
  unsigned int v18; // w9
  unsigned int v19; // w13

  if ( !a5 )
  {
    result = a1 + a3;
    if ( a2 < 0x64 )
    {
      v16 = result;
      v18 = a2;
      if ( a2 <= 9 )
      {
LABEL_15:
        *(_BYTE *)(v16 - 1) = v18 + 48;
        return result;
      }
    }
    else
    {
      v16 = result;
      do
      {
        v17 = a2 >> 4;
        v18 = a2 / 0x64;
        v19 = a2 % 0x64;
        a2 /= 0x64u;
        *(_WORD *)(v16 - 2) = *(_WORD *)&a00010203040506_1[2 * v19];
        v16 -= 2LL;
      }
      while ( v17 > 0x270 );
      if ( v18 <= 9 )
        goto LABEL_15;
    }
    *(_WORD *)(v16 - 2) = *(_WORD *)&a00010203040506_1[2 * v18];
    return result;
  }
  v5 = a3 - a4;
  result = a1 + a3 + 1;
  if ( a3 - a4 < 2 )
  {
    v9 = a2;
    v8 = result;
    if ( (v5 & 1) == 0 )
      goto LABEL_7;
  }
  else
  {
    v7 = (v5 >> 1) + 1;
    v8 = result;
    do
    {
      --v7;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64u;
      *(_WORD *)(v8 - 2) = *(_WORD *)&a00010203040506_1[2 * v10];
      v8 -= 2LL;
    }
    while ( v7 > 1 );
    if ( (v5 & 1) == 0 )
      goto LABEL_7;
  }
  v11 = (v9 % 0xA) | 0x30;
  v9 /= 0xAu;
  *(_BYTE *)--v8 = v11;
LABEL_7:
  *(_BYTE *)(v8 - 1) = a5;
  v12 = v8 - 1;
  if ( v9 < 0x64 )
  {
    v14 = v9;
    if ( v9 <= 9 )
    {
LABEL_10:
      *(_BYTE *)(v12 - 1) = v14 + 48;
      return result;
    }
  }
  else
  {
    do
    {
      v13 = v9 >> 4;
      v14 = v9 / 0x64;
      v15 = v9 % 0x64;
      v9 /= 0x64u;
      *(_WORD *)(v12 - 2) = *(_WORD *)&a00010203040506_1[2 * v15];
      v12 -= 2LL;
    }
    while ( v13 > 0x270 );
    if ( v14 <= 9 )
      goto LABEL_10;
  }
  *(_WORD *)(v12 - 2) = *(_WORD *)&a00010203040506_1[2 * v14];
  return result;
}


================================================================================
Function: sub_680C3F4 (0x680C3F4)
================================================================================

__int64 __fastcall sub_680C3F4(unsigned int **a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x20
  __int64 v12; // x8
  unsigned int *v13; // x21
  __int64 v14; // x1
  char v15; // w9
  int v16; // w21
  unsigned int *v17; // x19
  char v18; // w9
  __int64 v19; // x10
  __int64 v20; // x8
  __int64 v21; // x1

  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_174D7FE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_680C530(a2, *a1[1], *a1[2], a1[3][1], a1[4]);
  v11 = v10;
  if ( (*((_BYTE *)a1[5] + 6) & 0x10) != 0 )
  {
    v12 = *(_QWORD *)(v10 + 16);
    v13 = a1[6];
    v14 = v12 + 1;
    if ( *(_QWORD *)(v10 + 24) < (unsigned __int64)(v12 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v10)(v10);
      v12 = *(_QWORD *)(v11 + 16);
      v14 = v12 + 1;
    }
    v15 = *(_BYTE *)v13;
    *(_QWORD *)(v11 + 16) = v14;
    *(_BYTE *)(*(_QWORD *)(v11 + 8) + v12) = v15;
    v16 = *a1[7];
    if ( v16 >= 1 )
    {
      v17 = a1[8];
      do
      {
        v20 = *(_QWORD *)(v11 + 16);
        v21 = v20 + 1;
        if ( *(_QWORD *)(v11 + 24) < (unsigned __int64)(v20 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v11)(v11);
          v20 = *(_QWORD *)(v11 + 16);
          v21 = v20 + 1;
        }
        --v16;
        v18 = *(_BYTE *)v17;
        v19 = *(_QWORD *)(v11 + 8);
        *(_QWORD *)(v11 + 16) = v21;
        *(_BYTE *)(v19 + v20) = v18;
      }
      while ( v16 );
    }
  }
  return v11;
}


================================================================================
Function: sub_680C530 (0x680C530)
================================================================================

__int64 __fastcall sub_680C530(__int64 a1, unsigned int a2, int a3, int a4, __int64 a5)
{
  _BYTE *v8; // x9
  unsigned int v9; // w15
  unsigned int v10; // w10
  unsigned int v11; // w14
  char *v12; // x9
  unsigned int v13; // w15
  unsigned int v14; // w10
  unsigned int v15; // w14
  __int64 v16; // x8
  __int64 v17; // x1
  __int64 v18; // x20
  __int64 v19; // x9
  __int64 v20; // x8
  __int64 v21; // x1
  void (__fastcall **v23)(_QWORD); // [xsp+0h] [xbp-230h] BYREF
  _BYTE *v24; // [xsp+8h] [xbp-228h]
  __int128 v25; // [xsp+10h] [xbp-220h]
  _BYTE v26[508]; // [xsp+20h] [xbp-210h] BYREF
  _BYTE v27[12]; // [xsp+21Ch] [xbp-14h] BYREF

  if ( *(_BYTE *)(a5 + 24) )
  {
    v23 = (void (__fastcall **)(_QWORD))&off_6C599D8;
    v24 = v26;
    v25 = xmmword_B03780;
    if ( a2 < 0x64 )
    {
      v8 = &v27[a3];
      v10 = a2;
      if ( a2 <= 9 )
      {
LABEL_6:
        *(v8 - 1) = v10 + 48;
LABEL_14:
        sub_53DDE58((unsigned __int64)v27, (__int64)&v27[a3], (__int64)&v23);
        if ( a4 >= 1 )
        {
          do
          {
            v16 = v25;
            v17 = v25 + 1;
            if ( *((_QWORD *)&v25 + 1) < (unsigned __int64)(v25 + 1) )
            {
              (*v23)(&v23);
              v16 = v25;
              v17 = v25 + 1;
            }
            --a4;
            *(_QWORD *)&v25 = v17;
            v24[v16] = 48;
          }
          while ( a4 );
        }
        v18 = sub_53DDAC4(a5, a1, v24, v25);
        if ( v24 != v26 )
          sub_65ECAF4();
        return v18;
      }
    }
    else
    {
      v8 = &v27[a3];
      do
      {
        v9 = a2 >> 4;
        v10 = a2 / 0x64;
        v11 = a2 % 0x64;
        a2 /= 0x64u;
        *((_WORD *)v8 - 1) = *(_WORD *)&a00010203040506_1[2 * v11];
        v8 -= 2;
      }
      while ( v9 > 0x270 );
      if ( v10 <= 9 )
        goto LABEL_6;
    }
    *((_WORD *)v8 - 1) = *(_WORD *)&a00010203040506_1[2 * v10];
    goto LABEL_14;
  }
  if ( a2 < 0x64 )
  {
    v12 = (char *)&v23 + a3;
    v14 = a2;
    if ( a2 <= 9 )
    {
LABEL_11:
      *(v12 - 1) = v14 + 48;
      goto LABEL_23;
    }
  }
  else
  {
    v12 = (char *)&v23 + a3;
    do
    {
      v13 = a2 >> 4;
      v14 = a2 / 0x64;
      v15 = a2 % 0x64;
      a2 /= 0x64u;
      *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v15];
      v12 -= 2;
    }
    while ( v13 > 0x270 );
    if ( v14 <= 9 )
      goto LABEL_11;
  }
  *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
LABEL_23:
  v18 = sub_53DDE58((unsigned __int64)&v23, (__int64)&v23 + a3, a1);
  if ( a4 >= 1 )
  {
    do
    {
      v20 = *(_QWORD *)(v18 + 16);
      v21 = v20 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v20 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v20 = *(_QWORD *)(v18 + 16);
        v21 = v20 + 1;
      }
      --a4;
      v19 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v21;
      *(_BYTE *)(v19 + v20) = 48;
    }
    while ( a4 );
  }
  return v18;
}


================================================================================
Function: sub_680C7D0 (0x680C7D0)
================================================================================

__int64 __fastcall sub_680C7D0(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x8
  char v14; // w24
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x22
  __int64 v18; // x21
  int v19; // w23
  unsigned int *v20; // x20
  char v21; // w9
  __int64 v22; // x10
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_174D7F4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_250EF44(a1, v10 >> v9, v8);
  v12 = **a5;
  if ( (_DWORD)v12 )
  {
    v13 = *(_QWORD *)(v7 + 16);
    v14 = byte_174D7FE[v12];
    v15 = v13 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v13 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v13 = *(_QWORD *)(v7 + 16);
      v15 = v13 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v13) = v14;
  }
  v17 = v10 - v11;
  v18 = sub_680C938(v7, *a5[1], *a5[2], *a5[3], *(unsigned __int8 *)a5[4], a5[5]);
  v19 = *a5[6];
  if ( v19 >= 1 )
  {
    v20 = a5[7];
    do
    {
      v23 = *(_QWORD *)(v18 + 16);
      v24 = v23 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v23 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v23 = *(_QWORD *)(v18 + 16);
        v24 = v23 + 1;
      }
      --v19;
      v21 = *(_BYTE *)v20;
      v22 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v24;
      *(_BYTE *)(v22 + v23) = v21;
    }
    while ( v19 );
  }
  result = v18;
  if ( v17 )
    return sub_250EF44(v18, v17, v8);
  return result;
}


================================================================================
Function: sub_680C938 (0x680C938)
================================================================================

__int64 __fastcall sub_680C938(__int64 a1, unsigned int a2, int a3, int a4, char a5, __int64 a6)
{
  __int64 v9; // x0
  __int64 v10; // x19
  __int64 v11; // x0
  _UNKNOWN **v13; // [xsp+0h] [xbp-230h] BYREF
  _BYTE *v14; // [xsp+8h] [xbp-228h]
  __int128 v15; // [xsp+10h] [xbp-220h]
  _BYTE v16[508]; // [xsp+20h] [xbp-210h] BYREF
  _BYTE v17[12]; // [xsp+21Ch] [xbp-14h] BYREF

  if ( *(_BYTE *)(a6 + 24) )
  {
    v13 = &off_6C599D8;
    v14 = v16;
    v15 = xmmword_B03780;
    v9 = sub_680C274((__int64)v17, a2, a3, a4, a5);
    sub_53DDE58((unsigned __int64)v17, v9, (__int64)&v13);
    sub_53DDAC4(a6, a1, v14, (unsigned int)a4);
    v10 = sub_53DDE58((unsigned __int64)&v14[a4], (__int64)&v14[v15], a1);
    if ( v14 != v16 )
      sub_65ECAF4();
  }
  else
  {
    v11 = sub_680C274((__int64)&v13, a2, a3, a4, a5);
    return sub_53DDE58((unsigned __int64)&v13, v11, a1);
  }
  return v10;
}


================================================================================
Function: sub_680CA60 (0x680CA60)
================================================================================

__int64 __fastcall sub_680CA60(unsigned int **a1, __int64 a2)
{
  __int64 v3; // x19
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w22
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x8
  unsigned int *v11; // x22
  __int64 v12; // x1
  char v13; // w9
  __int64 v14; // x8
  unsigned int *v15; // x22
  __int64 v16; // x1
  char v17; // w9
  int v18; // w22
  unsigned int *v19; // x23
  char v20; // w9
  __int64 v21; // x10
  __int64 v22; // x8
  __int64 v23; // x1
  unsigned int v24; // w10
  _BYTE *v25; // x1
  _BYTE *v26; // x9
  unsigned int v27; // w15
  unsigned int v28; // w11
  unsigned int v29; // w14
  _BYTE v31[12]; // [xsp+Ch] [xbp-14h] BYREF

  v3 = a2;
  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_174D7FE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))v3)(v3);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(v3 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = *(_QWORD *)(v3 + 16);
  v11 = a1[1];
  v12 = v10 + 1;
  if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v10 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v3)(v3);
    v10 = *(_QWORD *)(v3 + 16);
    v12 = v10 + 1;
  }
  v13 = *(_BYTE *)v11;
  *(_QWORD *)(v3 + 16) = v12;
  *(_BYTE *)(*(_QWORD *)(v3 + 8) + v10) = v13;
  if ( *(_BYTE *)a1[2] )
  {
    v14 = *(_QWORD *)(v3 + 16);
    v15 = a1[3];
    v16 = v14 + 1;
    if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v3)(v3);
      v14 = *(_QWORD *)(v3 + 16);
      v16 = v14 + 1;
    }
    v17 = *(_BYTE *)v15;
    *(_QWORD *)(v3 + 16) = v16;
    *(_BYTE *)(*(_QWORD *)(v3 + 8) + v14) = v17;
    v18 = *a1[4];
    if ( v18 >= 1 )
    {
      v19 = a1[1];
      do
      {
        v22 = *(_QWORD *)(v3 + 16);
        v23 = v22 + 1;
        if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v22 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v3)(v3);
          v22 = *(_QWORD *)(v3 + 16);
          v23 = v22 + 1;
        }
        --v18;
        v20 = *(_BYTE *)v19;
        v21 = *(_QWORD *)(v3 + 8);
        *(_QWORD *)(v3 + 16) = v23;
        *(_BYTE *)(v21 + v22) = v20;
      }
      while ( v18 );
    }
    v24 = *a1[5];
    v25 = &v31[*a1[6]];
    if ( v24 < 0x64 )
    {
      v26 = &v31[*a1[6]];
      v28 = *a1[5];
      if ( v24 <= 9 )
      {
LABEL_19:
        *(v26 - 1) = v28 + 48;
        return sub_53DDE58((unsigned __int64)v31, (__int64)v25, v3);
      }
    }
    else
    {
      v26 = &v31[*a1[6]];
      do
      {
        v27 = v24 >> 4;
        v28 = v24 / 0x64;
        v29 = v24 % 0x64;
        v24 /= 0x64u;
        *((_WORD *)v26 - 1) = *(_WORD *)&a00010203040506_1[2 * v29];
        v26 -= 2;
      }
      while ( v27 > 0x270 );
      if ( v28 <= 9 )
        goto LABEL_19;
    }
    *((_WORD *)v26 - 1) = *(_WORD *)&a00010203040506_1[2 * v28];
    return sub_53DDE58((unsigned __int64)v31, (__int64)v25, v3);
  }
  return v3;
}


================================================================================
Function: sub_680CC80 (0x680CC80)
================================================================================

__int64 __fastcall sub_680CC80(__int64 a1, long double a2)
{
  __int64 v3; // x21
  double v4; // d0
  __int64 v5; // x2
  const char *v6; // x9
  __int64 v8; // x1
  unsigned int v9; // [xsp+0h] [xbp-40h] BYREF
  const char *v10; // [xsp+8h] [xbp-38h]
  __int128 v11; // [xsp+10h] [xbp-30h] BYREF
  __int128 v12; // [xsp+20h] [xbp-20h] BYREF

  v3 = *(_QWORD *)&a2 >> 55;
  v12 = xmmword_AFF2B0;
  if ( (~*(_QWORD *)&a2 & 0x7FF0000000000000LL) != 0 )
  {
    if ( *(__int64 *)&a2 < 0 )
      *(double *)&a2 = -*(double *)&a2;
    *(_QWORD *)&v11 = sub_6807AA0(a2);
    *((_QWORD *)&v11 + 1) = v8;
    return sub_680CD84(a1, &v11, &v12, (v3 << 32) & 0x10000000000LL, 0LL);
  }
  else
  {
    v4 = fabs(*(double *)&a2);
    if ( (unsigned int)v3 < 0x100 )
      v5 = 3LL;
    else
      v5 = 4LL;
    v6 = "nan";
    if ( v4 == INFINITY )
      v6 = "inf";
    v11 = xmmword_AFF2B0;
    v9 = (unsigned int)v3 >> 8;
    v10 = v6;
    return sub_680B6FC(a1, &v11, v5, v5, &v9);
  }
}


================================================================================
Function: sub_680CD84 (0x680CD84)
================================================================================

__int64 __fastcall sub_680CD84(__int64 a1, unsigned __int64 *a2, unsigned int *a3, unsigned __int64 a4, __int64 *a5)
{
  unsigned __int64 *v6; // x21
  __int64 v8; // x15
  unsigned __int64 v9; // x28
  unsigned __int64 v10; // x25
  __int64 v11; // x9
  signed int v12; // w26
  int v13; // w19
  __int64 v14; // x22
  char v15; // w24
  __int64 *v17; // x21
  __int64 v18; // x2
  __int64 *v19; // x0
  __int64 v20; // x9
  int v21; // w8
  int v22; // w10
  bool v23; // cc
  int v24; // w9
  __int64 v25; // x10
  int v26; // w8
  __int64 v27; // x23
  __int64 v28; // x24
  __int64 v29; // x20
  __int64 v30; // x19
  unsigned __int8 *v31; // x9
  unsigned __int64 v32; // x11
  unsigned int v33; // w8
  int v34; // w10
  unsigned __int8 *v35; // x11
  __int64 v36; // x0
  unsigned int *v37; // x1
  int v38; // w12
  int v40; // w8
  char v41; // w12
  unsigned __int64 v42; // x11
  __int64 v43; // x9
  __int64 v44; // x13
  __int64 v45; // x12
  char *v46; // x20
  char v47; // w8
  unsigned __int64 v48; // x9
  bool v49; // cf
  unsigned __int64 v50; // x9
  unsigned __int64 v51; // x21
  __int64 v52; // x19
  unsigned __int8 *v54; // x9
  unsigned __int64 v55; // x11
  unsigned int v56; // w8
  int v57; // w10
  unsigned __int8 *v58; // x11
  __int64 v59; // x1
  int v60; // w12
  char v61; // w12
  unsigned __int64 v62; // x8
  unsigned __int64 v63; // x11
  char v64; // w9
  unsigned __int64 v65; // x8
  unsigned __int64 v66; // x22
  unsigned __int64 v67; // x21
  __int64 v68; // x0
  __int64 v69; // x0
  int v72; // w8
  int v74; // w9
  unsigned __int64 v75; // x13
  unsigned __int64 v76; // x8
  unsigned __int64 v77; // x8
  char v78; // w10
  int v80; // [xsp+8h] [xbp-98h] BYREF
  int v81; // [xsp+Ch] [xbp-94h] BYREF
  _BYTE v82[4]; // [xsp+10h] [xbp-90h] BYREF
  int v83; // [xsp+14h] [xbp-8Ch] BYREF
  _BYTE v84[4]; // [xsp+18h] [xbp-88h] BYREF
  int v85; // [xsp+1Ch] [xbp-84h] BYREF
  unsigned __int64 v86; // [xsp+20h] [xbp-80h] BYREF
  unsigned __int64 v87; // [xsp+28h] [xbp-78h] BYREF
  int *v88; // [xsp+30h] [xbp-70h] BYREF
  _BYTE *v89; // [xsp+38h] [xbp-68h]
  int *v90; // [xsp+40h] [xbp-60h]
  unsigned __int64 *v91; // [xsp+48h] [xbp-58h]
  int *v92; // [xsp+50h] [xbp-50h]
  __int64 *v93; // [xsp+58h] [xbp-48h]
  int *v94; // [xsp+60h] [xbp-40h]
  int *v95; // [xsp+68h] [xbp-38h]
  _BYTE *v96; // [xsp+70h] [xbp-30h]
  int v97; // [xsp+78h] [xbp-28h] BYREF
  unsigned __int64 v98; // [xsp+80h] [xbp-20h]
  unsigned __int8 *v99; // [xsp+88h] [xbp-18h]
  char v100; // [xsp+90h] [xbp-10h]

  v6 = a2;
  v8 = a1;
  v9 = HIDWORD(a4);
  v10 = *a2;
  v84[0] = 48;
  v86 = v10;
  v87 = a4;
  v11 = byte_102749E[__clz(v10 | 1) ^ 0x3F];
  v12 = v11 - (qword_10274E0[v11] > v10);
  v13 = BYTE5(a4);
  if ( BYTE5(a4) )
    v14 = (unsigned int)(v12 + 1);
  else
    v14 = (unsigned int)v12;
  v85 = v11 - (qword_10274E0[v11] > v10);
  v83 = BYTE5(a4);
  if ( (a4 & 0x2000000000000LL) != 0 )
  {
    if ( a5 )
    {
      v17 = a5;
      sub_683B82C((__int64 *)&v88, a5);
    }
    else
    {
      v17 = 0LL;
      sub_683B7A0(&v88);
    }
    v19 = sub_683BBD0((__int64 *)&v88, (__int64)&unk_79D7EA8, v18);
    v15 = (*(__int64 (__fastcall **)(__int64 *))(*v19 + 24))(v19);
    sub_683B844(&v88);
    v8 = a1;
    a5 = v17;
    v6 = a2;
  }
  else
  {
    v15 = 46;
  }
  v20 = *((unsigned int *)v6 + 2);
  v82[0] = v15;
  v21 = v12 + v20;
  if ( BYTE4(a4) != 1 )
  {
    if ( BYTE4(a4) || ((int)a4 <= 0 ? (v22 = 16) : (v22 = a4), v21 >= -3 ? (v23 = v21 <= v22) : (v23 = 0), v23) )
    {
      v81 = v12 + v20;
      if ( (v20 & 0x80000000) == 0 )
      {
        v26 = a4 - v21;
        v27 = v20 + v14;
        v80 = v26;
        if ( (v9 & 0x100000) != 0 )
        {
          v28 = v8;
          if ( v26 > 0 || (unsigned __int8)v9 == 2 )
          {
            if ( v26 < 1 )
              goto LABEL_68;
          }
          else
          {
            v26 = 1;
            v80 = 1;
          }
          v27 += (unsigned int)(v26 + 1);
        }
        else
        {
          v28 = v8;
        }
LABEL_68:
        sub_53DD748(&v97, a5, ((unsigned int)v9 >> 17) & 1);
        v54 = v99;
        if ( (v97 & 1) != 0 )
        {
          v55 = v98;
        }
        else
        {
          v54 = (unsigned __int8 *)&v97 + 1;
          v55 = (unsigned __int64)(unsigned __int8)v97 >> 1;
        }
        v56 = 0;
        if ( v100 )
        {
          v57 = 0;
          v58 = &v54[v55];
          v59 = v28;
          if ( v58 == v54 )
            goto LABEL_75;
LABEL_73:
          v60 = *v54;
          if ( (unsigned int)(v60 - 127) >= 0xFFFFFF82 )
          {
            ++v54;
            while ( 1 )
            {
              v57 += v60;
              if ( v57 >= v12 )
                break;
              ++v56;
              if ( v58 != v54 )
                goto LABEL_73;
LABEL_75:
              v60 = (char)*(v58 - 1);
            }
          }
        }
        else
        {
          v59 = v28;
        }
        v61 = *(_WORD *)((char *)a3 + 9);
        v62 = v27 + v56;
        v88 = &v83;
        v89 = &v86;
        v90 = &v85;
        v91 = v6;
        v63 = *a3;
        v92 = &v97;
        v93 = (__int64 *)&v87;
        v64 = byte_174D7F4[v61 & 0xF];
        v49 = v63 >= v62;
        v65 = v63 - v62;
        if ( v49 )
          v66 = v65;
        else
          v66 = 0LL;
        v67 = v66 >> v64;
        v94 = (int *)v82;
        v95 = &v80;
        v96 = v84;
        if ( v66 >> v64 )
          v59 = sub_250EF44(v59, v66 >> v64, (char *)a3 + 11);
        v68 = sub_680D6A8(&v88, v59);
        v52 = v68;
        if ( v66 == v67 )
          goto LABEL_101;
        v69 = sub_250EF44(v68, v66 - v67, (char *)a3 + 11);
LABEL_100:
        v52 = v69;
LABEL_101:
        if ( (v97 & 1) != 0 )
          sub_65ECAF4();
        return v52;
      }
      if ( v21 >= 1 )
      {
        v29 = v8;
        v80 = (a4 - v12) & ((int)((_DWORD)v9 << 11) >> 31);
        sub_53DD748(&v97, a5, ((unsigned int)v9 >> 17) & 1);
        v31 = v99;
        if ( (v97 & 1) != 0 )
        {
          v32 = v98;
        }
        else
        {
          v31 = (unsigned __int8 *)&v97 + 1;
          v32 = (unsigned __int64)(unsigned __int8)v97 >> 1;
        }
        v33 = 0;
        if ( v100 )
        {
          v34 = 0;
          v35 = &v31[v32];
          v36 = v29;
          v37 = a3;
          if ( v35 == v31 )
            goto LABEL_34;
LABEL_32:
          v38 = *v31;
          if ( (unsigned int)(v38 - 127) >= 0xFFFFFF82 )
          {
            ++v31;
            while ( 1 )
            {
              v34 += v38;
              if ( v34 >= v12 )
                break;
              ++v33;
              if ( v35 != v31 )
                goto LABEL_32;
LABEL_34:
              v38 = (char)*(v35 - 1);
            }
          }
        }
        else
        {
          v36 = v29;
          v37 = a3;
        }
        v88 = &v83;
        v89 = &v86;
        v90 = &v85;
        v91 = (unsigned __int64 *)&v81;
        v92 = (int *)v82;
        v93 = (__int64 *)&v97;
        v94 = &v80;
        v95 = (int *)v84;
        v30 = (((_DWORD)a4 - v12) & ((int)((_DWORD)v9 << 11) >> 31) & (unsigned int)~((int)((a4 - v12) & ((int)((_DWORD)v9 << 11) >> 31)) >> 31))
            + 1
            + v14;
        v69 = sub_680DA9C(v36, v37, v30 + v33, v30 + v33, &v88);
        goto LABEL_100;
      }
      if ( (int)a4 < -v21 && (int)a4 > -1 && v12 == 0 )
        v72 = a4;
      else
        v72 = -v21;
      v97 = v72;
      if ( v72 | v12 )
      {
        LOBYTE(v80) = 1;
      }
      else
      {
        LOBYTE(v80) = (v9 & 0x100000) != 0;
        if ( (v9 & 0x100000) == 0 )
        {
          v74 = 1;
          goto LABEL_107;
        }
      }
      v74 = 2;
LABEL_107:
      v75 = *a3;
      v76 = (unsigned int)(v74 + v72) + v14;
      v49 = v75 >= v76;
      v77 = v75 - v76;
      if ( !v49 )
        v77 = 0LL;
      v78 = byte_174D7F4[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v88 = &v83;
      v89 = v84;
      v46 = (char *)a3 + 11;
      v90 = &v80;
      v91 = (unsigned __int64 *)v82;
      v51 = v77 - (v77 >> v78);
      v92 = &v97;
      v93 = (__int64 *)&v86;
      v94 = &v85;
      if ( v77 >> v78 )
        v8 = sub_250EF44(v8, v77 >> v78, (char *)a3 + 11);
      v52 = sub_680DD2C(&v88, v8);
      if ( v51 )
        return sub_250EF44(v52, v51, v46);
      return v52;
    }
  }
  v24 = v21 - 1;
  if ( (v9 & 0x100000) != 0 )
  {
    v25 = ((_DWORD)a4 - v12) & (unsigned int)~(((int)a4 - v12) >> 31);
    v14 += v25;
  }
  else if ( v12 == 1 )
  {
    v15 = 0;
    LODWORD(v25) = 0;
    v82[0] = 0;
  }
  else
  {
    LODWORD(v25) = 0;
  }
  v23 = v21 <= 0;
  v40 = 1 - v21;
  if ( !v23 )
    v40 = v24;
  if ( (v9 & 0x10000) != 0 )
    v41 = 69;
  else
    v41 = 101;
  v42 = *a3;
  LODWORD(v88) = v13;
  v89 = (_BYTE *)v10;
  LODWORD(v90) = v12;
  BYTE4(v90) = v15;
  LODWORD(v91) = v25;
  BYTE4(v91) = 48;
  BYTE5(v91) = v41;
  LODWORD(v92) = v24;
  if ( (int)v42 < 1 )
    return sub_680D3A8(&v88, v8);
  v43 = 2LL;
  v44 = 3LL;
  if ( v15 )
    v45 = 3LL;
  else
    v45 = 2LL;
  if ( v40 > 999 )
    v44 = 4LL;
  if ( v40 > 99 )
    v43 = v44;
  v46 = (char *)a3 + 11;
  v47 = byte_174D7F4[*(_WORD *)((_BYTE *)a3 + 9) & 0xFLL];
  v48 = v14 + v43 + v45;
  v49 = v42 >= v48;
  v50 = v42 - v48;
  if ( !v49 )
    v50 = 0LL;
  v51 = v50 - (v50 >> v47);
  if ( v50 >> v47 )
    v8 = sub_250EF44(v8, v50 >> v47, (char *)a3 + 11);
  v52 = sub_680D3A8(&v88, v8);
  if ( v51 )
    return sub_250EF44(v52, v51, v46);
  return v52;
}


================================================================================
Function: sub_680D3A8 (0x680D3A8)
================================================================================

__int64 __fastcall sub_680D3A8(unsigned int *a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w22
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x0
  int v12; // w22
  __int64 v13; // x20
  __int64 v14; // x8
  char v15; // w22
  __int64 v16; // x1
  __int64 v17; // x9
  char v19; // w9
  __int64 v20; // x10
  __int64 v21; // x8
  __int64 v22; // x1
  _BYTE v23[24]; // [xsp+0h] [xbp-20h] BYREF

  v4 = *a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_174D7FE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64, __int64))a2)(a2, v8);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_680D504(v23, *((_QWORD *)a1 + 1), a1[4], 1LL, *((unsigned __int8 *)a1 + 20));
  v11 = sub_53DDE58((unsigned __int64)v23, v10, a2);
  v12 = a1[6];
  v13 = v11;
  if ( v12 >= 1 )
  {
    do
    {
      v21 = *(_QWORD *)(v13 + 16);
      v22 = v21 + 1;
      if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v21 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v13)(v13);
        v21 = *(_QWORD *)(v13 + 16);
        v22 = v21 + 1;
      }
      --v12;
      v19 = *((_BYTE *)a1 + 28);
      v20 = *(_QWORD *)(v13 + 8);
      *(_QWORD *)(v13 + 16) = v22;
      *(_BYTE *)(v20 + v21) = v19;
    }
    while ( v12 );
  }
  v14 = *(_QWORD *)(v13 + 16);
  v15 = *((_BYTE *)a1 + 29);
  v16 = v14 + 1;
  if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v14 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v13)(v13);
    v14 = *(_QWORD *)(v13 + 16);
    v16 = v14 + 1;
  }
  v17 = *(_QWORD *)(v13 + 8);
  *(_QWORD *)(v13 + 16) = v16;
  *(_BYTE *)(v17 + v14) = v15;
  return sub_680C0BC(a1[8], v13);
}


================================================================================
Function: sub_680D504 (0x680D504)
================================================================================

__int64 __fastcall sub_680D504(__int64 a1, unsigned __int64 a2, int a3, int a4, char a5)
{
  unsigned int v5; // w11
  __int64 result; // x0
  unsigned int v7; // w13
  __int64 v8; // x9
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x15
  char v11; // w12
  __int64 v12; // x9
  bool v13; // cc
  unsigned __int64 v14; // x11
  unsigned __int64 v15; // x14
  __int64 v16; // x8
  unsigned __int64 v17; // x9
  unsigned __int64 v18; // x13

  if ( !a5 )
  {
    result = a1 + a3;
    if ( a2 < 0x64 )
    {
      v16 = result;
      v17 = a2;
      if ( a2 <= 9 )
      {
LABEL_15:
        *(_BYTE *)(v16 - 1) = v17 + 48;
        return result;
      }
    }
    else
    {
      v16 = result;
      do
      {
        v13 = a2 >> 4 > 0x270;
        v17 = a2 / 0x64;
        v18 = a2 % 0x64;
        a2 /= 0x64uLL;
        *(_WORD *)(v16 - 2) = *(_WORD *)&a00010203040506_1[2 * v18];
        v16 -= 2LL;
      }
      while ( v13 );
      if ( v17 <= 9 )
        goto LABEL_15;
    }
    *(_WORD *)(v16 - 2) = *(_WORD *)&a00010203040506_1[2 * v17];
    return result;
  }
  v5 = a3 - a4;
  result = a1 + a3 + 1;
  if ( a3 - a4 < 2 )
  {
    v9 = a2;
    v8 = result;
    if ( (v5 & 1) == 0 )
      goto LABEL_7;
  }
  else
  {
    v7 = (v5 >> 1) + 1;
    v8 = result;
    do
    {
      --v7;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64uLL;
      *(_WORD *)(v8 - 2) = *(_WORD *)&a00010203040506_1[2 * v10];
      v8 -= 2LL;
    }
    while ( v7 > 1 );
    if ( (v5 & 1) == 0 )
      goto LABEL_7;
  }
  v11 = (v9 % 0xA) | 0x30;
  v9 /= 0xAuLL;
  *(_BYTE *)--v8 = v11;
LABEL_7:
  *(_BYTE *)(v8 - 1) = a5;
  v12 = v8 - 1;
  if ( v9 < 0x64 )
  {
    v14 = v9;
    if ( v9 <= 9 )
    {
LABEL_10:
      *(_BYTE *)(v12 - 1) = v14 + 48;
      return result;
    }
  }
  else
  {
    do
    {
      v13 = v9 >> 4 > 0x270;
      v14 = v9 / 0x64;
      v15 = v9 % 0x64;
      v9 /= 0x64uLL;
      *(_WORD *)(v12 - 2) = *(_WORD *)&a00010203040506_1[2 * v15];
      v12 -= 2LL;
    }
    while ( v13 );
    if ( v14 <= 9 )
      goto LABEL_10;
  }
  *(_WORD *)(v12 - 2) = *(_WORD *)&a00010203040506_1[2 * v14];
  return result;
}


================================================================================
Function: sub_680D6A8 (0x680D6A8)
================================================================================

__int64 __fastcall sub_680D6A8(unsigned int **a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x20
  __int64 v12; // x8
  unsigned int *v13; // x21
  __int64 v14; // x1
  char v15; // w9
  int v16; // w21
  unsigned int *v17; // x19
  char v18; // w9
  __int64 v19; // x10
  __int64 v20; // x8
  __int64 v21; // x1

  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_174D7FE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_680D7E4(a2, *(_QWORD *)a1[1], *a1[2], a1[3][2], a1[4]);
  v11 = v10;
  if ( (*((_BYTE *)a1[5] + 6) & 0x10) != 0 )
  {
    v12 = *(_QWORD *)(v10 + 16);
    v13 = a1[6];
    v14 = v12 + 1;
    if ( *(_QWORD *)(v10 + 24) < (unsigned __int64)(v12 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v10)(v10);
      v12 = *(_QWORD *)(v11 + 16);
      v14 = v12 + 1;
    }
    v15 = *(_BYTE *)v13;
    *(_QWORD *)(v11 + 16) = v14;
    *(_BYTE *)(*(_QWORD *)(v11 + 8) + v12) = v15;
    v16 = *a1[7];
    if ( v16 >= 1 )
    {
      v17 = a1[8];
      do
      {
        v20 = *(_QWORD *)(v11 + 16);
        v21 = v20 + 1;
        if ( *(_QWORD *)(v11 + 24) < (unsigned __int64)(v20 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v11)(v11);
          v20 = *(_QWORD *)(v11 + 16);
          v21 = v20 + 1;
        }
        --v16;
        v18 = *(_BYTE *)v17;
        v19 = *(_QWORD *)(v11 + 8);
        *(_QWORD *)(v11 + 16) = v21;
        *(_BYTE *)(v19 + v20) = v18;
      }
      while ( v16 );
    }
  }
  return v11;
}


================================================================================
Function: sub_680D7E4 (0x680D7E4)
================================================================================

__int64 __fastcall sub_680D7E4(__int64 a1, unsigned __int64 a2, int a3, int a4, __int64 a5)
{
  _BYTE *v8; // x9
  bool v9; // cc
  unsigned __int64 v10; // x10
  unsigned __int64 v11; // x14
  char *v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x14
  __int64 v15; // x8
  __int64 v16; // x1
  __int64 v17; // x20
  __int64 v18; // x9
  __int64 v19; // x8
  __int64 v20; // x1
  void (__fastcall **v22)(_QWORD); // [xsp+8h] [xbp-238h] BYREF
  _BYTE *v23; // [xsp+10h] [xbp-230h]
  __int128 v24; // [xsp+18h] [xbp-228h]
  _BYTE v25[508]; // [xsp+28h] [xbp-218h] BYREF
  _BYTE v26[20]; // [xsp+224h] [xbp-1Ch] BYREF

  if ( *(_BYTE *)(a5 + 24) )
  {
    v22 = (void (__fastcall **)(_QWORD))&off_6C599D8;
    v23 = v25;
    v24 = xmmword_B03780;
    if ( a2 < 0x64 )
    {
      v8 = &v26[a3];
      v10 = a2;
      if ( a2 <= 9 )
      {
LABEL_6:
        *(v8 - 1) = v10 + 48;
LABEL_14:
        sub_53DDE58((unsigned __int64)v26, (__int64)&v26[a3], (__int64)&v22);
        if ( a4 >= 1 )
        {
          do
          {
            v15 = v24;
            v16 = v24 + 1;
            if ( *((_QWORD *)&v24 + 1) < (unsigned __int64)(v24 + 1) )
            {
              (*v22)(&v22);
              v15 = v24;
              v16 = v24 + 1;
            }
            --a4;
            *(_QWORD *)&v24 = v16;
            v23[v15] = 48;
          }
          while ( a4 );
        }
        v17 = sub_53DDAC4(a5, a1, v23, v24);
        if ( v23 != v25 )
          sub_65ECAF4();
        return v17;
      }
    }
    else
    {
      v8 = &v26[a3];
      do
      {
        v9 = a2 >> 4 > 0x270;
        v10 = a2 / 0x64;
        v11 = a2 % 0x64;
        a2 /= 0x64uLL;
        *((_WORD *)v8 - 1) = *(_WORD *)&a00010203040506_1[2 * v11];
        v8 -= 2;
      }
      while ( v9 );
      if ( v10 <= 9 )
        goto LABEL_6;
    }
    *((_WORD *)v8 - 1) = *(_WORD *)&a00010203040506_1[2 * v10];
    goto LABEL_14;
  }
  if ( a2 < 0x64 )
  {
    v12 = (char *)&v22 + a3;
    v13 = a2;
    if ( a2 <= 9 )
    {
LABEL_11:
      *(v12 - 1) = v13 + 48;
      goto LABEL_23;
    }
  }
  else
  {
    v12 = (char *)&v22 + a3;
    do
    {
      v9 = a2 >> 4 > 0x270;
      v13 = a2 / 0x64;
      v14 = a2 % 0x64;
      a2 /= 0x64uLL;
      *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
      v12 -= 2;
    }
    while ( v9 );
    if ( v13 <= 9 )
      goto LABEL_11;
  }
  *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
LABEL_23:
  v17 = sub_53DDE58((unsigned __int64)&v22, (__int64)&v22 + a3, a1);
  if ( a4 >= 1 )
  {
    do
    {
      v19 = *(_QWORD *)(v17 + 16);
      v20 = v19 + 1;
      if ( *(_QWORD *)(v17 + 24) < (unsigned __int64)(v19 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v17)(v17);
        v19 = *(_QWORD *)(v17 + 16);
        v20 = v19 + 1;
      }
      --a4;
      v18 = *(_QWORD *)(v17 + 8);
      *(_QWORD *)(v17 + 16) = v20;
      *(_BYTE *)(v18 + v19) = 48;
    }
    while ( a4 );
  }
  return v17;
}


================================================================================
Function: sub_680DA9C (0x680DA9C)
================================================================================

__int64 __fastcall sub_680DA9C(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x8
  char v14; // w24
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x22
  __int64 v18; // x21
  int v19; // w23
  unsigned int *v20; // x20
  char v21; // w9
  __int64 v22; // x10
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_174D7F4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_250EF44(a1, v10 >> v9, v8);
  v12 = **a5;
  if ( (_DWORD)v12 )
  {
    v13 = *(_QWORD *)(v7 + 16);
    v14 = byte_174D7FE[v12];
    v15 = v13 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v13 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v13 = *(_QWORD *)(v7 + 16);
      v15 = v13 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v13) = v14;
  }
  v17 = v10 - v11;
  v18 = sub_680DC04(v7, *(_QWORD *)a5[1], *a5[2], *a5[3], *(unsigned __int8 *)a5[4], a5[5]);
  v19 = *a5[6];
  if ( v19 >= 1 )
  {
    v20 = a5[7];
    do
    {
      v23 = *(_QWORD *)(v18 + 16);
      v24 = v23 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v23 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v23 = *(_QWORD *)(v18 + 16);
        v24 = v23 + 1;
      }
      --v19;
      v21 = *(_BYTE *)v20;
      v22 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v24;
      *(_BYTE *)(v22 + v23) = v21;
    }
    while ( v19 );
  }
  result = v18;
  if ( v17 )
    return sub_250EF44(v18, v17, v8);
  return result;
}


================================================================================
Function: sub_680DC04 (0x680DC04)
================================================================================

__int64 __fastcall sub_680DC04(__int64 a1, unsigned __int64 a2, int a3, int a4, char a5, __int64 a6)
{
  __int64 v9; // x0
  __int64 v10; // x19
  __int64 v11; // x0
  _UNKNOWN **v13; // [xsp+8h] [xbp-238h] BYREF
  _BYTE *v14; // [xsp+10h] [xbp-230h]
  __int128 v15; // [xsp+18h] [xbp-228h]
  _BYTE v16[504]; // [xsp+28h] [xbp-218h] BYREF
  _BYTE v17[24]; // [xsp+220h] [xbp-20h] BYREF

  if ( *(_BYTE *)(a6 + 24) )
  {
    v13 = &off_6C599D8;
    v14 = v16;
    v15 = xmmword_B03780;
    v9 = sub_680D504((__int64)v17, a2, a3, a4, a5);
    sub_53DDE58((unsigned __int64)v17, v9, (__int64)&v13);
    sub_53DDAC4(a6, a1, v14, (unsigned int)a4);
    v10 = sub_53DDE58((unsigned __int64)&v14[a4], (__int64)&v14[v15], a1);
    if ( v14 != v16 )
      sub_65ECAF4();
  }
  else
  {
    v11 = sub_680D504((__int64)&v13, a2, a3, a4, a5);
    return sub_53DDE58((unsigned __int64)&v13, v11, a1);
  }
  return v10;
}


================================================================================
Function: sub_680DD2C (0x680DD2C)
================================================================================

__int64 __fastcall sub_680DD2C(unsigned int **a1, __int64 a2)
{
  __int64 v3; // x19
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w22
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x8
  unsigned int *v11; // x22
  __int64 v12; // x1
  char v13; // w9
  __int64 v14; // x8
  unsigned int *v15; // x22
  __int64 v16; // x1
  char v17; // w9
  int v18; // w22
  unsigned int *v19; // x23
  char v20; // w9
  __int64 v21; // x10
  __int64 v22; // x8
  __int64 v23; // x1
  unsigned __int64 v24; // x10
  _BYTE *v25; // x1
  _BYTE *v26; // x9
  bool v27; // cc
  unsigned __int64 v28; // x11
  unsigned __int64 v29; // x14
  _BYTE v31[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v3 = a2;
  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_174D7FE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))v3)(v3);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(v3 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = *(_QWORD *)(v3 + 16);
  v11 = a1[1];
  v12 = v10 + 1;
  if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v10 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v3)(v3);
    v10 = *(_QWORD *)(v3 + 16);
    v12 = v10 + 1;
  }
  v13 = *(_BYTE *)v11;
  *(_QWORD *)(v3 + 16) = v12;
  *(_BYTE *)(*(_QWORD *)(v3 + 8) + v10) = v13;
  if ( *(_BYTE *)a1[2] )
  {
    v14 = *(_QWORD *)(v3 + 16);
    v15 = a1[3];
    v16 = v14 + 1;
    if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v3)(v3);
      v14 = *(_QWORD *)(v3 + 16);
      v16 = v14 + 1;
    }
    v17 = *(_BYTE *)v15;
    *(_QWORD *)(v3 + 16) = v16;
    *(_BYTE *)(*(_QWORD *)(v3 + 8) + v14) = v17;
    v18 = *a1[4];
    if ( v18 >= 1 )
    {
      v19 = a1[1];
      do
      {
        v22 = *(_QWORD *)(v3 + 16);
        v23 = v22 + 1;
        if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v22 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v3)(v3);
          v22 = *(_QWORD *)(v3 + 16);
          v23 = v22 + 1;
        }
        --v18;
        v20 = *(_BYTE *)v19;
        v21 = *(_QWORD *)(v3 + 8);
        *(_QWORD *)(v3 + 16) = v23;
        *(_BYTE *)(v21 + v22) = v20;
      }
      while ( v18 );
    }
    v24 = *(_QWORD *)a1[5];
    v25 = &v31[*a1[6]];
    if ( v24 < 0x64 )
    {
      v26 = &v31[*a1[6]];
      v28 = *(_QWORD *)a1[5];
      if ( v24 <= 9 )
      {
LABEL_19:
        *(v26 - 1) = v28 + 48;
        return sub_53DDE58((unsigned __int64)v31, (__int64)v25, v3);
      }
    }
    else
    {
      v26 = &v31[*a1[6]];
      do
      {
        v27 = v24 >> 4 > 0x270;
        v28 = v24 / 0x64;
        v29 = v24 % 0x64;
        v24 /= 0x64uLL;
        *((_WORD *)v26 - 1) = *(_WORD *)&a00010203040506_1[2 * v29];
        v26 -= 2;
      }
      while ( v27 );
      if ( v28 <= 9 )
        goto LABEL_19;
    }
    *((_WORD *)v26 - 1) = *(_WORD *)&a00010203040506_1[2 * v28];
    return sub_53DDE58((unsigned __int64)v31, (__int64)v25, v3);
  }
  return v3;
}


================================================================================
Function: sub_680DF58 (0x680DF58)
================================================================================

__int64 __fastcall sub_680DF58(__int64 a1, _UNKNOWN **a2, _BYTE *a3, __int64 a4, long double a5)
{
  __int64 v7; // x0
  long double v8; // q0
  char v9; // w22
  unsigned int v10; // w21
  unsigned int v11; // w8
  int v12; // w9
  unsigned int v13; // w24
  int v14; // w0
  __int64 v15; // x8
  char v16; // w22
  __int64 v17; // x1
  __int64 v18; // x9
  char v19; // w8
  __int64 v20; // x0
  const char *v21; // x21
  const char *v22; // x22
  const char *v23; // x9
  __int64 v24; // x2
  __int64 v25; // x19
  bool v26; // cc
  unsigned int v27; // w22
  __int64 v28; // x24
  unsigned int v29; // w0
  long double v32; // [xsp+20h] [xbp-280h]
  long double v33; // [xsp+30h] [xbp-270h]
  long double v34; // [xsp+40h] [xbp-260h]
  _BYTE *v35; // [xsp+60h] [xbp-240h] BYREF
  unsigned __int64 v36; // [xsp+68h] [xbp-238h]
  _UNKNOWN **v37; // [xsp+70h] [xbp-230h] BYREF
  _BYTE *v38; // [xsp+78h] [xbp-228h]
  __int128 v39; // [xsp+80h] [xbp-220h]
  _BYTE v40[504]; // [xsp+90h] [xbp-210h] BYREF
  _UNKNOWN **v41; // [xsp+288h] [xbp-18h] BYREF
  unsigned __int64 v42; // [xsp+290h] [xbp-10h]

  v41 = a2;
  v42 = (unsigned __int64)a3;
  v7 = sub_680E2C0(&v41, &v37);
  v8 = a5;
  v9 = BYTE1(v42);
  v10 = v7;
  v11 = HIDWORD(v7) & 0xFFFF00FF;
  if ( (*((_QWORD *)&a5 + 1) & 0x8000000000000000LL) != 0 )
  {
    v34 = a5;
    v13 = v11 | 0x100;
    HIBYTE(v34) = HIBYTE(a5) ^ 0x80;
    v8 = v34;
  }
  else
  {
    v12 = (16 * *(unsigned __int16 *)((char *)&v42 + 1)) & 0x700;
    if ( v12 == 256 )
      v12 = 0;
    v13 = v11 | v12;
  }
  v32 = v8;
  v33 = v8;
  HIBYTE(v33) = HIBYTE(v8) & 0x7F;
  v14 = ((__int64 (*)(void))sub_6865770)();
  if ( (unsigned int)sub_6865848(v33, *(long double *)&xmmword_B02280) == 0 && v14 != 0 )
  {
    if ( (v9 & 0xF) == 4 && (v13 & 0xFF00) != 0 )
    {
      v15 = *(_QWORD *)(a1 + 16);
      v16 = byte_174D7FE[BYTE1(v13)];
      v17 = v15 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v15 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v15 = *(_QWORD *)(a1 + 16);
        v17 = v15 + 1;
      }
      v18 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v17;
      v13 &= 0xFFFF00FF;
      *(_BYTE *)(v18 + v15) = v16;
      if ( (_DWORD)v41 )
        LODWORD(v41) = (_DWORD)v41 - 1;
    }
    v37 = &off_6C599D8;
    v38 = v40;
    v39 = xmmword_B03780;
    if ( (unsigned __int8)v13 == 3 )
    {
      if ( (v13 & 0xFF00) != 0 )
      {
        v19 = byte_174D7FE[BYTE1(v13)];
        *(_QWORD *)&v39 = 1LL;
        v40[0] = v19;
      }
      sub_6808794(HIDWORD(v41), v10 | ((unsigned __int64)v13 << 32), &v37, v32);
      v35 = v38;
      v36 = v39;
      v20 = sub_680E378(a1, &v41, v39, v39, &v35);
    }
    else
    {
      if ( (_BYTE)v42 )
        v26 = SHIDWORD(v41) <= -1;
      else
        v26 = 0;
      if ( v26 )
        v27 = 6;
      else
        v27 = HIDWORD(v41);
      if ( (unsigned __int8)v13 == 1 )
      {
        if ( v27 == 0x7FFFFFFF )
          sub_6806F24((__int64)"number is too big");
        ++v27;
      }
      v28 = v13 | 0x80000;
      v29 = sub_680A5BC(v27, v10 | ((unsigned __int64)(unsigned int)v28 << 32), &v37, v32);
      v35 = v38;
      v36 = __PAIR64__(v29, v39);
      v20 = sub_680E57C(a1, &v35, &v41, (v28 << 32) | v27, a4);
    }
    v25 = v20;
    if ( v38 != v40 )
      sub_65ECAF4();
  }
  else
  {
    v37 = v41;
    v38 = (_BYTE *)v42;
    if ( (v42 & 0xFF000000FF000000LL) == 0x100000030000000LL )
      BYTE3(v38) = 32;
    if ( (v13 & 0x10000) != 0 )
      v21 = "INF";
    else
      v21 = "inf";
    if ( (v13 & 0x10000) != 0 )
      v22 = "NAN";
    else
      v22 = "nan";
    if ( (unsigned int)sub_6865770(v33, *(long double *)&xmmword_B02280) )
      v23 = v22;
    else
      v23 = v21;
    if ( BYTE1(v13) )
      v24 = 4LL;
    else
      v24 = 3LL;
    LODWORD(v35) = BYTE1(v13);
    v36 = (unsigned __int64)v23;
    return sub_680B6FC(a1, &v37, v24, v24, &v35);
  }
  return v25;
}


================================================================================
Function: sub_680E2C0 (0x680E2C0)
================================================================================

__int64 __fastcall sub_680E2C0(__int64 a1)
{
  unsigned int v1; // w8
  int v2; // w9
  __int64 v3; // x8

  v1 = *(unsigned __int16 *)(a1 + 9);
  v2 = (v1 >> 7) & 1;
  v3 = (((v1 >> 8) & 1) << 17) & 0xFFEFFFFF | (v2 << 20);
  switch ( *(_BYTE *)(a1 + 8) )
  {
    case 0:
      return v3 << 32;
    case 7:
      goto LABEL_3;
    case 8:
      LODWORD(v3) = v3 | 0x10000;
LABEL_3:
      v3 = v3 & 0x1FFF00 | 3;
      return v3 << 32;
    case 9:
      goto LABEL_5;
    case 0xA:
      LODWORD(v3) = v3 | 0x10000;
LABEL_5:
      v3 = v3 & 0xFFF00 | (((*(_DWORD *)(a1 + 4) != 0) | (unsigned int)v2) << 20) | 1;
      return v3 << 32;
    case 0xB:
      goto LABEL_7;
    case 0xC:
      LODWORD(v3) = v3 | 0x10000;
LABEL_7:
      v3 = v3 & 0xFFF00 | (((*(_DWORD *)(a1 + 4) != 0) | (unsigned int)v2) << 20) | 2;
      return v3 << 32;
    case 0xD:
      goto LABEL_9;
    case 0xE:
      LODWORD(v3) = v3 | 0x10000;
LABEL_9:
      v3 &= 0x1FFF00u;
      return v3 << 32;
    default:
      sub_6806F24((__int64)"invalid type specifier");
  }
}


================================================================================
Function: sub_680E378 (0x680E378)
================================================================================

__int64 __fastcall sub_680E378(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 *a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x19
  _BYTE *v8; // x20
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x21
  unsigned __int64 v12; // x8
  __int64 v13; // x21
  unsigned __int64 v14; // x22
  __int64 v15; // x10
  __int64 v16; // x23
  __int64 v17; // x24
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x12
  unsigned __int64 v20; // x8
  __int64 v21; // x11
  _BYTE *v22; // x9
  char *v23; // x13
  unsigned __int64 v24; // x14
  __int64 v25; // x15
  _OWORD *v26; // x13
  __int128 *v27; // x14
  unsigned __int64 v28; // x16
  __int128 v29; // q0
  __int128 v30; // q1
  __int64 *v31; // x16
  _QWORD *v32; // x11
  __int64 v33; // x15
  __int64 v34; // t1
  char v35; // t1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_174D7F4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_250EF44(a1, v10 >> v9, v8);
  v12 = a5[1];
  v13 = v10 - v11;
  if ( v12 )
  {
    v14 = *a5;
    v15 = *(_QWORD *)(v7 + 16);
    v16 = v14 + v12;
    v17 = v12 + v14;
    do
    {
      v18 = *(_QWORD *)(v7 + 24);
      if ( v18 < v16 - v14 + v15 )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v15 = *(_QWORD *)(v7 + 16);
        v18 = *(_QWORD *)(v7 + 24);
      }
      v19 = v18 - v15;
      if ( v18 - v15 >= v16 - v14 )
        v20 = v16 - v14;
      else
        v20 = v18 - v15;
      if ( !v20 )
        goto LABEL_9;
      v21 = *(_QWORD *)(v7 + 8);
      v22 = (_BYTE *)(v21 + v15);
      if ( v20 >= 8 )
      {
        if ( (unsigned __int64)v22 >= v14 + v20 || (v24 = v20, v23 = (char *)v14, v14 >= v21 + v15 + v20) )
        {
          if ( v20 < 0x20 )
          {
            v25 = 0LL;
LABEL_26:
            v31 = (__int64 *)(v14 + v25);
            if ( v17 - v14 < v19 )
              v19 = v17 - v14;
            v32 = (_QWORD *)(v21 + v15 + v25);
            v23 = (char *)(v14 + (v19 & 0xFFFFFFFFFFFFFFF8LL));
            v22 += v19 & 0xFFFFFFFFFFFFFFF8LL;
            v24 = v20 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            v33 = v25 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v34 = *v31++;
              v33 += 8LL;
              *v32++ = v34;
            }
            while ( v33 );
            if ( v19 == (v19 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_8;
            goto LABEL_33;
          }
          v25 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          v26 = (_OWORD *)(v21 + v15 + 16);
          v27 = (__int128 *)(v14 + 16);
          v28 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v29 = *(v27 - 1);
            v30 = *v27;
            v27 += 2;
            v28 -= 32LL;
            *(v26 - 1) = v29;
            *v26 = v30;
            v26 += 2;
          }
          while ( v28 );
          if ( v20 == v25 )
            goto LABEL_8;
          if ( (v20 & 0x18) != 0 )
            goto LABEL_26;
          v24 = v20 & 0x1F;
          v22 += v25;
          v23 = (char *)(v14 + v25);
        }
      }
      else
      {
        v23 = (char *)v14;
        v24 = v20;
      }
      do
      {
LABEL_33:
        v35 = *v23++;
        --v24;
        *v22++ = v35;
      }
      while ( v24 );
LABEL_8:
      v15 = *(_QWORD *)(v7 + 16);
LABEL_9:
      v15 += v20;
      v14 += v20;
      *(_QWORD *)(v7 + 16) = v15;
    }
    while ( v14 != v16 );
  }
  result = v7;
  if ( v13 )
    return sub_250EF44(v7, v13, v8);
  return result;
}


================================================================================
Function: sub_680E57C (0x680E57C)
================================================================================

__int64 __fastcall sub_680E57C(__int64 a1, __int64 a2, unsigned int *a3, unsigned __int64 a4, __int64 *a5)
{
  __int64 v8; // x15
  unsigned __int64 v9; // x28
  signed int v10; // w26
  int v11; // w19
  _BYTE *v12; // x25
  __int64 v13; // x14
  char v14; // w24
  __int64 *v16; // x22
  __int64 v17; // x2
  __int64 *v18; // x0
  __int64 v19; // x9
  int v20; // w8
  int v21; // w10
  int v22; // w8
  __int64 v23; // x23
  __int64 v24; // x24
  int v25; // w9
  __int64 v26; // x10
  __int64 v27; // x20
  __int64 v28; // x19
  unsigned __int8 *v29; // x9
  unsigned __int64 v30; // x11
  unsigned int v31; // w8
  int v32; // w10
  unsigned __int8 *v33; // x11
  __int64 v34; // x0
  unsigned int *v35; // x1
  int v36; // w12
  int v37; // w8
  char v38; // w12
  unsigned __int64 v39; // x11
  __int64 v40; // x9
  __int64 v41; // x13
  __int64 v42; // x12
  _BYTE *v43; // x20
  char v44; // w8
  unsigned __int64 v45; // x9
  bool v46; // cf
  unsigned __int64 v47; // x9
  __int64 v48; // x21
  __int64 v49; // x19
  unsigned __int8 *v51; // x9
  unsigned __int64 v52; // x11
  unsigned int v53; // w8
  int v54; // w10
  unsigned __int8 *v55; // x11
  __int64 v56; // x1
  int v57; // w12
  char v58; // w12
  unsigned __int64 v59; // x8
  unsigned __int64 v60; // x11
  char v61; // w9
  unsigned __int64 v62; // x8
  unsigned __int64 v63; // x22
  unsigned __int64 v64; // x21
  __int64 v65; // x0
  __int64 v66; // x0
  bool v67; // cc
  int v69; // w8
  int v71; // w9
  unsigned __int64 v72; // x13
  unsigned __int64 v73; // x8
  unsigned __int64 v74; // x8
  char v75; // w10
  __int64 v76; // [xsp+0h] [xbp-A0h]
  int v77; // [xsp+8h] [xbp-98h] BYREF
  int v78; // [xsp+Ch] [xbp-94h] BYREF
  _BYTE v79[4]; // [xsp+10h] [xbp-90h] BYREF
  int v80; // [xsp+14h] [xbp-8Ch] BYREF
  _BYTE v81[4]; // [xsp+18h] [xbp-88h] BYREF
  int v82; // [xsp+1Ch] [xbp-84h] BYREF
  _BYTE *v83; // [xsp+20h] [xbp-80h] BYREF
  unsigned __int64 v84; // [xsp+28h] [xbp-78h] BYREF
  int *v85; // [xsp+30h] [xbp-70h] BYREF
  _BYTE *v86; // [xsp+38h] [xbp-68h]
  int *v87; // [xsp+40h] [xbp-60h]
  int *v88; // [xsp+48h] [xbp-58h]
  int *v89; // [xsp+50h] [xbp-50h]
  int *v90; // [xsp+58h] [xbp-48h]
  int *v91; // [xsp+60h] [xbp-40h]
  int *v92; // [xsp+68h] [xbp-38h]
  _BYTE *v93; // [xsp+70h] [xbp-30h]
  int v94; // [xsp+78h] [xbp-28h] BYREF
  unsigned __int64 v95; // [xsp+80h] [xbp-20h]
  unsigned __int8 *v96; // [xsp+88h] [xbp-18h]
  char v97; // [xsp+90h] [xbp-10h]

  v8 = a1;
  v9 = HIDWORD(a4);
  v10 = *(_DWORD *)(a2 + 8);
  v11 = BYTE5(a4);
  v12 = *(_BYTE **)a2;
  v81[0] = 48;
  if ( BYTE5(a4) )
    v13 = (unsigned int)(v10 + 1);
  else
    v13 = (unsigned int)v10;
  v82 = v10;
  v83 = v12;
  v84 = a4;
  v80 = BYTE5(a4);
  if ( (a4 & 0x2000000000000LL) != 0 )
  {
    v76 = v13;
    if ( a5 )
    {
      v16 = a5;
      sub_683B82C((__int64 *)&v85, a5);
    }
    else
    {
      v16 = 0LL;
      sub_683B7A0(&v85);
    }
    v18 = sub_683BBD0((__int64 *)&v85, (__int64)&unk_79D7EA8, v17);
    v14 = (*(__int64 (__fastcall **)(__int64 *))(*v18 + 24))(v18);
    sub_683B844(&v85);
    v8 = a1;
    v13 = v76;
    a5 = v16;
  }
  else
  {
    v14 = 46;
  }
  v19 = *(unsigned int *)(a2 + 12);
  v79[0] = v14;
  v20 = v10 + v19;
  if ( BYTE4(a4) != 1 )
  {
    if ( BYTE4(a4) || ((int)a4 <= 0 ? (v21 = 16) : (v21 = a4), v20 >= -3 && v20 <= v21) )
    {
      v78 = v10 + v19;
      if ( (v19 & 0x80000000) == 0 )
      {
        v22 = a4 - v20;
        v23 = v19 + v13;
        v77 = v22;
        if ( (v9 & 0x100000) == 0 )
        {
          v24 = v8;
LABEL_63:
          sub_53DD748(&v94, a5, ((unsigned int)v9 >> 17) & 1);
          v51 = v96;
          if ( (v94 & 1) != 0 )
          {
            v52 = v95;
          }
          else
          {
            v51 = (unsigned __int8 *)&v94 + 1;
            v52 = (unsigned __int64)(unsigned __int8)v94 >> 1;
          }
          v53 = 0;
          if ( v97 )
          {
            v54 = 0;
            v55 = &v51[v52];
            v56 = v24;
            if ( v55 == v51 )
              goto LABEL_70;
LABEL_68:
            v57 = *v51;
            if ( (unsigned int)(v57 - 127) >= 0xFFFFFF82 )
            {
              ++v51;
              while ( 1 )
              {
                v54 += v57;
                if ( v54 >= v10 )
                  break;
                ++v53;
                if ( v55 != v51 )
                  goto LABEL_68;
LABEL_70:
                v57 = (char)*(v55 - 1);
              }
            }
          }
          else
          {
            v56 = v24;
          }
          v58 = *(_WORD *)((char *)a3 + 9);
          v59 = v23 + v53;
          v85 = &v80;
          v86 = &v83;
          v87 = &v82;
          v88 = (int *)a2;
          v60 = *a3;
          v89 = &v94;
          v90 = (int *)&v84;
          v61 = byte_174D7F4[v58 & 0xF];
          v46 = v60 >= v59;
          v62 = v60 - v59;
          if ( v46 )
            v63 = v62;
          else
            v63 = 0LL;
          v64 = v63 >> v61;
          v91 = (int *)v79;
          v92 = &v77;
          v93 = v81;
          if ( v63 >> v61 )
            v56 = sub_250EF44(v56, v63 >> v61, (_BYTE *)a3 + 11);
          v65 = sub_680EE7C(&v85, v56);
          v49 = v65;
          if ( v63 == v64 )
            goto LABEL_96;
          v66 = sub_250EF44(v65, v63 - v64, (_BYTE *)a3 + 11);
LABEL_95:
          v49 = v66;
LABEL_96:
          if ( (v94 & 1) != 0 )
            sub_65ECAF4();
          return v49;
        }
        if ( v22 > 0 || (unsigned __int8)v9 == 2 )
        {
          v24 = v8;
          if ( v22 < 1 )
            goto LABEL_63;
        }
        else
        {
          v22 = 1;
          v24 = v8;
          v77 = 1;
        }
        v23 += (unsigned int)(v22 + 1);
        goto LABEL_63;
      }
      if ( v20 >= 1 )
      {
        v27 = v8;
        v77 = (a4 - v10) & ((int)((_DWORD)v9 << 11) >> 31);
        v28 = (v77 & (unsigned int)~(v77 >> 31)) + 1 + v13;
        sub_53DD748(&v94, a5, ((unsigned int)v9 >> 17) & 1);
        v29 = v96;
        if ( (v94 & 1) != 0 )
        {
          v30 = v95;
        }
        else
        {
          v29 = (unsigned __int8 *)&v94 + 1;
          v30 = (unsigned __int64)(unsigned __int8)v94 >> 1;
        }
        v31 = 0;
        if ( v97 )
        {
          v32 = 0;
          v33 = &v29[v30];
          v34 = v27;
          v35 = a3;
          if ( v33 == v29 )
            goto LABEL_32;
LABEL_30:
          v36 = *v29;
          if ( (unsigned int)(v36 - 127) >= 0xFFFFFF82 )
          {
            ++v29;
            while ( 1 )
            {
              v32 += v36;
              if ( v32 >= v10 )
                break;
              ++v31;
              if ( v33 != v29 )
                goto LABEL_30;
LABEL_32:
              v36 = (char)*(v33 - 1);
            }
          }
        }
        else
        {
          v34 = v27;
          v35 = a3;
        }
        v85 = &v80;
        v86 = &v83;
        v87 = &v82;
        v88 = &v78;
        v89 = (int *)v79;
        v90 = &v94;
        v91 = &v77;
        v92 = (int *)v81;
        v66 = sub_680F3F0(v34, v35, v28 + v31, v28 + v31, &v85);
        goto LABEL_95;
      }
      v67 = (int)a4 >= -v20 || (int)a4 <= -1;
      if ( !v67 && v10 == 0 )
        v69 = a4;
      else
        v69 = -v20;
      v94 = v69;
      if ( v69 | v10 )
      {
        LOBYTE(v77) = 1;
      }
      else
      {
        LOBYTE(v77) = (v9 & 0x100000) != 0;
        if ( (v9 & 0x100000) == 0 )
        {
          v71 = 1;
          goto LABEL_102;
        }
      }
      v71 = 2;
LABEL_102:
      v72 = *a3;
      v73 = (unsigned int)(v71 + v69) + v13;
      v46 = v72 >= v73;
      v74 = v72 - v73;
      if ( !v46 )
        v74 = 0LL;
      v75 = byte_174D7F4[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v85 = &v80;
      v86 = v81;
      v43 = (char *)a3 + 11;
      v87 = &v77;
      v88 = (int *)v79;
      v48 = v74 - (v74 >> v75);
      v89 = &v94;
      v90 = (int *)&v83;
      v91 = &v82;
      if ( v74 >> v75 )
        v8 = sub_250EF44(v8, v74 >> v75, (_BYTE *)a3 + 11);
      v49 = sub_680F740(&v85, v8);
      if ( !v48 )
        return v49;
      return sub_250EF44(v49, v48, v43);
    }
  }
  v25 = v20 - 1;
  if ( (v9 & 0x100000) != 0 )
  {
    v26 = ((_DWORD)a4 - v10) & (unsigned int)~(((int)a4 - v10) >> 31);
    v13 += v26;
  }
  else if ( v10 == 1 )
  {
    v14 = 0;
    LODWORD(v26) = 0;
    v79[0] = 0;
  }
  else
  {
    LODWORD(v26) = 0;
  }
  v67 = v20 <= 0;
  v37 = 1 - v20;
  if ( !v67 )
    v37 = v25;
  if ( (v9 & 0x10000) != 0 )
    v38 = 69;
  else
    v38 = 101;
  v39 = *a3;
  LODWORD(v85) = v11;
  v86 = v12;
  LODWORD(v87) = v10;
  BYTE4(v87) = v14;
  LODWORD(v88) = v26;
  BYTE4(v88) = 48;
  BYTE5(v88) = v38;
  LODWORD(v89) = v25;
  if ( (int)v39 < 1 )
    return sub_680EB80(&v85, v8);
  v40 = 2LL;
  v41 = 3LL;
  if ( v14 )
    v42 = 3LL;
  else
    v42 = 2LL;
  if ( v37 > 999 )
    v41 = 4LL;
  if ( v37 > 99 )
    v40 = v41;
  v43 = (char *)a3 + 11;
  v44 = byte_174D7F4[*(_WORD *)((_BYTE *)a3 + 9) & 0xFLL];
  v45 = v13 + v40 + v42;
  v46 = v39 >= v45;
  v47 = v39 - v45;
  if ( !v46 )
    v47 = 0LL;
  v48 = v47 - (v47 >> v44);
  if ( v47 >> v44 )
    v8 = sub_250EF44(v8, v47 >> v44, (_BYTE *)a3 + 11);
  v49 = sub_680EB80(&v85, v8);
  if ( v48 )
    return sub_250EF44(v49, v48, v43);
  return v49;
}


================================================================================
Function: sub_680EB80 (0x680EB80)
================================================================================

__int64 __fastcall sub_680EB80(unsigned int *a1, __int64 a2)
{
  __int64 v3; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  unsigned __int64 v10; // x21
  __int64 v11; // x23
  int v12; // w24
  __int64 v13; // x0
  __int64 v14; // x20
  __int64 v15; // x9
  __int64 v16; // x1
  int v17; // w21
  __int64 v18; // x8
  char v19; // w21
  __int64 v20; // x1
  __int64 v21; // x9
  char v23; // w9
  __int64 v24; // x10
  __int64 v25; // x8
  __int64 v26; // x1

  v3 = *a1;
  if ( (_DWORD)v3 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_174D7FE[v3];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = *((_QWORD *)a1 + 1);
  v11 = (int)a1[4];
  v12 = *((unsigned __int8 *)a1 + 20);
  v13 = sub_680ECFC(v10, v10 + 1, a2);
  v14 = v13;
  if ( v12 )
  {
    v15 = *(_QWORD *)(v13 + 16);
    v16 = v15 + 1;
    if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v15 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v13)(v13);
      v15 = *(_QWORD *)(v14 + 16);
      v16 = v15 + 1;
    }
    *(_QWORD *)(v14 + 16) = v16;
    *(_BYTE *)(*(_QWORD *)(v14 + 8) + v15) = v12;
    v14 = sub_680ECFC(v10 + 1, v10 + v11, v14);
  }
  v17 = a1[6];
  if ( v17 >= 1 )
  {
    do
    {
      v25 = *(_QWORD *)(v14 + 16);
      v26 = v25 + 1;
      if ( *(_QWORD *)(v14 + 24) < (unsigned __int64)(v25 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v14)(v14);
        v25 = *(_QWORD *)(v14 + 16);
        v26 = v25 + 1;
      }
      --v17;
      v23 = *((_BYTE *)a1 + 28);
      v24 = *(_QWORD *)(v14 + 8);
      *(_QWORD *)(v14 + 16) = v26;
      *(_BYTE *)(v24 + v25) = v23;
    }
    while ( v17 );
  }
  v18 = *(_QWORD *)(v14 + 16);
  v19 = *((_BYTE *)a1 + 29);
  v20 = v18 + 1;
  if ( *(_QWORD *)(v14 + 24) < (unsigned __int64)(v18 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v14)(v14);
    v18 = *(_QWORD *)(v14 + 16);
    v20 = v18 + 1;
  }
  v21 = *(_QWORD *)(v14 + 8);
  *(_QWORD *)(v14 + 16) = v20;
  *(_BYTE *)(v21 + v18) = v19;
  return sub_680C0BC(a1[8], v14);
}


================================================================================
Function: sub_680ECFC (0x680ECFC)
================================================================================

__int64 __fastcall sub_680ECFC(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // x21
  __int64 v6; // x10
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x12
  unsigned __int64 v10; // x8
  __int64 v11; // x11
  _BYTE *v12; // x9
  char *v13; // x13
  unsigned __int64 v14; // x14
  __int64 v15; // x15
  _OWORD *v16; // x13
  __int128 *v17; // x14
  unsigned __int64 v18; // x16
  __int128 v19; // q0
  __int128 v20; // q1
  _QWORD *v21; // x11
  __int64 *v22; // x16
  __int64 v23; // x15
  __int64 v24; // t1
  char v25; // t1

  if ( a1 != a2 )
  {
    v5 = a1;
    v6 = *(_QWORD *)(a3 + 16);
    do
    {
      v7 = *(_QWORD *)(a3 + 24);
      v8 = a2 - v5;
      if ( v7 < a2 - v5 + v6 )
      {
        (**(void (__fastcall ***)(__int64))a3)(a3);
        v6 = *(_QWORD *)(a3 + 16);
        v7 = *(_QWORD *)(a3 + 24);
      }
      v9 = v7 - v6;
      if ( v7 - v6 >= v8 )
        v10 = a2 - v5;
      else
        v10 = v7 - v6;
      if ( !v10 )
        goto LABEL_4;
      v11 = *(_QWORD *)(a3 + 8);
      v12 = (_BYTE *)(v11 + v6);
      if ( v10 >= 8 )
      {
        if ( (unsigned __int64)v12 >= v5 + v10 || (v14 = v10, v13 = (char *)v5, v5 >= v11 + v6 + v10) )
        {
          if ( v10 < 0x20 )
          {
            v15 = 0LL;
LABEL_21:
            if ( v9 >= v8 )
              v9 = a2 - v5;
            v21 = (_QWORD *)(v11 + v6 + v15);
            v22 = (__int64 *)(v5 + v15);
            v13 = (char *)(v5 + (v9 & 0xFFFFFFFFFFFFFFF8LL));
            v12 += v9 & 0xFFFFFFFFFFFFFFF8LL;
            v14 = v10 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
            v23 = v15 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v24 = *v22++;
              v23 += 8LL;
              *v21++ = v24;
            }
            while ( v23 );
            if ( v9 == (v9 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_3;
            goto LABEL_28;
          }
          v15 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          v16 = (_OWORD *)(v11 + v6 + 16);
          v17 = (__int128 *)(v5 + 16);
          v18 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v19 = *(v17 - 1);
            v20 = *v17;
            v17 += 2;
            v18 -= 32LL;
            *(v16 - 1) = v19;
            *v16 = v20;
            v16 += 2;
          }
          while ( v18 );
          if ( v10 == v15 )
            goto LABEL_3;
          if ( (v10 & 0x18) != 0 )
            goto LABEL_21;
          v14 = v10 & 0x1F;
          v12 += v15;
          v13 = (char *)(v5 + v15);
        }
      }
      else
      {
        v13 = (char *)v5;
        v14 = v10;
      }
      do
      {
LABEL_28:
        v25 = *v13++;
        --v14;
        *v12++ = v25;
      }
      while ( v14 );
LABEL_3:
      v6 = *(_QWORD *)(a3 + 16);
LABEL_4:
      v6 += v10;
      v5 += v10;
      *(_QWORD *)(a3 + 16) = v6;
    }
    while ( v5 != a2 );
  }
  return a3;
}


================================================================================
Function: sub_680EE7C (0x680EE7C)
================================================================================

__int64 __fastcall sub_680EE7C(unsigned int **a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x20
  __int64 v12; // x8
  unsigned int *v13; // x21
  __int64 v14; // x1
  char v15; // w9
  int v16; // w21
  unsigned int *v17; // x19
  char v18; // w9
  __int64 v19; // x10
  __int64 v20; // x8
  __int64 v21; // x1

  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_174D7FE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_680EFB8(a2, *(_QWORD *)a1[1], *a1[2], a1[3][3], a1[4]);
  v11 = v10;
  if ( (*((_BYTE *)a1[5] + 6) & 0x10) != 0 )
  {
    v12 = *(_QWORD *)(v10 + 16);
    v13 = a1[6];
    v14 = v12 + 1;
    if ( *(_QWORD *)(v10 + 24) < (unsigned __int64)(v12 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v10)(v10);
      v12 = *(_QWORD *)(v11 + 16);
      v14 = v12 + 1;
    }
    v15 = *(_BYTE *)v13;
    *(_QWORD *)(v11 + 16) = v14;
    *(_BYTE *)(*(_QWORD *)(v11 + 8) + v12) = v15;
    v16 = *a1[7];
    if ( v16 >= 1 )
    {
      v17 = a1[8];
      do
      {
        v20 = *(_QWORD *)(v11 + 16);
        v21 = v20 + 1;
        if ( *(_QWORD *)(v11 + 24) < (unsigned __int64)(v20 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v11)(v11);
          v20 = *(_QWORD *)(v11 + 16);
          v21 = v20 + 1;
        }
        --v16;
        v18 = *(_BYTE *)v17;
        v19 = *(_QWORD *)(v11 + 8);
        *(_QWORD *)(v11 + 16) = v21;
        *(_BYTE *)(v19 + v20) = v18;
      }
      while ( v16 );
    }
  }
  return v11;
}


================================================================================
Function: sub_680EFB8 (0x680EFB8)
================================================================================

__int64 __fastcall sub_680EFB8(__int64 a1, unsigned __int64 a2, int a3, int a4, __int64 a5)
{
  unsigned __int64 v6; // x21
  __int64 v7; // x19
  __int64 v9; // x3
  __int64 v10; // x25
  unsigned __int64 i; // x8
  unsigned __int64 v12; // x26
  unsigned __int64 v13; // x11
  unsigned __int64 v14; // x8
  _BYTE *v15; // x10
  _BYTE *v16; // x9
  char *v17; // x12
  unsigned __int64 v18; // x13
  unsigned __int64 v19; // x14
  _OWORD *v20; // x12
  __int128 *v21; // x13
  unsigned __int64 v22; // x15
  __int128 v23; // q0
  __int128 v24; // q1
  _QWORD *v25; // x10
  __int64 *v26; // x16
  unsigned __int64 v27; // x14
  __int64 v28; // t1
  char v29; // t1
  __int64 v30; // x1
  __int64 v31; // x10
  __int64 v32; // x22
  unsigned __int64 v33; // x8
  unsigned __int64 v34; // x24
  unsigned __int64 v35; // x12
  unsigned __int64 v36; // x8
  __int64 v37; // x11
  _BYTE *v38; // x9
  char *v39; // x13
  unsigned __int64 v40; // x14
  __int64 v41; // x15
  _OWORD *v42; // x13
  __int128 *v43; // x14
  unsigned __int64 v44; // x16
  __int128 v45; // q0
  __int128 v46; // q1
  _QWORD *v47; // x11
  __int64 *v48; // x16
  __int64 v49; // x15
  __int64 v50; // t1
  char v51; // t1
  __int64 v52; // x9
  __int64 v53; // x8
  __int64 v54; // x1
  void (__fastcall **v56)(_QWORD); // [xsp+0h] [xbp-220h] BYREF
  _BYTE *v57; // [xsp+8h] [xbp-218h]
  __int128 v58; // [xsp+10h] [xbp-210h]
  _BYTE v59[504]; // [xsp+20h] [xbp-200h] BYREF

  v6 = a2;
  v7 = a1;
  if ( !*(_BYTE *)(a5 + 24) )
  {
    if ( !a3 )
    {
LABEL_67:
      if ( a4 >= 1 )
      {
        do
        {
          v53 = *(_QWORD *)(v7 + 16);
          v54 = v53 + 1;
          if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v53 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v7)(v7);
            v53 = *(_QWORD *)(v7 + 16);
            v54 = v53 + 1;
          }
          --a4;
          v52 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v54;
          *(_BYTE *)(v52 + v53) = 48;
        }
        while ( a4 );
      }
      return v7;
    }
    v31 = *(_QWORD *)(a1 + 16);
    v32 = a2 + a3;
    while ( 1 )
    {
      v33 = *(_QWORD *)(v7 + 24);
      v34 = v32 - v6;
      if ( v33 < v32 - v6 + v31 )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v31 = *(_QWORD *)(v7 + 16);
        v33 = *(_QWORD *)(v7 + 24);
      }
      v35 = v33 - v31;
      if ( v33 - v31 >= v34 )
        v36 = v32 - v6;
      else
        v36 = v33 - v31;
      if ( !v36 )
        goto LABEL_41;
      v37 = *(_QWORD *)(v7 + 8);
      v38 = (_BYTE *)(v37 + v31);
      if ( v36 >= 8 )
      {
        if ( (unsigned __int64)v38 >= v6 + v36 || (v40 = v36, v39 = (char *)v6, v6 >= v37 + v31 + v36) )
        {
          if ( v36 < 0x20 )
          {
            v41 = 0LL;
LABEL_58:
            if ( v34 < v35 )
              v35 = v32 - v6;
            v47 = (_QWORD *)(v37 + v31 + v41);
            v48 = (__int64 *)(v6 + v41);
            v39 = (char *)(v6 + (v35 & 0xFFFFFFFFFFFFFFF8LL));
            v38 += v35 & 0xFFFFFFFFFFFFFFF8LL;
            v40 = v36 - (v35 & 0xFFFFFFFFFFFFFFF8LL);
            v49 = v41 - (v35 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v50 = *v48++;
              v49 += 8LL;
              *v47++ = v50;
            }
            while ( v49 );
            if ( v35 == (v35 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_40;
            goto LABEL_65;
          }
          v41 = v36 & 0xFFFFFFFFFFFFFFE0LL;
          v42 = (_OWORD *)(v37 + v31 + 16);
          v43 = (__int128 *)(v6 + 16);
          v44 = v36 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v45 = *(v43 - 1);
            v46 = *v43;
            v43 += 2;
            v44 -= 32LL;
            *(v42 - 1) = v45;
            *v42 = v46;
            v42 += 2;
          }
          while ( v44 );
          if ( v36 == v41 )
            goto LABEL_40;
          if ( (v36 & 0x18) != 0 )
            goto LABEL_58;
          v40 = v36 & 0x1F;
          v38 += v41;
          v39 = (char *)(v6 + v41);
        }
      }
      else
      {
        v39 = (char *)v6;
        v40 = v36;
      }
      do
      {
LABEL_65:
        v51 = *v39++;
        --v40;
        *v38++ = v51;
      }
      while ( v40 );
LABEL_40:
      v31 = *(_QWORD *)(v7 + 16);
LABEL_41:
      v31 += v36;
      v6 += v36;
      *(_QWORD *)(v7 + 16) = v31;
      if ( v6 == v32 )
        goto LABEL_67;
    }
  }
  v9 = 0LL;
  v56 = (void (__fastcall **)(_QWORD))&off_6C599D8;
  v57 = v59;
  v58 = xmmword_B03780;
  if ( a3 )
  {
    v10 = a2 + a3;
    for ( i = 500LL; ; i = *((_QWORD *)&v58 + 1) )
    {
      v12 = v10 - v6;
      if ( i < v10 - v6 + v9 )
      {
        (*v56)(&v56);
        i = *((_QWORD *)&v58 + 1);
        v9 = v58;
      }
      v13 = i - v9;
      v14 = i - v9 >= v12 ? v10 - v6 : i - v9;
      if ( v14 )
        break;
LABEL_29:
      v9 += v14;
      v6 += v14;
      *(_QWORD *)&v58 = v9;
      if ( v6 == v10 )
        goto LABEL_31;
    }
    v15 = v57;
    v16 = &v57[v9];
    if ( v14 < 8 )
    {
      v17 = (char *)v6;
      v18 = v14;
      goto LABEL_27;
    }
    if ( (unsigned __int64)v16 < v6 + v14 )
    {
      v18 = v14;
      v17 = (char *)v6;
      if ( v6 < (unsigned __int64)&v57[v9 + v14] )
        goto LABEL_27;
    }
    if ( v14 >= 0x20 )
    {
      v19 = v14 & 0xFFFFFFFFFFFFFFE0LL;
      v20 = &v57[v9 + 16];
      v21 = (__int128 *)(v6 + 16);
      v22 = v14 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v23 = *(v21 - 1);
        v24 = *v21;
        v21 += 2;
        v22 -= 32LL;
        *(v20 - 1) = v23;
        *v20 = v24;
        v20 += 2;
      }
      while ( v22 );
      if ( v14 == v19 )
        goto LABEL_28;
      if ( (v14 & 0x18) == 0 )
      {
        v18 = v14 & 0x1F;
        v16 += v19;
        v17 = (char *)(v6 + v19);
        do
        {
LABEL_27:
          v29 = *v17++;
          --v18;
          *v16++ = v29;
        }
        while ( v18 );
LABEL_28:
        v9 = v58;
        goto LABEL_29;
      }
    }
    else
    {
      v19 = 0LL;
    }
    if ( v12 < v13 )
      v13 = v10 - v6;
    v25 = &v15[v9 + v19];
    v26 = (__int64 *)(v6 + v19);
    v17 = (char *)(v6 + (v13 & 0xFFFFFFFFFFFFFFF8LL));
    v16 += v13 & 0xFFFFFFFFFFFFFFF8LL;
    v18 = v14 - (v13 & 0xFFFFFFFFFFFFFFF8LL);
    v27 = v19 - (v13 & 0xFFFFFFFFFFFFFFF8LL);
    do
    {
      v28 = *v26++;
      v27 += 8LL;
      *v25++ = v28;
    }
    while ( v27 );
    if ( v13 == (v13 & 0xFFFFFFFFFFFFFFF8LL) )
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_31:
  if ( a4 >= 1 )
  {
    do
    {
      v30 = v9 + 1;
      if ( *((_QWORD *)&v58 + 1) < (unsigned __int64)(v9 + 1) )
      {
        (*v56)(&v56);
        v9 = v58;
        v30 = v58 + 1;
      }
      *(_QWORD *)&v58 = v30;
      --a4;
      v57[v9] = 48;
      v9 = v58;
    }
    while ( a4 );
  }
  v7 = sub_53DDAC4(a5, v7, v57, v9);
  if ( v57 != v59 )
    sub_65ECAF4();
  return v7;
}


================================================================================
Function: sub_680F3F0 (0x680F3F0)
================================================================================

__int64 __fastcall sub_680F3F0(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x8
  char v14; // w24
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x22
  __int64 v18; // x21
  int v19; // w23
  unsigned int *v20; // x20
  char v21; // w9
  __int64 v22; // x10
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_174D7F4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_250EF44(a1, v10 >> v9, v8);
  v12 = **a5;
  if ( (_DWORD)v12 )
  {
    v13 = *(_QWORD *)(v7 + 16);
    v14 = byte_174D7FE[v12];
    v15 = v13 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v13 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v13 = *(_QWORD *)(v7 + 16);
      v15 = v13 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v13) = v14;
  }
  v17 = v10 - v11;
  v18 = sub_680F558(v7, *(_QWORD *)a5[1], *a5[2], *a5[3], *(unsigned __int8 *)a5[4], a5[5]);
  v19 = *a5[6];
  if ( v19 >= 1 )
  {
    v20 = a5[7];
    do
    {
      v23 = *(_QWORD *)(v18 + 16);
      v24 = v23 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v23 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v23 = *(_QWORD *)(v18 + 16);
        v24 = v23 + 1;
      }
      --v19;
      v21 = *(_BYTE *)v20;
      v22 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v24;
      *(_BYTE *)(v22 + v23) = v21;
    }
    while ( v19 );
  }
  result = v18;
  if ( v17 )
    return sub_250EF44(v18, v17, v8);
  return result;
}


================================================================================
Function: sub_680F558 (0x680F558)
================================================================================

__int64 __fastcall sub_680F558(__int64 a1, unsigned __int64 a2, int a3, unsigned int a4, char a5, __int64 a6)
{
  __int64 v12; // x0
  __int64 v13; // x9
  __int64 v14; // x26
  __int64 v15; // x1
  __int64 v16; // x10
  __int64 v17; // x22
  __int64 v18; // x0
  __int64 v19; // x9
  __int64 v20; // x1
  _UNKNOWN **v22; // [xsp+8h] [xbp-228h] BYREF
  _BYTE *v23; // [xsp+10h] [xbp-220h]
  __int128 v24; // [xsp+18h] [xbp-218h]
  _BYTE v25[504]; // [xsp+28h] [xbp-208h] BYREF

  if ( *(_BYTE *)(a6 + 24) )
  {
    v22 = &off_6C599D8;
    v23 = v25;
    v24 = xmmword_B03780;
    v12 = sub_680ECFC(a2, a2 + (int)a4, (__int64)&v22);
    if ( a5 )
    {
      v13 = *(_QWORD *)(v12 + 16);
      v14 = v12;
      v15 = v13 + 1;
      if ( *(_QWORD *)(v12 + 24) < (unsigned __int64)(v13 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v12)(v12);
        v13 = *(_QWORD *)(v14 + 16);
        v15 = v13 + 1;
      }
      v16 = *(_QWORD *)(v14 + 8);
      *(_QWORD *)(v14 + 16) = v15;
      *(_BYTE *)(v16 + v13) = a5;
      sub_680ECFC(a2 + (int)a4, a2 + a3, v14);
    }
    sub_53DDAC4(a6, a1, v23, a4);
    v17 = sub_53DDE58((unsigned __int64)&v23[a4], (__int64)&v23[v24], a1);
    if ( v23 != v25 )
      sub_65ECAF4();
  }
  else
  {
    v18 = sub_680ECFC(a2, a2 + (int)a4, a1);
    v17 = v18;
    if ( a5 )
    {
      v19 = *(_QWORD *)(v18 + 16);
      v20 = v19 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v19 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v19 = *(_QWORD *)(v17 + 16);
        v20 = v19 + 1;
      }
      *(_QWORD *)(v17 + 16) = v20;
      *(_BYTE *)(*(_QWORD *)(v17 + 8) + v19) = a5;
      return sub_680ECFC(a2 + (int)a4, a2 + a3, v17);
    }
  }
  return v17;
}


================================================================================
Function: sub_680F740 (0x680F740)
================================================================================

__int64 __fastcall sub_680F740(unsigned int **a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x8
  unsigned int *v11; // x21
  __int64 v12; // x1
  char v13; // w9
  __int64 v14; // x8
  unsigned int *v15; // x21
  __int64 v16; // x1
  char v17; // w9
  int v18; // w21
  unsigned int *v19; // x22
  char v20; // w9
  __int64 v21; // x10
  __int64 v22; // x8
  __int64 v23; // x1
  __int64 v24; // x8
  __int64 v25; // x10
  unsigned __int64 v26; // x20
  __int64 v27; // x21
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x22
  unsigned __int64 v30; // x12
  unsigned __int64 v31; // x8
  __int64 v32; // x11
  _BYTE *v33; // x9
  char *v34; // x13
  unsigned __int64 v35; // x14
  __int64 v36; // x15
  _OWORD *v37; // x13
  __int128 *v38; // x14
  unsigned __int64 v39; // x16
  __int128 v40; // q0
  __int128 v41; // q1
  _QWORD *v42; // x11
  __int64 *v43; // x16
  __int64 v44; // x15
  __int64 v45; // t1
  char v46; // t1

  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_174D7FE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = *(_QWORD *)(a2 + 16);
  v11 = a1[1];
  v12 = v10 + 1;
  if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v10 + 1) )
  {
    (**(void (__fastcall ***)(__int64))a2)(a2);
    v10 = *(_QWORD *)(a2 + 16);
    v12 = v10 + 1;
  }
  v13 = *(_BYTE *)v11;
  *(_QWORD *)(a2 + 16) = v12;
  *(_BYTE *)(*(_QWORD *)(a2 + 8) + v10) = v13;
  if ( *(_BYTE *)a1[2] )
  {
    v14 = *(_QWORD *)(a2 + 16);
    v15 = a1[3];
    v16 = v14 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v14 = *(_QWORD *)(a2 + 16);
      v16 = v14 + 1;
    }
    v17 = *(_BYTE *)v15;
    *(_QWORD *)(a2 + 16) = v16;
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + v14) = v17;
    v18 = *a1[4];
    if ( v18 >= 1 )
    {
      v19 = a1[1];
      do
      {
        v22 = *(_QWORD *)(a2 + 16);
        v23 = v22 + 1;
        if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v22 + 1) )
        {
          (**(void (__fastcall ***)(__int64))a2)(a2);
          v22 = *(_QWORD *)(a2 + 16);
          v23 = v22 + 1;
        }
        --v18;
        v20 = *(_BYTE *)v19;
        v21 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a2 + 16) = v23;
        *(_BYTE *)(v21 + v22) = v20;
      }
      while ( v18 );
    }
    v24 = (int)*a1[6];
    if ( (_DWORD)v24 )
    {
      v25 = *(_QWORD *)(a2 + 16);
      v26 = *(_QWORD *)a1[5];
      v27 = v26 + v24;
      do
      {
        v28 = *(_QWORD *)(a2 + 24);
        v29 = v27 - v26;
        if ( v28 < v27 - v26 + v25 )
        {
          (**(void (__fastcall ***)(__int64))a2)(a2);
          v25 = *(_QWORD *)(a2 + 16);
          v28 = *(_QWORD *)(a2 + 24);
        }
        v30 = v28 - v25;
        if ( v28 - v25 >= v29 )
          v31 = v27 - v26;
        else
          v31 = v28 - v25;
        if ( !v31 )
          goto LABEL_18;
        v32 = *(_QWORD *)(a2 + 8);
        v33 = (_BYTE *)(v32 + v25);
        if ( v31 >= 8 )
        {
          if ( (unsigned __int64)v33 >= v26 + v31 || (v35 = v31, v34 = (char *)v26, v26 >= v32 + v25 + v31) )
          {
            if ( v31 < 0x20 )
            {
              v36 = 0LL;
LABEL_35:
              if ( v29 < v30 )
                v30 = v27 - v26;
              v42 = (_QWORD *)(v32 + v25 + v36);
              v43 = (__int64 *)(v26 + v36);
              v34 = (char *)(v26 + (v30 & 0xFFFFFFFFFFFFFFF8LL));
              v33 += v30 & 0xFFFFFFFFFFFFFFF8LL;
              v35 = v31 - (v30 & 0xFFFFFFFFFFFFFFF8LL);
              v44 = v36 - (v30 & 0xFFFFFFFFFFFFFFF8LL);
              do
              {
                v45 = *v43++;
                v44 += 8LL;
                *v42++ = v45;
              }
              while ( v44 );
              if ( v30 == (v30 & 0xFFFFFFFFFFFFFFF8LL) )
                goto LABEL_17;
              goto LABEL_42;
            }
            v36 = v31 & 0xFFFFFFFFFFFFFFE0LL;
            v37 = (_OWORD *)(v32 + v25 + 16);
            v38 = (__int128 *)(v26 + 16);
            v39 = v31 & 0xFFFFFFFFFFFFFFE0LL;
            do
            {
              v40 = *(v38 - 1);
              v41 = *v38;
              v38 += 2;
              v39 -= 32LL;
              *(v37 - 1) = v40;
              *v37 = v41;
              v37 += 2;
            }
            while ( v39 );
            if ( v31 == v36 )
              goto LABEL_17;
            if ( (v31 & 0x18) != 0 )
              goto LABEL_35;
            v35 = v31 & 0x1F;
            v33 += v36;
            v34 = (char *)(v26 + v36);
          }
        }
        else
        {
          v34 = (char *)v26;
          v35 = v31;
        }
        do
        {
LABEL_42:
          v46 = *v34++;
          --v35;
          *v33++ = v46;
        }
        while ( v35 );
LABEL_17:
        v25 = *(_QWORD *)(a2 + 16);
LABEL_18:
        v25 += v31;
        v26 += v31;
        *(_QWORD *)(a2 + 16) = v25;
      }
      while ( v26 != v27 );
    }
  }
  return a2;
}


================================================================================
Function: sub_680F9F8 (0x680F9F8)
================================================================================

__int64 __fastcall sub_680F9F8(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, __int64 a5)
{
  __int64 v6; // x19
  char *v7; // x20
  unsigned __int64 v8; // x9
  bool v9; // cf
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x24
  char v12; // w8
  unsigned __int64 v13; // x22
  __int64 v14; // x8
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x8
  __int64 v18; // x1
  __int64 v19; // x9
  unsigned __int64 v20; // x22
  __int64 v21; // x9
  __int64 v22; // x11
  unsigned __int64 v23; // x8
  __int64 v24; // x10
  unsigned __int64 v25; // x11
  __int64 v26; // x12
  _BYTE *v27; // x9
  unsigned __int64 v28; // x11
  _BYTE *v30; // x9
  unsigned __int64 v31; // x11
  bool v32; // cc
  _BYTE v33[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v6 = a1;
  v7 = (char *)a2 + 11;
  v8 = *a2;
  v9 = v8 >= a4;
  v10 = v8 - a4;
  if ( v9 )
    v11 = v10;
  else
    v11 = 0LL;
  v12 = byte_174D7F4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  v13 = v11 >> v12;
  if ( v11 >> v12 )
    v6 = sub_250EF44(a1, v11 >> v12, v7);
  v14 = *(_QWORD *)(v6 + 16);
  v15 = v14 + 1;
  if ( *(_QWORD *)(v6 + 24) < (unsigned __int64)(v14 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v6)(v6);
    v14 = *(_QWORD *)(v6 + 16);
    v15 = v14 + 1;
  }
  v16 = *(_QWORD *)(v6 + 8);
  *(_QWORD *)(v6 + 16) = v15;
  *(_BYTE *)(v16 + v14) = 48;
  v17 = *(_QWORD *)(v6 + 16);
  v18 = v17 + 1;
  if ( *(_QWORD *)(v6 + 24) < (unsigned __int64)(v17 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v6)(v6);
    v17 = *(_QWORD *)(v6 + 16);
    v18 = v17 + 1;
  }
  v19 = *(_QWORD *)(v6 + 8);
  *(_QWORD *)(v6 + 16) = v18;
  v20 = v11 - v13;
  *(_BYTE *)(v19 + v17) = 120;
  v21 = *(_QWORD *)(v6 + 16);
  v22 = *(unsigned int *)(a5 + 8);
  v23 = *(_QWORD *)a5;
  v24 = (int)v22;
  v25 = v21 + v22;
  if ( *(_QWORD *)(v6 + 24) >= v25 && (v26 = *(_QWORD *)(v6 + 8), *(_QWORD *)(v6 + 16) = v25, v26) )
  {
    v27 = (_BYTE *)(v21 + v24 + v26 - 1);
    do
    {
      v28 = v23 & 0xF;
      v9 = v23 >= 0x10;
      v23 >>= 4;
      *v27-- = a0123456789abcd_1[v28];
    }
    while ( v9 );
    if ( v20 )
      return sub_250EF44(v6, v20, v7);
  }
  else
  {
    v30 = &v33[v24 - 1];
    do
    {
      v31 = v23 & 0xF;
      v32 = v23 > 0xF;
      v23 >>= 4;
      *v30-- = a0123456789abcd_1[v31];
    }
    while ( v32 );
    v6 = sub_53DDE58(v33, &v33[v24], v6);
    if ( v20 )
      return sub_250EF44(v6, v20, v7);
  }
  return v6;
}


================================================================================
Function: sub_680FBC4 (0x680FBC4)
================================================================================

unsigned __int8 *__fastcall sub_680FBC4(__int64 a1, __int64 a2, __int64 a3, long double a4)
{
  char *v4; // x19
  int v5; // w8
  __int64 v7; // x10
  unsigned __int64 v8; // x8
  __int64 v9; // x12
  __int64 v10; // x9
  unsigned int *v11; // x11
  int v13; // w8
  int v14; // w8
  __int64 v15; // x10
  unsigned int *v16; // x11
  char *v17; // x0
  __int64 v18; // x21
  char *v19; // x3
  unsigned int v20; // w10
  float v21; // w22
  __int64 v22; // x0
  long double v23; // q0
  int v24; // w12
  __int64 v25; // x0
  const char *v26; // x8
  __int64 v27; // x2
  __int64 v28; // x8
  __int64 v29; // x1
  __int64 v30; // x9
  const char *v31; // x22
  const char *v32; // x1
  __int64 v33; // x11
  unsigned __int64 v34; // x22
  __int64 v35; // x2
  unsigned __int64 v36; // x8
  bool v37; // cc
  unsigned __int64 v38; // x8
  long double v40; // [xsp+0h] [xbp-70h]
  long double v41; // [xsp+10h] [xbp-60h]
  __int64 v42; // [xsp+20h] [xbp-50h] BYREF
  int v43; // [xsp+28h] [xbp-48h]
  __int64 v44; // [xsp+30h] [xbp-40h] BYREF
  __int64 v45; // [xsp+38h] [xbp-38h]
  __int64 v46; // [xsp+40h] [xbp-30h]
  __int64 v47; // [xsp+48h] [xbp-28h]
  unsigned __int64 v48; // [xsp+50h] [xbp-20h] BYREF
  __int64 v49; // [xsp+58h] [xbp-18h]
  int v50; // [xsp+60h] [xbp-10h]

  v4 = (char *)(a1 + 1);
  if ( a1 + 1 == a2 )
    sub_6806F24((__int64)"invalid format string");
  v5 = (unsigned __int8)*v4;
  if ( v5 == 123 )
  {
    *(_QWORD *)(a3 + 32) = sub_680ECFC(a1 + 1, a1 + 2, *(_QWORD *)(a3 + 32));
    return (unsigned __int8 *)(v4 + 1);
  }
  if ( v5 == 125 )
  {
    v7 = *(unsigned int *)(a3 + 24);
    if ( (v7 & 0x80000000) == 0 )
    {
      v8 = *(_QWORD *)(a3 + 40);
      *(_DWORD *)(a3 + 24) = v7 + 1;
      if ( (v8 & 0x8000000000000000LL) != 0 )
      {
        if ( (int)v7 < (int)v8 )
        {
          v10 = *(_QWORD *)(a3 + 48);
          v11 = (unsigned int *)(v10 + 32 * v7);
          LODWORD(v9) = v11[4];
          if ( (_DWORD)v9 )
            goto LABEL_26;
        }
      }
      else if ( (unsigned int)v7 <= 0xE )
      {
        v9 = (v8 >> (4 * (unsigned __int8)v7)) & 0xF;
        if ( ((v8 >> (4 * (unsigned __int8)v7)) & 0xF) != 0 )
        {
          v10 = *(_QWORD *)(a3 + 48);
          v11 = (unsigned int *)(v10 + 16 * v7);
LABEL_26:
          v18 = *(_QWORD *)(a3 + 32);
          v19 = (char *)*((_QWORD *)v11 + 1);
          v21 = *(float *)v11;
          v20 = v11[1];
          switch ( (int)v9 )
          {
            case 1:
              goto LABEL_31;
            case 2:
              goto LABEL_32;
            case 3:
              goto LABEL_33;
            case 4:
              goto LABEL_34;
            case 5:
              goto LABEL_35;
            case 6:
              goto LABEL_36;
            case 7:
              goto LABEL_37;
            case 8:
              goto LABEL_41;
            case 9:
              goto LABEL_44;
            case 10:
              goto LABEL_45;
            case 11:
              v22 = *(_QWORD *)(a3 + 32);
              *(_QWORD *)&v41 = *v11 | ((unsigned __int64)v20 << 32);
              *((_QWORD *)&v41 + 1) = *((_QWORD *)v11 + 1);
              v23 = v41;
              goto LABEL_56;
            case 12:
              goto LABEL_46;
            case 13:
              goto LABEL_48;
            case 14:
              v34 = *v11 | ((unsigned __int64)v20 << 32);
              v35 = 2LL;
              v36 = v34;
              v49 = 0x100000020000000LL;
              v48 = 0xFFFFFFFF00000000LL;
              do
              {
                v37 = v36 > 0xF;
                ++v35;
                v36 >>= 4;
              }
              while ( v37 );
              goto LABEL_59;
            case 15:
              goto LABEL_50;
            default:
              goto LABEL_51;
          }
        }
      }
LABEL_63:
      sub_6806F24((__int64)"argument not found");
    }
LABEL_64:
    sub_6806F24((__int64)"cannot switch from manual to automatic argument indexing");
  }
  v42 = a3;
  v43 = 0;
  if ( v5 == 58 )
  {
    v13 = *(_DWORD *)(a3 + 24);
    if ( v13 < 0 )
      goto LABEL_64;
    v43 = *(_DWORD *)(a3 + 24);
    *(_DWORD *)(a3 + 24) = v13 + 1;
  }
  else
  {
    v4 = (char *)sub_6810924(a1 + 1, a2, &v42);
  }
  if ( v4 == (char *)a2 )
    goto LABEL_65;
  v14 = *v4;
  if ( v14 == 58 )
  {
    v17 = (char *)sub_6810158(a3, v43, v4 + 1);
    if ( v17 == (char *)a2 || (v4 = v17, *v17 != 125) )
      sub_6806F24((__int64)"unknown format specifier");
    return (unsigned __int8 *)(v4 + 1);
  }
  if ( v14 != 125 )
LABEL_65:
    sub_6806F24((__int64)"missing '}' in format string");
  v8 = *(_QWORD *)(a3 + 40);
  if ( (v8 & 0x8000000000000000LL) != 0 )
  {
    if ( v43 >= (int)v8 )
      goto LABEL_63;
    v10 = *(_QWORD *)(a3 + 48);
    v16 = (unsigned int *)(v10 + 32LL * v43);
    LODWORD(v15) = v16[4];
    if ( !(_DWORD)v15 )
      goto LABEL_63;
  }
  else
  {
    if ( v43 > 14 )
      goto LABEL_63;
    v15 = (v8 >> (4 * (unsigned __int8)v43)) & 0xF;
    if ( ((v8 >> (4 * (unsigned __int8)v43)) & 0xF) == 0 )
      goto LABEL_63;
    v10 = *(_QWORD *)(a3 + 48);
    v16 = (unsigned int *)(v10 + 16LL * v43);
  }
  v18 = *(_QWORD *)(a3 + 32);
  v24 = v15 - 1;
  v19 = (char *)*((_QWORD *)v16 + 1);
  v21 = *(float *)v16;
  v20 = v16[1];
  switch ( v24 )
  {
    case 0:
LABEL_31:
      v25 = sub_680A850(v18, LODWORD(v21));
      goto LABEL_60;
    case 1:
LABEL_32:
      v25 = sub_68093A8(v18, LODWORD(v21));
      goto LABEL_60;
    case 2:
LABEL_33:
      v25 = sub_680AA3C(v18, LODWORD(v21) | ((unsigned __int64)v20 << 32));
      goto LABEL_60;
    case 3:
LABEL_34:
      v25 = sub_680AC4C(v18, LODWORD(v21) | ((unsigned __int64)v20 << 32));
      goto LABEL_60;
    case 4:
LABEL_35:
      v25 = sub_680AE00(v18, a2, LODWORD(v21) | ((unsigned __int64)v20 << 32), (__int64)v19);
      goto LABEL_60;
    case 5:
LABEL_36:
      v25 = sub_680B128(v18, a2, LODWORD(v21) | ((unsigned __int64)v20 << 32), v19);
      goto LABEL_60;
    case 6:
LABEL_37:
      *(_DWORD *)((char *)&v49 + 3) = 32;
      v26 = "true";
      if ( LOBYTE(v21) )
      {
        v27 = 4LL;
      }
      else
      {
        v26 = "false";
        v27 = 5LL;
      }
      LOBYTE(v49) = 0;
      v48 = 0xFFFFFFFF00000000LL;
      *(_WORD *)((char *)&v49 + 1) = 0;
      HIBYTE(v49) = 1;
      v44 = (__int64)v26;
      v45 = v27;
      v25 = sub_680B3F4(v18, &v48);
      goto LABEL_60;
    case 7:
LABEL_41:
      v28 = *(_QWORD *)(v18 + 16);
      v29 = v28 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v28 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v28 = *(_QWORD *)(v18 + 16);
        v29 = v28 + 1;
      }
      v30 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v29;
      *(_BYTE *)(v30 + v28) = LOBYTE(v21);
      goto LABEL_51;
    case 8:
LABEL_44:
      v25 = sub_680B5F8(v18, v21);
      goto LABEL_60;
    case 9:
LABEL_45:
      *(_QWORD *)&a4 = LODWORD(v21) | ((unsigned __int64)v20 << 32);
      v25 = sub_680CC80(v18, a4);
      goto LABEL_60;
    case 10:
      v22 = *(_QWORD *)(a3 + 32);
      *(_QWORD *)&v40 = *v16 | ((unsigned __int64)v20 << 32);
      *((_QWORD *)&v40 + 1) = *((_QWORD *)v16 + 1);
      v23 = v40;
LABEL_56:
      v25 = sub_680DF58(v22, 0xFFFFFFFF00000000LL, 0x100000020000000LL, 0LL, v23);
      goto LABEL_60;
    case 11:
LABEL_46:
      v31 = (const char *)(LODWORD(v21) | ((unsigned __int64)v20 << 32));
      if ( !v31 )
        sub_6806F24((__int64)"string pointer is null");
      v32 = &v31[strlen(v31)];
      goto LABEL_49;
    case 12:
LABEL_48:
      v31 = (const char *)(LODWORD(v21) | ((unsigned __int64)v20 << 32));
      v32 = &v19[(_QWORD)v31];
LABEL_49:
      v25 = sub_680ECFC(v31, v32, v18);
      goto LABEL_60;
    case 13:
      v34 = *v16 | ((unsigned __int64)v20 << 32);
      v35 = 2LL;
      v38 = v34;
      v49 = 0x100000020000000LL;
      v48 = 0xFFFFFFFF00000000LL;
      do
      {
        v37 = v38 > 0xF;
        ++v35;
        v38 >>= 4;
      }
      while ( v37 );
LABEL_59:
      v44 = v34;
      LODWORD(v45) = v35 - 2;
      v25 = sub_680F9F8(v18, &v48, v35, v35, &v44);
LABEL_60:
      *(_QWORD *)(a3 + 32) = v25;
      return (unsigned __int8 *)(v4 + 1);
    case 14:
LABEL_50:
      v33 = *(_QWORD *)(a3 + 56);
      v48 = 0LL;
      v49 = 0LL;
      v50 = 0;
      v44 = v18;
      v45 = v8;
      v46 = v10;
      v47 = v33;
      ((void (__fastcall *)(unsigned __int64, unsigned __int64 *, __int64 *))v19)(
        LODWORD(v21) | ((unsigned __int64)v20 << 32),
        &v48,
        &v44);
      v18 = v44;
      goto LABEL_51;
    default:
LABEL_51:
      *(_QWORD *)(a3 + 32) = v18;
      break;
  }
  return (unsigned __int8 *)(v4 + 1);
}


================================================================================
Function: sub_68100A8 (0x68100A8)
================================================================================

__int64 __fastcall sub_68100A8(__int64 result, char *s, char *a3)
{
  char *v4; // x21
  __int64 v5; // x20
  signed __int64 v6; // x23
  char *v7; // x0
  char *v8; // x22
  _BYTE *v9; // x1
  __int64 v10; // x23
  __int64 v11; // x0
  __int64 v12; // x19

  if ( s != a3 )
  {
    v4 = s;
    v5 = result;
    while ( 1 )
    {
      v6 = a3 - v4;
      v7 = (char *)memchr(v4, 125, a3 - v4);
      if ( !v7 )
        break;
      v8 = v7;
      v9 = v7 + 1;
      if ( v7 + 1 == a3 || *v9 != 125 )
        sub_6806F24((__int64)"unmatched '}' in format string");
      v10 = *(_QWORD *)v5;
      v11 = sub_680ECFC(v4, v9, *(_QWORD *)(*(_QWORD *)v5 + 32LL));
      v4 = v8 + 2;
      *(_QWORD *)(v10 + 32) = v11;
    }
    v12 = *(_QWORD *)v5;
    result = sub_680ECFC(v4, &v4[v6], *(_QWORD *)(*(_QWORD *)v5 + 32LL));
    *(_QWORD *)(v12 + 32) = result;
  }
  return result;
}


================================================================================
Function: sub_6810158 (0x6810158)
================================================================================

unsigned __int8 *__fastcall sub_6810158(_QWORD *a1, int a2, unsigned __int8 *src, unsigned __int8 *a4)
{
  unsigned __int8 *v5; // x8
  unsigned __int64 v7; // x9
  unsigned int v8; // w27
  __int64 v9; // x9
  float v10; // w20
  unsigned int v11; // w26
  __int64 *v12; // x19
  void (__fastcall *v13)(unsigned __int64, _QWORD *, __int64 *); // x11
  __int64 v14; // x9
  __int64 v15; // x10
  _QWORD *v16; // x23
  unsigned __int8 *v17; // x21
  int v18; // w0
  char v19; // w0
  unsigned __int64 v20; // x9
  __int64 v21; // x12
  char *v22; // x25
  int v23; // w10
  bool v24; // zf
  __int16 v25; // w28
  size_t v26; // x21
  int v27; // w9
  __int16 v28; // w9
  int v29; // w9
  unsigned __int8 *v30; // x0
  int v31; // w8
  unsigned __int8 *v32; // x0
  __int64 v33; // x24
  __int64 v34; // x4
  unsigned __int64 v35; // x8
  __int64 v36; // x0
  unsigned __int64 v37; // x1
  unsigned __int64 v38; // x20
  unsigned __int64 v39; // x8
  __int64 v40; // x2
  __int64 v41; // x0
  unsigned __int64 v42; // x20
  __int64 v43; // x10
  int v44; // w8
  const char *v45; // x8
  __int64 v46; // x2
  __int64 v47; // x0
  const char *v48; // x20
  __int64 v49; // x2
  unsigned __int64 v50; // x8
  bool v51; // cc
  unsigned __int64 v52; // x8
  __int64 v53; // x0
  bool v54; // cf
  size_t v56; // x0
  __int64 v57; // x4
  __int64 v58; // [xsp+8h] [xbp-78h]
  long double v59; // [xsp+10h] [xbp-70h]
  _QWORD v60[3]; // [xsp+20h] [xbp-60h] BYREF
  unsigned int v61; // [xsp+38h] [xbp-48h]
  _UNKNOWN **v62; // [xsp+40h] [xbp-40h] BYREF
  _BYTE *v63; // [xsp+48h] [xbp-38h] BYREF
  unsigned __int64 v64; // [xsp+50h] [xbp-30h] BYREF
  __int64 v65; // [xsp+58h] [xbp-28h]
  int v66; // [xsp+60h] [xbp-20h]

  v5 = src;
  v7 = a1[5];
  if ( (v7 & 0x8000000000000000LL) == 0 )
  {
    if ( a2 <= 14 )
    {
      v8 = (v7 >> (4 * (unsigned __int8)a2)) & 0xF;
      if ( v8 )
      {
        v9 = a1[6] + 16LL * a2;
        goto LABEL_7;
      }
    }
LABEL_129:
    sub_6806F24((__int64)"argument not found");
  }
  if ( (int)v7 <= a2 )
    goto LABEL_129;
  v9 = a1[6] + 32LL * a2;
  v8 = *(_DWORD *)(v9 + 16);
  if ( !v8 )
    goto LABEL_129;
LABEL_7:
  v10 = *(float *)v9;
  v11 = *(_DWORD *)(v9 + 4);
  v12 = a1 + 4;
  v13 = *(void (__fastcall **)(unsigned __int64, _QWORD *, __int64 *))(v9 + 8);
  if ( v8 == 15 )
  {
    v14 = a1[1];
    v15 = a1[2];
    v16 = a1 + 1;
    a1[1] = src;
    a1[2] = v15 + v14 - (_QWORD)src;
    v13(LODWORD(v10) | ((unsigned __int64)v11 << 32), a1 + 1, v12);
    return (unsigned __int8 *)*v16;
  }
  v58 = *(_QWORD *)(v9 + 8);
  LOBYTE(v63) = 0;
  *(_DWORD *)((char *)&v63 + 3) = 32;
  *(_WORD *)((char *)&v63 + 1) = 0;
  HIBYTE(v63) = 1;
  v60[0] = &v62;
  v60[1] = a1 + 1;
  v62 = (_UNKNOWN **)0xFFFFFFFF00000000LL;
  v60[2] = a1 + 4;
  v61 = v8;
  if ( a4 - src >= 2 )
  {
    v17 = src + 1;
    if ( src[1] == 125 )
    {
      v18 = *src;
      if ( (unsigned __int8)((v18 & 0xDF) - 91) >= 0xE6u && v18 != 76 )
      {
        v19 = sub_250DE24();
        if ( !v19 )
LABEL_131:
          sub_6806F24((__int64)"invalid type specifier");
        goto LABEL_77;
      }
    }
  }
  if ( src == a4 )
    goto LABEL_128;
  v20 = *src;
  v21 = byte_D1C6D0[v20 >> 3];
  v22 = (char *)(&src[((0x80FF0000uLL >> (*src >> 3)) & 1) + v21] >= a4
               ? src
               : &src[((0x80FF0000uLL >> (*src >> 3)) & 1) + v21]);
  while ( 1 )
  {
    v23 = *v22;
    if ( v23 == 94 )
      break;
    if ( v23 == 62 )
    {
      v25 = 2;
      v26 = v22 - (char *)src;
      if ( v22 == (char *)src )
        goto LABEL_26;
      goto LABEL_30;
    }
    if ( v23 == 60 )
    {
      v25 = 1;
      v26 = v22 - (char *)src;
      if ( v22 != (char *)src )
        goto LABEL_30;
LABEL_26:
      v22 = (char *)src;
      goto LABEL_35;
    }
    v24 = v22 == (char *)src;
    v22 = (char *)src;
    if ( v24 )
    {
      v25 = 0;
      goto LABEL_36;
    }
  }
  v25 = 3;
  v26 = v22 - (char *)src;
  if ( v22 == (char *)src )
    goto LABEL_26;
LABEL_30:
  if ( (_DWORD)v20 == 123 )
    sub_6806F24((__int64)"invalid fill character '{'");
  if ( v26 > 4 )
    sub_6806F24((__int64)"invalid fill");
  if ( v26 )
    memcpy((char *)&v63 + 3, src, v26);
  HIBYTE(v63) = v26;
LABEL_35:
  v5 = (unsigned __int8 *)(v22 + 1);
  *(_WORD *)((char *)&v63 + 1) = v25;
LABEL_36:
  if ( v5 == a4 )
    goto LABEL_128;
  v27 = (char)*v5;
  switch ( v27 )
  {
    case ' ':
      if ( v8 - 1 >= 0xB )
        goto LABEL_130;
      if ( v8 - 1 > 7 || v8 <= 8 && ((1 << v8) & 0x10A) != 0 )
      {
        v28 = 48;
        goto LABEL_55;
      }
LABEL_134:
      sub_6806F24((__int64)"format specifier requires signed argument");
    case '-':
      if ( v8 - 1 >= 0xB )
        goto LABEL_130;
      if ( v8 - 1 > 7 || v8 <= 8 && ((1 << v8) & 0x10A) != 0 )
      {
        v28 = 16;
        goto LABEL_55;
      }
      goto LABEL_134;
    case '+':
      if ( v8 - 1 >= 0xB )
        goto LABEL_130;
      if ( v8 - 1 > 7 || v8 <= 8 && ((1 << v8) & 0x10A) != 0 )
      {
        v28 = 32;
LABEL_55:
        v25 |= v28;
        ++v5;
        *(_WORD *)((char *)&v63 + 1) = v25;
        break;
      }
      goto LABEL_134;
  }
  if ( v5 == a4 )
    goto LABEL_128;
  v29 = *v5;
  if ( v29 == 35 )
  {
    if ( v8 - 1 >= 0xB )
      goto LABEL_130;
    v25 |= 0x80u;
    ++v5;
    *(_WORD *)((char *)&v63 + 1) = v25;
    if ( v5 == a4 )
      goto LABEL_128;
    v29 = *v5;
  }
  if ( v29 == 48 )
  {
    if ( v8 - 1 >= 0xB )
      goto LABEL_130;
    if ( (v25 & 0xF) == 0 )
      *(_WORD *)((char *)&v63 + 1) = v25 & 0xF0 | 4;
    ++v5;
    BYTE3(v63) = 48;
    if ( v5 == a4 )
LABEL_128:
      sub_6806F24((__int64)"missing '}' in format string");
  }
  v30 = (unsigned __int8 *)sub_6810B50(v5, a4, v60);
  if ( v30 == a4 )
    goto LABEL_128;
  v31 = *v30;
  v17 = v30;
  if ( v31 == 46 )
  {
    v32 = (unsigned __int8 *)sub_6810CC0(v30, a4, v60);
    if ( v32 == a4 )
      goto LABEL_128;
    v17 = v32;
    v31 = *v32;
  }
  if ( v31 == 76 )
  {
    if ( v61 - 1 < 0xB )
    {
      ++v17;
      *(_WORD *)(v60[0] + 9LL) |= 0x100u;
      goto LABEL_73;
    }
LABEL_130:
    sub_6806F24((__int64)"format specifier requires numeric argument");
  }
LABEL_73:
  if ( v17 == a4 )
    goto LABEL_128;
  if ( *v17 != 125 )
  {
    v19 = sub_250DE24();
    if ( !v19 )
      goto LABEL_131;
    ++v17;
LABEL_77:
    *(_BYTE *)(v60[0] + 8LL) = v19;
  }
  if ( v17 == a4 || *v17 != 125 )
    goto LABEL_128;
  v33 = a1[4];
  v34 = a1[7];
  switch ( v8 )
  {
    case 1u:
      if ( (LODWORD(v10) & 0x80000000) != 0 )
      {
        LODWORD(v10) = -LODWORD(v10);
        v35 = 0x100002D00000000LL;
      }
      else
      {
        v35 = (unsigned __int64)dword_AFDED0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7] << 32;
      }
      v37 = v35 | LODWORD(v10);
      v36 = a1[4];
      goto LABEL_118;
    case 2u:
      v36 = a1[4];
      v37 = LODWORD(v10) | ((unsigned __int64)dword_AFDED0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7] << 32);
LABEL_118:
      v41 = sub_53DCC60(v36, v37, &v62, a1[7], v34);
      goto LABEL_123;
    case 3u:
      v38 = LODWORD(v10) | ((unsigned __int64)v11 << 32);
      if ( (v38 & 0x8000000000000000LL) != 0 )
      {
        v38 = -(__int64)v38;
        v40 = 16777261LL;
      }
      else
      {
        v39 = *(unsigned __int16 *)((char *)&v63 + 1);
LABEL_87:
        v40 = dword_AFDED0[(v39 >> 4) & 7];
      }
      v41 = sub_6811588(a1[4], v38, v40, &v62, v34);
      goto LABEL_123;
    case 4u:
      v39 = *(unsigned __int16 *)((char *)&v63 + 1);
      v38 = LODWORD(v10) | ((unsigned __int64)v11 << 32);
      goto LABEL_87;
    case 5u:
      v42 = LODWORD(v10) | ((unsigned __int64)v11 << 32);
      v43 = v58;
      if ( v58 < 0 )
      {
        v54 = v42 == 0;
        v42 = -(__int64)v42;
        v43 = -(v58 + !v54);
        v44 = 16777261;
      }
      else
      {
        v44 = dword_AFDED0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7];
      }
      v64 = v42;
      v65 = v43;
      goto LABEL_122;
    case 6u:
      v64 = __PAIR64__(v11, LODWORD(v10));
      v44 = dword_AFDED0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7];
      v65 = v58;
LABEL_122:
      v66 = v44;
      v41 = sub_681244C(v33, &v64, &v62, v34);
      goto LABEL_123;
    case 7u:
      if ( ((unsigned __int8)v63 | 0x10) == 0x10 )
      {
        v45 = "true";
        if ( LOBYTE(v10) )
          v46 = 4LL;
        else
          v46 = 5LL;
        if ( !LOBYTE(v10) )
          v45 = "false";
        v47 = a1[4];
        v64 = (unsigned __int64)v45;
        v65 = v46;
        v41 = sub_680B3F4(v47, (unsigned int *)&v62, v46, v46, &v64);
      }
      else
      {
        v41 = sub_53DCC60(
                a1[4],
                LOBYTE(v10) | ((unsigned __int64)dword_AFDED0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7] << 32),
                &v62,
                0LL,
                v34);
      }
      goto LABEL_123;
    case 8u:
      v41 = sub_53DCA98(a1[4], LODWORD(v10), &v62, a1[7]);
      goto LABEL_123;
    case 9u:
      v41 = sub_68138DC(a1[4], v62, v63, a1[7], v10);
      goto LABEL_123;
    case 0xAu:
      v41 = sub_6813C04(a1[4], v62, v63, a1[7], COERCE_DOUBLE(LODWORD(v10) | ((unsigned __int64)v11 << 32)));
      goto LABEL_123;
    case 0xBu:
      *(_QWORD *)&v59 = LODWORD(v10) | ((unsigned __int64)v11 << 32);
      *((_QWORD *)&v59 + 1) = v58;
      v41 = sub_680DF58(a1[4], v62, v63, a1[7], v59);
      goto LABEL_123;
    case 0xCu:
      if ( (unsigned int)(unsigned __int8)v63 - 16 >= 2 && (_BYTE)v63 )
        goto LABEL_131;
      v48 = (const char *)(LODWORD(v10) | ((unsigned __int64)v11 << 32));
      if ( ((unsigned __int8)v63 & 0xEF) != 0 )
      {
        v49 = 2LL;
        v50 = (unsigned __int64)v48;
        do
        {
          v51 = v50 > 0xF;
          ++v49;
          v50 >>= 4;
        }
        while ( v51 );
LABEL_115:
        v53 = a1[4];
        v64 = (unsigned __int64)v48;
        LODWORD(v65) = v49 - 2;
        v41 = sub_680F9F8(v53, (unsigned int *)&v62, v49, v49, (__int64)&v64);
      }
      else
      {
        v56 = strlen(v48);
        v41 = sub_250E9D8(v33, v48, v56, &v62, v57);
      }
LABEL_123:
      v33 = v41;
LABEL_124:
      *v12 = v33;
      break;
    case 0xDu:
      if ( ((unsigned __int8)v63 & 0xEF) != 0 )
        goto LABEL_131;
      v41 = sub_250E9D8(a1[4], LODWORD(v10) | ((unsigned __int64)v11 << 32), v58, &v62, v34);
      goto LABEL_123;
    case 0xEu:
      if ( (_BYTE)v63 && (unsigned __int8)v63 != 17 )
        goto LABEL_131;
      v48 = (const char *)(LODWORD(v10) | ((unsigned __int64)v11 << 32));
      v49 = 2LL;
      v52 = (unsigned __int64)v48;
      do
      {
        v51 = v52 > 0xF;
        ++v49;
        v52 >>= 4;
      }
      while ( v51 );
      goto LABEL_115;
    default:
      goto LABEL_124;
  }
  return v17;
}


================================================================================
Function: sub_6810924 (0x6810924)
================================================================================

unsigned __int8 *__fastcall sub_6810924(unsigned __int64 a1, unsigned __int8 *a2, _DWORD *a3)
{
  int v3; // w11
  int v7; // w8
  unsigned __int8 *result; // x0
  unsigned __int8 *v9; // x8
  int v10; // w9
  int v11; // t1
  unsigned __int8 *v12; // x12
  unsigned __int8 *v13; // x9
  unsigned int v14; // w10
  int v15; // t1
  int v16; // w9

  v3 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v3 - 48) <= 9 )
  {
    if ( v3 == 48 )
    {
      v7 = 0;
      result = (unsigned __int8 *)(a1 + 1);
    }
    else
    {
      v7 = 0;
      v12 = (unsigned __int8 *)(a1 + 1);
      v13 = &a2[~a1 + a1];
      while ( 1 )
      {
        v14 = v7;
        v7 = v3 + 10 * v7 - 48;
        if ( v12 == a2 )
          break;
        v15 = *v12++;
        v3 = v15;
        if ( (unsigned int)(v15 - 48) >= 0xA )
        {
          v13 = v12 - 2;
          result = v12 - 1;
          goto LABEL_18;
        }
      }
      result = a2;
LABEL_18:
      if ( (__int64)&result[-a1] >= 10
        && (&result[-a1] != (unsigned __int8 *)&byte_9[1]
         || ((unsigned int)((char)*v13 - 48) + 10 * (unsigned __int64)v14) >> 31) )
      {
        v7 = 0x7FFFFFFF;
      }
    }
    if ( result != a2 )
    {
      v16 = *result;
      if ( v16 == 58 || v16 == 125 )
      {
        if ( *(int *)(*(_QWORD *)a3 + 24LL) >= 1 )
          sub_6806F24((__int64)"cannot switch from automatic to manual argument indexing");
        *(_DWORD *)(*(_QWORD *)a3 + 24LL) = -1;
        goto LABEL_27;
      }
    }
LABEL_28:
    sub_6806F24((__int64)"invalid format string");
  }
  if ( v3 != 95 && (v3 & 0xFFFFFFDF) - 65 > 0x19 )
    goto LABEL_28;
  v9 = (unsigned __int8 *)(a1 + 1);
  while ( v9 != a2 )
  {
    v11 = *v9++;
    v10 = v11;
    if ( (unsigned int)(v11 - 48) >= 0xA && v10 != 95 && (v10 & 0xFFFFFFDF) - 65 >= 0x1A )
    {
      a2 = v9 - 1;
      break;
    }
  }
  v7 = sub_6810A9C(*(_QWORD *)a3, a1, &a2[-a1]);
  result = a2;
LABEL_27:
  a3[2] = v7;
  return result;
}


================================================================================
Function: sub_6810A9C (0x6810A9C)
================================================================================

__int64 __fastcall sub_6810A9C(__int64 a1, const void *a2, size_t a3)
{
  __int64 v3; // x8
  bool v4; // nf
  __int64 v5; // x8
  _QWORD *v6; // x8
  __int64 v7; // x23
  unsigned int *v10; // x24
  const char *v11; // x22
  size_t v12; // x0
  bool v13; // zf
  size_t v14; // x2
  size_t v15; // x21
  __int64 result; // x0

  v3 = *(_QWORD *)(a1 + 40);
  if ( (v3 & 0x4000000000000000LL) == 0 )
    goto LABEL_15;
  v4 = v3 < 0;
  v5 = -32LL;
  if ( !v4 )
    v5 = -16LL;
  v6 = (_QWORD *)(*(_QWORD *)(a1 + 48) + v5);
  v7 = v6[1];
  if ( !v7 )
    goto LABEL_15;
  v10 = (unsigned int *)(*v6 + 8LL);
  while ( 1 )
  {
    v11 = (const char *)*((_QWORD *)v10 - 1);
    v12 = strlen(v11);
    v13 = v12 == a3;
    v14 = v12 >= a3 ? a3 : v12;
    if ( v14 )
    {
      v15 = v12;
      v13 = !memcmp(v11, a2, v14) && v15 == a3;
    }
    if ( v13 )
      break;
    v10 += 4;
    if ( !--v7 )
      goto LABEL_15;
  }
  result = *v10;
  if ( (result & 0x80000000) != 0 )
LABEL_15:
    sub_6806F24((__int64)"argument not found");
  return result;
}


================================================================================
Function: sub_6810B50 (0x6810B50)
================================================================================

unsigned __int8 *__fastcall sub_6810B50(unsigned __int64 a1, unsigned __int8 *a2, int **a3)
{
  unsigned __int8 *v3; // x19
  int v4; // w11
  int v5; // w8
  unsigned __int8 *v6; // x12
  unsigned __int8 *v7; // x9
  unsigned int v8; // w10
  int v9; // t1
  unsigned __int8 *v10; // x20
  int v11; // w8
  int **v13; // [xsp+0h] [xbp-10h] BYREF

  v3 = a2;
  v4 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v4 - 48) > 9 )
  {
    if ( v4 != 123 )
      return (unsigned __int8 *)a1;
    v10 = (unsigned __int8 *)(a1 + 1);
    if ( (unsigned __int8 *)(a1 + 1) != a2 )
    {
      v11 = *v10;
      v13 = a3;
      if ( v11 == 58 || v11 == 125 )
      {
        sub_6811038(&v13);
        if ( v10 == v3 )
          goto LABEL_22;
      }
      else
      {
        v10 = (unsigned __int8 *)sub_6810E78(a1 + 1, a2, &v13);
        if ( v10 == v3 )
          goto LABEL_22;
      }
      if ( *v10 == 125 )
        return v10 + 1;
    }
LABEL_22:
    sub_6806F24((__int64)"invalid format string");
  }
  v5 = 0;
  v6 = (unsigned __int8 *)(a1 + 1);
  v7 = &a2[~a1 + a1];
  while ( 1 )
  {
    v8 = v5;
    v5 = v4 + 10 * v5 - 48;
    if ( v6 == a2 )
      break;
    v9 = *v6++;
    v4 = v9;
    if ( (unsigned int)(v9 - 48) >= 0xA )
    {
      v7 = v6 - 2;
      v3 = v6 - 1;
      break;
    }
  }
  if ( (__int64)&v3[-a1] >= 10
    && (&v3[-a1] != (unsigned __int8 *)&byte_9[1] || ((unsigned int)((char)*v7 - 48) + 10 * (unsigned __int64)v8) >> 31)
    || v5 == -1 )
  {
    sub_6806F24((__int64)"number is too big");
  }
  **a3 = v5;
  return v3;
}


================================================================================
Function: sub_6810CC0 (0x6810CC0)
================================================================================

unsigned __int8 *__fastcall sub_6810CC0(__int64 a1, unsigned __int8 *a2, _DWORD *a3)
{
  char *v3; // x9
  unsigned __int8 *v5; // x19
  int v6; // w12
  int v7; // w8
  unsigned __int8 *v8; // x13
  unsigned __int8 *v9; // x10
  unsigned int v10; // w11
  int v11; // t1
  __int64 v12; // x9
  unsigned __int8 *v13; // x21
  int v14; // w8
  unsigned __int8 *v15; // x21
  int v16; // t1
  unsigned int v17; // w8
  _DWORD *v19; // [xsp+0h] [xbp-10h] BYREF

  v3 = (char *)(a1 + 1);
  if ( (unsigned __int8 *)(a1 + 1) == a2 )
    goto LABEL_25;
  v5 = a2;
  v6 = (unsigned __int8)*v3;
  if ( (unsigned int)(*v3 - 48) > 9 )
  {
    if ( v6 == 123 )
    {
      v13 = (unsigned __int8 *)(a1 + 2);
      if ( (unsigned __int8 *)(a1 + 2) == a2 )
        goto LABEL_26;
      v14 = *v13;
      v19 = a3;
      if ( v14 == 58 || v14 == 125 )
      {
        sub_68113C0(&v19);
        if ( v13 == v5 )
          goto LABEL_26;
      }
      else
      {
        v13 = (unsigned __int8 *)sub_6811200(a1 + 2, a2, &v19);
        if ( v13 == v5 )
          goto LABEL_26;
      }
      v16 = *v13;
      v15 = v13 + 1;
      if ( v16 == 125 )
      {
        v5 = v15;
        goto LABEL_21;
      }
LABEL_26:
      sub_6806F24((__int64)"invalid format string");
    }
LABEL_25:
    sub_6806F24((__int64)"missing precision specifier");
  }
  v7 = 0;
  v8 = (unsigned __int8 *)(a1 + 2);
  v9 = &a2[~(unsigned __int64)v3 + (_QWORD)v3];
  while ( 1 )
  {
    v10 = v7;
    v7 = 10 * v7 + (char)v6 - 48;
    if ( v8 == a2 )
      break;
    v11 = *v8++;
    LOBYTE(v6) = v11;
    if ( (unsigned int)(v11 - 48) >= 0xA )
    {
      v9 = v8 - 2;
      v5 = v8 - 1;
      break;
    }
  }
  v12 = v5 - (unsigned __int8 *)v3;
  if ( v12 >= 10 && (v12 != 10 || ((unsigned int)((char)*v9 - 48) + 10 * (unsigned __int64)v10) >> 31) || v7 == -1 )
    sub_6806F24((__int64)"number is too big");
  *(_DWORD *)(*(_QWORD *)a3 + 4LL) = v7;
LABEL_21:
  v17 = a3[6];
  if ( v17 <= 0xE && ((1 << v17) & 0x41FE) != 0 )
    sub_6806F24((__int64)"precision not allowed for this argument type");
  return v5;
}


================================================================================
Function: sub_6810E78 (0x6810E78)
================================================================================

unsigned __int8 *__fastcall sub_6810E78(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3)
{
  int v3; // w12
  unsigned int v4; // w8
  unsigned __int8 *v5; // x19
  unsigned __int8 *v6; // x8
  int v7; // w10
  int v8; // t1
  _DWORD **v9; // x21
  unsigned __int8 *v10; // x13
  unsigned __int8 *v11; // x10
  unsigned int v12; // w11
  int v13; // t1
  int v14; // w9
  _QWORD v16[2]; // [xsp+0h] [xbp-30h] BYREF
  int v17; // [xsp+10h] [xbp-20h]

  v3 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v3 - 48) <= 9 )
  {
    if ( v3 == 48 )
    {
      v4 = 0;
      v5 = (unsigned __int8 *)(a1 + 1);
    }
    else
    {
      v4 = 0;
      v10 = (unsigned __int8 *)(a1 + 1);
      v11 = &a2[~a1 + a1];
      while ( 1 )
      {
        v12 = v4;
        v4 = v3 + 10 * v4 - 48;
        if ( v10 == a2 )
          break;
        v13 = *v10++;
        v3 = v13;
        if ( (unsigned int)(v13 - 48) >= 0xA )
        {
          v11 = v10 - 2;
          v5 = v10 - 1;
          goto LABEL_20;
        }
      }
      v5 = a2;
LABEL_20:
      if ( (__int64)&v5[-a1] >= 10
        && (&v5[-a1] != (unsigned __int8 *)&byte_9[1]
         || ((unsigned int)((char)*v11 - 48) + 10 * (unsigned __int64)v12) >> 31) )
      {
        v4 = 0x7FFFFFFF;
      }
    }
    if ( v5 != a2 )
    {
      v14 = *v5;
      if ( v14 == 58 || v14 == 125 )
      {
        sub_6811118(a3, v4);
        return v5;
      }
    }
LABEL_29:
    sub_6806F24((__int64)"invalid format string");
  }
  if ( v3 != 95 && (v3 & 0xFFFFFFDF) - 65 > 0x19 )
    goto LABEL_29;
  v6 = (unsigned __int8 *)(a1 + 1);
  while ( v6 != a2 )
  {
    v8 = *v6++;
    v7 = v8;
    if ( (unsigned int)(v8 - 48) >= 0xA && v7 != 95 && (v7 & 0xFFFFFFDF) - 65 >= 0x1A )
    {
      v5 = v6 - 1;
      goto LABEL_13;
    }
  }
  v5 = a2;
LABEL_13:
  v9 = *(_DWORD ***)a3;
  sub_250E7F8(v16, *(_QWORD *)(*(_QWORD *)a3 + 16LL) + 8LL, a1, &v5[-a1]);
  if ( !v17 )
    sub_6806F24((__int64)"argument not found");
  **v9 = sub_250E72C(v16);
  return v5;
}


================================================================================
Function: sub_6811038 (0x6811038)
================================================================================

__int64 __fastcall sub_6811038(__int64 *a1)
{
  __int64 v1; // x20
  __int64 v2; // x10
  __int64 v3; // x8
  __int64 v4; // x9
  unsigned __int64 v5; // x10
  __int64 v6; // x8
  __int128 v7; // q0
  __int64 result; // x0
  __int128 v9; // [xsp+0h] [xbp-30h] BYREF
  int v10; // [xsp+10h] [xbp-20h]

  v1 = *a1;
  v2 = *(_QWORD *)(*a1 + 8);
  v3 = *(unsigned int *)(v2 + 16);
  if ( (v3 & 0x80000000) != 0 )
    sub_6806F24((__int64)"cannot switch from manual to automatic argument indexing");
  v4 = *(_QWORD *)(v1 + 16);
  *(_DWORD *)(v2 + 16) = v3 + 1;
  v5 = *(_QWORD *)(v4 + 8);
  if ( (v5 & 0x8000000000000000LL) == 0 )
  {
    if ( (unsigned int)v3 <= 0xE )
    {
      v10 = (v5 >> (4 * (unsigned __int8)v3)) & 0xF;
      if ( v10 )
      {
        v9 = *(_OWORD *)(*(_QWORD *)(v4 + 16) + 16 * v3);
        goto LABEL_8;
      }
    }
LABEL_9:
    sub_6806F24((__int64)"argument not found");
  }
  if ( (int)v3 >= (int)v5 )
    goto LABEL_9;
  v6 = *(_QWORD *)(v4 + 16) + 32 * v3;
  v7 = *(_OWORD *)v6;
  LODWORD(v6) = *(_DWORD *)(v6 + 16);
  v9 = v7;
  v10 = v6;
  if ( !(_DWORD)v6 )
    goto LABEL_9;
LABEL_8:
  result = sub_250E72C(&v9);
  **(_DWORD **)v1 = result;
  return result;
}


================================================================================
Function: sub_6811118 (0x6811118)
================================================================================

unsigned __int64 __fastcall sub_6811118(__int64 *a1, int a2)
{
  __int64 v2; // x20
  __int64 v3; // x8
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  __int64 v6; // x8
  __int128 v7; // q0
  unsigned __int64 result; // x0
  __int128 v9; // [xsp+0h] [xbp-30h] BYREF
  int v10; // [xsp+10h] [xbp-20h]

  v2 = *a1;
  v3 = *(_QWORD *)(*a1 + 8);
  if ( *(int *)(v3 + 16) >= 1 )
    sub_6806F24((__int64)"cannot switch from automatic to manual argument indexing");
  *(_DWORD *)(v3 + 16) = -1;
  v4 = *(_QWORD *)(v2 + 16);
  v5 = *(_QWORD *)(v4 + 8);
  if ( (v5 & 0x8000000000000000LL) == 0 )
  {
    if ( a2 <= 14 )
    {
      v10 = (v5 >> (4 * (unsigned __int8)a2)) & 0xF;
      if ( v10 )
      {
        v9 = *(_OWORD *)(*(_QWORD *)(v4 + 16) + 16LL * a2);
        goto LABEL_8;
      }
    }
LABEL_9:
    sub_6806F24((__int64)"argument not found");
  }
  if ( (int)v5 <= a2 )
    goto LABEL_9;
  v6 = *(_QWORD *)(v4 + 16) + 32LL * a2;
  v7 = *(_OWORD *)v6;
  LODWORD(v6) = *(_DWORD *)(v6 + 16);
  v9 = v7;
  v10 = v6;
  if ( !(_DWORD)v6 )
    goto LABEL_9;
LABEL_8:
  result = sub_250E72C((unsigned int *)&v9, a2);
  **(_DWORD **)v2 = result;
  return result;
}


================================================================================
Function: sub_6811200 (0x6811200)
================================================================================

unsigned __int8 *__fastcall sub_6811200(unsigned __int64 a1, unsigned __int8 *a2, __int64 *a3)
{
  int v3; // w12
  unsigned int v4; // w8
  unsigned __int8 *v5; // x19
  unsigned __int8 *v6; // x8
  int v7; // w10
  int v8; // t1
  __int64 v9; // x21
  unsigned __int8 *v10; // x13
  unsigned __int8 *v11; // x10
  unsigned int v12; // w11
  int v13; // t1
  int v14; // w9
  _QWORD v16[2]; // [xsp+0h] [xbp-30h] BYREF
  int v17; // [xsp+10h] [xbp-20h]

  v3 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v3 - 48) <= 9 )
  {
    if ( v3 == 48 )
    {
      v4 = 0;
      v5 = (unsigned __int8 *)(a1 + 1);
    }
    else
    {
      v4 = 0;
      v10 = (unsigned __int8 *)(a1 + 1);
      v11 = &a2[~a1 + a1];
      while ( 1 )
      {
        v12 = v4;
        v4 = v3 + 10 * v4 - 48;
        if ( v10 == a2 )
          break;
        v13 = *v10++;
        v3 = v13;
        if ( (unsigned int)(v13 - 48) >= 0xA )
        {
          v11 = v10 - 2;
          v5 = v10 - 1;
          goto LABEL_20;
        }
      }
      v5 = a2;
LABEL_20:
      if ( (__int64)&v5[-a1] >= 10
        && (&v5[-a1] != (unsigned __int8 *)&byte_9[1]
         || ((unsigned int)((char)*v11 - 48) + 10 * (unsigned __int64)v12) >> 31) )
      {
        v4 = 0x7FFFFFFF;
      }
    }
    if ( v5 != a2 )
    {
      v14 = *v5;
      if ( v14 == 58 || v14 == 125 )
      {
        sub_68114A0(a3, v4);
        return v5;
      }
    }
LABEL_29:
    sub_6806F24((__int64)"invalid format string");
  }
  if ( v3 != 95 && (v3 & 0xFFFFFFDF) - 65 > 0x19 )
    goto LABEL_29;
  v6 = (unsigned __int8 *)(a1 + 1);
  while ( v6 != a2 )
  {
    v8 = *v6++;
    v7 = v8;
    if ( (unsigned int)(v8 - 48) >= 0xA && v7 != 95 && (v7 & 0xFFFFFFDF) - 65 >= 0x1A )
    {
      v5 = v6 - 1;
      goto LABEL_13;
    }
  }
  v5 = a2;
LABEL_13:
  v9 = *a3;
  sub_250E7F8(v16, *(_QWORD *)(*a3 + 16) + 8LL, a1, &v5[-a1]);
  if ( !v17 )
    sub_6806F24((__int64)"argument not found");
  *(_DWORD *)(*(_QWORD *)v9 + 4LL) = sub_250E90C(v16);
  return v5;
}


================================================================================
Function: sub_68113C0 (0x68113C0)
================================================================================

__int64 __fastcall sub_68113C0(__int64 a1)
{
  _QWORD *v1; // x20
  __int64 v2; // x10
  __int64 v3; // x8
  __int64 v4; // x9
  unsigned __int64 v5; // x10
  __int64 v6; // x8
  __int128 v7; // q0
  __int64 result; // x0
  __int128 v9; // [xsp+0h] [xbp-30h] BYREF
  int v10; // [xsp+10h] [xbp-20h]

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
  v3 = *(unsigned int *)(v2 + 16);
  if ( (v3 & 0x80000000) != 0 )
    sub_6806F24((__int64)"cannot switch from manual to automatic argument indexing");
  v4 = v1[2];
  *(_DWORD *)(v2 + 16) = v3 + 1;
  v5 = *(_QWORD *)(v4 + 8);
  if ( (v5 & 0x8000000000000000LL) == 0 )
  {
    if ( (unsigned int)v3 <= 0xE )
    {
      v10 = (v5 >> (4 * (unsigned __int8)v3)) & 0xF;
      if ( v10 )
      {
        v9 = *(_OWORD *)(*(_QWORD *)(v4 + 16) + 16 * v3);
        goto LABEL_8;
      }
    }
LABEL_9:
    sub_6806F24((__int64)"argument not found");
  }
  if ( (int)v3 >= (int)v5 )
    goto LABEL_9;
  v6 = *(_QWORD *)(v4 + 16) + 32 * v3;
  v7 = *(_OWORD *)v6;
  LODWORD(v6) = *(_DWORD *)(v6 + 16);
  v9 = v7;
  v10 = v6;
  if ( !(_DWORD)v6 )
    goto LABEL_9;
LABEL_8:
  result = sub_250E90C(&v9);
  *(_DWORD *)(*v1 + 4LL) = result;
  return result;
}


================================================================================
Function: sub_68114A0 (0x68114A0)
================================================================================

unsigned __int64 __fastcall sub_68114A0(__int64 a1, int a2)
{
  _QWORD *v2; // x20
  __int64 v3; // x8
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  __int64 v6; // x8
  __int128 v7; // q0
  unsigned __int64 result; // x0
  __int128 v9; // [xsp+0h] [xbp-30h] BYREF
  int v10; // [xsp+10h] [xbp-20h]

  v2 = *(_QWORD **)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
  if ( *(int *)(v3 + 16) >= 1 )
    sub_6806F24((__int64)"cannot switch from automatic to manual argument indexing");
  *(_DWORD *)(v3 + 16) = -1;
  v4 = v2[2];
  v5 = *(_QWORD *)(v4 + 8);
  if ( (v5 & 0x8000000000000000LL) == 0 )
  {
    if ( a2 <= 14 )
    {
      v10 = (v5 >> (4 * (unsigned __int8)a2)) & 0xF;
      if ( v10 )
      {
        v9 = *(_OWORD *)(*(_QWORD *)(v4 + 16) + 16LL * a2);
        goto LABEL_8;
      }
    }
LABEL_9:
    sub_6806F24((__int64)"argument not found");
  }
  if ( (int)v5 <= a2 )
    goto LABEL_9;
  v6 = *(_QWORD *)(v4 + 16) + 32LL * a2;
  v7 = *(_OWORD *)v6;
  LODWORD(v6) = *(_DWORD *)(v6 + 16);
  v9 = v7;
  v10 = v6;
  if ( !(_DWORD)v6 )
    goto LABEL_9;
LABEL_8:
  result = sub_250E90C((unsigned int *)&v9, a2);
  *(_DWORD *)(*v2 + 4LL) = result;
  return result;
}


================================================================================
Function: sub_6811588 (0x6811588)
================================================================================

__int64 __fastcall sub_6811588(__int64 a1, unsigned __int64 a2, unsigned int a3, unsigned int *a4, __int64 a5)
{
  int v5; // w23
  unsigned int v7; // w21
  unsigned __int64 v8; // x20
  __int64 v9; // x19
  __int16 v10; // w10
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x8
  int v13; // w12
  __int64 v14; // x25
  int v15; // w10
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x11
  __int16 v18; // w9
  int v19; // w8
  __int64 v20; // x25
  unsigned __int64 v21; // x11
  unsigned __int64 v22; // x8
  bool v23; // cc
  unsigned __int64 v24; // x8
  int v25; // w13
  char *v26; // x26
  unsigned __int64 v27; // x12
  int v28; // w9
  __int64 v29; // x27
  __int16 v30; // w10
  int v31; // w8
  __int64 v32; // x25
  unsigned __int64 v33; // x13
  unsigned __int64 v34; // x8
  unsigned __int64 v35; // x8
  int v36; // w14
  unsigned __int64 v37; // x11
  int v38; // w10
  unsigned __int64 v39; // x12
  __int64 v40; // x25
  unsigned __int64 v41; // x8
  __int16 v42; // w10
  int v43; // w9
  int v44; // w8
  unsigned __int64 v45; // x8
  char *v46; // x26
  int v47; // w10
  __int64 v48; // x12
  unsigned __int64 v49; // x11
  unsigned __int64 v50; // x9
  unsigned __int64 v51; // x27
  __int64 v52; // x9
  bool v53; // cf
  unsigned __int64 v54; // x9
  unsigned __int64 v55; // x25
  char v56; // w8
  unsigned __int64 v57; // x23
  __int64 v58; // x8
  __int64 v59; // x1
  __int64 v60; // x9
  unsigned int v62; // w21
  __int64 v63; // x8
  __int64 v64; // x10
  _BYTE *v65; // x8
  char v66; // w10
  __int64 v67; // x9
  __int64 v68; // x8
  __int64 v69; // x1
  unsigned int v70; // w21
  __int64 v71; // x8
  __int64 v72; // x9
  __int64 v73; // x9
  const char *v74; // x8
  _BYTE *v75; // x9
  unsigned __int64 v76; // x10
  __int64 v77; // x9
  __int64 v78; // x8
  __int64 v79; // x1
  char *v80; // x1
  char v81; // w9
  const char *v82; // x9
  char *v83; // x8
  unsigned __int64 v84; // x10
  unsigned int v85; // w21
  __int64 v86; // x8
  __int64 v87; // x10
  _BYTE *v88; // x8
  char v89; // w10
  __int64 v90; // x9
  __int64 v91; // x8
  __int64 v92; // x1
  unsigned int v93; // w21
  char *v94; // x8
  unsigned __int64 v95; // x9
  unsigned __int64 v96; // x13
  __int64 v97; // x9
  __int64 v98; // x8
  __int64 v99; // x1
  unsigned __int64 v100; // x8
  unsigned __int64 v101; // x28
  _BYTE *v102; // x22
  char v103; // w9
  unsigned __int64 v104; // x23
  unsigned int v105; // w21
  __int64 v106; // x9
  __int64 v107; // x8
  __int64 v108; // x1
  __int64 v109; // x9
  __int64 v110; // x8
  __int64 v111; // x1
  __int64 v112; // x8
  __int64 v113; // x21
  __int64 v114; // x10
  _BYTE *v115; // x8
  char v116; // w10
  char *v117; // x1
  char v118; // w9
  unsigned __int64 v119; // x8
  char v120; // w10
  __int64 v121; // x21
  __int64 v122; // x0
  __int64 v123; // x1
  _BYTE *v124; // x2
  char v125; // w9
  unsigned __int64 v127; // x8
  unsigned __int64 v128; // x28
  char v129; // w9
  unsigned __int64 v130; // x23
  unsigned int v131; // w21
  __int64 v132; // x9
  __int64 v133; // x8
  __int64 v134; // x1
  __int64 v135; // x9
  __int64 v136; // x8
  __int64 v137; // x1
  __int64 v138; // x8
  __int64 v139; // x10
  _BYTE *v140; // x8
  char v141; // w10
  char v142; // w9
  unsigned __int64 v143; // x8
  char v144; // w10
  __int64 v145; // x23
  _DWORD v146[2]; // [xsp+0h] [xbp-50h] BYREF
  unsigned __int64 v147; // [xsp+8h] [xbp-48h]
  unsigned __int64 v148; // [xsp+10h] [xbp-40h]
  unsigned __int64 v149; // [xsp+18h] [xbp-38h]
  int v150; // [xsp+20h] [xbp-30h]
  char v151; // [xsp+24h] [xbp-2Ch]

  v5 = *((unsigned __int8 *)a4 + 8);
  v7 = a3;
  v8 = a2;
  v9 = a1;
  switch ( *((_BYTE *)a4 + 8) )
  {
    case 0:
    case 1:
      v10 = *(_WORD *)((char *)a4 + 9);
      if ( (v10 & 0x100) != 0 )
      {
        sub_53DD748((__int64)v146, a5, 1);
        v9 = sub_53DD848(v9, v8, v7, a4, v146);
        if ( (v146[0] & 1) != 0 )
          sub_65ECAF4();
        return v9;
      }
      v11 = byte_102749E[__clz(a2 | 1) ^ 0x3F];
      v12 = *a4;
      v13 = a4[1];
      v14 = (__PAIR128__(v11, a2) - qword_10274E0[v11]) >> 64;
      if ( !((v13 + 1) | (unsigned int)v12) )
      {
        if ( a3 )
        {
          v93 = a3 & 0xFFFFFF;
          if ( (a3 & 0xFFFFFF) != 0 )
          {
            do
            {
              v98 = *(_QWORD *)(v9 + 16);
              v99 = v98 + 1;
              if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v98 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v9)(v9);
                v98 = *(_QWORD *)(v9 + 16);
                v99 = v98 + 1;
              }
              v97 = *(_QWORD *)(v9 + 8);
              *(_QWORD *)(v9 + 16) = v99;
              v23 = v93 > 0xFF;
              *(_BYTE *)(v97 + v98) = v93;
              v93 >>= 8;
            }
            while ( v23 );
          }
        }
        v80 = (char *)v146 + v14;
        if ( v8 < 0x64 )
        {
          v94 = (char *)v146 + v14;
          v95 = v8;
          if ( v8 <= 9 )
          {
LABEL_123:
            *(v94 - 1) = v95 + 48;
            return sub_53DDE58((unsigned __int64)v146, (__int64)v80, v9);
          }
        }
        else
        {
          v94 = (char *)v146 + v14;
          do
          {
            v23 = v8 >> 4 > 0x270;
            v95 = v8 / 0x64;
            v96 = v8 % 0x64;
            v8 /= 0x64uLL;
            *((_WORD *)v94 - 1) = *(_WORD *)&a00010203040506_1[2 * v96];
            v94 -= 2;
          }
          while ( v23 );
          if ( v95 <= 9 )
            goto LABEL_123;
        }
        *((_WORD *)v94 - 1) = *(_WORD *)&a00010203040506_1[2 * v95];
        return sub_53DDE58((unsigned __int64)v146, (__int64)v80, v9);
      }
      v15 = v10 & 0xF;
      v16 = (unsigned int)v14 + HIBYTE(a3);
      if ( v15 == 4 )
      {
        v17 = v12 - v16;
        if ( (unsigned int)v12 > (unsigned int)v16 )
        {
          v16 = (unsigned int)v12;
        }
        else
        {
          v17 = 0LL;
          v16 = (unsigned int)v16;
        }
      }
      else
      {
        v17 = (unsigned int)(v13 - v14);
        if ( v13 <= (int)v14 )
          v17 = 0LL;
        else
          v16 = v13 + HIBYTE(a3);
      }
      v53 = v12 >= v16;
      v143 = v12 - v16;
      if ( !v53 )
        v143 = 0LL;
      v146[0] = a3;
      v144 = byte_174D7F4[v15];
      v147 = v16;
      v148 = v17;
      v149 = a2;
      v150 = v14;
      v145 = v143 - (v143 >> v144);
      if ( v143 >> v144 )
        v9 = sub_250EF44(a1, v143 >> v144, (_BYTE *)a4 + 11);
      v122 = sub_68120F0(v146, v9);
      v9 = v122;
      if ( !v145 )
        return v9;
      v123 = v145;
      v124 = (char *)a4 + 11;
      return sub_250EF44(v122, v123, v124);
    case 2:
      v40 = 0LL;
      v41 = a2;
      do
      {
        v23 = v41 > 7;
        ++v40;
        v41 >>= 3;
      }
      while ( v23 );
      v42 = *(_WORD *)((char *)a4 + 9);
      v43 = a4[1];
      if ( (v42 & 0x80) != 0 && v43 <= (int)v40 && a2 )
      {
        if ( a3 )
          v44 = 12288;
        else
          v44 = 48;
        v7 = (v44 | a3) + 0x1000000;
      }
      v45 = *a4;
      v46 = (char *)v146 + v40 - 1;
      if ( (unsigned int)v45 | (v43 + 1) )
      {
        v47 = v42 & 0xF;
        v48 = v40 + ((unsigned __int64)v7 >> 24);
        v49 = (unsigned int)v40 + HIBYTE(v7);
        if ( v47 == 4 )
        {
          v50 = v45 - v49;
          if ( (unsigned int)v45 <= (unsigned int)v48 )
            v49 = (unsigned int)v48;
          else
            v49 = (unsigned int)v45;
          if ( (unsigned int)v45 <= (unsigned int)v48 )
            v51 = 0LL;
          else
            v51 = v50;
        }
        else if ( v43 <= (int)v40 )
        {
          v51 = 0LL;
        }
        else
        {
          v51 = (unsigned int)(v43 - v40);
          v49 = HIBYTE(v7) + v43;
        }
        v53 = v45 >= v49;
        v127 = v45 - v49;
        if ( v53 )
          v128 = v127;
        else
          v128 = 0LL;
        v102 = (char *)a4 + 11;
        v129 = byte_174D7F4[v47];
        v130 = v128 >> v129;
        if ( v128 >> v129 )
          v9 = sub_250EF44(a1, v128 >> v129, (_BYTE *)a4 + 11);
        v131 = v7 & 0xFFFFFF;
        if ( v131 )
        {
          do
          {
            v133 = *(_QWORD *)(v9 + 16);
            v134 = v133 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v133 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v133 = *(_QWORD *)(v9 + 16);
              v134 = v133 + 1;
            }
            v132 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v134;
            v53 = v131 >= 0x100;
            *(_BYTE *)(v132 + v133) = v131;
            v131 >>= 8;
          }
          while ( v53 );
        }
        for ( ; v51; *(_BYTE *)(v135 + v136) = 48 )
        {
          v136 = *(_QWORD *)(v9 + 16);
          v137 = v136 + 1;
          if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v136 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v9)(v9);
            v136 = *(_QWORD *)(v9 + 16);
            v137 = v136 + 1;
          }
          --v51;
          v135 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v137;
        }
        v138 = *(_QWORD *)(v9 + 16);
        v113 = v128 - v130;
        if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v138 + v40) )
        {
          v139 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v138 + v40;
          if ( v139 )
          {
            v140 = (_BYTE *)(v139 + v138 + v40 - 1);
            do
            {
              v141 = v8 & 7 | 0x30;
              v53 = v8 >= 8;
              v8 >>= 3;
              *v140-- = v141;
            }
            while ( v53 );
            goto LABEL_193;
          }
        }
        v117 = (char *)v146 + v40;
        do
        {
          v142 = v8 & 7 | 0x30;
          v23 = v8 > 7;
          v8 >>= 3;
          *v46-- = v142;
        }
        while ( v23 );
        goto LABEL_192;
      }
      if ( v7 )
      {
        v85 = v7 & 0xFFFFFF;
        if ( v85 )
        {
          do
          {
            v91 = *(_QWORD *)(v9 + 16);
            v92 = v91 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v91 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v91 = *(_QWORD *)(v9 + 16);
              v92 = v91 + 1;
            }
            v90 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v92;
            v23 = v85 > 0xFF;
            *(_BYTE *)(v90 + v91) = v85;
            v85 >>= 8;
          }
          while ( v23 );
        }
      }
      v86 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v86 + v40) )
      {
        v87 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v86 + v40;
        if ( v87 )
        {
          v88 = (_BYTE *)(v87 + v86 + v40 - 1);
          do
          {
            v89 = v8 & 7 | 0x30;
            v53 = v8 >= 8;
            v8 >>= 3;
            *v88-- = v89;
          }
          while ( v53 );
          return v9;
        }
      }
      v80 = (char *)v146 + v40;
      do
      {
        v125 = v8 & 7 | 0x30;
        v23 = v8 > 7;
        v8 >>= 3;
        *v46-- = v125;
      }
      while ( v23 );
      return sub_53DDE58((unsigned __int64)v146, (__int64)v80, v9);
    case 3:
    case 4:
      v30 = *(_WORD *)((char *)a4 + 9);
      if ( (v30 & 0x80) != 0 )
      {
        if ( v5 == 4 )
          v31 = 22576;
        else
          v31 = 30768;
        if ( a3 )
          v31 <<= 8;
        v7 = (v31 | a3) + 0x2000000;
      }
      v32 = 0LL;
      v33 = (unsigned __int64)v7 >> 24;
      v34 = a2;
      do
      {
        v23 = v34 > 0xF;
        ++v32;
        ++v33;
        v34 >>= 4;
      }
      while ( v23 );
      v35 = *a4;
      v36 = a4[1];
      if ( (v36 + 1) | (unsigned int)v35 )
      {
        v37 = v32 + ((unsigned __int64)v7 >> 24);
        v38 = v30 & 0xF;
        if ( v38 == 4 )
        {
          if ( v33 <= v35 )
            v33 = *a4;
          if ( (unsigned int)v35 <= (unsigned int)v37 )
            v37 = (unsigned int)v37;
          else
            v37 = (unsigned int)v35;
          v39 = v33 - ((unsigned __int64)v7 >> 24) - v32;
        }
        else if ( v36 <= (int)v32 )
        {
          v39 = 0LL;
        }
        else
        {
          v39 = (unsigned int)(v36 - v32);
          v37 = v36 + HIBYTE(v7);
        }
        v53 = v35 >= v37;
        v119 = v35 - v37;
        if ( !v53 )
          v119 = 0LL;
        v146[0] = v7;
        v120 = byte_174D7F4[v38];
        v147 = v37;
        v148 = v39;
        v149 = a2;
        v150 = v32;
        v151 = (v32 | ((unsigned __int64)(v5 == 4) << 32)) >> 32;
        v121 = v119 - (v119 >> v120);
        if ( v119 >> v120 )
          v9 = sub_250EF44(a1, v119 >> v120, (_BYTE *)a4 + 11);
        v122 = sub_6812288(v146, v9);
        v9 = v122;
        if ( v121 )
        {
          v123 = v121;
          v124 = (char *)a4 + 11;
          return sub_250EF44(v122, v123, v124);
        }
        return v9;
      }
      if ( v7 )
      {
        v70 = v7 & 0xFFFFFF;
        if ( v70 )
        {
          do
          {
            v78 = *(_QWORD *)(v9 + 16);
            v79 = v78 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v78 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v78 = *(_QWORD *)(v9 + 16);
              v79 = v78 + 1;
            }
            v77 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v79;
            v23 = v70 > 0xFF;
            *(_BYTE *)(v77 + v78) = v70;
            v70 >>= 8;
          }
          while ( v23 );
        }
      }
      v71 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v71 + v32) )
      {
        v72 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v71 + v32;
        if ( v72 )
        {
          v73 = v72 + v71 + v32;
          if ( v5 == 4 )
            v74 = "0123456789ABCDEF";
          else
            v74 = "0123456789abcdef";
          v75 = (_BYTE *)(v73 - 1);
          do
          {
            v76 = v8 & 0xF;
            v53 = v8 >= 0x10;
            v8 >>= 4;
            *v75-- = v74[v76];
          }
          while ( v53 );
          return v9;
        }
      }
      v82 = "0123456789abcdef";
      v83 = (char *)&v146[-1] + v32 + 3;
      v80 = (char *)v146 + v32;
      if ( v5 == 4 )
        v82 = "0123456789ABCDEF";
      do
      {
        v84 = v8 & 0xF;
        v23 = v8 > 0xF;
        v8 >>= 4;
        *v83-- = v82[v84];
      }
      while ( v23 );
      return sub_53DDE58((unsigned __int64)v146, (__int64)v80, v9);
    case 5:
    case 6:
      v18 = *(_WORD *)((char *)a4 + 9);
      if ( (v18 & 0x80) != 0 )
      {
        if ( v5 == 6 )
          v19 = 16944;
        else
          v19 = 25136;
        if ( a3 )
          v19 <<= 8;
        v7 = (v19 | a3) + 0x2000000;
      }
      v20 = 0LL;
      v21 = (unsigned __int64)v7 >> 24;
      v22 = a2;
      do
      {
        v23 = v22 > 1;
        ++v20;
        ++v21;
        v22 >>= 1;
      }
      while ( v23 );
      v24 = *a4;
      v25 = a4[1];
      v26 = (char *)&v146[-1] + v20 + 3;
      if ( (v25 + 1) | (unsigned int)v24 )
      {
        v27 = v20 + ((unsigned __int64)v7 >> 24);
        v28 = v18 & 0xF;
        if ( v28 == 4 )
        {
          if ( (unsigned int)v24 <= (unsigned int)v27 )
            v27 = (unsigned int)v27;
          else
            v27 = (unsigned int)v24;
          if ( v21 <= v24 )
            v21 = *a4;
          v29 = v21 - ((unsigned __int64)v7 >> 24) - v20;
        }
        else if ( v25 <= (int)v20 )
        {
          v29 = 0LL;
        }
        else
        {
          v29 = (unsigned int)(v25 - v20);
          v27 = v25 + HIBYTE(v7);
        }
        v53 = v24 >= v27;
        v100 = v24 - v27;
        if ( v53 )
          v101 = v100;
        else
          v101 = 0LL;
        v102 = (char *)a4 + 11;
        v103 = byte_174D7F4[v28];
        v104 = v101 >> v103;
        if ( v101 >> v103 )
          v9 = sub_250EF44(a1, v101 >> v103, (_BYTE *)a4 + 11);
        v105 = v7 & 0xFFFFFF;
        if ( v105 )
        {
          do
          {
            v107 = *(_QWORD *)(v9 + 16);
            v108 = v107 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v107 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v107 = *(_QWORD *)(v9 + 16);
              v108 = v107 + 1;
            }
            v106 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v108;
            v53 = v105 >= 0x100;
            *(_BYTE *)(v106 + v107) = v105;
            v105 >>= 8;
          }
          while ( v53 );
        }
        for ( ; v29; *(_BYTE *)(v109 + v110) = 48 )
        {
          v110 = *(_QWORD *)(v9 + 16);
          v111 = v110 + 1;
          if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v110 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v9)(v9);
            v110 = *(_QWORD *)(v9 + 16);
            v111 = v110 + 1;
          }
          --v29;
          v109 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v111;
        }
        v112 = *(_QWORD *)(v9 + 16);
        v113 = v101 - v104;
        if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v112 + v20)
          && (v114 = *(_QWORD *)(v9 + 8), *(_QWORD *)(v9 + 16) = v112 + v20, v114) )
        {
          v115 = (_BYTE *)(v114 + v112 + v20 - 1);
          do
          {
            v116 = v8 & 1 | 0x30;
            v53 = v8 >= 2;
            v8 >>= 1;
            *v115-- = v116;
          }
          while ( v53 );
        }
        else
        {
          v117 = (char *)v146 + v20;
          do
          {
            v118 = v8 & 1 | 0x30;
            v23 = v8 > 1;
            v8 >>= 1;
            *v26-- = v118;
          }
          while ( v23 );
LABEL_192:
          v9 = sub_53DDE58((unsigned __int64)v146, (__int64)v117, v9);
        }
LABEL_193:
        if ( v113 )
        {
          v122 = v9;
          v123 = v113;
          v124 = v102;
          return sub_250EF44(v122, v123, v124);
        }
        return v9;
      }
      if ( v7 )
      {
        v62 = v7 & 0xFFFFFF;
        if ( v62 )
        {
          do
          {
            v68 = *(_QWORD *)(v9 + 16);
            v69 = v68 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v68 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v68 = *(_QWORD *)(v9 + 16);
              v69 = v68 + 1;
            }
            v67 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v69;
            v23 = v62 > 0xFF;
            *(_BYTE *)(v67 + v68) = v62;
            v62 >>= 8;
          }
          while ( v23 );
        }
      }
      v63 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v63 + v20) )
      {
        v64 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v63 + v20;
        if ( v64 )
        {
          v65 = (_BYTE *)(v64 + v63 + v20 - 1);
          do
          {
            v66 = v8 & 1 | 0x30;
            v53 = v8 >= 2;
            v8 >>= 1;
            *v65-- = v66;
          }
          while ( v53 );
          return v9;
        }
      }
      v80 = (char *)v146 + v20;
      do
      {
        v81 = v8 & 1 | 0x30;
        v23 = v8 > 1;
        v8 >>= 1;
        *v26-- = v81;
      }
      while ( v23 );
      return sub_53DDE58((unsigned __int64)v146, (__int64)v80, v9);
    case 0xF:
      v52 = *a4;
      v53 = v52 != 0;
      v54 = v52 - 1;
      if ( v53 )
        v55 = v54;
      else
        v55 = 0LL;
      v56 = byte_174D7F9[*(_WORD *)((_BYTE *)a4 + 9) & 0xF];
      v57 = v55 >> v56;
      if ( v55 >> v56 )
        v9 = sub_250EF44(a1, v55 >> v56, (_BYTE *)a4 + 11);
      v58 = *(_QWORD *)(v9 + 16);
      v59 = v58 + 1;
      if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v58 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v9)(v9);
        v58 = *(_QWORD *)(v9 + 16);
        v59 = v58 + 1;
      }
      v60 = *(_QWORD *)(v9 + 8);
      *(_QWORD *)(v9 + 16) = v59;
      *(_BYTE *)(v60 + v58) = v8;
      if ( v55 == v57 )
        return v9;
      return sub_250EF44(v9, v55 - v57, (_BYTE *)a4 + 11);
    default:
      sub_6806F24((__int64)"invalid type specifier");
  }
}


================================================================================
Function: sub_68120F0 (0x68120F0)
================================================================================

__int64 __fastcall sub_68120F0(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  unsigned __int64 v13; // x10
  _BYTE *v14; // x1
  _BYTE *v15; // x9
  bool v16; // cc
  unsigned __int64 v17; // x11
  unsigned __int64 v18; // x14
  _BYTE v20[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_QWORD *)(a1 + 24);
  v14 = &v20[*(int *)(a1 + 32)];
  if ( v13 >= 0x64 )
  {
    v15 = &v20[*(int *)(a1 + 32)];
    do
    {
      v16 = v13 >> 4 > 0x270;
      v17 = v13 / 0x64;
      v18 = v13 % 0x64;
      v13 /= 0x64uLL;
      *((_WORD *)v15 - 1) = *(_WORD *)&a00010203040506_1[2 * v18];
      v15 -= 2;
    }
    while ( v16 );
    if ( v17 <= 9 )
      goto LABEL_15;
LABEL_17:
    *((_WORD *)v15 - 1) = *(_WORD *)&a00010203040506_1[2 * v17];
    return sub_53DDE58((unsigned __int64)v20, (__int64)v14, a2);
  }
  v15 = &v20[*(int *)(a1 + 32)];
  v17 = *(_QWORD *)(a1 + 24);
  if ( v13 > 9 )
    goto LABEL_17;
LABEL_15:
  *(v15 - 1) = v17 + 48;
  return sub_53DDE58((unsigned __int64)v20, (__int64)v14, a2);
}


================================================================================
Function: sub_6812288 (0x6812288)
================================================================================

__int64 __fastcall sub_6812288(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  __int64 v13; // x11
  __int64 v14; // x10
  unsigned __int64 v15; // x8
  __int64 v16; // x9
  unsigned __int64 v17; // x13
  int v18; // w10
  __int64 v19; // x12
  bool v20; // zf
  __int64 v21; // x10
  const char *v22; // x9
  _BYTE *v23; // x10
  unsigned __int64 v24; // x11
  _BYTE *v25; // x1
  _BYTE *v26; // x10
  const char *v27; // x9
  unsigned __int64 v28; // x11
  bool v29; // cc
  _BYTE v31[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_QWORD *)(a2 + 16);
  v14 = *(unsigned int *)(a1 + 32);
  v15 = *(_QWORD *)(a1 + 24);
  v16 = (int)v14;
  v17 = v13 + v14;
  v18 = *(unsigned __int8 *)(a1 + 36);
  if ( *(_QWORD *)(a2 + 24) >= v17 && (v19 = *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16) = v17, v19) )
  {
    v20 = v18 == 0;
    v21 = v13 + v16 + v19;
    if ( v20 )
      v22 = "0123456789abcdef";
    else
      v22 = "0123456789ABCDEF";
    v23 = (_BYTE *)(v21 - 1);
    do
    {
      v24 = v15 & 0xF;
      v7 = v15 >= 0x10;
      v15 >>= 4;
      *v23-- = v22[v24];
    }
    while ( v7 );
  }
  else
  {
    v25 = &v31[v16];
    v20 = v18 == 0;
    v26 = &v31[v16 - 1];
    if ( v20 )
      v27 = "0123456789abcdef";
    else
      v27 = "0123456789ABCDEF";
    do
    {
      v28 = v15 & 0xF;
      v29 = v15 > 0xF;
      v15 >>= 4;
      *v26-- = v27[v28];
    }
    while ( v29 );
    return sub_53DDE58((unsigned __int64)v31, (__int64)v25, a2);
  }
  return a2;
}


================================================================================
Function: sub_681244C (0x681244C)
================================================================================

__int64 __fastcall sub_681244C(__int64 a1, __int64 a2, unsigned int *a3, __int64 a4)
{
  int v4; // w25
  unsigned int v5; // w22
  unsigned __int64 v6; // x20
  unsigned __int64 v7; // x21
  __int64 v9; // x19
  __int16 v10; // w26
  bool v11; // w8
  int v12; // w27
  __int16 v13; // w8
  int v14; // w9
  __int64 v15; // x27
  unsigned __int64 v16; // x11
  unsigned __int64 v17; // x10
  unsigned __int64 v18; // x12
  bool v19; // cc
  __int128 v20; // t2
  char v21; // w13
  bool v22; // zf
  bool v23; // w14
  unsigned __int64 v24; // x10
  int v25; // w13
  char *v26; // x25
  unsigned __int64 v27; // x12
  int v28; // w8
  __int64 v29; // x28
  __int16 v30; // w10
  int v31; // w9
  __int64 v32; // x24
  unsigned __int64 v33; // x13
  unsigned __int64 v34; // x9
  unsigned __int64 v35; // x12
  __int128 v36; // t2
  char v37; // w14
  bool v38; // w15
  unsigned __int64 v39; // x9
  int v40; // w14
  unsigned __int64 v41; // x12
  int v42; // w10
  unsigned __int64 v43; // x11
  __int64 v44; // x25
  unsigned __int64 v45; // x8
  unsigned __int64 v46; // x9
  __int128 v47; // t2
  char v48; // w10
  bool v49; // w11
  __int16 v50; // w10
  int v51; // w9
  int v52; // w8
  unsigned __int64 v53; // x8
  char *v54; // x27
  int v55; // w10
  __int64 v56; // x12
  unsigned __int64 v57; // x11
  unsigned __int64 v58; // x9
  unsigned __int64 v59; // x28
  __int64 v60; // x9
  bool v61; // cf
  unsigned __int64 v62; // x9
  unsigned __int64 v63; // x24
  char v64; // w8
  unsigned __int64 v65; // x22
  __int64 v66; // x8
  __int64 v67; // x22
  __int64 v68; // x1
  __int64 v69; // x9
  __int64 v71; // x1
  unsigned int v72; // w22
  __int64 v73; // x8
  __int64 v74; // x10
  _BYTE *v75; // x8
  unsigned __int64 v76; // x9
  __int128 v77; // t2
  bool v78; // w11
  char v79; // w12
  __int64 v80; // x9
  __int64 v81; // x8
  __int64 v82; // x1
  unsigned int v83; // w22
  __int64 v84; // x8
  __int64 v85; // x9
  __int64 v86; // x9
  const char *v87; // x8
  char *v88; // x9
  unsigned __int64 v89; // x10
  bool v90; // w12
  __int128 v91; // t2
  char v92; // w10
  __int64 v93; // x9
  __int64 v94; // x8
  __int64 v95; // x1
  char *v96; // x1
  unsigned __int64 v97; // x8
  __int128 v98; // t2
  bool v99; // w9
  bool v100; // w11
  char v101; // w10
  const char *v102; // x9
  char *v103; // x8
  unsigned __int64 v104; // x10
  bool v105; // w11
  bool v106; // w12
  __int128 v107; // t2
  char v108; // w10
  unsigned __int64 v109; // x25
  unsigned __int64 v110; // x24
  bool v111; // w8
  bool v112; // w8
  __int128 v113; // t2
  bool v114; // w9
  bool v115; // w8
  __int64 v116; // x0
  __int128 v117; // t2
  unsigned __int64 v118; // x9
  unsigned __int64 v119; // x1
  bool v120; // w8
  bool v121; // w9
  unsigned int v122; // w22
  __int64 v123; // x8
  __int64 v124; // x10
  _BYTE *v125; // x8
  unsigned __int64 v126; // x9
  __int128 v127; // t2
  bool v128; // w11
  char v129; // w12
  __int64 v130; // x9
  __int64 v131; // x8
  __int64 v132; // x1
  _BYTE *v133; // x23
  char v134; // w8
  unsigned __int64 v135; // x26
  unsigned __int64 v136; // x24
  unsigned int v137; // w22
  __int64 v138; // x9
  __int64 v139; // x8
  __int64 v140; // x1
  __int64 v141; // x9
  __int64 v142; // x8
  __int64 v143; // x1
  __int64 v144; // x8
  __int64 v145; // x22
  __int64 v146; // x10
  _BYTE *v147; // x8
  unsigned __int64 v148; // x9
  __int128 v149; // t2
  bool v150; // w11
  char v151; // w12
  char *v152; // x1
  unsigned __int64 v153; // x8
  __int128 v154; // t2
  bool v155; // w9
  bool v156; // w11
  char v157; // w10
  unsigned __int64 v158; // x9
  char v159; // w10
  __int64 v160; // x21
  __int64 v161; // x0
  __int64 v162; // x1
  _BYTE *v163; // x2
  unsigned __int64 v164; // x8
  __int128 v165; // t2
  bool v166; // w9
  bool v167; // w11
  char v168; // w10
  unsigned __int64 v169; // x8
  unsigned __int64 v170; // x26
  char v171; // w9
  unsigned __int64 v172; // x24
  unsigned int v173; // w22
  __int64 v174; // x9
  __int64 v175; // x8
  __int64 v176; // x1
  __int64 v177; // x9
  __int64 v178; // x8
  __int64 v179; // x1
  __int64 v180; // x8
  __int64 v181; // x10
  _BYTE *v182; // x8
  unsigned __int64 v183; // x9
  __int128 v184; // t2
  bool v185; // w11
  char v186; // w12
  unsigned __int64 v187; // x8
  __int128 v188; // t2
  bool v189; // w9
  bool v190; // w11
  char v191; // w10
  unsigned __int64 v192; // x8
  signed int v193; // w12
  unsigned __int64 v194; // x9
  unsigned __int64 v195; // x11
  unsigned int v196; // w22
  bool v197; // w8
  char *v198; // x23
  unsigned __int64 v199; // x0
  unsigned __int64 v200; // x1
  __int128 v201; // t2
  unsigned __int64 v202; // x9
  bool v203; // w10
  __int16 v204; // w8
  bool v205; // w9
  __int64 v206; // x9
  __int64 v207; // x8
  __int64 v208; // x1
  bool v209; // w8
  unsigned __int64 v211; // x8
  char v212; // w10
  __int64 v213; // x24
  _DWORD v214[2]; // [xsp+0h] [xbp-90h] BYREF
  unsigned __int64 v215; // [xsp+8h] [xbp-88h]
  unsigned __int64 v216; // [xsp+10h] [xbp-80h]
  unsigned __int64 v217; // [xsp+20h] [xbp-70h]
  unsigned __int64 v218; // [xsp+28h] [xbp-68h]
  int v219; // [xsp+30h] [xbp-60h]
  bool v220; // [xsp+34h] [xbp-5Ch]

  v4 = *((unsigned __int8 *)a3 + 8);
  v5 = *(_DWORD *)(a2 + 16);
  v6 = *(_QWORD *)a2;
  v7 = *(_QWORD *)(a2 + 8);
  v9 = a1;
  switch ( *((_BYTE *)a3 + 8) )
  {
    case 0:
    case 1:
      v10 = *(_WORD *)((char *)a3 + 9);
      if ( (v10 & 0x100) != 0 )
      {
        sub_53DD748((__int64)v214, a4, 1);
        v9 = sub_681319C(v9, v71, v6, v7, v5, a3, v214);
        if ( (v214[0] & 1) != 0 )
          sub_65ECAF4();
        return v9;
      }
      v11 = v6 < 0xA;
      if ( v7 )
        v11 = 0;
      if ( v11 )
      {
        v12 = 1;
        goto LABEL_230;
      }
      v12 = 4;
      v109 = *(_QWORD *)a2;
      v110 = *(_QWORD *)(a2 + 8);
      while ( 2 )
      {
        v111 = v109 > 0x63;
        if ( v110 )
          v111 = 1;
        if ( v111 )
        {
          v112 = v109 > 0x3E7;
          if ( v110 )
            v112 = 1;
          if ( v112 )
          {
            *((_QWORD *)&v113 + 1) = v110;
            *(_QWORD *)&v113 = v109;
            v114 = (unsigned __int64)(v113 >> 4) < 0x271;
            if ( v110 >> 4 )
              v115 = 0;
            else
              v115 = v114;
            if ( v115 )
              break;
            v116 = sub_6866974(v109, v110, 10000LL, 0LL);
            *((_QWORD *)&v117 + 1) = v110;
            *(_QWORD *)&v117 = v109;
            v118 = v110 >> 5;
            v12 += 4;
            v109 = v116;
            v110 = v119;
            v120 = (unsigned __int64)(v117 >> 5) > 0xC34;
            v22 = v118 == 0;
            v121 = v118 != 0;
            if ( !v22 )
              v120 = v121;
            if ( !v120 )
            {
              v12 -= 3;
              break;
            }
            continue;
          }
          --v12;
        }
        else
        {
          v12 -= 2;
        }
        break;
      }
LABEL_230:
      v192 = *a3;
      v193 = a3[1];
      if ( !((v193 + 1) | (unsigned int)v192) )
      {
        if ( v5 )
        {
          v196 = v5 & 0xFFFFFF;
          if ( v196 )
          {
            do
            {
              v207 = *(_QWORD *)(v9 + 16);
              v208 = v207 + 1;
              if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v207 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v9)(v9);
                v207 = *(_QWORD *)(v9 + 16);
                v208 = v207 + 1;
              }
              v206 = *(_QWORD *)(v9 + 8);
              *(_QWORD *)(v9 + 16) = v208;
              v19 = v196 > 0xFF;
              *(_BYTE *)(v206 + v207) = v196;
              v196 >>= 8;
            }
            while ( v19 );
          }
        }
        v197 = v6 < 0x64;
        if ( v7 )
          v197 = 0;
        if ( v197 )
        {
          v198 = (char *)v214 + v12;
          v199 = v6;
          v200 = v7;
        }
        else
        {
          v198 = (char *)v214 + v12;
          do
          {
            v199 = sub_6866974(v6, v7, 100LL, 0LL);
            *((_QWORD *)&v201 + 1) = v7;
            *(_QWORD *)&v201 = v6;
            v202 = v6 - 100 * v199;
            v6 = v199;
            v203 = (unsigned __int64)(v201 >> 4) > 0x270;
            v204 = *(_WORD *)&a00010203040506_1[2 * v202];
            v205 = v7 >> 4 != 0;
            if ( !(v7 >> 4) )
              v205 = v203;
            v7 = v200;
            *((_WORD *)v198 - 1) = v204;
            v198 -= 2;
          }
          while ( v205 );
        }
        v209 = v199 > 9;
        if ( v200 )
          v209 = 1;
        if ( v209 )
          *((_WORD *)v198 - 1) = *(_WORD *)&a00010203040506_1[2 * v199];
        else
          *(v198 - 1) = v199 + 48;
        v96 = (char *)v214 + v12;
        return sub_53DDE58((unsigned __int64)v214, (__int64)v96, v9);
      }
      v194 = v12 + HIBYTE(v5);
      if ( (v10 & 0xF) == 4 )
      {
        v195 = v192 - v194;
        if ( (unsigned int)v192 > (unsigned int)v194 )
        {
          v194 = (unsigned int)v192;
        }
        else
        {
          v195 = 0LL;
          v194 = (unsigned int)v194;
        }
      }
      else
      {
        v195 = (unsigned int)(v193 - v12);
        if ( v193 <= v12 )
          v195 = 0LL;
        else
          v194 = v193 + HIBYTE(v5);
      }
      v61 = v192 >= v194;
      v211 = v192 - v194;
      if ( !v61 )
        v211 = 0LL;
      v214[0] = v5;
      v212 = byte_174D7F4[v10 & 0xF];
      v215 = v194;
      v216 = v195;
      v217 = v6;
      v218 = v7;
      v219 = v12;
      v213 = v211 - (v211 >> v212);
      if ( v211 >> v212 )
        v9 = sub_250EF44(v9, v211 >> v212, (_BYTE *)a3 + 11);
      v161 = sub_6813528(v214, v9);
      v9 = v161;
      if ( v213 )
      {
        v162 = v213;
        v163 = (char *)a3 + 11;
        return sub_250EF44(v161, v162, v163);
      }
      return v9;
    case 2:
      v44 = 0LL;
      v45 = *(_QWORD *)a2;
      v46 = *(_QWORD *)(a2 + 8);
      do
      {
        v19 = v45 > 7;
        *((_QWORD *)&v47 + 1) = v46;
        *(_QWORD *)&v47 = v45;
        v45 = v47 >> 3;
        v48 = v19;
        v22 = v46 == 0;
        v49 = v46 != 0;
        v46 >>= 3;
        if ( !v22 )
          v48 = v49;
        ++v44;
      }
      while ( (v48 & 1) != 0 );
      v50 = *(_WORD *)((char *)a3 + 9);
      v51 = a3[1];
      if ( (v50 & 0x80) != 0 && v51 <= (int)v44 && v6 | v7 )
      {
        if ( v5 )
          v52 = 12288;
        else
          v52 = 48;
        v5 = (v52 | v5) + 0x1000000;
      }
      v53 = *a3;
      v54 = (char *)v214 + v44 - 1;
      if ( (unsigned int)v53 | (v51 + 1) )
      {
        v55 = v50 & 0xF;
        v56 = v44 + ((unsigned __int64)v5 >> 24);
        v57 = (unsigned int)v44 + HIBYTE(v5);
        if ( v55 == 4 )
        {
          v58 = v53 - v57;
          if ( (unsigned int)v53 <= (unsigned int)v56 )
            v57 = (unsigned int)v56;
          else
            v57 = (unsigned int)v53;
          if ( (unsigned int)v53 <= (unsigned int)v56 )
            v59 = 0LL;
          else
            v59 = v58;
        }
        else if ( v51 <= (int)v44 )
        {
          v59 = 0LL;
        }
        else
        {
          v59 = (unsigned int)(v51 - v44);
          v57 = HIBYTE(v5) + v51;
        }
        v61 = v53 >= v57;
        v169 = v53 - v57;
        if ( v61 )
          v170 = v169;
        else
          v170 = 0LL;
        v133 = (char *)a3 + 11;
        v171 = byte_174D7F4[v55];
        v172 = v170 >> v171;
        if ( v170 >> v171 )
          v9 = sub_250EF44(a1, v170 >> v171, (_BYTE *)a3 + 11);
        v173 = v5 & 0xFFFFFF;
        if ( v173 )
        {
          do
          {
            v175 = *(_QWORD *)(v9 + 16);
            v176 = v175 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v175 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v175 = *(_QWORD *)(v9 + 16);
              v176 = v175 + 1;
            }
            v174 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v176;
            v61 = v173 >= 0x100;
            *(_BYTE *)(v174 + v175) = v173;
            v173 >>= 8;
          }
          while ( v61 );
        }
        for ( ; v59; *(_BYTE *)(v177 + v178) = 48 )
        {
          v178 = *(_QWORD *)(v9 + 16);
          v179 = v178 + 1;
          if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v178 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v9)(v9);
            v178 = *(_QWORD *)(v9 + 16);
            v179 = v178 + 1;
          }
          --v59;
          v177 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v179;
        }
        v180 = *(_QWORD *)(v9 + 16);
        v145 = v170 - v172;
        if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v180 + v44) )
        {
          v181 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v180 + v44;
          if ( v181 )
          {
            v182 = (_BYTE *)(v181 + v180 + v44 - 1);
            do
            {
              *((_QWORD *)&v184 + 1) = v7;
              *(_QWORD *)&v184 = v6;
              v183 = v184 >> 3;
              v185 = v6 < 8;
              v186 = v6 & 7 | 0x30;
              if ( v7 )
                v185 = 0;
              v6 = v183;
              v7 >>= 3;
              *v182-- = v186;
            }
            while ( !v185 );
            goto LABEL_226;
          }
        }
        v152 = (char *)v214 + v44;
        do
        {
          *((_QWORD *)&v188 + 1) = v7;
          *(_QWORD *)&v188 = v6;
          v187 = v188 >> 3;
          v189 = v6 > 7;
          v22 = v7 == 0;
          v190 = v7 != 0;
          v7 >>= 3;
          v191 = v6 & 7 | 0x30;
          if ( !v22 )
            v189 = v190;
          v6 = v187;
          *v54-- = v191;
        }
        while ( v189 );
        goto LABEL_225;
      }
      if ( v5 )
      {
        v122 = v5 & 0xFFFFFF;
        if ( v122 )
        {
          do
          {
            v131 = *(_QWORD *)(v9 + 16);
            v132 = v131 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v131 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v131 = *(_QWORD *)(v9 + 16);
              v132 = v131 + 1;
            }
            v130 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v132;
            v19 = v122 > 0xFF;
            *(_BYTE *)(v130 + v131) = v122;
            v122 >>= 8;
          }
          while ( v19 );
        }
      }
      v123 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v123 + v44) )
      {
        v124 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v123 + v44;
        if ( v124 )
        {
          v125 = (_BYTE *)(v124 + v123 + v44 - 1);
          do
          {
            *((_QWORD *)&v127 + 1) = v7;
            *(_QWORD *)&v127 = v6;
            v126 = v127 >> 3;
            v128 = v6 < 8;
            v129 = v6 & 7 | 0x30;
            if ( v7 )
              v128 = 0;
            v6 = v126;
            v7 >>= 3;
            *v125-- = v129;
          }
          while ( !v128 );
          return v9;
        }
      }
      v96 = (char *)v214 + v44;
      do
      {
        *((_QWORD *)&v165 + 1) = v7;
        *(_QWORD *)&v165 = v6;
        v164 = v165 >> 3;
        v166 = v6 > 7;
        v22 = v7 == 0;
        v167 = v7 != 0;
        v7 >>= 3;
        v168 = v6 & 7 | 0x30;
        if ( !v22 )
          v166 = v167;
        v6 = v164;
        *v54-- = v168;
      }
      while ( v166 );
      return sub_53DDE58((unsigned __int64)v214, (__int64)v96, v9);
    case 3:
    case 4:
      v30 = *(_WORD *)((char *)a3 + 9);
      if ( (v30 & 0x80) != 0 )
      {
        if ( v4 == 4 )
          v31 = 22576;
        else
          v31 = 30768;
        if ( v5 )
          v31 <<= 8;
        v5 = (v31 | v5) + 0x2000000;
      }
      v32 = 0LL;
      v33 = (unsigned __int64)v5 >> 24;
      v34 = *(_QWORD *)a2;
      v35 = *(_QWORD *)(a2 + 8);
      do
      {
        v19 = v34 > 0xF;
        *((_QWORD *)&v36 + 1) = v35;
        *(_QWORD *)&v36 = v34;
        v34 = v36 >> 4;
        v37 = v19;
        v22 = v35 == 0;
        v38 = v35 != 0;
        v35 >>= 4;
        if ( !v22 )
          v37 = v38;
        ++v32;
        ++v33;
      }
      while ( (v37 & 1) != 0 );
      v39 = *a3;
      v40 = a3[1];
      if ( (v40 + 1) | (unsigned int)v39 )
      {
        v41 = v32 + ((unsigned __int64)v5 >> 24);
        v42 = v30 & 0xF;
        if ( v42 == 4 )
        {
          if ( v33 <= v39 )
            v33 = *a3;
          if ( (unsigned int)v39 <= (unsigned int)v41 )
            v41 = (unsigned int)v41;
          else
            v41 = (unsigned int)v39;
          v43 = v33 - ((unsigned __int64)v5 >> 24) - v32;
        }
        else if ( v40 <= (int)v32 )
        {
          v43 = 0LL;
        }
        else
        {
          v41 = v40 + HIBYTE(v5);
          v43 = (unsigned int)(v40 - v32);
        }
        v61 = v39 >= v41;
        v158 = v39 - v41;
        if ( !v61 )
          v158 = 0LL;
        v217 = *(_QWORD *)a2;
        v218 = v7;
        v159 = byte_174D7F4[v42];
        v214[0] = v5;
        v215 = v41;
        v216 = v43;
        v219 = v32;
        v220 = v4 == 4;
        v160 = v158 - (v158 >> v159);
        if ( v158 >> v159 )
          v9 = sub_250EF44(a1, v158 >> v159, (_BYTE *)a3 + 11);
        v161 = sub_68136F8(v214, v9);
        v9 = v161;
        if ( v160 )
        {
          v162 = v160;
          v163 = (char *)a3 + 11;
          return sub_250EF44(v161, v162, v163);
        }
        return v9;
      }
      if ( v5 )
      {
        v83 = v5 & 0xFFFFFF;
        if ( v83 )
        {
          do
          {
            v94 = *(_QWORD *)(v9 + 16);
            v95 = v94 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v94 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v94 = *(_QWORD *)(v9 + 16);
              v95 = v94 + 1;
            }
            v93 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v95;
            v19 = v83 > 0xFF;
            *(_BYTE *)(v93 + v94) = v83;
            v83 >>= 8;
          }
          while ( v19 );
        }
      }
      v84 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v84 + v32) )
      {
        v85 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v84 + v32;
        if ( v85 )
        {
          v86 = v85 + v84 + v32;
          if ( v4 == 4 )
            v87 = "0123456789ABCDEF";
          else
            v87 = "0123456789abcdef";
          v88 = (char *)(v86 - 1);
          do
          {
            v89 = v6 & 0xF;
            v90 = v6 < 0x10;
            *((_QWORD *)&v91 + 1) = v7;
            *(_QWORD *)&v91 = v6;
            v6 = v91 >> 4;
            v92 = v87[v89];
            if ( v7 )
              v90 = 0;
            v7 >>= 4;
            *v88-- = v92;
          }
          while ( !v90 );
          return v9;
        }
      }
      v102 = "0123456789abcdef";
      v103 = (char *)&v214[-1] + v32 + 3;
      v96 = (char *)v214 + v32;
      if ( v4 == 4 )
        v102 = "0123456789ABCDEF";
      do
      {
        v104 = v6 & 0xF;
        v105 = v6 > 0xF;
        v22 = v7 == 0;
        v106 = v7 != 0;
        *((_QWORD *)&v107 + 1) = v7;
        *(_QWORD *)&v107 = v6;
        v6 = v107 >> 4;
        v108 = v102[v104];
        v7 >>= 4;
        if ( !v22 )
          v105 = v106;
        *v103-- = v108;
      }
      while ( v105 );
      return sub_53DDE58((unsigned __int64)v214, (__int64)v96, v9);
    case 5:
    case 6:
      v13 = *(_WORD *)((char *)a3 + 9);
      if ( (v13 & 0x80) != 0 )
      {
        if ( v4 == 6 )
          v14 = 16944;
        else
          v14 = 25136;
        if ( v5 )
          v14 <<= 8;
        v5 = (v14 | v5) + 0x2000000;
      }
      v15 = 0LL;
      v16 = (unsigned __int64)v5 >> 24;
      v17 = *(_QWORD *)a2;
      v18 = *(_QWORD *)(a2 + 8);
      do
      {
        v19 = v17 > 1;
        *((_QWORD *)&v20 + 1) = v18;
        *(_QWORD *)&v20 = v17;
        v17 = v20 >> 1;
        v21 = v19;
        v22 = v18 == 0;
        v23 = v18 != 0;
        v18 >>= 1;
        if ( !v22 )
          v21 = v23;
        ++v15;
        ++v16;
      }
      while ( (v21 & 1) != 0 );
      v24 = *a3;
      v25 = a3[1];
      v26 = (char *)&v214[-1] + v15 + 3;
      if ( (v25 + 1) | (unsigned int)v24 )
      {
        v27 = v15 + ((unsigned __int64)v5 >> 24);
        v28 = v13 & 0xF;
        if ( v28 == 4 )
        {
          if ( (unsigned int)v24 <= (unsigned int)v27 )
            v27 = (unsigned int)v27;
          else
            v27 = (unsigned int)v24;
          if ( v16 <= v24 )
            v16 = *a3;
          v29 = v16 - ((unsigned __int64)v5 >> 24) - v15;
        }
        else if ( v25 <= (int)v15 )
        {
          v29 = 0LL;
        }
        else
        {
          v29 = (unsigned int)(v25 - v15);
          v27 = v25 + HIBYTE(v5);
        }
        v133 = (char *)a3 + 11;
        v134 = byte_174D7F4[v28];
        if ( v24 >= v27 )
          v135 = v24 - v27;
        else
          v135 = 0LL;
        v136 = v135 >> v134;
        if ( v135 >> v134 )
          v9 = sub_250EF44(a1, v135 >> v134, (_BYTE *)a3 + 11);
        v137 = v5 & 0xFFFFFF;
        if ( v137 )
        {
          do
          {
            v139 = *(_QWORD *)(v9 + 16);
            v140 = v139 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v139 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v139 = *(_QWORD *)(v9 + 16);
              v140 = v139 + 1;
            }
            v138 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v140;
            v61 = v137 >= 0x100;
            *(_BYTE *)(v138 + v139) = v137;
            v137 >>= 8;
          }
          while ( v61 );
        }
        for ( ; v29; *(_BYTE *)(v141 + v142) = 48 )
        {
          v142 = *(_QWORD *)(v9 + 16);
          v143 = v142 + 1;
          if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v142 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v9)(v9);
            v142 = *(_QWORD *)(v9 + 16);
            v143 = v142 + 1;
          }
          --v29;
          v141 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v143;
        }
        v144 = *(_QWORD *)(v9 + 16);
        v145 = v135 - v136;
        if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v144 + v15)
          && (v146 = *(_QWORD *)(v9 + 8), *(_QWORD *)(v9 + 16) = v144 + v15, v146) )
        {
          v147 = (_BYTE *)(v146 + v144 + v15 - 1);
          do
          {
            *((_QWORD *)&v149 + 1) = v7;
            *(_QWORD *)&v149 = v6;
            v148 = v149 >> 1;
            v150 = v6 < 2;
            v151 = v6 & 1 | 0x30;
            if ( v7 )
              v150 = 0;
            v6 = v148;
            v7 >>= 1;
            *v147-- = v151;
          }
          while ( !v150 );
        }
        else
        {
          v152 = (char *)v214 + v15;
          do
          {
            *((_QWORD *)&v154 + 1) = v7;
            *(_QWORD *)&v154 = v6;
            v153 = v154 >> 1;
            v155 = v6 > 1;
            v22 = v7 == 0;
            v156 = v7 != 0;
            v7 >>= 1;
            v157 = v6 & 1 | 0x30;
            if ( !v22 )
              v155 = v156;
            v6 = v153;
            *v26-- = v157;
          }
          while ( v155 );
LABEL_225:
          v9 = sub_53DDE58((unsigned __int64)v214, (__int64)v152, v9);
        }
LABEL_226:
        if ( v145 )
        {
          v161 = v9;
          v162 = v145;
          v163 = v133;
          return sub_250EF44(v161, v162, v163);
        }
      }
      else
      {
        if ( v5 )
        {
          v72 = v5 & 0xFFFFFF;
          if ( v72 )
          {
            do
            {
              v81 = *(_QWORD *)(v9 + 16);
              v82 = v81 + 1;
              if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v81 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v9)(v9);
                v81 = *(_QWORD *)(v9 + 16);
                v82 = v81 + 1;
              }
              v80 = *(_QWORD *)(v9 + 8);
              *(_QWORD *)(v9 + 16) = v82;
              v19 = v72 > 0xFF;
              *(_BYTE *)(v80 + v81) = v72;
              v72 >>= 8;
            }
            while ( v19 );
          }
        }
        v73 = *(_QWORD *)(v9 + 16);
        if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v73 + v15)
          || (v74 = *(_QWORD *)(v9 + 8), *(_QWORD *)(v9 + 16) = v73 + v15, !v74) )
        {
          v96 = (char *)v214 + v15;
          do
          {
            *((_QWORD *)&v98 + 1) = v7;
            *(_QWORD *)&v98 = v6;
            v97 = v98 >> 1;
            v99 = v6 > 1;
            v22 = v7 == 0;
            v100 = v7 != 0;
            v7 >>= 1;
            v101 = v6 & 1 | 0x30;
            if ( !v22 )
              v99 = v100;
            v6 = v97;
            *v26-- = v101;
          }
          while ( v99 );
          return sub_53DDE58((unsigned __int64)v214, (__int64)v96, v9);
        }
        v75 = (_BYTE *)(v74 + v73 + v15 - 1);
        do
        {
          *((_QWORD *)&v77 + 1) = v7;
          *(_QWORD *)&v77 = v6;
          v76 = v77 >> 1;
          v78 = v6 < 2;
          v79 = v6 & 1 | 0x30;
          if ( v7 )
            v78 = 0;
          v6 = v76;
          v7 >>= 1;
          *v75-- = v79;
        }
        while ( !v78 );
      }
      return v9;
    case 0xF:
      v60 = *a3;
      v61 = v60 != 0;
      v62 = v60 - 1;
      if ( v61 )
        v63 = v62;
      else
        v63 = 0LL;
      v64 = byte_174D7F9[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v65 = v63 >> v64;
      if ( v63 >> v64 )
        v9 = sub_250EF44(a1, v63 >> v64, (_BYTE *)a3 + 11);
      v66 = *(_QWORD *)(v9 + 16);
      v67 = v63 - v65;
      v68 = v66 + 1;
      if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v66 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v9)(v9);
        v66 = *(_QWORD *)(v9 + 16);
        v68 = v66 + 1;
      }
      v69 = *(_QWORD *)(v9 + 8);
      *(_QWORD *)(v9 + 16) = v68;
      *(_BYTE *)(v69 + v66) = v6;
      if ( !v67 )
        return v9;
      return sub_250EF44(v9, v67, (_BYTE *)a3 + 11);
    default:
      sub_6806F24((__int64)"invalid type specifier");
  }
}


================================================================================
Function: sub_681319C (0x681319C)
================================================================================

__int64 __fastcall sub_681319C(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        int a5,
        __int64 a6,
        unsigned __int8 *a7)
{
  bool v7; // w9
  unsigned __int64 v10; // x22
  _BYTE *v12; // x24
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x23
  int v15; // w27
  unsigned __int64 v16; // x25
  unsigned __int64 v17; // x24
  bool v18; // w8
  bool v19; // w8
  __int128 v20; // t2
  bool v21; // w9
  bool v22; // w8
  __int64 v23; // x0
  __int128 v24; // t2
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x1
  bool v27; // w8
  bool v28; // w9
  bool v29; // w8
  unsigned __int64 v30; // x1
  __int128 v31; // t2
  unsigned __int64 v32; // x9
  bool v33; // w10
  __int16 v34; // w8
  bool v35; // w9
  bool v36; // w8
  unsigned __int64 v37; // x9
  bool v38; // zf
  unsigned __int64 v39; // x9
  unsigned __int64 v40; // x13
  int v41; // w9
  unsigned __int8 *v42; // x11
  int v43; // w10
  int v44; // w12
  unsigned __int8 *v45; // x13
  int v46; // w14
  _QWORD v48[4]; // [xsp+8h] [xbp-58h] BYREF
  int v49; // [xsp+28h] [xbp-38h] BYREF
  int v50; // [xsp+2Ch] [xbp-34h] BYREF
  char v51; // [xsp+30h] [xbp-30h] BYREF
  _BYTE v52[7]; // [xsp+31h] [xbp-2Fh] BYREF

  v7 = a3 < 0xA;
  v10 = a3;
  if ( a4 )
    v7 = 0;
  v50 = a5;
  if ( v7 )
  {
    v12 = v52;
    LOBYTE(v13) = a3;
    v49 = 1;
  }
  else
  {
    v14 = a4;
    v15 = 4;
    v16 = a3;
    v17 = a4;
    while ( 1 )
    {
      v18 = v16 > 0x63;
      if ( v17 )
        v18 = 1;
      if ( !v18 )
      {
        v15 -= 2;
        goto LABEL_22;
      }
      v19 = v16 > 0x3E7;
      if ( v17 )
        v19 = 1;
      if ( !v19 )
        break;
      *((_QWORD *)&v20 + 1) = v17;
      *(_QWORD *)&v20 = v16;
      v21 = (unsigned __int64)(v20 >> 4) < 0x271;
      if ( v17 >> 4 )
        v22 = 0;
      else
        v22 = v21;
      if ( v22 )
        goto LABEL_22;
      v23 = sub_6866974(v16, v17, 10000LL, 0LL);
      *((_QWORD *)&v24 + 1) = v17;
      *(_QWORD *)&v24 = v16;
      v25 = v17 >> 5;
      v15 += 4;
      v16 = v23;
      v17 = v26;
      v27 = (unsigned __int64)(v24 >> 5) > 0xC34;
      v38 = v25 == 0;
      v28 = v25 != 0;
      if ( !v38 )
        v27 = v28;
      if ( !v27 )
      {
        v15 -= 3;
        goto LABEL_22;
      }
    }
    --v15;
LABEL_22:
    v29 = v10 < 0x64;
    if ( v14 )
      v29 = 0;
    v12 = &v52[v15 - 1];
    v49 = v15;
    if ( v29 )
    {
      v13 = v10;
      v30 = v14;
    }
    else
    {
      do
      {
        v13 = sub_6866974(v10, v14, 100LL, 0LL);
        *((_QWORD *)&v31 + 1) = v14;
        *(_QWORD *)&v31 = v10;
        v32 = v10 - 100 * v13;
        v10 = v13;
        v33 = (unsigned __int64)(v31 >> 4) > 0x270;
        v34 = *(_WORD *)&a00010203040506_1[2 * v32];
        v35 = v14 >> 4 != 0;
        if ( !(v14 >> 4) )
          v35 = v33;
        v14 = v30;
        *((_WORD *)v12 - 1) = v34;
        v12 -= 2;
      }
      while ( v35 );
    }
    v36 = v13 > 9;
    if ( v30 )
      v36 = 1;
    if ( v36 )
    {
      *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
      goto LABEL_35;
    }
  }
  *(v12 - 1) = v13 + 48;
LABEL_35:
  v37 = *a7;
  v38 = (v37 & 1) == 0;
  v39 = v37 >> 1;
  if ( v38 )
    v40 = v39;
  else
    v40 = *((_QWORD *)a7 + 1);
  v41 = v49;
  if ( v38 )
    v42 = a7 + 1;
  else
    v42 = (unsigned __int8 *)*((_QWORD *)a7 + 2);
  v43 = 0;
  if ( a7[24] )
  {
    v44 = 0;
    v45 = &v42[v40];
    if ( v45 == v42 )
      goto LABEL_45;
LABEL_43:
    v46 = *v42;
    if ( (unsigned int)(v46 - 127) >= 0xFFFFFF82 )
    {
      ++v42;
      while ( 1 )
      {
        v44 += v46;
        if ( v44 >= v49 )
          break;
        ++v43;
        if ( v45 != v42 )
          goto LABEL_43;
LABEL_45:
        v46 = (char)*(v45 - 1);
      }
    }
  }
  if ( v50 )
    v41 = v49 + 1;
  v48[0] = &v50;
  v48[1] = a7;
  v48[2] = &v51;
  v48[3] = &v49;
  return sub_6813440(a1, a6, (unsigned int)(v41 + v43), (unsigned int)(v41 + v43), v48);
}


================================================================================
Function: sub_6813440 (0x6813440)
================================================================================

__int64 __fastcall sub_6813440(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x24
  unsigned __int64 v11; // x22
  __int64 v12; // x22
  int v13; // w23
  __int64 v14; // x8
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_174D7F4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_250EF44(a1, v10 >> v9, v8);
  v12 = v10 - v11;
  v13 = **a5;
  if ( v13 )
  {
    v14 = *(_QWORD *)(v7 + 16);
    v15 = v14 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v14 = *(_QWORD *)(v7 + 16);
      v15 = v14 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v14) = v13;
  }
  result = sub_53DDAC4((unsigned __int8 *)a5[1], v7, (char *)a5[2], *a5[3]);
  if ( v12 )
    return sub_250EF44(result, v12, v8);
  return result;
}


================================================================================
Function: sub_6813528 (0x6813528)
================================================================================

__int64 __fastcall sub_6813528(__int64 a1, __int64 a2)
{
  unsigned int v4; // w21
  __int64 i; // x21
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  unsigned __int64 v13; // x21
  unsigned __int64 v14; // x22
  __int64 v15; // x8
  bool v16; // w9
  _BYTE *v17; // x20
  _BYTE *v18; // x25
  unsigned __int64 v19; // x0
  unsigned __int64 v20; // x1
  __int128 v21; // t2
  unsigned __int64 v22; // x9
  bool v23; // w10
  __int16 v24; // w8
  bool v25; // w9
  bool v26; // w8
  _BYTE v28[40]; // [xsp+0h] [xbp-30h] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v14 = *(_QWORD *)(a1 + 32);
  v13 = *(_QWORD *)(a1 + 40);
  v15 = *(int *)(a1 + 48);
  v16 = v14 < 0x64;
  if ( v13 )
    v16 = 0;
  v17 = &v28[v15];
  if ( v16 )
  {
    v18 = &v28[v15];
    v19 = v14;
    v20 = v13;
  }
  else
  {
    v18 = &v28[v15];
    do
    {
      v19 = sub_6866974(v14, v13, 100LL, 0LL);
      *((_QWORD *)&v21 + 1) = v13;
      *(_QWORD *)&v21 = v14;
      v22 = v14 - 100 * v19;
      v14 = v19;
      v23 = (unsigned __int64)(v21 >> 4) > 0x270;
      v24 = *(_WORD *)&a00010203040506_1[2 * v22];
      v25 = v13 >> 4 != 0;
      if ( !(v13 >> 4) )
        v25 = v23;
      v13 = v20;
      *((_WORD *)v18 - 1) = v24;
      v18 -= 2;
    }
    while ( v25 );
  }
  v26 = v19 > 9;
  if ( v20 )
    v26 = 1;
  if ( v26 )
    *((_WORD *)v18 - 1) = *(_WORD *)&a00010203040506_1[2 * v19];
  else
    *(v18 - 1) = v19 + 48;
  return sub_53DDE58((unsigned __int64)v28, (__int64)v17, a2);
}


================================================================================
Function: sub_68136F8 (0x68136F8)
================================================================================

__int64 __fastcall sub_68136F8(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  __int64 v13; // x12
  __int64 v14; // x11
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x9
  __int64 v17; // x10
  unsigned __int64 v18; // x14
  int v19; // w11
  __int64 v20; // x13
  bool v21; // zf
  __int64 v22; // x11
  const char *v23; // x10
  char *v24; // x11
  unsigned __int64 v25; // x12
  bool v26; // w14
  __int128 v27; // t2
  char v28; // w12
  _BYTE *v29; // x1
  char *v30; // x11
  const char *v31; // x10
  unsigned __int64 v32; // x12
  bool v33; // w13
  bool v34; // w14
  __int128 v35; // t2
  char v36; // w12
  _BYTE v38[36]; // [xsp+4h] [xbp-2Ch] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_QWORD *)(a2 + 16);
  v14 = *(unsigned int *)(a1 + 48);
  v16 = *(_QWORD *)(a1 + 32);
  v15 = *(_QWORD *)(a1 + 40);
  v17 = (int)v14;
  v18 = v13 + v14;
  v19 = *(unsigned __int8 *)(a1 + 52);
  if ( *(_QWORD *)(a2 + 24) >= v18 && (v20 = *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16) = v18, v20) )
  {
    v21 = v19 == 0;
    v22 = v13 + v17 + v20;
    if ( v21 )
      v23 = "0123456789abcdef";
    else
      v23 = "0123456789ABCDEF";
    v24 = (char *)(v22 - 1);
    do
    {
      v25 = v16 & 0xF;
      v26 = v16 < 0x10;
      *((_QWORD *)&v27 + 1) = v15;
      *(_QWORD *)&v27 = v16;
      v16 = v27 >> 4;
      v28 = v23[v25];
      if ( v15 )
        v26 = 0;
      v15 >>= 4;
      *v24-- = v28;
    }
    while ( !v26 );
  }
  else
  {
    v29 = &v38[v17];
    v21 = v19 == 0;
    v30 = &v38[v17 - 1];
    if ( v21 )
      v31 = "0123456789abcdef";
    else
      v31 = "0123456789ABCDEF";
    do
    {
      v32 = v16 & 0xF;
      v33 = v16 > 0xF;
      v21 = v15 == 0;
      v34 = v15 != 0;
      *((_QWORD *)&v35 + 1) = v15;
      *(_QWORD *)&v35 = v16;
      v16 = v35 >> 4;
      v36 = v31[v32];
      v15 >>= 4;
      if ( !v21 )
        v33 = v34;
      *v30-- = v36;
    }
    while ( v33 );
    return sub_53DDE58((unsigned __int64)v38, (__int64)v29, a2);
  }
  return a2;
}


================================================================================
Function: sub_68138DC (0x68138DC)
================================================================================

__int64 __fastcall sub_68138DC(__int64 a1, _UNKNOWN **a2, _BYTE *a3, __int64 *a4, float a5)
{
  __int64 v8; // x0
  unsigned int v9; // w21
  unsigned int v10; // w9
  int v11; // w10
  unsigned int v12; // w25
  float v13; // s0
  const char *v14; // x10
  const char *v15; // x9
  __int64 v16; // x2
  __int64 v17; // x19
  __int64 v18; // x8
  char v19; // w22
  __int64 v20; // x1
  __int64 v21; // x9
  char v22; // w8
  __int64 v23; // x0
  bool v24; // cc
  unsigned int v25; // w22
  _BYTE *v27; // [xsp+0h] [xbp-250h] BYREF
  __int64 v28; // [xsp+8h] [xbp-248h]
  _UNKNOWN **v29; // [xsp+10h] [xbp-240h] BYREF
  _BYTE *v30; // [xsp+18h] [xbp-238h]
  __int128 v31; // [xsp+20h] [xbp-230h]
  _BYTE v32[504]; // [xsp+30h] [xbp-220h] BYREF
  _UNKNOWN **v33; // [xsp+228h] [xbp-28h] BYREF
  unsigned __int64 v34; // [xsp+230h] [xbp-20h]

  v33 = a2;
  v34 = (unsigned __int64)a3;
  v8 = sub_680E2C0((__int64)&v33);
  v9 = v8;
  v10 = HIDWORD(v8) & 0xFFFF00FF;
  if ( (LODWORD(a5) & 0x80000000) != 0 )
  {
    a5 = -a5;
    v12 = v10 | 0x100;
  }
  else
  {
    v11 = (16 * *(unsigned __int16 *)((char *)&v34 + 1)) & 0x700;
    if ( v11 == 256 )
      v11 = 0;
    v12 = v10 | v11;
  }
  v13 = fabsf(a5);
  if ( v13 < INFINITY || v13 > INFINITY )
  {
    if ( (BYTE1(v34) & 0xF) == 4 && (v12 & 0xFF00) != 0 )
    {
      v18 = *(_QWORD *)(a1 + 16);
      v19 = byte_174D7FE[BYTE1(v12)];
      v20 = v18 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v18 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v18 = *(_QWORD *)(a1 + 16);
        v20 = v18 + 1;
      }
      v21 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v20;
      v12 &= 0xFFFF00FF;
      *(_BYTE *)(v21 + v18) = v19;
      if ( (_DWORD)v33 )
        LODWORD(v33) = (_DWORD)v33 - 1;
    }
    v29 = &off_6C599D8;
    v30 = v32;
    v31 = xmmword_B03780;
    if ( (unsigned __int8)v12 == 3 )
    {
      if ( (v12 & 0xFF00) != 0 )
      {
        v22 = byte_174D7FE[BYTE1(v12)];
        *(_QWORD *)&v31 = 1LL;
        v32[0] = v22;
      }
      sub_680844C(HIDWORD(v33), v9 | ((unsigned __int64)v12 << 32), &v29, a5);
      v27 = v30;
      v28 = v31;
      v23 = sub_680E378(a1, (unsigned int *)&v33, v31, v31, (unsigned __int64 *)&v27);
    }
    else
    {
      if ( (_BYTE)v34 )
        v24 = SHIDWORD(v33) <= -1;
      else
        v24 = 0;
      if ( v24 )
        v25 = 6;
      else
        v25 = HIDWORD(v33);
      if ( (unsigned __int8)v12 == 1 )
      {
        if ( v25 == 0x7FFFFFFF )
          sub_6806F24((__int64)"number is too big");
        ++v25;
      }
      v27 = v30;
      LODWORD(v28) = v31;
      HIDWORD(v28) = sub_6808ADC(v25);
      v23 = sub_680E57C(a1, (__int64)&v27, (unsigned int *)&v33, ((unsigned __int64)(v12 | 0x40000) << 32) | v25, a4);
    }
    v17 = v23;
    if ( v30 != v32 )
      sub_65ECAF4();
  }
  else
  {
    v29 = v33;
    v30 = (_BYTE *)v34;
    if ( (v34 & 0xFF000000FF000000LL) == 0x100000030000000LL )
      BYTE3(v30) = 32;
    v14 = "INF";
    if ( (v12 & 0x10000) == 0 )
      v14 = "inf";
    v15 = "NAN";
    if ( (v12 & 0x10000) == 0 )
      v15 = "nan";
    LODWORD(v27) = BYTE1(v12);
    if ( v13 == INFINITY )
      v15 = v14;
    if ( BYTE1(v12) )
      v16 = 4LL;
    else
      v16 = 3LL;
    v28 = (__int64)v15;
    return sub_680B6FC(a1, (unsigned int *)&v29, v16, v16, (unsigned int *)&v27);
  }
  return v17;
}


================================================================================
Function: sub_6813C04 (0x6813C04)
================================================================================

__int64 __fastcall sub_6813C04(__int64 a1, _UNKNOWN **a2, _BYTE *a3, __int64 *a4, double a5)
{
  __int64 v8; // x0
  unsigned int v9; // w21
  unsigned int v10; // w9
  int v11; // w10
  __int64 v12; // x24
  double v13; // d0
  const char *v14; // x10
  const char *v15; // x9
  __int64 v16; // x2
  __int64 v17; // x19
  __int64 v18; // x8
  char v19; // w22
  __int64 v20; // x1
  __int64 v21; // x9
  char v22; // w8
  __int64 v23; // x0
  bool v24; // cc
  unsigned int v25; // w22
  _BYTE *v27; // [xsp+0h] [xbp-250h] BYREF
  __int64 v28; // [xsp+8h] [xbp-248h]
  _UNKNOWN **v29; // [xsp+10h] [xbp-240h] BYREF
  _BYTE *v30; // [xsp+18h] [xbp-238h]
  __int128 v31; // [xsp+20h] [xbp-230h]
  _BYTE v32[504]; // [xsp+30h] [xbp-220h] BYREF
  _UNKNOWN **v33; // [xsp+228h] [xbp-28h] BYREF
  unsigned __int64 v34; // [xsp+230h] [xbp-20h]

  v33 = a2;
  v34 = (unsigned __int64)a3;
  v8 = sub_680E2C0((__int64)&v33);
  v9 = v8;
  v10 = HIDWORD(v8) & 0xFFFF00FF;
  if ( (*(_QWORD *)&a5 & 0x8000000000000000LL) != 0 )
  {
    a5 = -a5;
    v12 = v10 | 0x100;
  }
  else
  {
    v11 = (16 * *(unsigned __int16 *)((char *)&v34 + 1)) & 0x700;
    if ( v11 == 256 )
      v11 = 0;
    v12 = v10 | v11;
  }
  v13 = fabs(a5);
  if ( v13 < INFINITY || v13 > INFINITY )
  {
    if ( (BYTE1(v34) & 0xF) == 4 && (v12 & 0xFF00) != 0 )
    {
      v18 = *(_QWORD *)(a1 + 16);
      v19 = byte_174D7FE[BYTE1(v12)];
      v20 = v18 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v18 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v18 = *(_QWORD *)(a1 + 16);
        v20 = v18 + 1;
      }
      v21 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v20;
      v12 = (unsigned int)v12 & 0xFFFF00FF;
      *(_BYTE *)(v21 + v18) = v19;
      if ( (_DWORD)v33 )
        LODWORD(v33) = (_DWORD)v33 - 1;
    }
    v29 = &off_6C599D8;
    v30 = v32;
    v31 = xmmword_B03780;
    if ( (unsigned __int8)v12 == 3 )
    {
      if ( (v12 & 0xFF00) != 0 )
      {
        v22 = byte_174D7FE[BYTE1(v12)];
        *(_QWORD *)&v31 = 1LL;
        v32[0] = v22;
      }
      sub_680844C(HIDWORD(v33), v9 | ((unsigned __int64)(unsigned int)v12 << 32), &v29, a5);
      v27 = v30;
      v28 = v31;
      v23 = sub_680E378(a1, (unsigned int *)&v33, v31, v31, (unsigned __int64 *)&v27);
    }
    else
    {
      if ( (_BYTE)v34 )
        v24 = SHIDWORD(v33) <= -1;
      else
        v24 = 0;
      if ( v24 )
        v25 = 6;
      else
        v25 = HIDWORD(v33);
      if ( (unsigned __int8)v12 == 1 )
      {
        if ( v25 == 0x7FFFFFFF )
          sub_6806F24((__int64)"number is too big");
        ++v25;
      }
      v27 = v30;
      LODWORD(v28) = v31;
      HIDWORD(v28) = sub_6808ADC(v25);
      v23 = sub_680E57C(a1, (__int64)&v27, (unsigned int *)&v33, (v12 << 32) | v25, a4);
    }
    v17 = v23;
    if ( v30 != v32 )
      sub_65ECAF4();
  }
  else
  {
    v29 = v33;
    v30 = (_BYTE *)v34;
    if ( (v34 & 0xFF000000FF000000LL) == 0x100000030000000LL )
      BYTE3(v30) = 32;
    v14 = "INF";
    if ( (v12 & 0x10000) == 0 )
      v14 = "inf";
    v15 = "NAN";
    if ( (v12 & 0x10000) == 0 )
      v15 = "nan";
    LODWORD(v27) = BYTE1(v12);
    if ( v13 == INFINITY )
      v15 = v14;
    if ( BYTE1(v12) )
      v16 = 4LL;
    else
      v16 = 3LL;
    v28 = (__int64)v15;
    return sub_680B6FC(a1, (unsigned int *)&v29, v16, v16, (unsigned int *)&v27);
  }
  return v17;
}


================================================================================
Function: sub_6813F28 (0x6813F28)
================================================================================

__int64 __usercall sub_6813F28@<X0>(__int64 a1@<X0>, int a2@<W1>, int a3@<W8>)
{
  unsigned int v4; // w8
  unsigned int v5; // w10
  unsigned __int64 v6; // x8
  uint32x4_t *v7; // x9
  unsigned int v8; // w11
  unsigned __int64 v9; // x12
  unsigned __int32 v10; // w20
  int8x16_t v11; // q0
  uint32x4_t *v12; // x13
  uint32x4_t v13; // q1
  unsigned __int64 v14; // x14
  uint32x4_t v15; // q2
  uint32x4_t v16; // q3
  int8x16_t v17; // q6
  int8x16_t v18; // q5
  int32x4_t v19; // q4
  unsigned __int64 v20; // x13
  unsigned __int32 *v21; // x12
  unsigned __int32 v22; // w14
  unsigned __int32 v23; // w15
  unsigned __int64 v24; // x1

  v4 = a3 & 0xFFFFFFE0;
  v5 = a2 - v4;
  *(_DWORD *)(a1 + 168) += a2 / 32;
  if ( a2 == v4 )
    return a1;
  v6 = *(_QWORD *)(a1 + 16);
  if ( !v6 )
    return a1;
  v7 = *(uint32x4_t **)(a1 + 8);
  v8 = 32 - v5;
  if ( v6 < 8 )
  {
    v9 = 0LL;
    v10 = 0;
LABEL_8:
    v20 = v6 - v9;
    v21 = (unsigned __int32 *)v7 + v9;
    v22 = v10;
    do
    {
      --v20;
      v10 = *v21 >> v8;
      v23 = (*v21 << v5) + v22;
      v22 = v10;
      *v21++ = v23;
    }
    while ( v20 );
    goto LABEL_10;
  }
  v9 = v6 & 0xFFFFFFFFFFFFFFF8LL;
  v11 = 0uLL;
  v12 = v7 + 1;
  v13 = vnegq_s32(vdupq_n_s32(v8));
  v14 = v6 & 0xFFFFFFFFFFFFFFF8LL;
  v15 = vdupq_n_s32(v5);
  do
  {
    v16 = v12[-1];
    v17 = v11;
    v14 -= 8LL;
    v18 = vshlq_u32(v16, v13);
    v11 = vshlq_u32(*v12, v13);
    v19 = vaddq_s32(vshlq_u32(*v12, v15), vextq_s8(v18, v11, 0xCuLL));
    v12[-1] = vaddq_s32(vshlq_u32(v16, v15), vextq_s8(v17, v18, 0xCuLL));
    *v12 = v19;
    v12 += 2;
  }
  while ( v14 );
  v10 = v11.n128_u32[3];
  if ( v6 != v9 )
    goto LABEL_8;
LABEL_10:
  if ( v10 )
  {
    v24 = v6 + 1;
    if ( *(_QWORD *)(a1 + 24) < v6 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a1)(a1);
      v7 = *(uint32x4_t **)(a1 + 8);
      v6 = *(_QWORD *)(a1 + 16);
      v24 = v6 + 1;
    }
    *(_QWORD *)(a1 + 16) = v24;
    v7->n128_u32[v6] = v10;
  }
  return a1;
}


================================================================================
Function: sub_6814054 (0x6814054)
================================================================================

__int64 __fastcall sub_6814054(__int64 result, int a2)
{
  __int64 v2; // x19
  int v4; // w8
  int v5; // w21
  __int64 v6; // x10
  __int64 v7; // x8
  __int64 v8; // x8
  int v9; // w21
  bool v10; // cc
  __int64 v11; // x8
  __int64 v12; // x10
  unsigned __int64 v13; // x22
  __int64 v14; // x9
  __int64 v15; // x11
  unsigned __int64 v16; // x12
  __int64 v17; // x1

  v2 = result;
  if ( a2 )
  {
    v4 = 1;
    do
    {
      v5 = v4;
      v4 *= 2;
    }
    while ( v5 <= a2 );
    v6 = *(_QWORD *)(result + 24);
    **(_DWORD **)(result + 8) = 5;
    if ( v6 )
    {
      v7 = 1LL;
    }
    else
    {
      (**(void (__fastcall ***)(__int64, __int64))result)(result, 1LL);
      v7 = *(_QWORD *)(v2 + 24) != 0LL;
    }
    *(_QWORD *)(v2 + 16) = v7;
    *(_DWORD *)(v2 + 168) = 0;
    if ( (unsigned int)v5 >= 4 )
    {
      v9 = v5 >> 2;
      do
      {
        sub_6814654(v2);
        if ( (v9 & a2) != 0 )
        {
          v11 = *(_QWORD *)(v2 + 16);
          if ( v11 )
          {
            v12 = 0LL;
            v13 = 0LL;
            v14 = *(_QWORD *)(v2 + 8);
            do
            {
              v15 = 4 * v12++;
              v16 = 5LL * *(unsigned int *)(v14 + v15) + v13;
              v13 = HIDWORD(v16);
              *(_DWORD *)(v14 + v15) = v16;
            }
            while ( v11 != v12 );
            if ( HIDWORD(v16) )
            {
              v17 = v11 + 1;
              if ( *(_QWORD *)(v2 + 24) < (unsigned __int64)(v11 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v2)(v2);
                v14 = *(_QWORD *)(v2 + 8);
                v11 = *(_QWORD *)(v2 + 16);
                v17 = v11 + 1;
              }
              *(_QWORD *)(v2 + 16) = v17;
              *(_DWORD *)(v14 + 4 * v11) = v13;
            }
          }
        }
        LODWORD(v7) = v9 >> 1;
        v10 = (unsigned int)v9 > 1;
        v9 >>= 1;
      }
      while ( v10 );
    }
    return sub_6813F28(v2, a2, v7);
  }
  else
  {
    v8 = *(_QWORD *)(result + 24);
    **(_DWORD **)(result + 8) = 1;
    if ( !v8 )
    {
      result = (**(__int64 (__fastcall ***)(__int64, __int64))result)(result, 1LL);
      v8 = *(_QWORD *)(v2 + 24);
    }
    *(_DWORD *)(v2 + 168) = 0;
    *(_QWORD *)(v2 + 16) = v8 != 0;
  }
  return result;
}


================================================================================
Function: sub_68141C4 (0x68141C4)
================================================================================

__int64 __fastcall sub_68141C4(__int64 a1, __int64 a2)
{
  __int64 v2; // x24
  int v4; // w10
  __int64 v6; // x9
  int v7; // w11
  int v8; // w8
  unsigned int v9; // w12
  int v10; // w13
  int v11; // w17
  unsigned int v12; // w1
  unsigned int v13; // w0
  int v14; // w22
  __int64 v15; // x23
  unsigned __int64 v16; // x8
  unsigned __int64 v17; // x21
  char *v18; // x0
  __int64 v19; // x9
  __int64 v20; // x10
  char *v21; // x13
  char *v22; // x14
  __int64 v23; // x11
  char *v24; // x13
  __int64 v25; // x12
  char *v26; // x14
  __int64 v27; // x15
  __int128 v28; // q0
  __int128 v29; // q1
  __int64 v30; // x10
  int v31; // w11
  unsigned int v32; // w21
  __int64 v34; // x12
  __int64 v35; // x14
  unsigned int *v36; // x13
  __int64 v37; // x10
  __int64 v38; // x11
  __int64 v39; // x15
  unsigned int v40; // t1
  __int64 v41; // x11
  __int64 v42; // x9
  __int64 v43; // x11
  __int64 v44; // x9
  unsigned __int64 v46; // x9
  unsigned __int64 v47; // x22
  int v48; // w13
  unsigned int v49; // w14
  int v50; // w12
  int v51; // w15
  int v52; // w17
  unsigned int v53; // w2
  unsigned int v54; // w1

  v2 = *(_QWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 168);
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_DWORD *)(a2 + 168);
  if ( v4 + (_DWORD)v2 != v7 + (_DWORD)v6 )
  {
    if ( v4 + (int)v2 > v7 + (int)v6 )
      goto LABEL_7;
    return 0;
  }
  v8 = v2 - 1;
  v9 = v6 - 1;
  v10 = (v8 - v9) & ~((int)(v8 - v9) >> 31);
  if ( v10 < (int)v2 )
  {
    v11 = *(_QWORD *)(a1 + 16);
    while ( 1 )
    {
      --v11;
      v12 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4LL * v9);
      v13 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4LL * (unsigned int)v11);
      if ( v13 != v12 )
        break;
      --v9;
      if ( v11 <= v10 )
      {
        if ( v10 - 1 < (int)v6 + ~(_DWORD)v2 + v10 )
          return 0;
        goto LABEL_7;
      }
    }
    if ( v13 <= v12 )
      return 0;
    goto LABEL_7;
  }
  if ( v8 < (int)v9 )
    return 0;
LABEL_7:
  v14 = v4 - v7;
  v15 = (unsigned int)(v4 - v7 - 1);
  if ( v4 - v7 < 1 )
  {
    LODWORD(v16) = v2;
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 24);
    v17 = (unsigned int)(v14 + v2);
    if ( v16 < v17 )
    {
      (**(void (__fastcall ***)(__int64, _QWORD))a1)(a1, (unsigned int)(v14 + v2));
      v16 = *(_QWORD *)(a1 + 24);
    }
    v18 = *(char **)(a1 + 8);
    if ( v16 >= v17 )
      v16 = (unsigned int)(v14 + v2);
    v19 = (unsigned int)(v2 - 1);
    *(_QWORD *)(a1 + 16) = v16;
    if ( (int)v2 < 1 )
      goto LABEL_24;
    v20 = v14 + (int)v19;
    if ( (unsigned int)v19 < 7 )
      goto LABEL_21;
    if ( &v18[4 * v20 + -4 * v19] > &v18[4 * v20] )
      goto LABEL_21;
    if ( v18 > &v18[4 * v19] )
      goto LABEL_21;
    v21 = &v18[4 * v19];
    v22 = &v18[4 * v20];
    if ( &v18[4 * (v20 - v19)] < v21 + 4 && v18 < v22 + 4 )
      goto LABEL_21;
    v23 = v19 + 1;
    v24 = v21 - 12;
    v25 = (v19 + 1) & 0x1FFFFFFF8LL;
    v26 = v22 - 12;
    v19 -= v25;
    v20 -= v25;
    v27 = v25;
    do
    {
      v29 = *((_OWORD *)v24 - 1);
      v28 = *(_OWORD *)v24;
      v27 -= 8LL;
      v24 -= 32;
      *((_OWORD *)v26 - 1) = v29;
      *(_OWORD *)v26 = v28;
      v26 -= 32;
    }
    while ( v27 );
    if ( v23 != v25 )
    {
LABEL_21:
      v30 = 4 * v20;
      do
      {
        v31 = *(_DWORD *)&v18[4 * v19--];
        *(_DWORD *)&v18[v30] = v31;
        v30 -= 4LL;
      }
      while ( v19 != -1 );
    }
    if ( v14 >= 1 )
    {
LABEL_24:
      memset(v18, 0, 4 * v15 + 4);
      LODWORD(v16) = *(_DWORD *)(a1 + 16);
    }
    v4 = *(_DWORD *)(a1 + 168) - v14;
    v6 = *(_QWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 168) = v4;
    v7 = *(_DWORD *)(a2 + 168);
  }
  v32 = 0;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v34 = *(_QWORD *)(a1 + 8);
        if ( v6 )
        {
          v35 = 0LL;
          v36 = *(unsigned int **)(a2 + 8);
          LODWORD(v37) = v7 - v4;
          do
          {
            v38 = (unsigned int)v37;
            v37 = (unsigned int)(v37 + 1);
            v39 = 4 * v38;
            --v6;
            v40 = *v36++;
            v41 = v35 - v40 + *(unsigned int *)(v34 + 4 * v38);
            v35 = v41 >> 63;
            *(_DWORD *)(v34 + v39) = v41;
          }
          while ( v6 );
          v34 = *(_QWORD *)(a1 + 8);
          if ( v41 < 0 )
          {
            LODWORD(v42) = *(_DWORD *)(v34 + 4 * v37);
            v43 = -1LL;
            do
            {
              v42 = v43 + (unsigned int)v42;
              v43 = v42 >> 63;
            }
            while ( v42 < 0 );
            *(_DWORD *)(v34 + 4 * v37) = v42;
            v34 = *(_QWORD *)(a1 + 8);
          }
        }
        v44 = (unsigned int)v16;
        if ( (int)v16 >= 1 )
          LODWORD(v16) = 1;
        while ( (int)v44 >= 2 )
        {
          if ( *(_DWORD *)(v34 - 4 + 4 * v44--) )
          {
            LODWORD(v16) = v44 + 1;
            break;
          }
        }
        v46 = *(_QWORD *)(a1 + 24);
        v47 = (unsigned int)v16;
        if ( v46 < (unsigned int)v16 )
        {
          (**(void (__fastcall ***)(__int64, _QWORD))a1)(a1, (unsigned int)v16);
          v46 = *(_QWORD *)(a1 + 24);
        }
        v4 = *(_DWORD *)(a1 + 168);
        v16 = v46 >= v47 ? v47 : v46;
        v7 = *(_DWORD *)(a2 + 168);
        ++v32;
        *(_QWORD *)(a1 + 16) = v16;
        v6 = *(_QWORD *)(a2 + 16);
        if ( v4 + (_DWORD)v16 == v7 + (_DWORD)v6 )
          break;
        if ( v4 + (int)v16 <= v7 + (int)v6 )
          return v32;
      }
      v48 = v16 - 1;
      v49 = v6 - 1;
      v50 = v16;
      v51 = (v48 - v49) & ~((int)(v48 - v49) >> 31);
      if ( v51 >= (int)v16 )
        break;
      v48 = v51 - 1;
      v52 = v6 + ~(_DWORD)v16 + v51;
      while ( 1 )
      {
        --v50;
        v53 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4LL * v49);
        v54 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4LL * (unsigned int)v50);
        if ( v54 != v53 )
          break;
        --v49;
        if ( v50 <= v51 )
          goto LABEL_58;
      }
      if ( v54 <= v53 )
        return v32;
    }
    v52 = v6 - 1;
LABEL_58:
    ;
  }
  while ( v48 >= v52 );
  return v32;
}


================================================================================
Function: sub_6814654 (0x6814654)
================================================================================

uint32x4_t *__fastcall sub_6814654(__int64 a1)
{
  __int64 v2; // x22
  unsigned __int64 v3; // x20
  unsigned __int64 v4; // x2
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x9
  __int64 v7; // x10
  unsigned __int64 v8; // x14
  unsigned __int64 v9; // x13
  unsigned __int64 v10; // x12
  __int64 v11; // x15
  __int64 v12; // x17
  __int128 v13; // t2
  unsigned __int64 v14; // x1
  unsigned __int64 v15; // x24
  unsigned __int64 v16; // x23
  unsigned __int64 v17; // x7
  unsigned __int64 v18; // x6
  unsigned __int64 v19; // x5
  unsigned __int64 v20; // x4
  unsigned __int64 v21; // x25
  int32x4_t *v22; // x26
  uint32x4_t *v23; // x21
  int32x4_t v24; // t1
  int32x4_t v25; // q0
  uint32x4_t v26; // t1
  int8x16_t v27; // q0
  uint32x4_t v28; // q0
  uint64x2_t v29; // q2
  uint64x2_t v30; // q0
  unsigned __int64 v31; // kr00_8
  unsigned __int64 v32; // kr10_8
  unsigned __int64 v33; // kr20_8
  unsigned __int64 v34; // kr30_8
  __int64 v35; // x3
  __int64 v36; // x4
  int v37; // w14
  int v38; // w3
  unsigned int v39; // w0
  unsigned int v40; // w1
  __int128 v41; // t2
  __int64 v42; // x4
  __int64 v43; // x5
  __int64 v44; // x4
  __int64 v45; // x23
  __int64 v46; // x26
  unsigned __int64 v47; // x27
  unsigned __int64 v48; // x25
  unsigned __int64 v49; // x24
  unsigned __int64 v50; // x20
  unsigned __int64 v51; // x7
  unsigned __int64 v52; // x6
  __int64 v53; // x28
  int32x4_t *v54; // x30
  uint32x4_t *v55; // x21
  int32x4_t v56; // t1
  int32x4_t v57; // q0
  uint32x4_t v58; // t1
  int8x16_t v59; // q0
  uint32x4_t v60; // q0
  uint64x2_t v61; // q2
  uint64x2_t v62; // q0
  unsigned __int64 v63; // kr60_8
  unsigned __int64 v64; // kr70_8
  unsigned __int64 v65; // kr80_8
  unsigned __int64 v66; // kr90_8
  unsigned int *v67; // x3
  unsigned int *v68; // x5
  int v69; // w4
  __int64 v70; // x8
  unsigned int v71; // t1
  unsigned int v72; // t1
  __int64 v73; // x10
  unsigned int v74; // w11
  unsigned __int64 v76; // x9
  unsigned __int64 v77; // x20
  int v78; // w8
  uint32x4_t *result; // x0
  unsigned __int64 v80; // [xsp+8h] [xbp-C8h]
  char v81[8]; // [xsp+18h] [xbp-B8h] BYREF
  uint32x4_t *v82; // [xsp+20h] [xbp-B0h]
  __int64 v83; // [xsp+38h] [xbp-98h] BYREF

  v2 = *(_QWORD *)(a1 + 16);
  v3 = (unsigned int)(2 * v2);
  sub_6814A6C(v81, a1);
  v5 = *(_QWORD *)(a1 + 24);
  if ( v5 < v3 )
  {
    (**(void (__fastcall ***)(__int64, _QWORD))a1)(a1, (unsigned int)(2 * v2));
    v5 = *(_QWORD *)(a1 + 24);
  }
  if ( v5 >= v3 )
    v6 = (unsigned int)(2 * v2);
  else
    v6 = v5;
  v7 = *(_QWORD *)(a1 + 8);
  v80 = v5;
  *(_QWORD *)(a1 + 16) = v6;
  if ( (int)v2 < 1 )
  {
    v9 = 0LL;
    v10 = 0LL;
    if ( (int)v3 <= (int)v2 )
      goto LABEL_32;
    goto LABEL_20;
  }
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = -3LL;
  v12 = 1LL;
  do
  {
    if ( v8 < 3 )
    {
      v14 = 0LL;
      v4 = v8;
LABEL_14:
      v4 *= 4LL;
      do
      {
        v35 = v82->n128_u32[v14++];
        v36 = *(unsigned int *)((char *)v82->n128_u32 + v4);
        v4 -= 4LL;
        v10 = (__PAIR128__(v10, v9) + (unsigned __int64)(v36 * v35)) >> 64;
        v9 += v36 * v35;
      }
      while ( v12 != v14 );
      goto LABEL_8;
    }
    v15 = 0LL;
    v14 = (v8 + 1) & 0xFFFFFFFFFFFFFFFCLL;
    v16 = 0LL;
    v17 = 0LL;
    v18 = 0LL;
    v19 = 0LL;
    v20 = 0LL;
    v21 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    v4 = v8 - v14;
    v22 = (uint32x4_t *)((char *)v82 + 4 * v11);
    v23 = v82;
    do
    {
      v24 = *v22--;
      v25 = v24;
      v26 = *v23++;
      v27 = vrev64q_s32(v25);
      v28 = vextq_s8(v27, v27, 8uLL);
      v29 = vmull_u32((uint32x2_t)v28.n128_u64[0], (uint32x2_t)v26.n128_u64[0]);
      v30 = vmull_high_u32(v28, v26);
      v31 = v9 + v29.n128_u64[0];
      v10 = (__PAIR128__(v10, v9) + v29.n128_u64[0]) >> 64;
      v9 += v29.n128_u64[0];
      v32 = v17 + v30.n128_u64[0];
      v18 = (__PAIR128__(v18, v17) + v30.n128_u64[0]) >> 64;
      v17 += v30.n128_u64[0];
      v33 = v19 + v30.n128_u64[1];
      v20 = (__PAIR128__(v20, v19) + v30.n128_u64[1]) >> 64;
      v19 += v30.n128_u64[1];
      v34 = v15 + v29.n128_u64[1];
      v16 = (__PAIR128__(v16, v15) + v29.n128_u64[1]) >> 64;
      v15 += v29.n128_u64[1];
      v21 -= 4LL;
    }
    while ( v21 );
    v10 = (__PAIR128__(v10, v31) + __PAIR128__(v16, v34) + __PAIR128__(v18, v32) + __PAIR128__(v20, v33)) >> 64;
    v9 = v31 + v34 + v32 + v33;
    if ( v8 + 1 != v14 )
      goto LABEL_14;
LABEL_8:
    *(_DWORD *)(v7 + 4 * v8) = v9;
    *((_QWORD *)&v13 + 1) = v10;
    *(_QWORD *)&v13 = v9;
    v9 = v13 >> 32;
    v10 >>= 32;
    ++v8;
    ++v12;
    ++v11;
  }
  while ( v8 != (unsigned int)v2 );
  v7 = *(_QWORD *)(a1 + 8);
  if ( (int)v3 > (int)v2 )
  {
LABEL_20:
    v37 = 0;
    v38 = 1;
    v39 = v2 - 2;
    v40 = v2;
    while ( 1 )
    {
      v4 = v38;
      if ( (int)(v40 - (v2 - 1)) < (int)v2 )
      {
        v42 = (unsigned int)(v2 - 2 - v37);
        if ( (unsigned int)v42 >= 3 )
        {
          v45 = v42 + 1;
          v46 = (v42 + 1) & 0x1FFFFFFFCLL;
          v47 = 0LL;
          v48 = 0LL;
          v49 = 0LL;
          v50 = 0LL;
          v51 = 0LL;
          v52 = 0LL;
          v53 = (v39 + 1LL) & 0x1FFFFFFFCLL;
          v43 = (int)v2 - v46;
          v44 = v46 + v38;
          v54 = (uint32x4_t *)((char *)v82 + 4 * (int)v2 - 16);
          v55 = (uint32x4_t *)((char *)v82 + 4 * v38);
          do
          {
            v56 = *v54--;
            v57 = v56;
            v58 = *v55++;
            v59 = vrev64q_s32(v57);
            v60 = vextq_s8(v59, v59, 8uLL);
            v61 = vmull_u32((uint32x2_t)v60.n128_u64[0], (uint32x2_t)v58.n128_u64[0]);
            v62 = vmull_high_u32(v60, v58);
            v63 = v9 + v61.n128_u64[0];
            v10 = (__PAIR128__(v10, v9) + v61.n128_u64[0]) >> 64;
            v64 = v49 + v62.n128_u64[0];
            v50 = (__PAIR128__(v50, v49) + v62.n128_u64[0]) >> 64;
            v49 += v62.n128_u64[0];
            v65 = v51 + v62.n128_u64[1];
            v52 = (__PAIR128__(v52, v51) + v62.n128_u64[1]) >> 64;
            v51 += v62.n128_u64[1];
            v66 = v47 + v61.n128_u64[1];
            v48 = (__PAIR128__(v48, v47) + v61.n128_u64[1]) >> 64;
            v47 += v61.n128_u64[1];
            v9 += v61.n128_u64[0];
            v53 -= 4LL;
          }
          while ( v53 );
          v10 = (__PAIR128__(v10, v63) + __PAIR128__(v48, v66) + __PAIR128__(v50, v64) + __PAIR128__(v52, v65)) >> 64;
          v9 = v63 + v66 + v64 + v65;
          if ( v45 == v46 )
            goto LABEL_21;
        }
        else
        {
          v43 = (int)v2;
          v44 = v38;
        }
        v67 = (unsigned int *)v82 + v44;
        v68 = (unsigned int *)v82 + v43 - 1;
        v69 = v2 - v44;
        do
        {
          v71 = *v67++;
          v70 = v71;
          v72 = *v68--;
          v10 = (__PAIR128__(v10, v9) + (unsigned __int64)v72 * v70) >> 64;
          v9 += v72 * v70;
          --v69;
        }
        while ( v69 );
      }
LABEL_21:
      *(_DWORD *)(v7 + 4LL * v40) = v9;
      *((_QWORD *)&v41 + 1) = v10;
      *(_QWORD *)&v41 = v9;
      v9 = v41 >> 32;
      v10 >>= 32;
      ++v40;
      v38 = v4 + 1;
      ++v37;
      --v39;
      if ( (_DWORD)v4 == (_DWORD)v2 )
      {
        v7 = *(_QWORD *)(a1 + 8);
        break;
      }
    }
  }
LABEL_32:
  v73 = v7 - 4;
  if ( (int)v6 >= 1 )
    v74 = 1;
  else
    v74 = v6;
  while ( (int)v6 >= 2 )
  {
    if ( *(_DWORD *)(v73 + 4 * v6--) )
    {
      v74 = v6 + 1;
      break;
    }
  }
  v76 = v80;
  v77 = v74;
  if ( v80 < v74 )
  {
    (**(void (__fastcall ***)(__int64, _QWORD, unsigned __int64))a1)(a1, v74, v4);
    v76 = *(_QWORD *)(a1 + 24);
  }
  v78 = *(_DWORD *)(a1 + 168);
  result = v82;
  if ( v76 >= v77 )
    v76 = v77;
  *(_QWORD *)(a1 + 16) = v76;
  *(_DWORD *)(a1 + 168) = 2 * v78;
  if ( result != (uint32x4_t *)&v83 )
    return (uint32x4_t *)sub_65ECAF4();
  return result;
}


================================================================================
Function: sub_6814A6C (0x6814A6C)
================================================================================

_QWORD *__fastcall sub_6814A6C(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2; // x19
  unsigned __int64 v3; // x13
  unsigned __int64 v4; // x21
  unsigned __int64 v5; // x9
  int *v6; // x10
  unsigned __int64 v7; // x22
  _DWORD *v8; // x11
  char *v9; // x12
  char *v10; // x15
  _OWORD *v11; // x16
  unsigned __int64 v12; // x14
  __int64 v13; // x10
  __int64 v14; // x17
  char *v15; // x11
  __int128 *v16; // x13
  __int128 v17; // q0
  __int128 v18; // q1
  int *v19; // x12
  int v20; // t1
  unsigned __int64 v21; // x9
  _QWORD *v22; // x20
  unsigned __int64 v23; // x8

  result[2] = 0LL;
  result[3] = 0LL;
  v2 = result;
  result[1] = 0LL;
  v3 = a2[1];
  v4 = a2[2];
  *result = off_6C59998;
  v5 = a2[3];
  v6 = (int *)v3;
  v7 = v4;
  if ( (_QWORD *)v3 == a2 + 4 )
  {
    v8 = result + 4;
    result[3] = v5;
    result[1] = result + 4;
    if ( v4 )
    {
      v9 = (char *)a2 + 4 * v4;
      if ( (unsigned __int64)&v9[-v3] >= 0xFFFFFFFFFFFFFFE4LL )
        goto LABEL_10;
      v10 = (char *)a2 + 4 * v4 - v3;
      if ( (unsigned __int64)(result + 4) < ((unsigned __int64)(v10 + 28) & 0xFFFFFFFFFFFFFFFCLL) + v3 + 4
        && (unsigned __int64)result + ((unsigned __int64)(v10 + 64) & 0xFFFFFFFFFFFFFFFCLL) > v3 )
      {
        goto LABEL_10;
      }
      v11 = result + 6;
      v12 = ((unsigned __int64)&v9[-v3 + 28] >> 2) + 1;
      v13 = 4 * (v12 & 0x7FFFFFFFFFFFFFF8LL);
      v14 = v12 & 0x7FFFFFFFFFFFFFF8LL;
      v15 = (char *)result + v13;
      v6 = (int *)(v3 + v13);
      v8 = v15 + 32;
      v16 = (__int128 *)(v3 + 16);
      do
      {
        v17 = *(v16 - 1);
        v18 = *v16;
        v16 += 2;
        v14 -= 8LL;
        *(v11 - 1) = v17;
        *v11 = v18;
        v11 += 2;
      }
      while ( v14 );
      if ( v12 != (v12 & 0x7FFFFFFFFFFFFFF8LL) )
      {
LABEL_10:
        v19 = (int *)(v9 + 32);
        do
        {
          v20 = *v6++;
          *v8++ = v20;
        }
        while ( v6 != v19 );
      }
    }
  }
  else
  {
    result[3] = v5;
    a2[3] = 0LL;
    v5 = result[3];
    result[1] = v3;
    a2[1] = a2 + 4;
  }
  if ( v5 >= v4 )
  {
    v7 = v5;
  }
  else
  {
    v21 = v5 + (v5 >> 1);
    if ( v21 >= v4 )
    {
      v7 = v21;
      if ( v21 >> 62 )
      {
        if ( v4 >> 62 )
          goto LABEL_26;
        v7 = 0x3FFFFFFFFFFFFFFFLL;
      }
    }
    else if ( v4 >> 62 )
    {
LABEL_26:
      sub_24FD568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    }
    v22 = (_QWORD *)result[1];
    result = (_QWORD *)sub_65ECAAC();
    v2[1] = result;
    v2[3] = v7;
    if ( v22 != v2 + 4 )
    {
      result = (_QWORD *)sub_65ECAF4();
      v7 = v2[3];
    }
  }
  if ( v7 >= v4 )
    v23 = v4;
  else
    v23 = v7;
  v2[2] = v23;
  return result;
}


================================================================================
Function: sub_6819C28 (0x6819C28)
================================================================================

__int64 sub_6819C28()
{
  unsigned int *v1; // x0
  __int64 v2; // [xsp+8h] [xbp-18h] BYREF
  __int64 v3; // [xsp+10h] [xbp-10h]
  __int64 v4; // [xsp+18h] [xbp-8h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( clock_gettime(0, (struct timespec *)&v2) )
  {
    v1 = (unsigned int *)__errno();
    sub_684D644(*v1, "clock_gettime(CLOCK_REALTIME) failed");
  }
  return v3 / 1000 + 1000000 * v2;
}


================================================================================
Function: sub_6819D00 (0x6819D00)
================================================================================

__int64 sub_6819D00()
{
  int *v1; // x0
  __int64 v2; // [xsp+8h] [xbp-18h] BYREF
  __int64 v3; // [xsp+10h] [xbp-10h]
  __int64 v4; // [xsp+18h] [xbp-8h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( clock_gettime(1, (struct timespec *)&v2) )
  {
    v1 = (int *)__errno();
    sub_684D644(*v1, "clock_gettime(CLOCK_MONOTONIC) failed");
  }
  return v3 + 1000000000 * v2;
}


================================================================================
Function: sub_6819D84 (0x6819D84)
================================================================================

__int64 __fastcall sub_6819D84(pthread_cond_t *a1)
{
  return pthread_cond_signal(a1);
}


================================================================================
Function: sub_6819DA4 (0x6819DA4)
================================================================================

__int64 __fastcall sub_6819DA4(pthread_cond_t *a1)
{
  return pthread_cond_broadcast(a1);
}


================================================================================
Function: sub_6819F00 (0x6819F00)
================================================================================

bool sub_6819F00()
{
  return (int)sub_6862688() > 0;
}


================================================================================
Function: sub_681B888 (0x681B888)
================================================================================

unsigned __int64 __fastcall sub_681B888(unsigned __int64 a1)
{
  unsigned __int64 v1; // x9
  unsigned int *v2; // x8
  unsigned __int64 v3; // x10
  unsigned int *v4; // x12
  unsigned int *v5; // x12
  unsigned int v6; // t1
  unsigned __int64 result; // x0
  unsigned __int64 v8; // x12
  unsigned __int64 v9; // x8
  __int64 v10; // x13
  unsigned int *v11; // x11
  unsigned __int64 v12; // x14
  unsigned int *v13; // x16
  unsigned int *v14; // x16
  unsigned int v15; // t1
  __int64 v16; // x10
  __int64 v17; // x13
  unsigned __int64 v18; // x14
  unsigned __int64 v19; // x13
  unsigned __int64 v20; // x15
  unsigned __int64 v21; // x16
  unsigned __int64 v22; // x16
  unsigned __int64 v23; // x16
  unsigned __int64 v24; // x16
  unsigned __int64 v25; // x16
  unsigned __int64 v26; // x16
  unsigned __int64 v27; // x16
  unsigned __int64 v28; // x16
  unsigned __int64 v29; // x16
  unsigned __int64 v30; // x16
  unsigned __int64 v31; // x16
  unsigned __int64 v32; // x16
  unsigned __int64 v33; // x16
  unsigned __int64 v34; // x16
  unsigned __int64 v35; // x16
  unsigned __int64 v36; // x16
  unsigned __int64 v37; // x16
  unsigned __int64 v38; // x16
  unsigned __int64 v39; // x16
  unsigned __int64 v40; // x16
  unsigned __int64 v41; // x16
  unsigned __int64 v42; // x16
  unsigned __int64 v43; // x16
  unsigned __int64 v44; // x16
  unsigned __int64 v45; // x16
  unsigned __int64 v46; // x16
  unsigned __int64 v47; // x16
  unsigned __int64 v48; // x16
  unsigned __int64 v49; // x16
  unsigned __int64 v50; // x16
  unsigned __int64 v51; // x16
  unsigned __int64 v52; // x16
  unsigned __int64 v53; // x16
  unsigned __int64 v54; // x16
  unsigned __int64 v55; // x16
  unsigned __int64 v56; // x16
  unsigned __int64 v57; // x16
  unsigned __int64 v58; // x16
  unsigned __int64 v59; // x16
  unsigned __int64 v60; // x16
  unsigned __int64 v61; // x16
  unsigned __int64 v62; // x16
  unsigned __int64 v63; // x16
  unsigned __int64 v64; // x16
  unsigned __int64 v65; // x16
  unsigned __int64 v66; // x16
  unsigned __int64 v67; // x14

  if ( a1 > 0xD3 )
  {
    if ( a1 >= 0xFFFFFFFFFFFFFFC6LL )
      sub_681BFA8("__next_prime overflow");
    v8 = 48LL;
    v9 = a1 / 0xD2;
    v10 = 210 * (a1 / 0xD2);
    v11 = dword_174E098;
    do
    {
      v12 = v8 >> 1;
      v13 = &v11[v8 >> 1];
      v8 += ~(v8 >> 1);
      v15 = *v13;
      v14 = v13 + 1;
      if ( a1 % 0xD2 > v15 )
        v11 = v14;
      else
        v8 = v12;
    }
    while ( v8 );
    v16 = v11 - dword_174E098;
LABEL_16:
    result = v10 + dword_174E098[v16];
    v17 = 20LL;
    while ( 1 )
    {
      v18 = *(unsigned int *)((char *)&unk_174DFD8 + v17);
      if ( result / v18 < v18 )
        break;
      if ( result == result / v18 * v18 )
      {
LABEL_117:
        if ( v16 == 47 )
        {
          ++v9;
          v16 = 0LL;
        }
        else
        {
          ++v16;
        }
        v10 = 210 * v9;
        goto LABEL_16;
      }
      v17 += 4LL;
      if ( v17 == 188 )
      {
        v19 = 419LL;
        while ( 1 )
        {
          v20 = result / (v19 - 208);
          if ( v20 < v19 - 208 )
            return result;
          if ( result == v20 * (v19 - 208) )
            goto LABEL_117;
          v21 = result / (v19 - 198);
          if ( v21 < v19 - 198 )
            return result;
          if ( result == v21 * (v19 - 198) )
            goto LABEL_117;
          v22 = result / (v19 - 196);
          if ( v22 < v19 - 196 )
            return result;
          if ( result == v22 * (v19 - 196) )
            goto LABEL_117;
          v23 = result / (v19 - 192);
          if ( v23 < v19 - 192 )
            return result;
          if ( result == v23 * (v19 - 192) )
            goto LABEL_117;
          v24 = result / (v19 - 190);
          if ( v24 < v19 - 190 )
            return result;
          if ( result == v24 * (v19 - 190) )
            goto LABEL_117;
          v25 = result / (v19 - 186);
          if ( v25 < v19 - 186 )
            return result;
          if ( result == v25 * (v19 - 186) )
            goto LABEL_117;
          v26 = result / (v19 - 180);
          if ( v26 < v19 - 180 )
            return result;
          if ( result == v26 * (v19 - 180) )
            goto LABEL_117;
          v27 = result / (v19 - 178);
          if ( v27 < v19 - 178 )
            return result;
          if ( result == v27 * (v19 - 178) )
            goto LABEL_117;
          v28 = result / (v19 - 172);
          if ( v28 < v19 - 172 )
            return result;
          if ( result == v28 * (v19 - 172) )
            goto LABEL_117;
          v29 = result / (v19 - 168);
          if ( v29 < v19 - 168 )
            return result;
          if ( result == v29 * (v19 - 168) )
            goto LABEL_117;
          v30 = result / (v19 - 166);
          if ( v30 < v19 - 166 )
            return result;
          if ( result == v30 * (v19 - 166) )
            goto LABEL_117;
          v31 = result / (v19 - 162);
          if ( v31 < v19 - 162 )
            return result;
          if ( result == v31 * (v19 - 162) )
            goto LABEL_117;
          v32 = result / (v19 - 156);
          if ( v32 < v19 - 156 )
            return result;
          if ( result == v32 * (v19 - 156) )
            goto LABEL_117;
          v33 = result / (v19 - 150);
          if ( v33 < v19 - 150 )
            return result;
          if ( result == v33 * (v19 - 150) )
            goto LABEL_117;
          v34 = result / (v19 - 148);
          if ( v34 < v19 - 148 )
            return result;
          if ( result == v34 * (v19 - 148) )
            goto LABEL_117;
          v35 = result / (v19 - 142);
          if ( v35 < v19 - 142 )
            return result;
          if ( result == v35 * (v19 - 142) )
            goto LABEL_117;
          v36 = result / (v19 - 138);
          if ( v36 < v19 - 138 )
            return result;
          if ( result == v36 * (v19 - 138) )
            goto LABEL_117;
          v37 = result / (v19 - 136);
          if ( v37 < v19 - 136 )
            return result;
          if ( result == v37 * (v19 - 136) )
            goto LABEL_117;
          v38 = result / (v19 - 130);
          if ( v38 < v19 - 130 )
            return result;
          if ( result == v38 * (v19 - 130) )
            goto LABEL_117;
          v39 = result / (v19 - 126);
          if ( v39 < v19 - 126 )
            return result;
          if ( result == v39 * (v19 - 126) )
            goto LABEL_117;
          v40 = result / (v19 - 120);
          if ( v40 < v19 - 120 )
            return result;
          if ( result == v40 * (v19 - 120) )
            goto LABEL_117;
          v41 = result / (v19 - 112);
          if ( v41 < v19 - 112 )
            return result;
          if ( result == v41 * (v19 - 112) )
            goto LABEL_117;
          v42 = result / (v19 - 108);
          if ( v42 < v19 - 108 )
            return result;
          if ( result == v42 * (v19 - 108) )
            goto LABEL_117;
          v43 = result / (v19 - 106);
          if ( v43 < v19 - 106 )
            return result;
          if ( result == v43 * (v19 - 106) )
            goto LABEL_117;
          v44 = result / (v19 - 102);
          if ( v44 < v19 - 102 )
            return result;
          if ( result == v44 * (v19 - 102) )
            goto LABEL_117;
          v45 = result / (v19 - 100);
          if ( v45 < v19 - 100 )
            return result;
          if ( result == v45 * (v19 - 100) )
            goto LABEL_117;
          v46 = result / (v19 - 96);
          if ( v46 < v19 - 96 )
            return result;
          if ( result == v46 * (v19 - 96) )
            goto LABEL_117;
          v47 = result / (v19 - 88);
          if ( v47 < v19 - 88 )
            return result;
          if ( result == v47 * (v19 - 88) )
            goto LABEL_117;
          v48 = result / (v19 - 82);
          if ( v48 < v19 - 82 )
            return result;
          if ( result == v48 * (v19 - 82) )
            goto LABEL_117;
          v49 = result / (v19 - 78);
          if ( v49 < v19 - 78 )
            return result;
          if ( result == v49 * (v19 - 78) )
            goto LABEL_117;
          v50 = result / (v19 - 72);
          if ( v50 < v19 - 72 )
            return result;
          if ( result == v50 * (v19 - 72) )
            goto LABEL_117;
          v51 = result / (v19 - 70);
          if ( v51 < v19 - 70 )
            return result;
          if ( result == v51 * (v19 - 70) )
            goto LABEL_117;
          v52 = result / (v19 - 66);
          if ( v52 < v19 - 66 )
            return result;
          if ( result == v52 * (v19 - 66) )
            goto LABEL_117;
          v53 = result / (v19 - 60);
          if ( v53 < v19 - 60 )
            return result;
          if ( result == v53 * (v19 - 60) )
            goto LABEL_117;
          v54 = result / (v19 - 58);
          if ( v54 < v19 - 58 )
            return result;
          if ( result == v54 * (v19 - 58) )
            goto LABEL_117;
          v55 = result / (v19 - 52);
          if ( v55 < v19 - 52 )
            return result;
          if ( result == v55 * (v19 - 52) )
            goto LABEL_117;
          v56 = result / (v19 - 46);
          if ( v56 < v19 - 46 )
            return result;
          if ( result == v56 * (v19 - 46) )
            goto LABEL_117;
          v57 = result / (v19 - 42);
          if ( v57 < v19 - 42 )
            return result;
          if ( result == v57 * (v19 - 42) )
            goto LABEL_117;
          v58 = result / (v19 - 40);
          if ( v58 < v19 - 40 )
            return result;
          if ( result == v58 * (v19 - 40) )
            goto LABEL_117;
          v59 = result / (v19 - 36);
          if ( v59 < v19 - 36 )
            return result;
          if ( result == v59 * (v19 - 36) )
            goto LABEL_117;
          v60 = result / (v19 - 30);
          if ( v60 < v19 - 30 )
            return result;
          if ( result == v60 * (v19 - 30) )
            goto LABEL_117;
          v61 = result / (v19 - 28);
          if ( v61 < v19 - 28 )
            return result;
          if ( result == v61 * (v19 - 28) )
            goto LABEL_117;
          v62 = result / (v19 - 22);
          if ( v62 < v19 - 22 )
            return result;
          if ( result == v62 * (v19 - 22) )
            goto LABEL_117;
          v63 = result / (v19 - 18);
          if ( v63 < v19 - 18 )
            return result;
          if ( result == v63 * (v19 - 18) )
            goto LABEL_117;
          v64 = result / (v19 - 16);
          if ( v64 < v19 - 16 )
            return result;
          if ( result == v64 * (v19 - 16) )
            goto LABEL_117;
          v65 = result / (v19 - 12);
          if ( v65 < v19 - 12 )
            return result;
          if ( result == v65 * (v19 - 12) )
            goto LABEL_117;
          v66 = result / (v19 - 10);
          if ( v66 < v19 - 10 )
            return result;
          if ( result == v66 * (v19 - 10) )
            goto LABEL_117;
          if ( result / v19 < v19 )
            return result;
          v67 = result / v19 * v19;
          v19 += 210LL;
          if ( result == v67 )
            goto LABEL_117;
        }
      }
    }
  }
  else
  {
    v1 = 48LL;
    v2 = (unsigned int *)&unk_174DFD8;
    do
    {
      v3 = v1 >> 1;
      v4 = &v2[v1 >> 1];
      v1 += ~(v1 >> 1);
      v6 = *v4;
      v5 = v4 + 1;
      if ( v6 < a1 )
        v2 = v5;
      else
        v1 = v3;
    }
    while ( v1 );
    return *v2;
  }
  return result;
}


================================================================================
Function: sub_681BFA8 (0x681BFA8)
================================================================================

void __fastcall __noreturn sub_681BFA8(__int64 a1)
{
  __int64 v2; // x19

  v2 = sub_6861FD0(16LL);
  sub_681BFFC(v2, a1);
  sub_6862048(v2, (__int64)&`typeinfo for'std::overflow_error, (__int64)sub_6865364);
}


================================================================================
Function: sub_681BFFC (0x681BFFC)
================================================================================

__int64 __fastcall sub_681BFFC(_QWORD *a1, char *a2)
{
  __int64 result; // x0

  result = sub_684956C((int)a1, a2);
  *a1 = off_6C5F030;
  return result;
}


================================================================================
Function: sub_681C034 (0x681C034)
================================================================================

__int64 sub_681C034()
{
  return sub_681C03C();
}


================================================================================
Function: sub_681C03C (0x681C03C)
================================================================================

unsigned __int64 __fastcall sub_681C03C(_QWORD *a1)
{
  __int64 v2; // x8
  __int64 v3; // x20

  v2 = a1[9];
  *a1 = off_6C59D68;
  if ( v2 )
  {
    v3 = v2 - 1;
    do
    {
      (*(void (__fastcall **)(_QWORD, _QWORD *, _QWORD))(a1[7] + 8 * v3))(0LL, a1, *(unsigned int *)(a1[8] + 4 * v3));
      --v3;
    }
    while ( v3 != -1 );
  }
  sub_683B844(a1 + 6);
  sub_67F3C08(a1[7]);
  sub_67F3C08(a1[8]);
  sub_67F3C08(a1[11]);
  return sub_67F3C08(a1[14]);
}


================================================================================
Function: sub_681C128 (0x681C128)
================================================================================

long double __fastcall sub_681C128(__int64 a1)
{
  long double result; // q0

  *(_QWORD *)a1 = off_6C27F08;
  sub_683B7A0(a1 + 8);
  *(_OWORD *)&result = 0uLL;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}


================================================================================
Function: sub_681C568 (0x681C568)
================================================================================

void sub_681C568()
{
  ;
}


================================================================================
Function: sub_681C570 (0x681C570)
================================================================================

__int64 __fastcall sub_681C570(__int64 result, _QWORD *a2, char a3)
{
  char *v3; // x8
  int v4; // w9
  int v5; // w10
  int v6; // w9
  _BYTE *v7; // x19
  __int64 *v10; // x8
  __int64 v11; // x21
  _QWORD *v12; // x22
  unsigned __int8 *v13; // x8
  __int64 v14; // x8
  char *v15; // x8
  int v16; // w11
  int v17; // w9
  __int64 v18[2]; // [xsp+0h] [xbp-10h] BYREF

  v18[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_BYTE *)result = 0;
  v3 = (char *)a2 + *(_QWORD *)(*a2 - 24LL);
  v4 = *((_DWORD *)v3 + 8);
  if ( v4 )
  {
    v5 = *((_DWORD *)v3 + 9);
    v6 = v4 | (*((_QWORD *)v3 + 5) == 0LL) | 4;
    *((_DWORD *)v3 + 8) = v6;
    if ( (v6 & v5) != 0 )
      goto LABEL_3;
  }
  else
  {
    v7 = (_BYTE *)result;
    result = *((_QWORD *)v3 + 17);
    if ( result )
      result = sub_65FFD70();
    if ( (a3 & 1) == 0 )
    {
      v10 = (_QWORD *)((char *)a2 + *(_QWORD *)(*a2 - 24LL));
      if ( (*((_BYTE *)v10 + 9) & 0x10) != 0 )
      {
        sub_683B82C(v18, v10 + 6);
        v11 = sub_683BBD0(v18, &unk_79D7E58);
        result = sub_683B844(v18);
        v12 = *(_QWORD **)((char *)a2 + *(_QWORD *)(*a2 - 24LL) + 40);
        if ( !v12 )
          goto LABEL_22;
        while ( 1 )
        {
          if ( v12[3] == v12[4] )
          {
            result = (*(__int64 (__fastcall **)(_QWORD *))(*v12 + 72LL))(v12);
            if ( (_DWORD)result == -1 )
              goto LABEL_22;
          }
          v13 = (unsigned __int8 *)v12[3];
          if ( v13 == (unsigned __int8 *)v12[4] )
          {
            result = (*(__int64 (__fastcall **)(_QWORD *))(*v12 + 72LL))(v12);
            if ( (result & 0x80) != 0 )
              break;
          }
          else
          {
            result = *v13;
            if ( (result & 0x80) != 0 )
              break;
          }
          if ( (*(_QWORD *)(*(_QWORD *)(v11 + 16) + 8LL * (unsigned __int8)result) & 1) == 0 )
            break;
          v14 = v12[3];
          if ( v14 == v12[4] )
            (*(void (__fastcall **)(_QWORD *))(*v12 + 80LL))(v12);
          else
            v12[3] = v14 + 1;
        }
        if ( v12[3] == v12[4] )
        {
          result = (*(__int64 (__fastcall **)(_QWORD *))(*v12 + 72LL))(v12);
          if ( (_DWORD)result == -1 )
          {
LABEL_22:
            v15 = (char *)a2 + *(_QWORD *)(*a2 - 24LL);
            v16 = *((_DWORD *)v15 + 9);
            v17 = *((_DWORD *)v15 + 8) | (*((_QWORD *)v15 + 5) == 0LL) | 6;
            *((_DWORD *)v15 + 8) = v17;
            if ( (v17 & v16) != 0 )
LABEL_3:
              sub_681F46C("ios_base::clear");
          }
        }
      }
    }
    *v7 = *(_DWORD *)((char *)a2 + *(_QWORD *)(*a2 - 24LL) + 32) == 0;
  }
  return result;
}


================================================================================
Function: sub_681C794 (0x681C794)
================================================================================

__int64 __usercall sub_681C794@<X0>(__int64 a1@<X0>, __int64 *a2@<X8>)
{
  return sub_683B82C(a2, (__int64 *)(a1 + 48));
}


================================================================================
Function: sub_681CC68 (0x681CC68)
================================================================================

char *__fastcall sub_681CC68(char *a1, __int64 a2)
{
  __int64 v4; // x0
  char *v5; // x8
  int v6; // w10
  int v7; // w9
  char v9[8]; // [xsp+8h] [xbp-18h] BYREF
  char v10[4]; // [xsp+10h] [xbp-10h] BYREF
  int v11; // [xsp+14h] [xbp-Ch] BYREF
  __int64 v12; // [xsp+18h] [xbp-8h]

  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = 0;
  sub_681C570(v10, a1, 0LL);
  if ( v10[0] )
  {
    sub_683B82C(v9, &a1[*(_QWORD *)(*(_QWORD *)a1 - 24LL) + 48]);
    v4 = sub_683BBD0(v9, &unk_79D7CE0);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD, char *, int *, __int64))(*(_QWORD *)v4 + 64LL))(
      v4,
      *(_QWORD *)&a1[*(_QWORD *)(*(_QWORD *)a1 - 24LL) + 40],
      0LL,
      &a1[*(_QWORD *)(*(_QWORD *)a1 - 24LL)],
      &v11,
      a2);
    sub_683B844(v9);
    v5 = &a1[*(_QWORD *)(*(_QWORD *)a1 - 24LL)];
    v6 = *((_DWORD *)v5 + 9);
    v7 = *((_DWORD *)v5 + 8) | v11 | (*((_QWORD *)v5 + 5) == 0LL);
    *((_DWORD *)v5 + 8) = v7;
    if ( (v7 & v6) != 0 )
      sub_681F46C("ios_base::clear");
  }
  return a1;
}


================================================================================
Function: sub_681DD74 (0x681DD74)
================================================================================

_QWORD *__fastcall sub_681DD74(_QWORD *result, __int64 *a2)
{
  __int64 v2; // x8
  char *v3; // x8
  _BYTE *v4; // x19

  v2 = *a2;
  *(_BYTE *)result = 0;
  result[1] = a2;
  v3 = (char *)a2 + *(_QWORD *)(v2 - 24);
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = result;
    result = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( result )
      result = sub_65FFD70(result);
    *v4 = 1;
  }
  return result;
}


================================================================================
Function: sub_681DDC8 (0x681DDC8)
================================================================================

__int64 __fastcall sub_681DDC8(__int64 result)
{
  __int64 v1; // x8
  __int64 v2; // x19
  __int64 v3; // x0
  __int64 v4; // x8
  int v5; // w10
  int v6; // w9

  v1 = *(_QWORD *)(result + 8) + *(_QWORD *)(**(_QWORD **)(result + 8) - 24LL);
  if ( *(_QWORD *)(v1 + 40) )
  {
    if ( !*(_DWORD *)(v1 + 32) && (*(_BYTE *)(v1 + 9) & 0x20) != 0 )
    {
      v2 = result;
      result = sub_6819F00(result);
      if ( (result & 1) == 0 )
      {
        v3 = *(_QWORD *)(*(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL) + 40LL);
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 48LL))(v3);
        if ( (_DWORD)result == -1 )
        {
          v4 = *(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL);
          v5 = *(_DWORD *)(v4 + 36);
          v6 = *(_DWORD *)(v4 + 32) | 1;
          *(_DWORD *)(v4 + 32) = v6;
          if ( (v5 & v6) != 0 )
            sub_681F46C("ios_base::clear");
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_681F428 (0x681F428)
================================================================================

__int64 __fastcall sub_681F428(__int64 result, int a2)
{
  int v2; // w9
  int v3; // w8

  v2 = *(_DWORD *)(result + 36);
  v3 = (*(_QWORD *)(result + 40) == 0LL) | a2;
  *(_DWORD *)(result + 32) = v3;
  if ( (v2 & v3) != 0 )
    sub_681F46C("ios_base::clear");
  return result;
}


================================================================================
Function: sub_681F46C (0x681F46C)
================================================================================

void __fastcall __noreturn sub_681F46C(char *a1)
{
  _QWORD *v2; // x19
  unsigned __int8 v3; // w8

  v2 = (_QWORD *)sub_6861FD0(32LL);
  v3 = atomic_load(byte_79D7518);
  if ( (v3 & 1) == 0 )
  {
    if ( (unsigned int)sub_68626F8((__int64)byte_79D7518) )
    {
      sub_684CDE0(&qword_79D7510);
      qword_79D7510 = (__int64)off_6C59EF8;
      __cxa_atexit((void (*)(void *))sub_684D6F0, &qword_79D7510, &off_686E780);
      sub_6862850(byte_79D7518);
    }
  }
  sub_684D49C((__int64)v2, 1LL, (__int64)&qword_79D7510, a1);
  *v2 = off_6C59D40;
  sub_6862048((__int64)v2, (__int64)&`typeinfo for'std::ios_base::failure, (__int64)sub_681F334);
}


================================================================================
Function: sub_681F548 (0x681F548)
================================================================================

__int64 __fastcall sub_681F548(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 40) = a2;
  *(_DWORD *)(a1 + 32) = a2 == 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_OWORD *)(a1 + 16) = xmmword_B02690;
  *(_DWORD *)(a1 + 8) = 4098;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  return sub_683B7A0(a1 + 48);
}


================================================================================
Function: sub_6836BE4 (0x6836BE4)
================================================================================

__int64 __fastcall sub_6836BE4(__int64 a1, __int64 a2)
{
  unsigned __int8 v3; // w8
  unsigned __int8 v4; // w8
  unsigned __int8 v5; // w8

  *(_BYTE *)(a1 + 272) = 1;
  *(_QWORD *)a1 = &off_6C5A1B8;
  *(_QWORD *)(a1 + 8) = a2 - 1;
  *(_WORD *)(a1 + 288) = 17154;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 32) = a1 + 272;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_BYTE *)(a1 + 290) = 0;
  *(_QWORD *)(a1 + 16) = a1 + 48;
  *(_QWORD *)(a1 + 24) = a1 + 48;
  qword_79D87E0 = (__int64)off_6C5A9B8;
  *(_QWORD *)algn_79D87E8 = 0LL;
  sub_68371E4();
  qword_79D87F0 = (__int64)off_6C5A9F8;
  *(_QWORD *)algn_79D87F8 = 0LL;
  sub_683730C(a1);
  byte_79D8818 = 0;
  qword_79D8810 = (__int64)&unk_174E670;
  qword_79D8800 = (__int64)off_6C5A260;
  *(_QWORD *)algn_79D8808 = 0LL;
  sub_6837434(a1);
  qword_79D8820 = (__int64)off_6C5A598;
  *(_QWORD *)algn_79D8828 = 0LL;
  sub_683755C(a1);
  qword_79D8830 = (__int64)off_6C5A668;
  *(_QWORD *)algn_79D8838 = 0LL;
  sub_6837684(a1);
  qword_79D8840 = (__int64)off_6C5A3B8;
  *(_QWORD *)algn_79D8848 = 0LL;
  v3 = atomic_load(byte_79D7E08);
  if ( (v3 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_79D7E08) )
  {
    qword_79D7E00 = newlocale(8127LL, "C", 0LL);
    sub_6862850(byte_79D7E08);
  }
  qword_79D8850 = qword_79D7E00;
  sub_68377AC(a1, &qword_79D8840);
  qword_79D8860 = (__int64)off_6C5A710;
  *(_QWORD *)algn_79D8868 = 0LL;
  sub_68378D4(a1);
  qword_79D8870 = (__int64)off_6C5A7A8;
  *(_QWORD *)algn_79D8878 = 0LL;
  sub_68379FC(a1);
  qword_79D88A0 = 0LL;
  unk_79D88A8 = 0LL;
  word_79D8890 = 11310;
  qword_79D8898 = 0LL;
  qword_79D8880 = (__int64)off_6C5A418;
  *(_QWORD *)algn_79D8888 = 0LL;
  sub_6837B24(a1);
  qword_79D88D0 = 0LL;
  unk_79D88D8 = 0LL;
  qword_79D88C8 = 0LL;
  qword_79D88C0 = 0x2C0000002ELL;
  qword_79D88B0 = (__int64)off_6C5A468;
  *(_QWORD *)algn_79D88B8 = 0LL;
  sub_6837C4C(a1);
  qword_79D88E0 = (__int64)off_6C5AA38;
  *(_QWORD *)algn_79D88E8 = 0LL;
  sub_6837D74(a1);
  qword_79D88F0 = (__int64)off_6C5AB28;
  *(_QWORD *)algn_79D88F8 = 0LL;
  sub_6837E9C(a1);
  qword_79D8900 = (__int64)off_6C5AC08;
  *(_QWORD *)algn_79D8908 = 0LL;
  sub_6837FC4(a1);
  qword_79D8910 = (__int64)off_6C5ACE0;
  *(_QWORD *)algn_79D8918 = 0LL;
  sub_68380EC(a1);
  qword_79D8920 = (__int64)off_6C5B398;
  *(_QWORD *)algn_79D8928 = 0LL;
  sub_6838214(a1);
  qword_79D8930 = (__int64)off_6C5B450;
  *(_QWORD *)algn_79D8938 = 0LL;
  sub_683833C(a1);
  qword_79D8940 = (__int64)off_6C5B4F8;
  *(_QWORD *)algn_79D8948 = 0LL;
  sub_6838464(a1);
  qword_79D8950 = (__int64)off_6C5B5A0;
  *(_QWORD *)algn_79D8958 = 0LL;
  sub_683858C(a1);
  qword_79D8960 = (__int64)off_6C5B868;
  *(_QWORD *)algn_79D8968 = 0LL;
  sub_68386B4(a1);
  qword_79D8970 = (__int64)off_6C5B8E8;
  *(_QWORD *)algn_79D8978 = 0LL;
  sub_68387DC(a1);
  qword_79D8980 = (__int64)off_6C5B968;
  *(_QWORD *)algn_79D8988 = 0LL;
  sub_6838904(a1);
  qword_79D8990 = (__int64)off_6C5B9E8;
  *(_QWORD *)algn_79D8998 = 0LL;
  sub_6838A2C(a1);
  qword_79D89A0 = (__int64)off_6C5ADA8;
  *(_QWORD *)algn_79D89A8 = 0LL;
  qword_79D89B0 = (__int64)off_6C5AE08;
  sub_6838B54(a1);
  qword_79D89C0 = (__int64)off_6C5AEB8;
  *(_QWORD *)algn_79D89C8 = 0LL;
  qword_79D89D0 = (__int64)off_6C5AF18;
  sub_6838C7C(a1);
  qword_79D89E0 = (__int64)off_6C5A558;
  *(_QWORD *)algn_79D89E8 = 0LL;
  v4 = atomic_load(byte_79D7E08);
  if ( (v4 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_79D7E08) )
  {
    qword_79D7E00 = newlocale(8127LL, "C", 0LL);
    sub_6862850(byte_79D7E08);
  }
  qword_79D89F0 = qword_79D7E00;
  qword_79D89E0 = (__int64)off_6C5B228;
  sub_6838DA4(a1, &qword_79D89E0);
  qword_79D8A00 = (__int64)off_6C5A558;
  *(_QWORD *)algn_79D8A08 = 0LL;
  v5 = atomic_load(byte_79D7E08);
  if ( (v5 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_79D7E08) )
  {
    qword_79D7E00 = newlocale(8127LL, "C", 0LL);
    sub_6862850(byte_79D7E08);
  }
  qword_79D8A10 = qword_79D7E00;
  qword_79D8A00 = (__int64)off_6C5B2A0;
  sub_6838ECC(a1, &qword_79D8A00);
  qword_79D8A20 = (__int64)off_6C5BA68;
  *(_QWORD *)algn_79D8A28 = 0LL;
  sub_6838FF4(a1);
  qword_79D8A30 = (__int64)off_6C5BAF0;
  *(_QWORD *)algn_79D8A38 = 0LL;
  return sub_683911C(a1);
}


================================================================================
Function: sub_68371E4 (0x68371E4)
================================================================================

__int64 __fastcall sub_68371E4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7CC0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7CC0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7CC0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7CC8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_683730C (0x683730C)
================================================================================

__int64 __fastcall sub_683730C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7CD0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7CD0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7CD0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7CD8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6837434 (0x6837434)
================================================================================

__int64 __fastcall sub_6837434(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7E58;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7E58);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7E58, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7E60 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_683755C (0x683755C)
================================================================================

__int64 __fastcall sub_683755C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7E48;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7E48);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7E48, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7E50 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6837684 (0x6837684)
================================================================================

__int64 __fastcall sub_6837684(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7E68;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7E68);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7E68, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7E70 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_68377AC (0x68377AC)
================================================================================

__int64 __fastcall sub_68377AC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7E78;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7E78);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7E78, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7E80 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_68378D4 (0x68378D4)
================================================================================

__int64 __fastcall sub_68378D4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7E88;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7E88);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7E88, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7E90 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_68379FC (0x68379FC)
================================================================================

__int64 __fastcall sub_68379FC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7E98;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7E98);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7E98, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7EA0 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6837B24 (0x6837B24)
================================================================================

__int64 __fastcall sub_6837B24(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7EA8;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7EA8);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7EA8, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7EB0 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6837C4C (0x6837C4C)
================================================================================

__int64 __fastcall sub_6837C4C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7EB8;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7EB8);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7EB8, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7EC0 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6837D74 (0x6837D74)
================================================================================

__int64 __fastcall sub_6837D74(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7CE0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7CE0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7CE0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7CE8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6837E9C (0x6837E9C)
================================================================================

__int64 __fastcall sub_6837E9C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7CF0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7CF0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7CF0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7CF8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6837FC4 (0x6837FC4)
================================================================================

__int64 __fastcall sub_6837FC4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D00;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D00);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D00, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D08 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_68380EC (0x68380EC)
================================================================================

__int64 __fastcall sub_68380EC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D10;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D10);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D10, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D18 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6838214 (0x6838214)
================================================================================

__int64 __fastcall sub_6838214(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D60;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D60);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D60, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D68 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_683833C (0x683833C)
================================================================================

__int64 __fastcall sub_683833C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D70;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D70);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D70, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D78 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6838464 (0x6838464)
================================================================================

__int64 __fastcall sub_6838464(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D80;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D80);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D80, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D88 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_683858C (0x683858C)
================================================================================

__int64 __fastcall sub_683858C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D90;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D90);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D90, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D98 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_68386B4 (0x68386B4)
================================================================================

__int64 __fastcall sub_68386B4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7DA0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7DA0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7DA0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7DA8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_68387DC (0x68387DC)
================================================================================

__int64 __fastcall sub_68387DC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7DB0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7DB0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7DB0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7DB8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6838904 (0x6838904)
================================================================================

__int64 __fastcall sub_6838904(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7DC0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7DC0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7DC0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7DC8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6838A2C (0x6838A2C)
================================================================================

__int64 __fastcall sub_6838A2C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7DD0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7DD0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7DD0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7DD8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6838B54 (0x6838B54)
================================================================================

__int64 __fastcall sub_6838B54(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D20;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D20);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D20, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D28 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6838C7C (0x6838C7C)
================================================================================

__int64 __fastcall sub_6838C7C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D30;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D30);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D30, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D38 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6838DA4 (0x6838DA4)
================================================================================

__int64 __fastcall sub_6838DA4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D40;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D40);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D40, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D48 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6838ECC (0x6838ECC)
================================================================================

__int64 __fastcall sub_6838ECC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7D50;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7D50);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7D50, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7D58 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_6838FF4 (0x6838FF4)
================================================================================

__int64 __fastcall sub_6838FF4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7DE0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7DE0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7DE0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7DE8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_683911C (0x683911C)
================================================================================

__int64 __fastcall sub_683911C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_79D7DF0;
  v10[1] = sub_683BDE8;
  v4 = atomic_load(&qword_79D7DF0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_6848B54(&qword_79D7DF0, (__int64)&v11, (void (__fastcall *)(__int64))sub_68475DC);
  }
  v5 = dword_79D7DF8 - 1LL;
  sub_68487CC(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_6847484(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_68487F0(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_683B6F4 (0x683B6F4)
================================================================================

__int64 *sub_683B6F4()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_79D7E20);
  if ( (v0 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_79D7E20) )
  {
    sub_6836BE4(&unk_79D8A40, 1LL);
    qword_79D7E10 = (__int64)&unk_79D8A40;
    qword_79D7E18 = (__int64)&qword_79D7E10;
    sub_6862850(byte_79D7E20);
  }
  qword_79D7E28 = qword_79D7E10;
  sub_68487CC(qword_79D7E10);
  return &qword_79D7E28;
}


================================================================================
Function: sub_683B7A0 (0x683B7A0)
================================================================================

__int64 __fastcall sub_683B7A0(_QWORD *a1)
{
  unsigned __int8 v2; // w8

  v2 = atomic_load(byte_79D7E38);
  if ( (v2 & 1) == 0 && (unsigned int)sub_68626F8((__int64)byte_79D7E38) )
  {
    sub_683B6F4();
    qword_79D7E30 = (__int64)&qword_79D7E28;
    sub_6862850(byte_79D7E38);
  }
  *a1 = qword_79D7E28;
  return sub_68487CC();
}


================================================================================
Function: sub_683B82C (0x683B82C)
================================================================================

__int64 __fastcall sub_683B82C(__int64 *a1, __int64 *a2)
{
  __int64 v3; // x0

  v3 = *a2;
  *a1 = *a2;
  return sub_68487CC(v3);
}


================================================================================
Function: sub_683B844 (0x683B844)
================================================================================

__int64 __fastcall sub_683B844(_QWORD *a1)
{
  return sub_68487F0(*a1);
}


================================================================================
Function: sub_683BBD0 (0x683BBD0)
================================================================================

__int64 *__fastcall sub_683BBD0(__int64 *result, __int64 a2, __int64 a3)
{
  __int64 v4; // x21
  unsigned __int64 v5; // x8
  __int64 v6; // x8
  unsigned __int64 v7; // x9
  _QWORD v8[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v9; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v10[2]; // [xsp+20h] [xbp-10h] BYREF

  v10[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8[2] = 0LL;
  v4 = *result;
  v8[0] = a2;
  v8[1] = sub_683BDE8;
  v5 = atomic_load((unsigned __int64 *)a2);
  if ( v5 != -1LL )
  {
    v10[0] = v8;
    v9 = v10;
    result = (__int64 *)sub_6848B54(a2, &v9, sub_68475DC);
  }
  v6 = *(_QWORD *)(v4 + 16);
  v7 = *(int *)(a2 + 8) - 1LL;
  if ( v7 >= (*(_QWORD *)(v4 + 24) - v6) >> 3 || (result = *(__int64 **)(v6 + 8 * v7)) == 0LL )
    sub_253ABD8(result, a2, a3);
  return result;
}


================================================================================
Function: sub_6847484 (0x6847484)
================================================================================

char *__fastcall sub_6847484(char *result, size_t n)
{
  __int64 v2; // x8
  char *v3; // x21
  char **v4; // x19
  char *v6; // x22
  __int64 v7; // x21
  unsigned __int64 v8; // x9
  __int64 v9; // x8
  unsigned __int64 v10; // x23
  __int64 v12; // x0
  size_t v13; // x20
  char *v14; // x21
  size_t v15; // x20
  unsigned __int64 v16; // x23
  char *v17; // x1
  char *v18; // x24
  signed __int64 v19; // x2
  char *v20; // x20

  v3 = (char *)*((_QWORD *)result + 1);
  v2 = *((_QWORD *)result + 2);
  v4 = (char **)result;
  if ( n <= (v2 - (__int64)v3) >> 3 )
  {
    if ( n )
    {
      v13 = 8 * n;
      result = (char *)memset(*((void **)result + 1), 0, 8 * n);
      v3 += v13;
    }
    v4[1] = v3;
  }
  else
  {
    v6 = result + 32;
    v7 = (__int64)&v3[-*(_QWORD *)result] >> 3;
    v8 = v7 + n;
    if ( (v7 + n) >> 61 )
      sub_684DBEC();
    v9 = v2 - *(_QWORD *)result;
    if ( v9 >> 2 >= v8 )
      v8 = v9 >> 2;
    if ( (unsigned __int64)v9 >= 0x7FFFFFFFFFFFFFF8LL )
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if ( v10 )
    {
      if ( v10 <= 0x1C && result[256] == 0 )
      {
        v12 = (__int64)(result + 32);
        *((_BYTE *)v4 + 256) = 1;
      }
      else
      {
        v12 = sub_65ECAAC();
      }
    }
    else
    {
      v12 = 0LL;
    }
    v14 = (char *)(v12 + 8 * v7);
    v15 = 8 * n;
    v16 = v12 + 8 * v10;
    result = (char *)memset(v14, 0, v15);
    v17 = *v4;
    v18 = &v14[v15];
    v19 = v4[1] - *v4;
    v20 = &v14[-v19];
    if ( v19 >= 1 )
    {
      result = (char *)memcpy(&v14[-v19], v17, v19);
      v17 = *v4;
    }
    *v4 = v20;
    v4[1] = v18;
    v4[2] = (char *)v16;
    if ( v17 )
    {
      if ( v17 == v6 )
        *((_BYTE *)v4 + 256) = 0;
      else
        return (char *)sub_65ECAF4();
    }
  }
  return result;
}


================================================================================
Function: sub_68487CC (0x68487CC)
================================================================================

unsigned __int64 __fastcall sub_68487CC(__int64 a1)
{
  return sub_6867420(1uLL, (atomic_ullong *)(a1 + 8));
}


================================================================================
Function: sub_68487F0 (0x68487F0)
================================================================================

bool __fastcall sub_68487F0(__int64 a1)
{
  unsigned __int64 v2; // x20

  v2 = sub_68674B0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(a1 + 8));
  if ( !v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1);
  return v2 == 0;
}


================================================================================
Function: sub_68488BC (0x68488BC)
================================================================================

__int64 __fastcall sub_68488BC(unsigned __int64 *a1)
{
  __int64 result; // x0

  if ( !atomic_load(a1 + 2) )
    return (*(__int64 (__fastcall **)(unsigned __int64 *))(*a1 + 32))(a1);
  result = sub_68674B0(-1LL, a1 + 2);
  if ( !result )
    return (*(__int64 (__fastcall **)(unsigned __int64 *))(*a1 + 32))(a1);
  return result;
}


================================================================================
Function: sub_6848980 (0x6848980)
================================================================================

__int64 __fastcall sub_6848980(pthread_mutex_t *a1)
{
  __int64 result; // x0

  result = pthread_mutex_lock(a1);
  if ( (_DWORD)result )
    sub_684D644(result, "mutex lock failed");
  return result;
}


================================================================================
Function: sub_68489AC (0x68489AC)
================================================================================

bool __fastcall sub_68489AC(pthread_mutex_t *a1)
{
  return pthread_mutex_trylock(a1) == 0;
}


================================================================================
Function: sub_68489D4 (0x68489D4)
================================================================================

__int64 __fastcall sub_68489D4(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1);
}


================================================================================
Function: sub_68489F4 (0x68489F4)
================================================================================

__int64 __fastcall sub_68489F4(pthread_mutex_t *a1)
{
  int v2; // w0
  int v3; // w0
  int v4; // w20
  __int64 result; // x0
  int v6; // [xsp+Ch] [xbp-14h]
  int v7; // [xsp+Ch] [xbp-14h]
  pthread_mutexattr_t attr; // [xsp+10h] [xbp-10h] BYREF
  __int64 v9; // [xsp+18h] [xbp-8h]

  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = pthread_mutexattr_init(&attr);
  if ( v2 )
    sub_684D644(v2, "recursive_mutex constructor failed");
  v3 = pthread_mutexattr_settype(&attr, 1);
  if ( v3 )
  {
    v6 = v3;
    pthread_mutexattr_destroy(&attr);
    sub_684D644(v6, "recursive_mutex constructor failed");
  }
  v4 = pthread_mutex_init(a1, &attr);
  result = pthread_mutexattr_destroy(&attr);
  if ( v4 )
    sub_684D644(v4, "recursive_mutex constructor failed");
  if ( (_DWORD)result )
  {
    v7 = result;
    pthread_mutex_destroy(a1);
    sub_684D644(v7, "recursive_mutex constructor failed");
  }
  return result;
}


================================================================================
Function: sub_6848AE0 (0x6848AE0)
================================================================================

__int64 __fastcall sub_6848AE0(pthread_mutex_t *a1)
{
  __int64 result; // x0

  result = pthread_mutex_lock(a1);
  if ( (_DWORD)result )
    sub_684D644(result, "recursive_mutex lock failed");
  return result;
}


================================================================================
Function: sub_6848B0C (0x6848B0C)
================================================================================

__int64 __fastcall sub_6848B0C(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1);
}


================================================================================
Function: sub_6848B2C (0x6848B2C)
================================================================================

bool __fastcall sub_6848B2C(pthread_mutex_t *a1)
{
  return pthread_mutex_trylock(a1) == 0;
}


================================================================================
Function: sub_6848B54 (0x6848B54)
================================================================================

__int64 __fastcall sub_6848B54(unsigned __int64 *a1, __int64 a2, void (__fastcall *a3)(__int64))
{
  pthread_mutex_lock(&stru_79D8B80);
  while ( *a1 == 1 )
    pthread_cond_wait(&stru_79D8BA8, &stru_79D8B80);
  if ( *a1 )
    return pthread_mutex_unlock(&stru_79D8B80);
  *a1 = 1LL;
  pthread_mutex_unlock(&stru_79D8B80);
  a3(a2);
  pthread_mutex_lock(&stru_79D8B80);
  atomic_store(0xFFFFFFFFFFFFFFFFLL, a1);
  pthread_mutex_unlock(&stru_79D8B80);
  return pthread_cond_broadcast(&stru_79D8BA8);
}


================================================================================
Function: sub_6849378 (0x6849378)
================================================================================

void *__fastcall sub_6849378(_QWORD *a1, char *a2)
{
  char v3; // w9
  const char *v4; // x20
  size_t v5; // x21
  __int64 v6; // x0
  __int64 v7; // x22
  void *result; // x0

  v3 = *a2;
  *a1 = off_6C5EE70;
  if ( (v3 & 1) != 0 )
    v4 = (const char *)*((_QWORD *)a2 + 2);
  else
    v4 = a2 + 1;
  v5 = __strlen_chk(v4, 0xFFFFFFFFFFFFFFFFLL);
  v6 = sub_65ECAAC();
  v7 = v6 + 24;
  *(_QWORD *)v6 = v5;
  *(_QWORD *)(v6 + 8) = v5;
  *(_DWORD *)(v6 + 16) = 0;
  result = memcpy((void *)(v6 + 24), v4, v5 + 1);
  a1[1] = v7;
  return result;
}


================================================================================
Function: sub_6849410 (0x6849410)
================================================================================

void *__fastcall sub_6849410(_QWORD *a1, char *a2)
{
  size_t v4; // x21
  __int64 v5; // x0
  __int64 v6; // x22
  void *result; // x0

  *a1 = off_6C5EE70;
  v4 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
  v5 = sub_65ECAAC();
  v6 = v5 + 24;
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = v4;
  *(_DWORD *)(v5 + 16) = 0;
  result = memcpy((void *)(v5 + 24), a2, v4 + 1);
  a1[1] = v6;
  return result;
}


================================================================================
Function: sub_684949C (0x684949C)
================================================================================

__int64 __fastcall sub_684949C(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x9

  v2 = *(_QWORD *)(a2 + 8);
  *a1 = off_6C5EE70;
  a1[1] = v2;
  return sub_68673F0(1u, (atomic_uint *)(v2 - 8));
}


================================================================================
Function: sub_68494D4 (0x68494D4)
================================================================================

void *__fastcall sub_68494D4(_QWORD *a1, char *a2)
{
  char v3; // w9
  const char *v4; // x20
  size_t v5; // x21
  __int64 v6; // x0
  __int64 v7; // x22
  void *result; // x0

  v3 = *a2;
  *a1 = off_6C5EE98;
  if ( (v3 & 1) != 0 )
    v4 = (const char *)*((_QWORD *)a2 + 2);
  else
    v4 = a2 + 1;
  v5 = __strlen_chk(v4, 0xFFFFFFFFFFFFFFFFLL);
  v6 = sub_65ECAAC();
  v7 = v6 + 24;
  *(_QWORD *)v6 = v5;
  *(_QWORD *)(v6 + 8) = v5;
  *(_DWORD *)(v6 + 16) = 0;
  result = memcpy((void *)(v6 + 24), v4, v5 + 1);
  a1[1] = v7;
  return result;
}


================================================================================
Function: sub_684956C (0x684956C)
================================================================================

void *__fastcall sub_684956C(_QWORD *a1, char *a2)
{
  size_t v4; // x21
  __int64 v5; // x0
  __int64 v6; // x22
  void *result; // x0

  *a1 = off_6C5EE98;
  v4 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
  v5 = sub_65ECAAC();
  v6 = v5 + 24;
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = v4;
  *(_DWORD *)(v5 + 16) = 0;
  result = memcpy((void *)(v5 + 24), a2, v4 + 1);
  a1[1] = v6;
  return result;
}


================================================================================
Function: sub_68495F8 (0x68495F8)
================================================================================

__int64 __fastcall sub_68495F8(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x9

  v2 = *(_QWORD *)(a2 + 8);
  *a1 = off_6C5EE98;
  a1[1] = v2;
  return sub_68673F0(1u, (atomic_uint *)(v2 - 8));
}


================================================================================
Function: sub_6849630 (0x6849630)
================================================================================

void __noreturn sub_6849630()
{
  sub_24FD568("basic_string");
}


================================================================================
Function: sub_6849648 (0x6849648)
================================================================================

void __noreturn sub_6849648()
{
  sub_2532638("basic_string");
}


================================================================================
Function: sub_6849660 (0x6849660)
================================================================================

_BYTE *__fastcall sub_6849660(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        size_t a5,
        __int64 a6,
        size_t a7,
        const void *a8)
{
  char *v15; // x24
  unsigned __int64 v16; // x8
  unsigned __int64 v17; // x27
  _BYTE *result; // x0
  _BYTE *v19; // x28
  size_t v20; // x25
  size_t v21; // x9

  if ( -18LL - a2 < a3 )
    sub_6849630();
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v15 = *(char **)(a1 + 16);
  else
    v15 = (char *)(a1 + 1);
  if ( a2 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v17 = -17LL;
  }
  else
  {
    v16 = a3 + a2;
    if ( a3 + a2 < 2 * a2 )
      v16 = 2 * a2;
    if ( v16 >= 0x17 )
      v17 = (v16 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v17 = 23LL;
  }
  result = (_BYTE *)sub_65ECAAC();
  v19 = result;
  if ( a5 )
    result = memcpy(result, v15, a5);
  if ( a7 )
    result = memcpy(&v19[a5], a8, a7);
  v20 = a4 - (a5 + a6);
  if ( v20 )
    result = memcpy(&v19[a5 + a7], &v15[a5 + a6], v20);
  if ( a2 != 22 )
    result = (_BYTE *)sub_65ECAF4();
  v21 = a7 + a5 + v20;
  *(_QWORD *)a1 = v17 | 1;
  *(_QWORD *)(a1 + 8) = v21;
  *(_QWORD *)(a1 + 16) = v19;
  v19[v21] = 0;
  return result;
}


================================================================================
Function: sub_68497A0 (0x68497A0)
================================================================================

unsigned __int64 *__fastcall sub_68497A0(unsigned __int64 *result, __int128 *a2)
{
  unsigned __int64 *v2; // x19
  __int128 v3; // q0
  const void *v4; // x20
  unsigned __int64 v5; // x22
  void *v6; // x19
  __int64 v7; // x0

  v2 = result;
  if ( (*(_BYTE *)a2 & 1) != 0 )
  {
    v5 = *((_QWORD *)a2 + 1);
    v4 = (const void *)*((_QWORD *)a2 + 2);
    if ( v5 > 0x16 )
    {
      if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
        sub_6849630(result);
      v7 = sub_65ECAAC();
      v2[1] = v5;
      v2[2] = v7;
      *v2 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      v6 = (void *)v7;
    }
    else
    {
      *(_BYTE *)result = 2 * v5;
      v6 = (char *)result + 1;
    }
    return (unsigned __int64 *)memcpy(v6, v4, v5 + 1);
  }
  else
  {
    v3 = *a2;
    result[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)result = v3;
  }
  return result;
}


================================================================================
Function: sub_68499C0 (0x68499C0)
================================================================================

char *__fastcall sub_68499C0(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        size_t a5,
        __int64 a6,
        __int64 a7)
{
  char *v13; // x23
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x26
  char *result; // x0
  char *v17; // x27

  if ( -17LL - a2 < a3 )
    sub_6849630();
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v13 = *(char **)(a1 + 16);
  else
    v13 = (char *)(a1 + 1);
  if ( a2 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v15 = -17LL;
  }
  else
  {
    v14 = a3 + a2;
    if ( a3 + a2 < 2 * a2 )
      v14 = 2 * a2;
    if ( v14 >= 0x17 )
      v15 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v15 = 23LL;
  }
  result = (char *)sub_65ECAAC();
  v17 = result;
  if ( a5 )
    result = (char *)memcpy(result, v13, a5);
  if ( a4 != a5 + a6 )
    result = (char *)memcpy(&v17[a5 + a7], &v13[a5 + a6], a4 - (a5 + a6));
  if ( a2 != 22 )
    result = (char *)sub_65ECAF4();
  *(_QWORD *)(a1 + 16) = v17;
  *(_QWORD *)a1 = v15 | 1;
  return result;
}


================================================================================
Function: sub_6849AD8 (0x6849AD8)
================================================================================

__int64 __fastcall sub_6849AD8(__int64 result, char a2)
{
  _BYTE *v2; // x8

  if ( (*(_BYTE *)result & 1) != 0 )
  {
    v2 = *(_BYTE **)(result + 16);
    *(_QWORD *)(result + 8) = 1LL;
  }
  else
  {
    *(_BYTE *)result = 2;
    v2 = (_BYTE *)(result + 1);
  }
  *v2 = a2;
  v2[1] = 0;
  return result;
}


================================================================================
Function: sub_6849CE0 (0x6849CE0)
================================================================================

size_t *__fastcall sub_6849CE0(size_t *result, unsigned __int8 *a2, unsigned __int64 a3, size_t a4)
{
  unsigned __int64 v4; // x8
  size_t *v5; // x19
  unsigned __int64 v6; // x9
  bool v7; // cf
  size_t v8; // x9
  unsigned __int8 *v9; // x23
  size_t v10; // x21
  void *v12; // x19
  __int64 v13; // x0

  v4 = *a2;
  v5 = result;
  v6 = *((_QWORD *)a2 + 1);
  if ( (v4 & 1) == 0 )
    v6 = v4 >> 1;
  v7 = v6 >= a3;
  v8 = v6 - a3;
  if ( !v7 )
    sub_6849648(result);
  if ( (v4 & 1) != 0 )
    v9 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v9 = a2 + 1;
  if ( v8 >= a4 )
    v10 = a4;
  else
    v10 = v8;
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630(result);
  if ( v10 >= 0x17 )
  {
    v13 = sub_65ECAAC();
    v5[1] = v10;
    v5[2] = v13;
    *v5 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    v12 = (void *)v13;
  }
  else
  {
    *(_BYTE *)result = 2 * v10;
    v12 = (char *)result + 1;
    if ( !v10 )
      goto LABEL_17;
  }
  result = (size_t *)memcpy(v12, &v9[a3], v10);
LABEL_17:
  *((_BYTE *)v12 + v10) = 0;
  return result;
}


================================================================================
Function: sub_6849DAC (0x6849DAC)
================================================================================

__int64 __fastcall sub_6849DAC(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x8
  unsigned __int8 *v5; // x19
  bool v6; // zf
  bool v7; // cc
  size_t v8; // x8
  _BYTE *v9; // x0

  v3 = *a1;
  v6 = (v3 & 1) == 0;
  v4 = v3 >> 1;
  if ( v6 )
  {
    v5 = a1 + 1;
  }
  else
  {
    v4 = *((_QWORD *)a1 + 1);
    v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  }
  v6 = v4 == a3;
  v7 = v4 > a3;
  v8 = v4 - a3;
  if ( !v7 )
    return -1LL;
  if ( v6 )
    v9 = 0LL;
  else
    v9 = memchr(&v5[a3], a2, v8);
  if ( v9 )
    return v9 - v5;
  else
    return -1LL;
}


================================================================================
Function: sub_6849EB4 (0x6849EB4)
================================================================================

unsigned __int8 *__fastcall sub_6849EB4(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v5; // x20
  unsigned __int64 v6; // x9
  unsigned __int8 *v7; // x21
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x9

  v3 = *a1;
  if ( (v3 & 1) != 0 )
    v5 = *((_QWORD *)a1 + 1);
  else
    v5 = v3 >> 1;
  v6 = v5 - a2;
  if ( v5 < a2 )
    sub_6849648();
  if ( a3 )
  {
    if ( a3 == -1LL )
    {
      if ( (v3 & 1) != 0 )
      {
        *(_BYTE *)(*((_QWORD *)a1 + 2) + a2) = 0;
        *((_QWORD *)a1 + 1) = a2;
      }
      else
      {
        a1[a2 + 1] = 0;
        *a1 = 2 * a2;
      }
    }
    else
    {
      if ( (v3 & 1) != 0 )
        v7 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      else
        v7 = a1 + 1;
      if ( v6 >= a3 )
        v8 = a3;
      else
        v8 = v5 - a2;
      if ( v6 != v8 )
      {
        memmove(&v7[a2], &v7[a2 + v8], v6 - v8);
        LOBYTE(v3) = *a1;
      }
      v9 = v5 - v8;
      if ( (v3 & 1) != 0 )
        *((_QWORD *)a1 + 1) = v9;
      else
        *a1 = 2 * v9;
      v7[v9] = 0;
    }
  }
  return a1;
}


================================================================================
Function: sub_684A118 (0x684A118)
================================================================================

__int64 __fastcall sub_684A118(unsigned __int8 *a1, unsigned __int64 a2, size_t a3, void *s2, size_t a5)
{
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x9
  bool v7; // cf
  size_t v8; // x9
  size_t v10; // x20
  size_t v11; // x2
  unsigned __int8 *v12; // x8
  __int64 result; // x0

  v5 = *a1;
  v6 = *((_QWORD *)a1 + 1);
  if ( (v5 & 1) == 0 )
    v6 = v5 >> 1;
  if ( a5 == -1LL || (v7 = v6 >= a2, v8 = v6 - a2, !v7) )
    sub_6849648();
  if ( v8 >= a3 )
    v10 = a3;
  else
    v10 = v8;
  if ( v10 <= a5 )
    v11 = v10;
  else
    v11 = a5;
  if ( !v11
    || ((v5 & 1) == 0 ? (v12 = a1 + 1) : (v12 = (unsigned __int8 *)*((_QWORD *)a1 + 2)),
        result = memcmp(&v12[a2], s2, v11),
        !(_DWORD)result) )
  {
    if ( v10 < a5 )
      return 0xFFFFFFFFLL;
    else
      return v10 > a5;
  }
  return result;
}


================================================================================
Function: sub_684A29C (0x684A29C)
================================================================================

_QWORD *__fastcall sub_684A29C(_QWORD *a1, char *s)
{
  size_t v4; // x0
  unsigned int v5; // w8
  size_t v6; // x20
  unsigned __int64 v7; // x1
  __int64 v8; // x3
  void *v9; // x22

  v4 = strlen(s);
  v5 = *(unsigned __int8 *)a1;
  v6 = v4;
  if ( (v5 & 1) != 0 )
    v7 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v7 = 22LL;
  if ( v4 <= v7 )
  {
    if ( (v5 & 1) != 0 )
      v9 = (void *)a1[2];
    else
      v9 = (char *)a1 + 1;
    if ( v4 )
      memmove(v9, s, v4);
    *((_BYTE *)v9 + v6) = 0;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v6;
    else
      *(_BYTE *)a1 = 2 * v6;
  }
  else
  {
    if ( (v5 & 1) != 0 )
      v8 = a1[1];
    else
      v8 = v5 >> 1;
    sub_6849660((__int64)a1, v7, v4 - v7, v8, 0LL, v8, v4, s);
  }
  return a1;
}


================================================================================
Function: sub_684A438 (0x684A438)
================================================================================

unsigned __int8 *__fastcall sub_684A438(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v3; // w8
  unsigned int v4; // w9
  __int128 v5; // q0
  bool v6; // zf
  size_t v7; // x9
  __int64 v8; // x11
  size_t v9; // x20
  const void *v10; // x7
  unsigned __int64 v11; // x8
  void *v12; // x21
  __int64 v13; // x2
  __int64 v14; // x3
  __int64 v15; // x1

  if ( a1 == a2 )
    return a1;
  v3 = *a1;
  v4 = *a2;
  if ( (v3 & 1) == 0 )
  {
    if ( (v4 & 1) == 0 )
    {
      v5 = *(_OWORD *)a2;
      *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
      *(_OWORD *)a1 = v5;
      return a1;
    }
    v9 = *((_QWORD *)a2 + 1);
    v10 = (const void *)*((_QWORD *)a2 + 2);
    v13 = v9 - 22;
    if ( v9 <= 0x16 )
    {
      *a1 = 2 * v9;
      if ( v9 )
        memcpy(a1 + 1, v10, v9);
      a1[v9 + 1] = 0;
      return a1;
    }
    v14 = v3 >> 1;
    v15 = 22LL;
LABEL_21:
    sub_6849660(a1, v15, v13, v14, 0LL, v14, v9, v10);
    return a1;
  }
  v6 = (v4 & 1) == 0;
  v7 = v4 >> 1;
  v8 = *(_QWORD *)a1;
  if ( v6 )
    v9 = v7;
  else
    v9 = *((_QWORD *)a2 + 1);
  if ( v6 )
    v10 = a2 + 1;
  else
    v10 = (const void *)*((_QWORD *)a2 + 2);
  v11 = v8 & 0xFFFFFFFFFFFFFFFELL;
  if ( (v8 & 0xFFFFFFFFFFFFFFFELL) <= v9 )
  {
    v14 = *((_QWORD *)a1 + 1);
    v15 = v11 - 1;
    v13 = v9 - v11 + 1;
    goto LABEL_21;
  }
  v12 = (void *)*((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 1) = v9;
  if ( v9 )
    memcpy(v12, v10, v9);
  *((_BYTE *)v12 + v9) = 0;
  return a1;
}


================================================================================
Function: sub_684A544 (0x684A544)
================================================================================

_QWORD *__fastcall sub_684A544(_QWORD *a1, char *s)
{
  size_t v4; // x0
  size_t v5; // x21
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x1
  unsigned __int64 v8; // x22
  char *v9; // x23
  size_t v10; // x8

  v4 = strlen(s);
  v5 = v4;
  v6 = *(unsigned __int8 *)a1;
  if ( (v6 & 1) != 0 )
    v7 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v7 = 22LL;
  if ( (v6 & 1) != 0 )
    v8 = a1[1];
  else
    v8 = v6 >> 1;
  if ( v7 - v8 >= v4 )
  {
    if ( v4 )
    {
      if ( (v6 & 1) != 0 )
        v9 = (char *)a1[2];
      else
        v9 = (char *)a1 + 1;
      memcpy(&v9[v8], s, v4);
      v10 = v8 + v5;
      if ( (*(_BYTE *)a1 & 1) != 0 )
        a1[1] = v10;
      else
        *(_BYTE *)a1 = 2 * v10;
      v9[v10] = 0;
    }
  }
  else
  {
    sub_6849660(a1, v7, v8 + v4 - v7, v8, v8, 0LL, v4, s);
  }
  return a1;
}


================================================================================
Function: sub_684A624 (0x684A624)
================================================================================

char *__fastcall sub_684A624(_QWORD *a1, __int64 a2, char a3)
{
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  bool v7; // zf
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x22
  char *v10; // x23
  __int64 v11; // x21
  unsigned __int64 v12; // x10
  char *v13; // x8
  char v14; // w9

  v5 = *(unsigned __int8 *)a1;
  v6 = 22LL;
  v7 = (v5 & 1) == 0;
  v8 = v5 >> 1;
  if ( v7 )
    v9 = v8;
  else
    v9 = a1[1];
  if ( v7 )
    v10 = (char *)a1 + 1;
  else
    v10 = (char *)a1[2];
  v11 = a2 - (_QWORD)v10;
  if ( !v7 )
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  if ( v6 == v9 )
  {
    sub_68499C0(a1, v9, 1LL, v9, v11, 0LL, 1LL);
    v10 = (char *)a1[2];
  }
  else if ( v9 != v11 )
  {
    memmove((void *)(a2 + 1), (const void *)a2, v9 - v11);
  }
  v12 = v9 + 1;
  v10[v11] = a3;
  v13 = (char *)a1 + 1;
  v10[v9 + 1] = 0;
  v14 = *(_BYTE *)a1;
  if ( (*(_BYTE *)a1 & 1) != 0 )
    a1[1] = v12;
  else
    *(_BYTE *)a1 = 2 * v12;
  if ( (v14 & 1) != 0 )
    v13 = (char *)a1[2];
  return &v13[v11];
}


================================================================================
Function: sub_684A708 (0x684A708)
================================================================================

unsigned __int8 *__fastcall sub_684A708(unsigned __int8 *result, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x9

  v3 = *result;
  v4 = *((_QWORD *)result + 1);
  if ( (v3 & 1) == 0 )
    v4 = v3 >> 1;
  if ( v4 < a2 )
    return (unsigned __int8 *)sub_65FF79C((int)result, a2 - v4, a3);
  if ( (v3 & 1) != 0 )
  {
    *(_BYTE *)(*((_QWORD *)result + 2) + a2) = 0;
    *((_QWORD *)result + 1) = a2;
  }
  else
  {
    result[a2 + 1] = 0;
    *result = 2 * a2;
  }
  return result;
}


================================================================================
Function: sub_684B0A8 (0x684B0A8)
================================================================================

size_t __usercall sub_684B0A8@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, unsigned __int64 *a3@<X8>)
{
  size_t result; // x0
  unsigned __int64 v7; // x26
  size_t v8; // x20
  unsigned __int64 v9; // x8
  size_t v10; // x23
  void *v11; // x24
  unsigned __int64 v12; // x8
  const void *v13; // x7
  unsigned __int64 v14; // x1
  size_t v15; // x21
  unsigned __int64 v16; // x25
  char *v17; // x22
  size_t v18; // x8

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  result = strlen(a1);
  v7 = *a2;
  if ( (v7 & 1) != 0 )
    v8 = *((_QWORD *)a2 + 1);
  else
    v8 = v7 >> 1;
  v9 = v8 + result;
  if ( v8 + result >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v10 = result;
  if ( v9 <= 0x16 )
  {
    *(_BYTE *)a3 = 2 * result;
    v11 = (char *)a3 + 1;
    if ( !result )
      goto LABEL_8;
    goto LABEL_7;
  }
  v16 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
  result = sub_65ECAAC();
  v11 = (void *)result;
  a3[1] = v10;
  a3[2] = result;
  *a3 = v16 | 1;
  if ( v10 )
LABEL_7:
    result = (size_t)memcpy(v11, a1, v10);
LABEL_8:
  *((_BYTE *)v11 + v10) = 0;
  v12 = *(unsigned __int8 *)a3;
  if ( (v7 & 1) != 0 )
    v13 = (const void *)*((_QWORD *)a2 + 2);
  else
    v13 = a2 + 1;
  if ( (v12 & 1) != 0 )
    v14 = (*a3 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v14 = 22LL;
  if ( (v12 & 1) != 0 )
    v15 = a3[1];
  else
    v15 = v12 >> 1;
  if ( v14 - v15 < v8 )
    return (size_t)sub_6849660((__int64)a3, v14, v15 + v8 - v14, v15, v15, 0LL, v8, v13);
  if ( v8 )
  {
    if ( (v12 & 1) != 0 )
      v17 = (char *)a3[2];
    else
      v17 = (char *)a3 + 1;
    result = (size_t)memcpy(&v17[v15], v13, v8);
    v18 = v15 + v8;
    if ( (*(_BYTE *)a3 & 1) != 0 )
      a3[1] = v18;
    else
      *(_BYTE *)a3 = 2 * v18;
    v17[v18] = 0;
  }
  return result;
}


================================================================================
Function: sub_684BDC8 (0x684BDC8)
================================================================================

__int64 __usercall sub_684BDC8@<X0>(__int64 result@<X0>, unsigned __int64 *a2@<X8>)
{
  char *p_src; // x1
  char *v4; // x20
  unsigned int v5; // w9
  unsigned __int64 v6; // x21
  _BYTE *v7; // x19
  char src; // [xsp+Ch] [xbp-14h] BYREF
  _BYTE v9[3]; // [xsp+Dh] [xbp-13h] BYREF
  _BYTE v10[9]; // [xsp+17h] [xbp-9h] BYREF

  p_src = &src;
  v4 = v10;
  *(_QWORD *)&v10[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (result & 0x80000000) != 0 )
  {
    p_src = v9;
    result = (unsigned int)-(int)result;
    src = 45;
  }
  if ( v10 - p_src > 9
    || (v5 = (1233 * (32 - __clz(result | 1))) >> 12,
        v10 - p_src >= (unsigned int)(((__PAIR64__(v5, result) - dword_174FA90[v5]) >> 32) + 1)) )
  {
    result = sub_684C8FC(result);
    v4 = (char *)result;
  }
  v6 = v4 - &src;
  if ( (unsigned __int64)(v4 - &src) >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  if ( v6 > 0x16 )
  {
    result = sub_65ECAAC();
    a2[1] = v6;
    a2[2] = result;
    *a2 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    v7 = (_BYTE *)result;
  }
  else
  {
    *(_BYTE *)a2 = 2 * v6;
    v7 = (char *)a2 + 1;
  }
  if ( &src != v4 )
  {
    result = (__int64)memcpy(v7, &src, v4 - &src);
    v7 += v6;
  }
  *v7 = 0;
  return result;
}


================================================================================
Function: sub_684C254 (0x684C254)
================================================================================

__int64 __usercall sub_684C254@<X0>(__int64 a1@<X0>, size_t *a2@<X8>)
{
  __int64 result; // x0
  size_t v4; // x20
  _QWORD *v5; // x21
  _BYTE *v6; // x19
  _QWORD v7[4]; // [xsp+0h] [xbp-20h] BYREF

  v7[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = sub_684CB8C(a1, v7);
  v4 = result - (_QWORD)v7;
  if ( (unsigned __int64)(result - (_QWORD)v7) >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v5 = (_QWORD *)result;
  if ( v4 > 0x16 )
  {
    result = sub_65ECAAC();
    a2[1] = v4;
    a2[2] = result;
    *a2 = (v4 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    v6 = (_BYTE *)result;
  }
  else
  {
    *(_BYTE *)a2 = 2 * v4;
    v6 = (char *)a2 + 1;
  }
  if ( v7 != v5 )
  {
    result = (__int64)memcpy(v6, v7, v4);
    v6 += v4;
  }
  *v6 = 0;
  return result;
}


================================================================================
Function: sub_684C8FC (0x684C8FC)
================================================================================

__int64 __fastcall sub_684C8FC(unsigned int a1, _WORD *a2)
{
  __int64 result; // x0
  unsigned int v3; // w10
  unsigned int v4; // w9
  char v5; // w11
  __int64 v6; // x10
  __int16 v7; // w11
  _WORD *v8; // x10
  unsigned int v9; // w11
  unsigned int v10; // w9
  __int16 v11; // w12
  __int16 v12; // w13
  __int16 v13; // w8

  if ( a1 < 0x5F5E100 )
    return sub_684C9D0(a2, a1);
  v3 = a1 / 0x5F5E100;
  v4 = a1 % 0x5F5E100;
  if ( a1 > 0x3B9AC9FF )
  {
    v7 = word_174FB58[v3];
    v6 = 2LL;
    *a2 = v7;
  }
  else
  {
    v5 = v3 + 48;
    v6 = 1LL;
    *(_BYTE *)a2 = v5;
  }
  v8 = (_WORD *)((char *)a2 + v6);
  result = (__int64)(v8 + 4);
  v9 = v4 / 0x2710;
  v10 = v4 % 0x2710;
  v11 = word_174FB58[(unsigned __int16)v9 / 0x64u];
  v12 = word_174FB58[(unsigned __int16)v10 / 0x64u];
  LOWORD(v9) = word_174FB58[(unsigned __int16)v9 % 0x64u];
  *v8 = v11;
  v13 = word_174FB58[(unsigned __int16)v10 % 0x64u];
  v8[2] = v12;
  v8[1] = v9;
  v8[3] = v13;
  return result;
}


================================================================================
Function: sub_684C9D0 (0x684C9D0)
================================================================================

_WORD *__fastcall sub_684C9D0(_WORD *a1, unsigned int a2)
{
  _WORD *result; // x0
  unsigned int v3; // w9
  __int64 v4; // x10
  unsigned int v5; // w8
  __int16 v6; // w9
  __int16 v7; // w11
  _WORD *v8; // x10
  unsigned __int16 v9; // w9
  __int16 v10; // w8

  if ( a2 >> 4 > 0x270 )
  {
    v3 = a2 / 0x2710;
    if ( a2 >= 0xF4240 )
    {
      if ( a2 > 0x98967F )
      {
        v4 = 4LL;
        v7 = word_174FB58[v3 % 0x64];
        *a1 = word_174FB58[a2 / 0xF4240];
        a1[1] = v7;
      }
      else
      {
        v4 = 3LL;
        *(_BYTE *)a1 = (unsigned __int16)v3 / 0x64u + 48;
        *(_WORD *)((char *)a1 + 1) = word_174FB58[(unsigned __int16)v3 % 0x64u];
      }
    }
    else if ( a2 >> 5 > 0xC34 )
    {
      v4 = 2LL;
      *a1 = word_174FB58[v3];
    }
    else
    {
      v4 = 1LL;
      *(_BYTE *)a1 = v3 + 48;
    }
    v8 = (_WORD *)((char *)a1 + v4);
    v9 = a2 % 0x2710;
    result = v8 + 2;
    v10 = word_174FB58[v9 % 0x64u];
    *v8 = word_174FB58[v9 / 0x64u];
    v8[1] = v10;
  }
  else if ( a2 > 0x63 )
  {
    v5 = (unsigned __int16)a2 / 0x64u;
    v6 = word_174FB58[(unsigned __int16)a2 % 0x64u];
    if ( a2 > 0x3E7 )
    {
      *a1 = word_174FB58[v5];
      a1[1] = v6;
      return a1 + 2;
    }
    else
    {
      *(_BYTE *)a1 = v5 + 48;
      *(_WORD *)((char *)a1 + 1) = v6;
      return (_WORD *)((char *)a1 + 3);
    }
  }
  else if ( a2 > 9 )
  {
    *a1 = word_174FB58[a2];
    return a1 + 1;
  }
  else
  {
    *(_BYTE *)a1 = a2 + 48;
    return (_WORD *)((char *)a1 + 1);
  }
  return result;
}


================================================================================
Function: sub_684CB8C (0x684CB8C)
================================================================================

_WORD *__fastcall sub_684CB8C(unsigned __int64 a1, _WORD *a2)
{
  _WORD *result; // x0
  unsigned __int64 v3; // x19
  _WORD *v4; // x8
  __int16 v5; // w12
  __int16 v6; // w9
  __int16 v7; // w10
  unsigned __int64 v8; // x11
  unsigned __int64 v9; // x9
  char v10; // w12
  __int64 v11; // x11
  unsigned int v12; // w12
  __int16 v13; // w13
  __int16 v14; // w12
  __int16 v15; // w13
  unsigned __int64 v16; // x12
  __int64 v17; // x14
  unsigned int v18; // w10
  _WORD *v19; // x9
  unsigned __int64 v20; // x11
  unsigned int v21; // w13
  __int16 v22; // w15
  __int16 v23; // w16
  __int16 v24; // w17
  __int16 v25; // w8

  if ( a1 < 0x5F5E100 )
    return sub_684C9D0(a2, a1);
  if ( a1 >= 0x2386F26FC10000LL )
  {
    v8 = a1 / 0x2386F26FC10000LL;
    v9 = a1 % 0x2386F26FC10000LL;
    if ( (unsigned int)(a1 / 0x2386F26FC10000LL) > 0x63 )
    {
      v12 = (unsigned __int16)v8 / 0x64u;
      if ( (unsigned int)v8 > 0x3E7 )
      {
        *a2 = word_174FB58[v12];
        v15 = word_174FB58[(unsigned __int16)v8 % 0x64u];
        v11 = 4LL;
        a2[1] = v15;
      }
      else
      {
        *(_BYTE *)a2 = v12 + 48;
        v13 = word_174FB58[(unsigned __int16)v8 % 0x64u];
        v11 = 3LL;
        *(_WORD *)((char *)a2 + 1) = v13;
      }
    }
    else if ( (unsigned int)v8 > 9 )
    {
      v14 = word_174FB58[v8];
      v11 = 2LL;
      *a2 = v14;
    }
    else
    {
      v10 = v8 + 48;
      v11 = 1LL;
      *(_BYTE *)a2 = v10;
    }
    v16 = v9 / 0x5F5E100;
    v17 = (unsigned int)(v9 / 0x5F5E100);
    v18 = v9 % 0x5F5E100;
    v19 = (_WORD *)((char *)a2 + v11);
    v20 = (unsigned __int64)(3518437209LL * v17) >> 45;
    v21 = v18 / 0x2710;
    LOWORD(v16) = v16 - 10000 * v20;
    v18 %= 0x2710u;
    v22 = word_174FB58[(unsigned __int16)v20 / 0x64u];
    v23 = word_174FB58[(unsigned __int16)v21 / 0x64u];
    v24 = word_174FB58[(unsigned __int16)v16 / 0x64u];
    result = v19 + 8;
    LOWORD(v20) = word_174FB58[(unsigned __int16)v20 % 0x64u];
    LOWORD(v16) = word_174FB58[(unsigned __int16)v16 % 0x64u];
    *v19 = v22;
    LOWORD(v21) = word_174FB58[(unsigned __int16)v21 % 0x64u];
    v19[4] = v23;
    LOWORD(v17) = word_174FB58[(unsigned __int16)v18 / 0x64u];
    v19[2] = v24;
    v25 = word_174FB58[(unsigned __int16)v18 % 0x64u];
    v19[1] = v20;
    v19[3] = v16;
    v19[5] = v21;
    v19[6] = v17;
    v19[7] = v25;
  }
  else
  {
    v3 = a1 % 0x5F5E100;
    v4 = sub_684C9D0(a2, a1 / 0x5F5E100);
    v5 = word_174FB58[(unsigned int)v3 % 0x2710 / 0x64];
    v6 = word_174FB58[(unsigned __int16)((unsigned int)v3 / 0x2710) % 0x64u];
    *v4 = word_174FB58[(unsigned __int16)((unsigned int)v3 / 0x2710) / 0x64u];
    v7 = word_174FB58[(unsigned int)v3 % 0x2710 % 0x64];
    v4[2] = v5;
    v4[1] = v6;
    result = v4 + 4;
    v4[3] = v7;
  }
  return result;
}


================================================================================
Function: sub_684CDE0 (0x684CDE0)
================================================================================

_QWORD *__fastcall sub_684CDE0(_QWORD *result)
{
  *result = off_6C5C7F0;
  return result;
}


================================================================================
Function: sub_684D290 (0x684D290)
================================================================================

long double __usercall sub_684D290@<Q0>(long double *__return_ptr a1@<X8>, __int64 a2@<X0>, unsigned __int8 *a3@<X1>)
{
  unsigned __int64 v5; // x8
  unsigned __int64 v7; // x8
  char *v8; // x1
  size_t v9; // x2
  long double result; // q0
  __int64 v11; // x8
  _QWORD v12[4]; // [xsp+0h] [xbp-20h] BYREF

  v12[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *(_DWORD *)a2 )
  {
    v5 = *a3;
    if ( (v5 & 1) != 0 )
      v7 = *((_QWORD *)a3 + 1);
    else
      v7 = v5 >> 1;
    if ( v7 )
      sub_684A544((int)a3, ": ");
    (*(void (__fastcall **)(_QWORD *__return_ptr))(**(_QWORD **)(a2 + 8) + 48LL))(v12);
    if ( (v12[0] & 1) != 0 )
      v8 = (char *)v12[2];
    else
      v8 = (char *)v12 + 1;
    if ( (v12[0] & 1) != 0 )
      v9 = v12[1];
    else
      v9 = (unsigned __int64)LOBYTE(v12[0]) >> 1;
    sub_65FFB9C((int)a3, v8, v9);
    if ( (v12[0] & 1) != 0 )
      sub_65ECAF4();
  }
  result = *(long double *)a3;
  *(_QWORD *)a3 = 0LL;
  v11 = *((_QWORD *)a3 + 2);
  *((_QWORD *)a3 + 1) = 0LL;
  *((_QWORD *)a3 + 2) = 0LL;
  *a1 = result;
  *((_QWORD *)a1 + 2) = v11;
  return result;
}


================================================================================
Function: sub_684D49C (0x684D49C)
================================================================================

long double __fastcall sub_684D49C(__int64 a1, __int64 a2, __int64 a3, char *s)
{
  size_t v6; // x0
  size_t v7; // x21
  char *v8; // x22
  unsigned __int64 v9; // x23
  long double result; // q0
  _QWORD v11[3]; // [xsp+8h] [xbp-48h] BYREF
  __int64 v12[2]; // [xsp+20h] [xbp-30h] BYREF
  long double v13; // [xsp+38h] [xbp-18h] BYREF
  __int64 v14; // [xsp+48h] [xbp-8h]

  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_QWORD *)&v13 = a2;
  *((_QWORD *)&v13 + 1) = a3;
  v6 = strlen(s);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_6849630();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v9 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)sub_65ECAAC();
    v11[1] = v7;
    v11[2] = v8;
    v11[0] = v9 | 1;
    goto LABEL_6;
  }
  v8 = (char *)v11 + 1;
  LOBYTE(v11[0]) = 2 * v6;
  if ( v6 )
LABEL_6:
    memcpy(v8, s, v7);
  v8[v7] = 0;
  sub_684D290(v12, (int)&v13, (int)v11);
  sub_68494D4(a1, v12);
  if ( (v12[0] & 1) != 0 )
    sub_65ECAF4();
  if ( (v11[0] & 1) != 0 )
    sub_65ECAF4();
  result = v13;
  *(long double *)(a1 + 16) = v13;
  *(_QWORD *)a1 = off_6C5C838;
  return result;
}


================================================================================
Function: sub_684D644 (0x684D644)
================================================================================

void __fastcall __noreturn sub_684D644(int a1, char *a2)
{
  __int64 v4; // x19
  unsigned __int8 v5; // w8

  v4 = sub_6861FD0(32LL);
  v5 = atomic_load(byte_79D8BF0);
  if ( (v5 & 1) == 0 )
  {
    if ( (unsigned int)sub_68626F8((__int64)byte_79D8BF0) )
    {
      qword_79D8BE8 = (__int64)off_6C5C900;
      sub_6862850(byte_79D8BF0);
    }
  }
  sub_684D49C(v4, a1, (int)&qword_79D8BE8, a2);
  sub_6862048(v4, (__int64)&`typeinfo for'std::system_error, (__int64)sub_684D610);
}


================================================================================
Function: sub_684D7B0 (0x684D7B0)
================================================================================

_QWORD *__fastcall sub_684D7B0(_QWORD *result)
{
  if ( *result )
    sub_68629B8();
  return result;
}


================================================================================
Function: sub_684DAE4 (0x684DAE4)
================================================================================

long double __fastcall sub_684DAE4(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  v2 = (_OWORD *)sub_65ECAAC();
  *(_OWORD *)&result = 0uLL;
  *a1 = v2;
  *v2 = 0u;
  v2[1] = 0u;
  v2[2] = 0u;
  return result;
}


================================================================================
Function: sub_684DBEC (0x684DBEC)
================================================================================

void __noreturn sub_684DBEC()
{
  sub_24FD568((__int64)"vector");
}


================================================================================
Function: sub_684DDCC (0x684DDCC)
================================================================================

void __noreturn sub_684DDCC(char *format, ...)
{
  gcc_va_list va2; // [xsp+C0h] [xbp-90h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-68h] BYREF
  char *ptr; // [xsp+108h] [xbp-48h] BYREF
  gcc_va_list arg; // [xsp+110h] [xbp-40h] BYREF
  gcc_va_list va1; // [xsp+130h] [xbp-20h] BYREF

  va_start(va, format);
  va_start(va1, format);
  va_copy(arg, va1);
  vfprintf((FILE *)((char *)&_sF + 304), format, arg);
  fputc(10, (FILE *)((char *)&_sF + 304));
  va_copy(va2, va);
  vasprintf(&ptr, format, va2);
  android_set_abort_message(ptr);
  openlog("libc++abi", 0, 0);
  syslog(2, "%s", ptr);
  closelog();
  abort();
}


================================================================================
Function: sub_6861FAC (0x6861FAC)
================================================================================

bool __fastcall sub_6861FAC(_QWORD *a1)
{
  return *a1 >> 8 == 0x434C4E47432B2BLL;
}


================================================================================
Function: sub_6861FD0 (0x6861FD0)
================================================================================

__int64 __fastcall sub_6861FD0(__int64 a1)
{
  size_t v1; // x19
  void *v2; // x0
  void *v3; // x20
  __int64 v5; // x0
  __int64 v6; // x0

  v1 = (a1 + 143) & 0xFFFFFFFFFFFFFFF0LL;
  v2 = (void *)sub_6863918(v1);
  v3 = v2;
  if ( v2 )
  {
    memset(v2, 0, v1);
    return (__int64)v3 + 128;
  }
  else
  {
    v5 = sub_68629B8();
    v6 = sub_68631D0(v5);
    return sub_6862024(v6);
  }
}


================================================================================
Function: sub_6862024 (0x6862024)
================================================================================

__int64 __fastcall sub_6862024(__int64 a1)
{
  return sub_6863A84(a1 - 128);
}


================================================================================
Function: sub_6862048 (0x6862048)
================================================================================

void __fastcall __noreturn sub_6862048(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x22
  int v7; // w8

  v6 = sub_68626B0();
  *(_QWORD *)(a1 - 96) = sub_68629A4();
  *(_QWORD *)(a1 - 88) = sub_6862A18();
  *(_QWORD *)(a1 - 112) = a2;
  *(_QWORD *)(a1 - 104) = a3;
  sub_68620C8(a1 - 32);
  v7 = *(_DWORD *)(v6 + 8) + 1;
  *(_QWORD *)(a1 - 120) = 1LL;
  *(_QWORD *)(a1 - 24) = sub_68620E4;
  *(_DWORD *)(v6 + 8) = v7;
  sub_6867660(a1 - 32);
  sub_686214C(a1 - 128);
}


================================================================================
Function: sub_68620C8 (0x68620C8)
================================================================================

_QWORD *__fastcall sub_68620C8(_QWORD *result)
{
  *result = 0x434C4E47432B2B00LL;
  return result;
}


================================================================================
Function: sub_686214C (0x686214C)
================================================================================

void __fastcall __noreturn sub_686214C(__int64 a1)
{
  sub_686217C(a1 + 96);
  sub_6862A2C(*(_QWORD *)(a1 + 40));
}


================================================================================
Function: sub_686217C (0x686217C)
================================================================================

_QWORD *__fastcall sub_686217C(unsigned __int64 *a1)
{
  unsigned __int64 v2; // x20
  __int64 v3; // x0
  unsigned __int64 *v4; // x9
  int v5; // w8
  int v6; // w10
  unsigned __int64 v7; // x8
  bool v8; // zf
  _QWORD *v9; // x8

  v2 = *a1;
  v3 = sub_68626B0();
  v4 = a1 - 12;
  if ( v2 >> 8 == 0x434C4E47432B2BLL )
  {
    v5 = *((_DWORD *)a1 - 10);
    if ( v5 >= 0 )
      v6 = *((_DWORD *)a1 - 10);
    else
      v6 = -v5;
    v7 = *(_QWORD *)v3;
    v8 = *(_QWORD *)v3 == (_QWORD)v4;
    *((_DWORD *)a1 - 10) = v6 + 1;
    if ( !v8 )
    {
      *(a1 - 6) = v7;
      *(_QWORD *)v3 = v4;
    }
    v9 = (_QWORD *)*(a1 - 1);
    --*(_DWORD *)(v3 + 8);
  }
  else
  {
    if ( *(_QWORD *)v3 )
      sub_68629B8();
    v9 = a1 + 4;
    *(_QWORD *)v3 = v4;
  }
  return v9;
}


================================================================================
Function: sub_6862688 (0x6862688)
================================================================================

_QWORD *sub_6862688()
{
  _QWORD *result; // x0

  result = sub_68626D4();
  if ( result )
    return (_QWORD *)*((unsigned int *)result + 2);
  return result;
}


================================================================================
Function: sub_68626B0 (0x68626B0)
================================================================================

__int64 sub_68626B0()
{
  return sub_6866980(&unk_6CAF9E0);
}


================================================================================
Function: sub_68626D4 (0x68626D4)
================================================================================

_QWORD *sub_68626D4()
{
  return sub_6866980(qword_6CAF9E0);
}


================================================================================
Function: sub_68626F8 (0x68626F8)
================================================================================

__int64 __fastcall sub_68626F8(__int64 a1)
{
  int v1; // w20
  unsigned int v3; // w21
  char v5; // w23
  int v6; // w21
  int v7; // w8

  if ( atomic_load((unsigned __int8 *)a1) )
  {
    return 0;
  }
  else
  {
    if ( pthread_mutex_lock(&stru_79D8C08) )
      sub_684DDCC("%s failed to acquire mutex");
    v5 = *(_BYTE *)(a1 + 1);
    if ( (v5 & 2) != 0 )
    {
      v6 = *(_DWORD *)(a1 + 4);
      v1 = syscall(178LL);
      if ( v6 == v1 )
        sub_684DDCC("__cxa_guard_acquire detected recursive initialization");
    }
    while ( 1 )
    {
      v7 = *(unsigned __int8 *)(a1 + 1);
      if ( (v7 & 2) == 0 )
        break;
      *(_BYTE *)(a1 + 1) = v7 | 4;
      pthread_cond_wait(&stru_79D8C30, &stru_79D8C08);
    }
    if ( v7 == 1 )
    {
      v3 = 0;
    }
    else
    {
      if ( (v5 & 2) == 0 )
        v1 = syscall(178LL);
      v3 = 1;
      *(_DWORD *)(a1 + 4) = v1;
      *(_BYTE *)(a1 + 1) = 2;
    }
    if ( pthread_mutex_unlock(&stru_79D8C08) )
      sub_684DDCC("%s failed to release mutex");
  }
  return v3;
}


================================================================================
Function: sub_6862850 (0x6862850)
================================================================================

__int64 __fastcall sub_6862850(unsigned __int8 *a1)
{
  unsigned __int8 v2; // w20
  __int64 result; // x0

  atomic_store(1u, a1);
  if ( pthread_mutex_lock(&stru_79D8C08) )
    sub_684DDCC("%s failed to acquire mutex");
  v2 = a1[1];
  a1[1] = 1;
  result = pthread_mutex_unlock(&stru_79D8C08);
  if ( (_DWORD)result )
    sub_684DDCC("%s failed to release mutex");
  if ( (v2 & 4) != 0 )
  {
    result = pthread_cond_broadcast(&stru_79D8C30);
    if ( (_DWORD)result )
      sub_684DDCC("%s failed to broadcast");
  }
  return result;
}


================================================================================
Function: sub_68629A4 (0x68629A4)
================================================================================

unsigned __int64 sub_68629A4()
{
  return atomic_load((unsigned __int64 *)&off_6CAF9D0);
}


================================================================================
Function: sub_68629B8 (0x68629B8)
================================================================================

void __noreturn sub_68629B8()
{
  __int64 *v0; // x0
  __int64 v1; // x19
  unsigned __int64 v2; // x0

  v0 = (__int64 *)sub_68626D4();
  if ( v0 )
  {
    v1 = *v0;
    if ( *v0 )
    {
      if ( (sub_6861FAC(v1 + 96) & 1) != 0 )
        sub_6862A2C(*(_QWORD *)(v1 + 40));
    }
  }
  v2 = atomic_load((unsigned __int64 *)off_6CAF9C8);
  sub_6862A2C(v2);
}


================================================================================
Function: sub_68629FC (0x68629FC)
================================================================================

void __fastcall __noreturn sub_68629FC(void (*a1)(void))
{
  a1();
  sub_684DDCC("unexpected_handler unexpectedly returned");
}


================================================================================
Function: sub_6862A18 (0x6862A18)
================================================================================

unsigned __int64 sub_6862A18()
{
  return atomic_load((unsigned __int64 *)off_6CAF9C8);
}


================================================================================
Function: sub_6862A2C (0x6862A2C)
================================================================================

void __fastcall __noreturn sub_6862A2C(void (*a1)(void))
{
  a1();
  sub_684DDCC("terminate_handler unexpectedly returned");
}


================================================================================
Function: sub_68631D0 (0x68631D0)
================================================================================

void __fastcall __noreturn sub_68631D0(__int64 a1)
{
  __int64 v2; // x0

  if ( !a1 )
  {
    sub_686217C();
    sub_68629B8();
  }
  sub_686217C();
  if ( (sub_6861FAC(a1) & 1) != 0 )
  {
    v2 = *(_QWORD *)(a1 - 64);
  }
  else
  {
    sub_6862A18();
    v2 = sub_68629A4();
  }
  sub_68629FC(v2);
}


================================================================================
Function: sub_6863688 (0x6863688)
================================================================================

__int64 __fastcall sub_6863688(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  unsigned __int8 v5; // w8
  _QWORD *v6; // x0
  _QWORD *v7; // x21
  __int64 *v8; // x8
  __int64 v9; // x9

  if ( &_cxa_thread_atexit_impl )
    return __cxa_thread_atexit_impl(a1, a2);
  v5 = atomic_load(byte_79D8C68);
  if ( (v5 & 1) == 0 )
  {
    if ( (unsigned int)sub_68626F8((__int64)byte_79D8C68) )
    {
      sub_68637B8();
      __cxa_atexit((void (*)(void *))&loc_68637F4, &unk_79D8C60, &off_686E780);
      sub_6862850(byte_79D8C68);
    }
  }
  if ( (*(_BYTE *)sub_6866980(qword_6CAFA00) & 1) == 0 )
  {
    if ( pthread_setspecific(dword_79D8C70, &dword_79D8C70) )
      return 0xFFFFFFFFLL;
    *(_BYTE *)sub_6866980(qword_6CAFA00) = 1;
  }
  v6 = (_QWORD *)sub_67F3A24(0x18uLL);
  if ( v6 )
  {
    v7 = v6;
    *v6 = a1;
    v6[1] = a2;
    v8 = sub_6866980(qword_6CAFA20);
    result = 0LL;
    v9 = *v8;
    *v8 = (__int64)v7;
    v7[2] = v9;
    return result;
  }
  return 0xFFFFFFFFLL;
}


================================================================================
Function: sub_68637B8 (0x68637B8)
================================================================================

__int64 sub_68637B8()
{
  __int64 result; // x0

  result = pthread_key_create((pthread_key_t *)&dword_79D8C70, (void (*)(void *))sub_6863880);
  if ( (_DWORD)result )
    sub_684DDCC("std::__libcpp_tls_create() failed in __cxa_thread_atexit()");
  return result;
}


================================================================================
Function: sub_6863918 (0x6863918)
================================================================================

__int64 __fastcall sub_6863918(__int64 a1)
{
  unsigned __int64 StatusReg; // x20
  __int64 v2; // x19
  _QWORD v4[2]; // [xsp+0h] [xbp-10h] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a1 )
    v2 = a1;
  else
    v2 = 1LL;
  v4[1] = *(_QWORD *)(StatusReg + 40);
  if ( (unsigned int)sub_67F3D40(v4, 16LL, v2) )
    return sub_686398C(v2);
  else
    return v4[0];
}


================================================================================
Function: sub_686398C (0x686398C)
================================================================================

unsigned __int16 *__fastcall sub_686398C(__int64 a1)
{
  int *v2; // x11
  int *v3; // x12
  unsigned __int64 v4; // x10
  int *v5; // x19
  unsigned __int64 v6; // x11
  __int64 v7; // x13
  unsigned __int16 *v8; // x19
  unsigned __int16 *v9; // x9
  __int64 v10; // x10

  pthread_mutex_lock(&stru_79D8C74);
  v2 = (int *)qword_79D8CA0;
  if ( !qword_79D8CA0 )
  {
    v2 = dword_79D8CB0;
    qword_79D8CA0 = (__int64)dword_79D8CB0;
    dword_79D8CB0[0] = 8388736;
  }
  if ( v2 == (int *)&byte_79D8EB0 )
  {
LABEL_8:
    v8 = 0LL;
  }
  else
  {
    v3 = 0LL;
    v4 = ((unsigned __int64)(a1 + 3) >> 2) + 1;
    while ( 1 )
    {
      v5 = v2;
      v6 = *((unsigned __int16 *)v2 + 1);
      if ( v4 < v6 )
      {
        v9 = (unsigned __int16 *)&v5[(unsigned __int16)(v6 - v4)];
        *((_WORD *)v5 + 1) = v6 - v4;
        v8 = v9 + 2;
        *v9 = 0;
        v9[1] = v4;
        goto LABEL_13;
      }
      if ( v4 == v6 )
        break;
      v3 = v5;
      v7 = *(unsigned __int16 *)v5;
      v2 = &dword_79D8CB0[v7];
      if ( v7 == 128 )
        goto LABEL_8;
    }
    v10 = *(unsigned __int16 *)v5;
    if ( v3 )
    {
      *(_WORD *)v3 = v10;
      *(_WORD *)v5 = 0;
      v8 = (unsigned __int16 *)(v5 + 1);
    }
    else
    {
      *(_WORD *)v5 = 0;
      v8 = (unsigned __int16 *)(v5 + 1);
      qword_79D8CA0 = (__int64)&dword_79D8CB0[v10];
    }
  }
LABEL_13:
  pthread_mutex_unlock(&stru_79D8C74);
  return v8;
}


================================================================================
Function: sub_6863A84 (0x6863A84)
================================================================================

unsigned __int64 __fastcall sub_6863A84(unsigned __int64 a1)
{
  int *v3; // x20
  int v4; // w9
  bool v5; // zf
  int *v6; // x11
  int *v7; // x10
  __int64 v8; // x13
  __int64 v9; // x14
  __int64 v10; // x13
  __int16 v11; // w9

  if ( a1 < (unsigned __int64)dword_79D8CB0 || a1 >= (unsigned __int64)&byte_79D8EB0 )
    return sub_67F3C08(a1);
  v3 = (int *)(a1 - 4);
  pthread_mutex_lock(&stru_79D8C74);
  v4 = qword_79D8CA0;
  if ( qword_79D8CA0 )
    v5 = qword_79D8CA0 == (_QWORD)&byte_79D8EB0;
  else
    v5 = 1;
  if ( v5 )
  {
LABEL_13:
    qword_79D8CA0 = (__int64)v3;
    *(_WORD *)v3 = (v4 - (unsigned int)dword_79D8CB0) >> 2;
  }
  else
  {
    v6 = 0LL;
    v7 = (int *)qword_79D8CA0;
    while ( 1 )
    {
      v8 = *((unsigned __int16 *)v7 + 1);
      if ( &v7[v8] == v3 )
      {
        *((_WORD *)v7 + 1) = *(_WORD *)(a1 - 2) + v8;
        return pthread_mutex_unlock(&stru_79D8C74);
      }
      v9 = *(unsigned __int16 *)(a1 - 2);
      if ( &v3[v9] == v7 )
        break;
      v10 = *(unsigned __int16 *)v7;
      v6 = v7;
      v7 = &dword_79D8CB0[v10];
      if ( v10 == 128 )
        goto LABEL_13;
    }
    *(_WORD *)(a1 - 2) = v9 + v8;
    if ( v6 )
    {
      *(_WORD *)v6 = ((unsigned int)v3 - (unsigned int)dword_79D8CB0) >> 2;
    }
    else
    {
      v11 = *(_WORD *)v7;
      qword_79D8CA0 = (__int64)v3;
      *(_WORD *)v3 = v11;
    }
  }
  return pthread_mutex_unlock(&stru_79D8C74);
}


================================================================================
Function: sub_6865270 (0x6865270)
================================================================================

_QWORD *__fastcall sub_6865270(_QWORD *result)
{
  *result = off_6C5EDB8;
  return result;
}


================================================================================
Function: sub_68656D0 (0x68656D0)
================================================================================

_QWORD *__fastcall sub_68656D0(_QWORD *result)
{
  *result = off_6C5F0B0;
  return result;
}


================================================================================
Function: sub_6865770 (0x6865770)
================================================================================

__int64 sub_6865770()
{
  __int64 result; // x0
  bool v1; // w10
  bool v2; // w13
  bool v3; // w12
  bool v4; // w12
  __int128 v5; // [xsp+0h] [xbp-20h]
  __int128 v6; // [xsp+10h] [xbp-10h]

  result = 1LL;
  v1 = (_QWORD)v6 != 0LL;
  if ( (*((_QWORD *)&v6 + 1) & 0x7FFFFFFFFFFFFFFFLL) != 0x7FFF000000000000LL )
    v1 = (*((_QWORD *)&v6 + 1) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FFF000000000000LL;
  if ( !v1 )
  {
    v2 = (*((_QWORD *)&v5 + 1) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FFF000000000000LL;
    if ( (*((_QWORD *)&v5 + 1) & 0x7FFFFFFFFFFFFFFFLL) == 0x7FFF000000000000LL )
      v2 = (_QWORD)v5 != 0LL;
    if ( !v2 )
    {
      if ( !((unsigned __int64)v5 | (unsigned __int64)v6 | *((_QWORD *)&v5 + 1) & 0x7FFFFFFFFFFFFFFFLL | *((_QWORD *)&v6 + 1) & 0x7FFFFFFFFFFFFFFFLL) )
        return 0LL;
      if ( (__int64)(*((_QWORD *)&v5 + 1) & *((_QWORD *)&v6 + 1)) < 0 != __OFSUB__(
                                                                           *((_QWORD *)&v5 + 1) & 0x7FFFFFFFFFFFFFFFLL,
                                                                           0x7FFF000000000000LL) )
      {
        v4 = (unsigned __int64)v6 > (unsigned __int64)v5;
        if ( *((_QWORD *)&v6 + 1) != *((_QWORD *)&v5 + 1) )
          v4 = *((_QWORD *)&v6 + 1) > *((_QWORD *)&v5 + 1);
        if ( v4 )
          return 0xFFFFFFFFLL;
      }
      else
      {
        v3 = (unsigned __int64)v6 < (unsigned __int64)v5;
        if ( *((_QWORD *)&v6 + 1) != *((_QWORD *)&v5 + 1) )
          v3 = *((_QWORD *)&v6 + 1) < *((_QWORD *)&v5 + 1);
        if ( v3 )
          return 0xFFFFFFFFLL;
      }
      return v6 != v5;
    }
  }
  return result;
}


================================================================================
Function: sub_6865848 (0x6865848)
================================================================================

__int64 sub_6865848()
{
  _BOOL4 v0; // w9
  unsigned __int64 v1; // x10
  _BOOL4 v2; // w8
  __int64 v4; // [xsp+0h] [xbp-20h]
  __int64 v5; // [xsp+8h] [xbp-18h]
  __int64 v6; // [xsp+10h] [xbp-10h]
  __int64 v7; // [xsp+18h] [xbp-8h]

  v0 = v6 != 0;
  v1 = v5 & 0x7FFFFFFFFFFFFFFFLL;
  if ( (v7 & 0x7FFFFFFFFFFFFFFFLL) != 0x7FFF000000000000LL )
    v0 = (v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FFF000000000000LL;
  v2 = v1 > 0x7FFF000000000000LL;
  if ( v1 == 0x7FFF000000000000LL )
    v2 = v4 != 0;
  return v0 | (unsigned int)v2;
}


================================================================================
Function: sub_6866330 (0x6866330)
================================================================================

double sub_6866330()
{
  unsigned __int64 v0; // x10
  __int64 v1; // x10
  __int64 v2; // x9
  double result; // d0
  bool v4; // w11
  unsigned __int64 v5; // x10
  char v6; // w11
  char v7; // w10
  unsigned __int64 v8; // x12
  bool v9; // zf
  unsigned __int64 v10; // x14
  unsigned __int64 v11; // x11
  unsigned __int64 v12; // x16
  __int64 v13; // x11
  unsigned __int64 v14; // x13
  __int64 v15; // x12
  bool v16; // zf
  unsigned __int64 v17; // x9
  unsigned __int64 v18; // x10
  __int64 v19; // x11
  __int128 v20; // t2
  __int128 v21; // [xsp+0h] [xbp-10h]

  v0 = *((_QWORD *)&v21 + 1) & 0x7FFFFFFFFFFFFFFFLL;
  if ( (*((_QWORD *)&v21 + 1) & 0x7FFFFFFFFFFFFFFFuLL) - 0x3C01000000000000LL >= (*((_QWORD *)&v21 + 1) & 0x7FFFFFFFFFFFFFFFuLL)
                                                                               - 0x43FF000000000000LL )
  {
    v4 = v0 < 0x7FFF000000000000LL;
    if ( v0 == 0x7FFF000000000000LL )
      v4 = (_QWORD)v21 == 0LL;
    if ( v4 )
    {
      if ( v0 <= 0x43FEFFFFFFFFFFFFLL )
      {
        v5 = HIWORD(v0);
        if ( (unsigned int)v5 >= 0x3B91 )
        {
          v6 = v5 + 127;
          v7 = 1 - v5;
          v8 = *((_QWORD *)&v21 + 1) & 0xFFFFFFFFFFFFLL | 0x1000000000000LL;
          v9 = (v6 & 0x40) == 0LL;
          v10 = (_QWORD)v21 << v6;
          v11 = (v8 << v6) | ((unsigned __int64)v21 >> 1 >> ~v6);
          if ( v9 )
            v12 = v10;
          else
            v12 = 0LL;
          if ( !v9 )
            v11 = v10;
          v9 = (v12 | v11) == 0;
          v13 = (2 * v8) << ~v7;
          v14 = v8 >> v7;
          v15 = !v9;
          v16 = (v7 & 0x40) == 0LL;
          v17 = v13 | ((unsigned __int64)v21 >> v7);
          if ( (v7 & 0x40) != 0 )
            v18 = 0LL;
          else
            v18 = v14;
          if ( !v16 )
            v17 = v14;
          v19 = v17 & 0xFFFFFFFFFFFFFFFLL;
          *((_QWORD *)&v20 + 1) = v18;
          *(_QWORD *)&v20 = v17;
          v2 = v20 >> 60;
          if ( (v19 | (unsigned __int64)v15) < 0x800000000000001LL )
          {
            if ( (v19 | v15) != 0x800000000000000LL )
              goto LABEL_5;
            v1 = v2 & 1;
            goto LABEL_4;
          }
          *(_QWORD *)&result = (v2 + 1) | *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
        }
        else
        {
          *(_QWORD *)&result = *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
        }
      }
      else
      {
        *(_QWORD *)&result = *((_QWORD *)&v21 + 1) & 0x8000000000000000LL | 0x7FF0000000000000LL;
      }
    }
    else
    {
      *(_QWORD *)&result = (v21 >> 60) & 0x7FFFFFFFFFFFFLL | 0x7FF8000000000000LL | *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
    }
  }
  else
  {
    v1 = v21 >> 60;
    if ( ((unsigned __int64)v21 & 0xFFFFFFFFFFFFFFFLL) >= 0x800000000000001LL )
    {
      v2 = 0x4000000000000001LL;
LABEL_4:
      v2 += v1;
LABEL_5:
      *(_QWORD *)&result = v2 | *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
      return result;
    }
    v2 = v1 + 0x4000000000000000LL;
    if ( (v21 & 0xFFFFFFFFFFFFFFFLL) != 0x800000000000000LL )
      goto LABEL_5;
    *(_QWORD *)&result = (v2 + (v1 & 1)) | *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
  }
  return result;
}


================================================================================
Function: sub_68664F4 (0x68664F4)
================================================================================

float sub_68664F4()
{
  unsigned __int64 v0; // x10
  bool v1; // w12
  unsigned __int64 v2; // x11
  unsigned __int64 v3; // x9
  float result; // s0
  bool v5; // w11
  unsigned __int64 v6; // x10
  char v7; // w11
  char v8; // w10
  unsigned __int64 v9; // x12
  bool v10; // zf
  unsigned __int64 v11; // x14
  unsigned __int64 v12; // x11
  unsigned __int64 v13; // x16
  _BOOL8 v14; // x13
  __int64 v15; // x9
  unsigned __int64 v16; // x12
  __int64 v17; // x10
  bool v18; // w9
  bool v19; // w13
  unsigned __int64 v20; // [xsp+0h] [xbp-10h]
  unsigned __int64 v21; // [xsp+8h] [xbp-8h]

  v0 = v21 & 0x7FFFFFFFFFFFFFFFLL;
  if ( (v21 & 0x7FFFFFFFFFFFFFFFLL) - 0x3F81000000000000LL >= (v21 & 0x7FFFFFFFFFFFFFFFLL) - 0x407F000000000000LL )
  {
    v5 = v0 < 0x7FFF000000000000LL;
    if ( v0 == 0x7FFF000000000000LL )
      v5 = v20 == 0;
    if ( v5 )
    {
      if ( v0 <= 0x407EFFFFFFFFFFFFLL )
      {
        v6 = HIWORD(v0);
        if ( (unsigned int)v6 >= 0x3F11 )
        {
          v7 = v6 - 1;
          v8 = -127 - v6;
          v9 = v21 & 0xFFFFFFFFFFFFLL | 0x1000000000000LL;
          v10 = (v7 & 0x40) == 0LL;
          v11 = v20 << v7;
          v12 = (v9 << v7) | (v20 >> 1 >> ~v7);
          if ( v10 )
            v13 = v11;
          else
            v13 = 0LL;
          if ( !v10 )
            v12 = v11;
          v14 = (v13 | v12) != 0;
          v15 = ((2 * v9) << ~v8) | (v20 >> v8);
          if ( (v8 & 0x40) != 0 )
          {
            v15 = v9 >> v8;
            v16 = 0LL;
          }
          else
          {
            v16 = v9 >> v8;
          }
          v17 = v15 | v14;
          v18 = (v15 | v14) == 0;
          if ( (v16 & 0x1FFFFFF) == 0x1000000 )
            v19 = v18;
          else
            v19 = ((v16 >> 24) & 1) == 0;
          v3 = v16 >> 25;
          if ( v19 )
          {
            if ( v17 | v16 & 0x1FFFFFF ^ 0x1000000 )
              goto LABEL_6;
            LODWORD(result) = (((v16 & 0x2000000) != 0) + (unsigned int)(v16 >> 25)) | HIDWORD(v21) & 0x80000000;
          }
          else
          {
            LODWORD(result) = (v3 + 1) | HIDWORD(v21) & 0x80000000;
          }
        }
        else
        {
          LODWORD(result) = HIDWORD(v21) & 0x80000000;
        }
      }
      else
      {
        LODWORD(result) = HIDWORD(v21) & 0x80000000 | 0x7F800000;
      }
    }
    else
    {
      LODWORD(result) = (v21 >> 25) & 0x3FFFFF | 0x7FC00000 | HIDWORD(v21) & 0x80000000;
    }
  }
  else
  {
    v1 = v20 == 0;
    if ( (v21 & 0x1FFFFFF) != 0x1000000 )
      v1 = ((v21 >> 24) & 1) == 0;
    v2 = v21 >> 25;
    if ( !v1 )
    {
      LODWORD(v3) = v2 + 1073741825;
LABEL_6:
      LODWORD(result) = v3 | HIDWORD(v21) & 0x80000000;
      return result;
    }
    LODWORD(v3) = v2 + 0x40000000;
    if ( v20 | v21 & 0x1FFFFFF ^ 0x1000000 )
      goto LABEL_6;
    LODWORD(result) = (v3 + ((v21 & 0x2000000) != 0)) | HIDWORD(v21) & 0x80000000;
  }
  return result;
}


================================================================================
Function: sub_6866714 (0x6866714)
================================================================================

__int64 __fastcall sub_6866714(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 *a5)
{
  unsigned __int64 v5; // x8
  bool v6; // w9
  __int64 v7; // x9
  __int64 result; // x0
  int v9; // w12
  int v10; // w13
  int v11; // w9
  unsigned __int64 v12; // x11
  unsigned __int64 v13; // x10
  int v14; // w12
  __int64 v15; // x13
  __int128 v16; // t2
  char v18; // w10
  unsigned __int64 v19; // x11
  unsigned __int64 v20; // x13
  unsigned __int64 v21; // x9
  __int64 v22; // x14
  unsigned __int64 v23; // x8
  unsigned int v24; // w12
  unsigned __int64 v25; // x16
  unsigned __int64 v26; // x15
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x16
  unsigned __int64 v29; // x13
  __int64 v30; // x14
  unsigned __int64 v31; // x9
  unsigned __int64 v32; // x16
  unsigned __int64 v33; // x16
  unsigned __int64 v34; // x11
  unsigned __int64 v35; // x10

  v5 = a2;
  v6 = a3 <= a1;
  if ( a4 != a2 )
    v6 = a4 <= a2;
  if ( !v6 )
  {
    v7 = 0LL;
    if ( a5 )
    {
      *a5 = a1;
      a5[1] = a2;
      return 0LL;
    }
    return v7;
  }
  if ( a4 )
  {
    v9 = __clz(a4);
    v10 = __clz(a2);
    v11 = v9 - v10;
    v12 = a3 << ((unsigned __int8)v9 - (unsigned __int8)v10);
    if ( ((v9 - v10) & 0x40LL) != 0 )
      v13 = 0LL;
    else
      v13 = a3 << ((unsigned __int8)v9 - (unsigned __int8)v10);
    if ( (v11 & 0x40) == 0 )
      v12 = (a4 << ((unsigned __int8)v9 - (unsigned __int8)v10)) | (a3 >> 1 >> ~((unsigned __int8)v9
                                                                               - (unsigned __int8)v10));
    if ( v11 < 0 )
    {
      v7 = 0LL;
      if ( !a5 )
        return v7;
    }
    else
    {
      v7 = 0LL;
      v14 = ~v9 + v10;
      do
      {
        v15 = (__int64)(~v5 + __CFADD__(v13, ~a1) + v12) >> 63;
        v7 = 2 * v7 - v15;
        v5 = (__PAIR128__(v5, a1) - __PAIR128__(v15 & v12, v15 & v13)) >> 64;
        a1 -= v15 & v13;
        *((_QWORD *)&v16 + 1) = v12;
        *(_QWORD *)&v16 = v13;
        v13 = v16 >> 1;
        v12 >>= 1;
      }
      while ( !__CFADD__(v14++, 1) );
      if ( !a5 )
        return v7;
    }
    *a5 = a1;
    a5[1] = v5;
    return v7;
  }
  if ( a2 >= a3 )
  {
    v18 = __clz(a3);
    v19 = a3 << v18;
    v29 = a3 << v18 >> 32;
    v30 = (unsigned int)(a3 << v18);
    v24 = a1 << v18;
    v31 = ((a2 % a3) << v18) | (a1 >> 1 >> ~v18);
    v23 = v31 / v29;
    v32 = v31 % v29;
    do
    {
      if ( !HIDWORD(v23) && v23 * v30 <= ((a1 << v18 >> 32) | ((unsigned __int64)(unsigned int)v32 << 32)) )
        break;
      v32 += v29;
      --v23;
    }
    while ( !HIDWORD(v32) );
    v26 = ((a1 << v18 >> 32) | ((unsigned __int64)(unsigned int)v31 << 32)) - v23 * v19;
    v27 = v26 / v29;
    v33 = v26 % v29;
    do
    {
      if ( !HIDWORD(v27) && v27 * v30 <= (v24 | ((unsigned __int64)(unsigned int)v33 << 32)) )
        break;
      v33 += v29;
      --v27;
    }
    while ( !HIDWORD(v33) );
  }
  else
  {
    v18 = __clz(a3);
    v19 = a3 << v18;
    v20 = a3 << v18 >> 32;
    v21 = (a2 << v18) | (a1 >> 1 >> ~v18);
    v22 = (unsigned int)(a3 << v18);
    v23 = v21 / v20;
    v24 = a1 << v18;
    v25 = v21 % v20;
    do
    {
      if ( !HIDWORD(v23) && v23 * v22 <= ((a1 << v18 >> 32) | ((unsigned __int64)(unsigned int)v25 << 32)) )
        break;
      v25 += v20;
      --v23;
    }
    while ( !HIDWORD(v25) );
    v26 = ((a1 << v18 >> 32) | ((unsigned __int64)(unsigned int)v21 << 32)) - v23 * v19;
    v27 = v26 / v20;
    v28 = v26 % v20;
    do
    {
      if ( !HIDWORD(v27) && v27 * v22 <= (v24 | ((unsigned __int64)(unsigned int)v28 << 32)) )
        break;
      v28 += v20;
      --v27;
    }
    while ( !HIDWORD(v28) );
  }
  v34 = (v24 | ((unsigned __int64)(unsigned int)v26 << 32)) - v27 * v19;
  v7 = v27 + (v23 << 32);
  v35 = v34 >> v18;
  if ( !a5 )
    return v7;
  result = v7;
  *a5 = v35;
  a5[1] = 0LL;
  return result;
}


================================================================================
Function: sub_6866974 (0x6866974)
================================================================================

__int64 __fastcall sub_6866974(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_6866714(a1, a2, a3, a4, 0LL);
}


================================================================================
Function: sub_6866980 (0x6866980)
================================================================================

_QWORD *__fastcall sub_6866980(size_t *a1)
{
  unsigned __int64 v2; // x22
  _QWORD *v3; // x0
  unsigned __int64 v4; // x21
  _QWORD *v5; // x20
  unsigned __int64 v6; // x24
  __int64 v7; // x0
  __int64 v8; // x0
  pthread_key_t v9; // w0
  _QWORD *v10; // x22
  _QWORD *v11; // x20
  _QWORD *v12; // x22
  _QWORD *v13; // t1
  __int64 v14; // x20
  size_t v15; // x21
  __int64 v16; // x0
  const void *v17; // x1

  v2 = atomic_load(a1 + 2);
  if ( !v2 )
  {
    pthread_once(dword_79D8EB8, (void (*)(void))sub_6866B84);
    pthread_mutex_lock(&stru_79D8EC8);
    v2 = a1[2];
    if ( !v2 )
    {
      v2 = ++qword_79D8EC0;
      atomic_store(qword_79D8EC0, a1 + 2);
    }
    pthread_mutex_unlock(&stru_79D8EC8);
    v3 = pthread_getspecific(dword_79D8EB4);
    if ( v3 )
      goto LABEL_3;
LABEL_9:
    v6 = ((v2 + 17) & 0xFFFFFFFFFFFFFFF0LL) - 2;
    v8 = sub_67F3A24(8 * v6 + 16);
    if ( !v8 )
      abort();
    v5 = (_QWORD *)v8;
    memset((void *)(v8 + 16), 0, 8 * v6);
    *v5 = 1LL;
    goto LABEL_11;
  }
  v3 = pthread_getspecific(dword_79D8EB4);
  if ( !v3 )
    goto LABEL_9;
LABEL_3:
  v4 = v3[1];
  v5 = v3;
  if ( v4 >= v2 )
    goto LABEL_12;
  v6 = ((v2 + 17) & 0xFFFFFFFFFFFFFFF0LL) - 2;
  v7 = sub_67F3BA8(v3, 8 * v6 + 16);
  if ( !v7 )
    abort();
  v5 = (_QWORD *)v7;
  memset((void *)(v7 + 8 * v4 + 16), 0, 8 * (v6 - v4));
LABEL_11:
  v9 = dword_79D8EB4;
  v5[1] = v6;
  pthread_setspecific(v9, v5);
LABEL_12:
  v10 = &v5[v2 - 1];
  v13 = (_QWORD *)v10[2];
  v12 = v10 + 2;
  v11 = v13;
  if ( !v13 )
  {
    if ( a1[1] <= 8 )
      v14 = 8LL;
    else
      v14 = a1[1];
    if ( (v14 & (v14 - 1)) != 0 )
      abort();
    v15 = *a1;
    v16 = sub_67F3A24(v14 + 7 + *a1);
    if ( !v16 )
      abort();
    v11 = (_QWORD *)((v16 + v14 + 7) & -v14);
    *(v11 - 1) = v16;
    v17 = (const void *)a1[3];
    if ( v17 )
      memcpy(v11, v17, v15);
    else
      memset(v11, 0, v15);
    *v12 = v11;
  }
  return v11;
}


================================================================================
Function: sub_6866D60 (0x6866D60)
================================================================================

char __fastcall sub_6866D60(int a1, unsigned __int8 a2, atomic_uchar *a3)
{
  int v3; // w16

  if ( byte_79D8EF0 )
  {
    atomic_compare_exchange_strong_explicit(a3, (unsigned __int8 *)&a1, a2, memory_order_release, memory_order_relaxed);
  }
  else
  {
    v3 = (unsigned __int8)a1;
    do
      a1 = __ldxr((unsigned __int8 *)a3);
    while ( a1 == v3 && __stlxr(a2, (unsigned __int8 *)a3) );
  }
  return a1;
}


================================================================================
Function: sub_6866E20 (0x6866E20)
================================================================================

__int16 __fastcall sub_6866E20(int a1, unsigned __int16 a2, atomic_ushort *a3)
{
  int v3; // w16

  if ( byte_79D8EF0 )
  {
    atomic_compare_exchange_strong(a3, (unsigned __int16 *)&a1, a2);
  }
  else
  {
    v3 = (unsigned __int16)a1;
    do
      a1 = __ldaxr((unsigned __int16 *)a3);
    while ( a1 == v3 && __stlxr(a2, (unsigned __int16 *)a3) );
  }
  return a1;
}


================================================================================
Function: sub_6866E60 (0x6866E60)
================================================================================

unsigned int __fastcall sub_6866E60(unsigned int result, unsigned int a2, atomic_uint *a3)
{
  unsigned int v4; // w16

  if ( byte_79D8EF0 )
  {
    atomic_compare_exchange_strong_explicit(a3, &result, a2, memory_order_relaxed, memory_order_relaxed);
  }
  else
  {
    v4 = result;
    do
      result = __ldxr((unsigned int *)a3);
    while ( result == v4 && __stxr(a2, (unsigned int *)a3) );
  }
  return result;
}


================================================================================
Function: sub_6866F20 (0x6866F20)
================================================================================

unsigned int __fastcall sub_6866F20(unsigned int result, unsigned int a2, atomic_uint *a3)
{
  unsigned int v4; // w16

  if ( byte_79D8EF0 )
  {
    atomic_compare_exchange_strong(a3, &result, a2);
  }
  else
  {
    v4 = result;
    do
      result = __ldaxr((unsigned int *)a3);
    while ( result == v4 && __stlxr(a2, (unsigned int *)a3) );
  }
  return result;
}


================================================================================
Function: sub_6866F60 (0x6866F60)
================================================================================

unsigned __int64 __fastcall sub_6866F60(unsigned __int64 result, unsigned __int64 a2, atomic_ullong *a3)
{
  unsigned __int64 v4; // x16

  if ( byte_79D8EF0 )
  {
    atomic_compare_exchange_strong_explicit(a3, &result, a2, memory_order_relaxed, memory_order_relaxed);
  }
  else
  {
    v4 = result;
    do
      result = __ldxr((unsigned __int64 *)a3);
    while ( result == v4 && __stxr(a2, (unsigned __int64 *)a3) );
  }
  return result;
}


================================================================================
Function: sub_6866FE0 (0x6866FE0)
================================================================================

unsigned __int64 __fastcall sub_6866FE0(unsigned __int64 result, unsigned __int64 a2, atomic_ullong *a3)
{
  unsigned __int64 v4; // x16

  if ( byte_79D8EF0 )
  {
    atomic_compare_exchange_strong_explicit(a3, &result, a2, memory_order_release, memory_order_relaxed);
  }
  else
  {
    v4 = result;
    do
      result = __ldxr((unsigned __int64 *)a3);
    while ( result == v4 && __stlxr(a2, (unsigned __int64 *)a3) );
  }
  return result;
}


================================================================================
Function: sub_6867020 (0x6867020)
================================================================================

unsigned __int64 __fastcall sub_6867020(unsigned __int64 result, unsigned __int64 a2, atomic_ullong *a3)
{
  unsigned __int64 v4; // x16

  if ( byte_79D8EF0 )
  {
    atomic_compare_exchange_strong(a3, &result, a2);
  }
  else
  {
    v4 = result;
    do
      result = __ldaxr((unsigned __int64 *)a3);
    while ( result == v4 && __stlxr(a2, (unsigned __int64 *)a3) );
  }
  return result;
}


================================================================================
Function: sub_6867150 (0x6867150)
================================================================================

__int64 __fastcall sub_6867150(unsigned __int8 a1, atomic_uchar *a2)
{
  __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_exchange_explicit(a2, a1, memory_order_acquire);
  do
    result = __ldaxr((unsigned __int8 *)a2);
  while ( __stxr(a1, (unsigned __int8 *)a2) );
  return result;
}


================================================================================
Function: sub_68671B0 (0x68671B0)
================================================================================

__int64 __fastcall sub_68671B0(unsigned int a1, atomic_uint *a2)
{
  __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_exchange_explicit(a2, a1, memory_order_acquire);
  do
    result = __ldaxr((unsigned int *)a2);
  while ( __stxr(a1, (unsigned int *)a2) );
  return result;
}


================================================================================
Function: sub_68671E0 (0x68671E0)
================================================================================

__int64 __fastcall sub_68671E0(unsigned int a1, atomic_uint *a2)
{
  __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_exchange(a2, a1);
  do
    result = __ldaxr((unsigned int *)a2);
  while ( __stlxr(a1, (unsigned int *)a2) );
  return result;
}


================================================================================
Function: sub_6867270 (0x6867270)
================================================================================

unsigned __int64 __fastcall sub_6867270(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_exchange(a2, a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_68672D0 (0x68672D0)
================================================================================

__int64 __fastcall sub_68672D0(unsigned __int16 a1, atomic_ushort *a2)
{
  __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_relaxed);
  do
    result = __ldxr((unsigned __int16 *)a2);
  while ( __stxr(result + a1, (unsigned __int16 *)a2) );
  return result;
}


================================================================================
Function: sub_6867360 (0x6867360)
================================================================================

__int64 __fastcall sub_6867360(unsigned __int16 a1, atomic_ushort *a2)
{
  __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_add(a2, a1);
  do
    result = __ldaxr((unsigned __int16 *)a2);
  while ( __stlxr(result + a1, (unsigned __int16 *)a2) );
  return result;
}


================================================================================
Function: sub_6867390 (0x6867390)
================================================================================

__int64 __fastcall sub_6867390(unsigned int a1, atomic_uint *a2)
{
  __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_relaxed);
  do
    result = __ldxr((unsigned int *)a2);
  while ( __stxr(result + a1, (unsigned int *)a2) );
  return result;
}


================================================================================
Function: sub_68673F0 (0x68673F0)
================================================================================

__int64 __fastcall sub_68673F0(unsigned int a1, atomic_uint *a2)
{
  __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_add(a2, a1);
  do
    result = __ldaxr((unsigned int *)a2);
  while ( __stlxr(result + a1, (unsigned int *)a2) );
  return result;
}


================================================================================
Function: sub_6867420 (0x6867420)
================================================================================

unsigned __int64 __fastcall sub_6867420(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_relaxed);
  do
    result = __ldxr((unsigned __int64 *)a2);
  while ( __stxr(result + a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_6867450 (0x6867450)
================================================================================

unsigned __int64 __fastcall sub_6867450(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_acquire);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stxr(result + a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_6867480 (0x6867480)
================================================================================

unsigned __int64 __fastcall sub_6867480(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_release);
  do
    result = __ldxr((unsigned __int64 *)a2);
  while ( __stlxr(result + a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_68674B0 (0x68674B0)
================================================================================

unsigned __int64 __fastcall sub_68674B0(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_add(a2, a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(result + a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_6867540 (0x6867540)
================================================================================

unsigned __int64 __fastcall sub_6867540(__int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_and(a2, ~a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(result & ~a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_6867600 (0x6867600)
================================================================================

unsigned __int64 __fastcall sub_6867600(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_or_explicit(a2, a1, memory_order_release);
  do
    result = __ldxr((unsigned __int64 *)a2);
  while ( __stlxr(result | a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_6867630 (0x6867630)
================================================================================

unsigned __int64 __fastcall sub_6867630(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_79D8EF0 )
    return atomic_fetch_or(a2, a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(result | a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_6867660 (0x6867660)
================================================================================

__int64 __fastcall sub_6867660(_QWORD *a1)
{
  int v2; // w0
  int v4; // w0
  _BYTE v5[624]; // [xsp+0h] [xbp-4D0h] BYREF
  _BYTE v6[528]; // [xsp+270h] [xbp-260h] BYREF
  __int64 v7; // [xsp+480h] [xbp-50h] BYREF
  _BYTE v8[24]; // [xsp+488h] [xbp-48h] BYREF
  __int64 (__fastcall *v9)(__int64, __int64, _QWORD, _QWORD *, _BYTE *); // [xsp+4A0h] [xbp-30h]

  sub_686B4B0(v6);
  a1[2] = 0LL;
  a1[3] = 0LL;
  sub_6867AD8(v5, v6);
  v2 = sub_6867CEC(v5);
  if ( !v2 )
    return 5LL;
  while ( (v2 & 0x80000000) == 0 && !(unsigned int)sub_6867D10(v5, v8) )
  {
    if ( v9 )
    {
      v4 = v9(1LL, 1LL, *a1, a1, v5);
      if ( v4 != 8 )
      {
        if ( v4 == 6 )
        {
          sub_6867B84(v5, 4294967294LL, &v7);
          a1[3] = v7;
          return sub_6867758(v6, v5, a1);
        }
        return 3LL;
      }
    }
    v2 = sub_6867CEC(v5);
    if ( !v2 )
      return 5LL;
  }
  return 3LL;
}


================================================================================
Function: sub_6867758 (0x6867758)
================================================================================

__int64 __fastcall sub_6867758(_OWORD *a1, __int64 a2, _QWORD *a3)
{
  int v5; // w0
  __int64 v6; // x1
  int v7; // w0
  __int64 v9; // [xsp+0h] [xbp-50h] BYREF
  __int64 (__fastcall *v10)(__int64, __int64, _QWORD, _QWORD *, __int64); // [xsp+18h] [xbp-38h]
  __int64 v11; // [xsp+48h] [xbp-8h] BYREF

  sub_6867AD8(a2, a1);
  v5 = sub_6867CEC(a2);
  if ( !v5 )
    return 5LL;
  while ( (v5 & 0x80000000) == 0 )
  {
    sub_6867B84(a2, 0xFFFFFFFE, &v11);
    if ( (unsigned int)sub_6867D10(a2, (__int64)&v9) )
      break;
    if ( v10 )
    {
      if ( v11 == a3[3] )
        v6 = 6LL;
      else
        v6 = 2LL;
      v7 = v10(1LL, v6, *a3, a3, a2);
      if ( v7 != 8 )
      {
        if ( v7 == 7 )
          sub_6867D50(a2);
        return 2LL;
      }
      if ( v11 == a3[3] )
      {
        fprintf(
          (FILE *)((char *)&_sF + 304),
          "libunwind: %s - %s\n",
          "unwind_phase2",
          "during phase1 personality function said it would stop here, but now in phase2 it did not stop here");
        fflush((FILE *)((char *)&_sF + 304));
        abort();
      }
    }
    v5 = sub_6867CEC(a2);
    if ( !v5 )
      return 5LL;
  }
  return 2LL;
}


================================================================================
Function: sub_6867AD8 (0x6867AD8)
================================================================================

__int64 __fastcall sub_6867AD8(__int64 a1, _OWORD *a2)
{
  __int128 v4; // q0
  __int128 v5; // q2
  __int128 v6; // q3
  __int128 v7; // q0
  __int128 v8; // q2
  __int128 v9; // q3
  __int128 v10; // q0
  __int128 v11; // q2
  __int128 v12; // q3
  __int128 v13; // q1
  __int128 v14; // q2
  __int128 v15; // q3

  *(_QWORD *)a1 = off_6C5F140;
  *(_QWORD *)(a1 + 8) = &unk_79D8EF1;
  memcpy((void *)(a1 + 16), a2, 0x110uLL);
  v4 = a2[20];
  v5 = a2[17];
  v6 = a2[18];
  *(_OWORD *)(a1 + 320) = a2[19];
  *(_OWORD *)(a1 + 336) = v4;
  *(_OWORD *)(a1 + 288) = v5;
  *(_OWORD *)(a1 + 304) = v6;
  v7 = a2[24];
  v8 = a2[21];
  v9 = a2[22];
  *(_OWORD *)(a1 + 384) = a2[23];
  *(_OWORD *)(a1 + 400) = v7;
  *(_OWORD *)(a1 + 352) = v8;
  *(_OWORD *)(a1 + 368) = v9;
  v10 = a2[28];
  v11 = a2[25];
  v12 = a2[26];
  *(_OWORD *)(a1 + 448) = a2[27];
  *(_OWORD *)(a1 + 464) = v10;
  *(_OWORD *)(a1 + 416) = v11;
  *(_OWORD *)(a1 + 432) = v12;
  v13 = a2[32];
  v15 = a2[29];
  v14 = a2[30];
  *(_OWORD *)(a1 + 512) = a2[31];
  *(_OWORD *)(a1 + 528) = v13;
  *(_OWORD *)(a1 + 603) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 480) = v15;
  *(_OWORD *)(a1 + 496) = v14;
  sub_68685E4(a1, 0LL);
  return 0LL;
}


================================================================================
Function: sub_6867B84 (0x6867B84)
================================================================================

__int64 __fastcall sub_6867B84(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 v6; // x8
  __int64 result; // x0

  if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1) & 1) == 0 )
    return 4294960754LL;
  v6 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 24LL))(a1, a2);
  result = 0LL;
  *a3 = v6;
  return result;
}


================================================================================
Function: sub_6867CEC (0x6867CEC)
================================================================================

__int64 __fastcall sub_6867CEC(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 64LL))(a1);
}


================================================================================
Function: sub_6867D10 (0x6867D10)
================================================================================

__int64 __fastcall sub_6867D10(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 72LL))(a1);
  if ( *(_QWORD *)(a2 + 8) )
    return 0LL;
  else
    return 4294960747LL;
}


================================================================================
Function: sub_6867D50 (0x6867D50)
================================================================================

__int64 __fastcall sub_6867D50(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 80LL))(a1);
  return 4294960756LL;
}


================================================================================
Function: sub_6867D78 (0x6867D78)
================================================================================

const char *__fastcall sub_6867D78(__int64 a1, unsigned int *a2, _QWORD *a3, __int64 a4, char a5)
{
  __int64 v9; // x23
  unsigned int *v10; // x24
  __int64 v11; // x8
  char *v12; // x1
  const char *result; // x0
  char *v14; // x23
  __int64 v15; // x3
  __int64 v16; // x24
  __int64 v17; // x0
  int v18; // w8
  __int64 v19; // x25
  __int64 v20; // x0
  unsigned int *v21; // x27
  int v22; // w8
  unsigned int *v23; // x26
  __int64 v24; // x3
  unsigned int *v25; // [xsp+18h] [xbp+18h] BYREF

  v10 = a2 + 1;
  v9 = *a2;
  if ( (_DWORD)v9 != -1 )
  {
    if ( *a2 )
      goto LABEL_3;
    return "FDE has zero length";
  }
  v9 = *(_QWORD *)(a2 + 1);
  v10 = a2 + 3;
  if ( !v9 )
    return "FDE has zero length";
LABEL_3:
  v11 = *v10;
  if ( !(_DWORD)v11 )
    return "FDE is really a CIE";
  v12 = (char *)v10 - v11;
  if ( (a5 & 1) != 0 )
  {
    if ( *(char **)a4 != v12 )
      return "CIE start does not match";
  }
  else
  {
    result = (const char *)sub_6867F08(a1, v12, a4);
    if ( result )
      return result;
  }
  v14 = (char *)v10 + v9;
  v15 = *(unsigned __int8 *)(a4 + 24);
  v25 = v10 + 1;
  v16 = sub_6869B8C(a1, &v25, v14, v15, 0LL);
  v17 = sub_6869B8C(a1, &v25, v14, *(_BYTE *)(a4 + 24) & 0xF, 0LL);
  v18 = *(unsigned __int8 *)(a4 + 49);
  v19 = v17;
  a3[5] = 0LL;
  if ( v18 )
  {
    v20 = sub_6869EA0(&v25, v14);
    v21 = v25;
    v22 = *(unsigned __int8 *)(a4 + 25);
    v23 = (unsigned int *)((char *)v25 + v20);
    if ( v22 != 255 )
    {
      if ( sub_6869B8C(a1, &v25, v14, v22 & 0xF, 0LL) )
      {
        v24 = *(unsigned __int8 *)(a4 + 25);
        v25 = v21;
        a3[5] = sub_6869B8C(a1, &v25, v14, v24, 0LL);
      }
    }
  }
  else
  {
    v23 = v25;
  }
  result = 0LL;
  a3[2] = v23;
  a3[3] = v16;
  *a3 = a2;
  a3[1] = v14 - (char *)a2;
  a3[4] = v19 + v16;
  return result;
}


================================================================================
Function: sub_6867F08 (0x6867F08)
================================================================================

const char *__fastcall sub_6867F08(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  char v4; // w20
  _BYTE *v6; // x8
  __int64 v7; // x9
  unsigned __int8 *v8; // x22
  const char *result; // x0
  __int64 v10; // x9
  int v11; // w24
  _BYTE *v12; // x23
  unsigned __int8 *v13; // x8
  int v15; // w0
  unsigned __int8 *v16; // x8
  int v17; // w11
  int v18; // w9
  unsigned __int8 *v19; // x10
  unsigned int v20; // w12
  unsigned int v21; // t1
  unsigned __int64 v22; // x13
  unsigned int v23; // w13
  __int64 v24; // x11
  char v29; // t1
  unsigned __int8 v30; // w3
  char v31; // w8
  unsigned __int8 v32; // t1
  char v33; // t1
  unsigned __int8 *v34; // x9
  unsigned __int8 *v35; // [xsp+18h] [xbp+18h] BYREF

  *(_BYTE *)(a3 + 51) = 0;
  *(_QWORD *)(a3 + 32) = 0LL;
  *(_QWORD *)(a3 + 40) = 0LL;
  *(_WORD *)(a3 + 48) = 0;
  v4 = (char)a2;
  *(_DWORD *)(a3 + 24) = 65280;
  *(_QWORD *)a3 = a2;
  v35 = a2;
  v6 = a2 + 4;
  v7 = *(unsigned int *)a2;
  v35 = a2 + 4;
  if ( (_DWORD)v7 != -1 )
  {
    v8 = &v6[v7];
    if ( v7 )
      goto LABEL_3;
    return 0LL;
  }
  v10 = *(_QWORD *)(a2 + 4);
  v6 = a2 + 12;
  v8 = &a2[v10 + 12];
  v35 = a2 + 12;
  if ( !v10 )
    return 0LL;
LABEL_3:
  if ( *(_DWORD *)v6 )
    return "CIE ID is not zero";
  v35 = v6 + 4;
  v11 = (unsigned __int8)v6[4];
  if ( (v11 & 0xFFFFFFFD) != 1 )
    return "CIE version is not 1 or 3";
  v12 = v6 + 5;
  v13 = v6 + 5;
  do
    v35 = v13;
  while ( *v13++ );
  v35 = v13;
  v15 = sub_6869EA0(&v35, v8);
  v16 = v35;
  v17 = 0;
  v18 = 0;
  *(_DWORD *)(a3 + 40) = v15;
  v19 = v16;
  do
  {
    if ( v19 == v8 )
    {
      fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    }
    v21 = *v19++;
    v20 = v21;
    ++v16;
    v22 = (unsigned __int64)(v21 & 0x7F) << v17;
    v17 += 7;
    v18 |= v22;
  }
  while ( (v21 & 0x80) != 0 );
  v23 = v17 - 7;
  v24 = -1LL << v17;
  v35 = v16;
  if ( ((v23 < 0x39) & (v20 >> 6)) == 0 )
    LODWORD(v24) = 0;
  *(_DWORD *)(a3 + 44) = v18 | v24;
  if ( v11 == 1 )
  {
    v35 = v16 + 1;
    *(_BYTE *)(a3 + 50) = *v19;
    if ( *v12 != 122 )
      goto LABEL_30;
LABEL_20:
    sub_6869EA0(&v35, v8);
    while ( 1 )
    {
      switch ( *v12 )
      {
        case 'B':
          __asm { BTI             j; jumptable 00000000068680CC case 66 }
          *(_BYTE *)(a3 + 51) = 1;
          goto LABEL_22;
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'M':
        case 'N':
        case 'O':
        case 'Q':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '^':
        case '_':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
          goto LABEL_22;
        case 'L':
          __asm { BTI             j; jumptable 00000000068680CC case 76 }
          ++v12;
          v29 = *v35++;
          *(_BYTE *)(a3 + 25) = v29;
          continue;
        case 'P':
          __asm { BTI             j; jumptable 00000000068680CC case 80 }
          v32 = *v35;
          v30 = *v35++;
          v31 = (char)v35;
          *(_BYTE *)(a3 + 26) = v32;
          *(_BYTE *)(a3 + 27) = v31 - v4;
          *(_QWORD *)(a3 + 32) = sub_6869B8C(a1, &v35, v8, v30, 0LL);
          ++v12;
          continue;
        case 'R':
          __asm { BTI             j; jumptable 00000000068680CC case 82 }
          ++v12;
          v33 = *v35++;
          *(_BYTE *)(a3 + 24) = v33;
          continue;
        case 'S':
          __asm { BTI             j; jumptable 00000000068680CC case 83 }
          *(_BYTE *)(a3 + 48) = 1;
          ++v12;
          continue;
        case 'z':
          __asm { BTI             j; jumptable 00000000068680CC case 122 }
          *(_BYTE *)(a3 + 49) = 1;
          ++v12;
          continue;
        default:
          if ( !*v12 )
            goto LABEL_30;
LABEL_22:
          __asm { BTI             j; jumptable 00000000068680CC cases 67-75,77-79,81,84-121 }
          ++v12;
          break;
      }
    }
  }
  *(_BYTE *)(a3 + 50) = sub_6869EA0(&v35, v8);
  if ( *v12 == 122 )
    goto LABEL_20;
LABEL_30:
  result = 0LL;
  v34 = v35;
  *(_QWORD *)(a3 + 8) = &v8[-*(_QWORD *)a3];
  *(_QWORD *)(a3 + 16) = v34;
  return result;
}


================================================================================
Function: sub_68685E4 (0x68685E4)
================================================================================

__int64 __fastcall sub_68685E4(__int64 *a1, char a2)
{
  __int64 v2; // x8
  __int64 result; // x0
  __int64 v6; // x8
  unsigned __int64 v7; // x20
  __int64 *i; // x8
  __int64 v9; // x21
  __int64 v10; // x8
  __int64 v11; // x10
  __int64 v12; // x11
  __int128 v13; // q0
  __int64 v14; // x10
  _QWORD v15[7]; // [xsp+0h] [xbp-6B0h] BYREF
  __int64 v16; // [xsp+38h] [xbp-678h] BYREF
  __int64 v17; // [xsp+40h] [xbp-670h]
  __int128 v18; // [xsp+50h] [xbp-660h]
  __int64 v19; // [xsp+60h] [xbp-650h]
  _BYTE v20[16]; // [xsp+68h] [xbp-648h] BYREF
  __int64 v21; // [xsp+78h] [xbp-638h]
  _QWORD data[2]; // [xsp+98h] [xbp-618h] BYREF
  unsigned __int64 v23; // [xsp+A8h] [xbp-608h]

  v2 = *a1;
  *((_BYTE *)a1 + 618) = 0;
  result = (*(__int64 (__fastcall **)(__int64 *, __int64))(v2 + 24))(a1, 0xFFFFFFFFLL);
  if ( !result )
    goto LABEL_19;
  v6 = a1[1];
  v7 = result - (a2 & 1);
  v23 = v7;
  data[0] = v6;
  data[1] = v20;
  if ( !dl_iterate_phdr((int (*)(struct dl_phdr_info *, size_t, void *))sub_686AD28, data)
    || !v21
    || (result = sub_686AA34(a1, v7, v20, 0LL), (result & 1) == 0) )
  {
    pthread_rwlock_rdlock(&stru_79D8EF4);
    for ( i = off_6CAFA40[0]; ; i += 4 )
    {
      if ( i >= off_6CAFA48 )
      {
        pthread_rwlock_unlock(&stru_79D8EF4);
        goto LABEL_15;
      }
      if ( i[1] <= v7 && i[2] > v7 )
        break;
    }
    v9 = i[3];
    pthread_rwlock_unlock(&stru_79D8EF4);
    if ( v9 )
    {
      if ( !sub_6867D78(a1[1], v9, &v16, v15, 0LL) )
      {
        memset(data, 0, 0x618uLL);
        result = sub_6868D74(a1[1], (int)&v16, (int)v15, v7, 4, data);
        if ( (result & 1) != 0 )
        {
          v10 = v19;
          v11 = v15[4];
          a1[76] = 0LL;
          v12 = (unsigned int)v23;
          a1[70] = v10;
          a1[71] = v11;
          v13 = v18;
          a1[72] = v12;
          *((_DWORD *)a1 + 148) = 50331648;
          v14 = v16;
          LODWORD(v10) = v17;
          *((_OWORD *)a1 + 34) = v13;
          a1[73] = 0LL;
          a1[75] = v14;
          *((_DWORD *)a1 + 149) = v10;
          return result;
        }
      }
    }
LABEL_15:
    result = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 24))(a1, 0xFFFFFFFFLL);
    if ( *(_DWORD *)result == -763358872 && *(_DWORD *)(result + 4) == -738197503 )
    {
      a1[76] = 0LL;
      *((_BYTE *)a1 + 618) = 1;
      *((_OWORD *)a1 + 36) = 0u;
      *((_OWORD *)a1 + 37) = 0u;
      *((_OWORD *)a1 + 34) = 0u;
      *((_OWORD *)a1 + 35) = 0u;
      return result;
    }
LABEL_19:
    *((_BYTE *)a1 + 616) = 1;
  }
  return result;
}


================================================================================
Function: sub_6868D74 (0x6868D74)
================================================================================

__int64 __fastcall sub_6868D74(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, int a5, _BYTE *dest)
{
  unsigned __int8 **v6; // x28
  __int64 v7; // x11
  __int64 v11; // x9
  __int64 v12; // x10
  __int64 v13; // x12
  __int64 v14; // x11
  __int64 v15; // x13
  unsigned __int8 *v16; // x9
  unsigned __int8 *v17; // x24
  unsigned __int64 v18; // x21
  unsigned __int64 v20; // x25
  unsigned __int8 *v21; // x8
  int v22; // w10
  int v26; // w8
  unsigned __int8 *v27; // x9
  unsigned __int64 v28; // x26
  __int64 v29; // x0
  char *v30; // x8
  __int64 v31; // x9
  __int64 v32; // x9
  unsigned __int64 v33; // x0
  __int64 v34; // x8
  unsigned __int64 v35; // x0
  char *v36; // x9
  _BYTE *v37; // x9
  int v38; // t1
  unsigned __int64 v39; // x0
  char *v40; // x9
  _BYTE *v41; // x9
  int v42; // t1
  unsigned __int64 v43; // x26
  unsigned __int64 v44; // x0
  char *v45; // x8
  _QWORD *v46; // x26
  unsigned __int64 v47; // x26
  int v48; // w0
  unsigned __int64 v49; // x0
  unsigned __int64 v50; // x0
  char *v51; // x8
  int v52; // w9
  unsigned __int64 v53; // x0
  unsigned __int8 *v54; // x9
  int v55; // w10
  __int64 v56; // x8
  unsigned __int8 *v57; // x12
  unsigned int v58; // w11
  unsigned int v59; // t1
  unsigned __int64 v60; // x13
  char *v61; // x12
  _BOOL4 v62; // w14
  __int64 v63; // x10
  int v64; // w14
  __int64 v65; // x11
  __int64 v66; // x10
  __int64 v67; // x8
  int v68; // w9
  unsigned __int64 v69; // x0
  unsigned __int8 *v70; // x10
  int v71; // w9
  int v72; // w8
  unsigned __int8 *v73; // x12
  unsigned int v74; // w11
  unsigned int v75; // t1
  unsigned __int64 v76; // x13
  unsigned int v77; // w10
  __int64 v78; // x9
  int v79; // w10
  int v80; // w10
  int v81; // w9
  unsigned __int8 *v82; // x11
  unsigned int v83; // w12
  unsigned int v84; // t1
  unsigned __int64 v85; // x13
  unsigned int v86; // w11
  __int64 v87; // x10
  unsigned __int64 v88; // x0
  unsigned __int64 v89; // x26
  __int64 v90; // x0
  __int64 v91; // x9
  int v92; // w10
  unsigned __int64 v93; // x0
  unsigned __int8 *v94; // x9
  int v95; // w10
  __int64 v96; // x8
  unsigned __int8 *v97; // x12
  unsigned int v98; // w11
  unsigned int v99; // t1
  unsigned __int64 v100; // x13
  _BOOL4 v101; // w14
  __int64 v102; // x10
  int v103; // w14
  __int64 v104; // x11
  unsigned __int64 v105; // x0
  unsigned __int8 *v106; // x10
  __int64 v107; // x0
  __int64 v108; // x26
  int v109; // w8
  __int64 v110; // x0
  char *v111; // x8
  __int64 v112; // x9
  _BYTE *v113; // x8
  int v114; // t1
  __int64 v115; // x8
  char *v116; // x9
  unsigned __int64 v117; // x0
  unsigned __int64 v118; // x26
  __int64 v119; // x0
  __int64 v120; // x9
  __int64 **v122; // x8
  const char *v123; // x0
  size_t v124; // x1
  __int64 **v125; // x8
  FILE *v126; // x3
  _BYTE v127[12]; // [xsp+0h] [xbp-690h] BYREF
  int v128; // [xsp+Ch] [xbp-684h]
  __int64 *v129; // [xsp+10h] [xbp-680h]
  _OWORD *v130; // [xsp+18h] [xbp-678h]
  __int64 v131; // [xsp+20h] [xbp-670h]
  unsigned __int8 **v132; // [xsp+28h] [xbp-668h]
  _BYTE *v133; // [xsp+30h] [xbp-660h]
  _BYTE v134[568]; // [xsp+38h] [xbp-658h] BYREF
  __int64 v135; // [xsp+270h] [xbp-420h] BYREF
  unsigned __int8 *v136; // [xsp+650h] [xbp-40h] BYREF
  _QWORD v137[6]; // [xsp+658h] [xbp-38h] BYREF
  __int64 v138; // [xsp+688h] [xbp-8h] BYREF

  v6 = (unsigned __int8 **)v137;
  v7 = *(_QWORD *)(a3 + 16);
  v11 = *(_QWORD *)(a3 + 8) + *(_QWORD *)a3;
  v133 = 0LL;
  v12 = *a2;
  v13 = a2[1];
  v137[0] = v7;
  v137[1] = v11;
  v14 = a2[2];
  v15 = a2[3];
  v137[2] = -1LL;
  v137[3] = v14;
  v131 = a1;
  v132 = (unsigned __int8 **)&v138;
  v137[4] = v13 + v12;
  v137[5] = a4 - v15;
  v129 = &v135;
  v130 = dest + 568;
  while ( 1 )
  {
    v17 = v6[1];
    v18 = (unsigned __int64)v6[2];
    v136 = *v6;
    v16 = v136;
    _ZF = v136 >= v17 || v18 == 0;
    if ( !_ZF )
      break;
LABEL_2:
    v6 += 3;
    if ( v6 == v132 )
      return 1LL;
  }
  v20 = 0LL;
  while ( 2 )
  {
    v21 = v16 + 1;
    v22 = *v16;
    v136 = v16 + 1;
    switch ( v22 )
    {
      case 0:
        goto LABEL_113;
      case 1:
        __asm { BTI             j; jumptable 0000000006868E4C case 1 }
        v20 = sub_6869B8C(v131, &v136, v17, *(unsigned __int8 *)(a3 + 24), 0LL);
        goto LABEL_113;
      case 2:
        __asm { BTI             j; jumptable 0000000006868E4C case 2 }
        v26 = v16[1];
        v27 = v16 + 2;
        goto LABEL_13;
      case 3:
        __asm { BTI             j; jumptable 0000000006868E4C case 3 }
        v26 = *(unsigned __int16 *)(v16 + 1);
        v27 = v16 + 3;
        goto LABEL_13;
      case 4:
        __asm { BTI             j; jumptable 0000000006868E4C case 4 }
        v26 = *(_DWORD *)(v16 + 1);
        v27 = v16 + 5;
LABEL_13:
        v20 += (unsigned int)(*(_DWORD *)(a3 + 40) * v26);
        v136 = v27;
        goto LABEL_113;
      case 5:
        __asm { BTI             j; jumptable 0000000006868E4C case 5 }
        v28 = sub_6869EA0(&v136, v17);
        v29 = sub_6869EA0(&v136, v17);
        if ( v28 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_offset_extended DWARF unwind, reg too big\n";
          v124 = 70LL;
          goto LABEL_134;
        }
        v30 = &dest[16 * v28];
        v31 = *(int *)(a3 + 44);
        if ( !v30[28] )
        {
          *(_OWORD *)&v134[16 * v28 + 24] = *(_OWORD *)&dest[16 * v28 + 24];
          v30[28] = 1;
        }
        v32 = v29 * v31;
LABEL_107:
        v92 = 2;
LABEL_108:
        *((_DWORD *)v30 + 6) = v92;
        *((_QWORD *)v30 + 4) = v32;
        goto LABEL_113;
      case 6:
        __asm { BTI             j; jumptable 0000000006868E4C case 6 }
        v33 = sub_6869EA0(&v136, v17);
        if ( v33 < 0x60 )
        {
          if ( dest[16 * v33 + 28] )
          {
            v34 = 16 * v33;
LABEL_112:
            *(_OWORD *)&dest[v34 + 24] = *(_OWORD *)&v134[v34 + 24];
          }
          goto LABEL_113;
        }
        v125 = off_6C79000;
        v123 = "libunwind: malformed DW_CFA_restore_extended DWARF unwind, reg too big\n";
        goto LABEL_124;
      case 7:
        __asm { BTI             j; jumptable 0000000006868E4C case 7 }
        v35 = sub_6869EA0(&v136, v17);
        if ( v35 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_undefined DWARF unwind, reg too big\n";
LABEL_133:
          v124 = 64LL;
          goto LABEL_134;
        }
        v36 = &dest[16 * v35];
        v38 = (unsigned __int8)v36[28];
        v37 = v36 + 28;
        if ( !v38 )
        {
          *(_OWORD *)&v134[16 * v35 + 24] = *(_OWORD *)&dest[16 * v35 + 24];
          *v37 = 1;
        }
        *(_DWORD *)&dest[16 * v35 + 24] = 1;
        goto LABEL_113;
      case 8:
        __asm { BTI             j; jumptable 0000000006868E4C case 8 }
        v39 = sub_6869EA0(&v136, v17);
        if ( v39 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_same_value DWARF unwind, reg too big\n";
          v124 = 65LL;
          goto LABEL_134;
        }
        v40 = &dest[16 * v39];
        v42 = (unsigned __int8)v40[28];
        v41 = v40 + 28;
        if ( !v42 )
        {
          *(_OWORD *)&v134[16 * v39 + 24] = *(_OWORD *)&dest[16 * v39 + 24];
          *v41 = 1;
        }
        *(_DWORD *)&dest[16 * v39 + 24] = 0;
        goto LABEL_113;
      case 9:
        __asm { BTI             j; jumptable 0000000006868E4C case 9 }
        v43 = sub_6869EA0(&v136, v17);
        v44 = sub_6869EA0(&v136, v17);
        if ( v43 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_register DWARF unwind, reg too big\n";
          v124 = 63LL;
          goto LABEL_134;
        }
        if ( v44 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_register DWARF unwind, reg2 too big\n";
          goto LABEL_133;
        }
        v45 = &dest[16 * v43];
        if ( !v45[28] )
        {
          *(_OWORD *)&v134[16 * v43 + 24] = *(_OWORD *)&dest[16 * v43 + 24];
          v45[28] = 1;
        }
        *((_QWORD *)v45 + 4) = v44;
        *((_DWORD *)v45 + 6) = 4;
        goto LABEL_113;
      case 10:
        __asm { BTI             j; jumptable 0000000006868E4C case 10 }
        *(_QWORD *)&v127[-1568] = v133;
        memcpy(&v127[-1560], dest, 0x618uLL);
        v133 = &v127[-1568];
        goto LABEL_113;
      case 11:
        __asm { BTI             j; jumptable 0000000006868E4C case 11 }
        if ( !v133 )
          return 0LL;
        v46 = v133;
        memcpy(dest, v133 + 8, 0x618uLL);
        v133 = (_BYTE *)*v46;
        goto LABEL_113;
      case 12:
        __asm { BTI             j; jumptable 0000000006868E4C case 12 }
        v47 = sub_6869EA0(&v136, v17);
        v48 = sub_6869EA0(&v136, v17);
        if ( v47 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_def_cfa DWARF unwind, reg too big\n";
          v124 = 62LL;
          goto LABEL_134;
        }
        *(_DWORD *)dest = v47;
        *((_DWORD *)dest + 1) = v48;
        goto LABEL_113;
      case 13:
        __asm { BTI             j; jumptable 0000000006868E4C case 13 }
        v49 = sub_6869EA0(&v136, v17);
        if ( v49 >= 0x60 )
        {
          v125 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_def_cfa_register DWARF unwind, reg too big\n";
LABEL_124:
          v126 = (FILE *)(v125[155] + 38);
          v124 = 71LL;
          goto LABEL_135;
        }
        *(_DWORD *)dest = v49;
        goto LABEL_113;
      case 14:
        __asm { BTI             j; jumptable 0000000006868E4C case 14 }
        *((_DWORD *)dest + 1) = sub_6869EA0(&v136, v17);
        goto LABEL_113;
      case 15:
        __asm { BTI             j; jumptable 0000000006868E4C case 15 }
        *(_DWORD *)dest = 0;
        *((_QWORD *)dest + 1) = v21;
        goto LABEL_91;
      case 16:
        __asm { BTI             j; jumptable 0000000006868E4C case 16 }
        v50 = sub_6869EA0(&v136, v17);
        if ( v50 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_expression DWARF unwind, reg too big\n";
          v124 = 65LL;
          goto LABEL_134;
        }
        v51 = &dest[16 * v50];
        if ( !v51[28] )
        {
          *(_OWORD *)&v134[16 * v50 + 24] = *(_OWORD *)&dest[16 * v50 + 24];
          v51[28] = 1;
        }
        v52 = 5;
LABEL_90:
        v106 = v136;
        *((_DWORD *)v51 + 6) = v52;
        *((_QWORD *)v51 + 4) = v106;
LABEL_91:
        v107 = sub_6869EA0(&v136, v17);
        v136 += v107;
        goto LABEL_113;
      case 17:
        __asm { BTI             j; jumptable 0000000006868E4C case 17 }
        v53 = sub_6869EA0(&v136, v17);
        if ( v53 < 0x60 )
        {
          v54 = v136;
          v55 = 0;
          v56 = 0LL;
          v57 = v136;
          do
          {
            if ( v57 == v17 )
            {
              fprintf(
                (FILE *)((char *)&_sF + 304),
                "libunwind: %s - %s\n",
                "getSLEB128",
                "truncated sleb128 expression");
              fflush((FILE *)((char *)&_sF + 304));
              abort();
            }
            v59 = *v57++;
            v58 = v59;
            ++v54;
            v60 = (unsigned __int64)(v59 & 0x7F) << v55;
            v55 += 7;
            v56 |= v60;
          }
          while ( (v59 & 0x80) != 0 );
          v61 = &dest[16 * v53];
          v62 = (unsigned int)(v55 - 7) < 0x39;
          v63 = -1LL << v55;
          _ZF = (v62 & (v58 >> 6)) == 0;
          v64 = (unsigned __int8)v61[28];
          if ( _ZF )
            v65 = 0LL;
          else
            v65 = v63;
          v66 = *(int *)(a3 + 44);
          v136 = v54;
          if ( !v64 )
          {
            *(_OWORD *)&v134[16 * v53 + 24] = *(_OWORD *)&dest[16 * v53 + 24];
            v61[28] = 1;
          }
          v67 = v56 | v65;
          v68 = 2;
LABEL_85:
          *((_DWORD *)v61 + 6) = v68;
          *((_QWORD *)v61 + 4) = v67 * v66;
LABEL_113:
          __asm { BTI             j; jumptable 0000000006868E4C case 0 }
          v16 = v136;
          if ( v136 >= v17 || v20 >= v18 )
            goto LABEL_2;
          continue;
        }
        v122 = off_6C79000;
        v123 = "libunwind: malformed DW_CFA_offset_extended_sf DWARF unwind, reg too big\n";
        v124 = 73LL;
LABEL_134:
        v126 = (FILE *)(v122[155] + 38);
LABEL_135:
        fwrite(v123, v124, 1uLL, v126);
        return 0LL;
      case 18:
        __asm { BTI             j; jumptable 0000000006868E4C case 18 }
        v69 = sub_6869EA0(&v136, v17);
        v70 = v136;
        v71 = 0;
        v72 = 0;
        v73 = v136;
        do
        {
          if ( v73 == v17 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v75 = *v73++;
          v74 = v75;
          ++v70;
          v76 = (unsigned __int64)(v75 & 0x7F) << v71;
          v71 += 7;
          v72 |= v76;
        }
        while ( (v75 & 0x80) != 0 );
        v136 = v70;
        if ( v69 > 0x5F )
        {
          v123 = "libunwind: malformed DW_CFA_def_cfa_sf DWARF unwind, reg too big\n";
          v124 = 65LL;
          v126 = (FILE *)((char *)&_sF + 304);
          goto LABEL_135;
        }
        v77 = v71 - 7;
        v78 = -1LL << v71;
        _ZF = ((v77 < 0x39) & (v74 >> 6)) == 0;
        v79 = *(_DWORD *)(a3 + 44);
        if ( _ZF )
          LODWORD(v78) = 0;
        *(_DWORD *)dest = v69;
        *((_DWORD *)dest + 1) = v79 * (v72 | v78);
        goto LABEL_113;
      case 19:
        __asm { BTI             j; jumptable 0000000006868E4C case 19 }
        v80 = 0;
        v81 = 0;
        v82 = v21;
        do
        {
          if ( v82 == v17 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v84 = *v82++;
          v83 = v84;
          ++v21;
          v85 = (unsigned __int64)(v84 & 0x7F) << v80;
          v80 += 7;
          v81 |= v85;
        }
        while ( (v84 & 0x80) != 0 );
        v86 = v80 - 7;
        v87 = -1LL << v80;
        v136 = v21;
        if ( ((v86 < 0x39) & (v83 >> 6)) == 0 )
          LODWORD(v87) = 0;
        *((_DWORD *)dest + 1) = *(_DWORD *)(a3 + 44) * (v81 | v87);
        goto LABEL_113;
      case 20:
        __asm { BTI             j; jumptable 0000000006868E4C case 20 }
        v88 = sub_6869EA0(&v136, v17);
        v89 = v88;
        if ( v88 >= 0x60 )
        {
          fprintf(
            (FILE *)((char *)&_sF + 304),
            "libunwind: malformed DW_CFA_val_offset DWARF unwind, reg (%lu) out of range\n\n",
            v88);
          return 0LL;
        }
        v90 = sub_6869EA0(&v136, v17);
        v30 = &dest[16 * v89];
        v91 = *(int *)(a3 + 44);
        if ( !v30[28] )
        {
          *(_OWORD *)&v134[16 * v89 + 24] = *(_OWORD *)&dest[16 * v89 + 24];
          v30[28] = 1;
        }
        v32 = v90 * v91;
        v92 = 3;
        goto LABEL_108;
      case 21:
        __asm { BTI             j; jumptable 0000000006868E4C case 21 }
        v93 = sub_6869EA0(&v136, v17);
        if ( v93 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_val_offset_sf DWARF unwind, reg too big\n";
          v124 = 68LL;
          goto LABEL_134;
        }
        v94 = v136;
        v95 = 0;
        v96 = 0LL;
        v97 = v136;
        do
        {
          if ( v97 == v17 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v99 = *v97++;
          v98 = v99;
          ++v94;
          v100 = (unsigned __int64)(v99 & 0x7F) << v95;
          v95 += 7;
          v96 |= v100;
        }
        while ( (v99 & 0x80) != 0 );
        v61 = &dest[16 * v93];
        v101 = (unsigned int)(v95 - 7) < 0x39;
        v102 = -1LL << v95;
        _ZF = (v101 & (v98 >> 6)) == 0;
        v103 = (unsigned __int8)v61[28];
        if ( _ZF )
          v104 = 0LL;
        else
          v104 = v102;
        v66 = *(int *)(a3 + 44);
        v136 = v94;
        if ( !v103 )
        {
          *(_OWORD *)&v134[16 * v93 + 24] = *(_OWORD *)&dest[16 * v93 + 24];
          v61[28] = 1;
        }
        v67 = v96 | v104;
        v68 = 3;
        goto LABEL_85;
      case 22:
        __asm { BTI             j; jumptable 0000000006868E4C case 22 }
        v105 = sub_6869EA0(&v136, v17);
        if ( v105 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_val_expression DWARF unwind, reg too big\n";
          v124 = 69LL;
          goto LABEL_134;
        }
        v51 = &dest[16 * v105];
        if ( !v51[28] )
        {
          *(_OWORD *)&v134[16 * v105 + 24] = *(_OWORD *)&dest[16 * v105 + 24];
          v51[28] = 1;
        }
        v52 = 6;
        goto LABEL_90;
      case 45:
        __asm { BTI             j; jumptable 0000000006868E4C case 45 }
        if ( a5 == 4 )
        {
          if ( !dest[572] )
          {
            *(_OWORD *)v129 = *v130;
            dest[572] = 1;
          }
          *((_QWORD *)dest + 72) ^= 1uLL;
        }
        goto LABEL_113;
      case 46:
        __asm { BTI             j; jumptable 0000000006868E4C case 46 }
        *((_DWORD *)dest + 4) = sub_6869EA0(&v136, v17);
        goto LABEL_113;
      case 47:
        __asm { BTI             j; jumptable 0000000006868E4C case 47 }
        v117 = sub_6869EA0(&v136, v17);
        if ( v117 >= 0x60 )
        {
          v122 = off_6C79000;
          v123 = "libunwind: malformed DW_CFA_GNU_negative_offset_extended DWARF unwind, reg too big\n";
          v124 = 83LL;
          goto LABEL_134;
        }
        v118 = v117;
        v119 = sub_6869EA0(&v136, v17);
        v30 = &dest[16 * v118];
        v120 = *(int *)(a3 + 44);
        if ( !v30[28] )
        {
          *(_OWORD *)&v134[16 * v118 + 24] = *(_OWORD *)&dest[16 * v118 + 24];
          v30[28] = 1;
        }
        v32 = -(v119 * v120);
        goto LABEL_107;
      default:
        __asm { BTI             j; jumptable 0000000006868E4C default case, cases 23-44 }
        v108 = v22 & 0x3F;
        v109 = v22 & 0xC0;
        if ( v109 == 64 )
        {
          v20 += (unsigned int)(*(_DWORD *)(a3 + 40) * v108);
          goto LABEL_113;
        }
        if ( v109 != 192 )
        {
          if ( v109 != 128 )
            return 0LL;
          v128 = a5;
          v110 = sub_6869EA0(&v136, v17);
          v111 = &dest[16 * (unsigned int)v108];
          v112 = *(int *)(a3 + 44);
          v114 = (unsigned __int8)v111[28];
          v113 = v111 + 28;
          if ( !v114 )
          {
            *(_OWORD *)&v134[16 * (unsigned int)v108 + 24] = *(_OWORD *)&dest[16 * (unsigned int)v108 + 24];
            *v113 = 1;
          }
          v115 = v110 * v112;
          v116 = &dest[16 * (unsigned int)v108];
          a5 = v128;
          *((_DWORD *)v116 + 6) = 2;
          *((_QWORD *)v116 + 4) = v115;
          goto LABEL_113;
        }
        if ( !dest[16 * v108 + 28] )
          goto LABEL_113;
        v34 = 16 * v108;
        goto LABEL_112;
    }
  }
}


================================================================================
Function: sub_6869B8C (0x6869B8C)
================================================================================

unsigned __int64 __fastcall sub_6869B8C(
        __int64 a1,
        unsigned __int8 **a2,
        unsigned __int8 *a3,
        unsigned __int8 a4,
        __int64 a5)
{
  unsigned __int8 *v5; // x21
  unsigned __int64 result; // x0
  int v13; // w10
  __int64 v14; // x8
  unsigned __int8 *v15; // x9
  unsigned __int8 *v16; // x11
  unsigned int v17; // w12
  unsigned int v18; // t1
  unsigned __int64 v19; // x13
  unsigned int v20; // w11
  __int64 v21; // x10

  v5 = *a2;
  switch ( a4 & 0xF )
  {
    case 0:
    case 4:
    case 0xC:
      __asm { BTI             j; jumptable 0000000006869BCC cases 0,4,12 }
      result = *(_QWORD *)v5;
      *a2 = v5 + 8;
      break;
    case 1:
      __asm { BTI             j; jumptable 0000000006869BCC case 1 }
      result = sub_6869EA0(a2, a3);
      break;
    case 2:
      __asm { BTI             j; jumptable 0000000006869BCC case 2 }
      result = *(unsigned __int16 *)v5;
      *a2 = v5 + 2;
      break;
    case 3:
      __asm { BTI             j; jumptable 0000000006869BCC case 3 }
      result = *(unsigned int *)v5;
      *a2 = v5 + 4;
      break;
    case 9:
      __asm { BTI             j; jumptable 0000000006869BCC case 9 }
      v13 = 0;
      v14 = 0LL;
      v15 = *a2;
      v16 = *a2;
      do
      {
        if ( v16 == a3 )
        {
          fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
          fflush((FILE *)((char *)&_sF + 304));
          abort();
        }
        v18 = *v16++;
        v17 = v18;
        ++v15;
        v19 = (unsigned __int64)(v18 & 0x7F) << v13;
        v13 += 7;
        v14 |= v19;
      }
      while ( (v18 & 0x80) != 0 );
      v20 = v13 - 7;
      v21 = -1LL << v13;
      *a2 = v15;
      if ( ((v20 < 0x39) & (v17 >> 6)) == 0 )
        v21 = 0LL;
      result = v14 | v21;
      break;
    case 0xA:
      __asm { BTI             j; jumptable 0000000006869BCC case 10 }
      result = *(__int16 *)v5;
      *a2 = v5 + 2;
      break;
    case 0xB:
      __asm { BTI             j; jumptable 0000000006869BCC case 11 }
      result = *(int *)v5;
      *a2 = v5 + 4;
      break;
    default:
      __asm { BTI             j; jumptable 0000000006869BCC default case, cases 5-8 }
      fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getEncodedP", "unknown pointer encoding");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
  switch ( (a4 >> 4) & 7 )
  {
    case 0:
      goto LABEL_16;
    case 1:
      __asm { BTI             j; jumptable 0000000006869CC8 case 1 }
      result += (unsigned __int64)v5;
LABEL_16:
      __asm { BTI             j; jumptable 0000000006869CC8 case 0 }
      if ( (a4 & 0x80) != 0 )
        return *(_QWORD *)result;
      return result;
    case 2:
      __asm { BTI             j; jumptable 0000000006869CC8 case 2 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getEncodedP",
        "DW_EH_PE_textrel pointer encoding not supported");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    case 3:
      __asm { BTI             j; jumptable 0000000006869CC8 case 3 }
      if ( !a5 )
      {
        fprintf(
          (FILE *)((char *)&_sF + 304),
          "libunwind: %s - %s\n",
          "getEncodedP",
          "DW_EH_PE_datarel is invalid with a datarelBase of 0");
        fflush((FILE *)((char *)&_sF + 304));
        abort();
      }
      result += a5;
      if ( (a4 & 0x80) == 0 )
        return result;
      return *(_QWORD *)result;
    case 4:
      __asm { BTI             j; jumptable 0000000006869CC8 case 4 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getEncodedP",
        "DW_EH_PE_funcrel pointer encoding not supported");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    case 5:
      __asm { BTI             j; jumptable 0000000006869CC8 case 5 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getEncodedP",
        "DW_EH_PE_aligned pointer encoding not supported");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    default:
      fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getEncodedP", "unknown pointer encoding");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
}


================================================================================
Function: sub_6869EA0 (0x6869EA0)
================================================================================

unsigned __int64 __fastcall sub_6869EA0(_BYTE **a1, _BYTE *a2)
{
  _BYTE *v2; // x9
  _BYTE *v4; // x10
  unsigned __int64 result; // x0
  unsigned __int8 v6; // w11
  _BYTE *v7; // x10

  v2 = *a1;
  if ( *a1 == a2 )
    goto LABEL_25;
  v4 = v2 + 1;
  result = *v2 & 0x7F;
  if ( (*v2 & 0x80) == 0 )
  {
LABEL_3:
    *a1 = v4;
    return result;
  }
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | ((unsigned __int64)(v2[1] & 0x7F) << 7);
  v4 = v2 + 2;
  if ( ((char)v2[1] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14);
  v4 = v2 + 3;
  if ( ((char)v2[2] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFFFFFFFFF01FFFFFLL | ((unsigned __int64)(v2[3] & 0x7F) << 21);
  v4 = v2 + 4;
  if ( ((char)v2[3] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFFFFFFF8001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28);
  v4 = v2 + 5;
  if ( ((char)v2[4] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFFFFFC00001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0xFFFFFC07FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35);
  v4 = v2 + 6;
  if ( ((char)v2[5] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFFFE0000001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0xFFFE0007FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35) & 0xFFFE03FFFFFFFFFFLL | ((unsigned __int64)(v2[6] & 0x7F) << 42);
  v4 = v2 + 7;
  if ( ((char)v2[6] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFF000000001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0xFF000007FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35) & 0xFF0003FFFFFFFFFFLL | ((unsigned __int64)(v2[6] & 0x7F) << 42) & 0xFF01FFFFFFFFFFFFLL | ((unsigned __int64)(v2[7] & 0x7F) << 49);
  v4 = v2 + 8;
  if ( ((char)v2[7] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0x80000000001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0x80000007FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35) & 0x800003FFFFFFFFFFLL | ((unsigned __int64)(v2[6] & 0x7F) << 42) & 0x8001FFFFFFFFFFFFLL | ((unsigned __int64)(v2[7] & 0x7F) << 49) & 0x80FFFFFFFFFFFFFFLL | ((unsigned __int64)(v2[8] & 0x7F) << 56);
  v4 = v2 + 9;
  if ( ((char)v2[8] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
  {
LABEL_25:
    fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getULEB128", "truncated uleb128 expression");
    fflush((FILE *)((char *)&_sF + 304));
    abort();
  }
  v6 = *v4;
  if ( (*v4 & 0x7E) != 0 )
  {
LABEL_26:
    fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getULEB128", "malformed uleb128 expression");
    fflush((FILE *)((char *)&_sF + 304));
    abort();
  }
  v7 = v2 + 10;
  if ( (v6 & 0x80) != 0 )
  {
    if ( v7 == a2 )
      goto LABEL_25;
    goto LABEL_26;
  }
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0x1FFFFF | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0x7FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35) & 0x3FFFFFFFFFFLL | ((unsigned __int64)(v2[6] & 0x7F) << 42) & 0x1FFFFFFFFFFFFLL | ((unsigned __int64)(v2[7] & 0x7F) << 49) & 0xFFFFFFFFFFFFFFLL | ((unsigned __int64)(v2[8] & 0x7F) << 56) & 0x7FFFFFFFFFFFFFFFLL | ((unsigned __int64)v6 << 63);
  *a1 = v7;
  return result;
}


================================================================================
Function: sub_686AA34 (0x686AA34)
================================================================================

__int64 __fastcall sub_686AA34(__int64 a1, unsigned __int64 a2, __int64 *a3, unsigned int a4)
{
  __int64 v8; // x2
  int v9; // w24
  __int64 v10; // x23
  __int64 *v11; // x8
  __int64 v12; // x23
  char v13; // w8
  __int64 result; // x0
  __int64 v15; // x25
  __int64 v16; // d0
  __int64 v17; // x9
  __int64 v18; // x10
  __int64 v19; // x22
  int v20; // w8
  __int64 v21; // x23
  __int64 v22; // x24
  __int64 *v23; // x8
  __int64 *v24; // x19
  size_t v25; // x21
  signed __int64 v26; // x28
  signed __int64 v27; // x27
  char *v28; // x20
  __int64 v29; // [xsp+0h] [xbp-6A0h]
  _BYTE v30[32]; // [xsp+18h] [xbp-688h] BYREF
  __int64 v31; // [xsp+38h] [xbp-668h]
  __int64 v32; // [xsp+50h] [xbp-650h] BYREF
  __int64 v33; // [xsp+58h] [xbp-648h]
  __int64 v34; // [xsp+68h] [xbp-638h]
  __int128 v35; // [xsp+70h] [xbp-630h]
  _BYTE s[16]; // [xsp+80h] [xbp-620h] BYREF
  unsigned int v37; // [xsp+90h] [xbp-610h]

  if ( a4 && (sub_686AEE8(*(_QWORD *)(a1 + 8), a2, a3[2], a3[3], a3[2] + a4, &v32, v30) & 1) != 0
    || (v8 = a3[4]) != 0 && (sub_686B0B0(*(_QWORD *)(a1 + 8), a2, v8, *((unsigned int *)a3 + 10), &v32, v30) & 1) != 0 )
  {
    v9 = 0;
    goto LABEL_22;
  }
  v10 = *a3;
  pthread_rwlock_rdlock(&stru_79D8EF4);
  v11 = off_6CAFA40[0];
  if ( off_6CAFA40[0] >= off_6CAFA48 )
  {
LABEL_20:
    pthread_rwlock_unlock(&stru_79D8EF4);
    goto LABEL_21;
  }
  if ( v10 == -1 )
  {
    while ( v11[1] > a2 || v11[2] <= a2 )
    {
      v11 += 4;
      if ( v11 >= off_6CAFA48 )
        goto LABEL_20;
    }
  }
  else
  {
    while ( *v11 != v10 || v11[1] > a2 || v11[2] <= a2 )
    {
      v11 += 4;
      if ( v11 >= off_6CAFA48 )
        goto LABEL_20;
    }
  }
  v12 = v11[3];
  pthread_rwlock_unlock(&stru_79D8EF4);
  if ( !v12 || (sub_686AEE8(*(_QWORD *)(a1 + 8), a2, a3[2], a3[3], v12, &v32, v30) & 1) == 0 )
  {
LABEL_21:
    v13 = sub_686AEE8(*(_QWORD *)(a1 + 8), a2, a3[2], a3[3], 0LL, &v32, v30);
    v9 = 0;
    result = 0LL;
    if ( (v13 & 1) == 0 )
      return result;
    goto LABEL_22;
  }
  v9 = 1;
LABEL_22:
  v15 = *a3;
  memset(s, 0, 0x618uLL);
  if ( (sub_6868D74(*(_QWORD *)(a1 + 8), &v32, (__int64)v30, a2, 4, s) & 1) == 0 )
    return 0LL;
  v16 = v35;
  v17 = v31;
  v18 = v37;
  result = 1LL;
  *(_OWORD *)(a1 + 552) = v35;
  v19 = v34;
  *(_QWORD *)(a1 + 568) = v17;
  *(_QWORD *)(a1 + 576) = v18;
  *(_DWORD *)(a1 + 592) = 50331648;
  v21 = v32;
  v20 = v33;
  *(_QWORD *)(a1 + 544) = v19;
  *(_QWORD *)(a1 + 584) = 0LL;
  *(_QWORD *)(a1 + 608) = v15;
  *(_QWORD *)(a1 + 600) = v21;
  *(_DWORD *)(a1 + 596) = v20;
  if ( ((a4 != 0) | v9) != 1 && !a3[4] )
  {
    v22 = *a3;
    v29 = v16;
    pthread_rwlock_wrlock(&stru_79D8EF4);
    v23 = off_6CAFA48;
    if ( off_6CAFA48 >= (__int64 *)off_6CAFA50 )
    {
      v24 = off_6CAFA40[0];
      v25 = off_6CAFA50 - (_UNKNOWN *)off_6CAFA40[0];
      v26 = (off_6CAFA50 - (_UNKNOWN *)off_6CAFA40[0]) >> 5;
      v27 = (off_6CAFA50 - (_UNKNOWN *)off_6CAFA40[0]) >> 3;
      v28 = (char *)sub_67F3A24(4 * (off_6CAFA50 - (_UNKNOWN *)off_6CAFA40[0]));
      memcpy(v28, v24, v25);
      if ( v24 != &qword_79D8F30 )
        sub_67F3C08((unsigned __int64)v24);
      v23 = (__int64 *)&v28[32 * v26];
      off_6CAFA50 = &v28[32 * v27];
      off_6CAFA40[0] = (__int64 *)v28;
    }
    *v23 = v22;
    v23[1] = v19;
    v23[3] = v21;
    v23[2] = v29;
    off_6CAFA48 = v23 + 4;
    pthread_rwlock_unlock(&stru_79D8EF4);
    return 1LL;
  }
  return result;
}


================================================================================
Function: sub_686AEE8 (0x686AEE8)
================================================================================

__int64 __fastcall sub_686AEE8(
        __int64 a1,
        unsigned __int64 a2,
        _BYTE *a3,
        __int64 a4,
        _BYTE *a5,
        _QWORD *a6,
        _BYTE *a7)
{
  _BYTE *v7; // x22
  unsigned __int64 v8; // x27
  _BYTE *v14; // x26
  unsigned int *v15; // x8
  __int64 v16; // x9
  __int64 v17; // x10
  char *v18; // x1
  unsigned __int8 v19; // w3
  unsigned __int64 v20; // x25
  unsigned __int64 v21; // x0
  unsigned __int64 v22; // x28
  int v23; // w8
  unsigned __int64 v24; // x0
  _BYTE *v25; // x24
  int v26; // w8
  _BYTE *v27; // x23
  unsigned __int8 v28; // w3
  __int64 result; // x0
  _BYTE *i; // [xsp+8h] [xbp-8h] BYREF

  if ( a5 )
    v7 = a5;
  else
    v7 = a3;
  if ( a4 == -1 )
    v8 = -1LL;
  else
    v8 = (unsigned __int64)&a3[a4];
  for ( i = v7; (unsigned __int64)v7 < v8; i = v7 )
  {
    v14 = v7;
    v15 = (unsigned int *)(v7 + 4);
    v16 = *(unsigned int *)v7;
    i = v7 + 4;
    if ( (_DWORD)v16 == -1 )
    {
      v15 = (unsigned int *)(v7 + 12);
      v16 = *(_QWORD *)(v7 + 4);
      i = v7 + 12;
    }
    if ( !v16 )
      break;
    v17 = *v15;
    v7 = (char *)v15 + v16;
    if ( (_DWORD)v17 )
    {
      v18 = (char *)v15 - v17;
      if ( (char *)v15 - v17 >= a3 && (unsigned __int64)v18 < v8 && !sub_6867F08(a1, v18, a7) )
      {
        v19 = a7[24];
        i += 4;
        v20 = sub_6869B8C(a1, &i, v7, v19, 0LL);
        v21 = sub_6869B8C(a1, &i, v7, a7[24] & 0xF, 0LL);
        if ( v20 < a2 )
        {
          v22 = v21 + v20;
          if ( v21 + v20 >= a2 )
          {
            v23 = (unsigned __int8)a7[49];
            a6[5] = 0LL;
            if ( v23 )
            {
              v24 = sub_6869EA0(&i, v7);
              v25 = i;
              v26 = (unsigned __int8)a7[25];
              v27 = &i[v24];
              if ( v26 != 255 )
              {
                if ( sub_6869B8C(a1, &i, v7, v26 & 0xF, 0LL) )
                {
                  v28 = a7[25];
                  i = v25;
                  a6[5] = sub_6869B8C(a1, &i, v7, v28, 0LL);
                }
              }
            }
            else
            {
              v27 = i;
            }
            a6[2] = v27;
            a6[3] = v20;
            result = 1LL;
            a6[4] = v22;
            *a6 = v14;
            a6[1] = v7 - v14;
            return result;
          }
        }
      }
    }
  }
  return 0LL;
}


================================================================================
Function: sub_686B0B0 (0x686B0B0)
================================================================================

unsigned __int64 __fastcall sub_686B0B0(__int64 a1, unsigned __int64 a2, _BYTE *a3, int a4, _QWORD *a5, __int64 a6)
{
  unsigned __int8 v6; // w8
  int v8; // w26
  unsigned __int8 *v9; // x25
  unsigned __int64 result; // x0
  unsigned __int64 v14; // x26
  unsigned __int8 *v15; // x28
  __int64 v16; // x27
  __int64 v17; // x21
  unsigned __int8 *v18; // x19
  unsigned __int64 v19; // x0
  unsigned int *v20; // x0
  _QWORD *v21; // [xsp+10h] [xbp-20h]
  unsigned int v22; // [xsp+1Ch] [xbp-14h]
  unsigned __int8 *v24; // [xsp+28h] [xbp-8h] BYREF

  if ( *a3 == 1 )
  {
    v6 = a3[1];
    v8 = (unsigned __int8)a3[2];
    v9 = &a3[a4];
    v24 = a3 + 4;
    v22 = (unsigned __int8)a3[3];
    sub_6869B8C(a1, &v24, v9, v6, (__int64)a3);
    if ( v8 != 255 )
    {
      result = sub_6869B8C(a1, &v24, v9, v8, (__int64)a3);
      if ( !result )
        return result;
      v14 = result;
      v15 = v24;
      v21 = a5;
      v16 = sub_686B280(v22);
      v17 = 0LL;
      while ( v14 > 1 )
      {
        v18 = &v15[((v14 >> 1) + v17) * v16];
        v24 = v18;
        v19 = sub_6869B8C(a1, &v24, v9, v22, (__int64)a3);
        if ( v19 >= a2 )
        {
          v14 >>= 1;
        }
        else
        {
          v17 += v14 >> 1;
          v14 -= v14 >> 1;
        }
        if ( v19 == a2 )
          goto LABEL_15;
      }
      v18 = &v15[v17 * v16];
LABEL_15:
      v24 = v18;
      sub_6869B8C(a1, &v24, v9, v22, (__int64)a3);
      v20 = (unsigned int *)sub_6869B8C(a1, &v24, v9, v22, (__int64)a3);
      if ( !sub_6867D78(a1, v20, v21, a6, 0) && v21[3] <= a2 && v21[4] > a2 )
        return 1LL;
    }
  }
  else
  {
    fwrite("libunwind: Unsupported .eh_frame_hdr version\n", 0x2DuLL, 1uLL, (FILE *)((char *)&_sF + 304));
  }
  return 0LL;
}


================================================================================
Function: sub_686B280 (0x686B280)
================================================================================

__int64 __fastcall sub_686B280(char a1)
{
  int v1; // w8
  __int64 result; // x0

  v1 = (a1 & 0xF) - 1;
  result = 4LL;
  switch ( v1 )
  {
    case 0:
    case 8:
      __asm { BTI             j; jumptable 000000000686B2B8 cases 1,9 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getTableEntrySize",
        "Can't binary search on variable length encoded data.");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    case 1:
    case 9:
      goto LABEL_3;
    case 2:
    case 10:
      __asm { BTI             j; jumptable 000000000686B2B8 cases 3,11 }
      result = 8LL;
LABEL_3:
      __asm { BTI             j; jumptable 000000000686B2B8 cases 2,10 }
      break;
    case 3:
    case 11:
      __asm { BTI             j; jumptable 000000000686B2B8 cases 4,12 }
      result = 16LL;
      break;
    default:
      __asm { BTI             j; jumptable 000000000686B2B8 default case, cases 5-8 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getTableEntrySize",
        "Unknown DWARF encoding for search table.");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
  return result;
}


================================================================================
Function: sub_686B4B0 (0x686B4B0)
================================================================================

__int64 __usercall sub_686B4B0@<X0>(
        __int64 a1@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        __int64 a4@<X3>,
        __int64 a5@<X4>,
        __int64 a6@<X5>,
        __int64 a7@<X6>,
        __int64 a8@<X7>,
        __int64 a9@<X8>,
        double a10@<D0>,
        double a11@<D1>,
        double a12@<D2>,
        double a13@<D3>,
        double a14@<D4>,
        double a15@<D5>,
        double a16@<D6>,
        double a17@<D7>,
        __int64 a18)
{
  __int64 v18; // x9
  __int64 v19; // x10
  __int64 v20; // x11
  __int64 v21; // x12
  __int64 v22; // x13
  __int64 v23; // x14
  __int64 v24; // x15
  __int64 v25; // x16
  __int64 v26; // x17
  __int64 v27; // x18
  __int64 v28; // x19
  __int64 v29; // x20
  __int64 v30; // x21
  __int64 v31; // x22
  __int64 v32; // x23
  __int64 v33; // x24
  __int64 v34; // x25
  __int64 v35; // x26
  __int64 v36; // x27
  __int64 v37; // x28
  __int64 v38; // x29
  __int64 v39; // x30
  __int64 v40; // d8
  __int64 v41; // d9
  __int64 v42; // d10
  __int64 v43; // d11
  __int64 v44; // d12
  __int64 v45; // d13
  __int64 v46; // d14
  __int64 v47; // d15
  __int64 v48; // d16
  __int64 v49; // d17
  __int64 v50; // d18
  __int64 v51; // d19
  __int64 v52; // d20
  __int64 v53; // d21
  __int64 v54; // d22
  __int64 v55; // d23
  __int64 v56; // d24
  __int64 v57; // d25
  __int64 v58; // d26
  __int64 v59; // d27
  __int64 v60; // d28
  __int64 v61; // d29
  __int64 v62; // d30
  __int64 v63; // d31

  *(_QWORD *)a1 = a1;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = a4;
  *(_QWORD *)(a1 + 32) = a5;
  *(_QWORD *)(a1 + 40) = a6;
  *(_QWORD *)(a1 + 48) = a7;
  *(_QWORD *)(a1 + 56) = a8;
  *(_QWORD *)(a1 + 64) = a9;
  *(_QWORD *)(a1 + 72) = v18;
  *(_QWORD *)(a1 + 80) = v19;
  *(_QWORD *)(a1 + 88) = v20;
  *(_QWORD *)(a1 + 96) = v21;
  *(_QWORD *)(a1 + 104) = v22;
  *(_QWORD *)(a1 + 112) = v23;
  *(_QWORD *)(a1 + 120) = v24;
  *(_QWORD *)(a1 + 128) = v25;
  *(_QWORD *)(a1 + 136) = v26;
  *(_QWORD *)(a1 + 144) = v27;
  *(_QWORD *)(a1 + 152) = v28;
  *(_QWORD *)(a1 + 160) = v29;
  *(_QWORD *)(a1 + 168) = v30;
  *(_QWORD *)(a1 + 176) = v31;
  *(_QWORD *)(a1 + 184) = v32;
  *(_QWORD *)(a1 + 192) = v33;
  *(_QWORD *)(a1 + 200) = v34;
  *(_QWORD *)(a1 + 208) = v35;
  *(_QWORD *)(a1 + 216) = v36;
  *(_QWORD *)(a1 + 224) = v37;
  *(_QWORD *)(a1 + 232) = v38;
  *(_QWORD *)(a1 + 240) = v39;
  *(_QWORD *)(a1 + 248) = &a18;
  *(_QWORD *)(a1 + 256) = v39;
  *(double *)(a1 + 272) = a10;
  *(double *)(a1 + 280) = a11;
  *(double *)(a1 + 288) = a12;
  *(double *)(a1 + 296) = a13;
  *(double *)(a1 + 304) = a14;
  *(double *)(a1 + 312) = a15;
  *(double *)(a1 + 320) = a16;
  *(double *)(a1 + 328) = a17;
  *(_QWORD *)(a1 + 336) = v40;
  *(_QWORD *)(a1 + 344) = v41;
  *(_QWORD *)(a1 + 352) = v42;
  *(_QWORD *)(a1 + 360) = v43;
  *(_QWORD *)(a1 + 368) = v44;
  *(_QWORD *)(a1 + 376) = v45;
  *(_QWORD *)(a1 + 384) = v46;
  *(_QWORD *)(a1 + 392) = v47;
  *(_QWORD *)(a1 + 400) = v48;
  *(_QWORD *)(a1 + 408) = v49;
  *(_QWORD *)(a1 + 416) = v50;
  *(_QWORD *)(a1 + 424) = v51;
  *(_QWORD *)(a1 + 432) = v52;
  *(_QWORD *)(a1 + 440) = v53;
  *(_QWORD *)(a1 + 448) = v54;
  *(_QWORD *)(a1 + 456) = v55;
  *(_QWORD *)(a1 + 464) = v56;
  *(_QWORD *)(a1 + 472) = v57;
  *(_QWORD *)(a1 + 480) = v58;
  *(_QWORD *)(a1 + 488) = v59;
  *(_QWORD *)(a1 + 496) = v60;
  *(_QWORD *)(a1 + 504) = v61;
  *(_QWORD *)(a1 + 512) = v62;
  *(_QWORD *)(a1 + 520) = v63;
  return 0LL;
}


================================================================================
Function: .__cxa_atexit (0x686B690)
================================================================================

// attributes: thunk
int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return _cxa_atexit(lpfunc, obj, lpdso_handle);
}


================================================================================
Function: .memcpy (0x686B6C0)
================================================================================

// attributes: thunk
void *memcpy(void *dest, const void *src, size_t n)
{
  return memcpy(dest, src, n);
}


================================================================================
Function: .strlen (0x686B6D0)
================================================================================

// attributes: thunk
size_t strlen(const char *s)
{
  return strlen(s);
}


================================================================================
Function: .memcmp (0x686B6F0)
================================================================================

// attributes: thunk
int memcmp(const void *s1, const void *s2, size_t n)
{
  return memcmp(s1, s2, n);
}


================================================================================
Function: .pthread_mutex_init (0x686B700)
================================================================================

// attributes: thunk
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr)
{
  return pthread_mutex_init(mutex, mutexattr);
}


================================================================================
Function: .pthread_mutex_destroy (0x686B710)
================================================================================

// attributes: thunk
int pthread_mutex_destroy(pthread_mutex_t *mutex)
{
  return pthread_mutex_destroy(mutex);
}


================================================================================
Function: .memset (0x686B720)
================================================================================

// attributes: thunk
void *memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}


================================================================================
Function: .__memcpy_chk (0x686B730)
================================================================================

// attributes: thunk
__int64 __fastcall __memcpy_chk()
{
  return _memcpy_chk();
}


================================================================================
Function: .pthread_once (0x686B740)
================================================================================

// attributes: thunk
int pthread_once(pthread_once_t *once_control, void (*init_routine)(void))
{
  return pthread_once(once_control, init_routine);
}


================================================================================
Function: .strncmp (0x686B770)
================================================================================

// attributes: thunk
int strncmp(const char *s1, const char *s2, size_t n)
{
  return strncmp(s1, s2, n);
}


================================================================================
Function: .strcmp (0x686B7C0)
================================================================================

// attributes: thunk
int strcmp(const char *s1, const char *s2)
{
  return strcmp(s1, s2);
}


================================================================================
Function: .fopen (0x686B7D0)
================================================================================

// attributes: thunk
FILE *fopen(const char *filename, const char *modes)
{
  return fopen(filename, modes);
}


================================================================================
Function: .fclose (0x686B7E0)
================================================================================

// attributes: thunk
int fclose(FILE *stream)
{
  return fclose(stream);
}


================================================================================
Function: .fwrite (0x686B810)
================================================================================

// attributes: thunk
size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)
{
  return fwrite(ptr, size, n, s);
}


================================================================================
Function: .fflush (0x686B820)
================================================================================

// attributes: thunk
int fflush(FILE *stream)
{
  return fflush(stream);
}


================================================================================
Function: .memmove (0x686B830)
================================================================================

// attributes: thunk
void *memmove(void *dest, const void *src, size_t n)
{
  return memmove(dest, src, n);
}


================================================================================
Function: .__open_2 (0x686B870)
================================================================================

// attributes: thunk
__int64 __fastcall __open_2()
{
  return _open_2();
}


================================================================================
Function: .read (0x686B880)
================================================================================

// attributes: thunk
ssize_t read(int fd, void *buf, size_t nbytes)
{
  return read(fd, buf, nbytes);
}


================================================================================
Function: .__errno (0x686B890)
================================================================================

// attributes: thunk
__int64 __errno(void)
{
  return _errno();
}


================================================================================
Function: .close (0x686B8A0)
================================================================================

// attributes: thunk
int close(int fd)
{
  return close(fd);
}


================================================================================
Function: .memchr (0x686B8D0)
================================================================================

// attributes: thunk
void *memchr(const void *s, int c, size_t n)
{
  return memchr(s, c, n);
}


================================================================================
Function: .pthread_create (0x686B940)
================================================================================

// attributes: thunk
int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
{
  return pthread_create(newthread, attr, start_routine, arg);
}


================================================================================
Function: .pthread_setspecific (0x686B950)
================================================================================

// attributes: thunk
int pthread_setspecific(pthread_key_t key, const void *pointer)
{
  return pthread_setspecific(key, pointer);
}


================================================================================
Function: .abort (0x686B960)
================================================================================

// attributes: thunk
void __noreturn abort(void)
{
  abort();
}


================================================================================
Function: .strncpy (0x686B970)
================================================================================

// attributes: thunk
char *strncpy(char *dest, const char *src, size_t n)
{
  return strncpy(dest, src, n);
}


================================================================================
Function: .__strlen_chk (0x686B980)
================================================================================

// attributes: thunk
size_t __strlen_chk(const char *a1, size_t a2)
{
  return _strlen_chk(a1, a2);
}


================================================================================
Function: .pthread_mutex_lock (0x686B990)
================================================================================

// attributes: thunk
int pthread_mutex_lock(pthread_mutex_t *mutex)
{
  return pthread_mutex_lock(mutex);
}


================================================================================
Function: .pthread_cond_signal (0x686B9A0)
================================================================================

// attributes: thunk
int pthread_cond_signal(pthread_cond_t *cond)
{
  return pthread_cond_signal(cond);
}


================================================================================
Function: .pthread_mutex_unlock (0x686B9B0)
================================================================================

// attributes: thunk
int pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}


================================================================================
Function: .pthread_cond_wait (0x686B9E0)
================================================================================

// attributes: thunk
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
{
  return pthread_cond_wait(cond, mutex);
}


================================================================================
Function: .pthread_self (0x686B9F0)
================================================================================

// attributes: thunk
pthread_t pthread_self(void)
{
  return pthread_self();
}


================================================================================
Function: .pthread_cond_init (0x686BA10)
================================================================================

// attributes: thunk
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr)
{
  return pthread_cond_init(cond, cond_attr);
}


================================================================================
Function: .stat (0x686BA40)
================================================================================

// attributes: thunk
int stat(const char *file, struct stat *buf)
{
  return stat(file, buf);
}


================================================================================
Function: .pthread_cond_destroy (0x686BA80)
================================================================================

// attributes: thunk
int pthread_cond_destroy(pthread_cond_t *cond)
{
  return pthread_cond_destroy(cond);
}


================================================================================
Function: .pthread_cond_broadcast (0x686BA90)
================================================================================

// attributes: thunk
int pthread_cond_broadcast(pthread_cond_t *cond)
{
  return pthread_cond_broadcast(cond);
}


================================================================================
Function: .mkdir (0x686BB10)
================================================================================

// attributes: thunk
int mkdir(const char *path, __mode_t mode)
{
  return mkdir(path, mode);
}


================================================================================
Function: .dl_iterate_phdr (0x686BB20)
================================================================================

// attributes: thunk
int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *), void *data)
{
  return dl_iterate_phdr(callback, data);
}


================================================================================
Function: .access (0x686BB40)
================================================================================

// attributes: thunk
int access(const char *name, int type)
{
  return access(name, type);
}


================================================================================
Function: .getenv (0x686BB50)
================================================================================

// attributes: thunk
char *getenv(const char *name)
{
  return getenv(name);
}


================================================================================
Function: .vsnprintf (0x686BC60)
================================================================================

// attributes: thunk
int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg)
{
  return vsnprintf(s, maxlen, format, arg);
}


================================================================================
Function: .gettimeofday (0x686BCB0)
================================================================================

// attributes: thunk
int gettimeofday(struct timeval *tv, __timezone_ptr_t tz)
{
  return gettimeofday(tv, tz);
}


================================================================================
Function: .sched_yield (0x686BD00)
================================================================================

// attributes: thunk
int sched_yield(void)
{
  return sched_yield();
}


================================================================================
Function: .time (0x686BD20)
================================================================================

// attributes: thunk
time_t time(time_t *timer)
{
  return time(timer);
}


================================================================================
Function: .__vsnprintf_chk (0x686BD60)
================================================================================

// attributes: thunk
__int64 __fastcall __vsnprintf_chk()
{
  return _vsnprintf_chk();
}


================================================================================
Function: .pthread_cond_timedwait (0x686BD70)
================================================================================

// attributes: thunk
int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime)
{
  return pthread_cond_timedwait(cond, mutex, abstime);
}


================================================================================
Function: .strtoll (0x686BD80)
================================================================================

// attributes: thunk
__int64 strtoll(const char *nptr, char **endptr, int base)
{
  return strtoll(nptr, endptr, base);
}


================================================================================
Function: .fcntl (0x686BE70)
================================================================================

// attributes: thunk
int fcntl(int fd, int cmd, ...)
{
  return fcntl(fd, cmd);
}


================================================================================
Function: .pipe (0x686BE80)
================================================================================

// attributes: thunk
int pipe(int pipedes[2])
{
  return pipe(pipedes);
}


================================================================================
Function: .strcpy (0x686BE90)
================================================================================

// attributes: thunk
char *strcpy(char *dest, const char *src)
{
  return strcpy(dest, src);
}


================================================================================
Function: .raise (0x686BF40)
================================================================================

// attributes: thunk
int raise(int sig)
{
  return raise(sig);
}


================================================================================
Function: .fprintf (0x686BF70)
================================================================================

// attributes: thunk
int fprintf(FILE *stream, const char *format, ...)
{
  return fprintf(stream, format);
}


================================================================================
Function: .clock_gettime (0x686BF80)
================================================================================

// attributes: thunk
int clock_gettime(clockid_t clock_id, struct timespec *tp)
{
  return clock_gettime(clock_id, tp);
}


================================================================================
Function: .log (0x686BFA0)
================================================================================

// attributes: thunk
double log(double x)
{
  return log(x);
}


================================================================================
Function: .strstr (0x686BFB0)
================================================================================

// attributes: thunk
char *strstr(const char *haystack, const char *needle)
{
  return strstr(haystack, needle);
}


================================================================================
Function: .strcasecmp (0x686C000)
================================================================================

// attributes: thunk
int strcasecmp(const char *s1, const char *s2)
{
  return strcasecmp(s1, s2);
}


================================================================================
Function: .strcat (0x686C010)
================================================================================

// attributes: thunk
char *strcat(char *dest, const char *src)
{
  return strcat(dest, src);
}


================================================================================
Function: .strchr (0x686C020)
================================================================================

// attributes: thunk
char *strchr(const char *s, int c)
{
  return strchr(s, c);
}


================================================================================
Function: .getpid (0x686C040)
================================================================================

// attributes: thunk
__pid_t getpid(void)
{
  return getpid();
}


================================================================================
Function: .pthread_mutexattr_init (0x686C080)
================================================================================

// attributes: thunk
int pthread_mutexattr_init(pthread_mutexattr_t *attr)
{
  return pthread_mutexattr_init(attr);
}


================================================================================
Function: .pthread_mutexattr_settype (0x686C090)
================================================================================

// attributes: thunk
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind)
{
  return pthread_mutexattr_settype(attr, kind);
}


================================================================================
Function: .pthread_mutexattr_destroy (0x686C0A0)
================================================================================

// attributes: thunk
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr)
{
  return pthread_mutexattr_destroy(attr);
}


================================================================================
Function: .pthread_mutex_trylock (0x686C0B0)
================================================================================

// attributes: thunk
int pthread_mutex_trylock(pthread_mutex_t *mutex)
{
  return pthread_mutex_trylock(mutex);
}


================================================================================
Function: .pthread_join (0x686C0C0)
================================================================================

// attributes: thunk
int pthread_join(pthread_t th, void **thread_return)
{
  return pthread_join(th, thread_return);
}


================================================================================
Function: .vfprintf (0x686C0E0)
================================================================================

// attributes: thunk
int vfprintf(FILE *s, const char *format, __gnuc_va_list arg)
{
  return vfprintf(s, format, arg);
}


================================================================================
Function: .strtol (0x686C190)
================================================================================

// attributes: thunk
__int64 strtol(const char *nptr, char **endptr, int base)
{
  return strtol(nptr, endptr, base);
}


================================================================================
Function: .inet_pton (0x686C200)
================================================================================

// attributes: thunk
int inet_pton(int af, const char *cp, void *buf)
{
  return inet_pton(af, cp, buf);
}


================================================================================
Function: .__FD_SET_chk (0x686C280)
================================================================================

// attributes: thunk
__int64 __fastcall __FD_SET_chk()
{
  return _FD_SET_chk();
}


================================================================================
Function: .select (0x686C290)
================================================================================

// attributes: thunk
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
{
  return select(nfds, readfds, writefds, exceptfds, timeout);
}


================================================================================
Function: .__FD_ISSET_chk (0x686C2A0)
================================================================================

// attributes: thunk
__int64 __fastcall __FD_ISSET_chk()
{
  return _FD_ISSET_chk();
}


================================================================================
Function: .nanosleep (0x686C310)
================================================================================

// attributes: thunk
int nanosleep(const struct timespec *requested_time, struct timespec *remaining)
{
  return nanosleep(requested_time, remaining);
}


================================================================================
Function: .fileno (0x686C320)
================================================================================

// attributes: thunk
int fileno(FILE *stream)
{
  return fileno(stream);
}


================================================================================
Function: .fstat (0x686C330)
================================================================================

// attributes: thunk
int fstat(int fd, struct stat *buf)
{
  return fstat(fd, buf);
}


================================================================================
Function: .qsort (0x686C980)
================================================================================

// attributes: thunk
void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar)
{
  qsort(base, nmemb, size, compar);
}


================================================================================
Function: .feof (0x686C990)
================================================================================

// attributes: thunk
int feof(FILE *stream)
{
  return feof(stream);
}


================================================================================
Function: .syscall (0x686C9C0)
================================================================================

// attributes: thunk
__int64 syscall(__int64 sysno, ...)
{
  return syscall(sysno);
}


================================================================================
Function: .strrchr (0x686CA40)
================================================================================

// attributes: thunk
char *strrchr(const char *s, int c)
{
  return strrchr(s, c);
}


================================================================================
Function: .munmap (0x686CA60)
================================================================================

// attributes: thunk
int munmap(void *addr, size_t len)
{
  return munmap(addr, len);
}


================================================================================
Function: .mprotect (0x686CA70)
================================================================================

// attributes: thunk
int mprotect(void *addr, size_t len, int prot)
{
  return mprotect(addr, len, prot);
}


================================================================================
Function: .mmap (0x686CA80)
================================================================================

// attributes: thunk
void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset)
{
  return mmap(addr, len, prot, flags, fd, offset);
}


================================================================================
Function: .sysconf (0x686CA90)
================================================================================

// attributes: thunk
__int64 sysconf(int name)
{
  return sysconf(name);
}


================================================================================
Function: .fputc (0x686CB10)
================================================================================

// attributes: thunk
int fputc(int c, FILE *stream)
{
  return fputc(c, stream);
}


================================================================================
Function: .strcspn (0x686CB50)
================================================================================

// attributes: thunk
size_t strcspn(const char *s, const char *reject)
{
  return strcspn(s, reject);
}


================================================================================
Function: .strncat (0x686CB60)
================================================================================

// attributes: thunk
char *strncat(char *dest, const char *src, size_t n)
{
  return strncat(dest, src, n);
}


================================================================================
Function: .gmtime_r (0x686CB70)
================================================================================

// attributes: thunk
struct tm *gmtime_r(const time_t *timer, struct tm *tp)
{
  return gmtime_r(timer, tp);
}


================================================================================
Function: .fgets (0x686CBF0)
================================================================================

// attributes: thunk
char *fgets(char *s, int n, FILE *stream)
{
  return fgets(s, n, stream);
}


================================================================================
Function: .fdopen (0x686CC30)
================================================================================

// attributes: thunk
FILE *fdopen(int fd, const char *modes)
{
  return fdopen(fd, modes);
}


================================================================================
Function: .pthread_getspecific (0x686CD00)
================================================================================

// attributes: thunk
void *pthread_getspecific(pthread_key_t key)
{
  return pthread_getspecific(key);
}


================================================================================
Function: .pthread_key_create (0x686CD10)
================================================================================

// attributes: thunk
int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *))
{
  return pthread_key_create(key, destr_function);
}


================================================================================
Function: .sigaction (0x686CE20)
================================================================================

// attributes: thunk
int sigaction(int sig, const struct sigaction *act, struct sigaction *oact)
{
  return sigaction(sig, act, oact);
}


================================================================================
Function: .strtok_r (0x686CFF0)
================================================================================

// attributes: thunk
char *strtok_r(char *s, const char *delim, char **save_ptr)
{
  return strtok_r(s, delim, save_ptr);
}


================================================================================
Function: .pthread_detach (0x686D000)
================================================================================

// attributes: thunk
int pthread_detach(pthread_t th)
{
  return pthread_detach(th);
}


================================================================================
Function: .unlink (0x686D010)
================================================================================

// attributes: thunk
int unlink(const char *name)
{
  return unlink(name);
}


================================================================================
Function: .memrchr (0x686D020)
================================================================================

// attributes: thunk
void *memrchr(const void *s, int c, size_t n)
{
  return memrchr(s, c, n);
}


================================================================================
Function: .open (0x686D030)
================================================================================

// attributes: thunk
int open(const char *file, int oflag, ...)
{
  return open(file, oflag);
}


================================================================================
Function: .madvise (0x686D1A0)
================================================================================

// attributes: thunk
int madvise(void *addr, size_t len, int advice)
{
  return madvise(addr, len, advice);
}


================================================================================
Function: .snprintf (0x686D1D0)
================================================================================

// attributes: thunk
int snprintf(char *s, size_t maxlen, const char *format, ...)
{
  return snprintf(s, maxlen, format);
}


================================================================================
Function: .pthread_rwlock_rdlock (0x686D3E0)
================================================================================

// attributes: thunk
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_rdlock(rwlock);
}


================================================================================
Function: .pthread_rwlock_unlock (0x686D3F0)
================================================================================

// attributes: thunk
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_unlock(rwlock);
}


================================================================================
Function: .pthread_rwlock_wrlock (0x686D400)
================================================================================

// attributes: thunk
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_wrlock(rwlock);
}


================================================================================
Function: .arc4random_buf (0x686D450)
================================================================================

// attributes: thunk
void arc4random_buf(void *a1, size_t a2)
{
  arc4random_buf(a1, a2);
}


================================================================================
Function: .newlocale (0x686D480)
================================================================================

// attributes: thunk
__int64 __fastcall newlocale(__int64 a1, __int64 a2, __int64 a3)
{
  return newlocale(a1, a2, a3);
}


================================================================================
Function: .vasprintf (0x686D4B0)
================================================================================

// attributes: thunk
int vasprintf(char **ptr, const char *f, __gnuc_va_list arg)
{
  return vasprintf(ptr, f, arg);
}


================================================================================
Function: .android_set_abort_message (0x686D730)
================================================================================

// attributes: thunk
__int64 __fastcall android_set_abort_message()
{
  return android_set_abort_message();
}


================================================================================
Function: .openlog (0x686D740)
================================================================================

// attributes: thunk
void openlog(const char *ident, int option, int facility)
{
  openlog(ident, option, facility);
}


================================================================================
Function: .syslog (0x686D750)
================================================================================

// attributes: thunk
void syslog(int pri, const char *fmt, ...)
{
  syslog(pri, fmt);
}


================================================================================
Function: .closelog (0x686D760)
================================================================================

// attributes: thunk
void closelog(void)
{
  closelog();
}


================================================================================
Function: .__cxa_thread_atexit_impl (0x686D770)
================================================================================

// attributes: thunk
__int64 __fastcall __cxa_thread_atexit_impl()
{
  return _cxa_thread_atexit_impl();
}


