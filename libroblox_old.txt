================================================================================
Function: sub_24DB560 (0x24DB560)
================================================================================

__int64 __fastcall sub_24DB560(__int64 a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x19
  __int64 result; // x0
  __int64 v7; // [xsp+0h] [xbp-10h] BYREF

  v4 = *(_QWORD *)(a2 + 8);
  if ( v4 )
  {
    (*(void (__fastcall **)(__int64 *__return_ptr, _QWORD))(*(_QWORD *)v4 + 40LL))(&v7, *(_QWORD *)(a2 + 8));
    v5 = v7;
    if ( v7 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
      if ( v7 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 32LL))(v7);
    }
  }
  else
  {
    v5 = 0LL;
  }
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  if ( result )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)result + 32LL))(result);
  *(_QWORD *)(a1 + 8) = v5;
  if ( v5 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 24LL))(v5);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 32LL))(v5);
  }
  return result;
}


================================================================================
Function: sub_24DE568 (0x24DE568)
================================================================================

void __fastcall __noreturn sub_24DE568(__int64 a1)
{
  __int64 v2; // x19

  v2 = sub_67EAFB8(16LL);
  sub_24DE5B8(v2, a1);
  sub_67EB030(v2, (__int64)&`typeinfo for'std::length_error, (__int64)sub_67EE288);
}


================================================================================
Function: sub_24DE5B8 (0x24DE5B8)
================================================================================

__int64 __fastcall sub_24DE5B8(_QWORD *a1, char *a2)
{
  __int64 result; // x0

  result = sub_67D23F8((int)a1, a2);
  *a1 = off_6BE6118;
  return result;
}


================================================================================
Function: sub_24DF128 (0x24DF128)
================================================================================

unsigned __int64 __fastcall sub_24DF128(__int64 a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 v3; // x9
  __int64 v4; // x10
  __int64 v5; // x13
  __int64 v6; // x15
  __int64 v7; // x16
  __int64 v8; // x14
  __int64 v9; // x10
  unsigned __int64 v10; // x8
  unsigned __int64 result; // x0
  __int64 v12; // x12
  unsigned __int64 v13; // x9
  __int64 v14; // x11
  unsigned __int64 v15; // x9
  unsigned __int64 v16; // x8
  __int64 v17; // x11
  __int64 v18; // x14
  __int64 v19; // x12
  __int64 v20; // x3
  __int64 v21; // x4
  __int64 v22; // x17
  unsigned __int64 v23; // x15
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x16
  __int64 v26; // x6
  __int64 v27; // x13
  __int64 v28; // x14
  unsigned __int64 v29; // x0
  __int64 v30; // x11
  _QWORD *v31; // x1
  __int64 v32; // x17
  __int64 v33; // t1
  __int64 v34; // x12
  unsigned __int64 v35; // x13
  unsigned __int64 v36; // x14
  __int64 v37; // x15
  unsigned __int64 v38; // x16
  __int64 v39; // x2
  __int64 v40; // x5
  unsigned __int64 v41; // x4
  unsigned __int64 v42; // x10
  __int64 v43; // x14
  __int64 v44; // x6
  __int64 v45; // x16
  __int64 v46; // x3
  __int64 v47; // x4
  __int64 v48; // x19
  __int64 v49; // x7
  unsigned __int64 v50; // x12
  __int64 v51; // x2
  unsigned __int64 v52; // x12
  unsigned __int64 v53; // x9
  unsigned __int64 v54; // x10
  __int64 v55; // x9
  unsigned __int64 v56; // x10
  __int64 v57; // x9
  unsigned __int64 v58; // x8
  unsigned __int64 v59; // x8

  if ( a3 > 0x20 )
  {
    if ( a3 > 0x40 )
    {
      v18 = *(__int64 *)((char *)a2 + a3 - 56);
      v17 = *(__int64 *)((char *)a2 + a3 - 48);
      v19 = *(__int64 *)((char *)a2 + a3 - 24);
      v20 = *(__int64 *)((char *)a2 + a3 - 40);
      v22 = *(__int64 *)((char *)a2 + a3 - 16);
      v21 = *(__int64 *)((char *)a2 + a3 - 8);
      v23 = *(__int64 *)((char *)a2 + a3 - 64) + a3;
      v24 = v18 + v22;
      v25 = (0x9DDFEA08EB382D69LL * (v19 ^ (v17 + a3))) ^ v19 ^ ((0x9DDFEA08EB382D69LL * (v19 ^ (v17 + a3))) >> 47);
      v26 = v23 + v18 + v17;
      v27 = v18 + v22 + *(__int64 *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      v28 = v27 + v19 + v22;
      v29 = 0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * v25) ^ ((0x9DDFEA08EB382D69LL * v25) >> 47));
      v30 = v28 + v21;
      v33 = *a2;
      v31 = a2 + 4;
      v32 = v33;
      v34 = __ROR8__(v28, 44) + v27 + __ROR8__(v27 + v20 + v21, 21);
      v35 = 64 - ((a3 - 1) & 0xFFFFFFFFFFFFFFC0LL);
      v36 = __ROR8__(v26, 44)
          + v23
          + __ROR8__(
              v20 + v23 - 0x622015F714C7D297LL * ((0x9DDFEA08EB382D69LL * v25) ^ ((0x9DDFEA08EB382D69LL * v25) >> 47)),
              21);
      v37 = v26 + v20;
      v38 = v33 - 0x4B6D499041670D8DLL * v20;
      while ( 1 )
      {
        v39 = v31[2];
        v40 = v31[3];
        v41 = v24 + v36;
        v42 = v38 + v37 + v24;
        v43 = v32 - 0x4B6D499041670D8DLL * v36;
        v44 = v31[1];
        v45 = v41 + v39;
        v46 = *(v31 - 3);
        v47 = *(v31 - 2);
        v48 = *(v31 - 1);
        v49 = __ROR8__(v42 + v46, 37);
        v24 = v44 + v37 - 0x4B6D499041670D8DLL * __ROR8__(v45, 42);
        v38 = 0xB492B66FBE98F273LL * __ROR8__(v29 + v30, 33);
        v29 = (0xB492B66FBE98F273LL * v49) ^ v34;
        v50 = v38 + v34 + *v31;
        v51 = v50 + v44 + v39;
        v37 = v43 + v46 + v47 + v48;
        v36 = __ROR8__(v43 + v46 + v47, 44) + v43 + __ROR8__(v43 + v30 + v29 + v48, 21);
        v30 = v51 + v40;
        v34 = __ROR8__(v51, 44) + v50 + __ROR8__(v24 + v47 + v50 + v40, 21);
        if ( !v35 )
          break;
        v32 = v31[4];
        v35 += 64LL;
        v31 += 8;
      }
      v52 = 0x9DDFEA08EB382D69LL
          * ((0x9DDFEA08EB382D69LL * (v34 ^ v36)) ^ v34 ^ ((0x9DDFEA08EB382D69LL * (v34 ^ v36)) >> 47));
      v53 = v29
          - 0x4B6D499041670D8DLL * (v24 ^ (v24 >> 47))
          - 0x622015F714C7D297LL
          * ((0x9DDFEA08EB382D69LL
            * ((0x9DDFEA08EB382D69LL * (v30 ^ v37)) ^ v30 ^ ((0x9DDFEA08EB382D69LL * (v30 ^ v37)) >> 47))) ^ ((0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v30 ^ v37)) ^ v30 ^ ((0x9DDFEA08EB382D69LL * (v30 ^ v37)) >> 47))) >> 47));
      v54 = v38 - 0x622015F714C7D297LL * (v52 ^ (v52 >> 47));
      return 0x9DDFEA08EB382D69LL
           * ((0x9DDFEA08EB382D69LL
             * ((0x9DDFEA08EB382D69LL * (v54 ^ v53)) ^ v54 ^ ((0x9DDFEA08EB382D69LL * (v54 ^ v53)) >> 47))) ^ ((0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v54 ^ v53)) ^ v54 ^ ((0x9DDFEA08EB382D69LL * (v54 ^ v53)) >> 47))) >> 47));
    }
    else
    {
      v3 = *(__int64 *)((char *)a2 + a3 - 16);
      v4 = *a2 - 0x3C5A37A36834CED9LL * (v3 + a3);
      v6 = a2[2];
      v5 = a2[3];
      v7 = *(__int64 *)((char *)a2 + a3 - 32) + v6;
      v8 = v4 + a2[1] + v6;
      v9 = __ROR8__(v4 + a2[1], 7) + __ROR8__(v4, 37) + __ROR8__(v4 + v5, 52) + __ROR8__(v8, 31);
      v10 = 0xC3A5C85C97CB3127LL
          * (*(__int64 *)((char *)a2 + a3 - 24) + v7 + v3 + *(__int64 *)((char *)a2 + a3 - 8) + v5 + v9)
          - 0x651E95C4D06FBFB1LL
          * (v8
           + v5
           + __ROR8__(v7, 37)
           + __ROR8__(*(__int64 *)((char *)a2 + a3 - 24) + v7, 7)
           + __ROR8__(*(__int64 *)((char *)a2 + a3 - 8) + v5 + v7, 52)
           + __ROR8__(*(__int64 *)((char *)a2 + a3 - 24) + v7 + v3, 31));
      return 0x9AE16A3B2F90404FLL
           * ((v9 - 0x3C5A37A36834CED9LL * (v10 ^ (v10 >> 47))) ^ ((v9 - 0x3C5A37A36834CED9LL * (v10 ^ (v10 >> 47))) >> 47));
    }
  }
  else if ( a3 > 0x10 )
  {
    v12 = a2[1];
    v13 = 0xB492B66FBE98F273LL * *a2;
    v14 = __ROR8__(v13 - v12, 43);
    v15 = v13 + a3 + __ROR8__(v12 ^ 0xC949D7C7509E6557LL, 20) - 0x9AE16A3B2F90404FLL * *(__int64 *)((char *)a2 + a3 - 8);
    v16 = 0x9DDFEA08EB382D69LL
        * ((__ROR8__(0x9AE16A3B2F90404FLL * *(__int64 *)((char *)a2 + a3 - 8), 30)
          + v14
          - 0x3C5A37A36834CED9LL * *(__int64 *)((char *)a2 + a3 - 16)) ^ v15);
    return 0x9DDFEA08EB382D69LL
         * ((0x9DDFEA08EB382D69LL * (v16 ^ v15 ^ (v16 >> 47))) ^ ((0x9DDFEA08EB382D69LL * (v16 ^ v15 ^ (v16 >> 47))) >> 47));
  }
  else if ( a3 < 9 )
  {
    if ( a3 < 4 )
    {
      result = 0x9AE16A3B2F90404FLL;
      if ( a3 )
      {
        v59 = (0xC949D7C7509E6557LL * (a3 + 4LL * *((unsigned __int8 *)a2 + a3 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                       * (*(unsigned __int8 *)a2 | ((unsigned __int64)*((unsigned __int8 *)a2 + (a3 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v59 ^ (v59 >> 47));
      }
    }
    else
    {
      v57 = *(unsigned int *)((char *)a2 + a3 - 4);
      v58 = 0x9DDFEA08EB382D69LL * (((unsigned int)(8 * *(_DWORD *)a2) + a3) ^ v57);
      return 0x9DDFEA08EB382D69LL
           * ((0x9DDFEA08EB382D69LL * (v58 ^ v57 ^ (v58 >> 47))) ^ ((0x9DDFEA08EB382D69LL * (v58 ^ v57 ^ (v58 >> 47))) >> 47));
    }
  }
  else
  {
    v55 = *(__int64 *)((char *)a2 + a3 - 8);
    v56 = ((v55 + a3) << -(char)a3) | ((v55 + a3) >> a3);
    return (0x9DDFEA08EB382D69LL
          * ((0x9DDFEA08EB382D69LL
            * ((0x9DDFEA08EB382D69LL * (v56 ^ *a2)) ^ v56 ^ ((0x9DDFEA08EB382D69LL * (v56 ^ *a2)) >> 47))) ^ ((0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v56 ^ *a2)) ^ v56 ^ ((0x9DDFEA08EB382D69LL * (v56 ^ *a2)) >> 47))) >> 47))) ^ v55;
  }
  return result;
}


================================================================================
Function: sub_24EA5A8 (0x24EA5A8)
================================================================================

void __noreturn sub_24EA5A8()
{
  _QWORD *v0; // x0

  v0 = (_QWORD *)sub_67EAFB8(8LL);
  *v0 = off_67F8760;
  sub_67EB030((__int64)v0, (__int64)&`typeinfo for'std::bad_function_call, (__int64)sub_67EE220);
}


================================================================================
Function: sub_24EEE24 (0x24EEE24)
================================================================================

__int64 __fastcall sub_24EEE24(char a1)
{
  int v1; // w8
  __int64 result; // x0

  v1 = a1 - 65;
  result = 1LL;
  switch ( v1 )
  {
    case 0:
      result = 8LL;
      break;
    case 1:
      result = 6LL;
      break;
    case 4:
      result = 10LL;
      break;
    case 5:
      result = 12LL;
      break;
    case 6:
      result = 14LL;
      break;
    case 23:
      result = 4LL;
      break;
    case 32:
      result = 7LL;
      break;
    case 33:
      result = 5LL;
      break;
    case 34:
      result = 15LL;
      break;
    case 35:
      return result;
    case 36:
      result = 9LL;
      break;
    case 37:
      result = 11LL;
      break;
    case 38:
      result = 13LL;
      break;
    case 46:
      result = 2LL;
      break;
    case 47:
      result = 17LL;
      break;
    case 50:
      result = 16LL;
      break;
    case 55:
      result = 3LL;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}


================================================================================
Function: sub_24EF72C (0x24EF72C)
================================================================================

unsigned __int64 __fastcall sub_24EF72C(unsigned int *a1, char a2)
{
  unsigned int v2; // w9
  unsigned __int64 result; // x0
  _BYTE v4[8]; // [xsp+0h] [xbp-10h] BYREF

  v2 = a1[4];
  v4[0] = a2;
  switch ( v2 )
  {
    case 1u:
      result = *a1;
      if ( (result & 0x80000000) != 0 )
        goto LABEL_13;
      return result;
    case 2u:
      result = *a1;
      goto LABEL_9;
    case 3u:
      result = *(_QWORD *)a1;
      if ( (result & 0x8000000000000000LL) != 0 )
        goto LABEL_13;
      goto LABEL_9;
    case 4u:
    case 6u:
      goto LABEL_8;
    case 5u:
      if ( (*((_QWORD *)a1 + 1) & 0x8000000000000000LL) != 0 )
LABEL_13:
        sub_67900C8((__int64)v4, (__int64)"negative width");
LABEL_8:
      result = *(_QWORD *)a1;
LABEL_9:
      if ( result >> 31 )
        sub_67900C8((__int64)v4, (__int64)"number is too big");
      return result;
    default:
      sub_67900C8((__int64)v4, (__int64)"width is not integer");
  }
}


================================================================================
Function: sub_24EF7F8 (0x24EF7F8)
================================================================================

long double __usercall sub_24EF7F8@<Q0>(__int64 *a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, __int64 a4@<X8>)
{
  __int64 v4; // x25
  __int64 v6; // x24
  __int64 v7; // x8
  _QWORD *v8; // x8
  __int64 v9; // x26
  unsigned int *v12; // x27
  const char *v13; // x23
  size_t v14; // x0
  long double result; // q0
  bool v16; // zf
  size_t v17; // x2
  size_t v18; // x22
  __int64 v19; // x8
  __int64 v20; // x8

  v4 = *a1;
  if ( (*a1 & 0x4000000000000000LL) == 0 )
    goto LABEL_21;
  v6 = a1[1];
  v7 = -32LL;
  if ( v4 >= 0 )
    v7 = -16LL;
  v8 = (_QWORD *)(v6 + v7);
  v9 = v8[1];
  if ( !v9 )
    goto LABEL_21;
  v12 = (unsigned int *)(*v8 + 8LL);
  while ( 1 )
  {
    v13 = (const char *)*((_QWORD *)v12 - 1);
    v14 = strlen(v13);
    v16 = v14 == a3;
    if ( v14 >= a3 )
      v17 = a3;
    else
      v17 = v14;
    if ( v17 )
    {
      v18 = v14;
      v16 = !memcmp(v13, a2, v17) && v18 == a3;
    }
    if ( v16 )
      break;
    v12 += 4;
    if ( !--v9 )
      goto LABEL_21;
  }
  v19 = *v12;
  if ( (v19 & 0x80000000) == 0 )
  {
    *(_DWORD *)(a4 + 16) = 0;
    if ( v4 < 0 )
    {
      if ( (int)v19 < (int)v4 )
      {
        v20 = v6 + 32 * v19;
        result = *(long double *)v20;
        LODWORD(v20) = *(_DWORD *)(v20 + 16);
        *(long double *)a4 = result;
        *(_DWORD *)(a4 + 16) = v20;
      }
    }
    else if ( (unsigned int)v19 <= 0xE )
    {
      *(_DWORD *)(a4 + 16) = ((unsigned __int64)v4 >> (4 * (unsigned __int8)v19)) & 0xF;
      if ( (((unsigned __int64)v4 >> (4 * (unsigned __int8)v19)) & 0xF) != 0 )
      {
        result = *(long double *)(v6 + 16 * v19);
        *(long double *)a4 = result;
      }
    }
  }
  else
  {
LABEL_21:
    *(_DWORD *)(a4 + 16) = 0;
  }
  return result;
}


================================================================================
Function: sub_24EF90C (0x24EF90C)
================================================================================

unsigned __int64 __fastcall sub_24EF90C(unsigned int *a1, char a2)
{
  unsigned int v2; // w9
  unsigned __int64 result; // x0
  _BYTE v4[8]; // [xsp+0h] [xbp-10h] BYREF

  v2 = a1[4];
  v4[0] = a2;
  switch ( v2 )
  {
    case 1u:
      result = *a1;
      if ( (result & 0x80000000) != 0 )
        goto LABEL_13;
      return result;
    case 2u:
      result = *a1;
      goto LABEL_9;
    case 3u:
      result = *(_QWORD *)a1;
      if ( (result & 0x8000000000000000LL) != 0 )
        goto LABEL_13;
      goto LABEL_9;
    case 4u:
    case 6u:
      goto LABEL_8;
    case 5u:
      if ( (*((_QWORD *)a1 + 1) & 0x8000000000000000LL) != 0 )
LABEL_13:
        sub_67900C8((__int64)v4, (__int64)"negative precision");
LABEL_8:
      result = *(_QWORD *)a1;
LABEL_9:
      if ( result >> 31 )
        sub_67900C8((__int64)v4, (__int64)"number is too big");
      return result;
    default:
      sub_67900C8((__int64)v4, (__int64)"precision is not integer");
  }
}


================================================================================
Function: sub_24EF9D8 (0x24EF9D8)
================================================================================

__int64 __fastcall sub_24EF9D8(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, _DWORD *a4)
{
  unsigned __int64 v7; // x8
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x24
  __int64 v12; // x24
  _DWORD *v13; // x25
  __int64 v14; // x0
  __int64 v15; // x8
  __int64 v16; // x3
  _QWORD v18[2]; // [xsp+8h] [xbp-28h] BYREF
  __int64 v19; // [xsp+18h] [xbp-18h] BYREF
  _DWORD v20[2]; // [xsp+20h] [xbp-10h] BYREF

  v7 = (unsigned int)a4[1];
  if ( a3 <= v7 || (int)v7 <= -1 )
    v9 = a3;
  else
    v9 = (unsigned int)a4[1];
  if ( *a4 )
  {
    v10 = a2;
    v19 = 0LL;
    v18[0] = &v19;
    if ( v9 >= 4 )
    {
      v10 = a2;
      v11 = a2 + v9 - 3;
      while ( v10 < v11 )
      {
        v10 = sub_24EFD2C(v18, v10, v10);
        if ( !v10 )
          goto LABEL_17;
      }
    }
    v12 = a2 + v9 - v10;
    if ( a2 + v9 != v10 )
    {
      *(_DWORD *)((char *)v20 + 3) = 0;
      v20[0] = 0;
      __memcpy_chk();
      v13 = v20;
      do
      {
        v14 = sub_24EFD2C(v18, v13, v10);
        if ( !v14 )
          break;
        v15 = v14 - (_QWORD)v13;
        v13 = (_DWORD *)v14;
        v10 += v15;
      }
      while ( v14 - (__int64)v20 < v12 );
    }
LABEL_17:
    v16 = v19;
  }
  else
  {
    v16 = 0LL;
  }
  v18[0] = a2;
  v18[1] = v9;
  return sub_24EFB28(a1, a4, v9, v16, v18);
}


================================================================================
Function: sub_24EFB28 (0x24EFB28)
================================================================================

__int64 __fastcall sub_24EFB28(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 *a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x19
  _BYTE *v8; // x20
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x21
  unsigned __int64 v12; // x8
  __int64 v13; // x21
  unsigned __int64 v14; // x22
  __int64 v15; // x10
  __int64 v16; // x23
  __int64 v17; // x24
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x12
  unsigned __int64 v20; // x8
  __int64 v21; // x11
  _BYTE *v22; // x9
  char *v23; // x13
  unsigned __int64 v24; // x14
  __int64 v25; // x15
  _OWORD *v26; // x13
  __int128 *v27; // x14
  unsigned __int64 v28; // x16
  __int128 v29; // q0
  __int128 v30; // q1
  __int64 *v31; // x16
  _QWORD *v32; // x11
  __int64 v33; // x15
  __int64 v34; // t1
  char v35; // t1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_D13B50[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_24EFF44(a1, v10 >> v9, v8);
  v12 = a5[1];
  v13 = v10 - v11;
  if ( v12 )
  {
    v14 = *a5;
    v15 = *(_QWORD *)(v7 + 16);
    v16 = v14 + v12;
    v17 = v12 + v14;
    do
    {
      v18 = *(_QWORD *)(v7 + 24);
      if ( v18 < v16 - v14 + v15 )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v15 = *(_QWORD *)(v7 + 16);
        v18 = *(_QWORD *)(v7 + 24);
      }
      v19 = v18 - v15;
      if ( v18 - v15 >= v16 - v14 )
        v20 = v16 - v14;
      else
        v20 = v18 - v15;
      if ( !v20 )
        goto LABEL_9;
      v21 = *(_QWORD *)(v7 + 8);
      v22 = (_BYTE *)(v21 + v15);
      if ( v20 >= 8 )
      {
        if ( (unsigned __int64)v22 >= v14 + v20 || (v24 = v20, v23 = (char *)v14, v14 >= v21 + v15 + v20) )
        {
          if ( v20 < 0x20 )
          {
            v25 = 0LL;
LABEL_26:
            v31 = (__int64 *)(v14 + v25);
            if ( v17 - v14 < v19 )
              v19 = v17 - v14;
            v32 = (_QWORD *)(v21 + v15 + v25);
            v23 = (char *)(v14 + (v19 & 0xFFFFFFFFFFFFFFF8LL));
            v22 += v19 & 0xFFFFFFFFFFFFFFF8LL;
            v24 = v20 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            v33 = v25 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v34 = *v31++;
              v33 += 8LL;
              *v32++ = v34;
            }
            while ( v33 );
            if ( v19 == (v19 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_8;
            goto LABEL_33;
          }
          v25 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          v26 = (_OWORD *)(v21 + v15 + 16);
          v27 = (__int128 *)(v14 + 16);
          v28 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v29 = *(v27 - 1);
            v30 = *v27;
            v27 += 2;
            v28 -= 32LL;
            *(v26 - 1) = v29;
            *v26 = v30;
            v26 += 2;
          }
          while ( v28 );
          if ( v20 == v25 )
            goto LABEL_8;
          if ( (v20 & 0x18) != 0 )
            goto LABEL_26;
          v24 = v20 & 0x1F;
          v22 += v25;
          v23 = (char *)(v14 + v25);
        }
      }
      else
      {
        v23 = (char *)v14;
        v24 = v20;
      }
      do
      {
LABEL_33:
        v35 = *v23++;
        --v24;
        *v22++ = v35;
      }
      while ( v24 );
LABEL_8:
      v15 = *(_QWORD *)(v7 + 16);
LABEL_9:
      v15 += v20;
      v14 += v20;
      *(_QWORD *)(v7 + 16) = v15;
    }
    while ( v14 != v16 );
  }
  result = v7;
  if ( v13 )
    return sub_24EFF44(v7, v13, v8);
  return result;
}


================================================================================
Function: sub_24EFD2C (0x24EFD2C)
================================================================================

char *__fastcall sub_24EFD2C(_QWORD **a1, unsigned __int8 *a2)
{
  unsigned int v2; // w13
  unsigned int v3; // w15
  unsigned int v4; // w17
  unsigned __int64 v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w10
  __int64 v9; // x11
  int32x4_t v10; // q1
  unsigned __int64 v11; // d0
  _QWORD *v12; // x9
  char *result; // x0

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = ((0x80FF0000uLL >> (*a2 >> 3)) & 1) + byte_D13A40[*a2 >> 3];
  v6 = (((dword_D13B00[v5] & (char)*a2) << 18) | ((v2 & 0x3F) << 12) | ((v3 & 0x3F) << 6) | v4 & 0x3F) >> dword_D13B28[v5];
  if ( (((v3 >> 4) & 0xC | (v2 >> 2) & 0x30 | (v4 >> 6) & 0xFFFFFE3F | ((v6 < dword_D13B14[v5]) << 6) & 0x7F | ((HIWORD(v6) > 0x10u) << 8) | ((v6 >> 11 == 27) << 7)) ^ 0x2A) >> dword_D13B3C[v5] )
    v7 = -1;
  else
    v7 = (((dword_D13B00[v5] & (char)*a2) << 18) | ((v2 & 0x3F) << 12) | ((v3 & 0x3F) << 6) | v4 & 0x3F) >> dword_D13B28[v5];
  if ( v7 >> 8 < 0x11 )
  {
    v9 = 1LL;
  }
  else if ( v7 >> 5 >= 0x8B && v7 - 9001 >= 2 )
  {
    v10 = vdupq_n_s32(v7);
    v11 = vmovn_s16(
            vuzp1q_s16(
              vcgtq_u32((uint32x4_t)xmmword_AF5F70, vaddq_s32(v10, (int32x4_t)xmmword_AF8170)),
              vcgtq_u32((uint32x4_t)xmmword_AF7270, vaddq_s32(v10, (int32x4_t)xmmword_AFDA70)))).n64_u64[0];
    v9 = 2LL;
    if ( !(v11 & 1 | (unsigned __int8)(2 * (BYTE1(v11) & 1)) & 0xC3 | (unsigned __int8)(4 * (BYTE2(v11) & 1)) & 0xC7 | (unsigned __int8)(8 * (BYTE3(v11) & 1)) & 0xCF | (unsigned __int8)(16 * (BYTE4(v11) & 1)) & 0xDF | (unsigned __int8)(32 * (BYTE5(v11) & 1)) | ((BYTE6(v11) & 1u) << 6) | (unsigned __int8)(HIBYTE(v11) << 7))
      && (v7 - 44032) >> 2 >= 0xAE9
      && (v7 == 12351 || (v7 - 11904) >> 4 >= 0x765) )
    {
      if ( v7 >> 8 == 505 )
        v9 = 2LL;
      else
        v9 = 1LL;
    }
  }
  else
  {
    v9 = 2LL;
  }
  v12 = *a1;
  result = (char *)&a2[v5];
  *v12 += v9;
  return result;
}


================================================================================
Function: sub_24EFF44 (0x24EFF44)
================================================================================

__int64 __fastcall sub_24EFF44(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 v3; // x22
  __int64 v5; // x20
  char v7; // w9
  __int64 v8; // x10
  __int64 v9; // x8
  __int64 v10; // x1
  __int64 v11; // x23
  _BYTE *v12; // x24
  __int64 v13; // x10
  _BYTE *v14; // x25
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x26
  unsigned __int64 v17; // x12
  unsigned __int64 v18; // x8
  __int64 v19; // x11
  _BYTE *v20; // x9
  char *v21; // x13
  unsigned __int64 v22; // x14
  __int64 v23; // x15
  _OWORD *v24; // x13
  __int128 *v25; // x14
  unsigned __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  _QWORD *v29; // x11
  __int64 *v30; // x16
  __int64 v31; // x15
  __int64 v32; // t1
  char v33; // t1

  v3 = (unsigned __int8)a3[4];
  v5 = a2;
  if ( (_DWORD)v3 != 1 )
  {
    if ( !a2 )
      return a1;
    v11 = 0LL;
    v12 = &a3[v3];
    while ( !(_DWORD)v3 )
    {
LABEL_9:
      if ( ++v11 == v5 )
        return a1;
    }
    v13 = *(_QWORD *)(a1 + 16);
    v14 = a3;
    while ( 1 )
    {
      v15 = *(_QWORD *)(a1 + 24);
      v16 = v12 - v14;
      if ( v15 < v12 - v14 + v13 )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v13 = *(_QWORD *)(a1 + 16);
        v15 = *(_QWORD *)(a1 + 24);
      }
      v17 = v15 - v13;
      if ( v15 - v13 >= v16 )
        v18 = v12 - v14;
      else
        v18 = v15 - v13;
      if ( !v18 )
        goto LABEL_13;
      v19 = *(_QWORD *)(a1 + 8);
      v20 = (_BYTE *)(v19 + v13);
      if ( v18 >= 8 )
      {
        if ( v20 >= &v14[v18] || (v22 = v18, v21 = v14, (unsigned __int64)v14 >= v19 + v13 + v18) )
        {
          if ( v18 < 0x20 )
          {
            v23 = 0LL;
LABEL_30:
            if ( v16 < v17 )
              v17 = v12 - v14;
            v29 = (_QWORD *)(v19 + v13 + v23);
            v30 = (__int64 *)&v14[v23];
            v21 = &v14[v17 & 0xFFFFFFFFFFFFFFF8LL];
            v20 += v17 & 0xFFFFFFFFFFFFFFF8LL;
            v22 = v18 - (v17 & 0xFFFFFFFFFFFFFFF8LL);
            v31 = v23 - (v17 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v32 = *v30++;
              v31 += 8LL;
              *v29++ = v32;
            }
            while ( v31 );
            if ( v17 == (v17 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_12;
            goto LABEL_37;
          }
          v23 = v18 & 0xFFFFFFFFFFFFFFE0LL;
          v24 = (_OWORD *)(v19 + v13 + 16);
          v25 = (__int128 *)(v14 + 16);
          v26 = v18 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v27 = *(v25 - 1);
            v28 = *v25;
            v25 += 2;
            v26 -= 32LL;
            *(v24 - 1) = v27;
            *v24 = v28;
            v24 += 2;
          }
          while ( v26 );
          if ( v18 == v23 )
            goto LABEL_12;
          if ( (v18 & 0x18) != 0 )
            goto LABEL_30;
          v22 = v18 & 0x1F;
          v20 += v23;
          v21 = &v14[v23];
        }
      }
      else
      {
        v21 = v14;
        v22 = v18;
      }
      do
      {
LABEL_37:
        v33 = *v21++;
        --v22;
        *v20++ = v33;
      }
      while ( v22 );
LABEL_12:
      v13 = *(_QWORD *)(a1 + 16);
LABEL_13:
      v13 += v18;
      v14 += v18;
      *(_QWORD *)(a1 + 16) = v13;
      if ( v14 == v12 )
        goto LABEL_9;
    }
  }
  if ( a2 )
  {
    do
    {
      v9 = *(_QWORD *)(a1 + 16);
      v10 = v9 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v9 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v9 = *(_QWORD *)(a1 + 16);
        v10 = v9 + 1;
      }
      --v5;
      v7 = *a3;
      v8 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v10;
      *(_BYTE *)(v8 + v9) = v7;
    }
    while ( v5 );
  }
  return a1;
}


================================================================================
Function: sub_2502DA8 (0x2502DA8)
================================================================================

__int64 __fastcall sub_2502DA8(__int64 result)
{
  _BYTE *v1; // x19

  v1 = (_BYTE *)result;
  if ( (*(_BYTE *)(result + 24) & 1) != 0 )
    result = sub_6575460();
  if ( (*v1 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_2507BE0 (0x2507BE0)
================================================================================

__int64 __fastcall sub_2507BE0(unsigned __int64 **a1, __int128 *a2)
{
  unsigned __int64 v3; // x21
  unsigned __int64 v4; // x9
  unsigned __int64 v6; // x23
  __int64 v7; // x0
  unsigned __int64 *v8; // x21
  unsigned __int64 v9; // x23
  __int64 result; // x0
  unsigned __int64 *v11; // x8
  unsigned __int64 *v12; // x10
  unsigned __int64 *v13; // x9
  __int128 v14; // q0
  bool v15; // zf
  unsigned __int64 *v16; // x20
  unsigned __int64 *v17; // x19
  char v18; // t1

  v3 = 0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1);
  v4 = v3 + 1;
  if ( v3 + 1 > 0xAAAAAAAAAAAAAAALL )
    sub_67D6BD4();
  if ( 0x5555555555555556LL * (a1[2] - *a1) >= v4 )
    v4 = 0x5555555555555556LL * (a1[2] - *a1);
  if ( 0xAAAAAAAAAAAAAAABLL * (a1[2] - *a1) >= 0x555555555555555LL )
    v6 = 0xAAAAAAAAAAAAAAALL;
  else
    v6 = v4;
  if ( v6 )
  {
    if ( v6 > 0xAAAAAAAAAAAAAAALL )
      sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    v7 = sub_6575418();
  }
  else
  {
    v7 = 0LL;
  }
  v8 = (unsigned __int64 *)(v7 + 24 * v3);
  v9 = v7 + 24 * v6;
  result = (__int64)sub_67D2788(v8, a2);
  v11 = *a1;
  v12 = a1[1];
  v13 = v8 + 3;
  if ( v12 == *a1 )
  {
    v16 = *a1;
  }
  else
  {
    do
    {
      v14 = *(_OWORD *)(v12 - 3);
      *(v8 - 1) = *(v12 - 1);
      *(_OWORD *)(v8 - 3) = v14;
      v8 -= 3;
      *(v12 - 2) = 0LL;
      *(v12 - 1) = 0LL;
      v15 = v12 - 3 == v11;
      *(v12 - 3) = 0LL;
      v12 -= 3;
    }
    while ( !v15 );
    v16 = *a1;
    v11 = a1[1];
  }
  *a1 = v8;
  a1[1] = v13;
  a1[2] = (unsigned __int64 *)v9;
  if ( v11 != v16 )
  {
    v17 = v11;
    do
    {
      v18 = *((_BYTE *)v17 - 24);
      v17 -= 3;
      if ( (v18 & 1) != 0 )
        result = sub_6575460();
    }
    while ( v17 != v16 );
  }
  if ( v16 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_2507ED0 (0x2507ED0)
================================================================================

__int64 __fastcall sub_2507ED0(__int64 result, __int64 a2)
{
  __int64 v2; // x9
  __int64 v3; // x8
  __int64 *v4; // x11
  _BYTE *v5; // x11
  int v6; // t1
  __int64 v7; // x11
  int v8; // t1
  __int64 *v9; // x10
  __int64 v10; // x11
  __int64 v11; // x10
  __int64 *v12; // x9
  __int64 v13; // x10
  __int64 **v14; // x10
  __int64 v15; // x11

  *(_BYTE *)(a2 + 24) = a2 == result;
  if ( a2 != result )
  {
    do
    {
      v2 = *(_QWORD *)(a2 + 16);
      if ( *(_BYTE *)(v2 + 24) )
        return result;
      v3 = *(_QWORD *)(v2 + 16);
      v4 = *(__int64 **)v3;
      if ( *(_QWORD *)v3 == v2 )
      {
        v7 = *(_QWORD *)(v3 + 8);
        if ( !v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8) )
        {
          if ( *(_QWORD *)v2 == a2 )
          {
            v9 = *(__int64 **)(a2 + 16);
          }
          else
          {
            v9 = *(__int64 **)(v2 + 8);
            v10 = *v9;
            *(_QWORD *)(v2 + 8) = *v9;
            if ( v10 )
            {
              *(_QWORD *)(v10 + 16) = v2;
              v3 = *(_QWORD *)(v2 + 16);
            }
            v9[2] = v3;
            *(_QWORD *)(*(_QWORD *)(v2 + 16) + 8LL * (**(_QWORD **)(v2 + 16) != v2)) = v9;
            *(_QWORD *)(v2 + 16) = v9;
            v3 = v9[2];
            *v9 = v2;
          }
          v12 = *(__int64 **)v3;
          v15 = *(_QWORD *)(*(_QWORD *)v3 + 8LL);
          *((_BYTE *)v9 + 24) = 1;
          *(_BYTE *)(v3 + 24) = 0;
          *(_QWORD *)v3 = v15;
          if ( v15 )
            *(_QWORD *)(v15 + 16) = v3;
          v14 = (__int64 **)(v3 + 16);
          v12[2] = *(_QWORD *)(v3 + 16);
          *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8LL * (**(_QWORD **)(v3 + 16) != v3)) = v12;
          v12[1] = v3;
          goto LABEL_27;
        }
      }
      else if ( !v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6) )
      {
        if ( *(_QWORD *)v2 == a2 )
        {
          v11 = *(_QWORD *)(a2 + 8);
          *(_QWORD *)v2 = v11;
          if ( v11 )
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = *(_QWORD *)(v2 + 16);
          }
          *(_QWORD *)(a2 + 16) = v3;
          *(_QWORD *)(*(_QWORD *)(v2 + 16) + 8LL * (**(_QWORD **)(v2 + 16) != v2)) = a2;
          *(_QWORD *)(v2 + 16) = a2;
          v3 = *(_QWORD *)(a2 + 16);
          *(_QWORD *)(a2 + 8) = v2;
        }
        else
        {
          a2 = *(_QWORD *)(a2 + 16);
        }
        v12 = *(__int64 **)(v3 + 8);
        v13 = *v12;
        *(_BYTE *)(a2 + 24) = 1;
        *(_BYTE *)(v3 + 24) = 0;
        *(_QWORD *)(v3 + 8) = v13;
        if ( v13 )
          *(_QWORD *)(v13 + 16) = v3;
        v14 = (__int64 **)(v3 + 16);
        v12[2] = *(_QWORD *)(v3 + 16);
        *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8LL * (**(_QWORD **)(v3 + 16) != v3)) = v12;
        *v12 = v3;
LABEL_27:
        *v14 = v12;
        return result;
      }
      a2 = *(_QWORD *)(v2 + 16);
      *(_BYTE *)(v2 + 24) = 1;
      *(_BYTE *)(v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while ( v3 != result );
  }
  return result;
}


================================================================================
Function: sub_250A6BC (0x250A6BC)
================================================================================

void __fastcall sub_250A6BC(__int64 a1, _QWORD *a2)
{
  _QWORD *v3; // x9
  __int64 v4; // x8
  __int64 v5; // x1
  __int64 v6; // x0
  __int64 v7; // x0
  _QWORD *v8; // x20
  _QWORD *v9; // x22
  __int64 v10; // x0
  __int64 v11; // x0
  __int64 v12; // x0
  __int64 v13; // x0
  __int64 v14; // x20
  __int64 v15; // x21
  char v16; // t1
  __int64 v17; // x20
  __int64 v18; // x21
  __int64 v19; // x22
  __int64 v20; // x20
  __int64 v21; // x21
  char v22; // t1
  __int64 v23; // x20
  __int64 v24; // x21
  char v25; // t1
  __int64 v26; // x20
  __int64 v27; // x21
  char v28; // t1

  v3 = (_QWORD *)(*a2 - 344LL);
  *(_QWORD *)a1 = *a2;
  v4 = a2[1];
  v5 = *(_QWORD *)(a1 + 424);
  *(_QWORD *)(a1 + *v3) = v4;
  sub_250A990(a1 + 408, v5);
  v6 = *(_QWORD *)(a1 + 408);
  *(_QWORD *)(a1 + 408) = 0LL;
  if ( v6 )
    sub_6575460();
  if ( *(_BYTE *)(a1 + 392) && (*(_BYTE *)(a1 + 368) & 1) != 0 )
    sub_6575460();
  if ( *(_BYTE *)(a1 + 360) && (*(_BYTE *)(a1 + 336) & 1) != 0 )
    sub_6575460();
  sub_250AA34(a1 + 296, *(_QWORD *)(a1 + 312));
  v7 = *(_QWORD *)(a1 + 296);
  *(_QWORD *)(a1 + 296) = 0LL;
  if ( v7 )
    v7 = sub_6575460();
  v8 = *(_QWORD **)(a1 + 272);
  if ( v8 )
  {
    do
    {
      v9 = (_QWORD *)*v8;
      sub_250AAC8(v7, a1 + 272, v8 + 2);
      v7 = sub_6575460();
      v8 = v9;
    }
    while ( v9 );
  }
  v10 = *(_QWORD *)(a1 + 256);
  *(_QWORD *)(a1 + 256) = 0LL;
  if ( v10 )
    sub_6575460();
  sub_250AB58(a1 + 216, *(_QWORD *)(a1 + 232));
  v11 = *(_QWORD *)(a1 + 216);
  *(_QWORD *)(a1 + 216) = 0LL;
  if ( v11 )
    sub_6575460();
  sub_250ABEC(a1 + 176, *(_QWORD *)(a1 + 192));
  v12 = *(_QWORD *)(a1 + 176);
  *(_QWORD *)(a1 + 176) = 0LL;
  if ( v12 )
    sub_6575460();
  sub_250AC80(a1 + 136, *(_QWORD *)(a1 + 152));
  v13 = *(_QWORD *)(a1 + 136);
  *(_QWORD *)(a1 + 136) = 0LL;
  if ( v13 )
    sub_6575460();
  v14 = *(_QWORD *)(a1 + 112);
  if ( v14 )
  {
    if ( *(_QWORD *)(a1 + 120) != v14 )
    {
      v15 = *(_QWORD *)(a1 + 120);
      do
      {
        v16 = *(_BYTE *)(v15 - 32);
        v15 -= 32LL;
        if ( (v16 & 1) != 0 )
          sub_6575460();
      }
      while ( v15 != v14 );
    }
    *(_QWORD *)(a1 + 120) = v14;
    sub_6575460();
  }
  v17 = *(_QWORD *)(a1 + 88);
  if ( v17 )
  {
    v18 = *(_QWORD *)(a1 + 96);
    if ( v18 != v17 )
    {
      do
      {
        if ( (*(_BYTE *)(v18 - 24) & 1) != 0 )
          sub_6575460();
        v19 = v18 - 48;
        if ( (*(_BYTE *)(v18 - 48) & 1) != 0 )
          sub_6575460();
        v18 -= 48LL;
      }
      while ( v19 != v17 );
    }
    *(_QWORD *)(a1 + 96) = v17;
    sub_6575460();
  }
  v20 = *(_QWORD *)(a1 + 64);
  if ( v20 )
  {
    if ( *(_QWORD *)(a1 + 72) != v20 )
    {
      v21 = *(_QWORD *)(a1 + 72);
      do
      {
        v22 = *(_BYTE *)(v21 - 32);
        v21 -= 32LL;
        if ( (v22 & 1) != 0 )
          sub_6575460();
      }
      while ( v21 != v20 );
    }
    *(_QWORD *)(a1 + 72) = v20;
    sub_6575460();
  }
  v23 = *(_QWORD *)(a1 + 40);
  if ( v23 )
  {
    if ( *(_QWORD *)(a1 + 48) != v23 )
    {
      v24 = *(_QWORD *)(a1 + 48);
      do
      {
        v25 = *(_BYTE *)(v24 - 32);
        v24 -= 32LL;
        if ( (v25 & 1) != 0 )
          sub_6575460();
      }
      while ( v24 != v23 );
    }
    *(_QWORD *)(a1 + 48) = v23;
    sub_6575460();
  }
  v26 = *(_QWORD *)(a1 + 16);
  if ( v26 )
  {
    if ( *(_QWORD *)(a1 + 24) != v26 )
    {
      v27 = *(_QWORD *)(a1 + 24);
      do
      {
        v28 = *(_BYTE *)(v27 - 32);
        v27 -= 32LL;
        if ( (v28 & 1) != 0 )
          sub_6575460();
      }
      while ( v27 != v26 );
    }
    *(_QWORD *)(a1 + 24) = v26;
    sub_6575460();
  }
  nullsub_257();
}


================================================================================
Function: sub_250A990 (0x250A990)
================================================================================

__int64 __fastcall sub_250A990(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 *v4; // x21
  __int64 *v5; // x20
  __int64 *v6; // x22
  char v7; // t1

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = v2[5];
      v5 = *v2;
      if ( v4 )
      {
        if ( v2[6] != v4 )
        {
          v6 = v2[6];
          do
          {
            v7 = *((_BYTE *)v6 - 24);
            v6 -= 3;
            if ( (v7 & 1) != 0 )
              sub_6575460();
          }
          while ( v6 != v4 );
        }
        v2[6] = v4;
        sub_6575460();
      }
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_6575460();
      result = sub_6575460();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_250AA34 (0x250AA34)
================================================================================

__int64 __fastcall sub_250AA34(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_6575460();
          sub_6575460();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_6575460();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_6575460();
      result = sub_6575460();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_250AAC8 (0x250AAC8)
================================================================================

__int64 __fastcall sub_250AAC8(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 **v4; // x20
  __int64 result; // x0
  __int64 *v6; // x21

  v4 = *(__int64 ***)(a3 + 40);
  if ( v4 )
  {
    do
    {
      v6 = *v4;
      if ( ((_BYTE)v4[5] & 1) != 0 )
        sub_6575460();
      if ( ((_BYTE)v4[2] & 1) != 0 )
        sub_6575460();
      sub_6575460();
      v4 = (__int64 **)v6;
    }
    while ( v6 );
  }
  result = *(_QWORD *)(a3 + 24);
  *(_QWORD *)(a3 + 24) = 0LL;
  if ( result )
    result = sub_6575460();
  if ( (*(_BYTE *)a3 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_250AB58 (0x250AB58)
================================================================================

__int64 __fastcall sub_250AB58(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_6575460();
          sub_6575460();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_6575460();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_6575460();
      result = sub_6575460();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_250ABEC (0x250ABEC)
================================================================================

__int64 __fastcall sub_250ABEC(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_6575460();
          sub_6575460();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_6575460();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_6575460();
      result = sub_6575460();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_250AC80 (0x250AC80)
================================================================================

__int64 __fastcall sub_250AC80(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_6575460();
          sub_6575460();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_6575460();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_6575460();
      result = sub_6575460();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_250E098 (0x250E098)
================================================================================

__int64 **__fastcall sub_250E098(_QWORD *a1, unsigned __int8 *a2)
{
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x8
  bool v6; // zf
  unsigned __int64 v7; // x8
  __int64 *v8; // x1
  unsigned __int64 v9; // x2
  unsigned __int64 v10; // x0
  int8x8_t v11; // x24
  unsigned __int64 v12; // x19
  uint8x8_t v13; // d0
  unsigned __int64 v14; // x25
  unsigned __int64 v15; // x26
  __int64 ***v16; // x8
  size_t v17; // x10
  unsigned __int8 *v18; // x11
  unsigned __int8 *v19; // x12
  unsigned __int64 v20; // x9
  __int64 **v21; // x20
  size_t v22; // x21
  unsigned __int8 *v23; // x22
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x10
  unsigned __int64 v26; // x11
  __int64 *v27; // x0
  __int64 v28; // x9
  __int64 v30; // [xsp+0h] [xbp-10h] BYREF

  v4 = *((_QWORD *)a2 + 1);
  v5 = *a2;
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
    v8 = (__int64 *)(a2 + 1);
  else
    v8 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v6 )
    v9 = v7;
  else
    v9 = v4;
  v10 = sub_24DF128((__int64)&v30, v8, v9);
  v11.n64_u64[0] = a1[1];
  if ( !v11.n64_u64[0] )
    return 0LL;
  v12 = v10;
  v13.n64_u64[0] = vcnt_s8(v11).n64_u64[0];
  v13.n64_u16[0] = vaddlv_u8(v13);
  v14 = v13.n64_u32[0];
  if ( v13.n64_u32[0] > 1uLL )
  {
    v15 = v10;
    if ( v10 >= v11.n64_u64[0] )
      v15 = v10 % v11.n64_u64[0];
  }
  else
  {
    v15 = (v11.n64_u64[0] - 1) & v10;
  }
  v16 = *(__int64 ****)(*a1 + 8 * v15);
  if ( !v16 )
    return 0LL;
  v17 = *((_QWORD *)a2 + 1);
  v18 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  v19 = a2 + 1;
  v20 = *a2;
  v21 = *v16;
  if ( (v20 & 1) != 0 )
    v22 = v17;
  else
    v22 = v20 >> 1;
  if ( (v20 & 1) != 0 )
    v23 = v18;
  else
    v23 = v19;
  for ( ; v21; v21 = (__int64 **)*v21 )
  {
    v24 = (unsigned __int64)v21[1];
    if ( v24 == v12 )
    {
      v25 = *((unsigned __int8 *)v21 + 16);
      v26 = (unsigned __int64)v21[3];
      if ( (v25 & 1) == 0 )
        v26 = v25 >> 1;
      if ( v26 == v22 )
      {
        if ( (v25 & 1) != 0 )
          v27 = v21[4];
        else
          v27 = (__int64 *)((char *)v21 + 17);
        if ( (v25 & 1) != 0 )
        {
          if ( !v22 || !memcmp(v27, v23, v22) )
            return v21;
        }
        else
        {
          if ( !v22 )
            return v21;
          v28 = 0LL;
          while ( *((unsigned __int8 *)v21 + v28 + 17) == v23[v28] )
          {
            if ( v25 >> 1 == ++v28 )
              return v21;
          }
        }
      }
    }
    else
    {
      if ( v14 <= 1 )
      {
        v24 &= v11.n64_u64[0] - 1;
      }
      else if ( v24 >= v11.n64_u64[0] )
      {
        v24 %= v11.n64_u64[0];
      }
      if ( v24 != v15 )
        return 0LL;
    }
  }
  return v21;
}


================================================================================
Function: sub_250E25C (0x250E25C)
================================================================================

__int64 **__fastcall sub_250E25C(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3, __int64 *a4)
{
  unsigned __int64 v4; // x27
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  bool v10; // zf
  unsigned __int64 v11; // x8
  __int64 *v12; // x1
  unsigned __int64 v13; // x2
  unsigned __int64 v14; // x0
  unsigned __int64 v15; // x20
  unsigned __int64 v16; // x26
  uint8x8_t v17; // d0
  unsigned __int64 v18; // x28
  __int64 ***v19; // x8
  unsigned __int64 v20; // x10
  unsigned __int8 *v21; // x11
  unsigned __int8 *v22; // x12
  unsigned __int64 v23; // x9
  __int64 **v24; // x22
  size_t v25; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x11
  __int64 *v30; // x0
  __int64 v31; // x9
  __int64 v32; // x0
  __int64 v33; // x8
  __int64 v34; // x9
  __int64 v35; // x8
  float v36; // s1
  float v37; // s0
  _BOOL8 v38; // x9
  unsigned __int64 v39; // x10
  unsigned __int64 v40; // x1
  _QWORD *v41; // x8
  __int64 v42; // x9
  unsigned __int64 v43; // x9
  _QWORD v45[2]; // [xsp+0h] [xbp-20h] BYREF
  char v46; // [xsp+10h] [xbp-10h]

  v8 = *((_QWORD *)a2 + 1);
  v9 = *a2;
  v10 = (v9 & 1) == 0;
  v11 = v9 >> 1;
  if ( v10 )
    v12 = (__int64 *)(a2 + 1);
  else
    v12 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v10 )
    v13 = v11;
  else
    v13 = v8;
  v14 = sub_24DF128((__int64)v45, v12, v13);
  v15 = v14;
  v16 = *(_QWORD *)(a1 + 8);
  if ( v16 )
  {
    v17.n64_u64[0] = vcnt_s8((int8x8_t)v16).n64_u64[0];
    v17.n64_u16[0] = vaddlv_u8(v17);
    v18 = v17.n64_u32[0];
    if ( v17.n64_u32[0] > 1uLL )
    {
      v4 = v14;
      if ( v14 >= v16 )
        v4 = v14 % v16;
    }
    else
    {
      v4 = (v16 - 1) & v14;
    }
    v19 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v4);
    if ( v19 )
    {
      v20 = *((_QWORD *)a2 + 1);
      v21 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v22 = a2 + 1;
      v23 = *a2;
      v24 = *v19;
      v25 = (v23 & 1) != 0 ? v20 : v23 >> 1;
      for ( i = (v23 & 1) != 0 ? v21 : v22; v24; v24 = (__int64 **)*v24 )
      {
        v27 = (unsigned __int64)v24[1];
        if ( v27 != v15 )
        {
          if ( v18 > 1 )
          {
            if ( v27 >= v16 )
              v27 %= v16;
          }
          else
          {
            v27 &= v16 - 1;
          }
          if ( v27 != v4 )
            break;
        }
        v28 = *((unsigned __int8 *)v24 + 16);
        v29 = (unsigned __int64)v24[3];
        if ( (v28 & 1) == 0 )
          v29 = v28 >> 1;
        if ( v29 == v25 )
        {
          if ( (v28 & 1) != 0 )
            v30 = v24[4];
          else
            v30 = (__int64 *)((char *)v24 + 17);
          if ( (v28 & 1) != 0 )
          {
            if ( !v25 || !memcmp(v30, i, v25) )
              return v24;
          }
          else
          {
            if ( !v25 )
              return v24;
            v31 = 0LL;
            while ( *((unsigned __int8 *)v24 + v31 + 17) == i[v31] )
            {
              if ( v28 >> 1 == ++v31 )
                return v24;
            }
          }
        }
      }
    }
  }
  v32 = sub_6575418();
  v33 = *a4;
  v45[0] = v32;
  v45[1] = a1 + 16;
  v34 = *(_QWORD *)(v33 + 16);
  *(_OWORD *)(v32 + 16) = *(_OWORD *)v33;
  *(_QWORD *)(v32 + 32) = v34;
  *(_QWORD *)(v33 + 8) = 0LL;
  *(_QWORD *)(v33 + 16) = 0LL;
  *(_QWORD *)v33 = 0LL;
  v35 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v32 + 48) = 0LL;
  *(_QWORD *)(v32 + 56) = 0LL;
  v36 = *(float *)(a1 + 32);
  *(_QWORD *)(v32 + 40) = 0LL;
  v46 = 1;
  *(_QWORD *)v32 = 0LL;
  *(_QWORD *)(v32 + 8) = v15;
  v37 = (float)(unsigned __int64)(v35 + 1);
  if ( !v16 || (float)(v36 * (float)v16) < v37 )
  {
    v38 = v16 < 3 || (v16 & (v16 - 1)) != 0;
    v39 = vcvtps_u32_f32(v37 / v36);
    if ( (v38 | (2 * v16)) >= v39 )
      v40 = v38 | (2 * v16);
    else
      v40 = v39;
    sub_250E5AC(a1, v40);
    v16 = *(_QWORD *)(a1 + 8);
    if ( (v16 & (v16 - 1)) != 0 )
    {
      if ( v15 >= v16 )
        v4 = v15 % v16;
      else
        v4 = v15;
    }
    else
    {
      v4 = (v16 - 1) & v15;
    }
  }
  v41 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if ( v41 )
  {
    *(_QWORD *)v45[0] = *v41;
    *v41 = v45[0];
  }
  else
  {
    *(_QWORD *)v45[0] = *(_QWORD *)(a1 + 16);
    v42 = *(_QWORD *)a1;
    *(_QWORD *)(a1 + 16) = v45[0];
    *(_QWORD *)(v42 + 8 * v4) = a1 + 16;
    if ( *(_QWORD *)v45[0] )
    {
      v43 = *(_QWORD *)(*(_QWORD *)v45[0] + 8LL);
      if ( (v16 & (v16 - 1)) != 0 )
      {
        if ( v43 >= v16 )
          v43 %= v16;
      }
      else
      {
        v43 &= v16 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v43) = v45[0];
    }
  }
  v24 = (__int64 **)v45[0];
  ++*(_QWORD *)(a1 + 24);
  return v24;
}


================================================================================
Function: sub_250E5AC (0x250E5AC)
================================================================================

unsigned __int64 __fastcall sub_250E5AC(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  unsigned __int64 v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3 = 2LL;
  }
  else
  {
    v3 = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_67A4870(a2);
      v3 = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3 > v4.n64_u64[0] )
    return sub_250E6E4(v2, v3);
  if ( v3 < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_67A4870(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3 < result )
      v3 = result;
    if ( v3 < v4.n64_u64[0] )
      return sub_250E6E4(v2, v3);
  }
  return result;
}


================================================================================
Function: sub_250E6E4 (0x250E6E4)
================================================================================

__int64 __fastcall sub_250E6E4(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // x8
  __int64 result; // x0
  __int64 v6; // x8
  _QWORD *v7; // x13
  unsigned __int64 v8; // x11
  uint8x8_t v9; // d0
  unsigned __int64 v10; // x10
  __int64 *v11; // x26
  unsigned __int64 v12; // x12
  unsigned __int64 v13; // x27
  __int64 v14; // x8
  unsigned __int64 v15; // x24
  _QWORD *v16; // x28
  size_t v17; // x21
  _QWORD *v18; // x23
  __int64 v19; // x8
  char v20; // w9
  unsigned int v21; // t1
  unsigned __int64 v22; // x10
  unsigned __int64 v23; // x11
  unsigned __int8 *v24; // x1
  unsigned __int8 *v25; // x8
  unsigned __int64 v26; // x9
  unsigned __int64 v27; // [xsp+8h] [xbp-18h]
  _QWORD *v28; // [xsp+10h] [xbp-10h]
  unsigned __int64 v29; // [xsp+18h] [xbp-8h]

  if ( a2 )
  {
    if ( a2 >> 61 )
      sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    v4 = sub_6575418();
    result = *a1;
    *a1 = v4;
    if ( result )
      result = sub_6575460();
    v6 = 0LL;
    a1[1] = a2;
    do
      *(_QWORD *)(*a1 + 8 * v6++) = 0LL;
    while ( a2 != v6 );
    v7 = (_QWORD *)a1[2];
    if ( v7 )
    {
      v8 = v7[1];
      v9.n64_u64[0] = vcnt_s8((int8x8_t)a2).n64_u64[0];
      v9.n64_u16[0] = vaddlv_u8(v9);
      v10 = v9.n64_u32[0];
      if ( v9.n64_u32[0] > 1uLL )
      {
        if ( v8 >= a2 )
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v8) = a1 + 2;
      v11 = (__int64 *)*v7;
      if ( *v7 )
      {
        v12 = a2 - 1;
        v27 = v9.n64_u32[0];
        do
        {
          v13 = v11[1];
          if ( v10 > 1 )
          {
            if ( v13 >= a2 )
              v13 %= a2;
          }
          else
          {
            v13 &= v12;
          }
          if ( v13 == v8 )
          {
            v7 = v11;
          }
          else if ( *(_QWORD *)(*a1 + 8 * v13) )
          {
            v14 = *v11;
            if ( *v11 )
            {
              v15 = *((unsigned __int8 *)v11 + 16);
              v16 = v11;
              v28 = v7;
              v29 = v8;
              if ( (v15 & 1) != 0 )
                v17 = v11[3];
              else
                v17 = v15 >> 1;
              while ( 1 )
              {
                v18 = v16;
                v16 = (_QWORD *)v14;
                v21 = *(unsigned __int8 *)(v14 + 16);
                v19 = v14 + 16;
                v20 = v21;
                v22 = *(_QWORD *)(v19 + 8);
                v23 = (unsigned __int64)v21 >> 1;
                if ( (v21 & 1) == 0 )
                  v22 = v23;
                if ( v17 != v22 )
                  break;
                if ( (v15 & 1) != 0 )
                  result = v11[4];
                else
                  result = (__int64)v11 + 17;
                if ( (v20 & 1) != 0 )
                  v24 = (unsigned __int8 *)v16[4];
                else
                  v24 = (unsigned __int8 *)(v19 + 1);
                if ( (v15 & 1) != 0 )
                {
                  if ( v17 )
                  {
                    result = memcmp((const void *)result, v24, v17);
                    if ( (_DWORD)result )
                      break;
                  }
                }
                else
                {
                  v25 = (unsigned __int8 *)v11 + 17;
                  v26 = v15 >> 1;
                  if ( v17 )
                  {
                    while ( *v25 == *v24 )
                    {
                      --v26;
                      ++v25;
                      ++v24;
                      if ( !v26 )
                        goto LABEL_29;
                    }
                    break;
                  }
                }
LABEL_29:
                v14 = *v16;
                if ( !*v16 )
                {
                  v18 = v16;
                  v16 = 0LL;
                  break;
                }
              }
              v12 = a2 - 1;
              v10 = v27;
              v8 = v29;
              v7 = v28;
            }
            else
            {
              v16 = 0LL;
              v18 = v11;
            }
            *v7 = v16;
            *v18 = **(_QWORD **)(*a1 + 8 * v13);
            **(_QWORD **)(*a1 + 8 * v13) = v11;
          }
          else
          {
            *(_QWORD *)(*a1 + 8 * v13) = v7;
            v7 = v11;
            v8 = v13;
          }
          v11 = (__int64 *)*v7;
        }
        while ( *v7 );
      }
    }
  }
  else
  {
    result = *a1;
    *a1 = 0LL;
    if ( result )
      result = sub_6575460();
    a1[1] = 0LL;
  }
  return result;
}


================================================================================
Function: sub_2511460 (0x2511460)
================================================================================

_QWORD *__fastcall sub_2511460(_QWORD *a1, int a2, int a3)
{
  char *v6; // x22
  int v7; // w5
  __int64 v8; // x23
  int v9; // w26
  __int64 v10; // x2
  __int64 *v11; // x0
  char v12; // w24
  int v13; // w2
  _BYTE v15[16]; // [xsp+0h] [xbp-20h] BYREF
  __int64 v16; // [xsp+10h] [xbp-10h] BYREF

  sub_67A6D5C(v15, a1);
  if ( v15[0] )
  {
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    v7 = *((_DWORD *)v6 + 36);
    v8 = *((_QWORD *)v6 + 5);
    v9 = *((_DWORD *)v6 + 2);
    if ( v7 == -1 )
    {
      sub_67A577C(&v16, (char *)a1 + *(_QWORD *)(*a1 - 24LL));
      v11 = sub_67C4BB8(&v16, (__int64)&qword_795CE58, v10);
      v12 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*v11 + 56))(v11, 32LL);
      sub_67C482C(&v16);
      v7 = v12;
      *((_DWORD *)v6 + 36) = v12;
    }
    if ( (v9 & 0xB0) == 0x20 )
      v13 = a2 + a3;
    else
      v13 = a2;
    if ( !sub_25115E8(v8, a2, v13, a2 + a3, (int)v6, v7) )
      sub_67A8410();
  }
  sub_67A6DB0(v15);
  return a1;
}


================================================================================
Function: sub_25115E8 (0x25115E8)
================================================================================

__int64 __fastcall sub_25115E8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int c)
{
  __int64 v6; // x19
  __int64 v7; // x8
  bool v12; // cc
  size_t v13; // x8
  __int64 v14; // x25
  size_t v15; // x23
  char *v16; // x25
  _QWORD *v17; // x1
  __int64 v18; // x24
  __int64 v19; // x22
  _QWORD v21[2]; // [xsp+0h] [xbp-20h] BYREF
  _QWORD *v22; // [xsp+10h] [xbp-10h]

  v6 = a1;
  if ( a1 )
  {
    v7 = *(_QWORD *)(a5 + 24);
    v12 = v7 <= a4 - a2;
    v13 = v7 - (a4 - a2);
    v14 = a3 - a2;
    if ( v12 )
      v15 = 0LL;
    else
      v15 = v13;
    if ( v14 >= 1 && (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 96LL))(a1) != v14 )
      return 0LL;
    if ( v15 )
    {
      if ( v15 >= 0x17 )
      {
        v16 = (char *)sub_6575418();
        v21[1] = v15;
        v22 = v16;
        v21[0] = (v15 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        v16 = (char *)v21 + 1;
        LOBYTE(v21[0]) = 2 * v15;
      }
      memset(v16, c, v15);
      v16[v15] = 0;
      v17 = (v21[0] & 1) != 0 ? v22 : (_QWORD *)((char *)v21 + 1);
      v18 = (*(__int64 (__fastcall **)(__int64, _QWORD *, size_t))(*(_QWORD *)v6 + 96LL))(v6, v17, v15);
      if ( (v21[0] & 1) != 0 )
        sub_6575460();
      if ( v18 != v15 )
        return 0LL;
    }
    v19 = a4 - a3;
    if ( v19 < 1 || (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 96LL))(v6, a3, v19) == v19 )
      *(_QWORD *)(a5 + 24) = 0LL;
    else
      return 0LL;
  }
  return v6;
}


================================================================================
Function: sub_2512CE8 (0x2512CE8)
================================================================================

void __fastcall __noreturn sub_2512CE8(__int64 a1)
{
  __int64 v2; // x19

  v2 = sub_67EAFB8(16LL);
  sub_2512D38(v2, a1);
  sub_67EB030(v2, (__int64)&`typeinfo for'std::out_of_range, (__int64)sub_67EE288);
}


================================================================================
Function: sub_2512D38 (0x2512D38)
================================================================================

__int64 __fastcall sub_2512D38(_QWORD *a1, char *a2)
{
  __int64 result; // x0

  result = sub_67D23F8((int)a1, a2);
  *a1 = off_6BE6158;
  return result;
}


================================================================================
Function: sub_2513400 (0x2513400)
================================================================================

__int64 __fastcall sub_2513400(__int64 *a1, __int128 **a2)
{
  __int128 *v3; // x8
  __int64 result; // x0
  unsigned __int64 v5; // x22
  unsigned __int64 *v7; // x20
  __int128 *i; // x21
  __int128 *v9; // x22

  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  v3 = a2[1];
  result = (char *)v3 - (char *)*a2;
  if ( v3 != *a2 )
  {
    v5 = 0xAAAAAAAAAAAAAAABLL * (result >> 3);
    if ( v5 >= 0xAAAAAAAAAAAAAABLL )
      sub_67D6BD4();
    result = sub_6575418();
    *a1 = result;
    a1[1] = result;
    v7 = (unsigned __int64 *)result;
    a1[2] = result + 24 * v5;
    v9 = *a2;
    for ( i = a2[1]; v9 != i; v7 += 3 )
    {
      result = (__int64)sub_67D2788(v7, v9);
      v9 = (__int128 *)((char *)v9 + 24);
    }
    a1[1] = (__int64)v7;
  }
  return result;
}


================================================================================
Function: sub_25138D8 (0x25138D8)
================================================================================

__int64 __fastcall sub_25138D8(__int64 a1)
{
  unsigned __int64 v2; // x20
  unsigned __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_67F0440(1LL, a1 + 56);
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65786C4(0LL, "Reference count overflow");
  if ( v2 >> 62 != 2 )
  {
    sub_6577E74(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7286220);
      v5 = sub_6585904(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_2513AFC(v5);
      sub_67F05F0(0x8000000000000000LL, a1 + 56);
    }
    sub_67D1AF4(a1 + 8);
  }
  return a1;
}


================================================================================
Function: sub_2513AFC (0x2513AFC)
================================================================================

__int64 sub_2513AFC()
{
  __int64 v0; // x19

  v0 = sub_6575FA8(3600LL, 16LL);
  sub_6229ABC();
  return v0;
}


================================================================================
Function: sub_251B288 (0x251B288)
================================================================================

void __noreturn sub_251B288()
{
  __int64 v0; // x19

  v0 = sub_67EAFB8(8LL);
  sub_67EE6B8();
  sub_67EB030(v0, (__int64)&`typeinfo for'std::bad_cast, (__int64)sub_67EE6D0);
}


================================================================================
Function: sub_25445A8 (0x25445A8)
================================================================================

__int64 *__fastcall sub_25445A8(__int64 *result, __int64 *a2)
{
  __int64 v2; // x9
  __int64 *v3; // x10
  __int64 *v4; // x8
  int v5; // w11
  __int64 **v6; // x12
  __int64 *v7; // x8
  int v8; // w12
  __int64 v9; // x13
  __int64 v10; // x13
  __int64 v11; // x14
  __int64 **v12; // x10
  _QWORD *v13; // x10
  _QWORD *v14; // x11
  __int64 *v15; // x11
  __int64 *v16; // x12
  __int64 *v17; // x12
  __int64 *v18; // x11
  __int64 *v19; // x10
  __int64 *v20; // x11
  __int64 *v21; // x10
  __int64 v22; // x9
  __int64 v23; // x9
  __int64 *v24; // x8
  __int64 v25; // x9
  __int64 v26; // x10
  __int64 v27; // x8
  __int64 *v28; // x9
  __int64 v29; // x10

  v2 = *a2;
  v3 = a2;
  if ( *a2 )
  {
    v4 = (__int64 *)a2[1];
    if ( !v4 )
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (__int64 *)*v4;
    }
    while ( v4 );
  }
  v2 = v3[1];
  if ( v2 )
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (__int64 **)v3[2];
  v7 = *v6;
  if ( *v6 == v3 )
  {
    *v6 = (__int64 *)v2;
    if ( v3 == result )
    {
      v7 = 0LL;
      result = (__int64 *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (__int64 *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if ( v3 != a2 )
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8LL * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if ( v10 )
      *(_QWORD *)(v10 + 16) = v3;
    if ( result == a2 )
      result = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
  }
  if ( !v8 || !result )
    return result;
  if ( !v5 )
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while ( 1 )
  {
    v12 = (__int64 **)v7[2];
    if ( *v12 == v7 )
      break;
    if ( *((_BYTE *)v7 + 24) )
    {
      v13 = (_QWORD *)*v7;
      if ( !*v7 )
        goto LABEL_37;
    }
    else
    {
      v15 = v12[1];
      *((_BYTE *)v7 + 24) = 1;
      *((_BYTE *)v12 + 24) = 0;
      v16 = (__int64 *)*v15;
      v12[1] = (__int64 *)*v15;
      if ( v16 )
        v16[2] = (__int64)v12;
      v15[2] = (__int64)v12[2];
      v12[2][*v12[2] != (_QWORD)v12] = (__int64)v15;
      *v15 = (__int64)v12;
      v17 = (__int64 *)*v7;
      v12[2] = v15;
      if ( result == v17 )
        result = v7;
      v7 = (__int64 *)v17[1];
      v13 = (_QWORD *)*v7;
      if ( !*v7 )
        goto LABEL_37;
    }
    if ( !*((_BYTE *)v13 + 24) )
    {
      v18 = (__int64 *)v7[1];
      if ( !v18 )
        goto LABEL_59;
LABEL_58:
      if ( *((_BYTE *)v18 + 24) )
      {
LABEL_59:
        v22 = v13[1];
        *((_BYTE *)v13 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        *v7 = v22;
        if ( v22 )
          *(_QWORD *)(v22 + 16) = v7;
        v13[2] = v7[2];
        v18 = v7;
        *(_QWORD *)(v7[2] + 8LL * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v13;
        v13[1] = v7;
        v7[2] = (__int64)v13;
      }
      else
      {
        v13 = v7;
      }
      v27 = v13[2];
      v28 = *(__int64 **)(v27 + 8);
      *((_BYTE *)v13 + 24) = *(_BYTE *)(v27 + 24);
      v29 = *v28;
      *(_BYTE *)(v27 + 24) = 1;
      *((_BYTE *)v18 + 24) = 1;
      *(_QWORD *)(v27 + 8) = v29;
      if ( v29 )
        *(_QWORD *)(v29 + 16) = v27;
      v28[2] = *(_QWORD *)(v27 + 16);
      *(_QWORD *)(*(_QWORD *)(v27 + 16) + 8LL * (**(_QWORD **)(v27 + 16) != v27)) = v28;
      *v28 = v27;
      *(_QWORD *)(v27 + 16) = v28;
      return result;
    }
LABEL_37:
    v18 = (__int64 *)v7[1];
    if ( v18 && !*((_BYTE *)v18 + 24) )
      goto LABEL_58;
    v19 = (__int64 *)v7[2];
    *((_BYTE *)v7 + 24) = 0;
    if ( v19 == result )
    {
      v19 = result;
LABEL_56:
      *((_BYTE *)v19 + 24) = 1;
      return result;
    }
    if ( !*((_BYTE *)v19 + 24) )
      goto LABEL_56;
LABEL_23:
    v7 = *(__int64 **)(v19[2] + 8LL * (*(_QWORD *)v19[2] == (_QWORD)v19));
  }
  if ( *((_BYTE *)v7 + 24) )
  {
    v14 = (_QWORD *)*v7;
    if ( !*v7 )
      goto LABEL_48;
LABEL_47:
    if ( !*((_BYTE *)v14 + 24) )
      goto LABEL_68;
  }
  else
  {
    v20 = (__int64 *)v7[1];
    *((_BYTE *)v7 + 24) = 1;
    *((_BYTE *)v12 + 24) = 0;
    *v12 = v20;
    if ( v20 )
      v20[2] = (__int64)v12;
    v7[2] = (__int64)v12[2];
    if ( result == (__int64 *)v12 )
      result = v7;
    v12[2][*v12[2] != (_QWORD)v12] = (__int64)v7;
    v7[1] = (__int64)v12;
    v12[2] = v7;
    v7 = *v12;
    v14 = (_QWORD *)**v12;
    if ( v14 )
      goto LABEL_47;
  }
LABEL_48:
  v21 = (__int64 *)v7[1];
  if ( !v21 || *((_BYTE *)v21 + 24) )
  {
    v19 = (__int64 *)v7[2];
    *((_BYTE *)v7 + 24) = 0;
    if ( !*((_BYTE *)v19 + 24) || v19 == result )
      goto LABEL_56;
    goto LABEL_23;
  }
  if ( !v14 )
    goto LABEL_65;
  if ( *((_BYTE *)v14 + 24) )
  {
    v21 = (__int64 *)v7[1];
LABEL_65:
    v23 = *v21;
    *((_BYTE *)v21 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v7[1] = v23;
    if ( v23 )
      *(_QWORD *)(v23 + 16) = v7;
    v21[2] = v7[2];
    v14 = v7;
    *(_QWORD *)(v7[2] + 8LL * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v21;
    *v21 = (__int64)v7;
    v7[2] = (__int64)v21;
  }
  else
  {
LABEL_68:
    v21 = v7;
  }
  v24 = (__int64 *)v21[2];
  v25 = *v24;
  *((_BYTE *)v21 + 24) = *((_BYTE *)v24 + 24);
  v26 = *(_QWORD *)(v25 + 8);
  *((_BYTE *)v24 + 24) = 1;
  *((_BYTE *)v14 + 24) = 1;
  *v24 = v26;
  if ( v26 )
    *(_QWORD *)(v26 + 16) = v24;
  *(_QWORD *)(v25 + 16) = v24[2];
  *(_QWORD *)(v24[2] + 8LL * (*(_QWORD *)v24[2] != (_QWORD)v24)) = v25;
  *(_QWORD *)(v25 + 8) = v24;
  v24[2] = v25;
  return result;
}


================================================================================
Function: sub_254B3DC (0x254B3DC)
================================================================================

__int64 __fastcall sub_254B3DC(__int64 a1)
{
  unsigned __int64 *v2; // x20
  __int64 result; // x0

  v2 = *(unsigned __int64 **)(a1 + 464);
  if ( !v2 || sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v2 + 1)) )
  {
    if ( (*(_BYTE *)(a1 + 424) & 1) == 0 )
      goto LABEL_5;
    goto LABEL_4;
  }
  (*(void (__fastcall **)(unsigned __int64 *))(*v2 + 16))(v2);
  sub_67D18A4(v2);
  if ( (*(_BYTE *)(a1 + 424) & 1) != 0 )
LABEL_4:
    sub_6575460();
LABEL_5:
  if ( (*(_BYTE *)(a1 + 392) & 1) != 0 )
    sub_6575460();
  result = sub_254B784(a1);
  if ( (*(_BYTE *)a1 & 1) == 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_254B784 (0x254B784)
================================================================================

__int64 __fastcall sub_254B784(__int64 result)
{
  int v1; // w9
  unsigned int v2; // w8
  unsigned __int8 *v3; // x10
  unsigned __int8 *v4; // t1
  unsigned __int8 *v5; // x20
  unsigned __int8 *v6; // x21
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x10
  int v9; // w8
  unsigned __int64 v10; // x9
  __int64 v11; // x10
  __int16 v12; // [xsp+0h] [xbp-20h]
  char v13; // [xsp+2h] [xbp-1Eh]

  v1 = *(_DWORD *)result;
  if ( (*(_DWORD *)result & 1) != 0 )
    v2 = 8;
  else
    v2 = *(_DWORD *)(result + 16);
  if ( v2 )
  {
    v4 = *(unsigned __int8 **)(result + 8);
    result += 8LL;
    v3 = v4;
    if ( (v1 & 1) != 0 )
      v5 = (unsigned __int8 *)result;
    else
      v5 = v3;
    v6 = &v5[48 * v2];
    HIBYTE(v12) = 95;
    v13 = 0;
    do
    {
      v7 = *v5;
      v8 = *((_QWORD *)v5 + 1);
      v9 = v7 & 1;
      v10 = v7 >> 1;
      if ( !v9 )
        v8 = v10;
      if ( v8 )
      {
        if ( v8 == 1 )
        {
          if ( v9 )
          {
            if ( **((_BYTE **)v5 + 2) == 95 )
            {
LABEL_10:
              result = sub_6575460();
              goto LABEL_11;
            }
          }
          else
          {
            v11 = 0LL;
            while ( v5[v11 + 1] == *((unsigned __int8 *)&v12 + v11 + 1) )
            {
              if ( v10 == ++v11 )
                goto LABEL_11;
            }
          }
        }
        if ( (v5[24] & 1) != 0 )
        {
          result = sub_6575460();
          v9 = *v5 & 1;
        }
      }
      if ( v9 )
        goto LABEL_10;
LABEL_11:
      v5 += 48;
    }
    while ( v5 != v6 );
  }
  return result;
}


================================================================================
Function: sub_254CDB4 (0x254CDB4)
================================================================================

unsigned __int64 __fastcall sub_254CDB4(unsigned __int64 *a1, char *s)
{
  unsigned __int64 result; // x0
  size_t v5; // x20
  void *v6; // x19
  unsigned __int64 v7; // x22
  __int64 v8; // x0

  result = strlen(s);
  if ( result >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v5 = result;
  if ( result >= 0x17 )
  {
    v7 = (result + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = sub_6575418();
    a1[1] = v5;
    a1[2] = v8;
    *a1 = v7 | 1;
    v6 = (void *)v8;
  }
  else
  {
    *(_BYTE *)a1 = 2 * result;
    v6 = (char *)a1 + 1;
    if ( !result )
      goto LABEL_7;
  }
  result = (unsigned __int64)memcpy(v6, s, v5);
LABEL_7:
  *((_BYTE *)v6 + v5) = 0;
  return result;
}


================================================================================
Function: sub_2550CD0 (0x2550CD0)
================================================================================

__int64 sub_2550CD0()
{
  return sub_67EF968(&unk_6C03458);
}


================================================================================
Function: sub_25556AC (0x25556AC)
================================================================================

__int64 __fastcall sub_25556AC(__int64 result, __int128 *a2, __int128 *a3)
{
  __int64 v3; // x8
  unsigned __int64 *v4; // x22
  __int128 *v6; // x21
  _QWORD *v7; // x19
  unsigned __int64 v8; // x24
  unsigned __int64 *v9; // x23
  char v10; // t1
  __int64 v11; // x8
  __int128 *v12; // x23
  unsigned __int64 v13; // x26
  __int128 *v14; // x25
  unsigned __int64 *v15; // x21
  unsigned __int64 *v16; // x20
  char v17; // t1
  unsigned __int64 v18; // x8
  __int64 v19; // x10
  unsigned __int64 v20; // x8
  __int64 v21; // x23

  v3 = *(_QWORD *)(result + 16);
  v4 = *(unsigned __int64 **)result;
  v6 = a2;
  v7 = (_QWORD *)result;
  v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)a3 - (char *)a2) >> 3);
  if ( v8 > 0xAAAAAAAAAAAAAAABLL * ((v3 - *(_QWORD *)result) >> 3) )
  {
    if ( v4 )
    {
      if ( *(unsigned __int64 **)(result + 8) != v4 )
      {
        v9 = *(unsigned __int64 **)(result + 8);
        do
        {
          v10 = *((_BYTE *)v9 - 24);
          v9 -= 3;
          if ( (v10 & 1) != 0 )
            sub_6575460();
        }
        while ( v9 != v4 );
      }
      v7[1] = v4;
      sub_6575460();
      v3 = 0LL;
      *v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }
    if ( v8 > 0xAAAAAAAAAAAAAAALL )
      goto LABEL_34;
    v18 = 0xAAAAAAAAAAAAAAABLL * (v3 >> 3);
    v19 = 2 * v18;
    if ( 2 * v18 < v8 )
      v19 = v8;
    v20 = v18 >= 0x555555555555555LL ? 0xAAAAAAAAAAAAAAALL : v19;
    if ( v20 > 0xAAAAAAAAAAAAAAALL )
LABEL_34:
      sub_67D6BD4();
    v21 = 24 * v20;
    result = sub_6575418();
    v4 = (unsigned __int64 *)result;
    *v7 = result;
    v7[1] = result;
    for ( v7[2] = result + v21; v6 != a3; v4 += 3 )
    {
      result = (__int64)sub_67D2788(v4, v6);
      v6 = (__int128 *)((char *)v6 + 24);
    }
LABEL_32:
    v7[1] = v4;
    return result;
  }
  v11 = *(_QWORD *)(result + 8) - (_QWORD)v4;
  v12 = (__int128 *)((char *)a2 + v11);
  v13 = 0xAAAAAAAAAAAAAAABLL * (v11 >> 3);
  if ( v8 <= v13 )
    v14 = a3;
  else
    v14 = (__int128 *)((char *)a2 + v11);
  if ( v14 != a2 )
  {
    do
    {
      result = (__int64)sub_67D3420((unsigned __int8 *)v4, (unsigned __int8 *)v6);
      v6 = (__int128 *)((char *)v6 + 24);
      v4 += 3;
    }
    while ( v6 != v14 );
  }
  v15 = (unsigned __int64 *)v7[1];
  if ( v8 <= v13 )
  {
    if ( v15 != v4 )
    {
      v16 = (unsigned __int64 *)v7[1];
      do
      {
        v17 = *((_BYTE *)v16 - 24);
        v16 -= 3;
        if ( (v17 & 1) != 0 )
          result = sub_6575460();
      }
      while ( v16 != v4 );
    }
    goto LABEL_32;
  }
  if ( v14 != a3 )
  {
    do
    {
      result = (__int64)sub_67D2788(v15, v12);
      v12 = (__int128 *)((char *)v12 + 24);
      v15 += 3;
    }
    while ( v12 != a3 );
  }
  v7[1] = v15;
  return result;
}


================================================================================
Function: sub_255C8E8 (0x255C8E8)
================================================================================

__int64 __fastcall sub_255C8E8(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  __int64 v6; // x10
  __int64 result; // x0
  __int64 v8; // x10

  v2 = a1 + 8;
  *(_QWORD *)a1 = off_67FA690;
  *(_QWORD *)(a1 + 72) = off_67FA6E8;
  sub_61D2A18(a1 + 8);
  v6 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)a1 = off_6BA08F8;
  *(_DWORD *)(a1 + 12) = 33;
  *(_QWORD *)(a1 + 16) = v6;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)((char *)&dword_0 + a1) = off_6BA08F8;
  sub_67D2788(a1 + 32, a2);
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 60) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 68) = 0;
  sub_61D2A4C(v2);
  sub_61D2A18(a1 + 80);
  *(_QWORD *)(a1 + 72) = off_6BA0A98;
  *(_BYTE *)(a1 + 408) = 0;
  *(_BYTE *)(a1 + 432) = 0;
  *(_QWORD *)((char *)&dword_0 + a1 + 72) = off_6BA0A98;
  *(_QWORD *)(a1 + 232) = 0LL;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 240) = 1065353216;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 280) = 1065353216;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_DWORD *)(a1 + 320) = 1065353216;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_DWORD *)(a1 + 360) = 1065353216;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_DWORD *)(a1 + 400) = 1065353216;
  *(_BYTE *)(a1 + 440) = 0;
  *(_BYTE *)(a1 + 464) = 0;
  *(_BYTE *)(a1 + 472) = 0;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_DWORD *)(a1 + 512) = 1065353216;
  *(_DWORD *)(a1 + 520) = 0;
  result = sub_61D2A4C(a1 + 80);
  v8 = a1 + 528;
  *(_QWORD *)(a1 + 528) = &unk_6BA0C40;
  *(_QWORD *)(v8 + unk_6BA0BF0) = off_6BA0CD0;
  *(_QWORD *)(v8 + *(_QWORD *)(*(_QWORD *)(a1 + 528) - 88LL)) = off_6BA0E58;
  *(_QWORD *)a1 = off_6BA04A8;
  *(_QWORD *)(a1 + 72) = off_6BA0658;
  *(_QWORD *)(a1 + 528) = &unk_6BA0800;
  *(_QWORD *)(a1 + 536) = 0x3FF0000000000000LL;
  return result;
}


================================================================================
Function: sub_2568AA8 (0x2568AA8)
================================================================================

__int64 __fastcall sub_2568AA8(unsigned __int64 *a1, __int128 *a2)
{
  unsigned __int64 v3; // x21
  unsigned __int64 v4; // x10
  unsigned __int64 v6; // x22
  __int64 result; // x0
  __int128 v8; // q0
  __int64 v9; // x9
  __int128 v10; // q1
  unsigned __int64 v11; // x10
  __int64 v12; // x12
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x11
  unsigned __int64 v15; // x20
  unsigned __int64 v16; // x9
  __int128 v17; // q0
  __int64 v18; // x12
  __int128 v19; // q0
  bool v20; // zf
  unsigned __int64 v21; // x20
  unsigned __int64 v22; // x21
  unsigned __int64 v23; // x19

  v3 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(a1[1] - *a1) >> 4);
  v4 = v3 + 1;
  if ( v3 + 1 > 0x555555555555555LL )
    sub_67D6BD4();
  if ( 0x5555555555555556LL * ((__int64)(a1[2] - *a1) >> 4) >= v4 )
    v4 = 0x5555555555555556LL * ((__int64)(a1[2] - *a1) >> 4);
  if ( 0xAAAAAAAAAAAAAAABLL * ((__int64)(a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL )
    v6 = 0x555555555555555LL;
  else
    v6 = v4;
  if ( v6 )
  {
    if ( v6 > 0x555555555555555LL )
      sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    result = sub_6575418();
  }
  else
  {
    result = 0LL;
  }
  v8 = *a2;
  *(_QWORD *)a2 = 0LL;
  *((_QWORD *)a2 + 1) = 0LL;
  v9 = *((_QWORD *)a2 + 2);
  v10 = *(__int128 *)((char *)a2 + 24);
  *((_QWORD *)a2 + 2) = 0LL;
  *((_QWORD *)a2 + 3) = 0LL;
  v11 = result + 48 * v3;
  v12 = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 4) = 0LL;
  *((_QWORD *)a2 + 5) = 0LL;
  v13 = result + 48 * v6;
  v15 = *a1;
  v14 = a1[1];
  *(_QWORD *)(v11 + 16) = v9;
  v16 = v11 + 48;
  *(_OWORD *)v11 = v8;
  *(_QWORD *)(v11 + 40) = v12;
  *(_OWORD *)(v11 + 24) = v10;
  if ( v14 == v15 )
  {
    *a1 = v11;
    a1[1] = v16;
    a1[2] = v13;
    if ( v15 )
      return sub_6575460();
  }
  else
  {
    do
    {
      v17 = *(_OWORD *)(v14 - 48);
      *(_QWORD *)(v11 - 32) = *(_QWORD *)(v14 - 32);
      *(_OWORD *)(v11 - 48) = v17;
      v18 = *(_QWORD *)(v14 - 8);
      *(_QWORD *)(v14 - 40) = 0LL;
      *(_QWORD *)(v14 - 32) = 0LL;
      v19 = *(_OWORD *)(v14 - 24);
      *(_QWORD *)(v14 - 48) = 0LL;
      *(_QWORD *)(v11 - 8) = v18;
      *(_OWORD *)(v11 - 24) = v19;
      v11 -= 48LL;
      *(_QWORD *)(v14 - 16) = 0LL;
      *(_QWORD *)(v14 - 8) = 0LL;
      v20 = v14 - 48 == v15;
      *(_QWORD *)(v14 - 24) = 0LL;
      v14 -= 48LL;
    }
    while ( !v20 );
    v21 = *a1;
    v22 = a1[1];
    *a1 = v11;
    a1[1] = v16;
    a1[2] = v13;
    if ( v22 != v21 )
    {
      do
      {
        if ( (*(_BYTE *)(v22 - 24) & 1) != 0 )
          result = sub_6575460();
        v23 = v22 - 48;
        if ( (*(_BYTE *)(v22 - 48) & 1) != 0 )
          result = sub_6575460();
        v22 -= 48LL;
      }
      while ( v23 != v21 );
    }
    if ( v21 )
      return sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_258083C (0x258083C)
================================================================================

size_t *__fastcall sub_258083C(size_t *result, void *src, size_t n, size_t a4, void *a5, size_t a6)
{
  size_t *v9; // x19
  void *v12; // x25
  _QWORD *v13; // x23
  size_t v14; // x26
  void *v15; // x23

  v9 = result;
  if ( !src )
  {
    *result = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
    v13 = result + 3;
    if ( a5 )
      goto LABEL_11;
    goto LABEL_7;
  }
  if ( n >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( n >= 0x17 )
  {
    v14 = (n + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v12 = (void *)sub_6575418();
    v9[1] = n;
    v9[2] = (size_t)v12;
    *v9 = v14 | 1;
    goto LABEL_9;
  }
  *(_BYTE *)result = 2 * n;
  v12 = (char *)result + 1;
  if ( n )
LABEL_9:
    result = (size_t *)memcpy(v12, src, n);
  *((_BYTE *)v12 + n) = 0;
  v13 = v9 + 3;
  if ( a5 )
  {
LABEL_11:
    if ( a6 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_67D2618();
    if ( a6 >= 0x17 )
    {
      v15 = (void *)sub_6575418();
      v9[4] = a6;
      v9[5] = (size_t)v15;
      v9[3] = (a6 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      *(_BYTE *)v13 = 2 * a6;
      v15 = (char *)v13 + 1;
      if ( !a6 )
        goto LABEL_17;
    }
    result = (size_t *)memcpy(v15, a5, a6);
LABEL_17:
    *((_BYTE *)v15 + a6) = 0;
    goto LABEL_18;
  }
LABEL_7:
  *v13 = 0LL;
  v13[1] = 0LL;
  v13[2] = 0LL;
LABEL_18:
  v9[6] = a4;
  return result;
}


================================================================================
Function: sub_2590CA4 (0x2590CA4)
================================================================================

__int64 **__fastcall sub_2590CA4(__int64 *a1, unsigned __int8 *a2, __int128 *a3)
{
  unsigned __int64 v3; // x27
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  __int64 *v11; // x1
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x26
  uint8x8_t v16; // d0
  unsigned __int64 v17; // x28
  __int64 ***v18; // x8
  unsigned __int64 v19; // x10
  unsigned __int8 *v20; // x11
  unsigned __int8 *v21; // x12
  unsigned __int64 v22; // x9
  __int64 **v23; // x22
  size_t v24; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  __int64 *v29; // x0
  __int64 v30; // x9
  __int64 *v31; // x24
  _QWORD *v32; // x22
  __int64 v33; // x8
  float v34; // s1
  float v35; // s0
  _BOOL8 v36; // x9
  unsigned __int64 v37; // x10
  __int64 v38; // x1
  __int64 v39; // x8
  _QWORD *v40; // x9
  __int64 v41; // x9
  unsigned __int64 v42; // x9
  _QWORD v44[2]; // [xsp+0h] [xbp-20h] BYREF
  char v45; // [xsp+10h] [xbp-10h]

  v7 = *((_QWORD *)a2 + 1);
  v8 = *a2;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v11 = (__int64 *)(a2 + 1);
  else
    v11 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v9 )
    v12 = v10;
  else
    v12 = v7;
  v13 = sub_24DF128((__int64)v44, v11, v12);
  v14 = v13;
  v15 = a1[1];
  if ( v15 )
  {
    v16.n64_u64[0] = vcnt_s8((int8x8_t)v15).n64_u64[0];
    v16.n64_u16[0] = vaddlv_u8(v16);
    v17 = v16.n64_u32[0];
    if ( v16.n64_u32[0] > 1uLL )
    {
      v3 = v13;
      if ( v13 >= v15 )
        v3 = v13 % v15;
    }
    else
    {
      v3 = (v15 - 1) & v13;
    }
    v18 = *(__int64 ****)(*a1 + 8 * v3);
    if ( v18 )
    {
      v19 = *((_QWORD *)a2 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v21 = a2 + 1;
      v22 = *a2;
      v23 = *v18;
      v24 = (v22 & 1) != 0 ? v19 : v22 >> 1;
      for ( i = (v22 & 1) != 0 ? v20 : v21; v23; v23 = (__int64 **)*v23 )
      {
        v26 = (unsigned __int64)v23[1];
        if ( v26 != v14 )
        {
          if ( v17 > 1 )
          {
            if ( v26 >= v15 )
              v26 %= v15;
          }
          else
          {
            v26 &= v15 - 1;
          }
          if ( v26 != v3 )
            break;
        }
        v27 = *((unsigned __int8 *)v23 + 16);
        v28 = (unsigned __int64)v23[3];
        if ( (v27 & 1) == 0 )
          v28 = v27 >> 1;
        if ( v28 == v24 )
        {
          if ( (v27 & 1) != 0 )
            v29 = v23[4];
          else
            v29 = (__int64 *)((char *)v23 + 17);
          if ( (v27 & 1) != 0 )
          {
            if ( !v24 || !memcmp(v29, i, v24) )
              return v23;
          }
          else
          {
            if ( !v24 )
              return v23;
            v30 = 0LL;
            while ( *((unsigned __int8 *)v23 + v30 + 17) == i[v30] )
            {
              if ( v27 >> 1 == ++v30 )
                return v23;
            }
          }
        }
      }
    }
  }
  v31 = a1 + 2;
  v32 = (_QWORD *)sub_6575418();
  v44[0] = v32;
  v44[1] = a1 + 2;
  v45 = 0;
  sub_67D2788(v32 + 2, a3);
  sub_67D2788(v32 + 5, (__int128 *)((char *)a3 + 24));
  v33 = a1[3];
  v34 = *((float *)a1 + 8);
  *v32 = 0LL;
  v32[1] = v14;
  v45 = 1;
  v35 = (float)(unsigned __int64)(v33 + 1);
  if ( !v15 || (float)(v34 * (float)v15) < v35 )
  {
    v36 = v15 < 3 || (v15 & (v15 - 1)) != 0;
    v37 = vcvtps_u32_f32(v35 / v34);
    if ( (v36 | (2 * v15)) >= v37 )
      v38 = v36 | (2 * v15);
    else
      v38 = v37;
    sub_250E5AC(a1, v38);
    v15 = a1[1];
    if ( (v15 & (v15 - 1)) != 0 )
    {
      if ( v14 >= v15 )
        v3 = v14 % v15;
      else
        v3 = v14;
    }
    else
    {
      v3 = (v15 - 1) & v14;
    }
  }
  v39 = *a1;
  v40 = *(_QWORD **)(*a1 + 8 * v3);
  if ( v40 )
  {
    *v32 = *v40;
    *v40 = v32;
  }
  else
  {
    v41 = *v31;
    *v31 = (__int64)v32;
    *v32 = v41;
    *(_QWORD *)(v39 + 8 * v3) = v31;
    if ( *(_QWORD *)v44[0] )
    {
      v42 = *(_QWORD *)(*(_QWORD *)v44[0] + 8LL);
      if ( (v15 & (v15 - 1)) != 0 )
      {
        if ( v42 >= v15 )
          v42 %= v15;
      }
      else
      {
        v42 &= v15 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v42) = v44[0];
    }
  }
  v23 = (__int64 **)v44[0];
  ++a1[3];
  return v23;
}


================================================================================
Function: sub_2591944 (0x2591944)
================================================================================

__int64 **__fastcall sub_2591944(__int64 *a1, unsigned __int8 *a2, __int64 a3, __int128 **a4)
{
  unsigned __int64 v4; // x27
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  bool v10; // zf
  unsigned __int64 v11; // x8
  __int64 *v12; // x1
  unsigned __int64 v13; // x2
  unsigned __int64 v14; // x0
  unsigned __int64 v15; // x20
  unsigned __int64 v16; // x26
  uint8x8_t v17; // d0
  unsigned __int64 v18; // x28
  __int64 ***v19; // x8
  unsigned __int64 v20; // x10
  unsigned __int8 *v21; // x11
  unsigned __int8 *v22; // x12
  unsigned __int64 v23; // x9
  __int64 **v24; // x22
  size_t v25; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x11
  __int64 *v30; // x0
  __int64 v31; // x9
  __int64 *v32; // x23
  _QWORD *v33; // x22
  __int128 *v34; // x1
  __int64 v35; // x8
  float v36; // s1
  float v37; // s0
  _BOOL8 v38; // x9
  unsigned __int64 v39; // x10
  __int64 v40; // x1
  __int64 v41; // x8
  _QWORD *v42; // x9
  __int64 v43; // x9
  unsigned __int64 v44; // x9
  _QWORD v46[2]; // [xsp+0h] [xbp-20h] BYREF
  char v47; // [xsp+10h] [xbp-10h]

  v8 = *((_QWORD *)a2 + 1);
  v9 = *a2;
  v10 = (v9 & 1) == 0;
  v11 = v9 >> 1;
  if ( v10 )
    v12 = (__int64 *)(a2 + 1);
  else
    v12 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v10 )
    v13 = v11;
  else
    v13 = v8;
  v14 = sub_24DF128((__int64)v46, v12, v13);
  v15 = v14;
  v16 = a1[1];
  if ( v16 )
  {
    v17.n64_u64[0] = vcnt_s8((int8x8_t)v16).n64_u64[0];
    v17.n64_u16[0] = vaddlv_u8(v17);
    v18 = v17.n64_u32[0];
    if ( v17.n64_u32[0] > 1uLL )
    {
      v4 = v14;
      if ( v14 >= v16 )
        v4 = v14 % v16;
    }
    else
    {
      v4 = (v16 - 1) & v14;
    }
    v19 = *(__int64 ****)(*a1 + 8 * v4);
    if ( v19 )
    {
      v20 = *((_QWORD *)a2 + 1);
      v21 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v22 = a2 + 1;
      v23 = *a2;
      v24 = *v19;
      v25 = (v23 & 1) != 0 ? v20 : v23 >> 1;
      for ( i = (v23 & 1) != 0 ? v21 : v22; v24; v24 = (__int64 **)*v24 )
      {
        v27 = (unsigned __int64)v24[1];
        if ( v27 != v15 )
        {
          if ( v18 > 1 )
          {
            if ( v27 >= v16 )
              v27 %= v16;
          }
          else
          {
            v27 &= v16 - 1;
          }
          if ( v27 != v4 )
            break;
        }
        v28 = *((unsigned __int8 *)v24 + 16);
        v29 = (unsigned __int64)v24[3];
        if ( (v28 & 1) == 0 )
          v29 = v28 >> 1;
        if ( v29 == v25 )
        {
          if ( (v28 & 1) != 0 )
            v30 = v24[4];
          else
            v30 = (__int64 *)((char *)v24 + 17);
          if ( (v28 & 1) != 0 )
          {
            if ( !v25 || !memcmp(v30, i, v25) )
              return v24;
          }
          else
          {
            if ( !v25 )
              return v24;
            v31 = 0LL;
            while ( *((unsigned __int8 *)v24 + v31 + 17) == i[v31] )
            {
              if ( v28 >> 1 == ++v31 )
                return v24;
            }
          }
        }
      }
    }
  }
  v32 = a1 + 2;
  v33 = (_QWORD *)sub_6575418();
  v34 = *a4;
  v47 = 0;
  v46[0] = v33;
  v46[1] = a1 + 2;
  sub_67D2788(v33 + 2, v34);
  v35 = a1[3];
  v36 = *((float *)a1 + 8);
  v33[5] = 0LL;
  v33[6] = 0LL;
  v33[7] = 0LL;
  v47 = 1;
  *v33 = 0LL;
  v33[1] = v15;
  v37 = (float)(unsigned __int64)(v35 + 1);
  if ( !v16 || (float)(v36 * (float)v16) < v37 )
  {
    v38 = v16 < 3 || (v16 & (v16 - 1)) != 0;
    v39 = vcvtps_u32_f32(v37 / v36);
    if ( (v38 | (2 * v16)) >= v39 )
      v40 = v38 | (2 * v16);
    else
      v40 = v39;
    sub_250E5AC(a1, v40);
    v16 = a1[1];
    if ( (v16 & (v16 - 1)) != 0 )
    {
      if ( v15 >= v16 )
        v4 = v15 % v16;
      else
        v4 = v15;
    }
    else
    {
      v4 = (v16 - 1) & v15;
    }
  }
  v41 = *a1;
  v42 = *(_QWORD **)(*a1 + 8 * v4);
  if ( v42 )
  {
    *v33 = *v42;
    *v42 = v33;
  }
  else
  {
    v43 = *v32;
    *v32 = (__int64)v33;
    *v33 = v43;
    *(_QWORD *)(v41 + 8 * v4) = v32;
    if ( *(_QWORD *)v46[0] )
    {
      v44 = *(_QWORD *)(*(_QWORD *)v46[0] + 8LL);
      if ( (v16 & (v16 - 1)) != 0 )
      {
        if ( v44 >= v16 )
          v44 %= v16;
      }
      else
      {
        v44 &= v16 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v44) = v46[0];
    }
  }
  v24 = (__int64 **)v46[0];
  ++a1[3];
  return v24;
}


================================================================================
Function: sub_259B1A8 (0x259B1A8)
================================================================================

__int64 __fastcall sub_259B1A8(__int64 a1)
{
  unsigned int v2; // w0
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  *(_DWORD *)(a1 + 3) = 0;
  *(_DWORD *)a1 = 0;
  v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 8), 0LL);
  if ( v2 )
  {
    sub_25A21C8(v4, v2, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v4);
  }
  sub_25A1F60(a1 + 48);
  sub_25A1F60(a1 + 136);
  return sub_25A1F60(a1 + 224);
}


================================================================================
Function: sub_259D768 (0x259D768)
================================================================================

__int64 __usercall sub_259D768@<X0>(_QWORD *a1@<X0>, __int64 a2@<X1>, _QWORD *a3@<X8>)
{
  int v6; // w19
  _QWORD *v7; // x0
  _QWORD *v8; // x22
  __int64 v9; // x8
  __int64 v10; // x8
  __int64 v11; // x0

  v6 = sub_6574924(dword_7280548);
  sub_657E47C(a1);
  v7 = (_QWORD *)sub_657DD4C(96LL);
  v7[2] = 0LL;
  v7[3] = 0LL;
  v8 = v7;
  v9 = *a1;
  v7[1] = sub_25B0610;
  *v7 = 0x100000000LL;
  v7[4] = v9;
  if ( v9 )
  {
    sub_67F03E0(1u, (atomic_uint *)(v9 + 4));
    v10 = v8[3] | 4LL;
  }
  else
  {
    v10 = 4LL;
  }
  v8[3] = v10;
  v11 = *(_QWORD *)(a2 + 32);
  v8[5] = sub_25B0634;
  if ( v11 )
  {
    if ( a2 == v11 )
    {
      v8[10] = v8 + 6;
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 32) + 24LL))(*(_QWORD *)(a2 + 32));
      goto LABEL_9;
    }
    v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
  }
  v8[10] = v11;
LABEL_9:
  sub_657D3C0(*a1, v8);
  *a3 = v8;
  sub_67F03E0(1u, (atomic_uint *)((char *)v8 + 4));
  return sub_6574924(v6);
}


================================================================================
Function: sub_25A1F60 (0x25A1F60)
================================================================================

__int64 __fastcall sub_25A1F60(__int64 a1)
{
  __int64 result; // x0
  _BYTE v3[56]; // [xsp+0h] [xbp-40h] BYREF

  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0LL) )
  {
    sub_25A21C8(v3);
    sub_25A2098((__int64)v3);
  }
  result = pthread_cond_init((pthread_cond_t *)(a1 + 40), 0LL);
  if ( (_DWORD)result )
  {
    pthread_mutex_destroy((pthread_mutex_t *)a1);
    sub_25A21C8(v3);
    sub_25A2098((__int64)v3);
  }
  return result;
}


================================================================================
Function: sub_25A2098 (0x25A2098)
================================================================================

void __fastcall __noreturn sub_25A2098(__int64 a1)
{
  __int64 v2; // x19
  _QWORD v3[2]; // [xsp+0h] [xbp-60h] BYREF
  __int128 v4; // [xsp+10h] [xbp-50h]
  unsigned __int64 v5[7]; // [xsp+20h] [xbp-40h] BYREF
  int v6; // [xsp+58h] [xbp-8h]

  v2 = sub_67EAFB8(104LL);
  sub_67D25E0(v3, a1);
  v4 = *(_OWORD *)(a1 + 16);
  v3[0] = off_6800DD8;
  sub_67D2788(v5, (__int128 *)(a1 + 32));
  memset(&v5[4], 0, 24);
  v6 = -1;
  v3[0] = off_6800F60;
  v5[3] = (unsigned __int64)off_6800F88;
  sub_25A2308(v2, v3);
  sub_67EB030(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::thread_resource_error>>,
    (__int64)sub_25A2228);
}


================================================================================
Function: sub_25A21C8 (0x25A21C8)
================================================================================

__int64 __fastcall sub_25A21C8(_QWORD *a1, unsigned int a2, char *a3)
{
  __int64 v6; // x22
  __int64 result; // x0

  v6 = sub_6765A30();
  result = sub_67D2554((int)a1, a3);
  a1[2] = a2;
  a1[3] = v6;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[4] = 0LL;
  *a1 = off_6800FA8;
  return result;
}


================================================================================
Function: sub_25A2308 (0x25A2308)
================================================================================

__int64 __fastcall sub_25A2308(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int128 v5; // q0

  *(_QWORD *)(a1 + 96) = off_67F7C48;
  sub_67D25E0((_QWORD *)a1, a2);
  *(_QWORD *)a1 = off_6800DD8;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_67D2788((unsigned __int64 *)(a1 + 32), (__int128 *)(a2 + 32));
  v4 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)a1 = off_6800FA8;
  *(_QWORD *)(a1 + 56) = off_67F7B38;
  *(_QWORD *)(a1 + 64) = v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(_QWORD *)a1 = off_6800EC0;
  *(_QWORD *)(a1 + 56) = off_6800EF8;
  *(_QWORD *)(a1 + 96) = &off_6800F30;
  return sub_24DB560(a1 + 56, a2 + 56);
}


================================================================================
Function: sub_25A6300 (0x25A6300)
================================================================================

void __fastcall __noreturn sub_25A6300(__int64 a1)
{
  __int64 v2; // x19
  _QWORD v3[2]; // [xsp+0h] [xbp-60h] BYREF
  __int128 v4; // [xsp+10h] [xbp-50h]
  unsigned __int64 v5[7]; // [xsp+20h] [xbp-40h] BYREF
  int v6; // [xsp+58h] [xbp-8h]

  v2 = sub_67EAFB8(104LL);
  sub_67D25E0(v3, a1);
  v4 = *(_OWORD *)(a1 + 16);
  v3[0] = off_6800DD8;
  sub_67D2788(v5, (__int128 *)(a1 + 32));
  memset(&v5[4], 0, 24);
  v6 = -1;
  v3[0] = off_68014F0;
  v5[3] = (unsigned __int64)off_6801518;
  sub_25A66D0(v2, v3);
  sub_67EB030(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::lock_error>>,
    (__int64)sub_25A65F0);
}


================================================================================
Function: sub_25A6430 (0x25A6430)
================================================================================

__int64 __fastcall sub_25A6430(_QWORD *a1, unsigned int a2, char *a3)
{
  __int64 v6; // x22
  __int64 result; // x0

  v6 = sub_6765A30();
  result = sub_67D2554((int)a1, a3);
  a1[2] = a2;
  a1[3] = v6;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[4] = 0LL;
  *a1 = off_6801538;
  return result;
}


================================================================================
Function: sub_25A64D0 (0x25A64D0)
================================================================================

__int64 __fastcall sub_25A64D0(__int64 a1)
{
  int v2; // w9
  pthread_mutex_t *v3; // x19
  unsigned int v4; // w1
  _BYTE v6[8]; // [xsp+8h] [xbp-58h] BYREF
  _QWORD v7[7]; // [xsp+10h] [xbp-50h] BYREF
  pthread_mutex_t *v8; // [xsp+48h] [xbp-18h] BYREF
  unsigned __int8 v9; // [xsp+50h] [xbp-10h]

  sub_6767D68(v6);
  v9 = 0;
  v8 = (pthread_mutex_t *)(a1 + 8);
  sub_25A70B8((__int64)&v8);
  while ( *(unsigned __int8 *)(a1 + 4) | *(unsigned __int8 *)(a1 + 6) )
    sub_25A6F10((pthread_mutex_t *)(a1 + 48), (__int64)&v8);
  v2 = v9;
  ++*(_DWORD *)a1;
  if ( v2 )
  {
    v3 = v8;
    do
      v4 = pthread_mutex_unlock(v3);
    while ( v4 == 4 );
    if ( v4 )
    {
      sub_25A6430(v7, v4, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300((__int64)v7);
    }
  }
  return sub_6767E60(v6);
}


================================================================================
Function: sub_25A66D0 (0x25A66D0)
================================================================================

__int64 __fastcall sub_25A66D0(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int128 v5; // q0

  *(_QWORD *)(a1 + 96) = off_67F7C48;
  sub_67D25E0((_QWORD *)a1, a2);
  *(_QWORD *)a1 = off_6800DD8;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_67D2788((unsigned __int64 *)(a1 + 32), (__int128 *)(a2 + 32));
  v4 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)a1 = off_6801538;
  *(_QWORD *)(a1 + 56) = off_67F7B38;
  *(_QWORD *)(a1 + 64) = v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(_QWORD *)a1 = off_6801450;
  *(_QWORD *)(a1 + 56) = off_6801488;
  *(_QWORD *)(a1 + 96) = &off_68014C0;
  return sub_24DB560(a1 + 56, a2 + 56);
}


================================================================================
Function: sub_25A6F10 (0x25A6F10)
================================================================================

__int64 __fastcall sub_25A6F10(pthread_mutex_t *a1, __int64 a2)
{
  pthread_cond_t *v4; // x21
  unsigned int v5; // w22
  __int64 v6; // x0
  __int64 result; // x0
  _BYTE v8[56]; // [xsp+10h] [xbp-40h] BYREF

  v4 = (pthread_cond_t *)&a1[1];
  sub_25A71A4(v8, a1, &a1[1]);
  sub_25A76CC(a2);
  do
    v5 = pthread_cond_wait(v4, a1);
  while ( v5 == 4 );
  sub_25A72E4(v8);
  v6 = sub_25A70B8(a2);
  result = sub_6767B28(v6);
  if ( v5 )
  {
    sub_25A7500(v8, v5, "boost::condition_variable::wait failed in pthread_cond_wait");
    sub_25A73D0(v8);
  }
  return result;
}


================================================================================
Function: sub_25A70B8 (0x25A70B8)
================================================================================

__int64 __fastcall sub_25A70B8(__int64 a1)
{
  pthread_mutex_t *v1; // x20
  __int64 result; // x0
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  v1 = *(pthread_mutex_t **)a1;
  if ( !*(_QWORD *)a1 )
  {
    sub_25A6430(v4, 1u, "boost unique_lock has no mutex");
    sub_25A6300((__int64)v4);
  }
  if ( *(_BYTE *)(a1 + 8) )
  {
    sub_25A6430(v4, 0x23u, "boost unique_lock owns already the mutex");
    sub_25A6300((__int64)v4);
  }
  do
    result = pthread_mutex_lock(v1);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    sub_25A6430(v4, result, "boost: mutex lock failed in pthread_mutex_lock");
    sub_25A6300((__int64)v4);
  }
  *(_BYTE *)(a1 + 8) = 1;
  return result;
}


================================================================================
Function: sub_25A71A4 (0x25A71A4)
================================================================================

__int64 __fastcall sub_25A71A4(__int64 *a1, pthread_mutex_t *a2, __int64 a3)
{
  __int64 v6; // x0
  int v7; // w8
  __int64 v8; // x8
  pthread_mutex_t *v9; // x19
  __int64 result; // x0
  __int64 v11; // x0
  pthread_mutex_t *mutex; // [xsp+8h] [xbp-48h] BYREF
  _QWORD v13[7]; // [xsp+10h] [xbp-40h] BYREF

  v6 = sub_67667A8();
  *a1 = v6;
  a1[1] = (__int64)a2;
  if ( !v6 )
  {
    *((_BYTE *)a1 + 16) = 0;
    return pthread_mutex_lock(a2);
  }
  v7 = *(unsigned __int8 *)(v6 + 408);
  *((_BYTE *)a1 + 16) = v7;
  if ( !v7 )
    return pthread_mutex_lock(a2);
  sub_25A7560(&mutex, (pthread_mutex_t *)(v6 + 48));
  v8 = *a1;
  if ( *(_BYTE *)(*a1 + 409) )
  {
    *(_BYTE *)(v8 + 409) = 0;
    v11 = sub_67EAFB8(1LL);
    sub_67EB030(v11, (__int64)&`typeinfo for'boost::thread_interrupted, 0LL);
  }
  *(_QWORD *)(v8 + 344) = a2;
  *(_QWORD *)(v8 + 352) = a3;
  pthread_mutex_lock((pthread_mutex_t *)a1[1]);
  v9 = mutex;
  do
    result = pthread_mutex_unlock(v9);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    sub_25A6430(v13, result, "boost: mutex unlock failed in pthread_mutex_unlock");
    sub_25A6300((__int64)v13);
  }
  return result;
}


================================================================================
Function: sub_25A72E4 (0x25A72E4)
================================================================================

__int64 __fastcall sub_25A72E4(__int64 *a1)
{
  int v2; // w8
  pthread_mutex_t *v3; // x0
  __int64 v4; // x8
  pthread_mutex_t *v5; // x19
  __int64 result; // x0
  pthread_mutex_t *mutex; // [xsp+8h] [xbp-48h] BYREF
  _QWORD v8[7]; // [xsp+10h] [xbp-40h] BYREF

  v2 = *((unsigned __int8 *)a1 + 16);
  v3 = (pthread_mutex_t *)a1[1];
  if ( !v2 )
    return pthread_mutex_unlock(v3);
  pthread_mutex_unlock(v3);
  sub_25A7560(&mutex, (pthread_mutex_t *)(*a1 + 48));
  v4 = *a1;
  v5 = mutex;
  *(_QWORD *)(v4 + 344) = 0LL;
  *(_QWORD *)(v4 + 352) = 0LL;
  do
    result = pthread_mutex_unlock(v5);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    sub_25A6430(v8, result, "boost: mutex unlock failed in pthread_mutex_unlock");
    sub_25A6300((__int64)v8);
  }
  return result;
}


================================================================================
Function: sub_25A73D0 (0x25A73D0)
================================================================================

void __fastcall __noreturn sub_25A73D0(__int64 a1)
{
  __int64 v2; // x19
  _QWORD v3[2]; // [xsp+0h] [xbp-60h] BYREF
  __int128 v4; // [xsp+10h] [xbp-50h]
  unsigned __int64 v5[7]; // [xsp+20h] [xbp-40h] BYREF
  int v6; // [xsp+58h] [xbp-8h]

  v2 = sub_67EAFB8(104LL);
  sub_67D25E0(v3, a1);
  v4 = *(_OWORD *)(a1 + 16);
  v3[0] = off_6800DD8;
  sub_67D2788(v5, (__int128 *)(a1 + 32));
  memset(&v5[4], 0, 24);
  v6 = -1;
  v3[0] = off_68016A0;
  v5[3] = (unsigned __int64)off_68016C8;
  sub_25A7894(v2, v3);
  sub_67EB030(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::condition_error>>,
    (__int64)sub_25A77B4);
}


================================================================================
Function: sub_25A7500 (0x25A7500)
================================================================================

void *__fastcall sub_25A7500(_QWORD *a1, unsigned int a2, char *a3)
{
  __int64 *v6; // x22
  void *result; // x0

  v6 = sub_6765A30();
  result = sub_67D2554(a1, a3);
  a1[2] = a2;
  a1[3] = v6;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[4] = 0LL;
  *a1 = off_68016E8;
  return result;
}


================================================================================
Function: sub_25A7560 (0x25A7560)
================================================================================

__int64 __fastcall sub_25A7560(_QWORD *a1, pthread_mutex_t *mutex)
{
  __int64 result; // x0
  unsigned int v4; // w20
  __int64 v5; // x19
  _QWORD v6[7]; // [xsp+0h] [xbp-40h] BYREF

  *a1 = mutex;
  do
    result = pthread_mutex_lock(mutex);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    v4 = result;
    v5 = sub_6765A30();
    sub_67D2554((int)v6, "boost: mutex lock failed in pthread_mutex_lock");
    v6[3] = v5;
    memset(&v6[4], 0, 24);
    v6[2] = v4;
    v6[0] = off_6801538;
    sub_25A6300((__int64)v6);
  }
  return result;
}


================================================================================
Function: sub_25A76CC (0x25A76CC)
================================================================================

__int64 __fastcall sub_25A76CC(__int64 a1)
{
  pthread_mutex_t *v1; // x20
  __int64 result; // x0
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  v1 = *(pthread_mutex_t **)a1;
  if ( !*(_QWORD *)a1 )
  {
    sub_25A6430(v4, 1u, "boost unique_lock has no mutex");
    sub_25A6300((__int64)v4);
  }
  if ( !*(_BYTE *)(a1 + 8) )
  {
    sub_25A6430(v4, 1u, "boost unique_lock doesn't own the mutex");
    sub_25A6300((__int64)v4);
  }
  do
    result = pthread_mutex_unlock(v1);
  while ( (_DWORD)result == 4 );
  if ( (_DWORD)result )
  {
    sub_25A6430(v4, result, "boost: mutex unlock failed in pthread_mutex_unlock");
    sub_25A6300((__int64)v4);
  }
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}


================================================================================
Function: sub_25A7894 (0x25A7894)
================================================================================

__int64 __fastcall sub_25A7894(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int128 v5; // q0

  *(_QWORD *)(a1 + 96) = off_67F7C48;
  sub_67D25E0((_QWORD *)a1, a2);
  *(_QWORD *)a1 = off_6800DD8;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_67D2788((unsigned __int64 *)(a1 + 32), (__int128 *)(a2 + 32));
  v4 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)a1 = off_68016E8;
  *(_QWORD *)(a1 + 56) = off_67F7B38;
  *(_QWORD *)(a1 + 64) = v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = *(_OWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v5;
  *(_QWORD *)a1 = off_6801600;
  *(_QWORD *)(a1 + 56) = off_6801638;
  *(_QWORD *)(a1 + 96) = &off_6801670;
  return sub_24DB560(a1 + 56, a2 + 56);
}


================================================================================
Function: sub_25A80D4 (0x25A80D4)
================================================================================

__int64 __fastcall sub_25A80D4(__int64 a1)
{
  __int64 result; // x0
  pthread_mutex_t *v4; // x19
  pthread_mutex_t *mutex; // [xsp+0h] [xbp-50h] BYREF
  char v6; // [xsp+8h] [xbp-48h]
  __int64 v7; // [xsp+10h] [xbp-40h] BYREF
  char v8; // [xsp+18h] [xbp-38h]

  mutex = (pthread_mutex_t *)(a1 + 8);
  v6 = 0;
  result = sub_25A70B8((__int64)&mutex);
  if ( (*(_DWORD *)a1)-- != 1 )
  {
    if ( !v6 )
      return result;
    goto LABEL_8;
  }
  if ( *(_BYTE *)(a1 + 5) )
  {
    *(_WORD *)(a1 + 4) = 1;
    sub_25A76CC((__int64)&mutex);
    v8 = 1;
    v7 = a1 + 224;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 224));
    pthread_cond_signal((pthread_cond_t *)(a1 + 264));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 224));
  }
  else
  {
    *(_BYTE *)(a1 + 6) = 0;
    sub_25A76CC((__int64)&mutex);
  }
  result = sub_25A8230(a1);
  if ( v6 )
  {
LABEL_8:
    v4 = mutex;
    do
      result = pthread_mutex_unlock(v4);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25A6430(&v7, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300((__int64)&v7);
    }
  }
  return result;
}


================================================================================
Function: sub_25A8230 (0x25A8230)
================================================================================

__int64 __fastcall sub_25A8230(__int64 a1)
{
  pthread_mutex_t *v2; // x20

  v2 = (pthread_mutex_t *)(a1 + 136);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 136));
  pthread_cond_signal((pthread_cond_t *)(a1 + 176));
  pthread_mutex_unlock(v2);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 88));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 48));
}


================================================================================
Function: sub_25D550C (0x25D550C)
================================================================================

__int64 __fastcall sub_25D550C(__int64 a1, unsigned int a2)
{
  unsigned int v3; // w8
  __int64 result; // x0
  unsigned int v5; // w20
  __int64 v6; // x22
  int v7; // w9
  __int64 v8; // x8
  unsigned __int64 *v9; // x20
  __int64 v10; // x19
  __int128 v11; // [xsp+0h] [xbp-20h] BYREF

  v3 = *(_DWORD *)a1 & 0xFFFFFFFE | (a2 < 9);
  *(_DWORD *)a1 = v3;
  if ( a2 > 8 )
  {
    v6 = a2;
    v5 = a2;
    result = sub_6575418();
    v3 = *(_DWORD *)a1;
    *(_QWORD *)(a1 + 8) = result;
    *(_QWORD *)(a1 + 16) = v6;
  }
  else
  {
    result = *(_QWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 16);
  }
  v7 = v3 & 1;
  if ( (v3 & 1) != 0 )
    v8 = 8LL;
  else
    v8 = v5;
  if ( v7 )
    v9 = (unsigned __int64 *)(a1 + 8);
  else
    v9 = (unsigned __int64 *)result;
  LOWORD(v11) = 0;
  *(_DWORD *)a1 = v7;
  *(_DWORD *)(a1 + 4) = 0;
  if ( (_DWORD)v8 )
  {
    v10 = 48 * v8;
    do
    {
      result = (__int64)sub_67D2788(v9, &v11);
      v9 += 6;
      v10 -= 48LL;
    }
    while ( v10 );
    if ( (v11 & 1) != 0 )
      return sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_261941C (0x261941C)
================================================================================

__int64 **__fastcall sub_261941C(_QWORD *a1, unsigned __int8 *a2)
{
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x8
  bool v6; // zf
  unsigned __int64 v7; // x8
  __int64 *v8; // x1
  unsigned __int64 v9; // x2
  unsigned __int64 v10; // x0
  int8x8_t v11; // x24
  unsigned __int64 v12; // x19
  uint8x8_t v13; // d0
  unsigned __int64 v14; // x25
  unsigned __int64 v15; // x26
  __int64 ***v16; // x8
  size_t v17; // x10
  unsigned __int8 *v18; // x11
  unsigned __int8 *v19; // x12
  unsigned __int64 v20; // x9
  __int64 **v21; // x20
  size_t v22; // x21
  unsigned __int8 *v23; // x22
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x10
  unsigned __int64 v26; // x11
  __int64 *v27; // x0
  __int64 v28; // x9
  __int64 v30; // [xsp+0h] [xbp-10h] BYREF

  v4 = *((_QWORD *)a2 + 1);
  v5 = *a2;
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
    v8 = (__int64 *)(a2 + 1);
  else
    v8 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v6 )
    v9 = v7;
  else
    v9 = v4;
  v10 = sub_24DF128((__int64)&v30, v8, v9);
  v11.n64_u64[0] = a1[1];
  if ( !v11.n64_u64[0] )
    return 0LL;
  v12 = v10;
  v13.n64_u64[0] = vcnt_s8(v11).n64_u64[0];
  v13.n64_u16[0] = vaddlv_u8(v13);
  v14 = v13.n64_u32[0];
  if ( v13.n64_u32[0] > 1uLL )
  {
    v15 = v10;
    if ( v10 >= v11.n64_u64[0] )
      v15 = v10 % v11.n64_u64[0];
  }
  else
  {
    v15 = (v11.n64_u64[0] - 1) & v10;
  }
  v16 = *(__int64 ****)(*a1 + 8 * v15);
  if ( !v16 )
    return 0LL;
  v17 = *((_QWORD *)a2 + 1);
  v18 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  v19 = a2 + 1;
  v20 = *a2;
  v21 = *v16;
  if ( (v20 & 1) != 0 )
    v22 = v17;
  else
    v22 = v20 >> 1;
  if ( (v20 & 1) != 0 )
    v23 = v18;
  else
    v23 = v19;
  for ( ; v21; v21 = (__int64 **)*v21 )
  {
    v24 = (unsigned __int64)v21[1];
    if ( v12 == v24 )
    {
      v25 = *((unsigned __int8 *)v21 + 16);
      v26 = (unsigned __int64)v21[3];
      if ( (v25 & 1) == 0 )
        v26 = v25 >> 1;
      if ( v26 == v22 )
      {
        if ( (v25 & 1) != 0 )
          v27 = v21[4];
        else
          v27 = (__int64 *)((char *)v21 + 17);
        if ( (v25 & 1) != 0 )
        {
          if ( !v22 || !memcmp(v27, v23, v22) )
            return v21;
        }
        else
        {
          if ( !v22 )
            return v21;
          v28 = 0LL;
          while ( *((unsigned __int8 *)v21 + v28 + 17) == v23[v28] )
          {
            if ( v25 >> 1 == ++v28 )
              return v21;
          }
        }
      }
    }
    else
    {
      if ( v14 <= 1 )
      {
        v24 &= v11.n64_u64[0] - 1;
      }
      else if ( v24 >= v11.n64_u64[0] )
      {
        v24 %= v11.n64_u64[0];
      }
      if ( v24 != v15 )
        return 0LL;
    }
  }
  return v21;
}


================================================================================
Function: sub_26B93A8 (0x26B93A8)
================================================================================

__int64 __fastcall sub_26B93A8(__int64 a1)
{
  __int64 v1; // x20
  __int64 result; // x0
  int v4; // w8
  __int64 v5; // x10
  unsigned __int64 v6; // x9
  bool v7; // zf
  unsigned __int64 v8; // x9
  __int64 v9; // x9
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x21
  __int64 v12; // x9
  __int64 v13; // x9
  unsigned __int64 v14; // x1
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x8
  bool v17; // zf
  unsigned __int64 v18; // x11
  __int64 v19; // x8
  char v20; // w9
  __int64 v21; // x10
  unsigned __int64 v22; // x9

  v1 = a1 + 64;
  result = sub_67D3420(a1 + 64);
  v4 = *(_DWORD *)(a1 + 96);
  *(_QWORD *)(a1 + 88) = 0LL;
  if ( (v4 & 8) != 0 )
  {
    v5 = *(_QWORD *)(a1 + 80);
    v6 = *(unsigned __int8 *)(a1 + 64);
    v7 = (v6 & 1) == 0;
    v8 = v6 >> 1;
    if ( v7 )
      v5 = v1 + 1;
    if ( !v7 )
      v8 = *(_QWORD *)(a1 + 72);
    v9 = v5 + v8;
    *(_QWORD *)(a1 + 16) = v5;
    *(_QWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 88) = v9;
    *(_QWORD *)(a1 + 32) = v9;
  }
  if ( (v4 & 0x10) != 0 )
  {
    v10 = *(unsigned __int8 *)(a1 + 64);
    if ( (v10 & 1) != 0 )
      v11 = *(_QWORD *)(a1 + 72);
    else
      v11 = v10 >> 1;
    if ( (v10 & 1) != 0 )
      v12 = *(_QWORD *)(a1 + 80);
    else
      v12 = v1 + 1;
    v13 = v12 + v11;
    if ( (v10 & 1) != 0 )
      v14 = (*(_QWORD *)(a1 + 64) & 0xFFFFFFFFFFFFFFFELL) - 1;
    else
      v14 = 22LL;
    *(_QWORD *)(a1 + 88) = v13;
    result = sub_67D36F0(v1, v14, 0LL);
    v15 = *(_QWORD *)(a1 + 72);
    v16 = *(unsigned __int8 *)(a1 + 64);
    v17 = (v16 & 1) == 0;
    v18 = v16 >> 1;
    if ( (v16 & 1) != 0 )
      v19 = *(_QWORD *)(a1 + 80);
    else
      v19 = v1 + 1;
    v20 = *(_BYTE *)(a1 + 96);
    if ( v17 )
      v15 = v18;
    *(_QWORD *)(a1 + 40) = v19;
    *(_QWORD *)(a1 + 48) = v19;
    *(_QWORD *)(a1 + 56) = v19 + v15;
    if ( (v20 & 3) != 0 )
    {
      if ( v11 >> 31 )
      {
        v21 = ((v11 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        v22 = 0x7FFFFFFF * ((v21 + ((v11 - 0x80000000 - v21) >> 1)) >> 30);
        v19 += v22 + 0x7FFFFFFF;
        v11 = v11 - v22 - 0x7FFFFFFF;
        *(_QWORD *)(a1 + 48) = v19;
      }
      if ( v11 )
        *(_QWORD *)(a1 + 48) = v19 + (unsigned int)v11;
    }
  }
  return result;
}


================================================================================
Function: sub_26E6A44 (0x26E6A44)
================================================================================

long double __fastcall sub_26E6A44(__int64 a1)
{
  long double result; // q0
  _BYTE v3[56]; // [xsp+0h] [xbp-40h] BYREF

  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)a1 = off_6BDF4F0;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 48), 0LL) )
  {
    sub_25A21C8(v3);
    sub_25A2098(v3);
  }
  sub_25A1F60(a1 + 88);
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 176), 0LL) )
  {
    sub_25A21C8(v3);
    sub_25A2098(v3);
  }
  sub_25A1F60(a1 + 216);
  *(_OWORD *)&result = 0uLL;
  *(_WORD *)(a1 + 304) = 0;
  *(_BYTE *)(a1 + 306) = 0;
  *(_QWORD *)(a1 + 312) = 0LL;
  *(_QWORD *)(a1 + 320) = a1 + 328;
  *(_QWORD *)(a1 + 328) = 0LL;
  *(_QWORD *)(a1 + 336) = 0LL;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_WORD *)(a1 + 408) = 1;
  return result;
}


================================================================================
Function: sub_26E6F90 (0x26E6F90)
================================================================================

__int64 __fastcall sub_26E6F90(_QWORD *a1)
{
  __int64 v2; // x20
  __int64 result; // x0

  v2 = sub_6765A30();
  result = sub_67D2554((int)a1, "boost::thread_resource_error");
  a1[2] = 11LL;
  a1[3] = v2;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[4] = 0LL;
  *a1 = off_6800FA8;
  return result;
}


================================================================================
Function: sub_2ACB540 (0x2ACB540)
================================================================================

void sub_2ACB540()
{
  unsigned __int8 v0; // w8
  __int64 v1; // x19
  __int64 v2; // x23
  __int64 v3; // x22
  int v4; // w19
  __int128 v5; // [xsp+0h] [xbp-20h] BYREF
  char *v6; // [xsp+10h] [xbp-10h]

  if ( dword_6C5BD50 )
  {
    v0 = atomic_load(byte_6C5BF88);
    if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0(byte_6C5BF88) )
    {
      dword_6C5BF80 = dword_6C5BEE0;
      sub_67EB838(byte_6C5BF88);
    }
    v1 = sub_6580494();
    v2 = *(_QWORD *)sub_6583344(&qword_6C5BF60);
    v3 = v1 - v2;
    if ( v1 - v2 >= (unsigned __int64)dword_6C5BD50 )
    {
      v4 = dword_6C5BEE4;
      if ( v4 != (unsigned int)sub_67F01D0((unsigned int)dword_6C5BEE4, &dword_6C5BF80) )
      {
        if ( v2 )
        {
          if ( v3 < 0 )
          {
            if ( !dword_6C5BD24 )
              atomic_store(dword_6C5BEE4, (unsigned int *)&dword_6C5BF58);
            v6 = (char *)sub_6575418(64LL);
            v5 = xmmword_AF9D70;
            strcpy(v6, "GameLdr-PerformanceCheck0,GameLdr-PerformanceCheck2");
            sub_3BBD530(&v5, 0LL);
          }
          else
          {
            if ( !dword_6C5BD38 )
              atomic_store(dword_6C5BEE4, (unsigned int *)&dword_6C5BF58);
            v6 = (char *)sub_6575418(64LL);
            v5 = xmmword_AF9D70;
            strcpy(v6, "GameLdr-PerformanceCheck0,GameLdr-PerformanceCheck3");
            sub_3BBD530(&v5, 0LL);
          }
        }
        else
        {
          atomic_store(dword_6C5BEE4, (unsigned int *)&dword_6C5BF58);
          v6 = (char *)sub_6575418(64LL);
          v5 = xmmword_AF9D70;
          strcpy(v6, "GameLdr-PerformanceCheck0,GameLdr-PerformanceCheck1");
          sub_3BBD530(&v5, 0LL);
        }
        if ( (v5 & 1) != 0 )
          sub_6575460(v6);
      }
    }
  }
}


================================================================================
Function: sub_2CAC424 (0x2CAC424)
================================================================================

bool __fastcall sub_2CAC424(pthread_mutex_t *a1, __int64 a2, const struct timespec *a3)
{
  pthread_cond_t *v6; // x22
  unsigned int v7; // w20
  __int64 v8; // x0
  _BYTE v10[56]; // [xsp+10h] [xbp-40h] BYREF

  v6 = (pthread_cond_t *)&a1[1];
  sub_25A71A4(v10, a1, &a1[1]);
  sub_25A76CC(a2);
  v7 = pthread_cond_timedwait(v6, a1, a3);
  v8 = sub_25A72E4(v10);
  sub_6767B28(v8);
  if ( v7 && v7 != 110 )
  {
    sub_25A7500(v10, v7, "boost::condition_variable::do_wait_until failed in pthread_cond_timedwait");
    sub_25A73D0(v10);
  }
  sub_25A70B8(a2);
  return v7 != 110;
}


================================================================================
Function: sub_2D35AC0 (0x2D35AC0)
================================================================================

__int64 __fastcall sub_2D35AC0(unsigned __int8 *a1, __int64 *a2, void *a3, __int64 a4, char *a5, char *a6, void *a7)
{
  char *v8; // x8
  unsigned __int8 *v9; // x28
  char v10; // w10
  unsigned __int8 *v11; // x9
  unsigned __int8 *v15; // x25
  unsigned __int8 *v16; // x4
  unsigned __int8 *v17; // x26
  _QWORD *v18; // x1
  __int64 v19; // x2
  unsigned __int8 *v20; // x9
  unsigned __int64 v21; // x10
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x8
  char *v24; // x11
  __int64 v25; // x12
  __int64 v26; // x13
  unsigned __int8 *v27; // x5
  __int64 v28; // x8
  __int64 v29; // x15
  __int64 v30; // x14
  __int64 v31; // x14
  __int64 v32; // x0
  unsigned __int64 v33; // x9
  bool v34; // zf
  unsigned __int64 v35; // x12
  unsigned __int8 *v36; // x9
  unsigned __int64 v37; // x10
  unsigned __int8 *v38; // x1
  _QWORD *v39; // x2
  _QWORD *v40; // x4
  __int64 v41; // x3
  __int64 v42; // x5
  __int64 v43; // x19
  __int64 v44; // x20
  unsigned __int64 v45; // x8
  unsigned __int64 v46; // x8
  __int64 v47; // x8
  __int64 result; // x0
  __int128 v49; // [xsp+0h] [xbp-40h] BYREF
  __int128 v50; // [xsp+10h] [xbp-30h]
  __int128 v51; // [xsp+20h] [xbp-20h]
  char v52; // [xsp+30h] [xbp-10h] BYREF

  v8 = a6;
  v9 = a1 + 1;
  v10 = *a1;
  v50 = 0u;
  v51 = 0u;
  v11 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  v49 = 0u;
  if ( (v10 & 1) == 0 )
    v11 = a1 + 1;
  if ( a5 == a6 )
  {
    v17 = v11;
    v15 = v11;
  }
  else
  {
    v15 = v11;
    v16 = v11;
    while ( 1 )
    {
      v17 = (unsigned __int8 *)v8;
      v15 = (unsigned __int8 *)sub_2D35EF4((int)&v52, (int)&v49, (int)a1, v15, v16);
      v18 = (_QWORD *)(*((_QWORD *)&v49 + 1) + ((((_QWORD)v51 + *((_QWORD *)&v51 + 1)) >> 9) & 0x7FFFFFFFFFFFF8LL));
      if ( (_QWORD)v50 == *((_QWORD *)&v49 + 1) )
        LODWORD(v19) = 0;
      else
        v19 = *v18 + (((_WORD)v51 + WORD4(v51)) & 0xFFF);
      sub_2D36B7C((int)&v49, (int)v18, v19, a7);
      v21 = *((_QWORD *)a1 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      v22 = *a1;
      v34 = (v22 & 1) == 0;
      v23 = v22 >> 1;
      if ( v34 )
      {
        v20 = v9;
        v21 = v23;
      }
      v24 = (char *)&v20[v21];
      if ( v17 == &v20[v21] )
        break;
      v25 = *a2;
      v26 = a2[1];
      if ( *a2 == v26 )
        break;
      v27 = v17;
LABEL_13:
      v28 = 0LL;
      do
      {
        if ( v27[v28] != *(unsigned __int8 *)(v25 + v28) )
        {
          v31 = v25 + v28;
          v8 = (char *)&v27[v28];
          if ( v31 == v26 )
            goto LABEL_22;
LABEL_20:
          if ( ++v27 != (unsigned __int8 *)v24 )
            goto LABEL_13;
          goto LABEL_26;
        }
        v29 = v28 + 1;
        if ( &v27[v28 + 1] == (unsigned __int8 *)v24 )
          break;
        v30 = v25 + v28++;
      }
      while ( v30 + 1 != v26 );
      v8 = (char *)&v27[v29];
      if ( v25 + v29 != v26 )
        goto LABEL_20;
LABEL_22:
      v16 = v17;
      if ( v27 == (unsigned __int8 *)v8 )
        break;
      a7 = a3;
    }
  }
LABEL_26:
  v32 = sub_2D35EF4((int)&v52, (int)&v49, (int)a1, v15, v17);
  v33 = *a1;
  v34 = (v33 & 1) == 0;
  v35 = v33 >> 1;
  if ( (v33 & 1) != 0 )
    v36 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  else
    v36 = v9;
  if ( v34 )
    v37 = v35;
  else
    v37 = *((_QWORD *)a1 + 1);
  v38 = &v36[v37];
  if ( *((_QWORD *)&v51 + 1) )
  {
    v39 = (_QWORD *)(*((_QWORD *)&v49 + 1) + (((unsigned __int64)v51 >> 9) & 0x7FFFFFFFFFFFF8LL));
    if ( (_QWORD)v50 == *((_QWORD *)&v49 + 1) )
    {
      v41 = 0LL;
      v42 = 0LL;
      v40 = (_QWORD *)(*((_QWORD *)&v49 + 1) + ((((_QWORD)v51 + *((_QWORD *)&v51 + 1)) >> 9) & 0x7FFFFFFFFFFFF8LL));
    }
    else
    {
      v40 = (_QWORD *)(*((_QWORD *)&v49 + 1) + ((((_QWORD)v51 + *((_QWORD *)&v51 + 1)) >> 9) & 0x7FFFFFFFFFFFF8LL));
      v41 = *v39 + (v51 & 0xFFF);
      v42 = *v40 + ((v51 + *((_QWORD *)&v51 + 1)) & 0xFFF);
    }
    sub_2D382F0(a1, v38, v39, v41, v40, v42);
  }
  else
  {
    sub_67D2E9C(a1, v32 - (_QWORD)v36, &v38[-v32]);
  }
  v43 = *((_QWORD *)&v49 + 1);
  v44 = v50;
  *((_QWORD *)&v51 + 1) = 0LL;
  v45 = v50 - *((_QWORD *)&v49 + 1);
  if ( (_QWORD)v50 - *((_QWORD *)&v49 + 1) >= 0x11uLL )
  {
    do
    {
      sub_6575460();
      v44 = v50;
      v43 = *((_QWORD *)&v49 + 1) + 8LL;
      v45 = v50 - (*((_QWORD *)&v49 + 1) + 8LL);
      *((_QWORD *)&v49 + 1) += 8LL;
    }
    while ( v45 > 0x10 );
  }
  v46 = v45 >> 3;
  if ( v46 == 1 )
  {
    v47 = 2048LL;
    goto LABEL_44;
  }
  if ( v46 == 2 )
  {
    v47 = 4096LL;
LABEL_44:
    *(_QWORD *)&v51 = v47;
  }
  if ( v43 != v44 )
  {
    do
    {
      v43 += 8LL;
      sub_6575460();
    }
    while ( v43 != v44 );
    if ( (_QWORD)v50 != *((_QWORD *)&v49 + 1) )
      *(_QWORD *)&v50 = v50 + 8 * ~((unsigned __int64)(v50 - *((_QWORD *)&v49 + 1) - 8) >> 3);
  }
  result = v49;
  if ( (_QWORD)v49 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_2D35EF4 (0x2D35EF4)
================================================================================

_BYTE *__fastcall sub_2D35EF4(int a1, int64x2_t *a2, int a3, _BYTE *dest, _BYTE *src, _BYTE *a6)
{
  __int64 v9; // x8
  _BYTE *v10; // x21
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x9
  __int64 v13; // x9
  _BYTE *i; // x21
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x8
  __int64 v17; // x11
  unsigned __int64 v18; // x8
  __int64 v19; // x10
  int64x2_t v20; // q0
  size_t v21; // x19

  v9 = a2[2].n128_i64[1];
  v10 = dest;
  if ( v9 && dest != src )
  {
    v11 = a2[2].n128_u64[0];
    do
    {
      *v10 = *(_BYTE *)(*(_QWORD *)(a2->n128_u64[1] + ((v11 >> 9) & 0x7FFFFFFFFFFFF8LL)) + (v11 & 0xFFF));
      v11 = a2[2].n128_u64[0] + 1;
      v9 = a2[2].n128_u64[1] - 1;
      a2[2].n128_u64[0] = v11;
      a2[2].n128_u64[1] = v9;
      if ( v11 >= 0x2000 )
      {
        sub_6575460();
        v12 = a2[2].n128_u64[0];
        v9 = a2[2].n128_i64[1];
        a2->n128_u64[1] += 8LL;
        v11 = v12 - 4096;
        a2[2].n128_u64[0] = v11;
      }
      ++v10;
    }
    while ( v9 && v10 != src );
  }
  if ( v9 )
  {
    if ( v10 != a6 )
    {
      v13 = a2[2].n128_i64[0];
      for ( i = v10 + 1; ; ++i )
      {
        v15 = a2->n128_u64[1];
        v16 = v9 + v13;
        v17 = ((a2[1].n128_u64[0] - v15) << 9) - 1;
        if ( a2[1].n128_u64[0] == v15 )
          v17 = 0LL;
        if ( v17 == v16 )
        {
          sub_2D360B8(a2);
          v15 = a2->n128_u64[1];
          v16 = a2[2].n128_u64[0] + a2[2].n128_u64[1];
        }
        *(_BYTE *)(*(_QWORD *)(v15 + ((v16 >> 9) & 0x7FFFFFFFFFFFF8LL)) + (v16 & 0xFFF)) = *(i - 1);
        v18 = a2[2].n128_u64[0];
        v19 = *(_QWORD *)(a2->n128_u64[1] + ((v18 >> 9) & 0x7FFFFFFFFFFFF8LL));
        ++a2[2].n128_u64[1];
        *(i - 1) = *(_BYTE *)(v19 + (v18 & 0xFFF));
        v20 = vaddq_s64(a2[2], (int64x2_t)xmmword_AF85E0);
        v13 = v20.n128_u64[0];
        a2[2] = v20;
        if ( v20.n128_u64[0] >= 0x2000 )
        {
          sub_6575460();
          v13 = a2[2].n128_u64[0] - 4096;
          a2->n128_u64[1] += 8LL;
          a2[2].n128_u64[0] = v13;
        }
        if ( i == a6 )
          break;
        v9 = a2[2].n128_i64[1];
      }
    }
  }
  else if ( v10 != src )
  {
    v21 = a6 - src;
    if ( v21 )
      memmove(v10, src, v21);
    return &v10[v21];
  }
  return a6;
}


================================================================================
Function: sub_2D360B8 (0x2D360B8)
================================================================================

__int64 __fastcall sub_2D360B8(__int64 *a1)
{
  unsigned __int64 v2; // x8
  bool v3; // cf
  unsigned __int64 v4; // x8
  __int64 *v5; // x9
  __int64 v6; // x8
  __int64 result; // x0
  __int64 v8; // x8
  __int64 v9; // x9
  __int64 v10; // x10
  unsigned __int64 v11; // x22
  unsigned __int64 v12; // x8
  __int64 v13; // x20
  __int64 v14; // x20
  __int64 v15; // x22
  __int128 v16; // q0
  __int64 v17; // x10
  __int64 v18; // x8
  __int64 v19; // x9
  __int64 *v20; // x8
  __int64 v21; // t1
  __int64 v22; // [xsp+8h] [xbp-38h] BYREF
  __int64 v23; // [xsp+10h] [xbp-30h] BYREF
  __int128 v24; // [xsp+18h] [xbp-28h]
  __int64 v25; // [xsp+28h] [xbp-18h]
  _QWORD *v26; // [xsp+30h] [xbp-10h]

  v2 = a1[4];
  v3 = v2 >= 0x1000;
  v4 = v2 - 4096;
  if ( v3 )
  {
    v5 = (__int64 *)a1[1];
    a1[4] = v4;
    v6 = *v5;
    a1[1] = (__int64)(v5 + 1);
    v23 = v6;
    return sub_2D362D4(a1, &v23);
  }
  v8 = a1[2];
  v9 = a1[3];
  v10 = v9 - *a1;
  v11 = (v8 - a1[1]) >> 3;
  if ( v11 < v10 >> 3 )
  {
    if ( v9 != v8 )
    {
      v23 = sub_6575418();
      return sub_2D3648C(a1, &v23);
    }
    v23 = sub_6575418();
    sub_2D36644(a1, &v23);
    v20 = (__int64 *)a1[1];
    v21 = *v20;
    a1[1] = (__int64)(v20 + 1);
    v23 = v21;
    return sub_2D362D4(a1, &v23);
  }
  v12 = v10 >> 2;
  if ( !v10 )
    v12 = 1LL;
  v26 = a1 + 3;
  if ( v12 >> 61 )
    sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v13 = 8 * v12;
  v23 = sub_6575418();
  *(_QWORD *)&v24 = v23 + 8 * v11;
  *((_QWORD *)&v24 + 1) = v24;
  v25 = v23 + v13;
  v22 = sub_6575418();
  sub_2D36804(&v23, &v22);
  v14 = a1[2];
  v15 = v14 + 8;
  while ( v14 != a1[1] )
  {
    v14 -= 8LL;
    v15 -= 8LL;
    sub_2D369BC(&v23, v14);
  }
  result = *a1;
  v16 = v24;
  *a1 = v23;
  v17 = v25;
  v18 = a1[2];
  v19 = a1[3];
  *(_OWORD *)(a1 + 1) = v16;
  v23 = result;
  *(_QWORD *)&v24 = v14;
  a1[3] = v17;
  *((_QWORD *)&v24 + 1) = v18;
  v25 = v19;
  if ( v14 != v18 )
    *((_QWORD *)&v24 + 1) = v18 + 8 * ~((unsigned __int64)(v18 - v15) >> 3);
  if ( result )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_2D362D4 (0x2D362D4)
================================================================================

__int64 __fastcall sub_2D362D4(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_6575418();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_6575460();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_2D3648C (0x2D3648C)
================================================================================

__int64 __fastcall sub_2D3648C(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_6575418();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_6575460();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_2D36644 (0x2D36644)
================================================================================

__int64 __fastcall sub_2D36644(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_6575418();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_6575460();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_2D36804 (0x2D36804)
================================================================================

__int64 __fastcall sub_2D36804(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_6575418();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_6575460();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_2D369BC (0x2D369BC)
================================================================================

__int64 __fastcall sub_2D369BC(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_6575418();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_6575460();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_2D36B7C (0x2D36B7C)
================================================================================

_QWORD *__fastcall sub_2D36B7C(int64x2_t *a1, char *a2, __int64 a3, char *src, char *a5)
{
  unsigned __int64 v5; // x10
  char *v6; // x20
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  char *v9; // x21
  unsigned __int64 v11; // x11
  char *v12; // x12
  unsigned __int64 v13; // x13
  __int64 v14; // x14
  unsigned __int64 v15; // x25
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x12
  char **v18; // x22
  char *v19; // x23
  unsigned __int64 v20; // x8
  char *v21; // x8
  char *v22; // x10
  char *v23; // x11
  char *v24; // x9
  char **v25; // x8
  char v26; // t1
  __int64 v27; // t1
  __int64 v28; // x11
  unsigned __int64 v29; // x10
  unsigned __int64 v30; // x11
  _QWORD *v31; // x2
  char *v32; // x3
  unsigned __int64 v33; // x8
  char *v34; // x11
  char *v35; // x12
  _QWORD *v36; // x9
  char *v37; // x10
  char *v38; // t1
  __int64 v39; // x10
  void **v40; // x0
  unsigned __int64 v41; // x11
  char *v42; // x1
  char *v43; // x11
  void **v44; // x10
  char v45; // t1
  __int64 v46; // t1
  __int64 v47; // t1
  __int64 v48; // x8
  _DWORD *v49; // x2
  __int64 v50; // x11
  _QWORD *v51; // x22
  unsigned __int64 v52; // x12
  char *v53; // x23
  _QWORD *v54; // x11
  char *v55; // x12
  char *v56; // t1
  char *v57; // t1
  __int64 v58; // x8
  char *v59; // x9
  unsigned __int64 v60; // x9
  char *v61; // x1
  unsigned __int64 v62; // x9
  __int64 v63; // x8
  __int64 v64; // x8
  char *v65; // x26
  __int64 v66; // x27
  unsigned __int64 v67; // x9
  __int64 v68; // x11
  char *v69; // x8
  __int64 v70; // x25
  char *v71; // t1
  _BYTE *v72; // x9
  char *v73; // x10
  bool v74; // cc
  char *v75; // x0
  __int64 v76; // x27
  __int64 v77; // x8
  unsigned __int64 v78; // x9
  unsigned __int64 v79; // x9
  _QWORD *result; // x0
  __int64 v81; // x1
  __int64 v82; // x8

  v5 = a1[2].n128_u64[0];
  v6 = a5;
  v7 = a1->n128_u64[1];
  v8 = a1[1].n128_u64[0];
  v9 = src;
  v11 = v5 >> 12;
  v12 = (char *)(v7 + 8 * (v5 >> 12));
  v13 = v8 - v7;
  if ( v8 == v7 )
    v14 = 0LL;
  else
    v14 = *(_QWORD *)v12 + (a1[2].n128_u64[0] & 0xFFF);
  v15 = a5 - src;
  if ( a3 == v14 )
    v16 = 0LL;
  else
    v16 = a3 + ((a2 - v12) << 9) - (v14 + *(_QWORD *)a2) + *(_QWORD *)v12;
  v17 = a1[2].n128_u64[1];
  if ( v16 < v17 - v16 )
  {
    if ( v15 > v5 )
    {
      sub_2D37208(a1, v15 - v5);
      v5 = a1[2].n128_u64[0];
      v7 = a1->n128_u64[1];
      v8 = a1[1].n128_u64[0];
      v11 = v5 >> 12;
    }
    v18 = (char **)(v7 + 8 * v11);
    if ( v8 == v7 )
    {
      v19 = 0LL;
      v20 = v15 - v16;
      if ( v15 > v16 )
      {
LABEL_12:
        v21 = &v9[v20];
        if ( v16 >= v15 >> 1 )
          v22 = v21;
        else
          v22 = &v6[-v16];
        if ( v22 == v9 )
        {
          v24 = v19;
          v25 = v18;
          v15 = v16;
          if ( !v16 )
            goto LABEL_111;
        }
        else
        {
          v23 = v22;
          v24 = v19;
          v25 = v18;
          do
          {
            if ( v24 == *v25 )
            {
              v27 = (__int64)*--v25;
              v24 = (char *)(v27 + 4096);
            }
            v26 = *--v23;
            *--v24 = v26;
            a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_AFBF00);
          }
          while ( v23 != v9 );
          v9 = v22;
          v15 = v16;
          if ( !v16 )
            goto LABEL_111;
        }
LABEL_46:
        v39 = v19 - *v18 + v15;
        if ( v39 < 1 )
        {
          v39 = 4095 - v39;
          v41 = (unsigned __int64)v39 >> 9;
          LOWORD(v39) = ~(_WORD)v39;
          v40 = (void **)((char *)v18 - (v41 & 0x7FFFFFFFFFFFF8LL));
        }
        else
        {
          v40 = (void **)((char *)v18 + (((unsigned __int64)v39 >> 9) & 0x7FFFFFFFFFFFF8LL));
        }
        v42 = (char *)*v40 + (v39 & 0xFFF);
        if ( v42 != v19 )
        {
          v43 = (char *)*v40 + (v39 & 0xFFF);
          v44 = v40;
          do
          {
            if ( v24 == *v25 )
            {
              v46 = (__int64)*--v25;
              v24 = (char *)(v46 + 4096);
            }
            --v24;
            if ( v43 == *v44 )
            {
              v47 = (__int64)*--v44;
              v43 = (char *)(v47 + 4096);
            }
            v45 = *--v43;
            *v24 = v45;
            a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_AFBF00);
          }
          while ( v43 != v19 );
        }
        if ( v15 < v16 )
        {
          v48 = v19 - *v18 + v16;
          if ( v48 < 1 )
          {
            v48 = 4095 - v48;
            v60 = (unsigned __int64)v48 >> 9;
            LOWORD(v48) = ~(_WORD)v48;
            v49 = (_DWORD *)((char *)v18 - (v60 & 0x7FFFFFFFFFFFF8LL));
          }
          else
          {
            v49 = (_DWORD *)((char *)v18 + (((unsigned __int64)v48 >> 9) & 0x7FFFFFFFFFFFF8LL));
          }
          v18 = (char **)sub_2D3788C((int)v40, (int)v42, (int)v49, *v49 + (unsigned int)(v48 & 0xFFF), (int)v18, v19);
          v19 = v61;
        }
        if ( v9 != v6 )
        {
          do
          {
            v64 = *v18 - v19 + 4096;
            if ( v6 - v9 <= v64 )
              v65 = v6;
            else
              v65 = &v9[v64];
            if ( v6 - v9 <= v64 )
              v66 = v6 - v9;
            else
              v66 = *v18 - v19 + 4096;
            if ( v65 != v9 )
              memmove(v19, v9, v65 - v9);
            if ( v66 )
            {
              v63 = v19 - *v18 + v66;
              if ( v63 < 1 )
              {
                v63 = 4095 - v63;
                v62 = (unsigned __int64)v63 >> 9;
                LOWORD(v63) = ~(_WORD)v63;
                v18 = (char **)((char *)v18 - (v62 & 0x7FFFFFFFFFFFF8LL));
              }
              else
              {
                v18 = (char **)((char *)v18 + (((unsigned __int64)v63 >> 9) & 0x7FFFFFFFFFFFF8LL));
              }
              v19 = &(*v18)[v63 & 0xFFF];
            }
            v9 = v65;
          }
          while ( v65 != v6 );
        }
        goto LABEL_111;
      }
    }
    else
    {
      v19 = &(*v18)[v5 & 0xFFF];
      v20 = v15 - v16;
      if ( v15 > v16 )
        goto LABEL_12;
    }
    v24 = v19;
    v25 = v18;
    if ( !v15 )
      goto LABEL_111;
    goto LABEL_46;
  }
  v28 = (v13 << 9) - 1;
  v29 = v17 + v5;
  if ( !v13 )
    v28 = 0LL;
  v30 = v28 - v29;
  if ( v15 > v30 )
  {
    sub_2D37A14(a1, v15 - v30);
    v17 = a1[2].n128_u64[1];
    v7 = a1->n128_u64[1];
    v8 = a1[1].n128_u64[0];
    v29 = a1[2].n128_u64[0] + v17;
  }
  v31 = (_QWORD *)(v7 + ((v29 >> 9) & 0x7FFFFFFFFFFFF8LL));
  if ( v8 == v7 )
    v32 = 0LL;
  else
    v32 = (char *)(*v31 + (v29 & 0xFFF));
  v33 = v17 - v16;
  if ( v17 - v16 >= v15 )
  {
    v37 = v32;
    v36 = v31;
    if ( !v15 )
      goto LABEL_111;
  }
  else
  {
    if ( v33 >= v15 >> 1 )
      v34 = &v9[v17 - v16];
    else
      v34 = &v9[v33];
    if ( v34 == v6 )
    {
      v37 = v32;
      v36 = v31;
      v15 = v17 - v16;
      if ( !v33 )
        goto LABEL_111;
    }
    else
    {
      v35 = v34;
      v36 = v31;
      v37 = v32;
      do
      {
        *v37++ = *v35;
        if ( &v37[-*v36] == (char *)&qword_1000 )
        {
          v38 = (char *)v36[1];
          ++v36;
          v37 = v38;
        }
        ++v35;
        ++a1[2].n128_u64[1];
      }
      while ( v35 != v6 );
      v6 = v34;
      v15 = v33;
      if ( !v33 )
        goto LABEL_111;
    }
  }
  v50 = (__int64)&v32[-v15 - *v31];
  if ( v50 < 1 )
  {
    v50 = 4095 - v50;
    v52 = (unsigned __int64)v50 >> 9;
    LOWORD(v50) = ~(_WORD)v50;
    v51 = (_QWORD *)((char *)v31 - (v52 & 0x7FFFFFFFFFFFF8LL));
  }
  else
  {
    v51 = (_QWORD *)((char *)v31 + (((unsigned __int64)v50 >> 9) & 0x7FFFFFFFFFFFF8LL));
  }
  v53 = (char *)(*v51 + (v50 & 0xFFF));
  if ( v53 != v32 )
  {
    v54 = v51;
    v55 = v53;
    do
    {
      *v37++ = *v55;
      if ( &v37[-*v36] == (char *)&qword_1000 )
      {
        v56 = (char *)v36[1];
        ++v36;
        v37 = v56;
      }
      if ( &(++v55)[-*v54] == (char *)&qword_1000 )
      {
        v57 = (char *)v54[1];
        ++v54;
        v55 = v57;
      }
      ++a1[2].n128_u64[1];
    }
    while ( v55 != v32 );
  }
  if ( v15 < v33 )
  {
    v58 = (__int64)&v32[-v33 - *v31];
    if ( v58 < 1 )
    {
      v58 = 4095 - v58;
      v67 = (unsigned __int64)v58 >> 9;
      LOWORD(v58) = ~(_WORD)v58;
      v59 = (char *)v31 - (v67 & 0x7FFFFFFFFFFFF8LL);
    }
    else
    {
      v59 = (char *)v31 + (((unsigned __int64)v58 >> 9) & 0x7FFFFFFFFFFFF8LL);
    }
    v68 = *(_QWORD *)v59 + (v58 & 0xFFF);
    if ( v53 != (char *)v68 )
    {
      v69 = (char *)*v51;
      v70 = (__int64)&v53[512 * ((char *)v51 - v59) - v68 - *v51 + *(_QWORD *)v59];
      if ( v70 >= 1 )
      {
        if ( v53 != v69 )
          goto LABEL_98;
LABEL_97:
        v71 = (char *)*--v51;
        v69 = v71;
        v53 = v71 + 4096;
        while ( 1 )
        {
LABEL_98:
          v72 = (_BYTE *)(v53 - v69);
          v73 = &v53[-v70];
          v74 = v53 - v69 <= v70;
          --v53;
          if ( v74 )
            v75 = v69;
          else
            v75 = v73;
          if ( v74 )
            v76 = (__int64)v72;
          else
            v76 = v70;
          sub_2D381D8(v75);
          v70 -= v76;
          if ( v76 != 1 )
          {
            v77 = (__int64)&v53[-v76 - *v51 + 1];
            if ( v77 < 1 )
            {
              v77 = 4094LL - (_QWORD)&v53[-v76 - *v51];
              v78 = (unsigned __int64)v77 >> 9;
              LOWORD(v77) = ~(_WORD)v77;
              v51 = (_QWORD *)((char *)v51 - (v78 & 0x7FFFFFFFFFFFF8LL));
            }
            else
            {
              v51 = (_QWORD *)((char *)v51 + (((unsigned __int64)v77 >> 9) & 0x7FFFFFFFFFFFF8LL));
            }
            v53 = (char *)(*v51 + (v77 & 0xFFF));
          }
          if ( v70 < 1 )
            break;
          v69 = (char *)*v51;
          if ( v53 == (char *)*v51 )
            goto LABEL_97;
        }
      }
    }
  }
  sub_2D37F00(v9, v6);
LABEL_111:
  v79 = a1->n128_u64[1];
  result = (_QWORD *)(v79 + ((a1[2].n128_u64[0] >> 9) & 0x7FFFFFFFFFFFF8LL));
  if ( a1[1].n128_u64[0] == v79 )
  {
    v81 = 0LL;
    if ( !v16 )
      return result;
  }
  else
  {
    v81 = *result + (a1[2].n128_u64[0] & 0xFFF);
    if ( !v16 )
      return result;
  }
  v82 = v81 - *result + v16;
  if ( v82 < 1 )
    return (_QWORD *)((char *)result - (((unsigned __int64)(4095 - v82) >> 9) & 0x7FFFFFFFFFFFF8LL));
  else
    return (_QWORD *)((char *)result + (((unsigned __int64)v82 >> 9) & 0x7FFFFFFFFFFFF8LL));
}


================================================================================
Function: sub_2D37208 (0x2D37208)
================================================================================

unsigned __int64 *__fastcall sub_2D37208(unsigned __int64 *result, unsigned __int64 a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x11
  __int64 v6; // x10
  unsigned __int64 v7; // x13
  unsigned __int64 v8; // x21
  __int64 v9; // x13
  unsigned __int64 v10; // x26
  unsigned __int64 v11; // x20
  __int64 v12; // x10
  __int64 v13; // x11
  _BOOL8 v14; // x22
  unsigned __int64 v15; // x24
  char *v16; // x0
  unsigned __int64 v17; // t1
  unsigned __int64 v18; // x20
  unsigned __int64 v19; // x8
  unsigned __int64 v20; // t1
  unsigned __int64 v22; // x9
  __int64 v23; // x8
  __int64 v24; // x8
  unsigned __int64 v25; // x21
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // t1
  char *v28; // x9
  unsigned __int64 v29; // x24
  __int64 *v30; // x25
  char *v31; // x22
  unsigned __int64 v32; // x20
  char *v33; // x21
  __int64 v34; // x8
  __int64 v35; // x8
  size_t v36; // x22
  __int64 v37; // x8
  __int64 v38; // x27
  char *v39; // x20
  unsigned __int64 v40; // x27
  __int64 v41; // x0
  unsigned __int64 v42; // x10
  bool v43; // zf
  signed __int64 v44; // x9
  char *v45; // x8
  unsigned __int64 v46; // x11
  char *v47; // x9
  __int64 v48; // x11
  __int128 *v49; // x14
  _OWORD *v50; // x10
  __int64 v51; // x13
  __int64 v52; // x15
  char *v53; // x13
  __int128 v54; // q0
  __int128 v55; // q1
  __int64 v56; // t1
  char *v57; // x22
  __int64 v58; // t1
  __int64 *v59; // x9
  unsigned __int64 v60; // x20
  char *v61; // x21
  __int64 v62; // x8
  __int64 v63; // x8
  size_t v64; // x22
  __int64 v65; // x8
  __int64 v66; // x26
  char *v67; // x20
  unsigned __int64 v68; // x26
  __int64 v69; // x0
  unsigned __int64 v70; // x10
  signed __int64 v71; // x9
  char *v72; // x8
  unsigned __int64 v73; // x11
  char *v74; // x9
  __int64 v75; // x11
  __int128 *v76; // x14
  _OWORD *v77; // x10
  __int64 v78; // x13
  __int64 v79; // x15
  char *v80; // x13
  __int128 v81; // q0
  __int128 v82; // q1
  __int64 v83; // t1
  char *v84; // x8
  char *v85; // x10
  char *v86; // x11
  char *v87; // x9
  unsigned __int64 v88; // x10
  signed __int64 v89; // x8
  __int64 v90; // [xsp+8h] [xbp-38h] BYREF
  unsigned __int64 v91; // [xsp+10h] [xbp-30h] BYREF
  char *v92; // [xsp+18h] [xbp-28h]
  char *v93; // [xsp+20h] [xbp-20h]
  char *v94; // [xsp+28h] [xbp-18h]
  _QWORD *v95; // [xsp+30h] [xbp-10h]

  v2 = result;
  v4 = result[1];
  v3 = result[2];
  v5 = result[4];
  v6 = v3 - v4;
  if ( v3 == v4 )
    v7 = a2 + 1;
  else
    v7 = a2;
  if ( (v7 & 0xFFF) != 0 )
    v8 = (v7 >> 12) + 1;
  else
    v8 = v7 >> 12;
  v9 = (v6 << 9) - 1;
  if ( !v6 )
    v9 = 0LL;
  if ( v8 >= (v9 - (result[5] + v5)) >> 12 )
    v10 = (v9 - (result[5] + v5)) >> 12;
  else
    v10 = v8;
  v11 = v8 - v10;
  if ( v8 == v10 )
  {
    result[4] = v5 + (v10 << 12);
    if ( v10 )
    {
      v17 = *(_QWORD *)(v3 - 8);
      result[2] = v3 - 8;
      v91 = v17;
      result = (unsigned __int64 *)sub_2D38018(result, &v91);
      if ( v10 != 1 )
      {
        v18 = 1 - v10;
        do
        {
          v19 = v2[2];
          v20 = *(_QWORD *)(v19 - 8);
          v2[2] = v19 - 8;
          v91 = v20;
          result = (unsigned __int64 *)sub_2D38018(v2, &v91);
        }
        while ( !__CFADD__(v18++, 1LL) );
      }
    }
  }
  else
  {
    v12 = v6 >> 3;
    v13 = result[3] - *result;
    if ( v11 <= (v13 >> 3) - v12 )
    {
      if ( v4 == *result )
      {
LABEL_32:
        v25 = v11;
        do
        {
          v91 = sub_6575418();
          result = (unsigned __int64 *)sub_2D3648C(v2, &v91);
          --v25;
        }
        while ( v25 );
        v10 += v11;
        v24 = v2[4];
      }
      else
      {
        while ( 1 )
        {
          v91 = sub_6575418();
          result = (unsigned __int64 *)sub_2D36644(v2, &v91);
          v22 = v2[1];
          v23 = v2[2] - v22 == 8 ? 4095LL : 4096LL;
          --v11;
          v24 = v23 + v2[4];
          v2[4] = v24;
          if ( !v11 )
            break;
          if ( v22 == *v2 )
            goto LABEL_32;
        }
      }
      for ( v2[4] = v24 + (v10 << 12); v10; --v10 )
      {
        v26 = v2[2];
        v27 = *(_QWORD *)(v26 - 8);
        v2[2] = v26 - 8;
        v91 = v27;
        result = (unsigned __int64 *)sub_2D38018(v2, &v91);
      }
    }
    else
    {
      v14 = v3 == v4;
      if ( v13 >> 2 >= v11 + v12 )
        v15 = v13 >> 2;
      else
        v15 = v11 + v12;
      v95 = result + 3;
      if ( v15 )
      {
        if ( v15 >> 61 )
          sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v16 = (char *)sub_6575418();
      }
      else
      {
        v16 = 0LL;
      }
      v28 = &v16[8 * v15];
      v29 = (v8 << 12) - v14;
      v91 = (unsigned __int64)v16;
      v92 = v16;
      v93 = v16;
      v94 = v28;
      do
      {
        v90 = sub_6575418();
        sub_2D36804(&v91, &v90);
        --v11;
      }
      while ( v11 );
      v30 = (__int64 *)v2[2];
      if ( v10 )
      {
        v31 = v93;
        do
        {
          if ( v31 == v94 )
          {
            v32 = v91;
            v33 = v92;
            if ( (unsigned __int64)v92 <= v91 )
            {
              if ( v31 == (char *)v91 )
                v40 = 1LL;
              else
                v40 = (__int64)&v31[-v91] >> 2;
              if ( v40 >> 61 )
                sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
              v41 = sub_6575418();
              v42 = v40 >> 2;
              v44 = v31 - v33;
              v43 = v31 == v33;
              v45 = (char *)(v41 + 8 * (v40 >> 2));
              v31 = v45;
              if ( !v43 )
              {
                v31 = &v45[v44 & 0xFFFFFFFFFFFFFFF8LL];
                v46 = v44 - 8;
                if ( (unsigned __int64)(v44 - 8) < 0x18 )
                {
                  v47 = (char *)(v41 + 8 * (v40 >> 2));
                  goto LABEL_64;
                }
                if ( v41 + 8 * v42 < (unsigned __int64)&v33[(v46 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
                {
                  v47 = (char *)(v41 + 8 * (v40 >> 2));
                  if ( v41 + 8 * v42 + (v46 & 0xFFFFFFFFFFFFFFF8LL) + 8 > (unsigned __int64)v33 )
                    goto LABEL_105;
                }
                v48 = (v46 >> 3) + 1;
                v49 = (__int128 *)(v33 + 16);
                v50 = (_OWORD *)(v41 + 8 * v42 + 16);
                v51 = 8 * (v48 & 0x3FFFFFFFFFFFFFFCLL);
                v52 = v48 & 0x3FFFFFFFFFFFFFFCLL;
                v47 = &v45[v51];
                v53 = &v33[v51];
                do
                {
                  v54 = *(v49 - 1);
                  v55 = *v49;
                  v49 += 2;
                  v52 -= 4LL;
                  *(v50 - 1) = v54;
                  *v50 = v55;
                  v50 += 2;
                }
                while ( v52 );
                v33 = v53;
                if ( v48 != (v48 & 0x3FFFFFFFFFFFFFFCLL) )
                {
LABEL_105:
                  do
                  {
LABEL_64:
                    v56 = *(_QWORD *)v33;
                    v33 += 8;
                    *(_QWORD *)v47 = v56;
                    v47 += 8;
                  }
                  while ( v47 != v31 );
                }
              }
              v91 = v41;
              v92 = (char *)(v41 + 8 * (v40 >> 2));
              v93 = v31;
              v94 = (char *)(v41 + 8 * v40);
              if ( v32 )
              {
                sub_6575460();
                v31 = v93;
              }
              goto LABEL_44;
            }
            v34 = (__int64)&v92[-v91] >> 3;
            if ( v34 + 1 >= 0 )
              v35 = v34 + 1;
            else
              v35 = v34 + 2;
            v36 = v31 - v92;
            v37 = v35 >> 1;
            v38 = -v37;
            v39 = &v92[-8 * v37];
            if ( v36 )
            {
              memmove(&v92[-8 * v37], v92, v36);
              v33 = v92;
            }
            v31 = &v39[v36];
            v92 = &v33[8 * v38];
            v93 = v31;
          }
LABEL_44:
          --v10;
          *(_QWORD *)v31 = *(v30 - 1);
          v31 = v93 + 8;
          v30 = (__int64 *)(v2[2] - 8);
          v93 += 8;
          v2[2] = (unsigned __int64)v30;
        }
        while ( v10 );
      }
      v57 = v93;
      if ( (__int64 *)v2[1] != v30 )
      {
        v30 = (__int64 *)v2[1];
        while ( 1 )
        {
          if ( v57 == v94 )
          {
            v60 = v91;
            v61 = v92;
            if ( (unsigned __int64)v92 <= v91 )
            {
              if ( v57 == (char *)v91 )
                v68 = 1LL;
              else
                v68 = (__int64)&v57[-v91] >> 2;
              if ( v68 >> 61 )
                sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
              v69 = sub_6575418();
              v70 = v68 >> 2;
              v71 = v57 - v61;
              v43 = v57 == v61;
              v72 = (char *)(v69 + 8 * (v68 >> 2));
              v57 = v72;
              if ( !v43 )
              {
                v57 = &v72[v71 & 0xFFFFFFFFFFFFFFF8LL];
                v73 = v71 - 8;
                if ( (unsigned __int64)(v71 - 8) < 0x18 )
                {
                  v74 = (char *)(v69 + 8 * (v68 >> 2));
                  goto LABEL_90;
                }
                if ( v69 + 8 * v70 < (unsigned __int64)&v61[(v73 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
                {
                  v74 = (char *)(v69 + 8 * (v68 >> 2));
                  if ( v69 + 8 * v70 + (v73 & 0xFFFFFFFFFFFFFFF8LL) + 8 > (unsigned __int64)v61 )
                    goto LABEL_106;
                }
                v75 = (v73 >> 3) + 1;
                v76 = (__int128 *)(v61 + 16);
                v77 = (_OWORD *)(v69 + 8 * v70 + 16);
                v78 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
                v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
                v74 = &v72[v78];
                v80 = &v61[v78];
                do
                {
                  v81 = *(v76 - 1);
                  v82 = *v76;
                  v76 += 2;
                  v79 -= 4LL;
                  *(v77 - 1) = v81;
                  *v77 = v82;
                  v77 += 2;
                }
                while ( v79 );
                v61 = v80;
                if ( v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL) )
                {
LABEL_106:
                  do
                  {
LABEL_90:
                    v83 = *(_QWORD *)v61;
                    v61 += 8;
                    *(_QWORD *)v74 = v83;
                    v74 += 8;
                  }
                  while ( v74 != v57 );
                }
              }
              v91 = v69;
              v92 = (char *)(v69 + 8 * (v68 >> 2));
              v93 = v57;
              v94 = (char *)(v69 + 8 * v68);
              if ( v60 )
              {
                sub_6575460();
                v57 = v93;
              }
              goto LABEL_70;
            }
            v62 = (__int64)&v92[-v91] >> 3;
            if ( v62 + 1 >= 0 )
              v63 = v62 + 1;
            else
              v63 = v62 + 2;
            v64 = v57 - v92;
            v65 = v63 >> 1;
            v66 = -v65;
            v67 = &v92[-8 * v65];
            if ( v64 )
            {
              memmove(&v92[-8 * v65], v92, v64);
              v61 = v92;
            }
            v57 = &v67[v64];
            v92 = &v61[8 * v66];
            v93 = v57;
          }
LABEL_70:
          v58 = *v30++;
          *(_QWORD *)v57 = v58;
          v59 = (__int64 *)v2[2];
          v57 = v93 + 8;
          v93 += 8;
          if ( v30 == v59 )
          {
            v84 = (char *)v2[1];
            goto LABEL_95;
          }
        }
      }
      v84 = (char *)v30;
LABEL_95:
      v85 = v92;
      result = (unsigned __int64 *)*v2;
      v86 = v94;
      *v2 = v91;
      v2[1] = (unsigned __int64)v85;
      v87 = (char *)v2[3];
      v88 = v2[4];
      v91 = (unsigned __int64)result;
      v92 = v84;
      v89 = (char *)v30 - v84;
      v2[2] = (unsigned __int64)v57;
      v2[3] = (unsigned __int64)v86;
      v93 = (char *)v30;
      v94 = v87;
      v2[4] = v29 + v88;
      if ( v89 )
        v93 = (char *)&v30[~((unsigned __int64)(v89 - 8) >> 3)];
      if ( result )
        return (unsigned __int64 *)sub_6575460();
    }
  }
  return result;
}


================================================================================
Function: sub_2D3788C (0x2D3788C)
================================================================================

_QWORD *__fastcall sub_2D3788C(_QWORD *a1, char *a2, char *a3, char *a4, _QWORD *a5, char *dest)
{
  char *v8; // x22
  _QWORD *v9; // x20
  __int64 v10; // x23
  unsigned __int64 v11; // x9
  __int64 v12; // x8
  __int64 v13; // x8
  __int64 v14; // x25
  __int64 v15; // x26
  char *v16; // x1
  unsigned __int64 v17; // x9
  __int64 v18; // x8
  __int64 v19; // x8
  char *v20; // x27
  __int64 v21; // x28

  if ( a4 != a2 )
  {
    v8 = a2;
    v9 = a1;
    v10 = &a4[512 * (a3 - (char *)a1)] - &a2[*(_QWORD *)a3] + *a1;
    if ( v10 >= 1 )
    {
      do
      {
        v13 = *v9 + 4096LL;
        if ( v13 - (__int64)v8 <= v10 )
          v14 = v13 - (_QWORD)v8;
        else
          v14 = v10;
        if ( v13 - (__int64)v8 <= v10 )
          v15 = *v9 + 4096LL;
        else
          v15 = (__int64)&v8[v10];
        if ( v8 != (char *)v15 )
        {
          v16 = v8;
          do
          {
            v19 = *a5 - (_QWORD)dest + 4096LL;
            if ( v15 - (__int64)v16 <= v19 )
              v20 = (char *)v15;
            else
              v20 = &v16[v19];
            if ( v15 - (__int64)v16 <= v19 )
              v21 = v15 - (_QWORD)v16;
            else
              v21 = *a5 - (_QWORD)dest + 4096LL;
            if ( v20 != v16 )
              memmove(dest, v16, v20 - v16);
            if ( v21 )
            {
              v18 = (__int64)&dest[v21 - *a5];
              if ( v18 < 1 )
              {
                v18 = 4095 - v18;
                v17 = (unsigned __int64)v18 >> 9;
                LOWORD(v18) = ~(_WORD)v18;
                a5 = (_QWORD *)((char *)a5 - (v17 & 0x7FFFFFFFFFFFF8LL));
              }
              else
              {
                a5 = (_QWORD *)((char *)a5 + (((unsigned __int64)v18 >> 9) & 0x7FFFFFFFFFFFF8LL));
              }
              dest = (char *)(*a5 + (v18 & 0xFFF));
            }
            v16 = v20;
          }
          while ( v20 != (char *)v15 );
        }
        v10 -= v14;
        if ( v14 )
        {
          v12 = (__int64)&v8[v14 - *v9];
          if ( v12 < 1 )
          {
            v12 = 4095 - v12;
            v11 = (unsigned __int64)v12 >> 9;
            LOWORD(v12) = ~(_WORD)v12;
            v9 = (_QWORD *)((char *)v9 - (v11 & 0x7FFFFFFFFFFFF8LL));
          }
          else
          {
            v9 = (_QWORD *)((char *)v9 + (((unsigned __int64)v12 >> 9) & 0x7FFFFFFFFFFFF8LL));
          }
          v8 = (char *)(*v9 + (v12 & 0xFFF));
        }
      }
      while ( v10 > 0 );
    }
  }
  return a5;
}


================================================================================
Function: sub_2D37A14 (0x2D37A14)
================================================================================

unsigned __int64 *__fastcall sub_2D37A14(unsigned __int64 *result, unsigned __int64 a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 *v3; // x8
  unsigned __int64 *v4; // x9
  unsigned __int64 v5; // x11
  __int64 v6; // x10
  unsigned __int64 v7; // x12
  unsigned __int64 v8; // x12
  unsigned __int64 v9; // x24
  unsigned __int64 v10; // x20
  unsigned __int64 *v11; // x9
  __int64 v12; // x21
  __int64 v13; // x11
  unsigned __int64 v14; // x22
  __int64 v15; // x0
  unsigned __int64 v16; // x8
  unsigned __int64 v17; // x20
  unsigned __int64 *v18; // x8
  unsigned __int64 v19; // t1
  unsigned __int64 v21; // x22
  __int64 v22; // x8
  __int64 v23; // x8
  __int64 v24; // x25
  _QWORD *v25; // x26
  char *v26; // x22
  unsigned __int64 v27; // x20
  char *v28; // x21
  __int64 v29; // x8
  __int64 v30; // x8
  size_t v31; // x22
  __int64 v32; // x8
  __int64 v33; // x27
  __int64 v34; // x20
  unsigned __int64 v35; // x27
  __int64 v36; // x0
  unsigned __int64 v37; // x10
  bool v38; // zf
  signed __int64 v39; // x9
  char *v40; // x8
  unsigned __int64 v41; // x11
  char *v42; // x9
  __int64 v43; // x11
  __int128 *v44; // x14
  _OWORD *v45; // x10
  __int64 v46; // x13
  __int64 v47; // x15
  char *v48; // x13
  __int128 v49; // q0
  __int128 v50; // q1
  __int64 v51; // t1
  unsigned __int64 v52; // x20
  unsigned __int64 v53; // x21
  unsigned __int64 v54; // x10
  __int128 v55; // q0
  unsigned __int64 v56; // x8
  char *v57; // x9
  char *v58; // x11
  unsigned __int64 *v59; // x8
  unsigned __int64 v60; // t1
  __int64 v61; // [xsp+8h] [xbp-38h] BYREF
  unsigned __int64 v62; // [xsp+10h] [xbp-30h] BYREF
  __int128 v63; // [xsp+18h] [xbp-28h]
  char *v64; // [xsp+28h] [xbp-18h]
  _QWORD *v65; // [xsp+30h] [xbp-10h]

  v2 = result;
  v4 = (unsigned __int64 *)result[1];
  v3 = (unsigned __int64 *)result[2];
  v5 = result[4];
  v6 = (char *)v3 - (char *)v4;
  if ( v3 == v4 )
    v7 = a2 + 1;
  else
    v7 = a2;
  if ( (v7 & 0xFFF) != 0 )
    v8 = (v7 >> 12) + 1;
  else
    v8 = v7 >> 12;
  if ( v8 >= v5 >> 12 )
    v9 = v5 >> 12;
  else
    v9 = v8;
  v10 = v8 - v9;
  if ( v8 == v9 )
  {
    result[4] = v5 - (v9 << 12);
    if ( v9 )
    {
      v16 = *v4;
      result[1] = (unsigned __int64)(v4 + 1);
      v62 = v16;
      result = (unsigned __int64 *)sub_2D362D4(result, &v62);
      if ( v9 != 1 )
      {
        v17 = 1 - v9;
        do
        {
          v18 = (unsigned __int64 *)v2[1];
          v19 = *v18;
          v2[1] = (unsigned __int64)(v18 + 1);
          v62 = v19;
          result = (unsigned __int64 *)sub_2D362D4(v2, &v62);
        }
        while ( !__CFADD__(v17++, 1LL) );
      }
    }
  }
  else
  {
    v11 = (unsigned __int64 *)result[3];
    v12 = v6 >> 3;
    v13 = (__int64)v11 - *result;
    if ( v10 <= (v13 >> 3) - (v6 >> 3) )
    {
      if ( v11 == v3 )
      {
LABEL_27:
        v21 = v10;
        do
        {
          v62 = sub_6575418();
          result = (unsigned __int64 *)sub_2D36644(v2, &v62);
          --v21;
          if ( v2[2] - v2[1] == 8 )
            v22 = 4095LL;
          else
            v22 = 4096LL;
          v23 = v22 + v2[4];
          v2[4] = v23;
        }
        while ( v21 );
        v9 += v10;
      }
      else
      {
        while ( 1 )
        {
          v62 = sub_6575418();
          result = (unsigned __int64 *)sub_2D3648C(v2, &v62);
          if ( !--v10 )
            break;
          if ( v2[3] == v2[2] )
            goto LABEL_27;
        }
        v23 = v2[4];
      }
      for ( v2[4] = v23 - (v9 << 12); v9; --v9 )
      {
        v59 = (unsigned __int64 *)v2[1];
        v60 = *v59;
        v2[1] = (unsigned __int64)(v59 + 1);
        v62 = v60;
        result = (unsigned __int64 *)sub_2D362D4(v2, &v62);
      }
    }
    else
    {
      if ( v13 >> 2 >= v10 + v12 )
        v14 = v13 >> 2;
      else
        v14 = v10 + v12;
      v65 = result + 3;
      if ( v14 )
      {
        if ( v14 >> 61 )
          sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v15 = sub_6575418();
      }
      else
      {
        v15 = 0LL;
      }
      v24 = -4096LL * v9;
      v62 = v15;
      *(_QWORD *)&v63 = v15 + 8 * (v12 - v9);
      *((_QWORD *)&v63 + 1) = v63;
      v64 = (char *)(v15 + 8 * v14);
      do
      {
        v61 = sub_6575418();
        sub_2D36804(&v62, &v61);
        --v10;
      }
      while ( v10 );
      if ( v9 )
      {
        v25 = (_QWORD *)v2[1];
        v26 = (char *)*((_QWORD *)&v63 + 1);
        do
        {
          if ( v26 == v64 )
          {
            v27 = v62;
            v28 = (char *)v63;
            if ( (unsigned __int64)v63 <= v62 )
            {
              if ( v26 == (char *)v62 )
                v35 = 1LL;
              else
                v35 = (__int64)&v26[-v62] >> 2;
              if ( v35 >> 61 )
                sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
              v36 = sub_6575418();
              v37 = v35 >> 2;
              v39 = v26 - v28;
              v38 = v26 == v28;
              v40 = (char *)(v36 + 8 * (v35 >> 2));
              v26 = v40;
              if ( !v38 )
              {
                v26 = &v40[v39 & 0xFFFFFFFFFFFFFFF8LL];
                v41 = v39 - 8;
                if ( (unsigned __int64)(v39 - 8) < 0x18 )
                {
                  v42 = (char *)(v36 + 8 * (v35 >> 2));
                  goto LABEL_59;
                }
                if ( v36 + 8 * v37 < (unsigned __int64)&v28[(v41 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
                {
                  v42 = (char *)(v36 + 8 * (v35 >> 2));
                  if ( v36 + 8 * v37 + (v41 & 0xFFFFFFFFFFFFFFF8LL) + 8 > (unsigned __int64)v28 )
                    goto LABEL_77;
                }
                v43 = (v41 >> 3) + 1;
                v44 = (__int128 *)(v28 + 16);
                v45 = (_OWORD *)(v36 + 8 * v37 + 16);
                v46 = 8 * (v43 & 0x3FFFFFFFFFFFFFFCLL);
                v47 = v43 & 0x3FFFFFFFFFFFFFFCLL;
                v42 = &v40[v46];
                v48 = &v28[v46];
                do
                {
                  v49 = *(v44 - 1);
                  v50 = *v44;
                  v44 += 2;
                  v47 -= 4LL;
                  *(v45 - 1) = v49;
                  *v45 = v50;
                  v45 += 2;
                }
                while ( v47 );
                v28 = v48;
                if ( v43 != (v43 & 0x3FFFFFFFFFFFFFFCLL) )
                {
LABEL_77:
                  do
                  {
LABEL_59:
                    v51 = *(_QWORD *)v28;
                    v28 += 8;
                    *(_QWORD *)v42 = v51;
                    v42 += 8;
                  }
                  while ( v42 != v26 );
                }
              }
              v62 = v36;
              *(_QWORD *)&v63 = v36 + 8 * (v35 >> 2);
              *((_QWORD *)&v63 + 1) = v26;
              v64 = (char *)(v36 + 8 * v35);
              if ( v27 )
              {
                sub_6575460();
                v26 = (char *)*((_QWORD *)&v63 + 1);
              }
              goto LABEL_39;
            }
            v29 = (__int64)(v63 - v62) >> 3;
            if ( v29 + 1 >= 0 )
              v30 = v29 + 1;
            else
              v30 = v29 + 2;
            v31 = (size_t)&v26[-v63];
            v32 = v30 >> 1;
            v33 = -v32;
            v34 = v63 - 8 * v32;
            if ( v31 )
            {
              memmove((void *)(v63 - 8 * v32), (const void *)v63, v31);
              v28 = (char *)v63;
            }
            v26 = (char *)(v34 + v31);
            *(_QWORD *)&v63 = &v28[8 * v33];
            *((_QWORD *)&v63 + 1) = v26;
          }
LABEL_39:
          --v9;
          *(_QWORD *)v26 = *v25;
          v26 = (char *)(*((_QWORD *)&v63 + 1) + 8LL);
          v25 = (_QWORD *)(v2[1] + 8);
          *((_QWORD *)&v63 + 1) += 8LL;
          v2[1] = (unsigned __int64)v25;
        }
        while ( v9 );
      }
      v52 = v2[2];
      v53 = v52 + 8;
      while ( v52 != v2[1] )
      {
        v52 -= 8LL;
        v53 -= 8LL;
        sub_2D369BC(&v62, v52);
      }
      v54 = v2[4];
      result = (unsigned __int64 *)*v2;
      *v2 = v62;
      v55 = v63;
      v56 = v2[2];
      v57 = (char *)v2[3];
      v62 = (unsigned __int64)result;
      *(_QWORD *)&v63 = v52;
      v58 = v64;
      *(_OWORD *)(v2 + 1) = v55;
      *((_QWORD *)&v63 + 1) = v56;
      v64 = v57;
      v2[3] = (unsigned __int64)v58;
      v2[4] = v54 + v24;
      if ( v52 != v56 )
        *((_QWORD *)&v63 + 1) = v56 + 8 * ~((v56 - v53) >> 3);
      if ( result )
        return (unsigned __int64 *)sub_6575460();
    }
  }
  return result;
}


================================================================================
Function: sub_2D37F00 (0x2D37F00)
================================================================================

_QWORD *__fastcall sub_2D37F00(char *a1, char *a2, _QWORD *a3, __int64 a4)
{
  char *v6; // x22
  unsigned __int64 v8; // x9
  __int64 v9; // x8
  char *v10; // x8
  __int64 v11; // x10
  __int64 v12; // x9
  unsigned __int64 v13; // x9
  __int64 v14; // x10
  __int64 v15; // x9
  __int64 v16; // x24

  if ( a2 != a1 )
  {
    v6 = a2;
    do
    {
      v10 = v6;
      v11 = ~*a3 + a4;
      if ( v11 < 1 )
      {
        v11 = 4095 - v11;
        v13 = (unsigned __int64)v11 >> 9;
        LOWORD(v11) = ~(_WORD)v11;
        v12 = *(_QWORD *)((char *)a3 - (v13 & 0x7FFFFFFFFFFFF8LL));
      }
      else
      {
        v12 = *(_QWORD *)((char *)a3 + (((unsigned __int64)v11 >> 9) & 0x7FFFFFFFFFFFF8LL));
      }
      v14 = v12 + (v11 & 0xFFF) + 1;
      v15 = v14 - v12;
      if ( v6 - a1 <= v15 )
        v6 = a1;
      else
        v6 -= v15;
      if ( v10 - a1 <= v15 )
        v16 = v10 - a1;
      else
        v16 = v15;
      if ( v10 != v6 )
        memmove((void *)(v14 - (v10 - v6)), v6, v10 - v6);
      if ( v16 )
      {
        v9 = a4 - (v16 + *a3);
        if ( v9 < 1 )
        {
          v9 = 4095 - v9;
          v8 = (unsigned __int64)v9 >> 9;
          LOWORD(v9) = ~(_WORD)v9;
          a3 = (_QWORD *)((char *)a3 - (v8 & 0x7FFFFFFFFFFFF8LL));
        }
        else
        {
          a3 = (_QWORD *)((char *)a3 + (((unsigned __int64)v9 >> 9) & 0x7FFFFFFFFFFFF8LL));
        }
        a4 = *a3 + (v9 & 0xFFF);
      }
    }
    while ( v6 != a1 );
  }
  return a3;
}


================================================================================
Function: sub_2D38018 (0x2D38018)
================================================================================

__int64 __fastcall sub_2D38018(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_6575418();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_6575460();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_2D381D8 (0x2D381D8)
================================================================================

_QWORD *__fastcall sub_2D381D8(char *a1, char *a2, _QWORD *a3, __int64 a4)
{
  char *v6; // x22
  unsigned __int64 v8; // x9
  __int64 v9; // x8
  char *v10; // x8
  __int64 v11; // x10
  __int64 v12; // x9
  unsigned __int64 v13; // x9
  __int64 v14; // x10
  __int64 v15; // x9
  __int64 v16; // x24

  if ( a2 != a1 )
  {
    v6 = a2;
    do
    {
      v10 = v6;
      v11 = ~*a3 + a4;
      if ( v11 < 1 )
      {
        v11 = 4095 - v11;
        v13 = (unsigned __int64)v11 >> 9;
        LOWORD(v11) = ~(_WORD)v11;
        v12 = *(_QWORD *)((char *)a3 - (v13 & 0x7FFFFFFFFFFFF8LL));
      }
      else
      {
        v12 = *(_QWORD *)((char *)a3 + (((unsigned __int64)v11 >> 9) & 0x7FFFFFFFFFFFF8LL));
      }
      v14 = v12 + (v11 & 0xFFF) + 1;
      v15 = v14 - v12;
      if ( v6 - a1 <= v15 )
        v6 = a1;
      else
        v6 -= v15;
      if ( v10 - a1 <= v15 )
        v16 = v10 - a1;
      else
        v16 = v15;
      if ( v10 != v6 )
        memmove((void *)(v14 - (v10 - v6)), v6, v10 - v6);
      if ( v16 )
      {
        v9 = a4 - (v16 + *a3);
        if ( v9 < 1 )
        {
          v9 = 4095 - v9;
          v8 = (unsigned __int64)v9 >> 9;
          LOWORD(v9) = ~(_WORD)v9;
          a3 = (_QWORD *)((char *)a3 - (v8 & 0x7FFFFFFFFFFFF8LL));
        }
        else
        {
          a3 = (_QWORD *)((char *)a3 + (((unsigned __int64)v9 >> 9) & 0x7FFFFFFFFFFFF8LL));
        }
        a4 = *a3 + (v9 & 0xFFF);
      }
    }
    while ( v6 != a1 );
  }
  return a3;
}


================================================================================
Function: sub_2D382F0 (0x2D382F0)
================================================================================

__int64 __fastcall sub_2D382F0(__int64 a1, __int64 a2, _QWORD *a3, char *a4, char *a5, char *a6)
{
  char *v9; // x23
  _QWORD *v10; // x22
  unsigned __int64 v11; // x26
  char *v12; // x0
  unsigned int v13; // w8
  char v14; // t1
  char *v15; // t1
  bool v16; // zf
  unsigned __int64 v17; // x8
  char *v18; // x2
  __int64 v19; // x19
  unsigned __int64 v21; // [xsp+0h] [xbp-20h] BYREF
  unsigned __int64 v22; // [xsp+8h] [xbp-18h]
  char *v23; // [xsp+10h] [xbp-10h]

  if ( a6 == a4 )
  {
    v13 = 0;
    v12 = (char *)&v21 + 1;
    LOBYTE(v21) = 0;
  }
  else
  {
    v9 = a4;
    v10 = a3;
    v11 = &a6[512 * (a5 - (char *)a3)] - &a4[*(_QWORD *)a5] + *a3;
    if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_67D2618();
    if ( v11 >= 0x17 )
    {
      v12 = (char *)sub_6575418();
      v22 = v11;
      v23 = v12;
      v21 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v12 = (char *)&v21 + 1;
      LOBYTE(v21) = 2 * ((_BYTE)a6 - ((_BYTE)a4 + *a5) + *(_BYTE *)a3);
    }
    do
    {
      v14 = *v9++;
      *v12 = v14;
      if ( &v9[-*v10] == (char *)&qword_1000 )
      {
        v15 = (char *)v10[1];
        ++v10;
        v9 = v15;
      }
      ++v12;
    }
    while ( v9 != a6 );
    v13 = (unsigned __int8)v21;
  }
  *v12 = 0;
  v16 = (v13 & 1) == 0;
  v17 = v13 >> 1;
  if ( v16 )
  {
    v18 = (char *)&v21 + 1;
  }
  else
  {
    v17 = v22;
    v18 = v23;
  }
  v19 = sub_2D38478(a1, a2, v18, &v18[v17]);
  if ( (v21 & 1) != 0 )
    sub_6575460();
  return v19;
}


================================================================================
Function: sub_2D38478 (0x2D38478)
================================================================================

unsigned __int64 __fastcall sub_2D38478(_QWORD *a1, __int64 a2, char *a3, char *a4)
{
  unsigned int v5; // w10
  char *v6; // x9
  int v7; // w8
  char *v8; // x28
  size_t v9; // x23
  size_t v10; // x21
  __int64 v11; // x10
  unsigned __int64 v12; // x20
  __int64 v15; // x25
  _BOOL4 v16; // w27
  char *v17; // x21
  unsigned __int64 v18; // x1
  char *v19; // x9
  size_t v20; // x8
  char *v21; // x8
  char *v22; // x10
  unsigned __int64 v23; // x8
  char *v24; // x2
  unsigned __int64 v25; // x11
  __int128 *v26; // x10
  char *v27; // x12
  unsigned __int64 v28; // x13
  __int128 v29; // q0
  __int128 v30; // q1
  char *v31; // x13
  char *v32; // x9
  unsigned __int64 v33; // x11
  __int64 v34; // t1
  char v35; // t1
  char *v36; // x8
  unsigned __int64 v38; // [xsp+0h] [xbp-20h] BYREF
  size_t v39; // [xsp+8h] [xbp-18h]
  char *v40; // [xsp+10h] [xbp-10h]

  v5 = *(unsigned __int8 *)a1;
  v6 = (char *)a1[2];
  v7 = v5 & 1;
  if ( (v5 & 1) != 0 )
    v8 = (char *)a1[2];
  else
    v8 = (char *)a1 + 1;
  v9 = a4 - a3;
  v10 = a2 - (_QWORD)v8;
  if ( a4 == a3 )
  {
LABEL_53:
    if ( v7 )
      v36 = v6;
    else
      v36 = (char *)a1 + 1;
    return (unsigned __int64)&v36[v10];
  }
  v11 = v5 >> 1;
  v12 = (unsigned __int64)a4;
  if ( v7 )
    v15 = a1[1];
  else
    v15 = v11;
  v16 = v8 <= a3 && &v8[v15] > a3;
  if ( !v16 )
  {
    if ( v7 )
      v18 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    else
      v18 = 22LL;
    if ( v18 - v15 >= v9 )
    {
      if ( v15 != v10 )
        memmove(&v8[v10 + v9], &v8[v10], v15 - v10);
      v19 = v8;
    }
    else
    {
      sub_67D29A8((__int64)a1, v18, v15 + v9 - v18, v15, v10, 0LL, v9);
      v19 = (char *)a1[2];
    }
    v20 = v15 + v9;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v20;
    else
      *(_BYTE *)a1 = 2 * v20;
    v19[v20] = 0;
    if ( a3 == (char *)v12 )
    {
LABEL_52:
      v6 = (char *)a1[2];
      v7 = *(_BYTE *)a1 & 1;
      goto LABEL_53;
    }
    v21 = &v19[v10];
    if ( v9 < 8 )
    {
      v22 = a3;
      goto LABEL_50;
    }
    if ( (unsigned __int64)v21 < v12 && &v19[v12 + a2 - (unsigned __int64)&v8[(_QWORD)a3]] > a3 )
    {
      v22 = a3;
      goto LABEL_50;
    }
    if ( v9 >= 0x20 )
    {
      v25 = v9 & 0xFFFFFFFFFFFFFFE0LL;
      v26 = (__int128 *)(a3 + 16);
      v27 = &v19[v10 + 16];
      v28 = v9 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v29 = *(v26 - 1);
        v30 = *v26;
        v26 += 2;
        v28 -= 32LL;
        *((_OWORD *)v27 - 1) = v29;
        *(_OWORD *)v27 = v30;
        v27 += 32;
      }
      while ( v28 );
      if ( v9 == v25 )
        goto LABEL_51;
      if ( (v9 & 0x18) == 0 )
      {
        v22 = &a3[v25];
        v21 += v25;
        do
        {
LABEL_50:
          v35 = *v22++;
          *v21++ = v35;
        }
        while ( v22 != (char *)v12 );
        goto LABEL_51;
      }
    }
    else
    {
      v25 = 0LL;
    }
    v21 += v9 & 0xFFFFFFFFFFFFFFF8LL;
    v22 = &a3[v9 & 0xFFFFFFFFFFFFFFF8LL];
    v31 = &a3[v25];
    v32 = &v19[v25 + a2 - (_QWORD)v8];
    v33 = v25 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
    do
    {
      v34 = *(_QWORD *)v31;
      v31 += 8;
      v33 += 8LL;
      *(_QWORD *)v32 = v34;
      v32 += 8;
    }
    while ( v33 );
    if ( v9 != (v9 & 0xFFFFFFFFFFFFFFF8LL) )
      goto LABEL_50;
LABEL_51:
    if ( v16 )
      return v12;
    goto LABEL_52;
  }
  if ( v9 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( v9 <= 0x16 )
  {
    v17 = (char *)&v38 + 1;
    LOBYTE(v38) = 2 * v9;
    if ( a3 == a4 )
      goto LABEL_29;
    goto LABEL_28;
  }
  v17 = (char *)sub_6575418();
  v39 = v9;
  v40 = v17;
  v38 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  if ( a3 != (char *)v12 )
  {
LABEL_28:
    memcpy(v17, a3, v9);
    v17 += v9;
  }
LABEL_29:
  *v17 = 0;
  v23 = (unsigned __int64)(unsigned __int8)v38 >> 1;
  if ( (v38 & 1) != 0 )
    v24 = v40;
  else
    v24 = (char *)&v38 + 1;
  if ( (v38 & 1) != 0 )
    v23 = v39;
  v12 = sub_2D38478(a1, a2, v24, &v24[v23]);
  if ( (v38 & 1) != 0 )
    sub_6575460();
  return v12;
}


================================================================================
Function: sub_2D7C0E4 (0x2D7C0E4)
================================================================================

__int64 __fastcall sub_2D7C0E4(__int64 a1, char *s)
{
  size_t v4; // x0
  size_t v5; // x21
  char *v6; // x22
  unsigned __int64 v7; // x23
  unsigned int v8; // w19
  _QWORD v10[3]; // [xsp+0h] [xbp-20h] BYREF

  v4 = strlen(s);
  if ( v4 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v5 = v4;
  if ( v4 >= 0x17 )
  {
    v7 = (v4 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v6 = (char *)sub_6575418();
    v10[1] = v5;
    v10[2] = v6;
    v10[0] = v7 | 1;
    goto LABEL_6;
  }
  v6 = (char *)v10 + 1;
  LOBYTE(v10[0]) = 2 * v4;
  if ( v4 )
LABEL_6:
    memcpy(v6, s, v5);
  v6[v5] = 0;
  v8 = sub_6762DC8(a1, v10);
  if ( (v10[0] & 1) != 0 )
    sub_6575460();
  return v8;
}


================================================================================
Function: sub_2D7C96C (0x2D7C96C)
================================================================================

__int64 __fastcall sub_2D7C96C(__int64 *a1, __int64 a2)
{
  __int64 result; // x0
  __int64 v4; // x9
  __int64 v5; // x10
  __int64 v6; // x19
  __int64 v7; // [xsp+8h] [xbp-18h] BYREF
  __int64 v8; // [xsp+10h] [xbp-10h] BYREF

  v7 = a2;
  v8 = 0LL;
  result = sub_2D7CD80(&v7, a2, &v8);
  v4 = v8;
  v5 = *a1;
  v6 = a1[1];
  *a1 = v7;
  a1[1] = v4;
  v7 = v5;
  v8 = v6;
  if ( v6 )
  {
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 12));
      if ( (_DWORD)result == 1 )
        return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  return result;
}


================================================================================
Function: sub_2D7CD80 (0x2D7CD80)
================================================================================

_QWORD *__fastcall sub_2D7CD80(__int64 a1, __int64 a2, __int64 *a3)
{
  _QWORD *result; // x0
  __int64 v6; // x20

  result = (_QWORD *)sub_6575418();
  v6 = *a3;
  result[2] = a2;
  *a3 = (__int64)result;
  *result = off_6876860;
  result[1] = 0x100000001LL;
  if ( v6 )
  {
    result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 12));
      if ( (_DWORD)result == 1 )
        return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  return result;
}


================================================================================
Function: sub_306491C (0x306491C)
================================================================================

__int64 **__fastcall sub_306491C(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3, __int128 **a4)
{
  unsigned __int64 v4; // x27
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  bool v10; // zf
  unsigned __int64 v11; // x8
  __int64 *v12; // x1
  unsigned __int64 v13; // x2
  unsigned __int64 v14; // x0
  unsigned __int64 v15; // x20
  unsigned __int64 v16; // x26
  uint8x8_t v17; // d0
  unsigned __int64 v18; // x28
  __int64 ***v19; // x8
  unsigned __int64 v20; // x10
  unsigned __int8 *v21; // x11
  unsigned __int8 *v22; // x12
  unsigned __int64 v23; // x9
  __int64 **v24; // x22
  size_t v25; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x11
  __int64 *v30; // x0
  __int64 v31; // x9
  __int64 *v32; // x23
  __int64 v33; // x22
  __int128 *v34; // x1
  __int64 v35; // x8
  float v36; // s1
  float v37; // s0
  _BOOL8 v38; // x9
  unsigned __int64 v39; // x10
  unsigned __int64 v40; // x1
  __int64 v41; // x8
  __int64 *v42; // x9
  __int64 v43; // x9
  unsigned __int64 v44; // x9
  _QWORD v46[2]; // [xsp+0h] [xbp-20h] BYREF
  char v47; // [xsp+10h] [xbp-10h]

  v8 = *((_QWORD *)a2 + 1);
  v9 = *a2;
  v10 = (v9 & 1) == 0;
  v11 = v9 >> 1;
  if ( v10 )
    v12 = (__int64 *)(a2 + 1);
  else
    v12 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v10 )
    v13 = v11;
  else
    v13 = v8;
  v14 = sub_24DF128((__int64)v46, v12, v13);
  v15 = v14;
  v16 = *(_QWORD *)(a1 + 8);
  if ( v16 )
  {
    v17.n64_u64[0] = vcnt_s8((int8x8_t)v16).n64_u64[0];
    v17.n64_u16[0] = vaddlv_u8(v17);
    v18 = v17.n64_u32[0];
    if ( v17.n64_u32[0] > 1uLL )
    {
      v4 = v14;
      if ( v14 >= v16 )
        v4 = v14 % v16;
    }
    else
    {
      v4 = (v16 - 1) & v14;
    }
    v19 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v4);
    if ( v19 )
    {
      v20 = *((_QWORD *)a2 + 1);
      v21 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v22 = a2 + 1;
      v23 = *a2;
      v24 = *v19;
      v25 = (v23 & 1) != 0 ? v20 : v23 >> 1;
      for ( i = (v23 & 1) != 0 ? v21 : v22; v24; v24 = (__int64 **)*v24 )
      {
        v27 = (unsigned __int64)v24[1];
        if ( v27 != v15 )
        {
          if ( v18 > 1 )
          {
            if ( v27 >= v16 )
              v27 %= v16;
          }
          else
          {
            v27 &= v16 - 1;
          }
          if ( v27 != v4 )
            break;
        }
        v28 = *((unsigned __int8 *)v24 + 16);
        v29 = (unsigned __int64)v24[3];
        if ( (v28 & 1) == 0 )
          v29 = v28 >> 1;
        if ( v29 == v25 )
        {
          if ( (v28 & 1) != 0 )
            v30 = v24[4];
          else
            v30 = (__int64 *)((char *)v24 + 17);
          if ( (v28 & 1) != 0 )
          {
            if ( !v25 || !memcmp(v30, i, v25) )
              return v24;
          }
          else
          {
            if ( !v25 )
              return v24;
            v31 = 0LL;
            while ( *((unsigned __int8 *)v24 + v31 + 17) == i[v31] )
            {
              if ( v28 >> 1 == ++v31 )
                return v24;
            }
          }
        }
      }
    }
  }
  v32 = (__int64 *)(a1 + 16);
  v33 = sub_6575418();
  v34 = *a4;
  v47 = 0;
  v46[0] = v33;
  v46[1] = a1 + 16;
  sub_67D2788((unsigned __int64 *)(v33 + 16), v34);
  v35 = *(_QWORD *)(a1 + 24);
  v36 = *(float *)(a1 + 32);
  *(_DWORD *)(v33 + 40) = 0;
  *(_QWORD *)v33 = 0LL;
  *(_QWORD *)(v33 + 8) = v15;
  v47 = 1;
  v37 = (float)(unsigned __int64)(v35 + 1);
  if ( !v16 || (float)(v36 * (float)v16) < v37 )
  {
    v38 = v16 < 3 || (v16 & (v16 - 1)) != 0;
    v39 = vcvtps_u32_f32(v37 / v36);
    if ( (v38 | (2 * v16)) >= v39 )
      v40 = v38 | (2 * v16);
    else
      v40 = v39;
    sub_3064C50(a1, v40);
    v16 = *(_QWORD *)(a1 + 8);
    if ( (v16 & (v16 - 1)) != 0 )
    {
      if ( v15 >= v16 )
        v4 = v15 % v16;
      else
        v4 = v15;
    }
    else
    {
      v4 = (v16 - 1) & v15;
    }
  }
  v41 = *(_QWORD *)a1;
  v42 = *(__int64 **)(*(_QWORD *)a1 + 8 * v4);
  if ( v42 )
  {
    *(_QWORD *)v33 = *v42;
    *v42 = v33;
  }
  else
  {
    v43 = *v32;
    *v32 = v33;
    *(_QWORD *)v33 = v43;
    *(_QWORD *)(v41 + 8 * v4) = v32;
    if ( *(_QWORD *)v46[0] )
    {
      v44 = *(_QWORD *)(*(_QWORD *)v46[0] + 8LL);
      if ( (v16 & (v16 - 1)) != 0 )
      {
        if ( v44 >= v16 )
          v44 %= v16;
      }
      else
      {
        v44 &= v16 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v44) = v46[0];
    }
  }
  v24 = (__int64 **)v46[0];
  ++*(_QWORD *)(a1 + 24);
  return v24;
}


================================================================================
Function: sub_3064C50 (0x3064C50)
================================================================================

unsigned __int64 __fastcall sub_3064C50(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x13
  unsigned __int64 v10; // x11
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  __int64 *v13; // x26
  unsigned __int64 v14; // x12
  unsigned __int64 v15; // x27
  __int64 v16; // x8
  unsigned __int64 v17; // x24
  _QWORD *v18; // x28
  size_t v19; // x21
  _QWORD *v20; // x23
  __int64 v21; // x8
  char v22; // w9
  unsigned int v23; // t1
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x11
  unsigned __int8 *v26; // x1
  unsigned __int8 *v27; // x8
  unsigned __int64 v28; // x9
  unsigned __int64 v29; // [xsp+8h] [xbp-48h]
  _QWORD *v30; // [xsp+10h] [xbp-40h]
  unsigned __int64 v31; // [xsp+18h] [xbp-38h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_67A4870(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_67A4870(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24DE568("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_6575418();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_6575460();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = (__int64 *)*v9;
          if ( *v9 )
          {
            v14 = v3.n64_u64[0] - 1;
            v29 = v11.n64_u32[0];
            do
            {
              v15 = v13[1];
              if ( v12 > 1 )
              {
                if ( v15 >= v3.n64_u64[0] )
                  v15 %= v3.n64_u64[0];
              }
              else
              {
                v15 &= v14;
              }
              if ( v15 == v10 )
              {
                v9 = v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v15) )
              {
                v16 = *v13;
                if ( *v13 )
                {
                  v17 = *((unsigned __int8 *)v13 + 16);
                  v18 = v13;
                  v30 = v9;
                  v31 = v10;
                  if ( (v17 & 1) != 0 )
                    v19 = v13[3];
                  else
                    v19 = v17 >> 1;
                  while ( 1 )
                  {
                    v20 = v18;
                    v18 = (_QWORD *)v16;
                    v23 = *(unsigned __int8 *)(v16 + 16);
                    v21 = v16 + 16;
                    v22 = v23;
                    v24 = *(_QWORD *)(v21 + 8);
                    v25 = (unsigned __int64)v23 >> 1;
                    if ( (v23 & 1) == 0 )
                      v24 = v25;
                    if ( v19 != v24 )
                      break;
                    if ( (v17 & 1) != 0 )
                      result = v13[4];
                    else
                      result = (unsigned __int64)v13 + 17;
                    if ( (v22 & 1) != 0 )
                      v26 = (unsigned __int8 *)v18[4];
                    else
                      v26 = (unsigned __int8 *)(v21 + 1);
                    if ( (v17 & 1) != 0 )
                    {
                      if ( v19 )
                      {
                        result = memcmp((const void *)result, v26, v19);
                        if ( (_DWORD)result )
                          break;
                      }
                    }
                    else
                    {
                      v27 = (unsigned __int8 *)v13 + 17;
                      v28 = v17 >> 1;
                      if ( v19 )
                      {
                        while ( *v27 == *v26 )
                        {
                          --v28;
                          ++v27;
                          ++v26;
                          if ( !v28 )
                            goto LABEL_46;
                        }
                        break;
                      }
                    }
LABEL_46:
                    v16 = *v18;
                    if ( !*v18 )
                    {
                      v20 = v18;
                      v18 = 0LL;
                      break;
                    }
                  }
                  v14 = v3.n64_u64[0] - 1;
                  v12 = v29;
                  v10 = v31;
                  v9 = v30;
                }
                else
                {
                  v18 = 0LL;
                  v20 = v13;
                }
                *v9 = v18;
                *v20 = **(_QWORD **)(v2->n64_u64[0] + 8 * v15);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v15) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v15) = v9;
                v9 = v13;
                v10 = v15;
              }
              v13 = (__int64 *)*v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_6575460();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_31D2730 (0x31D2730)
================================================================================

__int64 **__fastcall sub_31D2730(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int64 v3; // x27
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  unsigned __int8 *v11; // x1
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x26
  uint8x8_t v16; // d0
  unsigned __int64 v17; // x28
  __int64 ***v18; // x8
  unsigned __int64 v19; // x10
  unsigned __int8 *v20; // x11
  unsigned __int8 *v21; // x12
  unsigned __int64 v22; // x9
  __int64 **v23; // x22
  size_t v24; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  __int64 *v29; // x0
  __int64 v30; // x9
  __int64 *v31; // x23
  __int64 v32; // x22
  __int64 v33; // x8
  int v34; // w9
  float v35; // s1
  float v36; // s0
  _BOOL8 v37; // x9
  unsigned __int64 v38; // x10
  unsigned __int64 v39; // x1
  __int64 v40; // x8
  __int64 *v41; // x9
  __int64 v42; // x9
  unsigned __int64 v43; // x9
  _QWORD v45[2]; // [xsp+0h] [xbp-20h] BYREF
  char v46; // [xsp+10h] [xbp-10h]

  v7 = *((_QWORD *)a2 + 1);
  v8 = *a2;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v11 = a2 + 1;
  else
    v11 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  if ( v9 )
    v12 = v10;
  else
    v12 = v7;
  v13 = sub_24DF128(v45, v11, v12);
  v14 = v13;
  v15 = *(_QWORD *)(a1 + 8);
  if ( v15 )
  {
    v16.n64_u64[0] = vcnt_s8((int8x8_t)v15).n64_u64[0];
    v16.n64_u16[0] = vaddlv_u8(v16);
    v17 = v16.n64_u32[0];
    if ( v16.n64_u32[0] > 1uLL )
    {
      v3 = v13;
      if ( v13 >= v15 )
        v3 = v13 % v15;
    }
    else
    {
      v3 = (v15 - 1) & v13;
    }
    v18 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v3);
    if ( v18 )
    {
      v19 = *((_QWORD *)a2 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v21 = a2 + 1;
      v22 = *a2;
      v23 = *v18;
      v24 = (v22 & 1) != 0 ? v19 : v22 >> 1;
      for ( i = (v22 & 1) != 0 ? v20 : v21; v23; v23 = (__int64 **)*v23 )
      {
        v26 = (unsigned __int64)v23[1];
        if ( v26 != v14 )
        {
          if ( v17 > 1 )
          {
            if ( v26 >= v15 )
              v26 %= v15;
          }
          else
          {
            v26 &= v15 - 1;
          }
          if ( v26 != v3 )
            break;
        }
        v27 = *((unsigned __int8 *)v23 + 16);
        v28 = (unsigned __int64)v23[3];
        if ( (v27 & 1) == 0 )
          v28 = v27 >> 1;
        if ( v28 == v24 )
        {
          if ( (v27 & 1) != 0 )
            v29 = v23[4];
          else
            v29 = (__int64 *)((char *)v23 + 17);
          if ( (v27 & 1) != 0 )
          {
            if ( !v24 || !memcmp(v29, i, v24) )
              return v23;
          }
          else
          {
            if ( !v24 )
              return v23;
            v30 = 0LL;
            while ( *((unsigned __int8 *)v23 + v30 + 17) == i[v30] )
            {
              if ( v27 >> 1 == ++v30 )
                return v23;
            }
          }
        }
      }
    }
  }
  v31 = (__int64 *)(a1 + 16);
  v32 = sub_6575418();
  v46 = 0;
  v45[0] = v32;
  v45[1] = a1 + 16;
  sub_67D2788(v32 + 16, a3);
  v33 = *(_QWORD *)(a1 + 24);
  v34 = *(_DWORD *)(a3 + 24);
  *(_QWORD *)v32 = 0LL;
  *(_QWORD *)(v32 + 8) = v14;
  v35 = *(float *)(a1 + 32);
  v46 = 1;
  *(_DWORD *)(v32 + 40) = v34;
  v36 = (float)(unsigned __int64)(v33 + 1);
  if ( !v15 || (float)(v35 * (float)v15) < v36 )
  {
    v37 = v15 < 3 || (v15 & (v15 - 1)) != 0;
    v38 = vcvtps_u32_f32(v36 / v35);
    if ( (v37 | (2 * v15)) >= v38 )
      v39 = v37 | (2 * v15);
    else
      v39 = v38;
    sub_3064C50(a1, v39);
    v15 = *(_QWORD *)(a1 + 8);
    if ( (v15 & (v15 - 1)) != 0 )
    {
      if ( v14 >= v15 )
        v3 = v14 % v15;
      else
        v3 = v14;
    }
    else
    {
      v3 = (v15 - 1) & v14;
    }
  }
  v40 = *(_QWORD *)a1;
  v41 = *(__int64 **)(*(_QWORD *)a1 + 8 * v3);
  if ( v41 )
  {
    *(_QWORD *)v32 = *v41;
    *v41 = v32;
  }
  else
  {
    v42 = *v31;
    *v31 = v32;
    *(_QWORD *)v32 = v42;
    *(_QWORD *)(v40 + 8 * v3) = v31;
    if ( *(_QWORD *)v45[0] )
    {
      v43 = *(_QWORD *)(*(_QWORD *)v45[0] + 8LL);
      if ( (v15 & (v15 - 1)) != 0 )
      {
        if ( v43 >= v15 )
          v43 %= v15;
      }
      else
      {
        v43 &= v15 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v43) = v45[0];
    }
  }
  v23 = (__int64 **)v45[0];
  ++*(_QWORD *)(a1 + 24);
  return v23;
}


================================================================================
Function: sub_32F11B4 (0x32F11B4)
================================================================================

__int64 __fastcall sub_32F11B4(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_67F0440(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65786C4(0);
  if ( v2 >> 62 != 2 )
  {
    sub_6577E74(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7286220);
      v5 = sub_6585904(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_32F14B0(v5);
      sub_67F05F0(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_67D1AF4((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_32F14B0 (0x32F14B0)
================================================================================

__int64 sub_32F14B0()
{
  __int64 v0; // x19

  v0 = sub_6575FA8(0x88uLL, 8uLL);
  sub_64204F4();
  return v0;
}


================================================================================
Function: sub_3BBD530 (0x3BBD530)
================================================================================

__int64 __fastcall sub_3BBD530(__int64 a1, char a2)
{
  __int64 result; // x0
  __int64 v5; // x19
  __int64 v6; // [xsp+8h] [xbp-18h] BYREF
  __int64 v7; // [xsp+10h] [xbp-10h]

  sub_3BC86B8(&v6);
  result = v6;
  if ( v6 )
    result = sub_3BBD5E4(v6, a1, a2 & 1);
  v5 = v7;
  if ( v7 )
  {
    result = sub_67F04A0(-1LL, v7 + 8);
    if ( !result )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
      return sub_67D18A4(v5);
    }
  }
  return result;
}


================================================================================
Function: sub_3BBD5E4 (0x3BBD5E4)
================================================================================

_BYTE *__fastcall sub_3BBD5E4(_BYTE *result, unsigned __int8 *a2, char a3)
{
  _BYTE *v4; // x20
  __int64 v6; // x0
  __int64 v7; // x1
  unsigned __int8 *v8; // x3
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x8
  __int64 v12; // x0
  __int64 v13; // x23
  __int64 v14; // x3
  _QWORD *i; // x21
  __int64 **v16; // x19
  __int64 v17; // x0
  __int64 **v18; // x19
  __int64 *v19; // x20
  __int64 *v20; // x20
  int v21; // [xsp+4h] [xbp-7Ch] BYREF
  _BYTE v22[16]; // [xsp+8h] [xbp-78h] BYREF
  __int128 v23; // [xsp+20h] [xbp-60h] BYREF
  __int128 v24; // [xsp+30h] [xbp-50h]
  int v25; // [xsp+40h] [xbp-40h]
  __int128 v26; // [xsp+50h] [xbp-30h] BYREF
  __int128 v27; // [xsp+60h] [xbp-20h]
  int v28; // [xsp+70h] [xbp-10h]

  if ( !*result )
    return result;
  v4 = result;
  if ( byte_71CF7B0 )
  {
    if ( byte_6F75B30 )
      return result;
    v6 = qword_6D6BB40;
    v7 = qword_6D6BB48;
    if ( byte_71CF760 )
    {
      if ( (unsigned __int8)qword_6D6BB40 < 6u || BYTE1(qword_6D6BB40) < 3u )
        goto LABEL_13;
    }
    else if ( !(_BYTE)qword_6D6BB40 )
    {
      goto LABEL_13;
    }
  }
  else
  {
    v6 = qword_6D6BB40;
    v7 = qword_6D6BB48;
    if ( !(_BYTE)qword_6D6BB40 )
      goto LABEL_13;
  }
  if ( (*a2 & 1) != 0 )
    v8 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v8 = a2 + 1;
  sub_654E814(v6, v7, "[DFLog::AnalyticsDeferredEphemeralReportingDiagnostic] Converting CSV to bulk counters: %s", v8);
LABEL_13:
  v9 = 0LL;
  v26 = 0u;
  v27 = 0u;
  v28 = 1065353216;
  do
  {
    v10 = *a2;
    if ( (v10 & 1) != 0 )
      v11 = *((_QWORD *)a2 + 1);
    else
      v11 = v10 >> 1;
    if ( v9 >= v11 )
      break;
    v12 = sub_67D2D94(a2, 44LL, v9);
    v13 = v12;
    if ( v12 == -1 )
      v14 = -1LL;
    else
      v14 = v12 - v9;
    sub_67D2CC8(v22, a2, v9, v14, a2);
    v21 = 1;
    sub_3BCB110(&v26, v22, v22, &v21);
    if ( (v22[0] & 1) != 0 )
      sub_6575460();
    v9 = v13 + 1;
  }
  while ( v13 != -1 );
  v25 = v28;
  v23 = 0u;
  v24 = 0u;
  sub_3064C50(&v23, *((_QWORD *)&v26 + 1));
  for ( i = (_QWORD *)v27; i; i = (_QWORD *)*i )
    sub_31D2730(&v23, i + 2, i + 2);
  sub_3BC6F5C(v4 + 8, &v23, a3 & 1);
  v16 = (__int64 **)v24;
  if ( (_QWORD)v24 )
  {
    do
    {
      v19 = *v16;
      if ( ((_BYTE)v16[2] & 1) != 0 )
        sub_6575460();
      sub_6575460();
      v16 = (__int64 **)v19;
    }
    while ( v19 );
  }
  v17 = v23;
  *(_QWORD *)&v23 = 0LL;
  if ( v17 )
    sub_6575460();
  v18 = (__int64 **)v27;
  if ( (_QWORD)v27 )
  {
    do
    {
      v20 = *v18;
      if ( ((_BYTE)v18[2] & 1) != 0 )
        sub_6575460();
      sub_6575460();
      v18 = (__int64 **)v20;
    }
    while ( v20 );
  }
  result = (_BYTE *)v26;
  *(_QWORD *)&v26 = 0LL;
  if ( result )
    return (_BYTE *)sub_6575460();
  return result;
}


================================================================================
Function: sub_3BC08E8 (0x3BC08E8)
================================================================================

long double __usercall sub_3BC08E8@<Q0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  __int64 v3; // x20
  __int64 v4; // x20
  __int64 v5; // x21
  long double result; // q0

  if ( byte_71CF7B0 )
    v2 = byte_7286120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = sub_6575418();
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_QWORD *)v3 = off_68E07E0;
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
    *(_OWORD *)(v3 + 136) = 0u;
    *(_OWORD *)(v3 + 152) = 0u;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 168) = 0u;
    sub_6766848(v3 + 96);
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(v3 + 176) = 0LL;
    *(_QWORD *)(v3 + 168) = 0LL;
    *(_QWORD *)(v3 + 160) = v3 + 168;
    *a1 = v3 + 24;
    a1[1] = v3;
    *(_OWORD *)(v3 + 128) = 0u;
    *(_OWORD *)(v3 + 144) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
  }
  else
  {
    v4 = sub_678E980();
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 192LL, 8LL);
    *(_QWORD *)(v5 + 16) = 0LL;
    *(_QWORD *)(v5 + 24) = v4;
    *(_QWORD *)v5 = off_68E0790;
    *(_QWORD *)(v5 + 8) = 0LL;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    sub_6766848(v5 + 104);
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(v5 + 184) = 0LL;
    *(_QWORD *)(v5 + 176) = 0LL;
    *(_QWORD *)(v5 + 168) = v5 + 176;
    *a1 = v5 + 32;
    a1[1] = v5;
    *(_OWORD *)(v5 + 152) = 0u;
    *(_OWORD *)(v5 + 136) = 0u;
    *(_OWORD *)(v5 + 120) = 0u;
  }
  return result;
}


================================================================================
Function: sub_3BC13CC (0x3BC13CC)
================================================================================

_QWORD *__fastcall sub_3BC13CC(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // x22
  __int64 v3; // x23
  __int64 v6; // x21
  __int64 v7; // x21

  v3 = *a2;
  v2 = a2[1];
  if ( v2 )
    sub_67F0380(1LL, v2 + 8);
  v6 = a1[1];
  *a1 = v3;
  a1[1] = v2;
  if ( v6 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  v7 = a2[1];
  *a2 = 0LL;
  a2[1] = 0LL;
  if ( v7 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
    }
  }
  return a1;
}


================================================================================
Function: sub_3BC4804 (0x3BC4804)
================================================================================

__int64 __fastcall sub_3BC4804(__int64 result)
{
  __int64 *v1; // x19
  __int64 v2; // x8
  __int64 v3; // x19
  unsigned __int64 *v4; // x19
  __int64 v5; // [xsp+8h] [xbp-28h] BYREF
  __int64 v6; // [xsp+10h] [xbp-20h]
  _BYTE v7[8]; // [xsp+18h] [xbp-18h] BYREF
  __int64 v8; // [xsp+20h] [xbp-10h]

  if ( *(_BYTE *)(*(_QWORD *)result + 40LL) )
    return result;
  v1 = (__int64 *)result;
  result = sub_67679F4(*(_QWORD *)result + 48LL);
  if ( result )
    return result;
  if ( byte_71CF7B0 && byte_71CF760 )
  {
    if ( (unsigned __int8)qword_6D6BB40 < 6u || BYTE1(qword_6D6BB40) < 3u )
      goto LABEL_11;
    goto LABEL_10;
  }
  if ( (_BYTE)qword_6D6BB40 )
LABEL_10:
    sub_654E3D0();
LABEL_11:
  v2 = v1[1];
  v5 = *v1;
  v6 = v2;
  if ( v2 )
    sub_67F0410(1uLL, (atomic_ullong *)(v2 + 8));
  sub_3BC54C8(v7, sub_3BC49C0, &v5, 0LL);
  sub_3BC13CC(*v1 + 48, v7);
  result = sub_6767254(v7);
  v3 = v8;
  if ( v8 )
  {
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v8 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 16LL))(v3);
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v3 + 12));
      if ( (_DWORD)result == 1 )
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 24LL))(v3);
    }
  }
  v4 = (unsigned __int64 *)v6;
  if ( v6 )
  {
    result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v6 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v4 + 16))(v4);
      return sub_67D18A4(v4);
    }
  }
  return result;
}


================================================================================
Function: sub_3BC54C8 (0x3BC54C8)
================================================================================

__int64 __fastcall sub_3BC54C8(__int64 *a1, __int64 a2, __int64 *a3)
{
  __int64 v5; // x8
  __int64 v6; // x24
  __int64 v7; // x21
  __int128 v8; // q0
  __int64 v9; // x9
  __int64 result; // x0
  __int64 v11; // [xsp+8h] [xbp-48h]
  __int128 v12; // [xsp+10h] [xbp-40h] BYREF
  __int64 v13; // [xsp+20h] [xbp-30h]

  v6 = *a3;
  v5 = a3[1];
  v11 = v5;
  if ( v5 )
  {
    sub_67F0410(1uLL, (atomic_ullong *)(v5 + 8));
    sub_67F0410(1uLL, (atomic_ullong *)(v11 + 8));
    sub_67F0410(1uLL, (atomic_ullong *)(v11 + 8));
    sub_67F0410(1uLL, (atomic_ullong *)(v11 + 8));
    if ( !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v11 + 8)) )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
      sub_67D18A4((unsigned __int64 *)v11);
    }
    *(_QWORD *)&v12 = a2;
    *((_QWORD *)&v12 + 1) = v6;
    v13 = v11;
    sub_67F0410(1uLL, (atomic_ullong *)(v11 + 8));
    if ( !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v11 + 8)) )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
      sub_67D18A4((unsigned __int64 *)v11);
    }
    if ( !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v11 + 8)) )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
      sub_67D18A4((unsigned __int64 *)v11);
    }
  }
  else
  {
    *(_QWORD *)&v12 = a2;
    *((_QWORD *)&v12 + 1) = v6;
    v13 = 0LL;
  }
  v7 = sub_6575418();
  sub_26E6A44(v7);
  v8 = v12;
  v9 = v13;
  *((_QWORD *)&v12 + 1) = 0LL;
  v13 = 0LL;
  *(_OWORD *)(v7 + 416) = v8;
  *(_QWORD *)v7 = off_68E08D0;
  *(_QWORD *)(v7 + 432) = v9;
  *a1 = v7;
  a1[1] = 0LL;
  sub_3BE4398(a1, v7, a1 + 1);
  if ( v11 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v11 + 8)) )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16LL))(v11);
    sub_67D18A4((unsigned __int64 *)v11);
  }
  result = sub_6766850(a1);
  if ( (result & 1) == 0 )
  {
    sub_26E6F90(&v12);
    sub_25A2098(&v12);
  }
  return result;
}


================================================================================
Function: sub_3BC5798 (0x3BC5798)
================================================================================

__int64 __fastcall sub_3BC5798(__int64 a1, __int64 a2, char a3)
{
  _QWORD *v6; // x8
  __int64 v7; // x19
  __int64 v8; // x25
  __int64 v9; // x9
  _QWORD *v10; // x8
  __int64 **v11; // x20
  __int64 result; // x0
  __int64 v13; // x20
  __int64 *v14; // x21
  char v15; // t1
  _QWORD v16[3]; // [xsp+8h] [xbp-48h] BYREF
  __int128 v17; // [xsp+20h] [xbp-30h] BYREF
  __int128 v18; // [xsp+30h] [xbp-20h]
  int v19; // [xsp+40h] [xbp-10h]

  v6 = *(_QWORD **)a2;
  v17 = 0u;
  v18 = 0u;
  v7 = v6[15];
  v8 = v6[16];
  v6[15] = 0LL;
  v6[16] = 0LL;
  v9 = v6[17];
  v6[17] = 0LL;
  v10 = *(_QWORD **)a2;
  v16[2] = v9;
  v16[0] = v7;
  v16[1] = v8;
  v19 = 1065353216;
  sub_3BE45BC(v10 + 18, &v17);
  *(_QWORD *)(*(_QWORD *)a2 + 64LL) = 0x7FFFFFFFFFFFFFFFLL;
  if ( !*(_BYTE *)(a1 + 8) )
    sub_67D662C(1, "unique_lock::unlock: not locked");
  sub_67D19BC(*(pthread_mutex_t **)a1);
  *(_BYTE *)(a1 + 8) = 0;
  sub_3BC5D10(v16, &v17, a3 & 1);
  v11 = (__int64 **)v18;
  if ( (_QWORD)v18 )
  {
    do
    {
      v14 = *v11;
      if ( ((_BYTE)v11[2] & 1) != 0 )
        sub_6575460();
      sub_6575460();
      v11 = (__int64 **)v14;
    }
    while ( v14 );
  }
  result = v17;
  *(_QWORD *)&v17 = 0LL;
  if ( result )
    result = sub_6575460();
  if ( v7 )
  {
    if ( v8 != v7 )
    {
      v13 = v8;
      do
      {
        v15 = *(_BYTE *)(v13 - 32);
        v13 -= 32LL;
        if ( (v15 & 1) != 0 )
          sub_6575460();
      }
      while ( v13 != v7 );
    }
    return sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_3BC5D10 (0x3BC5D10)
================================================================================

__int64 __usercall sub_3BC5D10@<X0>(
        unsigned __int8 **a1@<X0>,
        __int64 a2@<X1>,
        char a3@<W2>,
        __int64 a4@<X5>,
        __int64 a5@<X6>,
        __int64 a6@<X7>,
        _OWORD *a7@<X8>,
        long double a8@<Q0>,
        long double a9@<Q1>,
        long double a10@<Q2>,
        long double a11@<Q3>)
{
  __int64 result; // x0
  __int128 *v16; // x24
  unsigned __int8 *v17; // x19
  unsigned __int8 *v18; // x20
  unsigned __int64 v19; // x8
  bool v20; // zf
  unsigned __int64 v21; // x8
  unsigned __int8 *v22; // x3
  unsigned __int64 v23; // x4
  unsigned __int8 *v24; // x20
  const void *v25; // x23
  unsigned __int64 v26; // x0
  size_t v27; // x24
  char *v28; // x25
  unsigned __int64 v29; // x26
  unsigned __int8 *i; // x22
  unsigned __int8 *v31; // x23
  long double v32; // q0
  unsigned __int8 *v33; // x1
  __int64 v34; // x22
  unsigned __int64 *v35; // x22
  __int64 **v36; // x22
  __int128 v37; // q0
  __int64 **j; // x19
  const void *v39; // x22
  unsigned __int64 v40; // x0
  size_t v41; // x23
  char *v42; // x24
  __int64 *v43; // x19
  unsigned __int64 v44; // x25
  __int64 **k; // x20
  __int64 *v46; // x1
  __int64 v47; // x19
  unsigned __int64 *v48; // x19
  __int64 **v49; // x19
  __int64 *v50; // x20
  __int64 v51; // [xsp+0h] [xbp-270h]
  __int64 v52; // [xsp+10h] [xbp-260h] BYREF
  __int64 v53; // [xsp+18h] [xbp-258h]
  __int64 v54; // [xsp+20h] [xbp-250h] BYREF
  size_t v55; // [xsp+28h] [xbp-248h]
  char *v56; // [xsp+30h] [xbp-240h]
  _QWORD v57[2]; // [xsp+38h] [xbp-238h] BYREF
  char v58; // [xsp+50h] [xbp-220h] BYREF
  char v59[15]; // [xsp+51h] [xbp-21Fh] BYREF
  __int64 v60; // [xsp+60h] [xbp-210h]
  __int128 v61; // [xsp+80h] [xbp-1F0h] BYREF
  __int128 v62; // [xsp+90h] [xbp-1E0h]
  int v63; // [xsp+A0h] [xbp-1D0h]
  __int64 v64; // [xsp+A8h] [xbp-1C8h]
  char v65; // [xsp+B0h] [xbp-1C0h]

  result = qword_6D6BB40;
  if ( !byte_71CF7B0 || !byte_71CF760 )
  {
    if ( !(_BYTE)qword_6D6BB40 )
      goto LABEL_8;
    goto LABEL_7;
  }
  if ( (unsigned __int8)qword_6D6BB40 >= 6u && BYTE1(qword_6D6BB40) >= 3u )
LABEL_7:
    result = sub_654E814(
               qword_6D6BB40,
               qword_6D6BB48,
               "[DFLog::AnalyticsDeferredEphemeralReportingDiagnostic] SendNow, # stats = %zu, # counters = %zu",
               (a1[1] - *a1) >> 5,
               *(_QWORD *)(a2 + 24),
               a4,
               a5,
               a6,
               a8,
               a9,
               a10,
               a11,
               v51);
LABEL_8:
  v16 = &xmmword_AF9000;
  v20 = *a1 == a1[1];
  *a7 = 0u;
  a7[1] = 0u;
  if ( v20 )
    goto LABEL_51;
  *(_QWORD *)&v62 = sub_6575418();
  strcpy((char *)v62, "76E5A40C-3AE1-4028-9F10-7C62520BD94F");
  v61 = xmmword_AF9340;
  sub_3D38DAC(v57, &v61);
  if ( (v61 & 1) != 0 )
    sub_6575460();
  sub_65631A0(&v61, 0LL);
  sub_656346C(&v61);
  v18 = *a1;
  v17 = a1[1];
  if ( *a1 != v17 )
  {
    do
    {
      sub_65633A4(&v61);
      v19 = *v18;
      v20 = (v19 & 1) == 0;
      v21 = v19 >> 1;
      if ( v20 )
        v22 = v18 + 1;
      else
        v22 = (unsigned __int8 *)*((_QWORD *)v18 + 2);
      if ( v20 )
        v23 = v21;
      else
        v23 = *((_QWORD *)v18 + 1);
      sub_656398C(&v61, "Key", 3LL, v22, v23);
      v24 = v18 + 1;
      sub_65639EC(&v61, "Value", *(double *)(v24 + 23));
      sub_65633E0(&v61);
      v18 = v24 + 31;
    }
    while ( v18 != v17 );
  }
  sub_65634A8(&v61);
  v25 = (const void *)sub_6563F48(&v61);
  v26 = sub_6563FEC(&v61);
  v27 = v26;
  if ( v26 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( v26 >= 0x17 )
  {
    v29 = (v26 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v28 = (char *)sub_6575418();
    v55 = v27;
    v56 = v28;
    v54 = v29 | 1;
  }
  else
  {
    v28 = (char *)&v54 + 1;
    LOBYTE(v54) = 2 * v26;
    if ( !v26 )
      goto LABEL_25;
  }
  memcpy(v28, v25, v27);
LABEL_25:
  v28[v27] = 0;
  sub_6563344(&v61);
  v31 = *a1;
  for ( i = a1[1]; v31 != i; v31 += 32 )
  {
    sub_6416B58(&v61, (unsigned int)dword_6F7A8B0, 4LL, (unsigned int)dword_6C2FC9C);
    if ( (*v31 & 1) != 0 )
      v33 = (unsigned __int8 *)*((_QWORD *)v31 + 2);
    else
      v33 = v31 + 1;
    *(_QWORD *)&v32 = *((_QWORD *)v31 + 3);
    sub_641B574(&v61, v33, v32);
    v58 = 18;
    strcpy(v59, "Telemetry");
    sub_641C358(&v61, &v58, (unsigned int)dword_6F7A8B0, 0LL);
    if ( (v58 & 1) != 0 )
      sub_6575460();
    sub_254B3DC(&v61);
  }
  if ( (a3 & 1) != 0 )
  {
    result = sub_3BE7F14(v57, &v54, &byte_6F77178, 0LL, 0LL);
    v16 = &xmmword_AF9000;
  }
  else
  {
    v64 = 0LL;
    v65 = 0;
    v63 = 1065353216;
    v61 = 0u;
    v62 = 0u;
    sub_6253A74(&v61, 23LL);
    v16 = &xmmword_AF9000;
    sub_62548C4(&v58, &v54, &byte_6F77178, 1LL);
    sub_621F58C(&v52, v57, &v58, &v61);
    sub_3BE3B58(a7, &v52);
    v34 = v53;
    if ( v53 )
    {
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v53 + 8)) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v34 + 16LL))(v34);
        if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v34 + 12)) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v34 + 24LL))(v34);
      }
    }
    if ( (v60 & 1) != 0 )
      sub_6575460();
    v35 = *(unsigned __int64 **)&v59[7];
    if ( *(_QWORD *)&v59[7] && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(*(_QWORD *)&v59[7] + 8LL)) )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v35 + 16))(v35);
      sub_67D18A4(v35);
    }
    v36 = (__int64 **)v62;
    if ( (_QWORD)v62 )
    {
      do
      {
        v43 = *v36;
        if ( ((_BYTE)v36[5] & 1) != 0 )
          sub_6575460();
        if ( ((_BYTE)v36[2] & 1) != 0 )
          sub_6575460();
        sub_6575460();
        v36 = (__int64 **)v43;
      }
      while ( v43 );
    }
    result = v61;
    *(_QWORD *)&v61 = 0LL;
    if ( result )
      result = sub_6575460();
  }
  if ( (v54 & 1) != 0 )
    result = sub_6575460();
  if ( (v57[0] & 1) != 0 )
    result = sub_6575460();
LABEL_51:
  if ( !*(_QWORD *)(a2 + 24) )
    return result;
  *(_QWORD *)&v62 = sub_6575418();
  v37 = v16[52];
  strcpy((char *)v62, "76E5A40C-3AE1-4028-9F10-7C62520BD94F");
  v61 = v37;
  sub_3D39018(v57, &v61);
  if ( (v61 & 1) != 0 )
    sub_6575460();
  sub_65631A0(&v61, 0LL);
  sub_65633A4(&v61);
  for ( j = *(__int64 ***)(a2 + 16); j; j = (__int64 **)*j )
    sub_6563B74(&v61, j + 2, *((unsigned int *)j + 10));
  sub_65633E0(&v61);
  v39 = (const void *)sub_6563F48(&v61);
  v40 = sub_6563FEC(&v61);
  v41 = v40;
  if ( v40 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( v40 >= 0x17 )
  {
    v44 = (v40 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v42 = (char *)sub_6575418();
    v55 = v41;
    v56 = v42;
    v54 = v44 | 1;
    goto LABEL_66;
  }
  v42 = (char *)&v54 + 1;
  LOBYTE(v54) = 2 * v40;
  if ( v40 )
LABEL_66:
    memcpy(v42, v39, v41);
  v42[v41] = 0;
  sub_6563344(&v61);
  if ( byte_71CF7B0 && byte_6F7A868 )
  {
    sub_6416B58(&v61, (unsigned int)dword_6F7A888, 5LL, (unsigned int)dword_6C2FC98);
    for ( k = *(__int64 ***)(a2 + 16); k; k = (__int64 **)*k )
    {
      if ( ((_BYTE)k[2] & 1) != 0 )
        v46 = k[4];
      else
        v46 = (__int64 *)((char *)k + 17);
      sub_641B6E8(&v61, v46, *((unsigned int *)k + 10));
    }
    v58 = 18;
    strcpy(v59, "Telemetry");
    sub_641C358(&v61, &v58, (unsigned int)dword_6F7A888, 0LL);
    if ( (v58 & 1) != 0 )
      sub_6575460();
    sub_254B3DC(&v61);
  }
  if ( (a3 & 1) != 0 )
  {
    result = sub_3BE7F14(v57, &v54, &byte_6F77178, 0LL, 0LL);
  }
  else
  {
    v64 = 0LL;
    v65 = 0;
    v63 = 1065353216;
    v61 = 0u;
    v62 = 0u;
    sub_6253A74(&v61, 23LL);
    sub_62548C4(&v58, &v54, &byte_6F77178, 1LL);
    sub_621F58C(&v52, v57, &v58, &v61);
    sub_3BE3B58(a7 + 1, &v52);
    v47 = v53;
    if ( v53 )
    {
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v53 + 8)) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v47 + 16LL))(v47);
        if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v47 + 12)) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v47 + 24LL))(v47);
      }
    }
    if ( (v60 & 1) != 0 )
      sub_6575460();
    v48 = *(unsigned __int64 **)&v59[7];
    if ( *(_QWORD *)&v59[7] && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(*(_QWORD *)&v59[7] + 8LL)) )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v48 + 16))(v48);
      sub_67D18A4(v48);
    }
    v49 = (__int64 **)v62;
    if ( (_QWORD)v62 )
    {
      do
      {
        v50 = *v49;
        if ( ((_BYTE)v49[5] & 1) != 0 )
          sub_6575460();
        if ( ((_BYTE)v49[2] & 1) != 0 )
          sub_6575460();
        sub_6575460();
        v49 = (__int64 **)v50;
      }
      while ( v50 );
    }
    result = v61;
    *(_QWORD *)&v61 = 0LL;
    if ( result )
      result = sub_6575460();
  }
  if ( (v54 & 1) != 0 )
    result = sub_6575460();
  if ( (v57[0] & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_3BC6650 (0x3BC6650)
================================================================================

_QWORD *__fastcall sub_3BC6650(_QWORD *result, __int64 a2, char a3)
{
  __int64 v3; // x19
  __int64 v4; // x19
  __int64 v5; // [xsp+8h] [xbp-28h] BYREF
  __int64 v6; // [xsp+10h] [xbp-20h]
  __int64 v7; // [xsp+20h] [xbp-10h]

  if ( *(_QWORD *)(*result + 168LL) + ((__int64)(*(_QWORD *)(*result + 128LL) - *(_QWORD *)(*result + 120LL)) >> 5) >= (unsigned __int64)dword_6C0BD44
    || (a3 & 1) != 0 )
  {
    result = sub_3BC5798(&v5, a2, result, a3 & 1);
    v3 = v7;
    if ( v7 )
    {
      result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 16LL))(v3);
        result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v3 + 12));
        if ( (_DWORD)result == 1 )
          result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 24LL))(v3);
      }
    }
    v4 = v6;
    if ( v6 )
    {
      result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 16LL))(v4);
        result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v4 + 12));
        if ( (_DWORD)result == 1 )
          return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_3BC677C (0x3BC677C)
================================================================================

long double __usercall sub_3BC677C@<Q0>(__int64 *a1@<X8>)
{
  bool v2; // zf
  __int64 v3; // x20
  __int64 v4; // x20
  __int64 v5; // x0
  __int64 v6; // x21
  __int64 v7; // x20
  long double result; // q0

  if ( byte_71CF7B0 )
    v2 = byte_7286120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = sub_6575418();
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_QWORD *)v3 = off_68E09C0;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_OWORD *)(v3 + 128) = 0u;
    *(_OWORD *)(v3 + 144) = 0u;
    *(_OWORD *)(v3 + 160) = 0u;
    *(_OWORD *)(v3 + 176) = 0u;
    *(_OWORD *)(v3 + 192) = 0u;
    *(_OWORD *)(v3 + 208) = 0u;
    *(_OWORD *)(v3 + 224) = 0u;
    *(_OWORD *)(v3 + 240) = 0u;
    *(_OWORD *)(v3 + 256) = 0u;
    *(_OWORD *)(v3 + 272) = 0u;
    *(_OWORD *)(v3 + 288) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    sub_6766848(v3 + 80);
    *(_QWORD *)(v3 + 200) = 0LL;
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(v3 + 288) = 0LL;
    *a1 = v3 + 32;
    a1[1] = v3;
    *(_QWORD *)(v3 + 96) = 0x7FFFFFFFFFFFFFFFLL;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
    *(_OWORD *)(v3 + 136) = 0u;
    *(_OWORD *)(v3 + 152) = 0u;
    *(_OWORD *)(v3 + 168) = 0u;
    *(_OWORD *)(v3 + 184) = 0u;
    *(_DWORD *)(v3 + 208) = 1065353216;
    *(_OWORD *)(v3 + 216) = 0u;
    *(_OWORD *)(v3 + 232) = 0u;
    *(_DWORD *)(v3 + 248) = 1065353216;
  }
  else
  {
    v4 = sub_678E980();
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 320LL, 16LL);
    *(_QWORD *)(v5 + 32) = v4;
    v6 = v5;
    *(_QWORD *)(v5 + 8) = 0LL;
    *(_QWORD *)(v5 + 16) = 0LL;
    *(_QWORD *)v5 = off_68E0970;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(_OWORD *)(v5 + 208) = 0u;
    *(_OWORD *)(v5 + 224) = 0u;
    *(_OWORD *)(v5 + 240) = 0u;
    *(_OWORD *)(v5 + 256) = 0u;
    *(_OWORD *)(v5 + 272) = 0u;
    *(_OWORD *)(v5 + 288) = 0u;
    *(_OWORD *)(v5 + 304) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    v7 = v5 + 48;
    *(_OWORD *)(v5 + 96) = 0u;
    sub_6766848(v5 + 96);
    *(_QWORD *)(v6 + 216) = 0LL;
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(v6 + 304) = 0LL;
    *a1 = v7;
    a1[1] = v6;
    *(_QWORD *)(v6 + 112) = 0x7FFFFFFFFFFFFFFFLL;
    *(_OWORD *)(v6 + 120) = 0u;
    *(_OWORD *)(v6 + 136) = 0u;
    *(_OWORD *)(v6 + 152) = 0u;
    *(_OWORD *)(v6 + 168) = 0u;
    *(_OWORD *)(v6 + 184) = 0u;
    *(_OWORD *)(v6 + 200) = 0u;
    *(_DWORD *)(v6 + 224) = 1065353216;
    *(_OWORD *)(v6 + 232) = 0u;
    *(_OWORD *)(v6 + 248) = 0u;
    *(_DWORD *)(v6 + 264) = 1065353216;
  }
  return result;
}


================================================================================
Function: sub_3BC6F5C (0x3BC6F5C)
================================================================================

pthread_mutex_t **__fastcall sub_3BC6F5C(pthread_mutex_t **result, __int64 a2, char a3)
{
  bool v3; // zf
  pthread_mutex_t **v4; // x20
  __int64 v7; // x0
  __int64 v8; // x5
  __int64 v9; // x6
  __int64 v10; // x7
  long double v11; // q0
  long double v12; // q1
  long double v13; // q2
  long double v14; // q3
  __int64 *v15; // x26
  bool v16; // zf
  __int64 v17; // x3
  pthread_mutex_t *v18; // x8
  int v19; // w24
  __int64 v20; // x0
  __int64 v21; // [xsp+0h] [xbp-30h]
  char v22[8]; // [xsp+8h] [xbp-28h] BYREF
  __int64 *v23; // [xsp+10h] [xbp-20h] BYREF
  pthread_mutex_t *v24; // [xsp+18h] [xbp-18h] BYREF
  char v25; // [xsp+20h] [xbp-10h]

  if ( byte_71CF7B0 )
    v3 = byte_6F75B30 == 0;
  else
    v3 = 1;
  if ( v3 )
  {
    v4 = result;
    v24 = *result;
    v25 = 1;
    sub_67D1968(v24);
    v7 = sub_3BC4804(v4);
    if ( (*v4)[3].__align != *(&(*v4)[3].__align + 1) || *(&(*v4)[4].__align + 1) )
    {
      v15 = *(__int64 **)(a2 + 16);
      if ( v15 )
        goto LABEL_9;
      goto LABEL_23;
    }
    (*v4)[1].__list.__prev = (struct __pthread_internal_list *)(sub_67A2CE8(v7) + 1000000000LL * dword_6C0BD40);
    sub_67A2D8C(&(*v4)[1].__align + 4);
    v15 = *(__int64 **)(a2 + 16);
    if ( !v15 )
    {
LABEL_23:
      result = (pthread_mutex_t **)sub_3BC6650(v4, &v24, a3 & 1);
      if ( v25 )
        return (pthread_mutex_t **)sub_67D19BC(v24);
      return result;
    }
    while ( 1 )
    {
LABEL_9:
      if ( byte_71CF7B0 )
        v16 = byte_71CF760 == 0;
      else
        v16 = 1;
      if ( v16 )
      {
        if ( (_BYTE)qword_6D6BB40 )
          goto LABEL_18;
      }
      else if ( (unsigned __int8)qword_6D6BB40 >= 6u && BYTE1(qword_6D6BB40) >= 3u )
      {
LABEL_18:
        if ( (v15[2] & 1) != 0 )
          v17 = v15[4];
        else
          v17 = (__int64)v15 + 17;
        sub_654E814(
          qword_6D6BB40,
          qword_6D6BB48,
          "[DFLog::AnalyticsDeferredEphemeralReportingDiagnostic] Adding counter %s = %d (bulk)",
          v17,
          *((unsigned int *)v15 + 10),
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v14,
          v21);
      }
      v18 = *v4;
      v23 = v15 + 2;
      v19 = *((_DWORD *)v15 + 10);
      v20 = sub_306491C(&v18[3].__align + 3, v15 + 2, &unk_E53F0B, &v23, v22);
      *(_DWORD *)(v20 + 40) += v19;
      v15 = (__int64 *)*v15;
      if ( !v15 )
        goto LABEL_23;
    }
  }
  return result;
}


================================================================================
Function: sub_3BC86B8 (0x3BC86B8)
================================================================================

__int64 __usercall sub_3BC86B8@<X0>(_QWORD *a1@<X8>)
{
  unsigned __int8 v2; // w9
  __int64 v3; // x20
  __int64 v4; // x8

  v2 = atomic_load(byte_6D6BF08);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6D6BF08) )
  {
    sub_3BE0324(&unk_6D6BEC8);
    __cxa_atexit((void (*)(void *))sub_3BE06E4, &unk_6D6BEC8, &off_67F7780);
    sub_67EB838(byte_6D6BF08);
  }
  v3 = qword_6D6BE18;
  sub_67D1968(qword_6D6BE18);
  if ( qword_6D6BE10 )
  {
    v4 = *(_QWORD *)(qword_6D6BE10 + 8);
    *a1 = *(_QWORD *)qword_6D6BE10;
    a1[1] = v4;
    if ( v4 )
      sub_67F0410(1LL, v4 + 8);
  }
  else
  {
    *a1 = 0LL;
    a1[1] = 0LL;
  }
  return sub_67D19BC(v3);
}


================================================================================
Function: sub_3BC8BC8 (0x3BC8BC8)
================================================================================

void __fastcall __noreturn sub_3BC8BC8(__int64 a1)
{
  __int64 v2; // x19
  __int128 v3; // q0
  __int64 v4; // x0
  __int128 v5; // q0
  _QWORD v6[2]; // [xsp+8h] [xbp-48h] BYREF
  __int128 v7; // [xsp+18h] [xbp-38h]
  __int64 (__fastcall **v8)(); // [xsp+28h] [xbp-28h] BYREF
  __int64 v9; // [xsp+30h] [xbp-20h]
  __int128 v10; // [xsp+38h] [xbp-18h]
  int v11; // [xsp+48h] [xbp-8h]

  v2 = sub_67EAFB8(80LL);
  sub_67D2484(v6, a1);
  v10 = 0uLL;
  v3 = *(_OWORD *)(a1 + 16);
  v11 = -1;
  v7 = v3;
  v6[0] = off_68DE178;
  v8 = off_68DE1A0;
  v9 = 0LL;
  *(_QWORD *)(v2 + 72) = off_67F7C48;
  sub_67D2484(v2, v6);
  *(_OWORD *)(v2 + 16) = v7;
  *(_QWORD *)v2 = off_68DE1C0;
  *(_QWORD *)(v2 + 32) = off_67F7B38;
  v4 = v9;
  *(_QWORD *)(v2 + 40) = v9;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = v10;
  *(_DWORD *)(v2 + 64) = v11;
  *(_OWORD *)(v2 + 48) = v5;
  *(_QWORD *)v2 = off_68DE0D8;
  *(_QWORD *)(v2 + 32) = off_68DE110;
  *(_QWORD *)(v2 + 72) = &off_68DE148;
  sub_24DB560(v2 + 32, (__int64)&v8);
  sub_67EB030(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::promise_moved>>,
    (__int64)sub_3BCA538);
}


================================================================================
Function: sub_3BC8D40 (0x3BC8D40)
================================================================================

__int64 __fastcall sub_3BC8D40(_QWORD *a1)
{
  __int64 v2; // x20
  __int64 result; // x0
  _QWORD v4[2]; // [xsp+0h] [xbp-20h] BYREF

  v2 = sub_6766264();
  (*(void (__fastcall **)(_QWORD *__return_ptr))(*(_QWORD *)v2 + 24LL))(v4);
  result = sub_67D2360(a1, v4);
  if ( (v4[0] & 1) != 0 )
    result = sub_6575460();
  a1[2] = 4LL;
  a1[3] = v2;
  *a1 = off_68DE1C0;
  return result;
}


================================================================================
Function: sub_3BC8DF8 (0x3BC8DF8)
================================================================================

void __fastcall __noreturn sub_3BC8DF8(__int64 a1)
{
  __int64 v2; // x19
  __int128 v3; // q0
  __int64 v4; // x0
  __int128 v5; // q0
  _QWORD v6[2]; // [xsp+8h] [xbp-48h] BYREF
  __int128 v7; // [xsp+18h] [xbp-38h]
  __int64 (__fastcall **v8)(); // [xsp+28h] [xbp-28h] BYREF
  __int64 v9; // [xsp+30h] [xbp-20h]
  __int128 v10; // [xsp+38h] [xbp-18h]
  int v11; // [xsp+48h] [xbp-8h]

  v2 = sub_67EAFB8(80LL);
  sub_67D2484(v6, a1);
  v11 = -1;
  v3 = *(_OWORD *)(a1 + 16);
  v6[0] = off_68DE318;
  v10 = 0uLL;
  v7 = v3;
  v8 = off_68DE340;
  v9 = 0LL;
  *(_QWORD *)(v2 + 72) = off_67F7C48;
  sub_67D2484(v2, v6);
  *(_OWORD *)(v2 + 16) = v7;
  *(_QWORD *)v2 = off_68DE360;
  *(_QWORD *)(v2 + 32) = off_67F7B38;
  v4 = v9;
  *(_QWORD *)(v2 + 40) = v9;
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
  v5 = v10;
  *(_DWORD *)(v2 + 64) = v11;
  *(_OWORD *)(v2 + 48) = v5;
  *(_QWORD *)v2 = off_68DE278;
  *(_QWORD *)(v2 + 32) = off_68DE2B0;
  *(_QWORD *)(v2 + 72) = &off_68DE2E8;
  sub_24DB560(v2 + 32, (__int64)&v8);
  sub_67EB030(
    v2,
    (__int64)&`typeinfo for'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::future_already_retrieved>>,
    (__int64)sub_3BCAB20);
}


================================================================================
Function: sub_3BC8F78 (0x3BC8F78)
================================================================================

__int64 __fastcall sub_3BC8F78(_QWORD *a1)
{
  __int64 v2; // x20
  __int64 result; // x0
  _QWORD v4[2]; // [xsp+0h] [xbp-20h] BYREF

  v2 = sub_6766264();
  (*(void (__fastcall **)(_QWORD *__return_ptr))(*(_QWORD *)v2 + 24LL))(v4);
  result = sub_67D2360(a1, v4);
  if ( (v4[0] & 1) != 0 )
    result = sub_6575460();
  a1[2] = 2LL;
  a1[3] = v2;
  *a1 = off_68DE360;
  return result;
}


================================================================================
Function: sub_3BC9264 (0x3BC9264)
================================================================================

__int64 __fastcall sub_3BC9264(__int64 a1)
{
  unsigned int v2; // w1
  __int64 result; // x0
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)a1 = off_68DDE18;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_WORD *)(a1 + 40) = 0;
  v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 52), 0LL);
  if ( v2 )
  {
    sub_25A21C8(v4, v2, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v4);
  }
  result = sub_25A1F60(a1 + 92);
  *(_BYTE *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0LL;
  *(_QWORD *)(a1 + 256) = 0LL;
  *(_QWORD *)(a1 + 200) = 0LL;
  *(_QWORD *)(a1 + 208) = 0LL;
  *(_QWORD *)(a1 + 184) = a1 + 184;
  *(_QWORD *)(a1 + 192) = a1 + 184;
  return result;
}


================================================================================
Function: sub_3BCB110 (0x3BCB110)
================================================================================

__int64 **__fastcall sub_3BCB110(__int64 *a1, unsigned __int8 *a2, __int128 *a3, int *a4)
{
  unsigned __int64 v4; // x28
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x8
  bool v11; // zf
  unsigned __int64 v12; // x8
  unsigned __int8 *v13; // x1
  unsigned __int64 v14; // x2
  unsigned __int64 v15; // x0
  unsigned __int64 v16; // x20
  unsigned __int64 v17; // x27
  uint8x8_t v18; // d0
  unsigned __int64 v19; // x26
  __int64 ***v20; // x8
  unsigned __int64 v21; // x10
  unsigned __int8 *v22; // x11
  unsigned __int8 *v23; // x12
  unsigned __int64 v24; // x9
  __int64 **v25; // x23
  size_t v26; // x24
  unsigned __int8 *i; // x25
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x10
  unsigned __int64 v30; // x11
  __int64 *v31; // x0
  __int64 v32; // x9
  __int64 *v33; // x24
  __int64 v34; // x0
  __int128 v35; // q0
  __int64 v36; // x8
  __int64 v37; // x9
  _QWORD *v38; // x23
  int v39; // w10
  float v40; // s1
  float v41; // s0
  _BOOL8 v42; // x9
  unsigned __int64 v43; // x10
  __int64 v44; // x1
  __int64 v45; // x8
  _QWORD *v46; // x9
  __int64 v47; // x9
  unsigned __int64 v48; // x9
  _QWORD v50[2]; // [xsp+10h] [xbp-20h] BYREF
  char v51; // [xsp+20h] [xbp-10h]

  v9 = *((_QWORD *)a2 + 1);
  v10 = *a2;
  v11 = (v10 & 1) == 0;
  v12 = v10 >> 1;
  if ( v11 )
    v13 = a2 + 1;
  else
    v13 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  if ( v11 )
    v14 = v12;
  else
    v14 = v9;
  v15 = sub_24DF128(v50, v13, v14);
  v16 = v15;
  v17 = a1[1];
  if ( v17 )
  {
    v18.n64_u64[0] = vcnt_s8((int8x8_t)v17).n64_u64[0];
    v18.n64_u16[0] = vaddlv_u8(v18);
    v19 = v18.n64_u32[0];
    if ( v18.n64_u32[0] > 1uLL )
    {
      v4 = v15;
      if ( v15 >= v17 )
        v4 = v15 % v17;
    }
    else
    {
      v4 = (v17 - 1) & v15;
    }
    v20 = *(__int64 ****)(*a1 + 8 * v4);
    if ( v20 )
    {
      v21 = *((_QWORD *)a2 + 1);
      v22 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v23 = a2 + 1;
      v24 = *a2;
      v25 = *v20;
      v26 = (v24 & 1) != 0 ? v21 : v24 >> 1;
      for ( i = (v24 & 1) != 0 ? v22 : v23; v25; v25 = (__int64 **)*v25 )
      {
        v28 = (unsigned __int64)v25[1];
        if ( v28 != v16 )
        {
          if ( v19 > 1 )
          {
            if ( v28 >= v17 )
              v28 %= v17;
          }
          else
          {
            v28 &= v17 - 1;
          }
          if ( v28 != v4 )
            break;
        }
        v29 = *((unsigned __int8 *)v25 + 16);
        v30 = (unsigned __int64)v25[3];
        if ( (v29 & 1) == 0 )
          v30 = v29 >> 1;
        if ( v30 == v26 )
        {
          if ( (v29 & 1) != 0 )
            v31 = v25[4];
          else
            v31 = (__int64 *)((char *)v25 + 17);
          if ( (v29 & 1) != 0 )
          {
            if ( !v26 || !memcmp(v31, i, v26) )
              return v25;
          }
          else
          {
            if ( !v26 )
              return v25;
            v32 = 0LL;
            while ( *((unsigned __int8 *)v25 + v32 + 17) == i[v32] )
            {
              if ( v29 >> 1 == ++v32 )
                return v25;
            }
          }
        }
      }
    }
  }
  v33 = a1 + 2;
  v34 = sub_6575418();
  v35 = *a3;
  *(_QWORD *)a3 = 0LL;
  *((_QWORD *)a3 + 1) = 0LL;
  v36 = *((_QWORD *)a3 + 2);
  *((_QWORD *)a3 + 2) = 0LL;
  v37 = a1[3];
  v38 = (_QWORD *)v34;
  *(_OWORD *)(v34 + 16) = v35;
  v39 = *a4;
  *(_QWORD *)(v34 + 32) = v36;
  v40 = *((float *)a1 + 8);
  v50[0] = v34;
  v50[1] = a1 + 2;
  *(_DWORD *)(v34 + 40) = v39;
  v41 = (float)(unsigned __int64)(v37 + 1);
  v51 = 1;
  *(_QWORD *)v34 = 0LL;
  *(_QWORD *)(v34 + 8) = v16;
  if ( !v17 || (float)(v40 * (float)v17) < v41 )
  {
    v42 = v17 < 3 || (v17 & (v17 - 1)) != 0;
    v43 = vcvtps_u32_f32(v41 / v40);
    if ( (v42 | (2 * v17)) >= v43 )
      v44 = v42 | (2 * v17);
    else
      v44 = v43;
    sub_3064C50(a1, v44);
    v17 = a1[1];
    if ( (v17 & (v17 - 1)) != 0 )
    {
      if ( v16 >= v17 )
        v4 = v16 % v17;
      else
        v4 = v16;
    }
    else
    {
      v4 = (v17 - 1) & v16;
    }
  }
  v45 = *a1;
  v46 = *(_QWORD **)(*a1 + 8 * v4);
  if ( v46 )
  {
    *v38 = *v46;
    *v46 = v38;
  }
  else
  {
    v47 = *v33;
    *v33 = (__int64)v38;
    *v38 = v47;
    *(_QWORD *)(v45 + 8 * v4) = v33;
    if ( *(_QWORD *)v50[0] )
    {
      v48 = *(_QWORD *)(*(_QWORD *)v50[0] + 8LL);
      if ( (v17 & (v17 - 1)) != 0 )
      {
        if ( v48 >= v17 )
          v48 %= v17;
      }
      else
      {
        v48 &= v17 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v48) = v50[0];
    }
  }
  v25 = (__int64 **)v50[0];
  ++a1[3];
  return v25;
}


================================================================================
Function: sub_3BCC250 (0x3BCC250)
================================================================================

_QWORD *__fastcall sub_3BCC250(_QWORD *result, unsigned __int8 *a2, __int64 *a3)
{
  _QWORD *v4; // x19
  __int64 v5; // x8
  __int64 i; // x9
  unsigned __int8 *v8; // x22
  __int64 *v9; // x23
  __int64 *v10; // x19

  v4 = result;
  v5 = result[1];
  if ( !v5 )
    goto LABEL_9;
  for ( i = 0LL; i != v5; *(_QWORD *)(*result + 8 * i++) = 0LL )
    ;
  v8 = (unsigned __int8 *)result[2];
  result[2] = 0LL;
  result[3] = 0LL;
  if ( v8 )
  {
    while ( a2 != (unsigned __int8 *)a3 )
    {
      sub_67D3420(v8 + 16, a2 + 16);
      sub_67D3420(v8 + 40, a2 + 40);
      v9 = *(__int64 **)v8;
      result = (_QWORD *)sub_3BCC36C(v4, v8);
      a2 = *(unsigned __int8 **)a2;
      v8 = (unsigned __int8 *)v9;
      if ( !v9 )
        goto LABEL_9;
    }
    do
    {
      v10 = *(__int64 **)v8;
      if ( (v8[40] & 1) != 0 )
        sub_6575460();
      if ( (v8[16] & 1) != 0 )
        sub_6575460();
      result = (_QWORD *)sub_6575460();
      v8 = (unsigned __int8 *)v10;
    }
    while ( v10 );
  }
  else
  {
LABEL_9:
    while ( a2 != (unsigned __int8 *)a3 )
    {
      result = (_QWORD *)sub_3BCC540(v4, a2 + 16);
      a2 = *(unsigned __int8 **)a2;
    }
  }
  return result;
}


================================================================================
Function: sub_3BCC36C (0x3BCC36C)
================================================================================

__int64 __fastcall sub_3BCC36C(__int64 *a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  bool v5; // zf
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x2
  __int64 *v8; // x1
  _QWORD *v9; // x0
  int8x8_t v10; // x8
  unsigned __int64 v11; // x9
  uint8x8_t v12; // d0
  unsigned __int64 v13; // x10
  __int64 v14; // x12
  __int64 v16; // [xsp+0h] [xbp-10h] BYREF

  v4 = *(unsigned __int8 *)(a2 + 16);
  v5 = (v4 & 1) == 0;
  v6 = v4 >> 1;
  if ( v5 )
    v7 = v6;
  else
    v7 = *(_QWORD *)(a2 + 24);
  if ( v5 )
    v8 = (__int64 *)(a2 + 17);
  else
    v8 = *(__int64 **)(a2 + 32);
  *(_QWORD *)(a2 + 8) = sub_24DF128((__int64)&v16, v8, v7);
  v9 = (_QWORD *)sub_3BCC5E4(a1);
  v10.n64_u64[0] = a1[1];
  v11 = *(_QWORD *)(a2 + 8);
  v12.n64_u64[0] = vcnt_s8(v10).n64_u64[0];
  v12.n64_u16[0] = vaddlv_u8(v12);
  if ( v12.n64_u32[0] > 1uLL )
  {
    if ( v11 >= v10.n64_u64[0] )
      v11 %= v10.n64_u64[0];
  }
  else
  {
    v11 &= v10.n64_u64[0] - 1;
  }
  if ( !v9 )
  {
    *(_QWORD *)a2 = a1[2];
    v14 = *a1;
    a1[2] = a2;
    *(_QWORD *)(v14 + 8 * v11) = a1 + 2;
    if ( !*(_QWORD *)a2 )
      goto LABEL_25;
    v13 = *(_QWORD *)(*(_QWORD *)a2 + 8LL);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v10.n64_u64[0] )
        v13 %= v10.n64_u64[0];
    }
    else
    {
      v13 &= v10.n64_u64[0] - 1;
    }
LABEL_24:
    *(_QWORD *)(*a1 + 8 * v13) = a2;
    goto LABEL_25;
  }
  *(_QWORD *)a2 = *v9;
  *v9 = a2;
  if ( *(_QWORD *)a2 )
  {
    v13 = *(_QWORD *)(*(_QWORD *)a2 + 8LL);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v10.n64_u64[0] )
        v13 %= v10.n64_u64[0];
    }
    else
    {
      v13 &= v10.n64_u64[0] - 1;
    }
    if ( v13 != v11 )
      goto LABEL_24;
  }
LABEL_25:
  ++a1[3];
  return a2;
}


================================================================================
Function: sub_3BCC540 (0x3BCC540)
================================================================================

__int64 __fastcall sub_3BCC540(__int64 a1)
{
  _QWORD v3[3]; // [xsp+0h] [xbp-20h] BYREF

  sub_3BCC7E4(v3);
  return sub_3BCC36C(a1, v3[0]);
}


================================================================================
Function: sub_3BCC5E4 (0x3BCC5E4)
================================================================================

__int64 *__fastcall sub_3BCC5E4(__int64 a1, unsigned __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // x23
  float v7; // s1
  float v8; // s0
  _BOOL8 v9; // x9
  unsigned __int64 v10; // x10
  __int64 v11; // x1
  uint8x8_t v12; // d0
  unsigned __int64 v13; // x24
  unsigned __int64 v14; // x25
  __int64 *v15; // x26
  int v16; // w27
  unsigned __int64 v17; // x8
  size_t v18; // x21
  unsigned __int8 *v19; // x22
  _BOOL4 v20; // w8
  int v21; // w9
  __int64 *v22; // x20
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x9
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x11
  unsigned __int64 v27; // x10
  const void *v28; // x0
  unsigned __int8 *v29; // x9
  unsigned __int64 v30; // x10
  unsigned __int8 *v31; // x11
  int v32; // w8
  int v33; // t1
  int v34; // t1
  bool v35; // zf

  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(float *)(a1 + 32);
  v8 = (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL);
  if ( !v6 || (float)(v7 * (float)v6) < v8 )
  {
    v9 = v6 < 3 || (v6 & (v6 - 1)) != 0;
    v10 = vcvtps_u32_f32(v8 / v7);
    if ( (v9 | (2 * v6)) >= v10 )
      v11 = v9 | (2 * v6);
    else
      v11 = v10;
    sub_250E5AC(a1, v11);
    v6 = *(_QWORD *)(a1 + 8);
  }
  v12.n64_u64[0] = vcnt_s8((int8x8_t)v6).n64_u64[0];
  v12.n64_u16[0] = vaddlv_u8(v12);
  v13 = v12.n64_u32[0];
  if ( v12.n64_u32[0] > 1uLL )
  {
    v14 = a2;
    if ( v6 <= a2 )
      v14 = a2 % v6;
  }
  else
  {
    v14 = (v6 - 1) & a2;
  }
  v15 = *(__int64 **)(*(_QWORD *)a1 + 8 * v14);
  if ( v15 )
  {
    v16 = 0;
    v17 = *a3;
    if ( (v17 & 1) != 0 )
      v18 = *((_QWORD *)a3 + 1);
    else
      v18 = v17 >> 1;
    if ( (v17 & 1) != 0 )
      v19 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
    else
      v19 = a3 + 1;
    while ( 1 )
    {
      v22 = v15;
      v15 = (__int64 *)*v15;
      if ( !v15 )
        return v22;
      v23 = v15[1];
      if ( v13 > 1 )
      {
        v24 = v15[1];
        if ( v23 >= v6 )
          v24 = v23 % v6;
      }
      else
      {
        v24 = v23 & (v6 - 1);
      }
      if ( v24 != v14 )
        return v22;
      if ( v23 != a2 )
        goto LABEL_21;
      v25 = *((unsigned __int8 *)v15 + 16);
      v26 = v15[3];
      v27 = v25 >> 1;
      if ( (v25 & 1) == 0 )
        v26 = v25 >> 1;
      if ( v26 == v18 )
      {
        if ( (v25 & 1) != 0 )
          v28 = (const void *)v15[4];
        else
          v28 = (char *)v15 + 17;
        if ( (v25 & 1) == 0 )
        {
          if ( v18 )
          {
            v29 = (unsigned __int8 *)v15 + 17;
            v30 = v27 - 1;
            v31 = v19;
            do
            {
              v33 = *v29++;
              v32 = v33;
              v34 = *v31++;
              v35 = v32 == v34;
              v20 = v32 == v34;
              v35 = !v35 || v30-- == 0;
            }
            while ( !v35 );
            goto LABEL_22;
          }
LABEL_47:
          v20 = 1;
          goto LABEL_22;
        }
        if ( !v18 )
          goto LABEL_47;
        v20 = memcmp(v28, v19, v18) == 0;
      }
      else
      {
LABEL_21:
        v20 = 0;
      }
LABEL_22:
      v21 = v16 & !v20;
      v16 |= v20;
      if ( v21 == 1 )
        return v22;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_3BCC7E4 (0x3BCC7E4)
================================================================================

unsigned __int64 __usercall sub_3BCC7E4@<X0>(__int64 a1@<X0>, __int128 *a2@<X1>, __int64 a3@<X8>)
{
  __int64 v4; // x22
  unsigned __int64 *v6; // x20
  __int64 *v7; // x9
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  bool v10; // zf
  unsigned __int64 v11; // x8
  __int64 *v12; // x1
  unsigned __int64 v13; // x2
  unsigned __int64 result; // x0
  __int64 v15; // [xsp+0h] [xbp-10h] BYREF

  v4 = a1 + 16;
  v6 = (unsigned __int64 *)sub_6575418();
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v4;
  *(_BYTE *)(a3 + 16) = 0;
  sub_67D2788(v6 + 2, a2);
  sub_67D2788(v6 + 5, (__int128 *)((char *)a2 + 24));
  v8 = v6[3];
  v7 = (__int64 *)v6[4];
  v9 = *((unsigned __int8 *)v6 + 16);
  *(_BYTE *)(a3 + 16) = 1;
  v10 = (v9 & 1) == 0;
  v11 = v9 >> 1;
  if ( v10 )
    v12 = (__int64 *)((char *)v6 + 17);
  else
    v12 = v7;
  if ( v10 )
    v13 = v11;
  else
    v13 = v8;
  result = sub_24DF128((__int64)&v15, v12, v13);
  *v6 = 0LL;
  v6[1] = result;
  return result;
}


================================================================================
Function: sub_3BDB2E4 (0x3BDB2E4)
================================================================================

__int64 __usercall sub_3BDB2E4@<X0>(__int64 *a1@<X0>, _QWORD *a2@<X8>)
{
  __int64 result; // x0
  __int64 v5; // x23
  __int64 v6; // x19
  _BYTE v7[32]; // [xsp+8h] [xbp-28h] BYREF

  result = sub_3BDCDD0();
  v5 = *a1;
  if ( !*a1 )
  {
    sub_3BC8D40(v7);
    sub_3BC8BC8(v7);
  }
  if ( *((_BYTE *)a1 + 16) )
  {
    sub_3BC8F78(v7);
    sub_3BC8DF8(v7);
  }
  v6 = a1[1];
  *((_BYTE *)a1 + 16) = 1;
  if ( v6 )
  {
    sub_67F0380(1u, (atomic_uint *)(v6 + 8));
    sub_67F0380(1u, (atomic_uint *)(v6 + 8));
    *a2 = v5;
    a2[1] = v6;
    sub_67F0380(1u, (atomic_uint *)(v6 + 8));
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 12));
      if ( (_DWORD)result == 1 )
        return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  else
  {
    *a2 = v5;
    a2[1] = 0LL;
  }
  return result;
}


================================================================================
Function: sub_3BDCDD0 (0x3BDCDD0)
================================================================================

__int64 __fastcall sub_3BDCDD0(unsigned __int64 a1)
{
  unsigned __int64 v2; // x23
  __int64 result; // x0
  unsigned int v4; // w21
  __int64 v5; // x20
  __int64 v6; // x25
  _QWORD *v7; // x20
  __int64 v8; // x19
  __int64 v9; // x19
  _QWORD *v10; // [xsp+10h] [xbp-30h] BYREF
  __int64 v11; // [xsp+18h] [xbp-28h] BYREF
  __int128 v12; // [xsp+20h] [xbp-20h] BYREF

  v2 = a1 % 0x29;
  result = sub_67F01D0(1u, (atomic_uint *)&dword_6D6BE20[a1 % 0x29]);
  if ( (_DWORD)result )
  {
    v4 = 0;
    do
    {
      if ( v4 >= 4 )
      {
        if ( v4 < 0x20 || (v4 & 1) != 0 )
        {
          sched_yield();
        }
        else
        {
          v12 = xmmword_AF8BD0;
          nanosleep((const struct timespec *)&v12, 0LL);
        }
      }
      ++v4;
      result = sub_67F01D0(1u, (atomic_uint *)&dword_6D6BE20[v2]);
    }
    while ( (_DWORD)result );
  }
  v6 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(a1 + 8);
  if ( !v5 )
  {
    atomic_store(0, &dword_6D6BE20[v2]);
    if ( v6 )
      return result;
    goto LABEL_16;
  }
  sub_67F0380(1u, (atomic_uint *)(v5 + 8));
  atomic_store(0, &dword_6D6BE20[v2]);
  result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v5 + 8));
  if ( (_DWORD)result == 1 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v5 + 12));
    if ( (_DWORD)result == 1 )
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 24LL))(v5);
  }
  if ( !v6 )
  {
LABEL_16:
    v12 = 0uLL;
    v7 = (_QWORD *)sub_6575418();
    sub_3BC9264();
    v7[33] = 0LL;
    v10 = v7;
    v11 = 0LL;
    *v7 = off_68DFE28;
    sub_3BDD74C(&v10, v7, &v11);
    result = sub_3BDD2BC(a1, &v12, &v10);
    v8 = v11;
    if ( v11 )
    {
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v11 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 16LL))(v8);
        result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v8 + 12));
        if ( (_DWORD)result == 1 )
          result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 24LL))(v8);
      }
    }
    v9 = *((_QWORD *)&v12 + 1);
    if ( *((_QWORD *)&v12 + 1) )
    {
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(*((_QWORD *)&v12 + 1) + 8LL));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v9 + 16LL))(v9);
        result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v9 + 12));
        if ( (_DWORD)result == 1 )
          return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 24LL))(v9);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_3BDD2BC (0x3BDD2BC)
================================================================================

bool __fastcall sub_3BDD2BC(unsigned __int64 a1, _QWORD *a2, _QWORD *a3)
{
  unsigned __int64 v6; // x24
  unsigned int v7; // w26
  __int64 v8; // x26
  __int64 v9; // x27
  _BOOL4 v10; // w21
  __int64 v11; // x9
  __int64 v12; // x20
  __int128 v14; // [xsp+10h] [xbp-20h] BYREF

  v6 = a1 % 0x29;
  if ( (unsigned int)sub_67F01D0(1u, (atomic_uint *)&dword_6D6BE20[a1 % 0x29]) )
  {
    v7 = 0;
    do
    {
      if ( v7 >= 4 )
      {
        if ( v7 < 0x20 || (v7 & 1) != 0 )
        {
          sched_yield();
        }
        else
        {
          v14 = xmmword_AF8BD0;
          nanosleep((const struct timespec *)&v14, 0LL);
        }
      }
      ++v7;
    }
    while ( (unsigned int)sub_67F01D0(1u, (atomic_uint *)&dword_6D6BE20[v6]) );
  }
  v8 = *(_QWORD *)a1;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)a1 == *a2 && v9 == a2[1];
  if ( v10 )
  {
    *(_QWORD *)a1 = *a3;
    *a3 = v8;
    v11 = a3[1];
    a3[1] = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v11;
    atomic_store(0, &dword_6D6BE20[v6]);
  }
  else
  {
    if ( v9 )
      sub_67F0380(1u, (atomic_uint *)(v9 + 8));
    atomic_store(0, &dword_6D6BE20[v6]);
    v12 = a2[1];
    *a2 = v8;
    a2[1] = v9;
    if ( v12 )
    {
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v12 + 8)) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 16LL))(v12);
        if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v12 + 12)) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 24LL))(v12);
      }
    }
  }
  return v10;
}


================================================================================
Function: sub_3BDD74C (0x3BDD74C)
================================================================================

_QWORD *__fastcall sub_3BDD74C(__int64 a1, __int64 a2, __int64 *a3)
{
  _QWORD *result; // x0
  __int64 v7; // x21

  result = (_QWORD *)sub_6575418();
  v7 = *a3;
  result[2] = a2;
  *a3 = (__int64)result;
  *result = off_68DFE88;
  result[1] = 0x100000001LL;
  if ( v7 )
  {
    result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
      result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 12));
      if ( (_DWORD)result == 1 )
        result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
    }
  }
  if ( a2 )
    return (_QWORD *)sub_3BDD86C(a2 + 8, a1, a2);
  return result;
}


================================================================================
Function: sub_3BDD86C (0x3BDD86C)
================================================================================

_QWORD *__fastcall sub_3BDD86C(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x20
  __int64 v5; // x8
  __int64 v7; // x19
  __int64 v8; // x8
  __int64 v9; // x22

  v4 = result;
  v5 = result[1];
  if ( v5 )
  {
    if ( atomic_load((unsigned int *)(v5 + 8)) )
      return result;
  }
  v7 = *(_QWORD *)(a2 + 8);
  if ( v7 )
  {
    sub_67F0380(1u, (atomic_uint *)(v7 + 8));
    v8 = v4[1];
    *v4 = a3;
    if ( v7 == v8 )
      goto LABEL_11;
    sub_67F0380(1u, (atomic_uint *)(v7 + 12));
    v9 = v4[1];
    if ( !v9 )
    {
      v4[1] = v7;
LABEL_11:
      result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
        result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 12));
        if ( (_DWORD)result == 1 )
          return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
      }
      return result;
    }
  }
  else
  {
    v9 = result[1];
    *result = a3;
    if ( !v9 )
      return result;
  }
  result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v9 + 12));
  if ( (_DWORD)result == 1 )
    result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 24LL))(v9);
  v4[1] = v7;
  if ( v7 )
    goto LABEL_11;
  return result;
}


================================================================================
Function: sub_3BE0324 (0x3BE0324)
================================================================================

__int64 __fastcall sub_3BE0324(__int64 a1)
{
  __int64 v2; // x22
  unsigned __int8 v3; // w8
  __int64 v4; // x0
  _QWORD *v5; // x0
  __int64 v6; // x8
  __int64 v7; // x9
  unsigned __int64 *v8; // x23
  unsigned __int64 *v9; // x23
  _QWORD *v10; // x0
  __int64 v11; // x8
  __int64 v12; // x9
  unsigned __int64 *v13; // x23
  unsigned __int64 *v14; // x23
  __int64 v15; // x8
  __int64 v16; // x9
  __int64 v17; // x23
  unsigned __int64 *v18; // x23
  __int64 v19; // x0
  __int64 v20; // x19
  __int64 result; // x0
  __int64 v22; // x8
  __int64 v23; // [xsp+0h] [xbp-50h] BYREF
  __int64 v24; // [xsp+8h] [xbp-48h]
  _QWORD v25[4]; // [xsp+10h] [xbp-40h] BYREF
  _QWORD *v26; // [xsp+30h] [xbp-20h]

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 48) = 0LL;
  v2 = a1 + 48;
  v3 = atomic_load(byte_6C38350);
  if ( (v3 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6C38350) )
  {
    qword_6C38310 = (__int64)off_67F87E8;
    sub_67D19DC(algn_6C38318);
    qword_6C38340 = 0LL;
    unk_6C38348 = 0LL;
    qword_6C38310 = (__int64)off_67FAA40;
    qword_6C38358 = (__int64)&qword_6C38310;
    sub_67EB838(byte_6C38350);
  }
  *(_QWORD *)(a1 + 56) = sub_25138D8(&qword_6C38310);
  v4 = sub_61CC7A4();
  v5 = sub_3BE098C(&v23, v4);
  v6 = v23;
  v7 = v24;
  v23 = 0LL;
  v24 = 0LL;
  v8 = *(unsigned __int64 **)(a1 + 8);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 8) = v7;
  if ( v8 )
  {
    v5 = (_QWORD *)sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v8 + 1));
    if ( !v5 )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v8 + 16))(v8);
      v5 = (_QWORD *)sub_67D18A4(v8);
    }
  }
  v9 = (unsigned __int64 *)v24;
  if ( v24 )
  {
    v5 = (_QWORD *)sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8));
    if ( !v5 )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v9 + 16))(v9);
      v5 = (_QWORD *)sub_67D18A4(v9);
    }
  }
  v10 = sub_3BE0A94(&v23, v5);
  v11 = v23;
  v12 = v24;
  v23 = 0LL;
  v24 = 0LL;
  v13 = *(unsigned __int64 **)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(a1 + 24) = v12;
  if ( v13 )
  {
    v10 = (_QWORD *)sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v13 + 1));
    if ( !v10 )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v13 + 16))(v13);
      v10 = (_QWORD *)sub_67D18A4(v13);
    }
  }
  v14 = (unsigned __int64 *)v24;
  if ( v24 )
  {
    v10 = (_QWORD *)sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8));
    if ( !v10 )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v14 + 16))(v14);
      v10 = (_QWORD *)sub_67D18A4(v14);
    }
  }
  sub_3BE0B9C(&v23, v10);
  v15 = v23;
  v16 = v24;
  v23 = 0LL;
  v24 = 0LL;
  v17 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 32) = v15;
  *(_QWORD *)(a1 + 40) = v16;
  if ( v17 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v17 + 8)) )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 16LL))(v17);
    sub_67D18A4((unsigned __int64 *)v17);
  }
  v18 = (unsigned __int64 *)v24;
  if ( v24 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v18 + 16))(v18);
    sub_67D18A4(v18);
  }
  qword_6D6BE10 = a1;
  v19 = sub_6575418();
  *(_QWORD *)(v19 + 32) = 0LL;
  qword_6D6BE18 = v19;
  v25[0] = off_68E0570;
  *(_OWORD *)v19 = 0u;
  *(_OWORD *)(v19 + 16) = 0u;
  v26 = v25;
  sub_62596C0(&v23, v25);
  if ( (sub_657CC24(v2, &v23) & 1) != 0 )
  {
    sub_657C5C4(v2);
    sub_657CD4C(v2, &v23);
  }
  v20 = v23;
  if ( v23 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFFLL, v23 + 4) == 1 )
      sub_657E090(v20);
  }
  result = (__int64)v26;
  if ( v25 == v26 )
  {
    v22 = 4LL;
  }
  else
  {
    if ( !v26 )
      return result;
    v22 = 5LL;
  }
  return (*(__int64 (**)(void))(*v26 + 8 * v22))();
}


================================================================================
Function: sub_3BE098C (0x3BE098C)
================================================================================

__int64 __usercall sub_3BE098C@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  _QWORD *v3; // x20
  __int64 v4; // x20
  _QWORD *v5; // x21
  __int64 result; // x0

  if ( byte_71CF7B0 )
    v2 = byte_7286120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = (_QWORD *)sub_6575418();
    v3[1] = 0LL;
    v3[2] = 0LL;
    *v3 = off_68E03E0;
    result = sub_3BE0D80(v3 + 3);
    *a1 = v3 + 3;
    a1[1] = v3;
  }
  else
  {
    v4 = sub_678E980();
    v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 216LL, 8LL);
    v5[2] = 0LL;
    v5[3] = v4;
    *v5 = off_68E0390;
    v5[1] = 0LL;
    result = sub_3BE0D80(v5 + 4);
    *a1 = v5 + 4;
    a1[1] = v5;
  }
  return result;
}


================================================================================
Function: sub_3BE0A94 (0x3BE0A94)
================================================================================

__int64 __usercall sub_3BE0A94@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  _QWORD *v3; // x20
  __int64 v4; // x20
  _QWORD *v5; // x21
  __int64 result; // x0

  if ( byte_71CF7B0 )
    v2 = byte_7286120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = (_QWORD *)sub_6575418();
    v3[1] = 0LL;
    v3[2] = 0LL;
    *v3 = off_68E0480;
    result = sub_3BE10A8(v3 + 3);
    *a1 = v3 + 3;
    a1[1] = v3;
  }
  else
  {
    v4 = sub_678E980();
    v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 280LL, 8LL);
    v5[2] = 0LL;
    v5[3] = v4;
    *v5 = off_68E0430;
    v5[1] = 0LL;
    result = sub_3BE10A8(v5 + 4);
    *a1 = v5 + 4;
    a1[1] = v5;
  }
  return result;
}


================================================================================
Function: sub_3BE0B9C (0x3BE0B9C)
================================================================================

_QWORD *__usercall sub_3BE0B9C@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  __int64 v3; // x20
  __int64 v4; // x20
  __int64 v5; // x21
  _QWORD *result; // x0

  if ( byte_71CF7B0 )
    v2 = byte_7286120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = sub_6575418();
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_DWORD *)(v3 + 24) = 0;
    *(_QWORD *)(v3 + 40) = 0LL;
    *(_QWORD *)(v3 + 48) = 0LL;
    *(_QWORD *)v3 = off_68E0520;
    *(_QWORD *)(v3 + 32) = 0LL;
    result = (_QWORD *)sub_6575418();
    *result = 0LL;
    result[1] = 0LL;
    *(_QWORD *)(v3 + 32) = result;
    *(_QWORD *)(v3 + 40) = result + 2;
    *(_QWORD *)(v3 + 48) = result + 2;
    *a1 = v3 + 24;
    a1[1] = v3;
  }
  else
  {
    v4 = sub_678E980();
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 64LL, 8LL);
    *(_QWORD *)(v5 + 16) = 0LL;
    *(_QWORD *)(v5 + 24) = v4;
    *(_QWORD *)(v5 + 48) = 0LL;
    *(_QWORD *)(v5 + 56) = 0LL;
    *(_QWORD *)v5 = off_68E04D0;
    *(_QWORD *)(v5 + 8) = 0LL;
    *(_DWORD *)(v5 + 32) = 0;
    *(_QWORD *)(v5 + 40) = 0LL;
    result = (_QWORD *)sub_6575418();
    *(_QWORD *)(v5 + 40) = result;
    *a1 = v5 + 32;
    a1[1] = v5;
    *(_QWORD *)(v5 + 56) = result + 2;
    *result = 0LL;
    result[1] = 0LL;
    *(_QWORD *)(v5 + 48) = result + 2;
  }
  return result;
}


================================================================================
Function: sub_3BE0D80 (0x3BE0D80)
================================================================================

long double __fastcall sub_3BE0D80(_BYTE *a1)
{
  _BYTE *v1; // x19
  long double result; // q0

  v1 = a1;
  *a1 = 1;
  sub_3BC677C();
  *(_OWORD *)(v1 + 24) = 0u;
  *((_QWORD *)v1 + 7) = 0LL;
  *(_OWORD *)(v1 + 40) = 0u;
  sub_642AE70(v1 + 64);
  *(_OWORD *)&result = 0uLL;
  *((_QWORD *)v1 + 21) = 0LL;
  *((_QWORD *)v1 + 22) = 0LL;
  v1 += 168;
  *((_QWORD *)v1 - 1) = v1;
  *(_OWORD *)(v1 - 88) = 0u;
  *(_OWORD *)(v1 - 72) = 0u;
  *(_OWORD *)(v1 - 56) = 0u;
  *(_OWORD *)(v1 - 40) = 0u;
  *(_OWORD *)(v1 - 24) = 0u;
  return result;
}


================================================================================
Function: sub_3BE10A8 (0x3BE10A8)
================================================================================

long double __fastcall sub_3BE10A8(__int64 a1)
{
  long double result; // q0

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_DWORD *)(a1 + 112) = 1065353216;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 152) = 1065353216;
  strcpy((char *)sub_6575418(), "EventIngest TimerThread");
  sub_3BC08E8();
  sub_67D3420(*(_QWORD *)(a1 + 160) + 48LL);
  sub_6575460();
  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)(a1 + 240) = 0LL;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  return result;
}


================================================================================
Function: sub_3BE3B58 (0x3BE3B58)
================================================================================

_QWORD *__fastcall sub_3BE3B58(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // x22
  __int64 v3; // x23
  __int64 v6; // x21
  __int64 v7; // x21

  v3 = *a2;
  v2 = a2[1];
  if ( v2 )
    sub_67F0380(1u, (atomic_uint *)(v2 + 8));
  v6 = a1[1];
  *a1 = v3;
  a1[1] = v2;
  if ( v6 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v6 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
    }
  }
  v7 = a2[1];
  *a2 = 0LL;
  a2[1] = 0LL;
  if ( v7 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
    }
  }
  return a1;
}


================================================================================
Function: sub_3BE4398 (0x3BE4398)
================================================================================

_QWORD *__fastcall sub_3BE4398(__int64 a1, __int64 a2, __int64 *a3)
{
  _QWORD *result; // x0
  __int64 v7; // x21

  result = (_QWORD *)sub_6575418();
  v7 = *a3;
  result[2] = a2;
  *a3 = (__int64)result;
  *result = off_68E0918;
  result[1] = 0x100000001LL;
  if ( v7 )
  {
    result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
      result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 12));
      if ( (_DWORD)result == 1 )
        result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
    }
  }
  if ( a2 )
    return (_QWORD *)sub_3BE44B8(a2 + 8, a1, a2);
  return result;
}


================================================================================
Function: sub_3BE44B8 (0x3BE44B8)
================================================================================

_QWORD *__fastcall sub_3BE44B8(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x20
  __int64 v5; // x8
  __int64 v7; // x19
  __int64 v8; // x8
  __int64 v9; // x22

  v4 = result;
  v5 = result[1];
  if ( v5 )
  {
    if ( atomic_load((unsigned int *)(v5 + 8)) )
      return result;
  }
  v7 = *(_QWORD *)(a2 + 8);
  if ( v7 )
  {
    sub_67F0380(1u, (atomic_uint *)(v7 + 8));
    v8 = v4[1];
    *v4 = a3;
    if ( v7 == v8 )
      goto LABEL_11;
    sub_67F0380(1u, (atomic_uint *)(v7 + 12));
    v9 = v4[1];
    if ( !v9 )
    {
      v4[1] = v7;
LABEL_11:
      result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
        result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 12));
        if ( (_DWORD)result == 1 )
          return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
      }
      return result;
    }
  }
  else
  {
    v9 = result[1];
    *result = a3;
    if ( !v9 )
      return result;
  }
  result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v9 + 12));
  if ( (_DWORD)result == 1 )
    result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 24LL))(v9);
  v4[1] = v7;
  if ( v7 )
    goto LABEL_11;
  return result;
}


================================================================================
Function: sub_3BE45BC (0x3BE45BC)
================================================================================

__int64 __fastcall sub_3BE45BC(__int64 *a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 v3; // x8
  __int64 v6; // x0
  __int64 result; // x0
  __int64 v8; // x11
  __int64 v9; // x10
  __int64 v10; // x13
  int v11; // s0
  int v12; // s1
  __int64 v13; // x13
  __int64 v14; // x10
  __int64 v15; // x12
  unsigned __int64 v16; // x12
  unsigned __int64 v17; // x11
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x9

  v2 = *a1;
  *a1 = 0LL;
  v3 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0LL;
  v6 = *a1;
  *a1 = v3;
  if ( v6 )
    sub_6575460();
  result = *(_QWORD *)a2;
  *(_QWORD *)a2 = v2;
  if ( result )
    result = sub_6575460();
  v8 = a1[2];
  v9 = *(_QWORD *)(a2 + 8);
  v10 = a1[1];
  v11 = *((_DWORD *)a1 + 8);
  a1[2] = *(_QWORD *)(a2 + 16);
  a1[1] = v9;
  v12 = *(_DWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 8) = v10;
  v13 = *(_QWORD *)(a2 + 24);
  v14 = a1[3];
  *(_QWORD *)(a2 + 16) = v8;
  *((_DWORD *)a1 + 8) = v12;
  a1[3] = v13;
  *(_QWORD *)(a2 + 24) = v14;
  v15 = a1[3];
  *(_DWORD *)(a2 + 32) = v11;
  if ( v15 )
  {
    v16 = a1[1];
    v17 = *(_QWORD *)(a1[2] + 8);
    if ( (v16 & (v16 - 1)) != 0 )
    {
      if ( v17 >= v16 )
        v17 %= v16;
    }
    else
    {
      v17 &= v16 - 1;
    }
    *(_QWORD *)(*a1 + 8 * v17) = a1 + 2;
  }
  if ( v14 )
  {
    v18 = *(_QWORD *)(a2 + 8);
    v19 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8LL);
    if ( (v18 & (v18 - 1)) != 0 )
    {
      if ( v19 >= v18 )
        v19 %= v18;
    }
    else
    {
      v19 &= v18 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a2 + 8 * v19) = a2 + 16;
  }
  return result;
}


================================================================================
Function: sub_3BE7F14 (0x3BE7F14)
================================================================================

__int64 __fastcall sub_3BE7F14(__int128 *a1, unsigned __int8 *a2, unsigned __int8 *a3, char a4, char a5)
{
  char *v9; // x1
  unsigned __int64 v10; // x2
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x9
  __int128 *v15; // x10
  unsigned __int64 v16; // x13
  bool v17; // zf
  size_t v18; // x13
  void *v19; // x3
  size_t v20; // x4
  _BYTE *v21; // x1
  size_t v22; // x2
  __int64 v23; // x8
  __int64 result; // x0
  unsigned __int64 *v25; // x19
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x8
  unsigned __int64 v28; // x9
  __int128 *v29; // x2
  unsigned __int64 v30; // x8
  __int64 **v31; // x21
  __int64 v32; // x0
  unsigned __int64 *v33; // x21
  __int64 *v34; // x22
  __int64 v35; // [xsp+0h] [xbp-210h] BYREF
  __int64 v36; // [xsp+8h] [xbp-208h]
  unsigned __int64 v37[3]; // [xsp+10h] [xbp-200h] BYREF
  int v38[2]; // [xsp+28h] [xbp-1E8h] BYREF
  __int64 v39; // [xsp+30h] [xbp-1E0h]
  char v40; // [xsp+38h] [xbp-1D8h]
  __int64 v41; // [xsp+50h] [xbp-1C0h]
  __int64 **v42; // [xsp+60h] [xbp-1B0h]
  char v43; // [xsp+78h] [xbp-198h]
  _QWORD v44[2]; // [xsp+F0h] [xbp-120h] BYREF
  _QWORD v45[2]; // [xsp+100h] [xbp-110h] BYREF
  _QWORD *v46; // [xsp+110h] [xbp-100h]
  __int128 v47; // [xsp+140h] [xbp-D0h]
  __int128 v48; // [xsp+150h] [xbp-C0h]
  int v49; // [xsp+160h] [xbp-B0h]
  _QWORD v50[18]; // [xsp+168h] [xbp-A8h] BYREF
  int v51; // [xsp+1F8h] [xbp-18h]

  if ( (a4 & 1) != 0 )
    sub_6579D18("%s?%s", v37);
  else
    sub_67D2788(v37, a1);
  if ( byte_71CF7B0 && byte_6D6BF68 )
  {
    sub_6254B64(v38, 0LL);
    if ( (v37[0] & 1) != 0 )
      v9 = (char *)v37[2];
    else
      v9 = (char *)v37 + 1;
    if ( (v37[0] & 1) != 0 )
      v10 = v37[1];
    else
      v10 = (unsigned __int64)LOBYTE(v37[0]) >> 1;
    sub_6255DFC(*(_QWORD *)v38, v9, v10);
    *(_DWORD *)(*(_QWORD *)v38 + 452LL) = 23;
    sub_62569C0();
    if ( (a4 & 1) == 0 )
    {
      sub_62566A8(*(_QWORD *)v38);
      v11 = *a2;
      if ( (v11 & 1) != 0 )
        v12 = *((_QWORD *)a2 + 1);
      else
        v12 = v11 >> 1;
      sub_6256DF0(*(_QWORD *)v38, a2, v12 > 0x100);
      v13 = *a3;
      if ( (v13 & 1) != 0 )
        v14 = *((_QWORD *)a3 + 1);
      else
        v14 = v13 >> 1;
      if ( v14 )
        v15 = (__int128 *)a3;
      else
        v15 = &xmmword_6F77160;
      v16 = *(unsigned __int8 *)v15;
      v17 = (v16 & 1) == 0;
      v18 = v16 >> 1;
      if ( v17 )
        v19 = (char *)v15 + 1;
      else
        v19 = (void *)*((_QWORD *)v15 + 2);
      if ( v17 )
        v20 = v18;
      else
        v20 = *((_QWORD *)v15 + 1);
      if ( (byte_6F76E58 & 1) != 0 )
        v21 = (_BYTE *)unk_6F76E68;
      else
        v21 = algn_6F76E59;
      if ( (byte_6F76E58 & 1) != 0 )
        v22 = qword_6F76E60;
      else
        v22 = (unsigned __int64)(unsigned __int8)byte_6F76E58 >> 1;
      sub_62556A4(v38[0], v21, v22, v19, v20);
    }
    v46 = v44;
    v44[0] = off_68E0B30;
    (***(void (__fastcall ****)(_QWORD, _QWORD *))v38)(*(_QWORD *)v38, v44);
    if ( v44 == v46 )
    {
      v23 = 4LL;
    }
    else
    {
      if ( !v46 )
      {
LABEL_44:
        result = sub_6256A9C(*(_QWORD *)v38, 3000LL);
        v25 = (unsigned __int64 *)v39;
        if ( v39 )
        {
          result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v39 + 8));
          if ( !result )
          {
            (*(void (__fastcall **)(unsigned __int64 *))(*v25 + 16))(v25);
            result = sub_67D18A4(v25);
          }
        }
        goto LABEL_68;
      }
      v23 = 5LL;
    }
    (*(void (**)(void))(*v46 + 8 * v23))();
    goto LABEL_44;
  }
  v50[0] = off_6810570;
  v44[0] = off_6810548;
  v44[1] = 0LL;
  sub_67A8530((__int64)v50, (__int64)v45);
  v50[17] = 0LL;
  v51 = -1;
  v44[0] = off_68104D8;
  v50[0] = off_6810500;
  sub_67A5110((__int64)v45);
  v49 = 8;
  v47 = 0u;
  v48 = 0u;
  v45[0] = off_67FDA98;
  sub_26B93A8((__int64)v45);
  v35 = qword_72804D8;
  v36 = qword_72804E0;
  if ( qword_72804E0 )
    sub_67F0410(1uLL, (atomic_ullong *)(qword_72804E0 + 8));
  sub_621636C(v38, v37, 23LL, 0LL);
  if ( (a4 & 1) != 0 )
  {
    sub_62186C8((int)v38, (int)&v35, 0, 0, 1);
  }
  else
  {
    v26 = *a3;
    v17 = (v26 & 1) == 0;
    v27 = v26 >> 1;
    if ( !v17 )
      v27 = *((_QWORD *)a3 + 1);
    v28 = *a2;
    if ( v27 )
      v29 = (__int128 *)a3;
    else
      v29 = &xmmword_6F77160;
    v30 = v28 >> 1;
    if ( (v28 & 1) != 0 )
      v30 = *((_QWORD *)a2 + 1);
    ((void (__fastcall *)(int *, _QWORD *, __int128 *, bool, __int64 *, _QWORD, _QWORD, __int64))sub_6216948)(
      v38,
      v44,
      v29,
      v30 > 0x100,
      &v35,
      a5 & 1,
      0LL,
      1LL);
  }
  if ( (v43 & 1) != 0 )
    sub_6575460();
  v31 = v42;
  if ( v42 )
  {
    do
    {
      v34 = *v31;
      if ( ((_BYTE)v31[5] & 1) != 0 )
        sub_6575460();
      if ( ((_BYTE)v31[2] & 1) != 0 )
        sub_6575460();
      sub_6575460();
      v31 = (__int64 **)v34;
    }
    while ( v34 );
  }
  v32 = v41;
  v41 = 0LL;
  if ( v32 )
    sub_6575460();
  if ( (v40 & 1) != 0 )
    sub_6575460();
  v33 = (unsigned __int64 *)v36;
  if ( v36 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v36 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v33 + 16))(v33);
    sub_67D18A4(v33);
  }
  v50[0] = off_6810500;
  v44[0] = off_68104D8;
  v45[0] = off_67FDA98;
  if ( (v47 & 1) != 0 )
    sub_6575460();
  sub_6589C04(v45);
  sub_67A5550();
  result = sub_67A501C();
LABEL_68:
  if ( (v37[0] & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_3C0ACD8 (0x3C0ACD8)
================================================================================

__int64 __fastcall sub_3C0ACD8(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_67F0440(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65786C4(0);
  if ( v2 >> 62 != 2 )
  {
    sub_6577E74(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7286220);
      v5 = sub_6585904(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_3C0AF20(v5);
      sub_67F05F0(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_67D1AF4((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_3C0AF20 (0x3C0AF20)
================================================================================

__int64 sub_3C0AF20()
{
  __int64 v0; // x19

  v0 = sub_6575FA8(0x68uLL, 8uLL);
  sub_62249E8();
  return v0;
}


================================================================================
Function: sub_3C8D8E4 (0x3C8D8E4)
================================================================================

__int64 __fastcall sub_3C8D8E4(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_67F0440(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65786C4(0);
  if ( v2 >> 62 != 2 )
  {
    sub_6577E74(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7286220);
      v5 = sub_6585904(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_3C8DB2C(v5);
      sub_67F05F0(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_67D1AF4((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_3C8DB2C (0x3C8DB2C)
================================================================================

__int64 sub_3C8DB2C()
{
  __int64 v0; // x19

  v0 = sub_6575FA8(0x378uLL, 8uLL);
  sub_3C8DB5C();
  return v0;
}


================================================================================
Function: sub_3C8DB5C (0x3C8DB5C)
================================================================================

long double __fastcall sub_3C8DB5C(__int64 a1)
{
  long double result; // q0

  *(_QWORD *)a1 = "BatchedReporterManager";
  *(_QWORD *)(a1 + 8) = 22LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = a1 + 24;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = off_6BA2C88;
  *(_DWORD *)(a1 + 92) = 2;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 1065353216;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_DWORD *)(a1 + 184) = 1065353216;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_QWORD *)(a1 + 240) = sub_6580530();
  sub_3C8DDB4(a1 + 248);
  *(_QWORD *)(a1 + 472) = 0LL;
  *(_QWORD *)(a1 + 480) = 0LL;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_DWORD *)(a1 + 468) = 1;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_QWORD *)(a1 + 456) = &off_6BA2B20;
  *(_QWORD *)(a1 + 568) = off_68E8528;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_DWORD *)(a1 + 520) = 1065353216;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_QWORD *)(a1 + 560) = 0LL;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_QWORD *)(a1 + 588) = 0LL;
  *(_QWORD *)(a1 + 580) = 0LL;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_DWORD *)(a1 + 596) = 0;
  *(_QWORD *)(a1 + 712) = 0LL;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_DWORD *)(a1 + 720) = 1065353216;
  *(_DWORD *)(a1 + 760) = 1065353216;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_OWORD *)(a1 + 744) = 0u;
  sub_642AE70((_QWORD *)(a1 + 768));
  *(_QWORD *)(a1 + 816) = 0LL;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  sub_642AE70((_QWORD *)(a1 + 824));
  *(_OWORD *)&result = 0uLL;
  *(_OWORD *)(a1 + 866) = 0u;
  *(_OWORD *)(a1 + 840) = 0u;
  *(_OWORD *)(a1 + 856) = 0u;
  return result;
}


================================================================================
Function: sub_3C8DDB4 (0x3C8DDB4)
================================================================================

__int64 __fastcall sub_3C8DDB4(__int64 a1)
{
  __int64 result; // x0

  *(_DWORD *)(a1 + 12) = 2;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)a1 = off_6BA2EC0;
  sub_3C8E330(a1 + 32);
  *(_OWORD *)(a1 + 152) = 0u;
  *(_QWORD *)(a1 + 184) = 0LL;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_QWORD *)(a1 + 192) = sub_67A2CE8();
  result = sub_654F358();
  *(_QWORD *)(a1 + 200) = result;
  return result;
}


================================================================================
Function: sub_3C8E330 (0x3C8E330)
================================================================================

__int64 __fastcall sub_3C8E330(__int64 a1)
{
  _QWORD *v2; // x0
  _QWORD *v3; // x21
  _QWORD *v4; // x0
  __int64 result; // x0
  __int64 v6; // x19
  __int64 v7; // x20
  char v8; // t1
  __int64 v9; // [xsp+0h] [xbp-20h]
  __int64 v10; // [xsp+8h] [xbp-18h]
  __int64 v11; // [xsp+10h] [xbp-10h]

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 112) = 0LL;
  v2 = (_QWORD *)sub_6575418();
  v2[1] = 0LL;
  v2[2] = 0LL;
  v2[4] = 0LL;
  v2[5] = 0LL;
  v2[3] = 0LL;
  v3 = v2 + 3;
  *v2 = &off_68E84D8;
  *(_QWORD *)(a1 + 88) = v2 + 3;
  *(_QWORD *)(a1 + 96) = v2;
  v4 = (_QWORD *)sub_6575418();
  v4[1] = 0LL;
  v4[2] = 0LL;
  *v4 = &off_68E84D8;
  v4[4] = 0LL;
  v4[5] = 0LL;
  v4[3] = 0LL;
  *(_QWORD *)(a1 + 104) = v4 + 3;
  *(_QWORD *)(a1 + 112) = v4;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  result = sub_654EFA4(v3);
  v6 = v9;
  if ( v9 )
  {
    if ( v10 != v9 )
    {
      v7 = v10;
      do
      {
        v8 = *(_BYTE *)(v7 - 24);
        v7 -= 24LL;
        if ( (v8 & 1) != 0 )
          sub_6575460();
      }
      while ( v7 != v6 );
    }
    v10 = v6;
    return sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_3D38DAC (0x3D38DAC)
================================================================================

__int64 __fastcall sub_3D38DAC(unsigned __int8 *a1)
{
  unsigned __int64 v2; // x12
  char *v3; // x21
  size_t v4; // x20
  unsigned __int8 *v5; // x0
  unsigned __int64 v6; // x1
  char *v7; // x6
  size_t v8; // x7
  __int64 result; // x0
  __int64 v10; // [xsp+10h] [xbp-D0h] BYREF
  _QWORD v11[2]; // [xsp+28h] [xbp-B8h] BYREF
  __int64 v12; // [xsp+38h] [xbp-A8h]
  _QWORD v13[3]; // [xsp+40h] [xbp-A0h] BYREF
  __int64 v14[2]; // [xsp+58h] [xbp-88h] BYREF
  char v15; // [xsp+70h] [xbp-70h]
  char v16; // [xsp+88h] [xbp-58h]
  char v17; // [xsp+A0h] [xbp-40h]
  char v18; // [xsp+B8h] [xbp-28h]

  sub_6429A24(v13);
  v2 = *a1;
  if ( (v13[0] & 1) != 0 )
    v3 = (char *)v13[2];
  else
    v3 = (char *)v13 + 1;
  if ( (v13[0] & 1) != 0 )
    v4 = v13[1];
  else
    v4 = (unsigned __int64)LOBYTE(v13[0]) >> 1;
  if ( (v2 & 1) != 0 )
    v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  else
    v5 = a1 + 1;
  if ( (v2 & 1) != 0 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v2 >> 1;
  sub_6517F8C(&v10, v5, v6);
  sub_6579D18("apiKey=%s", v11);
  if ( (v11[0] & 1) != 0 )
    LODWORD(v7) = v12;
  else
    v7 = (char *)v11 + 1;
  if ( (v11[0] & 1) != 0 )
    v8 = v11[1];
  else
    v8 = (unsigned __int64)LOBYTE(v11[0]) >> 1;
  sub_651925C(
    v14,
    "https",
    5uLL,
    v3,
    v4,
    "/v1.0/SequenceStatistics/BatchAddToSequencesV2",
    0x2EuLL,
    (int)v7,
    v8,
    &byte_CBCB6C,
    0LL);
  result = sub_65197D4(v14);
  if ( (v18 & 1) != 0 )
  {
    result = sub_6575460();
    if ( (v17 & 1) == 0 )
    {
LABEL_21:
      if ( (v16 & 1) == 0 )
        goto LABEL_22;
      goto LABEL_31;
    }
  }
  else if ( (v17 & 1) == 0 )
  {
    goto LABEL_21;
  }
  result = sub_6575460();
  if ( (v16 & 1) == 0 )
  {
LABEL_22:
    if ( (v15 & 1) == 0 )
      goto LABEL_23;
    goto LABEL_32;
  }
LABEL_31:
  result = sub_6575460();
  if ( (v15 & 1) == 0 )
  {
LABEL_23:
    if ( (v14[0] & 1) == 0 )
      goto LABEL_24;
    goto LABEL_33;
  }
LABEL_32:
  result = sub_6575460();
  if ( (v14[0] & 1) == 0 )
  {
LABEL_24:
    if ( (v11[0] & 1) == 0 )
      goto LABEL_25;
    goto LABEL_34;
  }
LABEL_33:
  result = sub_6575460();
  if ( (v11[0] & 1) == 0 )
  {
LABEL_25:
    if ( (v10 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_35;
  }
LABEL_34:
  result = sub_6575460();
  if ( (v10 & 1) == 0 )
  {
LABEL_26:
    if ( (v13[0] & 1) == 0 )
      return result;
    return sub_6575460();
  }
LABEL_35:
  result = sub_6575460();
  if ( (v13[0] & 1) == 0 )
    return result;
  return sub_6575460();
}


================================================================================
Function: sub_3D39018 (0x3D39018)
================================================================================

__int64 __fastcall sub_3D39018(unsigned __int8 *a1)
{
  unsigned __int64 v2; // x12
  char *v3; // x21
  size_t v4; // x20
  unsigned __int8 *v5; // x0
  unsigned __int64 v6; // x1
  char *v7; // x6
  size_t v8; // x7
  __int64 result; // x0
  __int64 v10; // [xsp+10h] [xbp-D0h] BYREF
  _QWORD v11[2]; // [xsp+28h] [xbp-B8h] BYREF
  __int64 v12; // [xsp+38h] [xbp-A8h]
  _QWORD v13[3]; // [xsp+40h] [xbp-A0h] BYREF
  __int64 v14[2]; // [xsp+58h] [xbp-88h] BYREF
  char v15; // [xsp+70h] [xbp-70h]
  char v16; // [xsp+88h] [xbp-58h]
  char v17; // [xsp+A0h] [xbp-40h]
  char v18; // [xsp+B8h] [xbp-28h]

  sub_6429A24(v13);
  v2 = *a1;
  if ( (v13[0] & 1) != 0 )
    v3 = (char *)v13[2];
  else
    v3 = (char *)v13 + 1;
  if ( (v13[0] & 1) != 0 )
    v4 = v13[1];
  else
    v4 = (unsigned __int64)LOBYTE(v13[0]) >> 1;
  if ( (v2 & 1) != 0 )
    v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  else
    v5 = a1 + 1;
  if ( (v2 & 1) != 0 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v2 >> 1;
  sub_6517F8C(&v10, v5, v6);
  sub_6579D18("apiKey=%s", v11);
  if ( (v11[0] & 1) != 0 )
    LODWORD(v7) = v12;
  else
    v7 = (char *)v11 + 1;
  if ( (v11[0] & 1) != 0 )
    v8 = v11[1];
  else
    v8 = (unsigned __int64)LOBYTE(v11[0]) >> 1;
  sub_651925C(v14, "https", 5uLL, v3, v4, "/v1.1/Counters/BatchIncrement", 0x1DuLL, (int)v7, v8, &byte_CBCB6C, 0LL);
  result = sub_65197D4(v14);
  if ( (v18 & 1) != 0 )
  {
    result = sub_6575460();
    if ( (v17 & 1) == 0 )
    {
LABEL_21:
      if ( (v16 & 1) == 0 )
        goto LABEL_22;
      goto LABEL_31;
    }
  }
  else if ( (v17 & 1) == 0 )
  {
    goto LABEL_21;
  }
  result = sub_6575460();
  if ( (v16 & 1) == 0 )
  {
LABEL_22:
    if ( (v15 & 1) == 0 )
      goto LABEL_23;
    goto LABEL_32;
  }
LABEL_31:
  result = sub_6575460();
  if ( (v15 & 1) == 0 )
  {
LABEL_23:
    if ( (v14[0] & 1) == 0 )
      goto LABEL_24;
    goto LABEL_33;
  }
LABEL_32:
  result = sub_6575460();
  if ( (v14[0] & 1) == 0 )
  {
LABEL_24:
    if ( (v11[0] & 1) == 0 )
      goto LABEL_25;
    goto LABEL_34;
  }
LABEL_33:
  result = sub_6575460();
  if ( (v11[0] & 1) == 0 )
  {
LABEL_25:
    if ( (v10 & 1) == 0 )
      goto LABEL_26;
    goto LABEL_35;
  }
LABEL_34:
  result = sub_6575460();
  if ( (v10 & 1) == 0 )
  {
LABEL_26:
    if ( (v13[0] & 1) == 0 )
      return result;
    return sub_6575460();
  }
LABEL_35:
  result = sub_6575460();
  if ( (v13[0] & 1) == 0 )
    return result;
  return sub_6575460();
}


================================================================================
Function: sub_45DE50C (0x45DE50C)
================================================================================

bool __fastcall sub_45DE50C(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3)
{
  __int64 v5; // x2
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x11
  bool v8; // zf
  unsigned __int64 v9; // x8
  unsigned __int8 *v10; // x27
  unsigned __int64 v11; // x24
  unsigned __int8 *v12; // x25
  unsigned __int64 v13; // x26
  unsigned __int64 v14; // x23
  unsigned __int64 v15; // x22
  unsigned __int8 *v16; // x28
  unsigned int v17; // w20
  __int64 *v18; // x0
  unsigned int v19; // w21
  __int64 v20; // x2
  __int64 *v21; // x0
  unsigned __int64 v22; // x9
  _BOOL4 v23; // w19
  unsigned __int8 *v25; // [xsp+8h] [xbp-18h]
  __int64 v26; // [xsp+10h] [xbp-10h] BYREF

  sub_67C4814(&v26, a3);
  v6 = *a1;
  v7 = *a2;
  v8 = (v6 & 1) == 0;
  v9 = v6 >> 1;
  if ( v8 )
    v10 = a1 + 1;
  else
    v10 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( v8 )
    v11 = v9;
  else
    v11 = *((_QWORD *)a1 + 1);
  if ( (v7 & 1) != 0 )
    v12 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v12 = a2 + 1;
  if ( (v7 & 1) != 0 )
    v13 = *((_QWORD *)a2 + 1);
  else
    v13 = v7 >> 1;
  v25 = v10;
  if ( v11 && v13 )
  {
    v14 = v13 - 1;
    v15 = v11 - 1;
    v16 = v12;
    while ( 1 )
    {
      v17 = *v10;
      v18 = sub_67C4BB8(&v26, (__int64)&qword_795CE58, v5);
      LOBYTE(v17) = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*v18 + 24))(v18, v17);
      v19 = *v16;
      v21 = sub_67C4BB8(&v26, (__int64)&qword_795CE58, v20);
      if ( (unsigned __int8)v17 != (*(unsigned __int8 (__fastcall **)(__int64 *, _QWORD))(*v21 + 24))(v21, v19) )
        break;
      ++v10;
      ++v16;
      if ( v15 )
      {
        v22 = v14;
        --v15;
        --v14;
        if ( v22 )
          continue;
      }
      goto LABEL_21;
    }
    v23 = 0;
  }
  else
  {
    v16 = v12;
LABEL_21:
    v23 = v16 == &v12[v13] && v10 == &v25[v11];
  }
  sub_67C482C(&v26);
  return v23;
}


================================================================================
Function: sub_45FAF9C (0x45FAF9C)
================================================================================

unsigned __int64 *__fastcall sub_45FAF9C(__int64 a1, __int64 a2)
{
  _QWORD *i; // x23

  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_67D2788((unsigned __int64 *)(a1 + 16), (__int128 *)(a2 + 16));
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  sub_250E5AC(a1 + 40, *(_QWORD *)(a2 + 48));
  for ( i = *(_QWORD **)(a2 + 56); i; i = (_QWORD *)*i )
    sub_2590CA4(a1 + 40, i + 2, i + 2);
  return sub_67D2788((unsigned __int64 *)(a1 + 80), (__int128 *)(a2 + 80));
}


================================================================================
Function: sub_51DBA88 (0x51DBA88)
================================================================================

__int64 __fastcall sub_51DBA88(__int64 result, char *a2, char *a3)
{
  __int64 v3; // x8
  unsigned __int64 v5; // x1
  unsigned __int64 v7; // x8
  __int64 *v8; // x20
  __int64 v9; // x8
  _QWORD *v10; // x22
  _QWORD *v11; // x9
  char *v12; // x10
  __int64 v13; // x9
  unsigned __int64 v14; // x10
  _QWORD *v15; // x11
  __int64 v16; // x10

  v3 = (a3 - a2) >> 4;
  v5 = *(_QWORD *)(result + 8);
  v7 = *(_QWORD *)(result + 24) - 0x5555555555555555LL * v3;
  v8 = (__int64 *)result;
  if ( v7 > v5 )
  {
    do
    {
      if ( v5 )
        v5 = (3 * v5) >> 1;
      else
        v5 = 4LL;
    }
    while ( v5 < v7 );
    result = sub_51DBB9C(result);
  }
  if ( a2 != a3 )
  {
    v9 = v8[3];
    v10 = a2 + 32;
    do
    {
      v13 = *v8;
      v14 = (v8[2] + v9) % (unsigned __int64)v8[1];
      v15 = (_QWORD *)*v10;
      if ( *v10 )
      {
        if ( v10 - 4 == v15 )
        {
          *(_QWORD *)(v13 + 48 * v14 + 32) = v13 + 48 * v14;
          result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v10 + 24LL))(*v10);
          v9 = v8[3];
          goto LABEL_11;
        }
        v16 = v13 + 48 * v14;
        v11 = v10;
        *(_QWORD *)(v16 + 32) = v15;
      }
      else
      {
        v11 = (_QWORD *)(v13 + 48 * v14 + 32);
      }
      *v11 = 0LL;
LABEL_11:
      ++v9;
      v12 = (char *)(v10 + 2);
      v10 += 6;
      v8[3] = v9;
    }
    while ( v12 != a3 );
  }
  return result;
}


================================================================================
Function: sub_51DBB9C (0x51DBB9C)
================================================================================

__int64 __fastcall sub_51DBB9C(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // x21
  unsigned __int64 v7; // x22
  _QWORD *v8; // x23
  __int64 v9; // x8
  __int64 v10; // x25
  __int64 v11; // x8
  _QWORD *v12; // x26
  _QWORD *v13; // x9
  _QWORD *v14; // x0
  __int64 result; // x0

  if ( is_mul_ok(a2, 0x30uLL) )
    v4 = 48 * a2;
  else
    v4 = -1LL;
  v5 = sub_6577314(v4);
  v6 = v5;
  if ( a1[3] )
  {
    v7 = 0LL;
    v8 = (_QWORD *)(v5 + 32);
    while ( 1 )
    {
      v10 = *a1 + 48 * ((v7 + a1[2]) % a1[1]);
      v12 = (_QWORD *)(v10 + 32);
      v11 = *(_QWORD *)(v10 + 32);
      if ( !v11 )
        break;
      if ( v10 != v11 )
      {
        v13 = (_QWORD *)(v10 + 32);
        *v8 = v11;
LABEL_13:
        *v13 = 0LL;
        goto LABEL_15;
      }
      *v8 = v8 - 4;
      (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)*v12 + 24LL))(*v12, v8 - 4);
LABEL_15:
      v14 = (_QWORD *)*v12;
      if ( v10 == *v12 )
      {
        v9 = 4LL;
      }
      else
      {
        if ( !v14 )
          goto LABEL_8;
        v9 = 5LL;
      }
      (*(void (**)(void))(*v14 + 8 * v9))();
LABEL_8:
      ++v7;
      v8 += 6;
      if ( v7 >= a1[3] )
        goto LABEL_18;
    }
    v13 = v8;
    goto LABEL_13;
  }
LABEL_18:
  result = *a1;
  if ( *a1 )
    result = sub_657738C();
  a1[1] = a2;
  a1[2] = 0LL;
  *a1 = v6;
  return result;
}


================================================================================
Function: sub_52F2BBC (0x52F2BBC)
================================================================================

unsigned __int64 *__fastcall sub_52F2BBC(unsigned __int64 *a1, char *src, char *a3)
{
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x10
  size_t v7; // x22
  unsigned __int64 v8; // x1
  size_t v9; // x21
  unsigned __int64 v10; // x8
  unsigned __int64 v12; // x10
  char *v13; // x22
  char *v14; // x11
  char *v15; // x8
  char *v16; // x9
  char *v17; // x1
  size_t v18; // x2
  __int128 *v19; // x12
  char *v20; // x11
  unsigned __int64 v21; // x13
  __int128 v22; // q0
  __int128 v23; // q1
  char v24; // t1
  size_t v25; // x8
  unsigned __int64 v27; // [xsp+0h] [xbp-20h] BYREF
  size_t v28; // [xsp+8h] [xbp-18h]
  char *v29; // [xsp+10h] [xbp-10h]

  v5 = *a1;
  v6 = *(unsigned __int8 *)a1;
  if ( (v6 & 1) != 0 )
    v7 = a1[1];
  else
    v7 = v6 >> 1;
  if ( (v6 & 1) != 0 )
    v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v8 = 22LL;
  v9 = a3 - src;
  if ( a3 == src )
    return a1;
  v10 = a1[2];
  if ( (v6 & 1) != 0 )
    v12 = a1[2];
  else
    v12 = (unsigned __int64)a1 + 1;
  if ( v12 > (unsigned __int64)src || v12 + v7 <= (unsigned __int64)src )
  {
    if ( v8 - v7 < v9 )
    {
      sub_67D29A8((__int64)a1, v8, v7 + v9 - v8, v7, v7, 0LL, 0LL);
      LOBYTE(v5) = *(_BYTE *)a1;
      v10 = a1[2];
    }
    if ( (v5 & 1) != 0 )
      v14 = (char *)v10;
    else
      v14 = (char *)a1 + 1;
    v15 = &v14[v7];
    if ( src == a3 )
      goto LABEL_42;
    if ( v9 >= 0x20 )
    {
      if ( v15 >= a3 || &v14[&a3[v7] - src] <= src )
      {
        v15 += v9 & 0xFFFFFFFFFFFFFFE0LL;
        v16 = &src[v9 & 0xFFFFFFFFFFFFFFE0LL];
        v19 = (__int128 *)(src + 16);
        v20 = &v14[v7 + 16];
        v21 = v9 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v22 = *(v19 - 1);
          v23 = *v19;
          v19 += 2;
          v21 -= 32LL;
          *((_OWORD *)v20 - 1) = v22;
          *(_OWORD *)v20 = v23;
          v20 += 32;
        }
        while ( v21 );
        if ( v9 == (v9 & 0xFFFFFFFFFFFFFFE0LL) )
          goto LABEL_42;
      }
      else
      {
        v16 = src;
      }
    }
    else
    {
      v16 = src;
    }
    do
    {
      v24 = *v16++;
      *v15++ = v24;
    }
    while ( v16 != a3 );
LABEL_42:
    *v15 = 0;
    v25 = v7 + v9;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v25;
    else
      *(_BYTE *)a1 = 2 * v25;
    return a1;
  }
  if ( v9 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( v9 <= 0x16 )
  {
    v13 = (char *)&v27 + 1;
    LOBYTE(v27) = 2 * v9;
    if ( src == a3 )
      goto LABEL_27;
    goto LABEL_26;
  }
  v13 = (char *)sub_6575418();
  v28 = v9;
  v29 = v13;
  v27 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  if ( src != a3 )
  {
LABEL_26:
    memcpy(v13, src, v9);
    v13 += v9;
  }
LABEL_27:
  *v13 = 0;
  if ( (v27 & 1) != 0 )
    v17 = v29;
  else
    v17 = (char *)&v27 + 1;
  if ( (v27 & 1) != 0 )
    v18 = v28;
  else
    v18 = (unsigned __int64)(unsigned __int8)v27 >> 1;
  sub_6588400(a1, v17, v18);
  if ( (v27 & 1) != 0 )
    sub_6575460();
  return a1;
}


================================================================================
Function: sub_536FEF8 (0x536FEF8)
================================================================================

__int64 __fastcall sub_536FEF8(__int64 a1, char a2, unsigned int *a3, __int64 a4)
{
  __int64 v5; // x20
  int v6; // w8
  unsigned int v7; // w8
  unsigned __int64 v8; // x9
  __int16 v10; // w9
  _BYTE *v11; // x19
  char v12; // w8
  unsigned __int64 v13; // x24
  unsigned __int64 v14; // x22
  __int64 v15; // x8
  __int64 v16; // x22
  __int64 v17; // x1
  __int64 v18; // x9
  __int64 v19; // [xsp+0h] [xbp-10h] BYREF

  v5 = a1;
  v6 = *((unsigned __int8 *)a3 + 8);
  if ( (unsigned int)(v6 - 1) >= 6 )
  {
    if ( *((_BYTE *)a3 + 8) && v6 != 15 )
      sub_67900C8(&v19, "invalid type specifier");
    v10 = *(_WORD *)((char *)a3 + 9);
    if ( (v10 & 0xF) == 4 || (v10 & 0x70) != 0 || (v10 & 0x80) != 0 )
      sub_67900C8(&v19, "invalid format specifier for char");
    v11 = (char *)a3 + 11;
    v12 = byte_1017AE9[v10 & 0xF];
    if ( *a3 )
      v13 = *a3 - 1LL;
    else
      v13 = 0LL;
    v14 = v13 >> v12;
    if ( v13 >> v12 )
      v5 = sub_24EFF44(a1, v13 >> v12, v11);
    v15 = *(_QWORD *)(v5 + 16);
    v16 = v13 - v14;
    v17 = v15 + 1;
    if ( *(_QWORD *)(v5 + 24) < (unsigned __int64)(v15 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v5)(v5);
      v15 = *(_QWORD *)(v5 + 16);
      v17 = v15 + 1;
    }
    v18 = *(_QWORD *)(v5 + 8);
    *(_QWORD *)(v5 + 16) = v17;
    *(_BYTE *)(v18 + v15) = a2;
    if ( v16 )
      return sub_24EFF44(v5, v16, v11);
    else
      return v5;
  }
  else
  {
    v7 = a2;
    if ( a2 < 0 )
    {
      v7 = -a2;
      v8 = 0x100002D00000000LL;
    }
    else
    {
      v8 = (unsigned __int64)dword_AF83F0[((unsigned __int64)*(unsigned __int16 *)((char *)a3 + 9) >> 4) & 7] << 32;
    }
    return sub_53700C0(a1, v8 | v7, a3, a4);
  }
}


================================================================================
Function: sub_53700C0 (0x53700C0)
================================================================================

__int64 __fastcall sub_53700C0(__int64 a1, unsigned __int64 a2, unsigned int *a3, __int64 a4)
{
  int v4; // w23
  unsigned int v6; // w20
  __int64 v7; // x19
  unsigned __int64 v8; // x21
  __int16 v9; // w10
  unsigned __int64 v10; // x8
  unsigned int v11; // w12
  __int64 v12; // x23
  unsigned __int64 v13; // x11
  unsigned __int64 v14; // x23
  unsigned __int64 v15; // x9
  unsigned int v16; // w10
  unsigned __int64 v17; // x11
  __int16 v18; // w10
  int v19; // w8
  unsigned __int64 v20; // x8
  int v21; // w11
  __int64 v22; // x25
  unsigned int v23; // w10
  unsigned __int64 v24; // x9
  unsigned __int64 v25; // x11
  bool v26; // cc
  unsigned __int64 v27; // x26
  __int16 v28; // w11
  int v29; // w8
  unsigned __int64 v30; // x8
  int v31; // w12
  __int64 v32; // x25
  unsigned __int64 v33; // x10
  unsigned int v34; // w11
  unsigned __int64 v35; // x12
  __int16 v36; // w11
  int v37; // w9
  __int64 v38; // x25
  int v40; // w8
  unsigned __int64 v41; // x8
  unsigned int v42; // w11
  unsigned __int64 v43; // x10
  unsigned __int64 v44; // x9
  bool v45; // cc
  unsigned __int64 v46; // x26
  __int64 v47; // x9
  bool v48; // cf
  unsigned __int64 v49; // x9
  unsigned __int64 v50; // x25
  char v51; // w8
  unsigned __int64 v52; // x23
  __int64 v53; // x8
  __int64 v54; // x1
  __int64 v55; // x9
  unsigned int v57; // w21
  __int64 v58; // x8
  __int64 v59; // x10
  _BYTE *v60; // x8
  char v61; // w10
  __int64 v62; // x9
  __int64 v63; // x8
  __int64 v64; // x1
  unsigned int v65; // w21
  __int64 v66; // x8
  __int64 v67; // x9
  __int64 v68; // x9
  const char *v69; // x8
  _BYTE *v70; // x9
  __int64 v71; // x10
  __int64 v72; // x9
  __int64 v73; // x8
  __int64 v74; // x1
  char *v75; // x1
  char *v76; // x8
  char v77; // w10
  const char *v78; // x8
  char *v79; // x9
  __int64 v80; // x10
  unsigned int v81; // w21
  __int64 v82; // x8
  __int64 v83; // x10
  _BYTE *v84; // x8
  char v85; // w10
  __int64 v86; // x9
  __int64 v87; // x8
  __int64 v88; // x1
  unsigned int v89; // w21
  char *v90; // x8
  unsigned int v91; // w14
  unsigned int v92; // w9
  unsigned int v93; // w13
  __int64 v94; // x9
  __int64 v95; // x8
  __int64 v96; // x1
  unsigned __int64 v97; // x8
  unsigned __int64 v98; // x27
  _BYTE *v99; // x22
  char v100; // w10
  unsigned __int64 v101; // x23
  unsigned int v102; // w21
  __int64 v103; // x9
  __int64 v104; // x8
  __int64 v105; // x1
  __int64 v106; // x9
  __int64 v107; // x8
  __int64 v108; // x1
  __int64 v109; // x8
  __int64 v110; // x21
  __int64 v111; // x10
  _BYTE *v112; // x8
  char v113; // w10
  char *v114; // x1
  char *v115; // x8
  char v116; // w10
  bool v117; // vf
  _BYTE *v118; // x20
  char v119; // w11
  unsigned __int64 v120; // x8
  __int64 v121; // x21
  char *v122; // x8
  char v123; // w10
  unsigned __int64 v125; // x8
  unsigned __int64 v126; // x27
  char v127; // w9
  unsigned __int64 v128; // x23
  unsigned int v129; // w21
  __int64 v130; // x9
  __int64 v131; // x8
  __int64 v132; // x1
  __int64 v133; // x9
  __int64 v134; // x8
  __int64 v135; // x1
  __int64 v136; // x8
  __int64 v137; // x10
  _BYTE *v138; // x8
  char v139; // w10
  char *v140; // x8
  char v141; // w10
  __int64 v142; // x0
  __int64 v143; // x1
  _BYTE *v144; // x2
  unsigned __int64 v145; // x8
  char v146; // w10
  _DWORD v147[2]; // [xsp+0h] [xbp-30h] BYREF
  unsigned __int64 v148; // [xsp+8h] [xbp-28h]
  unsigned __int64 v149; // [xsp+10h] [xbp-20h]
  unsigned __int64 v150; // [xsp+18h] [xbp-18h]
  bool v151; // [xsp+20h] [xbp-10h]

  v4 = *((unsigned __int8 *)a3 + 8);
  v6 = a2;
  v7 = a1;
  v8 = HIDWORD(a2);
  switch ( *((_BYTE *)a3 + 8) )
  {
    case 0:
    case 1:
      v9 = *(_WORD *)((char *)a3 + 9);
      if ( (v9 & 0x100) != 0 )
      {
        sub_5370BA8((__int64)v147, a4, 1);
        v7 = sub_5370CA8(v7, v6, (unsigned int)v8, a3, v147);
        if ( (v147[0] & 1) != 0 )
          sub_6575460();
        return v7;
      }
      v10 = *a3;
      v11 = a3[1];
      v12 = qword_1017C38[__clz(a2 | 1) ^ 0x1F] + (unsigned int)a2;
      if ( !((v11 + 1) | (unsigned int)v10) )
      {
        if ( HIDWORD(a2) )
        {
          v89 = HIDWORD(a2) & 0xFFFFFF;
          if ( (a2 & 0xFFFFFF00000000LL) != 0 )
          {
            do
            {
              v95 = *(_QWORD *)(v7 + 16);
              v96 = v95 + 1;
              if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v95 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v7)(v7);
                v95 = *(_QWORD *)(v7 + 16);
                v96 = v95 + 1;
              }
              v94 = *(_QWORD *)(v7 + 8);
              *(_QWORD *)(v7 + 16) = v96;
              v26 = v89 > 0xFF;
              *(_BYTE *)(v94 + v95) = v89;
              v89 >>= 8;
            }
            while ( v26 );
          }
        }
        v75 = (char *)v147 + (v12 >> 32);
        if ( v6 < 0x64 )
        {
          v90 = (char *)v147 + (v12 >> 32);
          v92 = v6;
          if ( v6 <= 9 )
          {
LABEL_117:
            *(v90 - 1) = v92 + 48;
            return sub_53712B8((unsigned __int64)v147, (__int64)v75, v7);
          }
        }
        else
        {
          v90 = (char *)v147 + (v12 >> 32);
          do
          {
            v91 = v6 >> 4;
            v92 = v6 / 0x64;
            v93 = v6 % 0x64;
            v6 /= 0x64u;
            *((_WORD *)v90 - 1) = *(_WORD *)&a00010203040506_1[2 * v93];
            v90 -= 2;
          }
          while ( v91 > 0x270 );
          if ( v92 <= 9 )
            goto LABEL_117;
        }
        *((_WORD *)v90 - 1) = *(_WORD *)&a00010203040506_1[2 * v92];
        return sub_53712B8((unsigned __int64)v147, (__int64)v75, v7);
      }
      v13 = HIDWORD(v12);
      v14 = v12 & 0xFFFFFFFF00000000LL | (unsigned int)a2;
      v15 = (unsigned int)(HIBYTE(HIDWORD(a2)) + v13);
      v16 = v9 & 0xF;
      if ( v16 == 4 )
      {
        v17 = v10 - v15;
        if ( (unsigned int)v10 > (unsigned int)v15 )
        {
          v15 = (unsigned int)v10;
        }
        else
        {
          v17 = 0LL;
          v15 = (unsigned int)v15;
        }
      }
      else
      {
        v117 = __OFSUB__(v11, (_DWORD)v13);
        v17 = v11 - (unsigned int)v13;
        if ( ((v17 & 0x80000000) != 0LL) ^ v117 | ((_DWORD)v17 == 0) )
          v17 = 0LL;
        else
          v15 = v11 + HIBYTE(HIDWORD(a2));
      }
      v48 = v10 >= v15;
      v145 = v10 - v15;
      if ( !v48 )
        v145 = 0LL;
      v147[0] = HIDWORD(a2);
      v118 = (char *)a3 + 11;
      v146 = byte_1017BD8[v16];
      v148 = v15;
      v149 = v17;
      v150 = v14;
      v121 = v145 - (v145 >> v146);
      if ( v145 >> v146 )
        v7 = sub_24EFF44(a1, v145 >> v146, (_BYTE *)a3 + 11);
      v7 = sub_5371438(v147, v7);
      if ( !v121 )
        return v7;
LABEL_195:
      v142 = v7;
      v143 = v121;
      v144 = v118;
      return sub_24EFF44(v142, v143, v144);
    case 2:
      v36 = *(_WORD *)((char *)a3 + 9);
      v37 = a3[1];
      v38 = (__clz(a2 | 1) ^ 0x1F) / 3 + 1;
      if ( (v36 & 0x80) != 0 && v37 <= (int)v38 && (_DWORD)a2 != 0 )
      {
        if ( HIDWORD(a2) )
          v40 = 12288;
        else
          v40 = 48;
        LODWORD(v8) = (v40 | HIDWORD(a2)) + 0x1000000;
      }
      v41 = *a3;
      if ( (unsigned int)v41 | (v37 + 1) )
      {
        v42 = v36 & 0xF;
        v43 = BYTE3(v8) + (unsigned int)v38;
        if ( v42 == 4 )
        {
          v44 = v41 - v43;
          v45 = (unsigned int)v41 > (unsigned int)v43;
          if ( (unsigned int)v41 <= (unsigned int)v43 )
            v43 = (unsigned int)v43;
          else
            v43 = (unsigned int)v41;
          if ( v45 )
            v46 = v44;
          else
            v46 = 0LL;
        }
        else
        {
          v46 = (unsigned int)(v37 - v38);
          if ( v37 <= (int)v38 )
            v46 = 0LL;
          else
            v43 = BYTE3(v8) + v37;
        }
        v48 = v41 >= v43;
        v125 = v41 - v43;
        if ( v48 )
          v126 = v125;
        else
          v126 = 0LL;
        v99 = (char *)a3 + 11;
        v127 = byte_1017BD8[v42];
        v128 = v126 >> v127;
        if ( v126 >> v127 )
          v7 = sub_24EFF44(a1, v126 >> v127, (_BYTE *)a3 + 11);
        v129 = v8 & 0xFFFFFF;
        if ( v129 )
        {
          do
          {
            v131 = *(_QWORD *)(v7 + 16);
            v132 = v131 + 1;
            if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v131 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v7)(v7);
              v131 = *(_QWORD *)(v7 + 16);
              v132 = v131 + 1;
            }
            v130 = *(_QWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 16) = v132;
            v48 = v129 >= 0x100;
            *(_BYTE *)(v130 + v131) = v129;
            v129 >>= 8;
          }
          while ( v48 );
        }
        for ( ; v46; *(_BYTE *)(v133 + v134) = 48 )
        {
          v134 = *(_QWORD *)(v7 + 16);
          v135 = v134 + 1;
          if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v134 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v7)(v7);
            v134 = *(_QWORD *)(v7 + 16);
            v135 = v134 + 1;
          }
          --v46;
          v133 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v135;
        }
        v136 = *(_QWORD *)(v7 + 16);
        v110 = v126 - v128;
        if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v136 + v38) )
        {
          v137 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v136 + v38;
          if ( v137 )
          {
            v138 = (_BYTE *)(v38 + v136 + v137 - 1);
            do
            {
              v139 = v6 & 7 | 0x30;
              v48 = v6 >= 8;
              v6 >>= 3;
              *v138-- = v139;
            }
            while ( v48 );
            goto LABEL_187;
          }
        }
        v114 = (char *)v147 + v38;
        v140 = (char *)&v147[-1] + v38 + 3;
        do
        {
          v141 = v6 & 7 | 0x30;
          v26 = v6 > 7;
          v6 >>= 3;
          *v140-- = v141;
        }
        while ( v26 );
        goto LABEL_186;
      }
      if ( (_DWORD)v8 )
      {
        v81 = v8 & 0xFFFFFF;
        if ( v81 )
        {
          do
          {
            v87 = *(_QWORD *)(v7 + 16);
            v88 = v87 + 1;
            if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v87 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v7)(v7);
              v87 = *(_QWORD *)(v7 + 16);
              v88 = v87 + 1;
            }
            v86 = *(_QWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 16) = v88;
            v26 = v81 > 0xFF;
            *(_BYTE *)(v86 + v87) = v81;
            v81 >>= 8;
          }
          while ( v26 );
        }
      }
      v82 = *(_QWORD *)(v7 + 16);
      if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v82 + v38) )
      {
        v83 = *(_QWORD *)(v7 + 8);
        *(_QWORD *)(v7 + 16) = v82 + v38;
        if ( v83 )
        {
          v84 = (_BYTE *)(v38 + v82 + v83 - 1);
          do
          {
            v85 = v6 & 7 | 0x30;
            v48 = v6 >= 8;
            v6 >>= 3;
            *v84-- = v85;
          }
          while ( v48 );
          return v7;
        }
      }
      v75 = (char *)v147 + v38;
      v122 = (char *)&v147[-1] + v38 + 3;
      do
      {
        v123 = v6 & 7 | 0x30;
        v26 = v6 > 7;
        v6 >>= 3;
        *v122-- = v123;
      }
      while ( v26 );
      return sub_53712B8((unsigned __int64)v147, (__int64)v75, v7);
    case 3:
    case 4:
      v28 = *(_WORD *)((char *)a3 + 9);
      if ( (v28 & 0x80) != 0 )
      {
        if ( v4 == 4 )
          v29 = 22576;
        else
          v29 = 30768;
        if ( HIDWORD(a2) )
          v29 <<= 8;
        LODWORD(v8) = (v29 | HIDWORD(a2)) + 0x2000000;
      }
      v30 = *a3;
      v31 = a3[1];
      v32 = 8 - (__clz(a2 | 1) >> 2);
      if ( !((v31 + 1) | (unsigned int)v30) )
      {
        if ( (_DWORD)v8 )
        {
          v65 = v8 & 0xFFFFFF;
          if ( v65 )
          {
            do
            {
              v73 = *(_QWORD *)(v7 + 16);
              v74 = v73 + 1;
              if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v73 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v7)(v7);
                v73 = *(_QWORD *)(v7 + 16);
                v74 = v73 + 1;
              }
              v72 = *(_QWORD *)(v7 + 8);
              *(_QWORD *)(v7 + 16) = v74;
              v26 = v65 > 0xFF;
              *(_BYTE *)(v72 + v73) = v65;
              v65 >>= 8;
            }
            while ( v26 );
          }
        }
        v66 = *(_QWORD *)(v7 + 16);
        if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v66 + v32) )
        {
          v67 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v66 + v32;
          if ( v67 )
          {
            v68 = v66 + v32 + v67;
            if ( v4 == 4 )
              v69 = "0123456789ABCDEF";
            else
              v69 = "0123456789abcdef";
            v70 = (_BYTE *)(v68 - 1);
            do
            {
              v71 = v6 & 0xF;
              v48 = v6 >= 0x10;
              v6 >>= 4;
              *v70-- = v69[v71];
            }
            while ( v48 );
            return v7;
          }
        }
        v78 = "0123456789abcdef";
        v75 = (char *)v147 + v32;
        if ( v4 == 4 )
          v78 = "0123456789ABCDEF";
        v79 = v75 - 1;
        do
        {
          v80 = v6 & 0xF;
          v26 = v6 > 0xF;
          v6 >>= 4;
          *v79-- = v78[v80];
        }
        while ( v26 );
        return sub_53712B8((unsigned __int64)v147, (__int64)v75, v7);
      }
      v33 = BYTE3(v8) + (unsigned int)v32;
      v34 = v28 & 0xF;
      if ( v34 == 4 )
      {
        v35 = v30 - v33;
        if ( (unsigned int)v30 > (unsigned int)v33 )
        {
          v33 = (unsigned int)v30;
        }
        else
        {
          v35 = 0LL;
          v33 = (unsigned int)v33;
        }
      }
      else if ( v31 <= (int)v32 )
      {
        v35 = 0LL;
      }
      else
      {
        v33 = v31 + BYTE3(v8);
        v35 = (unsigned int)(v31 - v32);
      }
      v147[0] = v8;
      v118 = (char *)a3 + 11;
      v148 = v33;
      v149 = v35;
      v119 = byte_1017BD8[v34];
      v48 = v30 >= v33;
      v120 = v30 - v33;
      v150 = (unsigned int)a2 | ((unsigned __int64)(v32 & 0xF) << 32);
      if ( !v48 )
        v120 = 0LL;
      v151 = v4 == 4;
      v121 = v120 - (v120 >> v119);
      if ( v120 >> v119 )
        v7 = sub_24EFF44(a1, v120 >> v119, (_BYTE *)a3 + 11);
      v7 = sub_53715C4(v147, v7);
      if ( v121 )
        goto LABEL_195;
      return v7;
    case 5:
    case 6:
      v18 = *(_WORD *)((char *)a3 + 9);
      if ( (v18 & 0x80) != 0 )
      {
        if ( v4 == 6 )
          v19 = 16944;
        else
          v19 = 25136;
        if ( HIDWORD(a2) )
          v19 <<= 8;
        LODWORD(v8) = (v19 | HIDWORD(a2)) + 0x2000000;
      }
      v20 = *a3;
      v21 = a3[1];
      v22 = 32 - __clz(a2 | 1);
      if ( (v21 + 1) | (unsigned int)v20 )
      {
        v23 = v18 & 0xF;
        v24 = BYTE3(v8) + (unsigned int)v22;
        if ( v23 == 4 )
        {
          v25 = v20 - v24;
          v26 = (unsigned int)v20 > (unsigned int)v24;
          if ( (unsigned int)v20 <= (unsigned int)v24 )
            v24 = (unsigned int)v24;
          else
            v24 = (unsigned int)v20;
          if ( v26 )
            v27 = v25;
          else
            v27 = 0LL;
        }
        else if ( v21 <= (int)v22 )
        {
          v27 = 0LL;
        }
        else
        {
          v24 = v21 + BYTE3(v8);
          v27 = (unsigned int)(v21 - v22);
        }
        v48 = v20 >= v24;
        v97 = v20 - v24;
        if ( v48 )
          v98 = v97;
        else
          v98 = 0LL;
        v99 = (char *)a3 + 11;
        v100 = byte_1017BD8[v23];
        v101 = v98 >> v100;
        if ( v98 >> v100 )
          v7 = sub_24EFF44(a1, v98 >> v100, (_BYTE *)a3 + 11);
        v102 = v8 & 0xFFFFFF;
        if ( v102 )
        {
          do
          {
            v104 = *(_QWORD *)(v7 + 16);
            v105 = v104 + 1;
            if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v104 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v7)(v7);
              v104 = *(_QWORD *)(v7 + 16);
              v105 = v104 + 1;
            }
            v103 = *(_QWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 16) = v105;
            v48 = v102 >= 0x100;
            *(_BYTE *)(v103 + v104) = v102;
            v102 >>= 8;
          }
          while ( v48 );
        }
        for ( ; v27; *(_BYTE *)(v106 + v107) = 48 )
        {
          v107 = *(_QWORD *)(v7 + 16);
          v108 = v107 + 1;
          if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v107 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v7)(v7);
            v107 = *(_QWORD *)(v7 + 16);
            v108 = v107 + 1;
          }
          --v27;
          v106 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v108;
        }
        v109 = *(_QWORD *)(v7 + 16);
        v110 = v98 - v101;
        if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v109 + v22)
          && (v111 = *(_QWORD *)(v7 + 8), *(_QWORD *)(v7 + 16) = v109 + v22, v111) )
        {
          v112 = (_BYTE *)(v109 + v22 + v111 - 1);
          do
          {
            v113 = v6 & 1 | 0x30;
            v48 = v6 >= 2;
            v6 >>= 1;
            *v112-- = v113;
          }
          while ( v48 );
        }
        else
        {
          v114 = (char *)v147 + v22;
          v115 = (char *)&v147[-1] + v22 + 3;
          do
          {
            v116 = v6 & 1 | 0x30;
            v26 = v6 > 1;
            v6 >>= 1;
            *v115-- = v116;
          }
          while ( v26 );
LABEL_186:
          v7 = sub_53712B8((unsigned __int64)v147, (__int64)v114, v7);
        }
LABEL_187:
        if ( v110 )
        {
          v142 = v7;
          v143 = v110;
          v144 = v99;
          return sub_24EFF44(v142, v143, v144);
        }
        return v7;
      }
      if ( (_DWORD)v8 )
      {
        v57 = v8 & 0xFFFFFF;
        if ( v57 )
        {
          do
          {
            v63 = *(_QWORD *)(v7 + 16);
            v64 = v63 + 1;
            if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v63 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v7)(v7);
              v63 = *(_QWORD *)(v7 + 16);
              v64 = v63 + 1;
            }
            v62 = *(_QWORD *)(v7 + 8);
            *(_QWORD *)(v7 + 16) = v64;
            v26 = v57 > 0xFF;
            *(_BYTE *)(v62 + v63) = v57;
            v57 >>= 8;
          }
          while ( v26 );
        }
      }
      v58 = *(_QWORD *)(v7 + 16);
      if ( *(_QWORD *)(v7 + 24) >= (unsigned __int64)(v58 + v22) )
      {
        v59 = *(_QWORD *)(v7 + 8);
        *(_QWORD *)(v7 + 16) = v58 + v22;
        if ( v59 )
        {
          v60 = (_BYTE *)(v58 + v22 + v59 - 1);
          do
          {
            v61 = v6 & 1 | 0x30;
            v48 = v6 >= 2;
            v6 >>= 1;
            *v60-- = v61;
          }
          while ( v48 );
          return v7;
        }
      }
      v75 = (char *)v147 + v22;
      v76 = (char *)&v147[-1] + v22 + 3;
      do
      {
        v77 = v6 & 1 | 0x30;
        v26 = v6 > 1;
        v6 >>= 1;
        *v76-- = v77;
      }
      while ( v26 );
      return sub_53712B8((unsigned __int64)v147, (__int64)v75, v7);
    case 0xF:
      v47 = *a3;
      v48 = v47 != 0;
      v49 = v47 - 1;
      if ( v48 )
        v50 = v49;
      else
        v50 = 0LL;
      v51 = byte_1017AE9[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v52 = v50 >> v51;
      if ( v50 >> v51 )
        v7 = sub_24EFF44(a1, v50 >> v51, (_BYTE *)a3 + 11);
      v53 = *(_QWORD *)(v7 + 16);
      v54 = v53 + 1;
      if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v53 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v53 = *(_QWORD *)(v7 + 16);
        v54 = v53 + 1;
      }
      v55 = *(_QWORD *)(v7 + 8);
      *(_QWORD *)(v7 + 16) = v54;
      *(_BYTE *)(v55 + v53) = v6;
      if ( v50 == v52 )
        return v7;
      return sub_24EFF44(v7, v50 - v52, (_BYTE *)a3 + 11);
    default:
      sub_678FF08((__int64)"invalid type specifier");
  }
}


================================================================================
Function: sub_5370BA8 (0x5370BA8)
================================================================================

__int64 __fastcall sub_5370BA8(__int64 result, __int64 a2, char a3)
{
  __int64 v3; // x19
  __int64 v4; // x8
  char v5; // w9
  __int128 v6; // [xsp+8h] [xbp-48h] BYREF
  __int64 v7; // [xsp+18h] [xbp-38h]
  char v8; // [xsp+20h] [xbp-30h]
  __int128 v9; // [xsp+28h] [xbp-28h] BYREF
  char v10; // [xsp+40h] [xbp-10h]

  v3 = result;
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = 0LL;
  *(_QWORD *)(result + 16) = 0LL;
  if ( (a3 & 1) != 0 )
  {
    sub_6791320(&v9, a2);
    result = (__int64)sub_67D2788((unsigned __int64 *)&v6, &v9);
    v8 = v10;
    if ( (v9 & 1) != 0 )
      result = sub_6575460();
    if ( (*(_BYTE *)v3 & 1) != 0 )
      result = sub_6575460();
    v4 = v7;
    v5 = v8;
    *(_OWORD *)v3 = v6;
    *(_QWORD *)(v3 + 16) = v4;
    *(_BYTE *)(v3 + 24) = v5;
  }
  else
  {
    *(_BYTE *)(result + 24) = 0;
  }
  return result;
}


================================================================================
Function: sub_5370CA8 (0x5370CA8)
================================================================================

__int64 __fastcall sub_5370CA8(__int64 a1, unsigned __int64 a2, int a3, __int64 a4, unsigned __int8 *a5)
{
  unsigned __int64 v5; // x8
  __int64 v6; // x9
  _BYTE *v7; // x8
  bool v8; // cc
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x13
  unsigned __int64 v11; // x9
  bool v12; // zf
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x13
  int v15; // w9
  unsigned __int8 *v16; // x11
  int v17; // w10
  int v18; // w12
  unsigned __int8 *v19; // x13
  int v20; // w14
  _QWORD v22[4]; // [xsp+8h] [xbp-58h] BYREF
  int v23; // [xsp+28h] [xbp-38h] BYREF
  int v24; // [xsp+2Ch] [xbp-34h] BYREF
  _BYTE v25[40]; // [xsp+30h] [xbp-30h] BYREF

  v5 = byte_1017AEE[__clz(a2 | 1) ^ 0x3F];
  v6 = (__PAIR128__(v5, a2) - qword_1017B30[v5]) >> 64;
  v7 = &v25[v6];
  v23 = v6;
  v24 = a3;
  if ( a2 >= 0x64 )
  {
    do
    {
      v8 = a2 >> 4 > 0x270;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64uLL;
      *((_WORD *)v7 - 1) = *(_WORD *)&a00010203040506_1[2 * v10];
      v7 -= 2;
    }
    while ( v8 );
    if ( v9 <= 9 )
      goto LABEL_4;
LABEL_6:
    *((_WORD *)v7 - 1) = *(_WORD *)&a00010203040506_1[2 * v9];
    goto LABEL_7;
  }
  v9 = a2;
  if ( a2 > 9 )
    goto LABEL_6;
LABEL_4:
  *(v7 - 1) = v9 + 48;
LABEL_7:
  v11 = *a5;
  v12 = (v11 & 1) == 0;
  v13 = v11 >> 1;
  if ( v12 )
    v14 = v13;
  else
    v14 = *((_QWORD *)a5 + 1);
  v15 = v23;
  if ( v12 )
    v16 = a5 + 1;
  else
    v16 = (unsigned __int8 *)*((_QWORD *)a5 + 2);
  v17 = 0;
  if ( a5[24] )
  {
    v18 = 0;
    v19 = &v16[v14];
    if ( v19 == v16 )
      goto LABEL_17;
LABEL_15:
    v20 = *v16;
    if ( (unsigned int)(v20 - 127) >= 0xFFFFFF82 )
    {
      ++v16;
      while ( 1 )
      {
        v18 += v20;
        if ( v18 >= v23 )
          break;
        ++v17;
        if ( v19 != v16 )
          goto LABEL_15;
LABEL_17:
        v20 = (char)*(v19 - 1);
      }
    }
  }
  if ( v24 )
    v15 = v23 + 1;
  v22[0] = &v24;
  v22[1] = a5;
  v22[2] = v25;
  v22[3] = &v23;
  return sub_5370E3C(a1, a4, (unsigned int)(v15 + v17), (unsigned int)(v15 + v17), v22);
}


================================================================================
Function: sub_5370E3C (0x5370E3C)
================================================================================

__int64 __fastcall sub_5370E3C(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x24
  unsigned __int64 v11; // x22
  __int64 v12; // x22
  int v13; // w23
  __int64 v14; // x8
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_1017BD8[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_24EFF44(a1, v10 >> v9, v8);
  v12 = v10 - v11;
  v13 = **a5;
  if ( v13 )
  {
    v14 = *(_QWORD *)(v7 + 16);
    v15 = v14 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v14 = *(_QWORD *)(v7 + 16);
      v15 = v14 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v14) = v13;
  }
  result = sub_5370F24((unsigned __int8 *)a5[1], v7, (char *)a5[2], *a5[3]);
  if ( v12 )
    return sub_24EFF44(result, v12, v8);
  return result;
}


================================================================================
Function: sub_5370F24 (0x5370F24)
================================================================================

__int64 __fastcall sub_5370F24(unsigned __int8 *a1, __int64 a2, char *a3, int a4)
{
  __int64 v4; // x22
  unsigned __int64 v8; // x11
  int v9; // w9
  unsigned __int8 *v10; // x8
  int v11; // w25
  unsigned __int8 *v12; // x27
  __int64 v13; // x10
  _DWORD *v14; // x8
  unsigned __int8 *v15; // x9
  bool v16; // zf
  __int64 v17; // x11
  unsigned __int8 *v18; // x9
  int v19; // w9
  bool v20; // cc
  __int64 v21; // x10
  int v22; // w11
  __int64 v23; // x9
  int v24; // w25
  __int64 v25; // x9
  __int64 v26; // x8
  unsigned __int8 v27; // w26
  __int64 v28; // x1
  __int64 v29; // x9
  __int64 v30; // x8
  char v31; // w26
  __int64 v32; // x1
  __int64 (__fastcall **v34)(); // [xsp+0h] [xbp-800h] BYREF
  _DWORD *v35; // [xsp+8h] [xbp-7F8h]
  __int128 v36; // [xsp+10h] [xbp-7F0h]
  _DWORD v37[502]; // [xsp+20h] [xbp-7E0h] BYREF

  LODWORD(v4) = a4;
  v8 = *a1;
  v34 = off_6B3FD10;
  v35 = v37;
  v9 = a1[24];
  v36 = xmmword_AF5E10;
  v10 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  v37[0] = 0;
  if ( v9 )
  {
    v11 = 0;
    if ( (v8 & 1) != 0 )
      v12 = v10;
    else
      v12 = a1 + 1;
    v13 = 1LL;
    v14 = v37;
    while ( 1 )
    {
      v15 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      v16 = (v8 & 1) == 0;
      v17 = (unsigned __int8)(v8 >> 1);
      if ( v16 )
        v15 = a1 + 1;
      else
        v17 = *((_QWORD *)a1 + 1);
      v18 = &v15[v17];
      if ( v18 == v12 )
      {
        v19 = (char)*(v18 - 1);
      }
      else
      {
        v19 = *v12;
        if ( (unsigned int)(v19 - 127) < 0xFFFFFF82 )
        {
          LODWORD(v23) = v13;
          if ( (int)v4 >= 1 )
            goto LABEL_26;
          goto LABEL_35;
        }
        ++v12;
      }
      v11 += v19;
      if ( v11 )
        v20 = v11 < (int)v4;
      else
        v20 = 0;
      if ( !v20 )
      {
        LODWORD(v23) = v13;
LABEL_25:
        if ( (int)v4 < 1 )
          goto LABEL_35;
        goto LABEL_26;
      }
      v23 = v13 + 1;
      if ( *((_QWORD *)&v36 + 1) >= (unsigned __int64)(v13 + 1) )
      {
        *(_QWORD *)&v36 = v13 + 1;
        v14[v13] = v11;
      }
      else
      {
        ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v34)(&v34, v13 + 1);
        v14 = v35;
        v21 = v36;
        v22 = a1[24];
        v23 = v36 + 1;
        *(_QWORD *)&v36 = v36 + 1;
        v35[v21] = v11;
        if ( !v22 )
          goto LABEL_25;
      }
      v8 = *a1;
      v13 = v23;
    }
  }
  LODWORD(v23) = 1;
  v14 = v37;
  if ( a4 >= 1 )
  {
LABEL_26:
    v24 = v23 - 1;
    v4 = (unsigned int)v4;
    do
    {
      if ( (_DWORD)v4 == v14[v24] )
      {
        v26 = *(_QWORD *)(a2 + 16);
        v27 = a1[24];
        v28 = v26 + 1;
        if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v26 + 1) )
        {
          (**(void (__fastcall ***)(__int64))a2)(a2);
          v26 = *(_QWORD *)(a2 + 16);
          v28 = v26 + 1;
        }
        --v24;
        v29 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a2 + 16) = v28;
        *(_BYTE *)(v29 + v26) = v27;
      }
      v30 = *(_QWORD *)(a2 + 16);
      v31 = *a3;
      v32 = v30 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v30 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v30 = *(_QWORD *)(a2 + 16);
        v32 = v30 + 1;
      }
      v25 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v32;
      --v4;
      ++a3;
      *(_BYTE *)(v25 + v30) = v31;
      v14 = v35;
    }
    while ( v4 );
  }
LABEL_35:
  if ( v14 != v37 )
    sub_6575460();
  return a2;
}


================================================================================
Function: sub_53712B8 (0x53712B8)
================================================================================

__int64 __fastcall sub_53712B8(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // x21
  __int64 v6; // x10
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x12
  unsigned __int64 v10; // x8
  __int64 v11; // x11
  _BYTE *v12; // x9
  char *v13; // x13
  unsigned __int64 v14; // x14
  __int64 v15; // x15
  _OWORD *v16; // x13
  __int128 *v17; // x14
  unsigned __int64 v18; // x16
  __int128 v19; // q0
  __int128 v20; // q1
  _QWORD *v21; // x11
  __int64 *v22; // x16
  __int64 v23; // x15
  __int64 v24; // t1
  char v25; // t1

  if ( a1 != a2 )
  {
    v5 = a1;
    v6 = *(_QWORD *)(a3 + 16);
    do
    {
      v7 = *(_QWORD *)(a3 + 24);
      v8 = a2 - v5;
      if ( v7 < a2 - v5 + v6 )
      {
        (**(void (__fastcall ***)(__int64))a3)(a3);
        v6 = *(_QWORD *)(a3 + 16);
        v7 = *(_QWORD *)(a3 + 24);
      }
      v9 = v7 - v6;
      if ( v7 - v6 >= v8 )
        v10 = a2 - v5;
      else
        v10 = v7 - v6;
      if ( !v10 )
        goto LABEL_4;
      v11 = *(_QWORD *)(a3 + 8);
      v12 = (_BYTE *)(v11 + v6);
      if ( v10 >= 8 )
      {
        if ( (unsigned __int64)v12 >= v5 + v10 || (v14 = v10, v13 = (char *)v5, v5 >= v11 + v6 + v10) )
        {
          if ( v10 < 0x20 )
          {
            v15 = 0LL;
LABEL_21:
            if ( v9 >= v8 )
              v9 = a2 - v5;
            v21 = (_QWORD *)(v11 + v6 + v15);
            v22 = (__int64 *)(v5 + v15);
            v13 = (char *)(v5 + (v9 & 0xFFFFFFFFFFFFFFF8LL));
            v12 += v9 & 0xFFFFFFFFFFFFFFF8LL;
            v14 = v10 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
            v23 = v15 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v24 = *v22++;
              v23 += 8LL;
              *v21++ = v24;
            }
            while ( v23 );
            if ( v9 == (v9 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_3;
            goto LABEL_28;
          }
          v15 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          v16 = (_OWORD *)(v11 + v6 + 16);
          v17 = (__int128 *)(v5 + 16);
          v18 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v19 = *(v17 - 1);
            v20 = *v17;
            v17 += 2;
            v18 -= 32LL;
            *(v16 - 1) = v19;
            *v16 = v20;
            v16 += 2;
          }
          while ( v18 );
          if ( v10 == v15 )
            goto LABEL_3;
          if ( (v10 & 0x18) != 0 )
            goto LABEL_21;
          v14 = v10 & 0x1F;
          v12 += v15;
          v13 = (char *)(v5 + v15);
        }
      }
      else
      {
        v13 = (char *)v5;
        v14 = v10;
      }
      do
      {
LABEL_28:
        v25 = *v13++;
        --v14;
        *v12++ = v25;
      }
      while ( v14 );
LABEL_3:
      v6 = *(_QWORD *)(a3 + 16);
LABEL_4:
      v6 += v10;
      v5 += v10;
      *(_QWORD *)(a3 + 16) = v6;
    }
    while ( v5 != a2 );
  }
  return a3;
}


================================================================================
Function: sub_5371438 (0x5371438)
================================================================================

__int64 __fastcall sub_5371438(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  unsigned int v13; // w10
  _BYTE *v14; // x1
  _BYTE *v15; // x9
  unsigned int v16; // w15
  unsigned int v17; // w11
  unsigned int v18; // w14
  _BYTE v20[12]; // [xsp+Ch] [xbp-14h] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_DWORD *)(a1 + 24);
  v14 = &v20[*(int *)(a1 + 28)];
  if ( v13 >= 0x64 )
  {
    v15 = &v20[*(int *)(a1 + 28)];
    do
    {
      v16 = v13 >> 4;
      v17 = v13 / 0x64;
      v18 = v13 % 0x64;
      v13 /= 0x64u;
      *((_WORD *)v15 - 1) = *(_WORD *)&a00010203040506_1[2 * v18];
      v15 -= 2;
    }
    while ( v16 > 0x270 );
    if ( v17 <= 9 )
      goto LABEL_15;
LABEL_17:
    *((_WORD *)v15 - 1) = *(_WORD *)&a00010203040506_1[2 * v17];
    return sub_53712B8((unsigned __int64)v20, (__int64)v14, a2);
  }
  v15 = &v20[*(int *)(a1 + 28)];
  v17 = *(_DWORD *)(a1 + 24);
  if ( v13 > 9 )
    goto LABEL_17;
LABEL_15:
  *(v15 - 1) = v17 + 48;
  return sub_53712B8((unsigned __int64)v20, (__int64)v14, a2);
}


================================================================================
Function: sub_53715C4 (0x53715C4)
================================================================================

__int64 __fastcall sub_53715C4(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  unsigned int v13; // w8
  __int64 v14; // x10
  __int64 v15; // x11
  __int64 v16; // x9
  unsigned __int64 v17; // x13
  int v18; // w10
  __int64 v19; // x12
  bool v20; // zf
  __int64 v21; // x10
  const char *v22; // x9
  _BYTE *v23; // x10
  __int64 v24; // x11
  _BYTE *v25; // x1
  _BYTE *v26; // x10
  const char *v27; // x9
  __int64 v28; // x11
  bool v29; // cc
  _BYTE v31[12]; // [xsp+Ch] [xbp-14h] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_DWORD *)(a1 + 24);
  v14 = *(unsigned int *)(a1 + 28);
  v15 = *(_QWORD *)(a2 + 16);
  v16 = (int)v14;
  v17 = v15 + v14;
  v18 = *(unsigned __int8 *)(a1 + 32);
  if ( *(_QWORD *)(a2 + 24) >= v17 && (v19 = *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16) = v17, v19) )
  {
    v20 = v18 == 0;
    v21 = v15 + v16 + v19;
    if ( v20 )
      v22 = "0123456789abcdef";
    else
      v22 = "0123456789ABCDEF";
    v23 = (_BYTE *)(v21 - 1);
    do
    {
      v24 = v13 & 0xF;
      v7 = v13 >= 0x10;
      v13 >>= 4;
      *v23-- = v22[v24];
    }
    while ( v7 );
  }
  else
  {
    v25 = &v31[v16];
    v20 = v18 == 0;
    v26 = &v31[v16 - 1];
    if ( v20 )
      v27 = "0123456789abcdef";
    else
      v27 = "0123456789ABCDEF";
    do
    {
      v28 = v13 & 0xF;
      v29 = v13 > 0xF;
      v13 >>= 4;
      *v26-- = v27[v28];
    }
    while ( v29 );
    return sub_53712B8((unsigned __int64)v31, (__int64)v25, a2);
  }
  return a2;
}


================================================================================
Function: sub_54751B8 (0x54751B8)
================================================================================

unsigned __int64 __fastcall sub_54751B8(unsigned __int64 *a1, char *s)
{
  unsigned __int64 result; // x0
  size_t v5; // x20
  void *v6; // x19
  unsigned __int64 v7; // x22
  __int64 v8; // x0

  result = strlen(s);
  if ( result >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v5 = result;
  if ( result >= 0x17 )
  {
    v7 = (result + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = sub_6575418();
    a1[1] = v5;
    a1[2] = v8;
    *a1 = v7 | 1;
    v6 = (void *)v8;
  }
  else
  {
    *(_BYTE *)a1 = 2 * result;
    v6 = (char *)a1 + 1;
    if ( !result )
      goto LABEL_7;
  }
  result = (unsigned __int64)memcpy(v6, s, v5);
LABEL_7:
  *((_BYTE *)v6 + v5) = 0;
  return result;
}


================================================================================
Function: sub_54E0F84 (0x54E0F84)
================================================================================

void *__fastcall sub_54E0F84(__int64 a1, int a2)
{
  void *result; // x0

  if ( a2 < 1 )
  {
    if ( a2 < -9999 )
      result = (void *)sub_54E448C(a1);
    else
      result = (void *)(*(_QWORD *)(a1 + 8) + 16LL * a2);
  }
  else if ( *(_QWORD *)(a1 + 16) + 16 * (unsigned __int64)(unsigned int)(a2 - 1) >= *(_QWORD *)(a1 + 8) )
  {
    result = &unk_1020EA0;
  }
  else
  {
    result = (void *)(*(_QWORD *)(a1 + 16) + 16LL * (unsigned int)(a2 - 1));
  }
  if ( result == &unk_1020EA0 )
    return 0LL;
  return result;
}


================================================================================
Function: sub_54E1098 (0x54E1098)
================================================================================

__int64 __fastcall sub_54E1098(__int64 result, int a2)
{
  __int64 v2; // x19
  __int64 v3; // x8
  __int64 v5; // x9
  unsigned __int64 v6; // x8

  v2 = result;
  v3 = *(_QWORD *)(result + 8);
  if ( *(_QWORD *)(result + 40) - v3 <= 16 * a2 )
  {
    result = sub_54ED1D0();
    v3 = *(_QWORD *)(v2 + 8);
  }
  v5 = *(_QWORD *)(v2 + 32);
  v6 = v3 + 16LL * a2;
  if ( *(_QWORD *)(v5 + 16) < v6 )
    *(_QWORD *)(v5 + 16) = v6;
  return result;
}


================================================================================
Function: sub_54E12F4 (0x54E12F4)
================================================================================

__int64 __fastcall sub_54E12F4(__int64 a1)
{
  return (*(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 16)) >> 4;
}


================================================================================
Function: sub_54E25FC (0x54E25FC)
================================================================================

__int64 __fastcall sub_54E25FC(__int64 result, char *a2)
{
  __int64 v2; // x19
  size_t v4; // x21
  _QWORD *v5; // x22
  __int64 v6; // x23
  __int64 v7; // x8

  v2 = result;
  if ( a2 )
  {
    v4 = strlen(a2);
    if ( *(_QWORD *)(*(_QWORD *)(v2 + 24) + 72LL) >= *(_QWORD *)(*(_QWORD *)(v2 + 24) + 64LL) )
      sub_54EE53C(v2, 1);
    if ( (*(_BYTE *)(v2 + 1) & 4) != 0 )
      sub_54EF570(v2, v2, (_QWORD *)(v2 + 104));
    v5 = (_QWORD *)(v2 + 8);
    v6 = *(_QWORD *)(v2 + 8);
    result = sub_54F51DC(v2, (int *)a2, v4);
    *(_QWORD *)v6 = result;
    v7 = *(_QWORD *)(v2 + 8);
    *(_DWORD *)(v6 + 12) = 5;
  }
  else
  {
    v7 = *(_QWORD *)(result + 8);
    v5 = (_QWORD *)(result + 8);
    *(_DWORD *)(v7 + 12) = 0;
  }
  *v5 = v7 + 16;
  return result;
}


================================================================================
Function: sub_54E2754 (0x54E2754)
================================================================================

__int64 sub_54E2754(__int64 a1, char *format, ...)
{
  gcc_va_list va1; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-28h] BYREF

  if ( *(_QWORD *)(*(_QWORD *)(a1 + 24) + 72LL) >= *(_QWORD *)(*(_QWORD *)(a1 + 24) + 64LL) )
    sub_54EE53C(a1, 1);
  if ( (*(_BYTE *)(a1 + 1) & 4) != 0 )
    sub_54EF570(a1, a1, a1 + 104);
  va_start(va, format);
  va_copy(va1, va);
  return sub_54F3C4C(a1, format);
}


================================================================================
Function: sub_54E448C (0x54E448C)
================================================================================

void *__fastcall sub_54E448C(_QWORD *a1, int a2)
{
  void *result; // x0
  __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x9
  __int64 *v6; // x9
  __int64 v7; // x8
  int v8; // w11
  __int64 v9; // x8

  switch ( a2 )
  {
    case -10002:
      v3 = a1[3];
      v4 = a1[11];
LABEL_13:
      *(_QWORD *)(v3 + 3200) = v4;
      result = (void *)(a1[3] + 3200LL);
      *(_DWORD *)(v3 + 3212) = 6;
      return result;
    case -10001:
      v3 = a1[3];
      v5 = a1[4];
      if ( v5 == a1[8] )
        v6 = a1 + 11;
      else
        v6 = (__int64 *)(**(_QWORD **)(v5 + 8) + 16LL);
      v4 = *v6;
      goto LABEL_13;
    case -10000:
      return (void *)(a1[3] + 3216LL);
  }
  v7 = **(_QWORD **)(a1[4] + 8LL);
  v8 = *(unsigned __int8 *)(v7 + 4);
  v9 = v7 + 16LL * (-10003 - a2) + 48;
  if ( -10002 - a2 <= v8 )
    return (void *)v9;
  else
    return &unk_1020EA0;
}


================================================================================
Function: sub_54EC328 (0x54EC328)
================================================================================

void __noreturn sub_54EC328(__int64 a1, const char *a2, ...)
{
  char s[512]; // [xsp+B0h] [xbp-240h] BYREF
  gcc_va_list va; // [xsp+2B0h] [xbp-40h] BYREF
  gcc_va_list arg; // [xsp+2D0h] [xbp-20h] BYREF

  va_start(va, a2);
  va_copy(arg, va);
  vsnprintf(s, 0x200uLL, a2, arg);
  sub_54E1098(a1, 1LL);
  sub_54EC5D4(a1, s);
  sub_54ECF70(a1, 2LL);
}


================================================================================
Function: sub_54EC5D4 (0x54EC5D4)
================================================================================

__int64 __fastcall sub_54EC5D4(__int64 a1, __int64 a2)
{
  int v2; // w20
  __int64 *v3; // x8
  __int64 v4; // x8
  char dest[256]; // [xsp+8h] [xbp-108h] BYREF

  v2 = a1;
  v3 = *(__int64 **)(*(_QWORD *)(a1 + 32) + 8LL);
  if ( *((_DWORD *)v3 + 3) != 7 )
    return sub_54E25FC(a1, a2);
  v4 = *v3;
  if ( *(_BYTE *)(v4 + 3) )
    return sub_54E25FC(a1, a2);
  sub_54F3E30(
    dest,
    0x100uLL,
    (char *)(*(_QWORD *)(*(_QWORD *)(v4 + 24) + 88LL) + 24LL),
    *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v4 + 24) + 88LL) + 20LL));
  return sub_54F3D1C(v2, "%s:%d: %s");
}


================================================================================
Function: sub_54ECEB0 (0x54ECEB0)
================================================================================

__int64 __fastcall sub_54ECEB0(__int64 a1, void (*a2)(void))
{
  a2();
  return 0LL;
}


================================================================================
Function: sub_54ECF70 (0x54ECF70)
================================================================================

void __fastcall __noreturn sub_54ECF70(__int64 a1, int a2)
{
  __int64 v4; // x0

  v4 = sub_67EAFB8(24LL);
  *(_DWORD *)(v4 + 16) = a2;
  *(_QWORD *)v4 = off_6B4A558;
  *(_QWORD *)(v4 + 8) = a1;
  sub_67EB030();
}


================================================================================
Function: sub_54ECFB0 (0x54ECFB0)
================================================================================

char *__fastcall sub_54ECFB0(__int64 a1, int a2, int a3)
{
  __int64 v5; // x22
  char *v6; // x20
  char *result; // x0
  __int64 v8; // x12
  __int64 v9; // x9
  unsigned __int64 v10; // x10
  char *v11; // x12
  unsigned __int64 v12; // x13
  __int64 v13; // x8
  char *v14; // x10
  __int64 v15; // x8
  char *v16; // x10
  __int64 v17; // x8
  char **v18; // x8
  unsigned __int64 i; // x9
  char *v20; // x10
  char *v21; // x11
  __int64 v22; // x8
  __int64 v23; // t1
  __int64 v24; // x10

  if ( a2 >= 67108865 && (_BYTE)word_6F11DD8 )
  {
    if ( a3 && (_BYTE)word_6F11DF0 )
    {
      v22 = *(_QWORD *)(a1 + 32);
      v23 = *(_QWORD *)(v22 - 40);
      v22 -= 40LL;
      v24 = *(_QWORD *)(v22 + 16);
      *(_QWORD *)(a1 + 32) = v22;
      *(_QWORD *)(a1 + 8) = v24;
      *(_QWORD *)(a1 + 16) = v23;
    }
    sub_54ECF70(a1, 4);
  }
  if ( a2 < -5 )
    sub_54F2A0C(a1);
  v5 = (unsigned int)(a2 + 5);
  v6 = *(char **)(a1 + 48);
  result = (char *)sub_54F2F9C(a1, v6, 16LL * *(int *)(a1 + 72), 16 * v5, *(_BYTE *)(a1 + 2));
  v8 = *(int *)(a1 + 72);
  *(_QWORD *)(a1 + 48) = result;
  if ( (int)v8 < (int)v5 )
  {
    v9 = v8;
    v10 = (int)v5 - v8;
    if ( v10 < 2 )
      goto LABEL_9;
    v9 = (v10 & 0xFFFFFFFFFFFFFFFELL) + v8;
    v11 = &result[16 * v8 + 28];
    v12 = v10 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v12 -= 2LL;
      *((_DWORD *)v11 - 4) = 0;
      *(_DWORD *)v11 = 0;
      v11 += 32;
    }
    while ( v12 );
    if ( v10 != (v10 & 0xFFFFFFFFFFFFFFFELL) )
    {
LABEL_9:
      v13 = (int)v5 - v9;
      v14 = &result[16 * v9 + 12];
      do
      {
        --v13;
        *(_DWORD *)v14 = 0;
        v14 += 16;
      }
      while ( v13 );
    }
  }
  v15 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 72) = v5;
  *(_QWORD *)(a1 + 40) = &result[16 * a2];
  v16 = &result[v15 - (_QWORD)v6];
  v17 = *(_QWORD *)(a1 + 96);
  for ( *(_QWORD *)(a1 + 8) = v16; v17; v17 = *(_QWORD *)(v17 + 32) )
    *(_QWORD *)(v17 + 8) = &result[*(_QWORD *)(v17 + 8) - (_QWORD)v6];
  v18 = *(char ***)(a1 + 64);
  for ( i = *(_QWORD *)(a1 + 32); (unsigned __int64)v18 <= i; v18 += 5 )
  {
    v20 = &result[v18[2] - v6];
    v21 = &result[*v18 - v6];
    v18[1] = &result[v18[1] - v6];
    v18[2] = v20;
    *v18 = v21;
  }
  *(_QWORD *)(a1 + 16) = &result[*(_QWORD *)(a1 + 16) - (_QWORD)v6];
  return result;
}


================================================================================
Function: sub_54ED150 (0x54ED150)
================================================================================

char *__fastcall sub_54ED150(__int64 a1, unsigned int a2)
{
  char *v3; // x21
  char *result; // x0
  __int64 v6; // x8

  if ( (a2 & 0x80000000) != 0 )
    sub_54F2A0C(a1);
  v3 = *(char **)(a1 + 64);
  result = (char *)sub_54F2F9C(a1, v3, 40LL * *(int *)(a1 + 76), 40LL * a2, *(_BYTE *)(a1 + 2));
  v6 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 76) = a2;
  *(_QWORD *)(a1 + 56) = &result[40 * a2 - 40];
  *(_QWORD *)(a1 + 64) = result;
  *(_QWORD *)(a1 + 32) = &result[v6 - (_QWORD)v3];
  return result;
}


================================================================================
Function: sub_54ED1D0 (0x54ED1D0)
================================================================================

__int64 sub_54ED1D0()
{
  return sub_54ECFB0();
}


================================================================================
Function: sub_54EDC18 (0x54EDC18)
================================================================================

__int64 __fastcall sub_54EDC18(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int16 v5; // w25
  __int64 v7; // x23
  __int64 v9; // x24
  int v11; // w26
  unsigned int v12; // w20
  __int64 v13; // x27
  __int64 v14; // x0
  char *v15; // x1
  size_t v16; // x2
  int v17; // w22
  int v18; // w0
  int v20; // w8
  unsigned int v21; // w8
  void (__fastcall *v22)(__int64); // x8
  unsigned __int64 v23; // x23
  __int64 v24; // x21
  __int64 v25; // x0
  char *v26; // x1
  size_t v27; // x2
  __int64 v28; // x22
  __int64 v29; // x8
  __int64 v30; // x11
  __int64 v31; // x0
  __int64 v32; // x8

  v5 = *(_WORD *)(a1 + 80);
  v7 = *(_QWORD *)(a1 + 32);
  v9 = *(_QWORD *)(a1 + 64);
  v11 = *(unsigned __int8 *)(a1 + 5);
  v12 = ((__int64 (*)(void))sub_54ECEB0)();
  if ( !v12 )
    return v12;
  if ( a5 )
  {
    if ( v12 == 2 )
      goto LABEL_14;
    v13 = *(_QWORD *)(a1 + 8);
    switch ( v12 )
    {
      case 3u:
        *(_OWORD *)v13 = *(_OWORD *)(v13 - 16);
        break;
      case 5u:
        v14 = a1;
        v15 = "error in error handling";
        v16 = 23LL;
        goto LABEL_12;
      case 4u:
        v14 = a1;
        v15 = "not enough memory";
        v16 = 17LL;
LABEL_12:
        *(_QWORD *)v13 = sub_54F51DC(v14, (int *)v15, v16);
        *(_DWORD *)(v13 + 12) = 5;
        break;
    }
    *(_QWORD *)(a1 + 8) = v13 + 16;
LABEL_14:
    v18 = sub_54ECEB0(a1, sub_54EDE74, *(_QWORD *)(a1 + 48) + a5);
    if ( v18 == 4 && v12 == 4 )
      v20 = 4;
    else
      v20 = 5;
    if ( v18 )
      v17 = v20;
    else
      v17 = 2;
    if ( v18 )
      v12 = v20;
    if ( !v11 )
      goto LABEL_26;
    goto LABEL_27;
  }
  v17 = v12;
  if ( !v11 )
LABEL_26:
    *(_BYTE *)(a1 + 5) = 0;
LABEL_27:
  v21 = *(unsigned __int16 *)(a1 + 80);
  *(_WORD *)(a1 + 80) = v5;
  if ( v21 <= *(unsigned __int16 *)(a1 + 82) )
  {
    v22 = *(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 24) + 3352LL);
    if ( v22 )
    {
      v22(a1);
      if ( *(_BYTE *)(a1 + 3) == 6 )
        return 0;
    }
  }
  v23 = v7 - v9;
  v24 = *(_QWORD *)(a1 + 48) + a4;
  sub_54EE27C(a1, v24);
  if ( (unsigned int)(v17 - 2) < 2 )
  {
    *(_OWORD *)v24 = *(_OWORD *)(*(_QWORD *)(a1 + 8) - 16LL);
  }
  else
  {
    if ( v17 == 5 )
    {
      v25 = a1;
      v26 = "error in error handling";
      v27 = 23LL;
      goto LABEL_37;
    }
    if ( v17 == 4 )
    {
      v25 = a1;
      v26 = "not enough memory";
      v27 = 17LL;
LABEL_37:
      *(_QWORD *)v24 = sub_54F51DC(v25, (int *)v26, v27);
      *(_DWORD *)(v24 + 12) = 5;
    }
  }
  v28 = *(_QWORD *)(a1 + 64);
  v29 = *(unsigned int *)(a1 + 76);
  v30 = *(_QWORD *)(v28 + v23);
  *(_QWORD *)(a1 + 32) = v28 + v23;
  *(_QWORD *)(a1 + 8) = v24 + 16;
  *(_QWORD *)(a1 + 16) = v30;
  if ( (int)v29 >= 20001 && (int)(-858993459 * (v23 >> 3)) <= 19998 )
  {
    v31 = sub_54F2F9C(a1, v28, 40 * v29, 800000LL, *(unsigned __int8 *)(a1 + 2));
    v32 = v31 + *(_QWORD *)(a1 + 32) - v28;
    *(_DWORD *)(a1 + 76) = 20000;
    *(_QWORD *)(a1 + 56) = v31 + 799960;
    *(_QWORD *)(a1 + 64) = v31;
    *(_QWORD *)(a1 + 32) = v32;
  }
  return v12;
}


================================================================================
Function: sub_54EDFE8 (0x54EDFE8)
================================================================================

long double __fastcall sub_54EDFE8(__int64 a1)
{
  __int64 v2; // x0
  __int64 v3; // x10
  long double result; // q0
  char v5; // w9
  char v6; // w8

  v2 = sub_54F2B70(a1, 176LL, *(_BYTE *)(a1 + 4));
  v3 = *(_QWORD *)(a1 + 24);
  *(_OWORD *)&result = 0uLL;
  v5 = *(_BYTE *)(a1 + 4);
  *(_BYTE *)v2 = 11;
  v6 = *(_BYTE *)(v3 + 32);
  *(_BYTE *)(v2 + 2) = v5;
  *(_OWORD *)(v2 + 160) = 0u;
  *(_OWORD *)(v2 + 147) = 0u;
  *(_OWORD *)(v2 + 131) = 0u;
  *(_OWORD *)(v2 + 115) = 0u;
  *(_OWORD *)(v2 + 99) = 0u;
  *(_OWORD *)(v2 + 83) = 0u;
  *(_OWORD *)(v2 + 67) = 0u;
  *(_BYTE *)(v2 + 1) = v6 & 3;
  *(_OWORD *)(v2 + 51) = 0u;
  *(_OWORD *)(v2 + 35) = 0u;
  *(_OWORD *)(v2 + 19) = 0u;
  *(_OWORD *)(v2 + 3) = 0u;
  return result;
}


================================================================================
Function: sub_54EE060 (0x54EE060)
================================================================================

__int64 __fastcall sub_54EE060(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 result; // x0
  __int64 v9; // x8
  char v10; // w10
  unsigned __int8 v11; // w9
  __int64 v12; // x9
  _DWORD *v13; // x10
  __int64 v14; // x11
  __int64 v15; // x8
  _DWORD *v16; // x10

  result = sub_54F2B70(a1, 16LL * a2 + 32, *(_BYTE *)(a1 + 4));
  v9 = *(_QWORD *)(a1 + 24);
  v10 = *(_BYTE *)(a1 + 4);
  *(_BYTE *)(result + 3) = 0;
  LOBYTE(v9) = *(_BYTE *)(v9 + 32);
  *(_BYTE *)result = 7;
  v11 = *(_BYTE *)(a4 + 6);
  *(_BYTE *)(result + 2) = v10;
  *(_BYTE *)(result + 4) = a2;
  *(_WORD *)(result + 5) = v11;
  *(_QWORD *)(result + 16) = a3;
  *(_QWORD *)(result + 24) = a4;
  *(_BYTE *)(result + 1) = v9 & 3;
  if ( a2 >= 1 )
  {
    if ( a2 == 1 )
    {
      v12 = 0LL;
LABEL_7:
      v15 = (unsigned int)a2 - v12;
      v16 = (_DWORD *)(result + 16 * v12 + 44);
      do
      {
        --v15;
        *v16 = 0;
        v16 += 4;
      }
      while ( v15 );
      return result;
    }
    v12 = a2 & 0xFFFFFFFE;
    v13 = (_DWORD *)(result + 60);
    v14 = v12;
    do
    {
      v14 -= 2LL;
      *(v13 - 4) = 0;
      *v13 = 0;
      v13 += 8;
    }
    while ( v14 );
    if ( v12 != a2 )
      goto LABEL_7;
  }
  return result;
}


================================================================================
Function: sub_54EE27C (0x54EE27C)
================================================================================

__int64 __fastcall sub_54EE27C(__int64 result, unsigned __int64 a2)
{
  _QWORD *v2; // x8
  __int64 v3; // x19
  __int128 v5; // q0

  v2 = *(_QWORD **)(result + 96);
  if ( v2 )
  {
    v3 = result;
    do
    {
      if ( v2[1] < a2 )
        break;
      *(_QWORD *)(v3 + 96) = v2[4];
      *(_QWORD *)(v2[3] + 16LL) = v2[2];
      *(_QWORD *)(v2[2] + 24LL) = v2[3];
      v5 = *(_OWORD *)v2[1];
      v2[1] = v2 + 2;
      *((_OWORD *)v2 + 1) = v5;
      result = sub_54EF590(v3, v2);
      v2 = *(_QWORD **)(v3 + 96);
    }
    while ( v2 );
  }
  return result;
}


================================================================================
Function: sub_54EE2F8 (0x54EE2F8)
================================================================================

__int64 __fastcall sub_54EE2F8(__int64 result, __int64 a2, char a3)
{
  _OWORD *v3; // x8
  __int128 v4; // q0

  v3 = (_OWORD *)(a2 + 16);
  *(_QWORD *)(*(_QWORD *)(a2 + 24) + 16LL) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(*(_QWORD *)(a2 + 16) + 24LL) = *(_QWORD *)(a2 + 24);
  if ( (a3 & 1) == 0 )
  {
    v4 = *(_OWORD *)*(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 8) = v3;
    *v3 = v4;
    return sub_54EF590(result, a2);
  }
  return result;
}


================================================================================
Function: sub_54EE328 (0x54EE328)
================================================================================

__int64 __fastcall sub_54EE328(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x1
  __int64 v7; // x1
  __int64 v8; // x1

  sub_54F2D00(a1, *(_QWORD *)(a2 + 16), 4LL * *(int *)(a2 + 136), *(_BYTE *)(a2 + 2));
  sub_54F2D00(a1, *(_QWORD *)(a2 + 24), 8LL * *(int *)(a2 + 140), *(_BYTE *)(a2 + 2));
  sub_54F2D00(a1, *(_QWORD *)(a2 + 8), 16LL * *(int *)(a2 + 152), *(_BYTE *)(a2 + 2));
  v6 = *(_QWORD *)(a2 + 56);
  if ( v6 )
    sub_54F2D00(a1, v6, *(int *)(a2 + 156), *(_BYTE *)(a2 + 2));
  sub_54F2D00(a1, *(_QWORD *)(a2 + 72), 24LL * *(int *)(a2 + 144), *(_BYTE *)(a2 + 2));
  sub_54F2D00(a1, *(_QWORD *)(a2 + 80), 8LL * *(int *)(a2 + 148), *(_BYTE *)(a2 + 2));
  v7 = *(_QWORD *)(a2 + 104);
  if ( v7 )
    sub_54F2D00(a1, v7, *(int *)(a2 + 136), *(_BYTE *)(a2 + 2));
  if ( *(_QWORD *)(a2 + 40) )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 24) + 3384LL))(a1, a2);
  v8 = *(_QWORD *)(a2 + 112);
  if ( v8 )
    sub_54F2D00(a1, v8, *(int *)(a2 + 172), *(_BYTE *)(a2 + 2));
  return sub_54F2E14(a1, a2, 176LL, *(unsigned __int8 *)(a2 + 2), a3);
}


================================================================================
Function: sub_54EE53C (0x54EE53C)
================================================================================

unsigned __int64 __fastcall sub_54EE53C(__int64 a1, char a2)
{
  __int64 v2; // x23
  __int64 v5; // x24
  __int64 v6; // x25
  __int64 v7; // x9
  void (__fastcall *v8)(__int64, _QWORD); // x8
  unsigned __int64 v9; // x20
  __int64 v10; // x22
  int v11; // w22
  double v12; // d0
  int v13; // w8
  double v14; // d0
  double v15; // d1
  double v16; // d0
  unsigned int v17; // w20
  double v18; // d8
  __int64 v19; // x22
  double v20; // d0
  __int64 v21; // x8
  __int64 v22; // x8
  __int64 v23; // x8
  _QWORD *v24; // x9
  int v25; // w11
  unsigned __int64 v26; // x21
  signed __int64 v27; // x8
  unsigned __int64 v28; // x10
  bool v29; // cf
  unsigned __int64 v30; // x8
  double v31; // d0
  double v32; // d1
  signed __int64 v33; // x9
  signed __int64 v34; // x10
  __int64 v35; // x10
  int v36; // w15
  unsigned __int64 v37; // x11
  unsigned __int64 v38; // x10
  double v39; // d2
  double v40; // d1
  double v41; // d2
  __int64 v42; // x12
  int v43; // w14
  int v44; // w14
  signed __int64 v45; // x13
  signed __int64 v46; // x15
  double v47; // d0
  __int64 v48; // x8
  __int128 v49; // q0
  __int128 v50; // q1
  __int128 v51; // q0
  __int128 v52; // q3
  __int128 v53; // q2
  __int128 v54; // q1
  __int128 v55; // q0
  __int128 v56; // q3
  __int64 v57; // x2
  __int128 v58; // q1
  __int128 v59; // q0
  __int128 v60; // q2
  __int128 v61; // q0
  __int64 v62; // x3
  __int64 v63; // x11
  void (__fastcall *v64)(__int64, _QWORD); // x8

  v2 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(v2 + 64);
  v5 = *(_QWORD *)(v2 + 72);
  v7 = 1374389535LL * *(_DWORD *)(v2 + 84) * *(_DWORD *)(v2 + 88);
  v8 = *(void (__fastcall **)(__int64, _QWORD))(v2 + 3296);
  v9 = (unsigned __int64)v7 >> 63;
  v10 = v7 >> 37;
  if ( v8 )
    v8(a1, 0LL);
  v11 = v10 + v9;
  if ( !*(_BYTE *)(v2 + 33) )
  {
    v12 = sub_54F4728();
    v13 = *(unsigned __int8 *)(v2 + 33);
    *(double *)(v2 + 6656) = v12;
    if ( !v13 )
    {
      v14 = sub_54F4728();
      v15 = *(double *)(v2 + 6736);
      *(double *)(v2 + 6944) = v14;
      *(double *)(v2 + 6936) = v14 - v15;
    }
  }
  v16 = sub_54F4728();
  v17 = *(unsigned __int8 *)(v2 + 33);
  v18 = v16;
  v19 = sub_54EE934(a1, v11);
  v20 = sub_54F4728() - v18;
  switch ( v17 )
  {
    case 0u:
      if ( *(_BYTE *)(v2 + 33) != 1 )
        goto LABEL_13;
      *(double *)(v2 + 6960) = v20 + *(double *)(v2 + 6960);
      if ( (a2 & 1) == 0 )
        goto LABEL_19;
      goto LABEL_11;
    case 1u:
    case 2u:
      v21 = *(_QWORD *)(v2 + 6992) + v19;
      *(double *)(v2 + 6960) = v20 + *(double *)(v2 + 6960);
      *(_QWORD *)(v2 + 6992) = v21;
      if ( (a2 & 1) == 0 )
        goto LABEL_19;
LABEL_11:
      v22 = 6968LL;
      goto LABEL_17;
    case 3u:
      *(double *)(v2 + 7016) = v20 + *(double *)(v2 + 7016);
      goto LABEL_13;
    case 4u:
      v23 = *(_QWORD *)(v2 + 7088) + v19;
      *(double *)(v2 + 7056) = v20 + *(double *)(v2 + 7056);
      *(_QWORD *)(v2 + 7088) = v23;
      if ( (a2 & 1) == 0 )
        goto LABEL_19;
      v22 = 7064LL;
LABEL_17:
      *(double *)(v2 + v22) = v20 + *(double *)(v2 + v22);
      goto LABEL_18;
    default:
LABEL_13:
      if ( (a2 & 1) != 0 )
      {
LABEL_18:
        v24 = (_QWORD *)(v2 + 7096);
        *(double *)(v2 + 6688) = v20 + *(double *)(v2 + 6688);
      }
      else
      {
LABEL_19:
        v24 = (_QWORD *)(v2 + 7104);
        *(double *)(v2 + 6680) = v20 + *(double *)(v2 + 6680);
      }
      v25 = *(unsigned __int8 *)(v2 + 33);
      v26 = 100 * v19 / (unsigned __int64)*(int *)(v2 + 84);
      v27 = *(_QWORD *)(v2 + 72);
      *v24 += v19;
      if ( v25 )
      {
        v28 = v27 + v26;
        v29 = v27 + v26 >= v5 - v6;
        v30 = v27 + v26 - (v5 - v6);
        *(_QWORD *)(v2 + 64) = v28;
        if ( v29 )
          *(_QWORD *)(v2 + 64) = v30;
      }
      else
      {
        v31 = *(double *)(v2 + 6664);
        v32 = v31 - *(double *)(v2 + 6672);
        v33 = v27 / 0x64uLL * *(int *)(v2 + 80);
        v34 = v33;
        if ( v32 >= 0.001 )
        {
          v35 = *(_QWORD *)(v2 + 6632);
          v36 = *(_DWORD *)(v2 + 6628);
          v37 = v35 - *(_QWORD *)(v2 + 6640);
          v38 = (unsigned __int64)(v35 - *(_QWORD *)(v2 + 6648)) >> 10;
          v39 = (double)v37;
          LODWORD(v37) = *(_DWORD *)(v2 + 6624);
          v40 = v39 / v32;
          v41 = *(double *)(v2 + 6656);
          v42 = v2 + 4 * (v37 & 0x1F);
          *(_DWORD *)(v2 + 6624) = v37 + 1;
          v43 = *(_DWORD *)(v42 + 6496);
          *(_DWORD *)(v42 + 6496) = v38;
          v44 = v36 + v38 - v43;
          *(_DWORD *)(v2 + 6628) = v44;
          v45 = v33
              - ((__int64)((v31 - v41) * v40)
               + vcvtd_n_s64_f64((double)(int)v38 * 0.405 + (double)v44 * 0.243, 0xAuLL));
          if ( v45 <= v33 )
            v46 = v45;
          else
            v46 = v33;
          if ( v45 >= v27 )
            v34 = v46;
          else
            v34 = v27;
        }
        *(_QWORD *)(v2 + 64) = v34;
        *(_QWORD *)(v2 + 6648) = v33;
        v47 = sub_54F4728();
        v48 = *(_QWORD *)(v2 + 72);
        *(double *)(v2 + 6672) = v47;
        *(_QWORD *)(v2 + 6640) = v48;
        *(double *)(v2 + 6952) = sub_54F4728();
        v49 = *(_OWORD *)(v2 + 7080);
        *(_OWORD *)(v2 + 6880) = *(_OWORD *)(v2 + 7096);
        v50 = *(_OWORD *)(v2 + 7048);
        *(_OWORD *)(v2 + 6864) = v49;
        v51 = *(_OWORD *)(v2 + 7032);
        v52 = *(_OWORD *)(v2 + 7016);
        v53 = *(_OWORD *)(v2 + 7112);
        *(_OWORD *)(v2 + 6832) = v50;
        v54 = *(_OWORD *)(v2 + 6968);
        *(_OWORD *)(v2 + 6816) = v51;
        v55 = *(_OWORD *)(v2 + 7064);
        *(_OWORD *)(v2 + 6800) = v52;
        v56 = *(_OWORD *)(v2 + 6920);
        v57 = *(_QWORD *)(v2 + 6696);
        *(_OWORD *)(v2 + 6752) = v54;
        v58 = *(_OWORD *)(v2 + 6936);
        *(_OWORD *)(v2 + 6848) = v55;
        v59 = *(_OWORD *)(v2 + 7000);
        *(_OWORD *)(v2 + 6896) = v53;
        v60 = *(_OWORD *)(v2 + 6984);
        *(_OWORD *)(v2 + 6704) = v56;
        *(_OWORD *)(v2 + 6720) = v58;
        *(_OWORD *)(v2 + 6784) = v59;
        v61 = *(_OWORD *)(v2 + 6952);
        *(_OWORD *)(v2 + 6768) = v60;
        *(_QWORD *)(v2 + 6696) = v57 + 1;
        *(_OWORD *)(v2 + 7112) = 0u;
        v63 = *(_QWORD *)(v2 + 64);
        v62 = *(_QWORD *)(v2 + 72);
        *(_OWORD *)(v2 + 6736) = v61;
        *(_OWORD *)(v2 + 7096) = 0u;
        *(_OWORD *)(v2 + 7080) = 0u;
        *(_OWORD *)(v2 + 7064) = 0u;
        *(_QWORD *)(v2 + 7128) = v62;
        *(_QWORD *)(v2 + 6912) = v62;
        *(_OWORD *)(v2 + 7048) = 0u;
        *(_OWORD *)(v2 + 7032) = 0u;
        *(_OWORD *)(v2 + 7016) = 0u;
        *(_OWORD *)(v2 + 7000) = 0u;
        *(_OWORD *)(v2 + 6984) = 0u;
        *(_OWORD *)(v2 + 6968) = 0u;
        *(_OWORD *)(v2 + 6952) = 0u;
        *(_OWORD *)(v2 + 6936) = 0u;
        *(_QWORD *)(v2 + 7128) = 0LL;
        *(_QWORD *)(v2 + 6920) = v62;
        *(_QWORD *)(v2 + 6928) = v63;
      }
      v64 = *(void (__fastcall **)(__int64, _QWORD))(v2 + 3296);
      if ( v64 )
        v64(a1, v17);
      return v26;
  }
}


================================================================================
Function: sub_54EE934 (0x54EE934)
================================================================================

unsigned __int64 __fastcall sub_54EE934(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x20
  unsigned __int64 v5; // x21
  __int64 v6; // x9
  bool v7; // w8
  __int64 v8; // x0
  __int64 v9; // x9
  __int64 v10; // x8
  __int64 v11; // x9
  bool v12; // w8
  __int64 v13; // x0
  __int64 v14; // x9
  __int64 v15; // x8
  double v16; // d0
  __int64 v17; // x8
  double v18; // d0
  __int64 v19; // x8
  __int64 v20; // x20
  double v21; // d8
  __int64 v22; // x21
  __int64 v23; // x23
  int *v24; // x8
  __int64 v25; // x23
  __int64 v26; // x0
  __int64 v27; // x25
  _BYTE *v28; // x24
  int v29; // w8
  int v30; // w26
  char v31; // w27
  int v32; // w8
  int v33; // w8
  int v34; // w8
  int v35; // w9
  __int64 v36; // x9
  int v37; // w8
  int v38; // w10
  __int64 v39; // x24
  double v40; // d9
  double v41; // d1
  __int64 v42; // x8
  __int64 v43; // x25
  double v44; // d10
  __int64 v45; // x27
  __int64 v46; // x8
  double v47; // d0
  double v48; // d8
  __int64 v49; // x28
  __int64 v50; // x21
  __int64 v51; // x10
  char v52; // w9
  __int64 v53; // x8
  char v54; // w11
  __int64 v55; // x11
  __int64 v56; // x12
  _BYTE *v57; // x13
  int v58; // w10
  int v59; // w22
  __int64 v60; // x8
  __int64 v61; // x9
  __int64 v62; // x11
  __int64 v63; // x10
  int v64; // w13
  int v65; // w12
  _BYTE *v66; // x14
  _BYTE *v67; // x11
  __int64 v68; // x0
  _DWORD *v69; // x0
  double v70; // d9
  __int64 v71; // x8
  __int64 v72; // x1
  __int64 v73; // x22
  __int64 v74; // x21
  __int64 v75; // x26
  double v76; // d0
  char v77; // w8
  int v79; // [xsp+0h] [xbp-40h] BYREF
  int v80; // [xsp+4h] [xbp-3Ch] BYREF
  _BYTE *v81; // [xsp+8h] [xbp-38h] BYREF
  _BYTE *v82; // [xsp+10h] [xbp-30h] BYREF

  v2 = *(_QWORD *)(a1 + 24);
  switch ( *(_BYTE *)(v2 + 33) )
  {
    case 0:
      sub_54EF378(a1);
      return 0LL;
    case 1:
      v6 = *(_QWORD *)(v2 + 40);
      v5 = 0LL;
      v7 = v6 != 0;
      if ( v6 && a2 )
      {
        v5 = 0LL;
        do
        {
          v8 = sub_54EF6F0(v2);
          v9 = *(_QWORD *)(v2 + 40);
          v5 += v8;
          v7 = v9 != 0;
        }
        while ( v9 && v5 < a2 );
      }
      if ( !v7 )
      {
        v10 = *(_QWORD *)(v2 + 7096) + *(_QWORD *)(v2 + 7104);
        *(_QWORD *)(v2 + 40) = *(_QWORD *)(v2 + 48);
        *(_QWORD *)(v2 + 48) = 0LL;
        *(_QWORD *)(v2 + 7112) = v10;
        *(_BYTE *)(v2 + 33) = 2;
      }
      return v5;
    case 2:
      v11 = *(_QWORD *)(v2 + 40);
      v5 = 0LL;
      v12 = v11 != 0;
      if ( v11 && a2 )
      {
        v5 = 0LL;
        do
        {
          v13 = sub_54EF6F0(v2);
          v14 = *(_QWORD *)(v2 + 40);
          v5 += v13;
          v12 = v14 != 0;
        }
        while ( v14 && v5 < a2 );
      }
      if ( !v12 )
      {
        v15 = *(_QWORD *)(v2 + 7096) + *(_QWORD *)(v2 + 7104) - *(_QWORD *)(v2 + 7112);
        *(_BYTE *)(v2 + 33) = 3;
        *(_QWORD *)(v2 + 7120) = v15;
      }
      return v5;
    case 3:
      v16 = sub_54F4728();
      v17 = *(_QWORD *)(v2 + 72);
      *(double *)(v2 + 7000) = v16;
      *(_QWORD *)(v2 + 7008) = v17;
      v18 = sub_54F4728();
      v19 = *(_QWORD *)(v2 + 72);
      *(double *)(v2 + 6664) = v18;
      *(_QWORD *)(v2 + 6632) = v19;
      v20 = *(_QWORD *)(a1 + 24);
      v21 = sub_54F4728();
      v22 = *(_QWORD *)(v20 + 2840);
      if ( v22 == v20 + 2816 )
      {
        v23 = 0LL;
      }
      else
      {
        v23 = 0LL;
        do
        {
          if ( (*(_BYTE *)(v22 + 1) & 7) == 0 )
          {
            v24 = *(int **)(v22 + 8);
            if ( v24[3] >= 5 && (*(_BYTE *)(*(_QWORD *)v24 + 1LL) & 3) != 0 )
              sub_54EF440(v20);
          }
          v22 = *(_QWORD *)(v22 + 24);
          v23 += 40LL;
        }
        while ( v22 != v20 + 2816 );
      }
      if ( *(_QWORD *)(v20 + 40) )
      {
        v39 = 0LL;
        do
          v39 += sub_54EF6F0(v20);
        while ( *(_QWORD *)(v20 + 40) );
      }
      else
      {
        v39 = 0LL;
      }
      v40 = sub_54F4728();
      v41 = *(double *)(v20 + 7024);
      v42 = *(_QWORD *)(v20 + 56);
      *(_QWORD *)(v20 + 56) = 0LL;
      *(_QWORD *)(v20 + 40) = v42;
      *(double *)(v20 + 7024) = v41 + v40 - v21;
      if ( (*(_BYTE *)(a1 + 1) & 3) != 0 )
        sub_54EF440(v20);
      sub_54EFE58(v20);
      if ( *(_QWORD *)(v20 + 40) )
      {
        v43 = 0LL;
        do
          v43 += sub_54EF6F0(v20);
        while ( *(_QWORD *)(v20 + 40) );
      }
      else
      {
        v43 = 0LL;
      }
      v44 = sub_54F4728();
      v45 = 0LL;
      v46 = *(_QWORD *)(v20 + 48);
      v47 = *(double *)(v20 + 7032) + v44 - v40;
      *(_QWORD *)(v20 + 40) = v46;
      *(_QWORD *)(v20 + 48) = 0LL;
      for ( *(double *)(v20 + 7032) = v47; *(_QWORD *)(v20 + 40); v45 += sub_54EF6F0(v20) )
        ;
      v48 = sub_54F4728();
      v49 = 0LL;
      v50 = *(_QWORD *)(v20 + 56);
      *(double *)(v20 + 7040) = *(double *)(v20 + 7040) + v48 - v44;
      if ( !v50 )
        goto LABEL_97;
LABEL_66:
      v51 = *(int *)(v50 + 8);
      v52 = *(_BYTE *)(v50 + 6);
      v53 = 16 * v51;
      v54 = v52;
      if ( (_DWORD)v51 )
      {
        v55 = 16 * v51;
        do
        {
          v56 = *(_QWORD *)(v50 + 24) + v55;
          if ( *(int *)(v56 - 4) >= 5 )
          {
            v57 = *(_BYTE **)(v56 - 16);
            if ( *v57 == 5 )
            {
              v57[1] &= 0xFCu;
            }
            else if ( (v57[1] & 3) != 0 )
            {
              *(_DWORD *)(v56 - 4) = 0;
            }
          }
          v55 -= 16LL;
          LODWORD(v51) = v51 - 1;
        }
        while ( (_DWORD)v51 );
        v54 = *(_BYTE *)(v50 + 6);
      }
      v58 = ~(-1 << v54);
      v59 = 0;
      v49 += v53 + 32LL * (1 << v52) + 48;
      v60 = 32LL * v58;
      v61 = v58 + 1LL;
      break;
    case 4:
      v25 = *(_QWORD *)(v2 + 752);
      v5 = 0LL;
      if ( !v25 || !a2 )
        goto LABEL_41;
      v5 = 0LL;
      while ( 1 )
      {
        v26 = sub_54F327C(v25);
        v27 = *(_QWORD *)(v2 + 752);
        v25 = v26;
        sub_54F323C(v27, &v82, &v81, &v80, &v79);
        v28 = v82;
        if ( v82 == v81 )
        {
          v32 = v79;
          v35 = (int)v82;
        }
        else
        {
          v29 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 32LL);
          v30 = v29 ^ 3;
          v31 = v29 & 3;
          do
          {
            if ( *v28 )
            {
              v33 = (unsigned __int8)v28[1];
              if ( ((v33 ^ 3) & v30) != 0 )
              {
                v28[1] = v33 & 0xF8 | v31;
              }
              else
              {
                sub_54EF6A4(a1, v28, v27);
                if ( !--v80 )
                {
                  v34 = ((int)v28 - (int)v82) / v79 + 1;
                  goto LABEL_39;
                }
              }
            }
            v32 = v79;
            v28 += v79;
          }
          while ( v28 != v81 );
          v35 = (int)v82;
        }
        v34 = ((int)v28 - v35) / v32;
LABEL_39:
        *(_QWORD *)(v2 + 752) = v25;
        v5 += 16 * v34;
        if ( !v25 || v5 >= a2 )
        {
LABEL_41:
          if ( !v25 )
          {
            *(_BYTE *)(*(_QWORD *)(v2 + 2808) + 1LL) = *(_BYTE *)(*(_QWORD *)(v2 + 2808) + 1LL) & 0xF8 | *(_BYTE *)(v2 + 32) & 3;
            v36 = *(_QWORD *)(a1 + 24);
            v37 = *(_DWORD *)(v36 + 12);
            v38 = v37 + 3;
            if ( v37 >= 0 )
              v38 = *(_DWORD *)(v36 + 12);
            if ( v37 >= 65 && *(_DWORD *)(v36 + 8) < (unsigned int)(v38 >> 2) )
              sub_54F4ED8(a1, (unsigned int)v37 >> 1);
            *(_BYTE *)(v2 + 33) = 0;
          }
          return v5;
        }
      }
    default:
      return 0LL;
  }
  do
  {
    v62 = *(_QWORD *)(v50 + 32);
    v63 = v62 + v60;
    v64 = *(_DWORD *)(v62 + v60 + 12);
    if ( !v64 )
      goto LABEL_78;
    v65 = *(_DWORD *)(v63 + 28);
    if ( (v65 & 0xFu) >= 5 )
    {
      v66 = *(_BYTE **)(v62 + v60 + 16);
      if ( *v66 == 5 )
      {
        v66[1] &= 0xFCu;
        v64 = *(_DWORD *)(v63 + 12);
      }
      else if ( (v66[1] & 3) != 0 )
      {
        *(_DWORD *)(v63 + 12) = 0;
LABEL_89:
        *(_DWORD *)(v63 + 28) = v65 & 0xFFFFFFF0 | 0xD;
        goto LABEL_78;
      }
    }
    if ( v64 < 5 )
      goto LABEL_77;
    v67 = *(_BYTE **)(v62 + v60);
    if ( *v67 == 5 )
    {
      v67[1] &= 0xFCu;
LABEL_77:
      ++v59;
      goto LABEL_78;
    }
    if ( (v67[1] & 3) == 0 )
      goto LABEL_77;
    v65 = *(_DWORD *)(v63 + 28);
    *(_DWORD *)(v63 + 12) = 0;
    if ( (v65 & 0xFu) >= 5 )
      goto LABEL_89;
LABEL_78:
    v60 -= 32LL;
    --v61;
  }
  while ( v61 );
  v68 = *(_QWORD *)(v50 + 16);
  if ( v68 )
  {
    if ( (*(_BYTE *)(v68 + 3) & 4) == 0 )
    {
      v69 = (_DWORD *)sub_54FB970(v68, 2LL);
      if ( v69 )
      {
        if ( v69[3] == 5 && strchr((const char *)(*(_QWORD *)v69 + 24LL), 115) && v59 < (3 << *(_BYTE *)(v50 + 6)) / 8 )
          sub_54F8FE0(a1, v50, (unsigned int)v59);
      }
    }
  }
  v50 = *(_QWORD *)(v50 + 40);
  if ( v50 )
    goto LABEL_66;
LABEL_97:
  *(_QWORD *)(v20 + 56) = 0LL;
  v70 = sub_54F4728();
  *(double *)(v20 + 7048) = *(double *)(v20 + 7048) + v70 - v48;
  v71 = *(_QWORD *)(a1 + 24);
  v72 = *(_QWORD *)(v71 + 2840);
  v73 = v71 + 2816;
  if ( v72 == v71 + 2816 )
  {
    v74 = 0LL;
  }
  else
  {
    v74 = 0LL;
    do
    {
      if ( *(_BYTE *)(v72 + 3) )
      {
        *(_BYTE *)(v72 + 3) = 0;
        v72 = *(_QWORD *)(v72 + 24);
      }
      else
      {
        v75 = *(_QWORD *)(v72 + 24);
        sub_54EE2F8(a1);
        v72 = v75;
      }
      v74 += 40LL;
    }
    while ( v72 != v73 );
  }
  v5 = v39 + v23 + v43 + v45 + v49 + v74;
  v76 = *(double *)(v20 + 7024) + sub_54F4728() - v70;
  v77 = *(_BYTE *)(v20 + 32) ^ 3;
  *(_QWORD *)(v20 + 752) = *(_QWORD *)(v20 + 744);
  *(_BYTE *)(v20 + 33) = 4;
  *(_BYTE *)(v20 + 32) = v77;
  *(double *)(v20 + 7024) = v76;
  return v5;
}


================================================================================
Function: sub_54EF378 (0x54EF378)
================================================================================

__int64 __fastcall sub_54EF378(__int64 a1)
{
  __int64 v1; // x19
  __int64 v3; // x1
  unsigned __int8 *v4; // x1
  __int64 v5; // x8
  unsigned __int8 *v6; // x1
  __int64 result; // x0

  v1 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(v1 + 2808);
  *(_QWORD *)(v1 + 40) = 0LL;
  *(_QWORD *)(v1 + 48) = 0LL;
  *(_QWORD *)(v1 + 56) = 0LL;
  if ( (*(_BYTE *)(v3 + 1) & 3) != 0 )
  {
    sub_54EF440(v1, (unsigned __int8 *)v3);
    v3 = *(_QWORD *)(v1 + 2808);
  }
  v4 = *(unsigned __int8 **)(v3 + 88);
  if ( (v4[1] & 3) != 0 )
    sub_54EF440(v1, v4);
  v5 = *(_QWORD *)(a1 + 24);
  if ( *(int *)(v5 + 3228) >= 5 )
  {
    v6 = *(unsigned __int8 **)(v5 + 3216);
    if ( (v6[1] & 3) != 0 )
      sub_54EF440(v1, v6);
  }
  result = sub_54EFE58(v1);
  *(_BYTE *)(v1 + 33) = 1;
  return result;
}


================================================================================
Function: sub_54EF440 (0x54EF440)
================================================================================

__int64 __fastcall sub_54EF440(__int64 result, unsigned __int8 *a2)
{
  int v3; // w9
  unsigned __int8 v4; // w8
  unsigned __int8 *v5; // x9
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  __int64 v9; // x8
  int *v10; // x8

  while ( 1 )
  {
    v3 = *a2;
    v4 = a2[1] & 0xFC;
    a2[1] = v4;
    if ( v3 != 8 )
      break;
    v5 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
    a2[1] = v4 | 4;
    if ( !v5 || (v5[1] & 3) == 0 )
      return result;
    a2 = v5;
  }
  switch ( v3 )
  {
    case 6:
      v6 = *(_QWORD *)(result + 40);
      *(_QWORD *)(result + 40) = a2;
      *((_QWORD *)a2 + 5) = v6;
      break;
    case 7:
      v7 = *(_QWORD *)(result + 40);
      *(_QWORD *)(result + 40) = a2;
      *((_QWORD *)a2 + 1) = v7;
      break;
    case 9:
      v8 = *(_QWORD *)(result + 40);
      *(_QWORD *)(result + 40) = a2;
      *((_QWORD *)a2 + 13) = v8;
      break;
    case 10:
      goto LABEL_15;
    case 11:
      v9 = *(_QWORD *)(result + 40);
      *(_QWORD *)(result + 40) = a2;
      *((_QWORD *)a2 + 16) = v9;
      break;
    case 12:
      v10 = (int *)*((_QWORD *)a2 + 1);
      if ( v10[3] >= 5 && (*(_BYTE *)(*(_QWORD *)v10 + 1LL) & 3) != 0 )
      {
        result = sub_54EF440(result);
        v10 = (int *)*((_QWORD *)a2 + 1);
      }
      if ( v10 == (int *)(a2 + 16) )
      {
        v4 = a2[1];
LABEL_15:
        a2[1] = v4 | 4;
      }
      break;
    default:
      return result;
  }
  return result;
}


================================================================================
Function: sub_54EF53C (0x54EF53C)
================================================================================

__int64 __fastcall sub_54EF53C(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  __int64 result; // x0
  __int64 v4; // x8

  result = *(_QWORD *)(a1 + 24);
  if ( *(_BYTE *)(result + 33) == 2 )
    return sub_54EF440(result, a3);
  *(_BYTE *)(a2 + 1) &= ~4u;
  v4 = *(_QWORD *)(result + 48);
  *(_QWORD *)(result + 48) = a2;
  *(_QWORD *)(a2 + 40) = v4;
  return result;
}


================================================================================
Function: sub_54EF570 (0x54EF570)
================================================================================

__int64 __fastcall sub_54EF570(__int64 result, __int64 a2, _QWORD *a3)
{
  __int64 v3; // x9

  v3 = *(_QWORD *)(result + 24);
  *(_BYTE *)(a2 + 1) &= ~4u;
  *a3 = *(_QWORD *)(v3 + 48);
  *(_QWORD *)(v3 + 48) = a2;
  return result;
}


================================================================================
Function: sub_54EF590 (0x54EF590)
================================================================================

__int64 __fastcall sub_54EF590(__int64 result, __int64 a2)
{
  char v2; // w9
  __int64 v3; // x8
  int *v4; // x8
  char v5; // w8

  v2 = *(_BYTE *)(a2 + 1);
  if ( (v2 & 7) == 0 )
  {
    v3 = *(_QWORD *)(result + 24);
    if ( (unsigned int)*(unsigned __int8 *)(v3 + 33) - 1 > 2 )
    {
      v5 = *(_BYTE *)(v3 + 32);
    }
    else
    {
      v4 = *(int **)(a2 + 8);
      *(_BYTE *)(a2 + 1) = v2 | 4;
      if ( v4[3] < 5 || (*(_BYTE *)(*(_QWORD *)v4 + 1LL) & 3) == 0 )
        return result;
      result = *(_QWORD *)(result + 24);
      if ( (unsigned int)*(unsigned __int8 *)(result + 33) - 1 <= 2 )
        return sub_54EF440(result);
      v5 = *(_BYTE *)(result + 32);
    }
    *(_BYTE *)(a2 + 1) = v2 & 0xF8 | v5 & 3;
  }
  return result;
}


================================================================================
Function: sub_54EF6A4 (0x54EF6A4)
================================================================================

__int64 __fastcall sub_54EF6A4(__int64 result, _BYTE *a2, __int64 a3)
{
  __int64 v3; // x4
  __int64 v4; // x3
  __int64 v5; // x2
  __int64 v6; // x8

  switch ( *a2 )
  {
    case 5:
      JUMPOUT(0x54F53DCLL);
    case 6:
      JUMPOUT(0x54F91A8LL);
    case 7:
      v6 = 48LL;
      v3 = a3;
      v4 = (unsigned __int8)a2[2];
      if ( !a2[3] )
        v6 = 32LL;
      v5 = v6 + 16LL * (unsigned __int8)a2[4];
      goto LABEL_5;
    case 8:
      JUMPOUT(0x54FBB8CLL);
    case 9:
      return sub_54F49A4();
    case 0xA:
      JUMPOUT(0x54E7000LL);
    case 0xB:
      return sub_54EE328();
    case 0xC:
      v3 = a3;
      v4 = (unsigned __int8)a2[2];
      v5 = 40LL;
LABEL_5:
      result = sub_54F2E14(result, a2, v5, v4, v3);
      break;
    default:
      return result;
  }
  return result;
}


================================================================================
Function: sub_54EF6F0 (0x54EF6F0)
================================================================================

__int64 __fastcall sub_54EF6F0(__int64 a1)
{
  __int64 result; // x0
  unsigned __int8 *v3; // x19
  int v4; // w8
  unsigned __int8 *v5; // x1
  __int64 v6; // x0
  const char *v7; // x22
  char *v8; // x21
  char *v9; // x0
  _BOOL4 v10; // w22
  __int64 v11; // x8
  int v12; // w21
  unsigned __int8 *v13; // x1
  unsigned __int8 v14; // w8
  unsigned __int64 v15; // x21
  unsigned __int8 *v16; // x22
  int v17; // w9
  __int64 v18; // x8
  unsigned __int8 v19; // w9
  __int64 v20; // x8
  __int64 v21; // x8
  int v22; // w8
  __int64 v23; // x21
  __int64 i; // x22
  __int64 v25; // x9
  unsigned __int8 *v26; // x1
  __int64 v27; // x8
  __int64 v28; // x9
  int v29; // w8
  __int64 j; // x21
  unsigned __int8 *v31; // x1
  int v32; // w9
  __int64 v33; // x10
  __int64 v34; // x11
  __int64 v35; // x23
  __int64 v36; // x8
  unsigned __int8 *v37; // x1
  __int64 v38; // x9
  __int64 v39; // x23
  __int64 v40; // x24
  __int64 v41; // x27
  __int64 v42; // x26
  unsigned __int8 *v43; // x1
  unsigned __int8 *v44; // x1
  unsigned __int8 *v45; // x1
  unsigned __int8 v46; // w9
  unsigned __int64 v47; // x21
  unsigned __int8 *v48; // x22
  unsigned __int8 *v49; // x21
  unsigned __int64 v50; // x12
  unsigned __int64 v51; // x8
  __int64 v52; // x9
  unsigned __int64 v53; // x10
  unsigned __int64 v54; // x9
  __int64 v55; // x10
  __int64 v56; // x13
  _DWORD *v57; // x12
  unsigned __int64 v58; // x8
  unsigned __int64 v59; // x9
  unsigned __int64 v60; // x20
  unsigned __int64 v61; // x10
  unsigned __int64 v62; // x11
  unsigned __int64 v63; // x10
  __int64 v64; // x21
  int v65; // w8
  __int64 v66; // x8

  result = 0LL;
  v3 = *(unsigned __int8 **)(a1 + 40);
  v4 = *v3 - 6;
  v3[1] |= 4u;
  switch ( v4 )
  {
    case 0:
      v5 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
      *(_QWORD *)(a1 + 40) = *((_QWORD *)v3 + 5);
      if ( v5
        && ((v5[1] & 3) == 0 || (sub_54EF440(a1, v5), (v5 = (unsigned __int8 *)*((_QWORD *)v3 + 2)) != 0LL))
        && (v5[3] & 4) == 0
        && (v6 = sub_54FB970(v5, 2LL)) != 0
        && *(_DWORD *)(v6 + 12) == 5 )
      {
        v7 = (const char *)(*(_QWORD *)v6 + 24LL);
        v8 = strchr(v7, 118);
        v9 = strchr(v7, 107);
        v10 = v9 != 0LL;
        if ( (unsigned __int64)v9 | (unsigned __int64)v8 )
        {
          v11 = *(_QWORD *)(a1 + 56);
          *(_QWORD *)(a1 + 56) = v3;
          *((_QWORD *)v3 + 5) = v11;
        }
        if ( v9 && v8 )
        {
LABEL_75:
          v3[1] &= ~4u;
          return 16LL * *((int *)v3 + 2) + 32LL * (1 << v3[6]) + 48;
        }
        if ( v8 )
        {
          v12 = 1;
          goto LABEL_61;
        }
      }
      else
      {
        v10 = 0;
      }
      v12 = *((_DWORD *)v3 + 2);
      if ( v12 )
      {
        v35 = 16LL * v12;
        do
        {
          v36 = *((_QWORD *)v3 + 3) + v35;
          if ( *(int *)(v36 - 4) >= 5 )
          {
            v37 = *(unsigned __int8 **)(v36 - 16);
            if ( (v37[1] & 3) != 0 )
              sub_54EF440(a1, v37);
          }
          v35 -= 16LL;
          --v12;
        }
        while ( v12 );
      }
LABEL_61:
      v38 = ~(-1 << v3[6]);
      v39 = 32 * v38;
      v40 = v38 + 1;
      do
      {
        v41 = *((_QWORD *)v3 + 4);
        v42 = v41 + v39;
        if ( *(_DWORD *)(v41 + v39 + 12) )
        {
          if ( !v10 && (*(_DWORD *)(v41 + v39 + 28) & 0xFu) >= 5 )
          {
            v43 = *(unsigned __int8 **)(v41 + v39 + 16);
            if ( (v43[1] & 3) != 0 )
              sub_54EF440(a1, v43);
          }
          if ( (v12 & 1) == 0 && *(int *)(v42 + 12) >= 5 )
          {
            v44 = *(unsigned __int8 **)(v41 + v39);
            if ( (v44[1] & 3) != 0 )
              sub_54EF440(a1, v44);
          }
        }
        else if ( (*(_DWORD *)(v42 + 28) & 0xFu) >= 5 )
        {
          *(_DWORD *)(v42 + 28) = *(_DWORD *)(v42 + 28) & 0xFFFFFFF0 | 0xD;
        }
        v39 -= 32LL;
        --v40;
      }
      while ( v40 );
      if ( (v10 | v12) != 1 )
        return 16LL * *((int *)v3 + 2) + 32LL * (1 << v3[6]) + 48;
      goto LABEL_75;
    case 1:
      v13 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
      *(_QWORD *)(a1 + 40) = *((_QWORD *)v3 + 1);
      if ( (v13[1] & 3) != 0 )
        sub_54EF440(a1, v13);
      if ( v3[3] )
      {
        v14 = v3[4];
        if ( v14 )
        {
          v15 = 0LL;
          v16 = v3 + 48;
          do
          {
            if ( *((int *)v16 + 3) >= 5 && (*(_BYTE *)(*(_QWORD *)v16 + 1LL) & 3) != 0 )
            {
              sub_54EF440(a1, *(unsigned __int8 **)v16);
              v14 = v3[4];
            }
            ++v15;
            v16 += 16;
          }
          while ( v15 < v14 );
        }
      }
      else
      {
        v45 = (unsigned __int8 *)*((_QWORD *)v3 + 3);
        if ( (v45[1] & 3) != 0 )
          sub_54EF440(a1, v45);
        v46 = v3[4];
        if ( v46 )
        {
          v47 = 0LL;
          v48 = v3 + 32;
          do
          {
            if ( *((int *)v48 + 3) >= 5 && (*(_BYTE *)(*(_QWORD *)v48 + 1LL) & 3) != 0 )
            {
              sub_54EF440(a1, *(unsigned __int8 **)v48);
              v46 = v3[4];
            }
            ++v47;
            v48 += 16;
            v14 = v46;
          }
          while ( v47 < v46 );
        }
        else
        {
          v14 = 0;
        }
      }
      v66 = 16LL * v14;
      if ( v3[3] )
        return v66 + 48;
      else
        return v66 + 32;
    case 3:
      v17 = v3[5];
      *(_QWORD *)(a1 + 40) = *((_QWORD *)v3 + 13);
      if ( v17 )
      {
        sub_54EFD88(a1, v3);
      }
      else
      {
        v49 = *(unsigned __int8 **)(*((_QWORD *)v3 + 3) + 2808LL);
        sub_54EFD88(a1, v3);
        if ( v49 != v3 )
          goto LABEL_86;
      }
      v18 = *(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 48) = v3;
      v19 = v3[1];
      *((_QWORD *)v3 + 13) = v18;
      v3[1] = v19 & 0xFB;
      if ( *(_BYTE *)(a1 + 33) != 3 )
        goto LABEL_94;
LABEL_86:
      v50 = *((_QWORD *)v3 + 1);
      v51 = *((_QWORD *)v3 + 6) + 16LL * *((int *)v3 + 18);
      if ( v50 < v51 )
      {
        v52 = v50 + 16;
        if ( v51 > v50 + 16 )
          v52 = *((_QWORD *)v3 + 6) + 16LL * *((int *)v3 + 18);
        v53 = v52 + ~v50;
        v54 = *((_QWORD *)v3 + 1);
        if ( v53 < 0x10 )
          goto LABEL_114;
        v55 = (v53 >> 4) + 1;
        v56 = v55 & 0x1FFFFFFFFFFFFFFELL;
        v54 = v50 + 16 * (v55 & 0x1FFFFFFFFFFFFFFELL);
        v57 = (_DWORD *)(v50 + 28);
        do
        {
          v56 -= 2LL;
          *(v57 - 4) = 0;
          *v57 = 0;
          v57 += 8;
        }
        while ( v56 );
        if ( v55 != (v55 & 0x1FFFFFFFFFFFFFFELL) )
        {
LABEL_114:
          do
          {
            *(_DWORD *)(v54 + 12) = 0;
            v54 += 16LL;
          }
          while ( v54 < v51 );
        }
      }
LABEL_94:
      if ( *(_BYTE *)(a1 + 33) == 1 )
      {
        v58 = *((_QWORD *)v3 + 8);
        v59 = *((_QWORD *)v3 + 4);
        v60 = *((_QWORD *)v3 + 1);
        if ( v58 <= v59 )
        {
          v61 = *((_QWORD *)v3 + 8);
          do
          {
            v62 = *(_QWORD *)(v61 + 16);
            v61 += 40LL;
            if ( v60 < v62 )
              v60 = v62;
          }
          while ( v61 <= v59 );
        }
        v63 = *((int *)v3 + 19);
        if ( (int)v63 <= 20000 )
        {
          v64 = *((_QWORD *)v3 + 6);
          if ( (int)v63 >= 17 && 3LL * (int)(-858993459 * ((v59 - v58) >> 3)) < v63 )
            sub_54ED150(v3, (unsigned int)v63 >> 1);
          v65 = *((_DWORD *)v3 + 18);
          if ( v65 >= 91 && (int)((__int64)(v60 - v64) >> 4) + 2LL * (int)((v60 - v64) >> 4) < (unsigned __int64)v65 )
            sub_54ECFB0((__int64)v3, (unsigned int)v65 >> 1, 0);
        }
      }
      return 40LL * *((int *)v3 + 19) + 16LL * *((int *)v3 + 18) + 128;
    case 5:
      v20 = *((_QWORD *)v3 + 11);
      *(_QWORD *)(a1 + 40) = *((_QWORD *)v3 + 16);
      if ( v20 )
        *(_BYTE *)(v20 + 1) &= 0xFCu;
      v21 = *((_QWORD *)v3 + 12);
      if ( v21 )
        *(_BYTE *)(v21 + 1) &= 0xFCu;
      v22 = *((_DWORD *)v3 + 38);
      if ( v22 >= 1 )
      {
        v23 = 0LL;
        for ( i = 0LL; i < v22; ++i )
        {
          v25 = *((_QWORD *)v3 + 1);
          if ( *(int *)(v25 + v23 + 12) >= 5 )
          {
            v26 = *(unsigned __int8 **)(v25 + v23);
            if ( (v26[1] & 3) != 0 )
            {
              sub_54EF440(a1, v26);
              v22 = *((_DWORD *)v3 + 38);
            }
          }
          v23 += 16LL;
        }
      }
      v27 = *((unsigned int *)v3 + 37);
      if ( (int)v27 >= 1 )
      {
        v28 = *((_QWORD *)v3 + 10);
        do
        {
          if ( *(_QWORD *)v28 )
            *(_BYTE *)(*(_QWORD *)v28 + 1LL) &= 0xFCu;
          --v27;
          v28 += 8LL;
        }
        while ( v27 );
      }
      v29 = *((_DWORD *)v3 + 35);
      if ( v29 >= 1 )
      {
        for ( j = 0LL; j < v29; ++j )
        {
          v31 = *(unsigned __int8 **)(*((_QWORD *)v3 + 3) + 8 * j);
          if ( v31 && (v31[1] & 3) != 0 )
          {
            sub_54EF440(a1, v31);
            v29 = *((_DWORD *)v3 + 35);
          }
        }
      }
      v32 = *((_DWORD *)v3 + 36);
      if ( v32 >= 1 )
      {
        v33 = *((_QWORD *)v3 + 9);
        v34 = *((unsigned int *)v3 + 36);
        do
        {
          if ( *(_QWORD *)v33 )
            *(_BYTE *)(*(_QWORD *)v33 + 1LL) &= 0xFCu;
          --v34;
          v33 += 24LL;
        }
        while ( v34 );
      }
      return 4LL * *((int *)v3 + 34)
           + 16LL * *((int *)v3 + 38)
           + *((int *)v3 + 39)
           + 24LL * v32
           + *((int *)v3 + 43)
           + 8 * (*((int *)v3 + 37) + (__int64)v29)
           + 176;
    default:
      return result;
  }
}


================================================================================
Function: sub_54EFD88 (0x54EFD88)
================================================================================

__int64 __fastcall sub_54EFD88(__int64 result, _QWORD *a2)
{
  unsigned __int8 *v3; // x1
  __int64 v4; // x19
  __int64 v5; // x8
  unsigned __int64 v6; // x21
  unsigned __int64 v7; // x8
  __int64 i; // x20
  char v9; // w8

  v3 = (unsigned __int8 *)a2[11];
  v4 = result;
  if ( (v3[1] & 3) != 0 )
    result = sub_54EF440(result, v3);
  v5 = a2[14];
  if ( v5 )
    *(_BYTE *)(v5 + 1) &= 0xFCu;
  v6 = a2[6];
  v7 = a2[1];
  while ( v6 < v7 )
  {
    if ( *(int *)(v6 + 12) >= 5 && (*(_BYTE *)(*(_QWORD *)v6 + 1LL) & 3) != 0 )
    {
      result = sub_54EF440(v4, *(unsigned __int8 **)v6);
      v7 = a2[1];
    }
    v6 += 16LL;
  }
  for ( i = a2[12]; i; i = *(_QWORD *)(i + 32) )
  {
    v9 = *(_BYTE *)(i + 1);
    *(_BYTE *)(i + 3) = 1;
    if ( (v9 & 3) != 0 )
      result = sub_54EF440(v4, (unsigned __int8 *)i);
  }
  return result;
}


================================================================================
Function: sub_54EFE58 (0x54EFE58)
================================================================================

__int64 __fastcall sub_54EFE58(__int64 result)
{
  _QWORD *v1; // x19
  unsigned __int8 *v2; // x1
  unsigned __int8 *v3; // x1
  unsigned __int8 *v4; // x1
  unsigned __int8 *v5; // x1
  unsigned __int8 *v6; // x1
  unsigned __int8 *v7; // x1
  unsigned __int8 *v8; // x1
  unsigned __int8 *v9; // x1
  unsigned __int8 *v10; // x1
  unsigned __int8 *v11; // x1
  unsigned __int8 *v12; // x1

  v1 = (_QWORD *)result;
  v2 = *(unsigned __int8 **)(result + 2856);
  if ( v2 && (v2[1] & 3) != 0 )
    result = sub_54EF440(result, v2);
  v3 = (unsigned __int8 *)v1[358];
  if ( v3 && (v3[1] & 3) != 0 )
    result = sub_54EF440((__int64)v1, v3);
  v4 = (unsigned __int8 *)v1[359];
  if ( v4 && (v4[1] & 3) != 0 )
    result = sub_54EF440((__int64)v1, v4);
  v5 = (unsigned __int8 *)v1[360];
  if ( v5 && (v5[1] & 3) != 0 )
    result = sub_54EF440((__int64)v1, v5);
  v6 = (unsigned __int8 *)v1[361];
  if ( v6 && (v6[1] & 3) != 0 )
    result = sub_54EF440((__int64)v1, v6);
  v7 = (unsigned __int8 *)v1[362];
  if ( v7 && (v7[1] & 3) != 0 )
    result = sub_54EF440((__int64)v1, v7);
  v8 = (unsigned __int8 *)v1[363];
  if ( v8 && (v8[1] & 3) != 0 )
    result = sub_54EF440((__int64)v1, v8);
  v9 = (unsigned __int8 *)v1[364];
  if ( v9 && (v9[1] & 3) != 0 )
    result = sub_54EF440((__int64)v1, v9);
  v10 = (unsigned __int8 *)v1[365];
  if ( v10 && (v10[1] & 3) != 0 )
    result = sub_54EF440((__int64)v1, v10);
  v11 = (unsigned __int8 *)v1[366];
  if ( v11 && (v11[1] & 3) != 0 )
    result = sub_54EF440((__int64)v1, v11);
  v12 = (unsigned __int8 *)v1[367];
  if ( v12 )
  {
    if ( (v12[1] & 3) != 0 )
      return sub_54EF440((__int64)v1, v12);
  }
  return result;
}


================================================================================
Function: sub_54F2A0C (0x54F2A0C)
================================================================================

void __fastcall __noreturn sub_54F2A0C(__int64 a1)
{
  sub_54EC328(a1, "memory allocation error: block too big");
}


================================================================================
Function: sub_54F2A20 (0x54F2A20)
================================================================================

_QWORD *__fastcall sub_54F2A20(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v6; // x23
  __int64 v7; // x22
  __int64 v8; // x0
  _QWORD *v9; // x22
  __int64 v10; // t1
  __int64 v11; // x9
  __int64 v12; // x10
  __int64 *v13; // x8
  __int64 v14; // x0
  _QWORD *v15; // x22
  int v16; // w10
  __int64 v17; // x11
  _QWORD *v18; // x9
  __int64 v19; // x9
  void (__fastcall *v20)(__int64, _QWORD, __int64); // x8
  __int64 v21; // x10

  v6 = *(_QWORD *)(a1 + 24);
  if ( (unsigned __int64)(a2 - 1) <= 0x3FF && (byte_6F11E20[a2 + 160] & 0x80000000) == 0 )
  {
    v7 = v6 + 8LL * (unsigned __int8)byte_6F11E20[a2 + 160];
    v10 = *(_QWORD *)(v7 + 96);
    v9 = (_QWORD *)(v7 + 96);
    v8 = v10;
    if ( v10 )
    {
      v11 = *(unsigned int *)(v8 + 48);
      if ( (v11 & 0x80000000) == 0 )
      {
LABEL_5:
        v12 = v8 + v11;
        LODWORD(v11) = v11 - *(_DWORD *)(v8 + 36);
        v13 = (__int64 *)(v12 + 56);
        *(_DWORD *)(v8 + 48) = v11;
        goto LABEL_11;
      }
    }
    else
    {
      v8 = sub_54F3354(a1, v6 + 96, 0LL);
      v11 = *(unsigned int *)(v8 + 48);
      if ( (v11 & 0x80000000) == 0 )
        goto LABEL_5;
    }
    v13 = *(__int64 **)(v8 + 40);
    *(_QWORD *)(v8 + 40) = *v13;
LABEL_11:
    v16 = *(_DWORD *)(v8 + 52);
    *v13 = v8;
    v17 = *(_QWORD *)(v8 + 40);
    *(_DWORD *)(v8 + 52) = v16 + 1;
    if ( !v17 && (v11 & 0x80000000) != 0 )
    {
      *v9 = *(_QWORD *)(v8 + 8);
      v18 = *(_QWORD **)(v8 + 8);
      if ( v18 )
        *v18 = 0LL;
      *(_QWORD *)(v8 + 8) = 0LL;
    }
    v15 = v13 + 1;
    goto LABEL_17;
  }
  v14 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64))(v6 + 16))(*(_QWORD *)(v6 + 24), 0LL, 0LL, a2);
  v15 = (_QWORD *)v14;
  if ( a2 && !v14 )
    sub_54ECF70(a1, 4LL);
LABEL_17:
  v19 = v6 + 8LL * a3;
  v20 = *(void (__fastcall **)(__int64, _QWORD, __int64))(v6 + 3360);
  v21 = *(_QWORD *)(v19 + 760) + a2;
  *(_QWORD *)(v6 + 72) += a2;
  *(_QWORD *)(v19 + 760) = v21;
  if ( v20 )
    v20(a1, 0LL, a2);
  return v15;
}


================================================================================
Function: sub_54F2B70 (0x54F2B70)
================================================================================

__int64 __fastcall sub_54F2B70(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v6; // x23
  __int64 v7; // x24
  __int64 v8; // x0
  __int64 v9; // x8
  __int64 v10; // x22
  __int64 v11; // x9
  int v12; // w10
  int v13; // w22
  __int64 v14; // x0
  __int64 v15; // x8
  __int64 v16; // x9
  void (__fastcall *v17)(__int64, _QWORD, __int64); // x8
  __int64 v18; // x10
  __int64 v20; // x9
  int v21; // w10
  _QWORD *v22; // x8

  v6 = *(_QWORD *)(a1 + 24);
  if ( (unsigned __int64)(a2 - 1) <= 0x3FF && (byte_6F11E20[a2 + 160] & 0x80000000) == 0 )
  {
    v7 = v6 + 8LL * (unsigned __int8)byte_6F11E20[a2 + 160];
    v8 = *(_QWORD *)(v7 + 416);
    if ( v8 )
    {
      v9 = *(unsigned int *)(v8 + 48);
      if ( (v9 & 0x80000000) == 0 )
        goto LABEL_5;
    }
    else
    {
      v8 = sub_54F3354(a1, v6 + 416, v6 + 744);
      v9 = *(unsigned int *)(v8 + 48);
      if ( (v9 & 0x80000000) == 0 )
      {
LABEL_5:
        v10 = v8 + v9 + 56;
        LODWORD(v9) = v9 - *(_DWORD *)(v8 + 36);
        v11 = *(_QWORD *)(v8 + 40);
        v12 = *(_DWORD *)(v8 + 52) + 1;
        *(_DWORD *)(v8 + 48) = v9;
        *(_DWORD *)(v8 + 52) = v12;
        if ( v11 )
          goto LABEL_11;
        goto LABEL_16;
      }
    }
    v10 = *(_QWORD *)(v8 + 40);
    v20 = *(_QWORD *)(v10 + 8);
    v21 = *(_DWORD *)(v8 + 52) + 1;
    *(_QWORD *)(v8 + 40) = v20;
    *(_DWORD *)(v8 + 52) = v21;
    if ( v20 )
      goto LABEL_11;
LABEL_16:
    if ( (v9 & 0x80000000) != 0 )
    {
      *(_QWORD *)(v7 + 416) = *(_QWORD *)(v8 + 8);
      v22 = *(_QWORD **)(v8 + 8);
      if ( v22 )
        *v22 = 0LL;
      *(_QWORD *)(v8 + 8) = 0LL;
    }
    goto LABEL_11;
  }
  v13 = a2 + 56;
  v14 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(v6 + 16))(
          *(_QWORD *)(v6 + 24),
          0LL,
          0LL,
          (int)a2 + 56);
  if ( !v14 )
    sub_54ECF70(a1, 4LL);
  *(_QWORD *)(v14 + 40) = 0LL;
  *(_QWORD *)(v14 + 48) = 0LL;
  *(_DWORD *)(v14 + 32) = v13;
  *(_DWORD *)(v14 + 36) = a2;
  *(_OWORD *)v14 = 0u;
  *(_OWORD *)(v14 + 16) = 0u;
  v15 = *(_QWORD *)(v6 + 744);
  *(_QWORD *)(v14 + 24) = v15;
  if ( v15 )
    *(_QWORD *)(v15 + 16) = v14;
  v10 = v14 + 56;
  *(_QWORD *)(v6 + 744) = v14;
  *(_DWORD *)(v14 + 48) = -(int)a2;
  *(_DWORD *)(v14 + 52) = 1;
LABEL_11:
  v16 = v6 + 8LL * a3;
  v17 = *(void (__fastcall **)(__int64, _QWORD, __int64))(v6 + 3360);
  v18 = *(_QWORD *)(v16 + 760) + a2;
  *(_QWORD *)(v6 + 72) += a2;
  *(_QWORD *)(v16 + 760) = v18;
  if ( v17 )
    v17(a1, 0LL, a2);
  return v10;
}


================================================================================
Function: sub_54F2D00 (0x54F2D00)
================================================================================

__int64 __fastcall sub_54F2D00(__int64 result, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v6; // x21
  unsigned int v7; // w9
  __int64 v8; // x1
  _QWORD *v9; // x8
  __int64 v10; // x10
  __int64 v11; // x8
  __int64 v12; // x10
  __int64 v13; // x10
  _QWORD *v14; // x10
  _QWORD *v15; // x11
  _QWORD *v16; // t1
  int v17; // w11
  _QWORD *v18; // x8
  _QWORD *v19; // x9
  __int64 v20; // x9
  __int64 v21; // t1

  v6 = *(_QWORD *)(result + 24);
  if ( (unsigned __int64)(a3 - 1) > 0x3FF || (v7 = byte_6F11E20[a3 + 160], (v7 & 0x80000000) != 0) )
  {
    result = (*(__int64 (__fastcall **)(_QWORD))(v6 + 16))(*(_QWORD *)(v6 + 24));
  }
  else
  {
    v9 = (_QWORD *)(a2 - 8);
    v8 = *(_QWORD *)(a2 - 8);
    v10 = *(_QWORD *)(v8 + 40);
    if ( !v10 )
    {
      if ( (*(_DWORD *)(v8 + 48) & 0x80000000) != 0 )
      {
        v13 = v6 + 8LL * v7;
        v16 = *(_QWORD **)(v13 + 96);
        v14 = (_QWORD *)(v13 + 96);
        v15 = v16;
        *(_QWORD *)(v8 + 8) = v16;
        if ( v16 )
          *v15 = v8;
        *v14 = v8;
        v10 = *(_QWORD *)(v8 + 40);
      }
      else
      {
        v10 = 0LL;
      }
    }
    v17 = *(_DWORD *)(v8 + 52);
    *v9 = v10;
    *(_QWORD *)(v8 + 40) = v9;
    *(_DWORD *)(v8 + 52) = --v17;
    if ( !v17 )
    {
      v18 = *(_QWORD **)(v8 + 8);
      if ( v18 )
        *v18 = *(_QWORD *)v8;
      if ( *(_QWORD *)v8 )
      {
        v19 = (_QWORD *)(*(_QWORD *)v8 + 8LL);
      }
      else
      {
        v20 = v6 + 8LL * v7;
        v21 = *(_QWORD *)(v20 + 96);
        v19 = (_QWORD *)(v20 + 96);
        if ( v21 != v8 )
          goto LABEL_18;
      }
      *v19 = v18;
LABEL_18:
      result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)(result + 24) + 16LL))(*(_QWORD *)(*(_QWORD *)(result + 24)
                                                                                               + 24LL));
    }
  }
  v11 = v6 + 8LL * a4;
  v12 = *(_QWORD *)(v11 + 760) - a3;
  *(_QWORD *)(v6 + 72) -= a3;
  *(_QWORD *)(v11 + 760) = v12;
  return result;
}


================================================================================
Function: sub_54F2E14 (0x54F2E14)
================================================================================

__int64 __fastcall sub_54F2E14(__int64 result, __int64 a2, __int64 a3, unsigned __int8 a4, __int64 a5)
{
  __int64 v7; // x21
  unsigned int v8; // w9
  __int64 v9; // x10
  __int64 v10; // x8
  __int64 v11; // x8
  __int64 v12; // x9
  _QWORD *v13; // x10
  __int64 v14; // x9
  __int64 v15; // x10
  _QWORD *v16; // x11
  _QWORD *v17; // x10
  int v18; // w11
  _QWORD *v19; // x10
  _QWORD *v20; // x9
  __int64 v21; // x9
  __int64 v22; // x10
  __int64 v23; // x11
  _QWORD *v24; // x8
  __int64 v25; // x8
  __int64 v26; // x10

  v7 = *(_QWORD *)(result + 24);
  if ( (unsigned __int64)(a3 - 1) > 0x3FF || (v8 = byte_6F11E20[a3 + 160], (v8 & 0x80000000) != 0) )
  {
    v11 = *(_QWORD *)(a5 + 24);
    if ( v11 )
      *(_QWORD *)(v11 + 16) = *(_QWORD *)(a5 + 16);
    v12 = *(_QWORD *)(a5 + 16);
    if ( v12 )
    {
      v13 = (_QWORD *)(v12 + 24);
    }
    else
    {
      v13 = (_QWORD *)(v7 + 744);
      v14 = v7;
      if ( *(_QWORD *)(v7 + 744) != a5 )
        goto LABEL_29;
    }
    v14 = v7;
    *v13 = v11;
LABEL_29:
    result = (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD))(v14 + 16))(
               *(_QWORD *)(v14 + 24),
               a5,
               *(int *)(a5 + 32),
               0LL);
    goto LABEL_30;
  }
  *(_BYTE *)a2 = 0;
  v9 = *(_QWORD *)(a5 + 40);
  v10 = *(_QWORD *)(result + 24);
  if ( !v9 )
  {
    if ( (*(_DWORD *)(a5 + 48) & 0x80000000) != 0 )
    {
      v15 = v10 + 8LL * v8;
      v16 = *(_QWORD **)(v15 + 416);
      v17 = (_QWORD *)(v15 + 416);
      *(_QWORD *)(a5 + 8) = v16;
      if ( v16 )
        *v16 = a5;
      *v17 = a5;
      v9 = *(_QWORD *)(a5 + 40);
    }
    else
    {
      v9 = 0LL;
    }
  }
  v18 = *(_DWORD *)(a5 + 52);
  *(_QWORD *)(a2 + 8) = v9;
  *(_QWORD *)(a5 + 40) = a2;
  *(_DWORD *)(a5 + 52) = --v18;
  if ( !v18 )
  {
    v19 = *(_QWORD **)(a5 + 8);
    if ( v19 )
      *v19 = *(_QWORD *)a5;
    if ( *(_QWORD *)a5 )
    {
      v20 = (_QWORD *)(*(_QWORD *)a5 + 8LL);
    }
    else
    {
      v21 = v10 + 8LL * v8;
      if ( *(_QWORD *)(v21 + 416) != a5 )
        goto LABEL_23;
      v20 = (_QWORD *)(v21 + 416);
    }
    *v20 = v19;
LABEL_23:
    v22 = *(_QWORD *)(a5 + 24);
    v14 = *(_QWORD *)(result + 24);
    if ( v22 )
      *(_QWORD *)(v22 + 16) = *(_QWORD *)(a5 + 16);
    v23 = *(_QWORD *)(a5 + 16);
    if ( v23 )
    {
      v24 = (_QWORD *)(v23 + 24);
    }
    else
    {
      v24 = (_QWORD *)(v10 + 744);
      if ( *v24 != a5 )
        goto LABEL_29;
    }
    *v24 = v22;
    goto LABEL_29;
  }
LABEL_30:
  v25 = v7 + 8LL * a4;
  v26 = *(_QWORD *)(v25 + 760) - a3;
  *(_QWORD *)(v7 + 72) -= a3;
  *(_QWORD *)(v25 + 760) = v26;
  return result;
}


================================================================================
Function: sub_54F2F9C (0x54F2F9C)
================================================================================

void *__fastcall sub_54F2F9C(__int64 a1, char *a2, size_t a3, size_t a4, unsigned __int8 a5)
{
  unsigned int v10; // w3
  __int64 v11; // x25
  unsigned int v12; // w26
  __int64 v13; // x0
  void *v14; // x24
  __int64 v15; // x24
  __int64 v16; // x0
  _QWORD *v17; // x24
  __int64 v18; // t1
  __int64 v19; // x9
  __int64 v20; // x10
  __int64 *v21; // x8
  __int64 v22; // x0
  _BOOL4 v23; // w8
  int v24; // w10
  __int64 v25; // x11
  _QWORD *v26; // x9
  size_t v27; // x2
  __int64 v28; // x1
  char *v29; // x23
  __int64 v30; // t1
  __int64 v31; // x8
  __int64 v32; // x9
  __int64 v33; // x9
  _QWORD *v34; // x9
  _QWORD *v35; // x10
  _QWORD *v36; // t1
  int v37; // w10
  _QWORD *v38; // x9
  _QWORD *v39; // x8
  __int64 v40; // x8
  __int64 v41; // t1
  __int64 v42; // x9
  void (__fastcall *v43)(__int64, size_t, size_t); // x8
  size_t v44; // x10

  if ( a4 - 1 > 0x3FF )
    v10 = -1;
  else
    v10 = byte_6F11E20[a4 + 160];
  v11 = *(_QWORD *)(a1 + 24);
  if ( a3 - 1 > 0x3FF )
  {
    v12 = -1;
    if ( (v10 & 0x80000000) == 0 )
      goto LABEL_12;
  }
  else
  {
    v12 = byte_6F11E20[a3 + 160];
    if ( (v10 & 0x80000000) == 0 )
      goto LABEL_12;
  }
  if ( (v12 & 0x80000000) != 0 )
  {
    v13 = (*(__int64 (__fastcall **)(_QWORD, char *, size_t, size_t))(v11 + 16))(*(_QWORD *)(v11 + 24), a2, a3, a4);
    v14 = (void *)v13;
    if ( !a4 || v13 )
      goto LABEL_49;
    goto LABEL_18;
  }
LABEL_12:
  if ( (v10 & 0x80000000) != 0 )
  {
    v22 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, size_t))(v11 + 16))(*(_QWORD *)(v11 + 24), 0LL, 0LL, a4);
    v14 = (void *)v22;
    v23 = a4 != 0;
    if ( !a4 || v22 )
      goto LABEL_27;
LABEL_18:
    sub_54ECF70(a1, 4LL);
  }
  v15 = v11 + 8LL * v10;
  v18 = *(_QWORD *)(v15 + 96);
  v17 = (_QWORD *)(v15 + 96);
  v16 = v18;
  if ( v18 )
  {
    v19 = *(unsigned int *)(v16 + 48);
    if ( (v19 & 0x80000000) == 0 )
    {
LABEL_15:
      v20 = v16 + v19;
      LODWORD(v19) = v19 - *(_DWORD *)(v16 + 36);
      v21 = (__int64 *)(v20 + 56);
      *(_DWORD *)(v16 + 48) = v19;
      goto LABEL_21;
    }
  }
  else
  {
    v16 = sub_54F3354(a1, v11 + 96, 0LL);
    v19 = *(unsigned int *)(v16 + 48);
    if ( (v19 & 0x80000000) == 0 )
      goto LABEL_15;
  }
  v21 = *(__int64 **)(v16 + 40);
  *(_QWORD *)(v16 + 40) = *v21;
LABEL_21:
  v24 = *(_DWORD *)(v16 + 52);
  *v21 = v16;
  v25 = *(_QWORD *)(v16 + 40);
  *(_DWORD *)(v16 + 52) = v24 + 1;
  if ( !v25 && (v19 & 0x80000000) != 0 )
  {
    *v17 = *(_QWORD *)(v16 + 8);
    v26 = *(_QWORD **)(v16 + 8);
    if ( v26 )
      *v26 = 0LL;
    *(_QWORD *)(v16 + 8) = 0LL;
  }
  v14 = v21 + 1;
  v23 = a4 != 0;
LABEL_27:
  if ( a3 && v23 )
  {
    if ( a4 <= a3 )
      v27 = a4;
    else
      v27 = a3;
    memcpy(v14, a2, v27);
  }
  if ( (v12 & 0x80000000) != 0 )
  {
    (*(void (__fastcall **)(_QWORD, char *, size_t, _QWORD))(v11 + 16))(*(_QWORD *)(v11 + 24), a2, a3, 0LL);
    goto LABEL_49;
  }
  v30 = *((_QWORD *)a2 - 1);
  v29 = a2 - 8;
  v28 = v30;
  v31 = *(_QWORD *)(a1 + 24);
  v32 = *(_QWORD *)(v30 + 40);
  if ( !v32 )
  {
    if ( (*(_DWORD *)(v28 + 48) & 0x80000000) != 0 )
    {
      v33 = v31 + 8LL * v12;
      v36 = *(_QWORD **)(v33 + 96);
      v34 = (_QWORD *)(v33 + 96);
      v35 = v36;
      *(_QWORD *)(v28 + 8) = v36;
      if ( v36 )
        *v35 = v28;
      *v34 = v28;
      v32 = *(_QWORD *)(v28 + 40);
    }
    else
    {
      v32 = 0LL;
    }
  }
  v37 = *(_DWORD *)(v28 + 52);
  *(_QWORD *)v29 = v32;
  *(_QWORD *)(v28 + 40) = v29;
  *(_DWORD *)(v28 + 52) = --v37;
  if ( !v37 )
  {
    v38 = *(_QWORD **)(v28 + 8);
    if ( v38 )
      *v38 = *(_QWORD *)v28;
    if ( *(_QWORD *)v28 )
    {
      v39 = (_QWORD *)(*(_QWORD *)v28 + 8LL);
    }
    else
    {
      v40 = v31 + 8LL * v12;
      v41 = *(_QWORD *)(v40 + 96);
      v39 = (_QWORD *)(v40 + 96);
      if ( v41 != v28 )
        goto LABEL_48;
    }
    *v39 = v38;
LABEL_48:
    (*(void (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD))(*(_QWORD *)(a1 + 24) + 16LL))(
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24LL),
      v28,
      *(int *)(v28 + 32),
      0LL);
  }
LABEL_49:
  v42 = v11 + 8LL * a5;
  v43 = *(void (__fastcall **)(__int64, size_t, size_t))(v11 + 3360);
  v44 = a4 - a3 + *(_QWORD *)(v42 + 760);
  *(_QWORD *)(v11 + 72) += a4 - a3;
  *(_QWORD *)(v42 + 760) = v44;
  if ( v43 )
    v43(a1, a3, a4);
  return v14;
}


================================================================================
Function: sub_54F323C (0x54F323C)
================================================================================

int *__fastcall sub_54F323C(int *result, _QWORD *a2, __int64 *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int64 v5; // x10
  unsigned __int64 v6; // x9
  __int64 v7; // x11
  __int64 v8; // x8
  __int64 v9; // x9

  v5 = result[9];
  v6 = result[8] - 56LL;
  v7 = (__int64)result + result[12] + 56;
  *a4 = result[13];
  v8 = (__int64)result + v5 * (int)(v6 / v5) + 56;
  v9 = v7 + v5;
  LODWORD(v5) = result[9];
  *a2 = v9;
  *a3 = v8;
  *a5 = v5;
  return result;
}


================================================================================
Function: sub_54F327C (0x54F327C)
================================================================================

__int64 __fastcall sub_54F327C(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}


================================================================================
Function: sub_54F3354 (0x54F3354)
================================================================================

__int64 __fastcall sub_54F3354(__int64 a1, __int64 a2, __int64 *a3, unsigned __int8 a4, char a5)
{
  __int64 v5; // x23
  int v7; // w24
  __int64 v10; // x21
  int v11; // w25
  __int64 result; // x0
  __int64 v13; // x8

  v5 = a4;
  v7 = *(_DWORD *)&byte_6F11E20[4 * a4];
  if ( v7 <= 512 )
    v10 = 16360LL;
  else
    v10 = 32744LL;
  if ( (a5 & 1) != 0 )
    v11 = 8;
  else
    v11 = 0;
  result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64))(*(_QWORD *)(a1 + 24) + 16LL))(
             *(_QWORD *)(*(_QWORD *)(a1 + 24) + 24LL),
             0LL,
             0LL,
             v10);
  if ( !result )
    sub_54ECF70(a1, 4);
  *(_QWORD *)(result + 40) = 0LL;
  *(_DWORD *)(result + 32) = v10;
  *(_DWORD *)(result + 36) = v7 + v11;
  *(_OWORD *)result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_QWORD *)(result + 48) = ((unsigned int)((v10 - 56) / (unsigned __int64)(v7 + v11)) - 1) * (v7 + v11);
  if ( a3 )
  {
    v13 = *a3;
    *(_QWORD *)(result + 24) = *a3;
    if ( v13 )
      *(_QWORD *)(v13 + 16) = result;
    *a3 = result;
  }
  *(_QWORD *)(a2 + 8 * v5) = result;
  return result;
}


================================================================================
Function: sub_54F39AC (0x54F39AC)
================================================================================

__int64 __fastcall sub_54F39AC(unsigned int a1)
{
  int v1; // w8
  unsigned int v2; // w9
  unsigned int v3; // w10

  v1 = -1;
  if ( a1 >= 0x100 )
  {
    v2 = a1;
    do
    {
      a1 = v2 >> 8;
      v3 = HIWORD(v2);
      v1 += 8;
      v2 >>= 8;
    }
    while ( v3 );
  }
  return v1 + (unsigned int)byte_1020EB0[a1];
}


================================================================================
Function: sub_54F3AA4 (0x54F3AA4)
================================================================================

__int64 __fastcall sub_54F3AA4(__int64 a1, __int64 a2)
{
  int v2; // w9
  unsigned int v3; // w8
  float v4; // w8
  float v5; // w9
  bool v6; // zf
  __int64 result; // x0

  v2 = *(_DWORD *)(a1 + 12) & 0xF;
  if ( v2 != *(_DWORD *)(a2 + 12) )
    return 0LL;
  v3 = 1;
  switch ( v2 )
  {
    case 0:
      goto LABEL_15;
    case 1:
      v4 = *(float *)a1;
      v5 = *(float *)a2;
      goto LABEL_7;
    case 2:
      if ( *(_QWORD *)a1 != *(_QWORD *)a2 )
        return 0LL;
      v4 = *(float *)(a1 + 8);
      v5 = *(float *)(a2 + 8);
LABEL_7:
      v6 = LODWORD(v4) == LODWORD(v5);
      goto LABEL_12;
    case 3:
      v6 = *(double *)a1 == *(double *)a2;
      goto LABEL_12;
    case 4:
      if ( *(float *)a1 != *(float *)a2 || *(float *)(a1 + 4) != *(float *)(a2 + 4) )
        return 0LL;
      v6 = *(float *)(a1 + 8) == *(float *)(a2 + 8);
      goto LABEL_12;
    default:
      v6 = *(_QWORD *)a1 == *(_QWORD *)a2;
LABEL_12:
      v3 = v6;
LABEL_15:
      result = v3;
      break;
  }
  return result;
}


================================================================================
Function: sub_54F3C4C (0x54F3C4C)
================================================================================

__int64 __fastcall sub_54F3C4C(__int64 a1, char *format, _OWORD *a3)
{
  __int128 v4; // q1
  __int64 v5; // x21
  size_t v6; // x0
  _QWORD *v7; // x8
  _OWORD v9[2]; // [xsp+0h] [xbp-230h] BYREF
  int s[128]; // [xsp+28h] [xbp-208h] BYREF

  v4 = a3[1];
  v9[0] = *a3;
  v9[1] = v4;
  vsnprintf((char *)s, 0x200uLL, format, v9);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = __strlen_chk((const char *)s, 0x200uLL);
  *(_QWORD *)v5 = sub_54F51DC(a1, s, v6);
  *(_DWORD *)(v5 + 12) = 5;
  v7 = *(_QWORD **)(a1 + 8);
  if ( (__int64)(*(_QWORD *)(a1 + 40) - (_QWORD)v7) <= 16 )
  {
    sub_54ED1D0();
    v7 = *(_QWORD **)(a1 + 8);
  }
  *(_QWORD *)(a1 + 8) = v7 + 2;
  return *v7 + 24LL;
}


================================================================================
Function: sub_54F3D1C (0x54F3D1C)
================================================================================

__int64 sub_54F3D1C(__int64 a1, char *format, ...)
{
  __int64 v3; // x21
  size_t v4; // x0
  _QWORD *v5; // x8
  gcc_va_list va; // [xsp+B0h] [xbp-250h] BYREF
  gcc_va_list arg; // [xsp+D0h] [xbp-230h] BYREF
  int s[128]; // [xsp+F8h] [xbp-208h] BYREF

  va_start(va, format);
  va_copy(arg, va);
  vsnprintf((char *)s, 0x200uLL, format, arg);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = __strlen_chk((const char *)s, 0x200uLL);
  *(_QWORD *)v3 = sub_54F51DC(a1, s, v4);
  *(_DWORD *)(v3 + 12) = 5;
  v5 = *(_QWORD **)(a1 + 8);
  if ( (__int64)(*(_QWORD *)(a1 + 40) - (_QWORD)v5) <= 16 )
  {
    sub_54ED1D0();
    v5 = *(_QWORD **)(a1 + 8);
  }
  *(_QWORD *)(a1 + 8) = v5 + 2;
  return *v5 + 24LL;
}


================================================================================
Function: sub_54F3E30 (0x54F3E30)
================================================================================

char *__fastcall sub_54F3E30(char *dest, unsigned __int64 a2, char *s, unsigned __int64 a4)
{
  int v4; // w8
  char *v7; // x19
  size_t v8; // x0
  size_t v9; // x2
  char *v10; // x0

  v4 = (unsigned __int8)*s;
  v7 = dest;
  if ( v4 == 64 )
  {
    if ( a4 <= a2 )
    {
      return s + 1;
    }
    else
    {
      dest[2] = 46;
      *(_WORD *)dest = 11822;
      memcpy(dest + 3, &s[a4 - a2 + 4], a2 - 4);
      v7[a2 - 1] = 0;
    }
  }
  else if ( v4 == 61 )
  {
    if ( a4 <= a2 )
    {
      return s + 1;
    }
    else
    {
      memcpy(dest, s + 1, a2 - 1);
      v7[a2 - 1] = 0;
    }
  }
  else
  {
    v8 = strcspn(s, "\n\r");
    if ( v8 <= a2 - 15 )
      v9 = v8;
    else
      v9 = a2 - 15;
    strcpy(v7, "[string \"");
    if ( s[v9] )
    {
      v10 = strncat(v7, s, v9);
      *(_DWORD *)&v7[strlen(v10)] = 3026478;
    }
    else
    {
      strcat(v7, s);
    }
    strcpy(&v7[strlen(v7)], "\"]");
  }
  return v7;
}


================================================================================
Function: sub_54F4728 (0x54F4728)
================================================================================

double sub_54F4728()
{
  unsigned __int8 v0; // w8
  __int64 v2; // [xsp+8h] [xbp-18h] BYREF
  __int64 v3; // [xsp+10h] [xbp-10h]

  v0 = atomic_load(byte_6F122D0);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0(byte_6F122D0) )
  {
    qword_6F122C8 = 0x3E112E0BE826D695LL;
    sub_67EB838(byte_6F122D0);
  }
  clock_gettime(1, (struct timespec *)&v2);
  return ((double)v2 * 1000000000.0 + (double)v3) * *(double *)&qword_6F122C8;
}


================================================================================
Function: sub_54F49A4 (0x54F49A4)
================================================================================

__int64 __fastcall sub_54F49A4(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v6)(_QWORD, __int64); // x8

  v6 = *(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(a1 + 24) + 3312LL);
  if ( v6 )
    v6(0LL, a2);
  sub_54F2D00(a1, *(_QWORD *)(a2 + 64), 40LL * *(int *)(a2 + 76), *(_BYTE *)(a2 + 2));
  sub_54F2D00(a1, *(_QWORD *)(a2 + 48), 16LL * *(int *)(a2 + 72), *(_BYTE *)(a2 + 2));
  return sub_54F2E14(a1, a2, 128LL, *(unsigned __int8 *)(a2 + 2), a3);
}


================================================================================
Function: sub_54F4ED8 (0x54F4ED8)
================================================================================

__int64 __fastcall sub_54F4ED8(__int64 a1, unsigned int a2)
{
  __int64 v4; // x22
  _QWORD *v5; // x0
  _QWORD *v6; // x21
  __int64 v7; // x23
  __int64 v8; // x8
  __int64 i; // x9
  __int64 v10; // x11
  __int64 v11; // x14
  __int64 v12; // x12
  __int64 result; // x0

  if ( (a2 & 0x80000000) != 0 )
    sub_54F2A0C(a1);
  v4 = 8LL * a2;
  v5 = sub_54F2A20(a1, v4, 0);
  v6 = v5;
  v7 = *(_QWORD *)(a1 + 24);
  if ( a2 )
    memset(v5, 0, v4);
  v8 = *(unsigned int *)(v7 + 12);
  if ( (int)v8 >= 1 )
  {
    for ( i = 0LL; i != v8; ++i )
    {
      v10 = *(_QWORD *)(*(_QWORD *)v7 + 8 * i);
      if ( v10 )
      {
        do
        {
          v11 = *(_QWORD *)(v10 + 8);
          v12 = (int)(*(_DWORD *)(v10 + 16) & (a2 - 1));
          *(_QWORD *)(v10 + 8) = v6[v12];
          v6[v12] = v10;
          v10 = v11;
        }
        while ( v11 );
      }
    }
  }
  result = sub_54F2D00(a1, *(_QWORD *)v7, 8LL * (int)v8, 0);
  *(_DWORD *)(v7 + 12) = a2;
  *(_QWORD *)v7 = v6;
  return result;
}


================================================================================
Function: sub_54F51DC (0x54F51DC)
================================================================================

__int64 __fastcall sub_54F51DC(__int64 a1, int *a2, size_t a3)
{
  int v6; // w10
  int v7; // w11
  unsigned int v8; // w24
  unsigned __int64 v9; // x8
  int *v10; // x9
  int v11; // w12
  int v12; // w15
  int v13; // t1
  unsigned int v14; // w12
  unsigned __int64 v15; // t2
  char *v16; // x9
  int v17; // w10
  __int64 v18; // x23
  __int64 v19; // x22
  __int64 v20; // x0
  char v21; // w10
  __int64 v22; // x23
  char v23; // w8
  __int64 *v24; // x10
  int v25; // w8
  __int64 v26; // x12
  unsigned int v27; // w9
  __int64 v28; // x11
  char v29; // w8

  if ( a3 < 0x20 )
  {
    v8 = a3;
    v9 = a3;
    v10 = a2;
    if ( !a3 )
    {
      v8 = 0;
      goto LABEL_8;
    }
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = a3;
    v9 = a3;
    v10 = a2;
    do
    {
      v12 = v10[1];
      v11 = v10[2];
      v13 = *v10;
      v10 += 3;
      v9 -= 12LL;
      v14 = v11 + v8;
      HIDWORD(v15) = v14;
      LODWORD(v15) = v14;
      v7 = (v14 ^ (v13 + v7)) - (v15 >> 14);
      HIDWORD(v15) = v7;
      LODWORD(v15) = v7;
      v6 = (v7 ^ (v12 + v6)) - (v15 >> 11);
      HIDWORD(v15) = v6;
      LODWORD(v15) = v6;
      v8 = (v6 ^ v14) - (v15 >> 25);
    }
    while ( v9 > 0x1F );
  }
  v16 = (char *)v10 - 1;
  do
  {
    v17 = (unsigned __int8)v16[v9--];
    v8 ^= 32 * v8 + (v8 >> 2) + v17;
  }
  while ( v9 );
LABEL_8:
  v18 = *(_QWORD *)(a1 + 24);
  v19 = *(_QWORD *)(*(_QWORD *)v18 + 8LL * (int)((*(_DWORD *)(v18 + 12) - 1) & v8));
  if ( v19 )
  {
    while ( *(_DWORD *)(v19 + 20) != a3 || memcmp(a2, (const void *)(v19 + 24), a3) )
    {
      v19 = *(_QWORD *)(v19 + 8);
      if ( !v19 )
        goto LABEL_9;
    }
    v29 = *(_BYTE *)(v19 + 1);
    if ( (v29 & 0xB) == (~*(_BYTE *)(v18 + 32) & 3) )
      *(_BYTE *)(v19 + 1) = v29 ^ 3;
  }
  else
  {
LABEL_9:
    if ( a3 >= 0x40000001 )
      sub_54F2A0C(a1);
    v20 = sub_54F2B70(a1, a3 + 25, *(unsigned __int8 *)(a1 + 4));
    v21 = *(_BYTE *)(a1 + 4);
    v22 = v20 + 24;
    v19 = v20;
    v23 = *(_BYTE *)(*(_QWORD *)(a1 + 24) + 32LL);
    *(_BYTE *)v20 = 5;
    *(_BYTE *)(v20 + 2) = v21;
    *(_DWORD *)(v20 + 4) = -32768;
    *(_DWORD *)(v20 + 16) = v8;
    *(_DWORD *)(v20 + 20) = a3;
    *(_BYTE *)(v20 + 1) = v23 & 3;
    memcpy((void *)(v20 + 24), a2, a3);
    *(_BYTE *)(v22 + a3) = 0;
    v24 = *(__int64 **)(a1 + 24);
    v25 = *((_DWORD *)v24 + 3);
    v26 = *v24;
    v27 = *((_DWORD *)v24 + 2) + 1;
    v28 = 8LL * ((v25 - 1) & v8);
    *((_DWORD *)v24 + 2) = v27;
    *(_QWORD *)(v19 + 8) = *(_QWORD *)(v26 + v28);
    *(_QWORD *)(v26 + v28) = v19;
    if ( v25 <= 0x3FFFFFFF && v27 > v25 )
      sub_54F4ED8(a1, (unsigned int)(2 * v25));
  }
  return v19;
}


================================================================================
Function: sub_54F8B60 (0x54F8B60)
================================================================================

__int64 __fastcall sub_54F8B60(__int64 a1, int a2, __int64 a3)
{
  void *v3; // x9
  _BOOL4 v4; // w11
  int v5; // w13
  __int64 v6; // x15
  char *v7; // x17
  __int64 v8; // x8
  double v9; // x17
  unsigned __int64 v10; // x1
  int v11; // w1
  int v12; // w2

  v3 = *(void **)(a1 + 32);
  if ( v3 == &unk_10210B0 )
  {
    v4 = *(_DWORD *)(a1 + 8) > a2;
    if ( !a3 )
      goto LABEL_9;
  }
  else
  {
    v4 = 1;
    if ( !a3 )
      goto LABEL_9;
  }
  if ( *(_DWORD *)(a3 + 12) == 3 )
  {
    if ( *(double *)a3 == (double)(int)*(double *)a3 )
      v5 = (int)*(double *)a3;
    else
      v5 = -1;
    goto LABEL_10;
  }
LABEL_9:
  v5 = -1;
LABEL_10:
  v6 = a2;
  do
  {
    do
      v8 = v6++;
    while ( v5 == (_DWORD)v6 );
    if ( !v4 )
      break;
    if ( *(_DWORD *)(a1 + 8) > (unsigned int)v8 )
    {
      v7 = (char *)(*(_QWORD *)(a1 + 24) + 16 * v8);
    }
    else if ( v3 == &unk_10210B0 )
    {
LABEL_22:
      v7 = (char *)&unk_1020EA0;
    }
    else
    {
      v9 = (double)(int)v6;
      v10 = HIDWORD(COERCE_UNSIGNED_INT64((double)(int)v6)) & 0x7FFFFFFF;
      v11 = (1540483477
           * ((1540483477 * (v10 ^ ((1540483477 * (LODWORD(v9) ^ ((unsigned int)v10 >> 18))) >> 22))) ^ ((1540483477 * ((1540483477 * (LODWORD(v9) ^ ((unsigned int)v10 >> 18))) ^ ((1540483477 * ((unsigned int)v10 ^ ((1540483477 * (LODWORD(v9) ^ ((unsigned int)v10 >> 18))) >> 22))) >> 17))) >> 19))) & ~(-1 << *(_BYTE *)(a1 + 6));
      v7 = *(char **)(a1 + 32);
      while ( 1 )
      {
        v7 += 32 * v11;
        v12 = *((_DWORD *)v7 + 7);
        if ( (v12 & 0xF) == 3 && *((double *)v7 + 2) == (double)(int)v6 )
          break;
        v11 = v12 >> 4;
        if ( (unsigned int)v12 <= 0xF )
          goto LABEL_22;
      }
    }
  }
  while ( *((_DWORD *)v7 + 3) );
  return (unsigned int)v8;
}


================================================================================
Function: sub_54F8C94 (0x54F8C94)
================================================================================

__int64 __fastcall sub_54F8C94(__int64 result, __int64 a2, int a3, int a4, long double a5, long double a6)
{
  __int64 v6; // x19
  int v7; // w23
  __int64 v8; // x26
  int v11; // w25
  void *v12; // x21
  __int64 v13; // x11
  unsigned __int64 v14; // x9
  __int64 v15; // x8
  _DWORD *v16; // x11
  unsigned __int64 v17; // x12
  __int64 v18; // x9
  __int64 v19; // x8
  _DWORD *v20; // x9
  int v21; // w0
  int v22; // w28
  __int64 v23; // x9
  __int64 v24; // x8
  __int64 v25; // x9
  __int64 v26; // x10
  __int64 v27; // x27
  long double *v28; // x0
  __int64 v29; // x24
  int v30; // w22
  int v31; // w23
  __int64 v32; // x25
  double v33; // x8
  int v34; // w8
  int v35; // w8
  double v36; // [xsp+8h] [xbp-18h] BYREF
  int v37; // [xsp+10h] [xbp-10h]
  int v38; // [xsp+14h] [xbp-Ch]

  v6 = result;
  if ( a3 > 0x4000000 )
    goto LABEL_43;
  v7 = a4;
  if ( a4 >= 67108865 )
    goto LABEL_43;
  v8 = *(int *)(a2 + 8);
  v11 = *(unsigned __int8 *)(a2 + 6);
  v12 = *(void **)(a2 + 32);
  if ( (int)v8 < a3 )
  {
    if ( a3 < 0 )
      goto LABEL_44;
    result = (__int64)sub_54F2F9C(result, *(char **)(a2 + 24), 16 * v8, 16LL * (unsigned int)a3, *(_BYTE *)(a2 + 2));
    v13 = *(int *)(a2 + 8);
    *(_QWORD *)(a2 + 24) = result;
    if ( (int)v13 < a3 )
    {
      v14 = (unsigned int)a3 - v13;
      v15 = v13;
      if ( v14 < 2 )
        goto LABEL_10;
      v15 = (v14 & 0xFFFFFFFFFFFFFFFELL) + v13;
      v16 = (_DWORD *)(result + 16 * v13 + 28);
      v17 = v14 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v17 -= 2LL;
        *(v16 - 4) = 0;
        *v16 = 0;
        v16 += 8;
      }
      while ( v17 );
      if ( v14 != (v14 & 0xFFFFFFFFFFFFFFFELL) )
      {
LABEL_10:
        v18 = result + 16 * v15;
        v19 = (unsigned int)a3 - v15;
        v20 = (_DWORD *)(v18 + 12);
        do
        {
          --v19;
          *v20 = 0;
          v20 += 4;
        }
        while ( v19 );
      }
    }
    *(_DWORD *)(a2 + 8) = a3;
  }
  if ( !v7 )
  {
    v22 = 0;
    *(_QWORD *)(a2 + 32) = &unk_10210B0;
    goto LABEL_23;
  }
  v21 = sub_54F39AC(v7 - 1);
  if ( v21 >= 26 )
LABEL_43:
    sub_54EC328(v6, "table overflow");
  LOBYTE(v7) = v21 + 1;
  v22 = 1 << (v21 + 1);
  result = (__int64)sub_54F2A20(v6, 32LL * v22, *(_BYTE *)(a2 + 2));
  *(_QWORD *)(a2 + 32) = result;
  if ( v22 <= 1 )
    v23 = 1LL;
  else
    v23 = (unsigned int)v22;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 12) = 0;
  if ( v22 >= 2 )
  {
    v24 = 0LL;
    v25 = 32 * v23 - 32;
    do
    {
      v26 = *(_QWORD *)(a2 + 32) + v24;
      v24 += 32LL;
      *(_DWORD *)(v26 + 60) = 0;
      *(_DWORD *)(v26 + 44) = 0;
    }
    while ( v25 != v24 );
  }
LABEL_23:
  *(_BYTE *)(a2 + 6) = v7;
  *(_DWORD *)(a2 + 12) = v22;
  *(_BYTE *)(a2 + 7) = ~(-1 << v7);
  if ( (int)v8 <= a3 )
    goto LABEL_30;
  v27 = a3;
  *(_DWORD *)(a2 + 8) = a3;
  do
  {
    while ( 1 )
    {
      v29 = *(_QWORD *)(a2 + 24);
      if ( !*(_DWORD *)(v29 + 16 * v27 + 12) )
        break;
      v38 = 3;
      *(double *)&a5 = (double)((int)v27 + 1);
      v36 = *(double *)&a5;
      v28 = (long double *)sub_54F9798(v6, a2, &v36, a5, a6);
      a5 = *(long double *)(v29 + 16 * v27++);
      *v28 = a5;
      if ( (_DWORD)v27 == (_DWORD)v8 )
        goto LABEL_28;
    }
    ++v27;
  }
  while ( (_DWORD)v27 != (_DWORD)v8 );
LABEL_28:
  if ( a3 < 0 )
LABEL_44:
    sub_54F2A0C(v6);
  result = (__int64)sub_54F2F9C(v6, *(char **)(a2 + 24), 16 * v8, 16LL * (unsigned int)a3, *(_BYTE *)(a2 + 2));
  *(_QWORD *)(a2 + 24) = result;
LABEL_30:
  v30 = 1 << v11;
  if ( v11 != 31 )
  {
    v31 = v30 + 1;
    v32 = (__int64)v12 + 32 * (unsigned int)(v30 - 1) + 16;
    do
    {
      if ( *(_DWORD *)(v32 - 4) )
      {
        v33 = *(double *)v32;
        v36 = *(double *)v32;
        v37 = *(_DWORD *)(v32 + 8);
        v38 = *(_DWORD *)(v32 + 12) & 0xF;
        if ( v38 == 3
          && (*(double *)&a5 = v33, v34 = (int)v33, *(double *)&a6 = (double)v34, *(double *)&a5 == (double)v34)
          && (v35 = v34 - 1, (unsigned int)v35 < *(_DWORD *)(a2 + 8)) )
        {
          result = *(_QWORD *)(a2 + 24) + 16LL * v35;
        }
        else
        {
          result = sub_54F9798(v6, a2, &v36, a5, a6);
        }
        a5 = *(long double *)(v32 - 16);
        *(long double *)result = a5;
      }
      --v31;
      v32 -= 32LL;
    }
    while ( v31 > 1 );
  }
  if ( v12 != &unk_10210B0 )
    return sub_54F2D00(v6, (__int64)v12, 32LL * v30, *(_BYTE *)(a2 + 2));
  return result;
}


================================================================================
Function: sub_54F8FE0 (0x54F8FE0)
================================================================================

__int64 __fastcall sub_54F8FE0(__int64 a1, __int64 a2, unsigned int a3)
{
  return sub_54F8C94(a1, a2, *(unsigned int *)(a2 + 8), a3);
}


================================================================================
Function: sub_54F8FEC (0x54F8FEC)
================================================================================

__int64 __fastcall sub_54F8FEC(__int64 a1, unsigned int a2, int a3)
{
  __int64 v6; // x19
  __int64 v7; // x4
  char v8; // w8
  __int64 v9; // x0
  __int64 v10; // x11
  unsigned __int64 v11; // x9
  __int64 v12; // x8
  _DWORD *v13; // x11
  unsigned __int64 v14; // x12
  __int64 v15; // x9
  __int64 v16; // x8
  _DWORD *v17; // x9
  int v18; // w0
  char v19; // w21
  int v20; // w22
  _QWORD *v21; // x0
  __int64 v22; // x9
  __int64 v23; // x8
  __int64 v24; // x9
  __int64 v25; // x10

  v6 = sub_54F2B70(a1, 48LL, *(_BYTE *)(a1 + 4));
  v7 = *(unsigned __int8 *)(a1 + 4);
  v8 = *(_BYTE *)(*(_QWORD *)(a1 + 24) + 32LL);
  *(_QWORD *)(v6 + 16) = 0LL;
  *(_QWORD *)(v6 + 24) = 0LL;
  *(_BYTE *)v6 = 6;
  *(_BYTE *)(v6 + 3) = -1;
  *(_BYTE *)(v6 + 2) = v7;
  *(_QWORD *)(v6 + 8) = 0LL;
  *(_DWORD *)(v6 + 4) = 0;
  *(_BYTE *)(v6 + 1) = v8 & 3;
  *(_QWORD *)(v6 + 32) = &unk_10210B0;
  if ( (int)a2 >= 1 )
  {
    if ( a2 >= 0x4000001 )
      goto LABEL_21;
    v9 = sub_54F2F9C(a1, 0LL, 0LL, 16LL * a2, v7);
    v10 = *(int *)(v6 + 8);
    *(_QWORD *)(v6 + 24) = v9;
    if ( (int)v10 < (int)a2 )
    {
      v11 = a2 - v10;
      v12 = v10;
      if ( v11 < 2 )
        goto LABEL_8;
      v12 = (v11 & 0xFFFFFFFFFFFFFFFELL) + v10;
      v13 = (_DWORD *)(v9 + 16 * v10 + 28);
      v14 = v11 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        v14 -= 2LL;
        *(v13 - 4) = 0;
        *v13 = 0;
        v13 += 8;
      }
      while ( v14 );
      if ( v11 != (v11 & 0xFFFFFFFFFFFFFFFELL) )
      {
LABEL_8:
        v15 = v9 + 16 * v12;
        v16 = a2 - v12;
        v17 = (_DWORD *)(v15 + 12);
        do
        {
          --v16;
          *v17 = 0;
          v17 += 4;
        }
        while ( v16 );
      }
    }
    *(_DWORD *)(v6 + 8) = a2;
  }
  if ( a3 < 1 )
    return v6;
  v18 = sub_54F39AC((unsigned int)(a3 - 1));
  if ( v18 >= 26 )
LABEL_21:
    sub_54EC328(a1, "table overflow");
  v19 = v18 + 1;
  v20 = 1 << (v18 + 1);
  v21 = sub_54F2A20(a1, 32LL * v20, *(_BYTE *)(v6 + 2));
  *(_QWORD *)(v6 + 32) = v21;
  if ( v20 <= 1 )
    v22 = 1LL;
  else
    v22 = (unsigned int)v20;
  *((_DWORD *)v21 + 7) = 0;
  *((_DWORD *)v21 + 3) = 0;
  if ( v20 >= 2 )
  {
    v23 = 0LL;
    v24 = 32 * v22 - 32;
    do
    {
      v25 = *(_QWORD *)(v6 + 32) + v23;
      v23 += 32LL;
      *(_DWORD *)(v25 + 60) = 0;
      *(_DWORD *)(v25 + 44) = 0;
    }
    while ( v24 != v23 );
  }
  *(_BYTE *)(v6 + 6) = v19;
  *(_DWORD *)(v6 + 12) = v20;
  *(_BYTE *)(v6 + 7) = ~(-1 << v19);
  return v6;
}


================================================================================
Function: sub_54F9300 (0x54F9300)
================================================================================

char *__fastcall sub_54F9300(__int64 a1, __int64 a2)
{
  char v2; // w9
  char *result; // x0
  int v4; // w9
  int v5; // w10

  v2 = *(_BYTE *)(a1 + 6);
  result = *(char **)(a1 + 32);
  v4 = *(_DWORD *)(a2 + 16) & ~(-1 << v2);
  while ( 1 )
  {
    result += 32 * v4;
    v5 = *((_DWORD *)result + 7);
    if ( (v5 & 0xF) == 5 && *((_QWORD *)result + 2) == a2 )
      break;
    v4 = v5 >> 4;
    if ( (unsigned int)v5 <= 0xF )
      return (char *)&unk_1020EA0;
  }
  return result;
}


================================================================================
Function: sub_54F9360 (0x54F9360)
================================================================================

void *__fastcall sub_54F9360(__int64 a1, _DWORD *a2)
{
  int v2; // w8
  __int64 v4; // x19
  int v5; // w10
  int v6; // w11
  int v7; // w8
  double v8; // d0
  int v9; // w8
  unsigned int v10; // w8
  signed int v11; // w9
  int v12; // w10

  v2 = a2[3];
  if ( !v2 )
    return &unk_1020EA0;
  if ( v2 != 3 )
  {
    if ( v2 == 5 )
    {
      v4 = *(_QWORD *)(a1 + 32);
      v5 = *(_DWORD *)(*(_QWORD *)a2 + 16LL) & ~(-1 << *(_BYTE *)(a1 + 6));
      while ( 1 )
      {
        v4 += 32LL * v5;
        v6 = *(_DWORD *)(v4 + 28);
        if ( (v6 & 0xF) == 5 && *(_QWORD *)(v4 + 16) == *(_QWORD *)a2 )
          break;
        v5 = v6 >> 4;
        if ( (unsigned int)v6 < 0x10 )
          return &unk_1020EA0;
      }
      return (void *)v4;
    }
    goto LABEL_12;
  }
  v7 = (int)*(double *)a2;
  v8 = (double)v7;
  if ( *(double *)a2 != (double)v7 )
  {
LABEL_12:
    v4 = sub_54F952C(a1, a2);
    if ( !(unsigned int)sub_54F3AA4(v4 + 16, a2) )
    {
      while ( 1 )
      {
        v10 = *(_DWORD *)(v4 + 28);
        if ( v10 < 0x10 )
          break;
        v4 += 32 * ((__int64)(int)v10 >> 4);
        if ( (unsigned int)sub_54F3AA4(v4 + 16, a2) )
          return (void *)v4;
      }
      return &unk_1020EA0;
    }
    return (void *)v4;
  }
  v9 = v7 - 1;
  if ( (unsigned int)v9 < *(_DWORD *)(a1 + 8) )
    return (void *)(*(_QWORD *)(a1 + 24) + 16LL * v9);
  v4 = *(_QWORD *)(a1 + 32);
  if ( (_UNKNOWN *)v4 == &unk_10210B0 )
    return &unk_1020EA0;
  v11 = (1540483477
       * ((1540483477
         * (HIDWORD(v8) & 0x7FFFFFFF ^ ((1540483477 * (LODWORD(v8) ^ ((HIDWORD(v8) & 0x7FFFFFFFu) >> 18))) >> 22))) ^ ((1540483477 * ((1540483477 * (LODWORD(v8) ^ ((HIDWORD(v8) & 0x7FFFFFFFu) >> 18))) ^ ((1540483477 * (HIDWORD(v8) & 0x7FFFFFFF ^ ((1540483477 * (LODWORD(v8) ^ ((HIDWORD(v8) & 0x7FFFFFFFu) >> 18))) >> 22))) >> 17))) >> 19))) & ~(-1 << *(_BYTE *)(a1 + 6));
  while ( 1 )
  {
    v4 += 32LL * v11;
    v12 = *(_DWORD *)(v4 + 28);
    if ( (v12 & 0xF) == 3 && *(double *)(v4 + 16) == v8 )
      break;
    v11 = v12 >> 4;
    if ( (unsigned int)v12 < 0x10 )
      return &unk_1020EA0;
  }
  return (void *)v4;
}


================================================================================
Function: sub_54F952C (0x54F952C)
================================================================================

__int64 __fastcall sub_54F952C(__int64 a1, __int64 a2)
{
  unsigned int v2; // w8
  unsigned int v3; // w8
  unsigned int v4; // w8
  int8x8_t v5; // d0
  int32x2_t v6; // d0
  unsigned int v7; // w8
  unsigned __int64 v8; // d0

  switch ( *(_DWORD *)(a2 + 12) )
  {
    case 1:
      v2 = *(_DWORD *)a2;
      break;
    case 3:
      v4 = *(_DWORD *)(a2 + 4) & 0x7FFFFFFF;
      v2 = 1540483477
         * ((1540483477 * (v4 ^ ((1540483477 * (*(_DWORD *)a2 ^ (v4 >> 18))) >> 22))) ^ ((1540483477
                                                                                        * ((1540483477
                                                                                          * (*(_DWORD *)a2 ^ (v4 >> 18))) ^ ((1540483477 * (v4 ^ ((1540483477 * (*(_DWORD *)a2 ^ (v4 >> 18))) >> 22))) >> 17))) >> 19));
      break;
    case 4:
      v5.n64_u64[0] = vbic_s8(*(int8x8_t *)(a2 + 4), vceq_s32(*(int32x2_t *)(a2 + 4), (int32x2_t)0x8000000080000000LL)).n64_u64[0];
      v6.n64_u64[0] = veor_s8(vshr_n_u32(v5, 0x11uLL), v5).n64_u64[0];
      if ( *(_DWORD *)a2 == 0x80000000 )
        v7 = 0;
      else
        v7 = *(_DWORD *)a2;
      v8 = vmul_s32(v6, (int32x2_t)0x4F9FFB70127409FLL).n64_u64[0];
      v2 = v8 ^ (73856093 * (v7 ^ (v7 >> 17))) ^ HIDWORD(v8);
      break;
    case 5:
      v2 = *(_DWORD *)(*(_QWORD *)a2 + 16LL);
      break;
    default:
      v3 = -2048144789 * (*(_DWORD *)a2 ^ HIWORD(*(_DWORD *)a2));
      v2 = (-1028477387 * (v3 ^ (v3 >> 13))) ^ ((-1028477387 * (v3 ^ (v3 >> 13))) >> 16);
      break;
  }
  return *(_QWORD *)(a1 + 32) + 32LL * (int)(v2 & ~(-1 << *(_BYTE *)(a1 + 6)));
}


================================================================================
Function: sub_54F963C (0x54F963C)
================================================================================

void *__fastcall sub_54F963C(__int64 a1, __int64 a2, __int64 a3)
{
  void *result; // x0
  long double v7; // q0
  int v8; // w8

  result = (void *)sub_54F9360(a2, a3);
  *(_BYTE *)(a2 + 3) = 0;
  if ( result == &unk_1020EA0 )
  {
    v8 = *(_DWORD *)(a3 + 12);
    switch ( v8 )
    {
      case 3:
        *(_QWORD *)&v7 = *(_QWORD *)a3;
        break;
      case 4:
        LODWORD(v7) = *(_DWORD *)(a3 + 8);
        break;
      case 0:
        sub_54EC328(a1, "table index is nil");
    }
    return (void *)sub_54F9798(a1, a2, a3, v7);
  }
  return result;
}


================================================================================
Function: sub_54F9798 (0x54F9798)
================================================================================

__int64 __fastcall sub_54F9798(__int64 a1, __int64 a2, _DWORD *a3, long double a4, long double a5)
{
  int v8; // w8
  int v9; // w9
  int v10; // w9
  __int64 v11; // x0
  int v12; // w8
  __int64 v13; // x25
  _DWORD *v14; // x26
  int v15; // w9
  int v16; // w27
  int v17; // w24
  __int64 v18; // x0
  int v19; // w9
  __int64 v20; // x8
  __int128 v21; // q0
  int v22; // w9
  __int64 v24; // x22
  __int64 v25; // [xsp+8h] [xbp-18h] BYREF
  int v26; // [xsp+10h] [xbp-10h]
  int v27; // [xsp+14h] [xbp-Ch]

  v8 = a3[3];
  while ( v8 == 3 )
  {
    *(_QWORD *)&a5 = *(_QWORD *)a3;
    *(double *)&a4 = (double)(*(_DWORD *)(a2 + 8) + 1);
    if ( *(double *)a3 != *(double *)&a4 )
      break;
LABEL_4:
    sub_54F9F50(a1, a2, a3, a4, a5);
    v8 = a3[3];
    if ( v8 == 3 )
    {
      v9 = (int)*(double *)a3;
      if ( *(double *)a3 == (double)v9 )
      {
        v10 = v9 - 1;
        v8 = 3;
        if ( (unsigned int)v10 < *(_DWORD *)(a2 + 8) )
          return *(_QWORD *)(a2 + 24) + 16LL * v10;
      }
    }
  }
  v11 = sub_54F952C(a2, a3);
  v24 = v11;
  if ( (_UNKNOWN *)v11 == &unk_10210B0 || *(_DWORD *)(v11 + 12) )
  {
    v12 = *(_DWORD *)(a2 + 12);
    while ( v12 >= 1 )
    {
      v13 = *(_QWORD *)(a2 + 32) + 32LL * (unsigned int)--v12;
      *(_DWORD *)(a2 + 12) = v12;
      v14 = (_DWORD *)(v13 + 28);
      if ( (*(_BYTE *)(v13 + 28) & 0xF) == 0 )
      {
        v15 = *(_DWORD *)(v11 + 24);
        v16 = *(_DWORD *)(v11 + 28);
        v17 = v16 & 0xF;
        v25 = *(_QWORD *)(v11 + 16);
        v26 = v15;
        v27 = v17;
        v18 = sub_54F952C(a2, &v25);
        if ( v18 == v24 )
        {
          if ( (unsigned int)v16 > 0xF )
          {
            *v14 = ((v24 + 32 * (unsigned __int64)(unsigned int)(v16 >> 4) - v13) >> 1) & 0xFFFFFFF0;
            v17 = *(_DWORD *)(v24 + 28) & 0xF;
          }
          *(_DWORD *)(v24 + 28) = ((unsigned __int64)(v13 - v24) >> 1) & 0xFFFFFFF0 | v17;
          v24 = v13;
        }
        else
        {
          do
          {
            v19 = *(_DWORD *)(v18 + 28);
            v20 = v18;
            v18 += 32 * ((__int64)v19 >> 4);
          }
          while ( v18 != v24 );
          *(_DWORD *)(v20 + 28) = ((unsigned __int64)(v13 - v20) >> 1) & 0xFFFFFFF0 | v19 & 0xF;
          v21 = *(_OWORD *)(v24 + 16);
          *(_OWORD *)v13 = *(_OWORD *)v24;
          *(_OWORD *)(v13 + 16) = v21;
          if ( *(_DWORD *)(v24 + 28) >= 0x10u )
          {
            *v14 += ((unsigned __int64)(v24 - v13) >> 1) & 0xFFFFFFF0;
            *(_DWORD *)(v24 + 28) &= 0xFu;
          }
          *(_DWORD *)(v24 + 12) = 0;
        }
        goto LABEL_21;
      }
    }
    goto LABEL_4;
  }
LABEL_21:
  v22 = *(_DWORD *)(v24 + 28);
  *(_QWORD *)(v24 + 16) = *(_QWORD *)a3;
  *(_DWORD *)(v24 + 24) = a3[2];
  *(_DWORD *)(v24 + 28) = v22 & 0xFFFFFFF0 | a3[3] & 0xF;
  if ( (int)a3[3] >= 5 && (*(_BYTE *)(a2 + 1) & 4) != 0 && (*(_BYTE *)(*(_QWORD *)a3 + 1LL) & 3) != 0 )
    sub_54EF53C(a1, a2);
  return v24;
}


================================================================================
Function: sub_54F9F50 (0x54F9F50)
================================================================================

__int64 __fastcall sub_54F9F50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x8
  int v7; // w23
  int v8; // w14
  int v9; // w12
  int v10; // w9
  int v11; // w16
  __int64 v12; // x13
  int v13; // w13
  __int64 v14; // x17
  __int64 v15; // x16
  __int64 v16; // x14
  unsigned __int64 v17; // x16
  __int64 v18; // x0
  __int64 v19; // x2
  unsigned __int64 v20; // x16
  __int64 v21; // x0
  int32x4_t v22; // q0
  __int64 v23; // x16
  int32x4_t v24; // q1
  const float *v25; // x0
  const float *v26; // x1
  unsigned __int128 v27; // q16
  unsigned __int128 v28; // q2
  __int64 v29; // x15
  __int64 v30; // x17
  __int64 v31; // x14
  int *v32; // x15
  int v33; // t1
  int v34; // w25
  int v35; // w22
  __int64 v36; // x9
  __int64 v37; // x26
  __int64 v38; // x27
  int v39; // w0
  int v40; // w8
  __int64 v41; // x8
  double v42; // d0
  unsigned int v43; // w0
  int v44; // w26
  int v45; // w8
  double v46; // d1
  unsigned int v47; // w8
  unsigned int v48; // w0
  int v49; // w0
  int v50; // w8
  int v51; // w12
  unsigned int v52; // w22
  int v53; // w8
  int v54; // w9
  int v55; // w11
  int *v56; // x10
  int v57; // w14
  bool v58; // w12
  unsigned int v59; // w23
  int v60; // w0
  int v61; // w8
  _OWORD v63[7]; // [xsp+0h] [xbp-80h] BYREF

  v6 = 0LL;
  v7 = 0;
  v8 = 1;
  v9 = 1;
  v10 = *(_DWORD *)(a2 + 8);
  memset(v63, 0, 108);
  do
  {
    v13 = v9;
    if ( v9 > v10 )
    {
      v13 = v10;
      if ( v8 > v10 )
        break;
    }
    if ( v13 < v8 )
    {
      v11 = 0;
    }
    else
    {
      v14 = v8;
      v15 = v13 - (__int64)v8;
      v16 = *(_QWORD *)(a2 + 24);
      v17 = v15 + 1;
      if ( v17 >= 9 )
      {
        v18 = v17 & 7;
        if ( (v17 & 7) == 0 )
          v18 = 8LL;
        v19 = v16 + 16 * v14;
        v20 = v17 - v18;
        v21 = v18 + v14;
        v14 += v20;
        v22 = 0uLL;
        v23 = ~(__int64)v13 + v21;
        v24 = 0uLL;
        v25 = (const float *)(v19 + 60);
        do
        {
          v26 = v25 - 16;
          v27 = (unsigned __int128)vld4q_f32(v25);
          v23 += 8LL;
          v25 += 32;
          v28 = (unsigned __int128)vld4q_f32(v26);
          v22 = vsubq_s32(v22, vtstq_s32((int32x4_t)v28, (int32x4_t)v28));
          v24 = vsubq_s32(v24, vtstq_s32((int32x4_t)v27, (int32x4_t)v27));
        }
        while ( v23 );
        v11 = vaddvq_s32(vaddq_s32(v24, v22));
      }
      else
      {
        v11 = 0;
      }
      v29 = v13 - v14;
      v30 = v16 + 16 * v14;
      v31 = v29 + 1;
      v32 = (int *)(v30 - 4);
      do
      {
        v33 = *v32;
        v32 += 4;
        if ( v33 )
          ++v11;
        --v31;
      }
      while ( v31 );
      v8 = v13 + 1;
    }
    v12 = 4 * v6;
    v7 += v11;
    ++v6;
    v9 *= 2;
    *(_DWORD *)((char *)v63 + v12) += v11;
  }
  while ( v6 != 27 );
  v34 = 0;
  v35 = 0;
  v36 = ~(-1 << *(_BYTE *)(a2 + 6));
  v37 = 32 * v36;
  v38 = v36 + 1;
  do
  {
    v41 = *(_QWORD *)(a2 + 32);
    if ( *(_DWORD *)(v41 + v37 + 12) )
    {
      if ( (*(_DWORD *)(v41 + v37 + 28) & 0xF) == 3 )
      {
        v42 = *(double *)(v41 + v37 + 16);
        if ( v42 == (double)(int)v42 )
          v43 = (int)v42 - 1;
        else
          v43 = -2;
        if ( v43 >> 26 )
        {
          v40 = 0;
        }
        else
        {
          v39 = sub_54F39AC(v43);
          v40 = 1;
          ++*((_DWORD *)v63 + v39 + 1);
        }
        v35 += v40;
      }
      ++v34;
    }
    v37 -= 32LL;
    --v38;
  }
  while ( v38 );
  v44 = v35 + v7;
  if ( *(_DWORD *)(a3 + 12) == 3 )
  {
    v45 = (int)*(double *)a3;
    v46 = (double)v45;
    v47 = v45 - 1;
    if ( *(double *)a3 == v46 )
      v48 = v47;
    else
      v48 = -2;
    if ( v48 >> 26 )
    {
      v50 = 0;
    }
    else
    {
      v49 = sub_54F39AC(v48);
      v50 = 1;
      ++*((_DWORD *)v63 + v49 + 1);
    }
    v44 += v50;
  }
  if ( v44 < 1 )
  {
    v53 = 0;
    v52 = 0;
  }
  else
  {
    v51 = 0;
    v52 = 0;
    v53 = 0;
    v54 = 0;
    v55 = 1;
    v56 = (int *)v63;
    do
    {
      v57 = *v56 + v54;
      v58 = v57 > v51;
      if ( *v56 > 0 )
        v54 += *v56;
      if ( *v56 > 0 && v58 )
      {
        v53 = v57;
        v52 = v55;
      }
      if ( v54 == v44 )
        break;
      v51 = v55 & 0x7FFFFFFF;
      ++v56;
      v55 *= 2;
    }
    while ( v51 < v44 );
  }
  v59 = v7 + v34 - v53 + 1;
  v60 = sub_54F8B60(a2, v52, a3);
  v61 = v60 - v52;
  if ( v60 != v52 )
  {
    v59 -= v61;
    v52 = sub_54F8B60(a2, (unsigned int)(v61 + v60), a3);
  }
  return sub_54F8C94(a1, a2, v52, v59);
}


================================================================================
Function: sub_54FB970 (0x54FB970)
================================================================================

__int64 __fastcall sub_54FB970(__int64 a1, char a2, __int64 a3)
{
  __int64 result; // x0

  result = sub_54F9300(a1, a3);
  if ( !*(_DWORD *)(result + 12) )
  {
    result = 0LL;
    *(_BYTE *)(a1 + 3) |= 1 << a2;
  }
  return result;
}


================================================================================
Function: sub_55066F8 (0x55066F8)
================================================================================

__int64 __fastcall sub_55066F8(__int64 a1, char *a2, unsigned __int8 *a3, __int64 a4, unsigned int a5)
{
  unsigned int v10; // w26
  __int64 result; // x0
  __int64 v12; // x21
  unsigned __int64 v13; // x23
  __int64 *v14; // x0
  size_t v15; // x0
  __int64 v16; // x27
  int v17; // w8
  __int64 v18; // x21
  unsigned __int8 v19; // w9
  int v20; // w10
  __int64 i; // x22
  int v22; // w8
  size_t v23; // x25
  __int64 v24; // x23
  unsigned __int8 v25; // w9
  int v26; // w10
  __int128 v27; // q0
  int v28; // w8
  int v29; // w10
  int v30; // w9
  unsigned __int8 v31; // w11
  int v32; // w12
  __int64 v33; // x9
  unsigned int v34; // w22
  __int64 (__fastcall *v35)(__int64, __int64, _QWORD); // x8
  int v36; // w8
  __int64 v37; // x23
  unsigned __int8 v38; // w9
  int v39; // w10
  __int64 v40; // x23
  __int64 v41; // x24
  __int64 v42; // x0
  __int64 v43; // x26
  __int64 v44; // x25
  unsigned __int8 v45; // w8
  int v46; // w8
  size_t v47; // x27
  unsigned __int8 v48; // w9
  int v49; // w10
  unsigned int v50; // w23
  _BYTE *v51; // x0
  __int64 v52; // x9
  __int64 v53; // x8
  int v54; // w8
  size_t v55; // x27
  unsigned __int8 v56; // w9
  int v57; // w10
  void *v58; // x0
  __int64 v59; // x9
  __int64 v60; // x8
  int v61; // w11
  __int64 v62; // x12
  _BYTE *v63; // x14
  __int64 v64; // x15
  char v65; // w16
  _BYTE *v66; // x10
  __int64 v67; // x13
  int v68; // w14
  int v69; // w14
  __int64 v70; // x11
  char v71; // w17
  _BYTE *v72; // x15
  __int64 v73; // x16
  int v74; // w10
  int v75; // w17
  int v76; // w10
  char v77; // w0
  _BYTE *v78; // x14
  __int64 v79; // x13
  int v80; // w15
  __int64 v81; // x16
  unsigned __int64 v82; // x15
  int v83; // w8
  __int64 v84; // x23
  unsigned __int8 v85; // w9
  int v86; // w10
  __int64 v87; // x0
  __int64 v88; // x8
  __int64 v89; // x9
  __int64 v90; // x11
  int v91; // w8
  __int64 v92; // x23
  unsigned __int8 v93; // w9
  int v94; // w10
  __int64 v95; // x0
  __int64 v96; // x8
  _DWORD *v97; // x9
  __int64 v98; // x10
  __int64 v99; // x9
  __int64 v100; // x8
  _DWORD *v101; // x9
  __int64 v102; // x24
  int v103; // w9
  __int64 v104; // x23
  _DWORD *v105; // x8
  __int64 v106; // d0
  __int64 v107; // x8
  int v108; // w8
  int v109; // w27
  unsigned __int8 v110; // w9
  int v111; // w10
  __int64 v112; // x28
  int k; // w25
  int v114; // w9
  int v115; // w8
  unsigned __int8 v116; // w10
  int v117; // w11
  __int64 v118; // x0
  __int64 v119; // x8
  int v120; // w9
  int v121; // w8
  unsigned __int8 v122; // w10
  int v123; // w11
  __int64 v124; // x8
  int v125; // w8
  __int64 v126; // x10
  int v127; // w0
  __int64 v128; // x8
  int v129; // w9
  unsigned int v130; // w8
  unsigned __int8 v131; // w10
  int v132; // w11
  __int64 v133; // x0
  __int64 v134; // x8
  __int64 v135; // d0
  __int64 v136; // x8
  int v137; // s1
  __int64 v138; // x9
  __int64 v139; // x9
  int v140; // w8
  __int64 v141; // x24
  unsigned __int8 v142; // w9
  int v143; // w10
  unsigned __int8 *v144; // x25
  __int64 m; // x8
  int v146; // w10
  unsigned int v147; // w9
  unsigned __int8 v148; // w11
  int v149; // w12
  int v150; // w10
  int v151; // w8
  __int64 v152; // x11
  unsigned __int8 *v153; // x12
  unsigned __int8 v154; // w13
  __int64 v155; // x24
  unsigned __int8 *v156; // x9
  int v157; // w11
  int v158; // w11
  int v159; // w10
  unsigned __int8 *v160; // x8
  unsigned __int8 *v161; // x23
  int v162; // w9
  __int64 v163; // x8
  int v164; // w8
  __int64 v165; // x9
  __int64 v166; // x2
  int v167; // w25
  unsigned __int64 v168; // x27
  int v169; // w28
  unsigned __int8 *v170; // x0
  int v171; // w8
  unsigned __int8 *v172; // x8
  unsigned __int8 v173; // w8
  __int64 v174; // x9
  char v175; // t1
  int v176; // w8
  _DWORD *v177; // x9
  __int64 v178; // x10
  int v179; // w11
  int v180; // w8
  __int64 v181; // x23
  unsigned __int8 v182; // w9
  int v183; // w10
  __int64 v184; // x0
  __int64 n; // x8
  int v186; // w14
  int v187; // w13
  __int64 v188; // x15
  unsigned __int8 *v189; // x16
  __int64 v190; // x10
  unsigned __int8 v191; // w17
  __int64 v192; // x11
  unsigned __int8 *v193; // x12
  int v194; // w15
  __int64 v195; // x13
  int v196; // w15
  int v197; // w14
  unsigned __int8 v198; // w16
  char *v199; // x13
  int v200; // w11
  int v201; // w10
  int v202; // w11
  char v203; // t1
  int v204; // w14
  __int64 v205; // x10
  int v206; // w8
  __int64 v207; // x23
  unsigned __int8 v208; // w9
  int v209; // w10
  __int64 ii; // x8
  __int64 v211; // x9
  int v212; // w10
  int v213; // w9
  unsigned __int8 v214; // w11
  int v215; // w12
  unsigned __int64 v216; // x0
  unsigned int v217; // w2
  unsigned int v218; // w1
  __int64 v219; // x12
  _BYTE *v220; // x13
  __int64 v221; // x14
  unsigned int v222; // w16
  unsigned int v223; // w15
  int j; // w11
  unsigned int v225; // w12
  int v226; // w12
  int v227; // w12
  __int64 v228; // x13
  __int64 v229; // x12
  _BYTE *v230; // x13
  unsigned int v231; // w14
  _BYTE *v232; // x13
  __int64 v233; // x14
  unsigned int v234; // w15
  int v235; // w9
  int v236; // w8
  unsigned __int8 *v237; // x10
  char v238; // t1
  int v239; // w12
  __int64 v240; // x0
  __int64 v241; // x8
  __int64 v242; // x8
  unsigned __int64 v243; // [xsp+0h] [xbp-1A0h]
  __int64 v244; // [xsp+8h] [xbp-198h]
  int v245; // [xsp+14h] [xbp-18Ch]
  __int64 v246; // [xsp+18h] [xbp-188h]
  unsigned int v247; // [xsp+2Ch] [xbp-174h]
  __int64 v248; // [xsp+30h] [xbp-170h]
  __int64 v249; // [xsp+40h] [xbp-160h]
  __int64 v250; // [xsp+48h] [xbp-158h]
  __int64 v251; // [xsp+58h] [xbp-148h]
  __int64 v252; // [xsp+60h] [xbp-140h]
  __int64 v253; // [xsp+70h] [xbp-130h]
  __int64 v254; // [xsp+80h] [xbp-120h] BYREF
  int v255; // [xsp+88h] [xbp-118h]
  _OWORD dest[16]; // [xsp+90h] [xbp-110h] BYREF

  v10 = *a3;
  sub_2ACB540();
  if ( !v10 )
  {
    strlen(a2);
    sub_54F3E30(dest, 256, a2);
    sub_54E2754(a1, "%s%.*s");
    return 1LL;
  }
  if ( v10 - 7 <= 0xFFFFFFFB )
  {
    strlen(a2);
    sub_54F3E30(dest, 256, a2);
    sub_54E2754(a1, "%s: bytecode version mismatch (expected [%d..%d], got %d)");
    return 1LL;
  }
  if ( (_BYTE)word_6F12308 )
    sub_55079C8(a1, a2, a3, a4, a5);
  v12 = *(_QWORD *)(a1 + 24);
  v13 = *(_QWORD *)(v12 + 64);
  if ( *(_QWORD *)(v12 + 72) >= v13 )
  {
    sub_54EE53C(a1, 1);
    v12 = *(_QWORD *)(a1 + 24);
    v13 = *(_QWORD *)(v12 + 64);
  }
  *(_QWORD *)(v12 + 64) = -1LL;
  if ( a5 )
    v14 = (__int64 *)sub_54E0F84(a1, a5);
  else
    v14 = (__int64 *)(a1 + 88);
  v249 = *v14;
  v15 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
  v248 = sub_54F51DC(a1, (int *)a2, v15);
  if ( v10 < 4 )
  {
    v16 = 1LL;
    v247 = v10;
    v243 = v13;
    v244 = v12;
    v245 = 0;
  }
  else
  {
    v245 = a3[1];
    if ( (unsigned int)(v245 - 4) <= 0xFFFFFFFC )
    {
      __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
      sub_54F3E30(dest, 256, a2);
      sub_54E2754(a1, "%s: bytecode type version mismatch (expected [%d..%d], got %d)");
      result = 1LL;
      *(_QWORD *)(v12 + 64) = v13;
      return result;
    }
    v247 = v10;
    v16 = 2LL;
    v243 = v13;
    v244 = v12;
  }
  v17 = 0;
  LODWORD(v18) = 0;
  do
  {
    v19 = a3[v16++];
    v20 = (v19 & 0x7F) << v17;
    v17 += 7;
    v18 = v20 | (unsigned int)v18;
  }
  while ( (v19 & 0x80) != 0 );
  v253 = sub_54F2A20(a1, 8 * v18, 0LL);
  if ( (_DWORD)v18 )
  {
    for ( i = 0LL; i != v18; ++i )
    {
      v22 = 0;
      LODWORD(v23) = 0;
      v24 = v16;
      do
      {
        v25 = a3[v24++];
        v26 = (v25 & 0x7F) << v22;
        v22 += 7;
        v23 = v26 | (unsigned int)v23;
      }
      while ( (v25 & 0x80) != 0 );
      v16 = v23 + v24;
      *(_QWORD *)(v253 + 8 * i) = sub_54F51DC(a1, (int *)&a3[v24], v23);
    }
    v16 = v24 + (unsigned int)v23;
  }
  if ( v245 == 3 )
  {
    *(_QWORD *)&v27 = 0x707070707070707LL;
    *((_QWORD *)&v27 + 1) = 0x707070707070707LL;
    v28 = a3[v16++];
    dest[0] = v27;
    for ( dest[1] = v27; v28; ++v16 )
    {
      v29 = 0;
      v30 = 0;
      do
      {
        v31 = a3[v16++];
        v32 = (v31 & 0x7F) << v29;
        v29 += 7;
        v30 |= v32;
      }
      while ( (v31 & 0x80) != 0 );
      if ( v30 )
        v33 = *(_QWORD *)(v253 + 8LL * (unsigned int)(v30 - 1));
      else
        v33 = 0LL;
      v34 = v28 - 1;
      if ( (unsigned int)(v28 - 1) <= 0x1F )
      {
        v35 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)(a1 + 24) + 3416LL);
        if ( v35 )
          *((_BYTE *)dest + v34) = v35(a1, v33 + 24, *(unsigned int *)(v33 + 20));
      }
      v28 = a3[v16];
    }
  }
  v36 = 0;
  LODWORD(v37) = 0;
  do
  {
    v38 = a3[v16++];
    v39 = (v38 & 0x7F) << v36;
    v36 += 7;
    v37 = v39 | (unsigned int)v37;
  }
  while ( (v38 & 0x80) != 0 );
  v251 = sub_54F2A20(a1, 8 * v37, 0LL);
  v252 = v37;
  if ( (_DWORD)v37 )
  {
    v246 = v37;
    v40 = 0LL;
    while ( 1 )
    {
      v42 = sub_54EDFE8(a1);
      *(_DWORD *)(v42 + 168) = v40;
      v43 = v42;
      v44 = v16 + 4;
      v250 = v40;
      *(_QWORD *)(v42 + 88) = v248;
      *(_BYTE *)(v42 + 6) = a3[v16];
      *(_BYTE *)(v42 + 4) = a3[v16 + 1];
      *(_BYTE *)(v42 + 3) = a3[v16 + 2];
      *(_BYTE *)(v42 + 5) = a3[v16 + 3];
      if ( v247 < 4 )
        goto LABEL_72;
      v45 = a3[v44];
      v44 = v16 + 5;
      *(_BYTE *)(v42 + 7) = v45;
      if ( v245 == 1 )
      {
        v46 = 0;
        LODWORD(v47) = 0;
        do
        {
          v48 = a3[v44++];
          v49 = (v48 & 0x7F) << v46;
          v46 += 7;
          v47 = v49 | (unsigned int)v47;
        }
        while ( (v48 & 0x80) != 0 );
        if ( (_DWORD)v47 )
        {
          if ( (unsigned int)v47 <= 0x7F )
            v50 = 3;
          else
            v50 = 4;
          v51 = (_BYTE *)sub_54F2A20(a1, v50 + (unsigned int)v47, *(unsigned __int8 *)(v42 + 2));
          *(_QWORD *)(v43 + 112) = v51;
          *(_DWORD *)(v43 + 172) = v50 + v47;
          if ( (unsigned int)v47 < 0x80 )
          {
            v53 = 1LL;
            v52 = 2LL;
            *v51 = v47;
          }
          else
          {
            v52 = 3LL;
            *v51 = v47 | 0x80;
            v53 = 2LL;
            *(_BYTE *)(*(_QWORD *)(v43 + 112) + 1LL) = (unsigned int)v47 >> 7;
          }
          *(_BYTE *)(*(_QWORD *)(v43 + 112) + v53) = 0;
          *(_BYTE *)(*(_QWORD *)(v43 + 112) + v52) = 0;
          memcpy((void *)(*(_QWORD *)(v43 + 112) + v50), &a3[v44], v47);
          v44 += v47;
        }
        goto LABEL_72;
      }
      if ( (v245 & 0xFE) != 2 )
        goto LABEL_72;
      v54 = 0;
      LODWORD(v55) = 0;
      do
      {
        v56 = a3[v44++];
        v57 = (v56 & 0x7F) << v54;
        v54 += 7;
        v55 = v57 | (unsigned int)v55;
      }
      while ( (v56 & 0x80) != 0 );
      if ( !(_DWORD)v55 )
        goto LABEL_72;
      v58 = (void *)sub_54F2A20(a1, v55, *(unsigned __int8 *)(v42 + 2));
      *(_QWORD *)(v43 + 112) = v58;
      *(_DWORD *)(v43 + 172) = v55;
      memcpy(v58, &a3[v44], v55);
      v44 += v55;
      if ( v245 != 3 )
        goto LABEL_72;
      v59 = *(_QWORD *)(v43 + 112);
      v60 = 0LL;
      v61 = 0;
      LODWORD(v62) = 0;
      v63 = (_BYTE *)(v59 + 6);
      v64 = v59 + 3;
      do
      {
        v65 = *(_BYTE *)(v59 + v60);
        v66 = v63;
        v67 = v64;
        ++v60;
        ++v64;
        v68 = (v65 & 0x7F) << v61;
        v61 += 7;
        v62 = v68 | (unsigned int)v62;
        v63 = v66 + 1;
      }
      while ( v65 < 0 );
      v69 = 0;
      LODWORD(v70) = 0;
      do
      {
        v71 = *(_BYTE *)(v59 + v60);
        v72 = v66;
        v73 = v67;
        ++v60;
        ++v67;
        v74 = (v71 & 0x7F) << v69;
        v69 += 7;
        v70 = v74 | (unsigned int)v70;
        v66 = v72 + 1;
      }
      while ( v71 < 0 );
      v75 = 0;
      v76 = 0;
      do
      {
        v77 = *(_BYTE *)(v59 + v60);
        v78 = v72;
        v79 = v73;
        ++v60;
        ++v73;
        v80 = (v77 & 0x7F) << v75;
        v75 += 7;
        v76 |= v80;
        v72 = v78 + 1;
      }
      while ( v77 < 0 );
      if ( (_DWORD)v62 )
        break;
LABEL_180:
      if ( !(_DWORD)v70 )
        goto LABEL_191;
      if ( (_DWORD)v70 == 1 )
      {
        v219 = 0LL;
      }
      else
      {
        v219 = (unsigned int)v70 & 0xFFFFFFFE;
        v220 = (_BYTE *)(v59 + v60 + 1);
        v221 = v219;
        do
        {
          v222 = (unsigned __int8)*(v220 - 1) - 64;
          v223 = (unsigned __int8)*v220 - 64;
          if ( v222 <= 0x1F )
            *(v220 - 1) = *((_BYTE *)dest + v222);
          if ( v223 <= 0x1F )
            *v220 = *((_BYTE *)dest + v223);
          v220 += 2;
          v221 -= 2LL;
        }
        while ( v221 );
        if ( v219 == v70 )
          goto LABEL_190;
      }
      v228 = v219 + v60;
      v229 = v70 - v219;
      v230 = (_BYTE *)(v59 + v228);
      do
      {
        v231 = (unsigned __int8)*v230 - 64;
        if ( v231 <= 0x1F )
          *v230 = *((_BYTE *)dest + v231);
        --v229;
        ++v230;
      }
      while ( v229 );
LABEL_190:
      v60 += v70;
LABEL_191:
      if ( v76 )
      {
        for ( j = 0; j != v76; ++j )
        {
          v225 = *(char *)(v59 + v60) - 64;
          if ( v225 <= 0x1F )
            *(_BYTE *)(v59 + v60) = *((_BYTE *)dest + v225);
          v60 += 2LL;
          do
            v226 = *(char *)(v59 + v60++);
          while ( v226 < 0 );
          do
            v227 = *(char *)(v59 + v60++);
          while ( v227 < 0 );
        }
      }
LABEL_72:
      v83 = 0;
      LODWORD(v84) = 0;
      do
      {
        v85 = a3[v44++];
        v86 = (v85 & 0x7F) << v83;
        v83 += 7;
        v84 = v86 | (unsigned int)v84;
      }
      while ( (v85 & 0x80) != 0 );
      if ( (v84 & 0x80000000) != 0 )
        sub_54F2A0C(a1);
      v87 = sub_54F2A20(a1, 4 * v84, *(unsigned __int8 *)(v43 + 2));
      *(_QWORD *)(v43 + 16) = v87;
      *(_DWORD *)(v43 + 136) = v84;
      if ( (_DWORD)v84 )
      {
        v88 = 0LL;
        v89 = 0LL;
        do
        {
          v90 = 4 * v89++;
          v88 += 4LL;
          *(_DWORD *)(v87 + v90) = *(_DWORD *)&a3[v44 + v90];
        }
        while ( v89 < *(int *)(v43 + 136) );
        v44 += v88;
      }
      v91 = 0;
      LODWORD(v92) = 0;
      *(_QWORD *)(v43 + 32) = v87;
      do
      {
        v93 = a3[v44++];
        v94 = (v93 & 0x7F) << v91;
        v91 += 7;
        v92 = v94 | (unsigned int)v92;
      }
      while ( (v93 & 0x80) != 0 );
      if ( (v92 & 0x80000000) != 0 )
        sub_54F2A0C(a1);
      v95 = sub_54F2A20(a1, 16 * v92, *(unsigned __int8 *)(v43 + 2));
      *(_QWORD *)(v43 + 8) = v95;
      *(_DWORD *)(v43 + 152) = v92;
      if ( !(_DWORD)v92 )
      {
        v104 = v44;
        goto LABEL_119;
      }
      if ( (_DWORD)v92 == 1 )
      {
        v96 = 0LL;
LABEL_88:
        v99 = v95 + 16 * v96;
        v100 = v92 - v96;
        v101 = (_DWORD *)(v99 + 12);
        do
        {
          --v100;
          *v101 = 0;
          v101 += 4;
        }
        while ( v100 );
        goto LABEL_90;
      }
      v96 = (unsigned int)v92 & 0xFFFFFFFE;
      v97 = (_DWORD *)(v95 + 28);
      v98 = v96;
      do
      {
        v98 -= 2LL;
        *(v97 - 4) = 0;
        *v97 = 0;
        v97 += 8;
      }
      while ( v98 );
      if ( v96 != v92 )
        goto LABEL_88;
LABEL_90:
      v102 = 0LL;
      do
      {
        v104 = v44 + 1;
        switch ( a3[v44] )
        {
          case 1u:
            v103 = a3[v104];
            v104 = v44 + 2;
            v105 = (_DWORD *)(*(_QWORD *)(v43 + 8) + 16 * v102);
            *v105 = v103;
            v105[3] = 1;
            break;
          case 2u:
            v106 = *(_QWORD *)&a3[v104];
            v104 = v44 + 9;
            v107 = *(_QWORD *)(v43 + 8) + 16 * v102;
            *(_QWORD *)v107 = v106;
            *(_DWORD *)(v107 + 12) = 3;
            break;
          case 3u:
            v120 = 0;
            v121 = 0;
            do
            {
              v122 = a3[v104++];
              v123 = (v122 & 0x7F) << v120;
              v120 += 7;
              v121 |= v123;
            }
            while ( (v122 & 0x80) != 0 );
            if ( v121 )
              v124 = *(_QWORD *)(v253 + 8LL * (unsigned int)(v121 - 1));
            else
              v124 = 0LL;
            v138 = *(_QWORD *)(v43 + 8) + 16 * v102;
            *(_QWORD *)v138 = v124;
            *(_DWORD *)(v138 + 12) = 5;
            break;
          case 4u:
            v125 = *(_DWORD *)&a3[v104];
            v126 = *(_QWORD *)(a1 + 88);
            v254 = *(_QWORD *)(v43 + 8);
            v255 = v125;
            if ( *(_BYTE *)(v126 + 5) )
            {
              sub_54E12F4(a1);
              v127 = sub_54EDC18(a1, sub_5507838, &v254, *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 48), 0LL);
              v128 = *(_QWORD *)(a1 + 8);
              if ( v127 )
                *(_DWORD *)(v128 - 4) = 0;
            }
            else
            {
              v139 = *(_QWORD *)(a1 + 8);
              v128 = v139 + 16;
              *(_DWORD *)(v139 + 12) = 0;
              *(_QWORD *)(a1 + 8) = v139 + 16;
            }
            v104 = v44 + 5;
            *(_OWORD *)(*(_QWORD *)(v43 + 8) + 16 * v102) = *(_OWORD *)(v128 - 16);
            *(_QWORD *)(a1 + 8) -= 16LL;
            break;
          case 5u:
            v108 = 0;
            v109 = 0;
            do
            {
              v110 = a3[v104++];
              v111 = (v110 & 0x7F) << v108;
              v108 += 7;
              v109 |= v111;
            }
            while ( (v110 & 0x80) != 0 );
            v112 = sub_54F8FEC(a1, 0LL, (unsigned int)v109);
            if ( v109 >= 1 )
            {
              for ( k = 0; k != v109; ++k )
              {
                v114 = 0;
                v115 = 0;
                do
                {
                  v116 = a3[v104++];
                  v117 = (v116 & 0x7F) << v114;
                  v114 += 7;
                  v115 |= v117;
                }
                while ( (v116 & 0x80) != 0 );
                v118 = sub_54F963C(a1, v112, *(_QWORD *)(v43 + 8) + 16LL * v115);
                *(_QWORD *)v118 = 0LL;
                *(_DWORD *)(v118 + 12) = 3;
              }
            }
            v119 = *(_QWORD *)(v43 + 8) + 16 * v102;
            *(_QWORD *)v119 = v112;
            *(_DWORD *)(v119 + 12) = 6;
            break;
          case 6u:
            v129 = 0;
            v130 = 0;
            do
            {
              v131 = a3[v104++];
              v132 = (v131 & 0x7F) << v129;
              v129 += 7;
              v130 |= v132;
            }
            while ( (v131 & 0x80) != 0 );
            v133 = sub_54EE060(a1, *(unsigned __int8 *)(*(_QWORD *)(v251 + 8LL * v130) + 3LL), v249);
            *(_BYTE *)(v133 + 6) = *(_BYTE *)(v133 + 4) != 0;
            v134 = *(_QWORD *)(v43 + 8) + 16 * v102;
            *(_QWORD *)v134 = v133;
            *(_DWORD *)(v134 + 12) = 7;
            break;
          case 7u:
            v135 = *(_QWORD *)&a3[v104];
            v104 = v44 + 17;
            v136 = *(_QWORD *)(v43 + 8) + 16 * v102;
            v137 = *(_DWORD *)&a3[v44 + 9];
            *(_QWORD *)v136 = v135;
            *(_DWORD *)(v136 + 8) = v137;
            *(_DWORD *)(v136 + 12) = 4;
            break;
          default:
            break;
        }
        ++v102;
        v44 = v104;
      }
      while ( v102 < *(int *)(v43 + 152) );
LABEL_119:
      v140 = 0;
      LODWORD(v141) = 0;
      do
      {
        v142 = a3[v104++];
        v143 = (v142 & 0x7F) << v140;
        v140 += 7;
        v141 = v143 | (unsigned int)v141;
      }
      while ( (v142 & 0x80) != 0 );
      v144 = a3 + 2;
      if ( (v141 & 0x80000000) != 0 )
        sub_54F2A0C(a1);
      *(_QWORD *)(v43 + 24) = sub_54F2A20(a1, 8 * v141, *(unsigned __int8 *)(v43 + 2));
      *(_DWORD *)(v43 + 140) = v141;
      if ( (_DWORD)v141 )
      {
        for ( m = 0LL; m != v141; ++m )
        {
          v146 = 0;
          v147 = 0;
          do
          {
            v148 = a3[v104++];
            v149 = (v148 & 0x7F) << v146;
            v146 += 7;
            v147 |= v149;
          }
          while ( (v148 & 0x80) != 0 );
          *(_QWORD *)(*(_QWORD *)(v43 + 24) + 8 * m) = *(_QWORD *)(v251 + 8LL * v147);
        }
      }
      v150 = 0;
      v151 = 0;
      v152 = v104 + 2;
      v153 = &a3[v104 + 5];
      do
      {
        v154 = a3[v104];
        v155 = v152;
        v156 = v153;
        ++v104;
        ++v153;
        v157 = (v154 & 0x7F) << v150;
        v150 += 7;
        v151 |= v157;
        v152 = v155 + 1;
      }
      while ( (v154 & 0x80) != 0 );
      v158 = 0;
      v159 = 0;
      *(_DWORD *)(v43 + 164) = v151;
      do
      {
        v160 = &a3[v155];
        v161 = v156;
        ++v155;
        LOBYTE(v160) = *(v160 - 1);
        v162 = ((unsigned __int8)v160 & 0x7F) << v158;
        v158 += 7;
        v159 |= v162;
        v156 = v161 + 1;
      }
      while ( ((unsigned __int8)v160 & 0x80) != 0 );
      if ( v159 )
        v163 = *(_QWORD *)(v253 + 8LL * (unsigned int)(v159 - 1));
      else
        v163 = 0LL;
      *(_QWORD *)(v43 + 96) = v163;
      if ( !a3[v155 - 1] )
        goto LABEL_145;
      v164 = a3[v155];
      v165 = *(int *)(v43 + 136);
      v166 = *(unsigned __int8 *)(v43 + 2);
      v167 = ((int)v165 - 1) >> v164;
      v168 = (v165 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      *(_DWORD *)(v43 + 160) = v164;
      v169 = v168 + 4 * v167 + 4;
      v170 = (unsigned __int8 *)sub_54F2A20(a1, v169, v166);
      v171 = *(_DWORD *)(v43 + 136);
      *(_DWORD *)(v43 + 156) = v169;
      *(_QWORD *)(v43 + 56) = v170;
      *(_QWORD *)(v43 + 64) = &v170[v168];
      if ( v171 < 1 )
      {
        ++v155;
        if ( (v167 & 0x80000000) == 0 )
          goto LABEL_140;
      }
      else
      {
        v172 = &a3[v155];
        v155 += 2LL;
        v173 = v172[1];
        *v170 = v173;
        if ( *(int *)(v43 + 136) >= 2 )
        {
          v174 = 1LL;
          do
          {
            v175 = *v161++;
            ++v155;
            v173 += v175;
            *(_BYTE *)(*(_QWORD *)(v43 + 56) + v174++) = v173;
          }
          while ( v174 < *(int *)(v43 + 136) );
        }
        if ( (v167 & 0x80000000) == 0 )
        {
LABEL_140:
          v176 = 0;
          v177 = *(_DWORD **)(v43 + 64);
          v178 = (unsigned int)(v167 + 1);
          v144 = a3 + 2;
          do
          {
            v179 = *(_DWORD *)&a3[v155];
            v155 += 4LL;
            --v178;
            v176 += v179;
            *v177++ = v176;
          }
          while ( v178 );
          goto LABEL_145;
        }
      }
      v144 = a3 + 2;
LABEL_145:
      v16 = v155 + 1;
      if ( a3[v155] )
      {
        v180 = 0;
        LODWORD(v181) = 0;
        v41 = v246;
        do
        {
          v182 = a3[v16++];
          v183 = (v182 & 0x7F) << v180;
          v180 += 7;
          v181 = v183 | (unsigned int)v181;
        }
        while ( (v182 & 0x80) != 0 );
        if ( (v181 & 0x80000000) != 0 )
          sub_54F2A0C(a1);
        v184 = sub_54F2A20(a1, 8 * (v181 + 2LL * (unsigned int)v181), *(unsigned __int8 *)(v43 + 2));
        *(_QWORD *)(v43 + 72) = v184;
        *(_DWORD *)(v43 + 144) = v181;
        if ( (_DWORD)v181 )
        {
          for ( n = 0LL; n != v181; ++n )
          {
            v186 = 0;
            v187 = 0;
            v188 = v16 + 3;
            v189 = &v144[v16];
            v190 = v16;
            do
            {
              v191 = a3[v190];
              v192 = v188;
              v193 = v189;
              ++v190;
              ++v189;
              v194 = (v191 & 0x7F) << v186;
              v186 += 7;
              v187 |= v194;
              v188 = v192 + 1;
            }
            while ( (v191 & 0x80) != 0 );
            if ( v187 )
              v195 = *(_QWORD *)(v253 + 8LL * (unsigned int)(v187 - 1));
            else
              v195 = 0LL;
            v196 = 0;
            v197 = 0;
            *(_QWORD *)(v184 + 24 * n) = v195;
            do
            {
              v198 = a3[v190];
              v16 = v192;
              v199 = (char *)v193;
              ++v190;
              ++v193;
              v200 = (v198 & 0x7F) << v196;
              v196 += 7;
              v197 |= v200;
              v192 = v16 + 1;
            }
            while ( (v198 & 0x80) != 0 );
            v201 = 0;
            v202 = 0;
            *(_DWORD *)(v184 + 24 * n + 8) = v197;
            do
            {
              v203 = *v199++;
              ++v16;
              v204 = (v203 & 0x7F) << v201;
              v201 += 7;
              v202 |= v204;
            }
            while ( v203 < 0 );
            v205 = v184 + 24 * n;
            *(_DWORD *)(v205 + 12) = v202;
            *(_BYTE *)(v205 + 16) = *v199;
          }
        }
        v206 = 0;
        LODWORD(v207) = 0;
        do
        {
          v208 = a3[v16++];
          v209 = (v208 & 0x7F) << v206;
          v206 += 7;
          v207 = v209 | (unsigned int)v207;
        }
        while ( (v208 & 0x80) != 0 );
        if ( (v207 & 0x80000000) != 0 )
          sub_54F2A0C(a1);
        *(_QWORD *)(v43 + 80) = sub_54F2A20(a1, 8 * v207, *(unsigned __int8 *)(v43 + 2));
        *(_DWORD *)(v43 + 148) = v207;
        if ( (_DWORD)v207 )
        {
          for ( ii = 0LL; ii != v207; ++ii )
          {
            v212 = 0;
            v213 = 0;
            do
            {
              v214 = a3[v16++];
              v215 = (v214 & 0x7F) << v212;
              v212 += 7;
              v213 |= v215;
            }
            while ( (v214 & 0x80) != 0 );
            if ( v213 )
              v211 = *(_QWORD *)(v253 + 8LL * (unsigned int)(v213 - 1));
            else
              v211 = 0LL;
            *(_QWORD *)(*(_QWORD *)(v43 + 80) + 8 * ii) = v211;
          }
        }
      }
      else
      {
        v41 = v246;
      }
      *(_QWORD *)(v251 + 8 * v250) = v43;
      v40 = v250 + 1;
      if ( v250 + 1 == v41 )
        goto LABEL_208;
    }
    if ( (unsigned int)v62 >= 3 )
    {
      v81 = v62 - 2;
      if ( (unsigned __int64)(v62 - 2) >= 2 )
      {
        v82 = (v81 & 0xFFFFFFFFFFFFFFFELL) + 2;
        v216 = v81 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          v217 = (unsigned __int8)*(v78 - 1) - 64;
          v218 = (unsigned __int8)*v78 - 64;
          if ( v217 <= 0x1F )
            *(v78 - 1) = *((_BYTE *)dest + v217);
          if ( v218 <= 0x1F )
            *v78 = *((_BYTE *)dest + v218);
          v78 += 2;
          v216 -= 2LL;
        }
        while ( v216 );
        if ( v81 == (v81 & 0xFFFFFFFFFFFFFFFELL) )
          goto LABEL_179;
      }
      else
      {
        v82 = 2LL;
      }
      v232 = (_BYTE *)(v79 + v82);
      v233 = v62 - v82;
      do
      {
        v234 = (unsigned __int8)*v232 - 64;
        if ( v234 <= 0x1F )
          *v232 = *((_BYTE *)dest + v234);
        ++v232;
        --v233;
      }
      while ( v233 );
    }
LABEL_179:
    v60 += v62;
    goto LABEL_180;
  }
LABEL_208:
  v235 = 0;
  v236 = 0;
  v237 = &a3[v16];
  do
  {
    v238 = *v237++;
    v239 = (v238 & 0x7F) << v235;
    v235 += 7;
    v236 |= v239;
  }
  while ( v238 < 0 );
  if ( (*(_BYTE *)(a1 + 1) & 4) != 0 )
    sub_54EF570(a1, a1, a1 + 104);
  v240 = sub_54EE060(a1, 0LL, v249);
  v241 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v241 = v240;
  *(_DWORD *)(v241 + 12) = 7;
  v242 = *(_QWORD *)(a1 + 8);
  if ( *(_QWORD *)(a1 + 40) - v242 <= 16 )
  {
    sub_54ED1D0(a1, 1LL);
    v242 = *(_QWORD *)(a1 + 8);
  }
  *(_QWORD *)(a1 + 8) = v242 + 16;
  sub_54F2D00(a1, v251, 8 * v252, 0LL);
  sub_54F2D00(a1, v253, 8 * v18, 0LL);
  result = 0LL;
  *(_QWORD *)(v244 + 64) = v243;
  return result;
}


================================================================================
Function: sub_55079C8 (0x55079C8)
================================================================================

__int64 __fastcall sub_55079C8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // x0
  int v6; // w20
  __int64 result; // x0

  v5 = sub_5507A4C(a3, a4);
  v6 = v5;
  result = sub_5507D98(v5, 1LL);
  if ( v6 && (v6 == 2 && byte_6F12390 || v6 == 3 && byte_6F123B0 || v6 == 6 && byte_6F123D0) )
    *(_DWORD *)(*(_QWORD *)(a1 + 24) + 3232LL) &= ~0x40000000u;
  return result;
}


================================================================================
Function: sub_5507A4C (0x5507A4C)
================================================================================

__int64 __fastcall sub_5507A4C(_BYTE *a1, unsigned __int64 a2)
{
  unsigned __int8 *v2; // x9
  int v3; // w11
  unsigned __int8 *v4; // x19
  unsigned __int8 *v5; // x10
  __int64 v6; // x9
  int v8; // w15
  char v9; // w14
  int v10; // w14
  __int64 v11; // x8
  unsigned __int8 v12; // w10
  char *v13; // x10
  int v14; // w11
  char v15; // w12
  char v16; // w11
  _OWORD v17[2]; // [xsp+0h] [xbp-50h] BYREF
  _OWORD v18[2]; // [xsp+20h] [xbp-30h] BYREF

  if ( !a2 || !*a1 )
    return 0LL;
  if ( a2 < 0x65 )
    return 2LL;
  v2 = &a1[a2 - 100];
  v4 = v2 + 36;
  v3 = v2[36];
  v5 = v2 + 4;
  if ( (v3 ^ 0x37) != *v2 || (v2[37] ^ 0xB4) != v2[1] || (v2[38] ^ 0x59) != v2[2] || (v2[39] ^ 0xF6) != v2[3] )
    return 2LL;
  v6 = 0LL;
  LOBYTE(v18[0]) = *v5 ^ v3;
  *(int8x16_t *)((char *)v18 + 1) = veorq_s8(*(int8x16_t *)(v5 + 1), *(int8x16_t *)(v5 + 33));
  *(int8x8_t *)((char *)&v18[1] + 1) = veor_s8(*(int8x8_t *)(v5 + 17), *(int8x8_t *)(v5 + 49));
  BYTE9(v18[1]) = v5[25] ^ v5[57];
  BYTE10(v18[1]) = v5[26] ^ v5[58];
  BYTE11(v18[1]) = v5[27] ^ v5[59];
  BYTE12(v18[1]) = v5[28] ^ v5[60];
  BYTE13(v18[1]) = v5[29] ^ v5[61];
  BYTE14(v18[1]) = v5[30] ^ v5[62];
  HIBYTE(v18[1]) = v5[31] ^ v5[63];
  do
  {
    v10 = v6 & 3;
    if ( (v6 & 3) != 0 )
    {
      if ( v10 == 1 )
      {
        LOBYTE(v8) = -3 - (v6 & 3);
        v9 = (v6 & 3) + 3;
      }
      else if ( v10 == 3 )
      {
        LOBYTE(v8) = ~(v6 & 3);
        v9 = (v6 & 3) + 1;
      }
      else
      {
        v8 = -(v6 | 4);
        v9 = v6 & 3 | 4;
      }
    }
    else
    {
      LOBYTE(v8) = -2 - (v6 & 3);
      v9 = (v6 & 3) + 2;
    }
    *((_BYTE *)v18 + v6) = ((*((_BYTE *)v18 + v6) ^ 0xC7) << v9) | ((unsigned __int8)(*((_BYTE *)v18 + v6) ^ 0xC7) >> (v8 & 7));
    ++v6;
  }
  while ( v6 != 32 );
  if ( *(_QWORD *)&v18[0] ^ 0xC9808EC736950ED6LL | *((_QWORD *)&v18[0] + 1) ^ 0xC536EBB3CD934AB4LL | *(_QWORD *)&v18[1] ^ 0xF2678A2F9E8F1092LL | *((_QWORD *)&v18[1] + 1) ^ 0x172BFDE4C2511367LL )
    return 3LL;
  memset(v18, 0, sizeof(v18));
  if ( (unsigned int)sub_677415C(v18, a1) )
    return 4LL;
  v11 = 0LL;
  v12 = 55;
  v17[0] = xmmword_1021132;
  v17[1] = unk_1021142;
LABEL_32:
  v16 = (v11 & 3) + 2;
  while ( 1 )
  {
    *((_BYTE *)v17 + v11) = ((v12 >> (v16 & 7)) | (v12 << (-v16 & 7))) ^ 0xC7;
    if ( v11 == 31 )
      break;
    v13 = (char *)v17 + v11++;
    v12 = v13[1];
    v14 = v11 & 3;
    if ( (v11 & 3) == 0 )
      goto LABEL_32;
    if ( v14 == 3 )
      v15 = 4;
    else
      v15 = v11 | 4;
    if ( v14 == 1 )
      v16 = (v11 & 3) + 3;
    else
      v16 = v15;
  }
  if ( (unsigned int)sub_677A8BC(v4, v18, 32LL, v17) )
    return 6LL;
  else
    return 0LL;
}


================================================================================
Function: sub_5507D98 (0x5507D98)
================================================================================

__int64 __fastcall sub_5507D98(__int64 result, int a2)
{
  int v3; // w20
  __int64 (__fastcall **v4)(); // [xsp+8h] [xbp-228h] BYREF
  _BYTE v5[40]; // [xsp+10h] [xbp-220h] BYREF
  _BYTE v6[472]; // [xsp+50h] [xbp-1E0h] BYREF

  if ( (_DWORD)result )
  {
    v3 = result;
    sub_255C8E8(&v4, &unk_6F12358);
    sub_61E5884(v6, "source", 6LL, "client", 1LL);
    sub_61E4E08(v6, "action", 6LL, a2, 1LL);
    sub_61E4E08(v6, "code", 4LL, v3, 1LL);
    sub_61D5D94(&v4);
    sub_250A6BC(v6, off_6BA0860);
    v4 = off_6BA08F8;
    if ( (v5[24] & 1) != 0 )
      sub_6575460();
    return nullsub_257(v5);
  }
  return result;
}


================================================================================
Function: sub_61CC7A4 (0x61CC7A4)
================================================================================

__int64 sub_61CC7A4()
{
  int v0; // w19
  unsigned __int8 v1; // w8

  v0 = sub_6574924(dword_6F7D1D8);
  v1 = atomic_load(byte_6F759B0);
  if ( (v1 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6F759B0) )
  {
    qword_6F75970 = (__int64)off_67F87E8;
    sub_67D19DC(&stru_6F75978);
    qword_6F759A0 = 0LL;
    unk_6F759A8 = 0LL;
    qword_6F75970 = (__int64)off_6BA00F8;
    qword_6F759B8 = (__int64)&qword_6F75970;
    sub_67EB838(byte_6F759B0);
  }
  sub_61CE0D0((__int64)&qword_6F75970);
  return sub_6574924(v0);
}


================================================================================
Function: sub_61CE0D0 (0x61CE0D0)
================================================================================

__int64 __fastcall sub_61CE0D0(__int64 a1)
{
  unsigned __int64 v2; // x20
  unsigned __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_67F0440(1LL, a1 + 56);
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65786C4(0LL, "Reference count overflow");
  if ( v2 >> 62 != 2 )
  {
    sub_6577E74(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7286220);
      v5 = sub_6585904(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_6207178(v5);
      sub_67F05F0(0x8000000000000000LL, a1 + 56);
    }
    sub_67D1AF4(a1 + 8);
  }
  return a1;
}


================================================================================
Function: sub_61D2A18 (0x61D2A18)
================================================================================

__int64 __fastcall sub_61D2A18(_DWORD *a1)
{
  __int64 result; // x0

  result = sub_6574924(dword_6F762A8);
  *a1 = result;
  return result;
}


================================================================================
Function: nullsub_257 (0x61D2A48)
================================================================================

void nullsub_257()
{
  ;
}


================================================================================
Function: sub_61D2A4C (0x61D2A4C)
================================================================================

__int64 __fastcall sub_61D2A4C(int *a1)
{
  int v1; // w8

  v1 = *a1;
  *a1 = 0;
  return sub_6574924(v1);
}


================================================================================
Function: sub_61D5D94 (0x61D5D94)
================================================================================

_QWORD *__fastcall sub_61D5D94(__int64 a1)
{
  unsigned __int8 v2; // w8
  __int64 v3; // x20
  _QWORD **v4; // x0
  _QWORD *v5; // x8
  unsigned __int8 v6; // w8
  const char *v7; // x2
  unsigned int v8; // w20
  __int64 v9; // x1
  unsigned __int64 v10; // x8
  bool v11; // zf
  unsigned __int64 v12; // x8
  __int64 v13; // x9
  __int64 v14; // x10
  unsigned __int8 v15; // w8
  _QWORD **v16; // x22
  _QWORD *result; // x0
  __int64 v18; // [xsp+0h] [xbp-A0h] BYREF
  _QWORD *v19; // [xsp+8h] [xbp-98h]
  __int64 v20; // [xsp+10h] [xbp-90h]
  __int64 v21; // [xsp+18h] [xbp-88h]
  __int128 v22; // [xsp+20h] [xbp-80h]
  __int128 v23; // [xsp+30h] [xbp-70h]
  __int128 v24; // [xsp+40h] [xbp-60h]
  int v25; // [xsp+50h] [xbp-50h]
  __int64 v26; // [xsp+58h] [xbp-48h]
  __int64 v27; // [xsp+60h] [xbp-40h]
  char v28; // [xsp+68h] [xbp-38h]
  __int64 v29; // [xsp+70h] [xbp-30h]
  unsigned __int64 v30; // [xsp+78h] [xbp-28h]
  __int64 v31; // [xsp+80h] [xbp-20h]
  __int64 v32; // [xsp+88h] [xbp-18h]

  v2 = atomic_load(byte_6F75D80);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6F75D80) )
  {
    qword_6F75D78 = sub_64BF11C("Telemetry", "Counter::send", 0xFFFFFFFFLL);
    sub_67EB838(byte_6F75D80);
  }
  v3 = qword_6F75D78;
  v18 = 0LL;
  v19 = 0LL;
  v25 = 0;
  v26 = 0LL;
  v27 = 0LL;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v28 = 0;
  v20 = qword_6F75D78;
  v21 = -1LL;
  v4 = (_QWORD **)sub_2550CD0();
  v5 = *v4;
  v19 = v5;
  if ( v5 )
    *v5 = &v18;
  *v4 = &v18;
  if ( byte_71CF7B0 )
  {
    v28 = byte_6F7D6E8;
    if ( byte_6F7D6E8 )
      sub_64AB8F8(v3);
  }
  else
  {
    v28 = 0;
  }
  v21 = sub_64BFCFC(v3, -1LL, 0LL);
  v6 = atomic_load(byte_6F75D90);
  if ( (v6 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6F75D90) )
  {
    qword_6F75D88 = sub_64BFCB4("Telemetry");
    sub_67EB838(byte_6F75D90);
  }
  if ( (*(_BYTE *)(a1 + 32) & 1) != 0 )
    v7 = *(const char **)(a1 + 48);
  else
    v7 = (const char *)(a1 + 33);
  sub_64BFEFC(qword_6F75D88, "%s (Counter)", v7);
  v8 = sub_6574924((unsigned int)dword_6F75D70);
  if ( !byte_6F75D50 )
  {
    v9 = qword_6F75910;
    if ( byte_71CF7B0 && byte_71CF760 )
    {
      if ( (unsigned __int8)qword_6F75908 < 6u || (qword_6F75908 & 0xFC00) == 0 )
        goto LABEL_23;
    }
    else if ( !(_BYTE)qword_6F75908 )
    {
LABEL_23:
      v15 = atomic_load(byte_6F759B0);
      if ( (v15 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6F759B0) )
      {
        qword_6F75970 = (__int64)off_67F87E8;
        sub_67D19DC(&stru_6F75978);
        qword_6F759A0 = 0LL;
        unk_6F759A8 = 0LL;
        qword_6F75970 = (__int64)off_6BA00F8;
        qword_6F759B8 = (__int64)&qword_6F75970;
        sub_67EB838(byte_6F759B0);
      }
      v16 = (_QWORD **)sub_61CE0D0(&qword_6F75970, v9);
      if ( !byte_71CF7B0 || !byte_6F765A8 || (unsigned int)sub_61E46D4(a1 + 32) >= dword_6F765D8 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 72) + 312LL))(a1 + 72);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 72) + 304LL))(a1 + 72);
      (*(void (__fastcall **)(_QWORD *, __int64))(*v16[6] + 32LL))(v16[6], a1);
      ((void (__fastcall *)(_QWORD **))(*v16)[2])(v16);
      goto LABEL_29;
    }
    v10 = *(unsigned __int8 *)(a1 + 32);
    v11 = (v10 & 1) == 0;
    v12 = v10 >> 1;
    if ( v11 )
    {
      v13 = a1 + 33;
    }
    else
    {
      v12 = *(_QWORD *)(a1 + 40);
      v13 = *(_QWORD *)(a1 + 48);
    }
    v14 = *(_QWORD *)(a1 + 536);
    v29 = v13;
    v30 = v12;
    v31 = v14;
    v32 = 0LL;
    sub_654E8B4(qword_6F75908);
    goto LABEL_23;
  }
LABEL_29:
  sub_6574924(v8);
  sub_64BFFEC(v20, v21, -1LL, 0LL, 0LL);
  result = (_QWORD *)sub_2550CD0();
  *result = v19;
  if ( v19 )
    *v19 = 0LL;
  if ( v28 )
    return (_QWORD *)sub_64AB960(v20);
  return result;
}


================================================================================
Function: sub_61E46D4 (0x61E46D4)
================================================================================

__int64 __fastcall sub_61E46D4(unsigned __int8 *a1)
{
  int v2; // w0
  unsigned __int8 *v3; // x9
  unsigned __int64 v4; // x10
  int v5; // w19
  unsigned __int64 v6; // x8
  bool v7; // zf
  unsigned __int64 v8; // x8
  unsigned __int8 *v9; // x0
  unsigned __int64 v10; // x1
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x20
  size_t v14[2]; // [xsp+0h] [xbp-150h] BYREF
  __int128 v15; // [xsp+18h] [xbp-138h] BYREF
  unsigned __int64 v16; // [xsp+30h] [xbp-120h] BYREF
  _QWORD v17[2]; // [xsp+38h] [xbp-118h] BYREF
  _QWORD v18[8]; // [xsp+48h] [xbp-108h] BYREF
  __int128 v19; // [xsp+88h] [xbp-C8h]
  __int128 v20; // [xsp+98h] [xbp-B8h]
  int v21; // [xsp+A8h] [xbp-A8h]
  _QWORD v22[18]; // [xsp+B0h] [xbp-A0h] BYREF
  int v23; // [xsp+140h] [xbp-10h]

  v2 = sub_6574924(dword_6F7D1D8);
  v4 = *((_QWORD *)a1 + 1);
  v3 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  v5 = v2;
  v16 = 0LL;
  v6 = *a1;
  v7 = (v6 & 1) == 0;
  v8 = v6 >> 1;
  if ( v7 )
    v9 = a1 + 1;
  else
    v9 = v3;
  if ( v7 )
    v10 = v8;
  else
    v10 = v4;
  sub_654CD24(&v15, v9, v10);
  if ( (v15 & 1) != 0 )
    v11 = *((_QWORD *)&v15 + 1);
  else
    v11 = (unsigned __int64)(unsigned __int8)v15 >> 1;
  if ( v11 < 0x11 )
    sub_67D2788(v14, &v15);
  else
    sub_67D2CC8(v14, (unsigned __int8 *)&v15, v11 - 16, 0xFFFFFFFFFFFFFFFFLL);
  v22[0] = off_6810570;
  v17[0] = off_6810548;
  v17[1] = 0LL;
  sub_67A8530(v22, v18);
  v22[17] = 0LL;
  v23 = -1;
  v17[0] = off_68104D8;
  v22[0] = off_6810500;
  sub_67A5110(v18);
  v21 = 8;
  v19 = 0u;
  v20 = 0u;
  v18[0] = off_67FDA98;
  sub_26B93A8(v18, v14);
  *(_DWORD *)((char *)&v17[1] + *(_QWORD *)(v17[0] - 24LL)) = *(_DWORD *)((_BYTE *)&v17[1] + *(_QWORD *)(v17[0] - 24LL)) & 0xFFFFFFB5 | 8;
  sub_67A5C50(v17, &v16);
  v22[0] = off_6810500;
  v17[0] = off_68104D8;
  v18[0] = off_67FDA98;
  if ( (v19 & 1) != 0 )
    sub_6575460();
  sub_6589C04(v18);
  sub_67A5550(v17, off_6810518);
  sub_67A501C(v22);
  if ( (v14[0] & 1) != 0 )
    sub_6575460();
  v12 = v16 % 0x64;
  v16 %= 0x64uLL;
  if ( (v15 & 1) != 0 )
    sub_6575460();
  sub_6574924(v5);
  return (unsigned int)v12;
}


================================================================================
Function: sub_61E4E08 (0x61E4E08)
================================================================================

__int64 __fastcall sub_61E4E08(__int64 a1, const void *a2, size_t a3, __int64 a4)
{
  unsigned int v8; // w19
  __int64 v9; // x0
  char *v10; // x24
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x10
  __int128 v13; // q0
  char *v14; // x9
  __int128 v15; // q0
  __int128 v17; // [xsp+8h] [xbp-48h] BYREF
  char *v18; // [xsp+18h] [xbp-38h]
  __int128 v19; // [xsp+20h] [xbp-30h] BYREF
  char *v20; // [xsp+30h] [xbp-20h]
  __int64 v21; // [xsp+38h] [xbp-18h]

  v8 = sub_6574924((unsigned int)dword_6F762A8);
  v9 = sub_6574924((unsigned int)dword_6F762A8);
  sub_6574924(v9);
  if ( !a2 )
  {
    v17 = 0uLL;
    v18 = 0LL;
    goto LABEL_10;
  }
  if ( a3 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618(&v17);
  if ( a3 >= 0x17 )
  {
    v10 = (char *)sub_6575418();
    *((_QWORD *)&v17 + 1) = a3;
    v18 = v10;
    *(_QWORD *)&v17 = (a3 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v10 = (char *)&v17 + 1;
    LOBYTE(v17) = 2 * a3;
    if ( !a3 )
      goto LABEL_9;
  }
  memcpy(v10, a2, a3);
LABEL_9:
  v10[a3] = 0;
LABEL_10:
  v11 = *(_QWORD *)(a1 + 24);
  v12 = *(_QWORD *)(a1 + 32);
  v13 = v17;
  v17 = 0uLL;
  v14 = v18;
  v18 = 0LL;
  v19 = v13;
  v20 = v14;
  v21 = a4;
  if ( v11 >= v12 )
  {
    sub_61EBC44(a1 + 16, &v19);
    if ( (v19 & 1) != 0 )
      sub_6575460();
  }
  else
  {
    v15 = v19;
    *(_QWORD *)(v11 + 16) = v20;
    *(_OWORD *)v11 = v15;
    v20 = 0LL;
    v19 = 0uLL;
    *(_QWORD *)(v11 + 24) = v21;
    *(_QWORD *)(a1 + 24) = v11 + 32;
  }
  if ( (v17 & 1) != 0 )
    sub_6575460();
  return sub_6574924(v8);
}


================================================================================
Function: sub_61E5884 (0x61E5884)
================================================================================

__int64 __fastcall sub_61E5884(__int64 a1, __int64 a2, __int64 a3, const char *a4, unsigned int a5)
{
  unsigned int v10; // w19
  size_t v11; // x4

  v10 = sub_6574924((unsigned int)dword_6F762A8);
  if ( a4 )
    v11 = strlen(a4);
  else
    v11 = 0LL;
  (*(void (__fastcall **)(__int64, __int64, __int64, const char *, size_t, _QWORD))(*(_QWORD *)a1 + 24LL))(
    a1,
    a2,
    a3,
    a4,
    v11,
    a5);
  return sub_6574924(v10);
}


================================================================================
Function: sub_61EBC44 (0x61EBC44)
================================================================================

__int64 __fastcall sub_61EBC44(__int64 *a1, __int128 *a2)
{
  __int64 v3; // x22
  unsigned __int64 v4; // x8
  __int64 v5; // x9
  __int64 v6; // x21
  __int64 result; // x0
  __int128 v9; // q0
  __int64 v10; // x12
  __int64 v11; // x13
  __int64 v12; // x10
  __int64 v13; // x11
  __int64 v14; // x20
  __int64 v15; // x8
  __int64 v16; // x9
  __int64 v17; // x12
  __int128 v18; // q0
  bool v19; // zf
  __int64 v20; // x14
  __int64 v21; // x11
  __int64 v22; // x19
  char v23; // t1

  v3 = (a1[1] - *a1) >> 5;
  v4 = v3 + 1;
  if ( (unsigned __int64)(v3 + 1) >> 59 )
    sub_67D6BD4(a1);
  v5 = a1[2] - *a1;
  if ( v5 >> 4 >= v4 )
    v4 = v5 >> 4;
  if ( (unsigned __int64)v5 >= 0x7FFFFFFFFFFFFFE0LL )
    v4 = 0x7FFFFFFFFFFFFFFLL;
  if ( v4 >> 59 )
    sub_24DE568("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v6 = 32 * v4;
  result = sub_6575418();
  v9 = *a2;
  *(_QWORD *)a2 = 0LL;
  *((_QWORD *)a2 + 1) = 0LL;
  v10 = *((_QWORD *)a2 + 2);
  v11 = *((_QWORD *)a2 + 3);
  *((_QWORD *)a2 + 2) = 0LL;
  v12 = result + 32 * v3;
  v14 = *a1;
  v13 = a1[1];
  v15 = result + v6;
  v16 = v12 + 32;
  *(_OWORD *)v12 = v9;
  *(_QWORD *)(v12 + 16) = v10;
  *(_QWORD *)(v12 + 24) = v11;
  if ( v13 == v14 )
  {
    *a1 = v12;
    a1[1] = v16;
    a1[2] = v15;
  }
  else
  {
    do
    {
      v17 = v12;
      v18 = *(_OWORD *)(v13 - 32);
      v19 = v13 - 32 == v14;
      *(_QWORD *)(v12 - 16) = *(_QWORD *)(v13 - 16);
      v12 -= 32LL;
      *(_OWORD *)v12 = v18;
      *(_QWORD *)(v13 - 24) = 0LL;
      *(_QWORD *)(v13 - 16) = 0LL;
      v20 = *(_QWORD *)(v13 - 8);
      *(_QWORD *)(v13 - 32) = 0LL;
      v13 -= 32LL;
      *(_QWORD *)(v17 - 8) = v20;
    }
    while ( !v19 );
    v14 = *a1;
    v21 = a1[1];
    *a1 = v12;
    a1[1] = v16;
    a1[2] = v15;
    if ( v21 != v14 )
    {
      v22 = v21;
      do
      {
        v23 = *(_BYTE *)(v22 - 32);
        v22 -= 32LL;
        if ( (v23 & 1) != 0 )
          result = sub_6575460();
      }
      while ( v22 != v14 );
    }
  }
  if ( v14 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_61EBEF8 (0x61EBEF8)
================================================================================

__int64 __fastcall sub_61EBEF8(unsigned __int64 *a1, __int128 *a2, __int128 *a3)
{
  unsigned __int64 v4; // x22
  unsigned __int64 v5; // x10
  unsigned __int64 v8; // x23
  __int64 result; // x0
  __int64 v10; // x9
  __int128 v11; // q0
  unsigned __int64 v12; // x10
  __int64 v13; // x12
  unsigned __int64 v14; // x8
  __int128 v15; // q1
  unsigned __int64 v16; // x11
  unsigned __int64 v17; // x20
  unsigned __int64 v18; // x9
  __int128 v19; // q0
  __int64 v20; // x12
  __int128 v21; // q0
  bool v22; // zf
  unsigned __int64 v23; // x20
  unsigned __int64 v24; // x21
  unsigned __int64 v25; // x19

  v4 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(a1[1] - *a1) >> 4);
  v5 = v4 + 1;
  if ( v4 + 1 > 0x555555555555555LL )
    sub_67D6BD4();
  if ( 0x5555555555555556LL * ((__int64)(a1[2] - *a1) >> 4) >= v5 )
    v5 = 0x5555555555555556LL * ((__int64)(a1[2] - *a1) >> 4);
  if ( 0xAAAAAAAAAAAAAAABLL * ((__int64)(a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL )
    v8 = 0x555555555555555LL;
  else
    v8 = v5;
  if ( v8 )
  {
    if ( v8 > 0x555555555555555LL )
      sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    result = sub_6575418();
  }
  else
  {
    result = 0LL;
  }
  v10 = *((_QWORD *)a2 + 2);
  v11 = *a2;
  *(_QWORD *)a2 = 0LL;
  *((_QWORD *)a2 + 1) = 0LL;
  *((_QWORD *)a2 + 2) = 0LL;
  v12 = result + 48 * v4;
  v13 = *((_QWORD *)a3 + 2);
  v14 = result + 48 * v8;
  v15 = *a3;
  *(_QWORD *)a3 = 0LL;
  *((_QWORD *)a3 + 1) = 0LL;
  *((_QWORD *)a3 + 2) = 0LL;
  v17 = *a1;
  v16 = a1[1];
  *(_QWORD *)(v12 + 16) = v10;
  v18 = v12 + 48;
  *(_OWORD *)v12 = v11;
  *(_OWORD *)(v12 + 24) = v15;
  *(_QWORD *)(v12 + 40) = v13;
  if ( v16 == v17 )
  {
    *a1 = v12;
    a1[1] = v18;
    a1[2] = v14;
    if ( v17 )
      return sub_6575460();
  }
  else
  {
    do
    {
      v19 = *(_OWORD *)(v16 - 48);
      *(_QWORD *)(v12 - 32) = *(_QWORD *)(v16 - 32);
      *(_OWORD *)(v12 - 48) = v19;
      v20 = *(_QWORD *)(v16 - 8);
      *(_QWORD *)(v16 - 40) = 0LL;
      *(_QWORD *)(v16 - 32) = 0LL;
      v21 = *(_OWORD *)(v16 - 24);
      *(_QWORD *)(v16 - 48) = 0LL;
      *(_QWORD *)(v12 - 8) = v20;
      *(_OWORD *)(v12 - 24) = v21;
      v12 -= 48LL;
      *(_QWORD *)(v16 - 16) = 0LL;
      *(_QWORD *)(v16 - 8) = 0LL;
      v22 = v16 - 48 == v17;
      *(_QWORD *)(v16 - 24) = 0LL;
      v16 -= 48LL;
    }
    while ( !v22 );
    v23 = *a1;
    v24 = a1[1];
    *a1 = v12;
    a1[1] = v18;
    a1[2] = v14;
    if ( v24 != v23 )
    {
      do
      {
        if ( (*(_BYTE *)(v24 - 24) & 1) != 0 )
          result = sub_6575460();
        v25 = v24 - 48;
        if ( (*(_BYTE *)(v24 - 48) & 1) != 0 )
          result = sub_6575460();
        v24 -= 48LL;
      }
      while ( v25 != v23 );
    }
    if ( v23 )
      return sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_6207178 (0x6207178)
================================================================================

_QWORD *sub_6207178()
{
  _QWORD *v0; // x19
  unsigned __int8 v1; // w8
  __int64 v2; // x8
  _QWORD *result; // x0

  v0 = (_QWORD *)sub_6575418();
  v0[1] = "RobloxTelemetryImpl";
  v0[2] = 19LL;
  *v0 = off_6BA3388;
  v1 = atomic_load(byte_6D6E158);
  if ( (v1 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6D6E158) )
  {
    qword_6D6E118 = (__int64)off_67F87E8;
    sub_67D19DC(&stru_6D6E120);
    qword_6D6E148 = 0LL;
    unk_6D6E150 = 0LL;
    qword_6D6E118 = (__int64)off_68E8478;
    qword_6D6E160 = (__int64)&qword_6D6E118;
    sub_67EB838(byte_6D6E158);
  }
  v2 = sub_3C8D8E4(&qword_6D6E118);
  result = v0;
  v0[3] = v2;
  return result;
}


================================================================================
Function: sub_621054C (0x621054C)
================================================================================

__int64 __fastcall sub_621054C(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_67F0440(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65786C4(0);
  if ( v2 >> 62 != 2 )
  {
    sub_6577E74(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7286220);
      v5 = sub_6585904(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_62107D0(v5);
      sub_67F05F0(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_67D1AF4((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_62107D0 (0x62107D0)
================================================================================

__int64 sub_62107D0()
{
  __int64 v0; // x19

  v0 = sub_6575FA8(0x58uLL, 8uLL);
  sub_6421008();
  return v0;
}


================================================================================
Function: sub_6216264 (0x6216264)
================================================================================

__int64 __fastcall sub_6216264(__int64 a1, char *s, int a3, int a4)
{
  _BYTE *v5; // x20
  size_t v7; // x0
  size_t v8; // x22
  void *v9; // x23
  unsigned __int64 v10; // x24

  v5 = (_BYTE *)(a1 + 16);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = a4;
  v7 = strlen(s);
  if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v8 = v7;
  if ( v7 >= 0x17 )
  {
    v10 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v9 = (void *)sub_6575418();
    *(_QWORD *)(a1 + 24) = v8;
    *(_QWORD *)(a1 + 32) = v9;
    *(_QWORD *)(a1 + 16) = v10 | 1;
  }
  else
  {
    *v5 = 2 * v7;
    v9 = v5 + 1;
    if ( !v7 )
      goto LABEL_7;
  }
  v7 = (size_t)memcpy(v9, s, v8);
LABEL_7:
  *((_BYTE *)v9 + v8) = 0;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_OWORD *)(a1 + 40) = 0u;
  return sub_6216380(v7);
}


================================================================================
Function: sub_621636C (0x621636C)
================================================================================

__int64 __fastcall sub_621636C(int a1, __int64 a2)
{
  char *v2; // x1

  if ( (*(_BYTE *)a2 & 1) != 0 )
    v2 = *(char **)(a2 + 16);
  else
    v2 = (char *)(a2 + 1);
  return sub_6216264(a1, v2);
}


================================================================================
Function: sub_6216380 (0x6216380)
================================================================================

__int64 sub_6216380()
{
  __int64 result; // x0
  unsigned __int64 v1; // x8
  __int128 *v2; // x0
  __int128 *v3; // x0
  __int128 *v4; // x0
  pthread_mutex_t *v5; // x19
  __int128 v6; // [xsp+38h] [xbp-98h] BYREF
  __int128 v7; // [xsp+50h] [xbp-80h] BYREF
  __int128 v8; // [xsp+68h] [xbp-68h] BYREF
  __int64 v9; // [xsp+78h] [xbp-58h]
  unsigned __int64 v10[2]; // [xsp+80h] [xbp-50h] BYREF
  pthread_mutex_t *v11; // [xsp+B8h] [xbp-18h] BYREF
  char v12; // [xsp+C0h] [xbp-10h]

  v11 = (pthread_mutex_t *)&unk_6F77490;
  v12 = 0;
  result = sub_25A70B8((__int64)&v11);
  if ( (xmmword_6F77460 & 1) != 0 )
    v1 = *((_QWORD *)&xmmword_6F77460 + 1);
  else
    v1 = (unsigned __int64)(unsigned __int8)xmmword_6F77460 >> 1;
  if ( !v1 )
  {
    sub_65386A0(&v6, 0LL, 3LL, 0LL);
    sub_67D2788((unsigned __int64 *)&v8, &v6);
    v2 = (__int128 *)sub_6762998((int)&v8);
    sub_67D2788((unsigned __int64 *)&v7, v2);
    if ( (v8 & 1) != 0 )
      sub_6575460();
    sub_67D2788((unsigned __int64 *)&v8, &v7);
    v3 = (__int128 *)sub_6762998((int)&v8);
    sub_67D2788(v10, v3);
    if ( (v8 & 1) != 0 )
      sub_6575460();
    if ( (v7 & 1) != 0 )
      sub_6575460();
    if ( (v6 & 1) != 0 )
      sub_6575460();
    if ( (sub_655E930(v10) & 1) == 0 )
    {
      sub_65386A0(&v6, 0LL, 3LL, 0LL);
      sub_67D2788((unsigned __int64 *)&v8, &v6);
      v4 = (__int128 *)sub_6762998((int)&v8);
      sub_67D2788((unsigned __int64 *)&v7, v4);
      if ( (v8 & 1) != 0 )
        sub_6575460();
      sub_67D3420((unsigned __int8 *)v10, (unsigned __int8 *)&v7);
      if ( (v7 & 1) != 0 )
        sub_6575460();
      if ( (v6 & 1) != 0 )
        sub_6575460();
    }
    result = (__int64)sub_6584E94(&v8, v10);
    if ( (xmmword_6F77460 & 1) != 0 )
      result = sub_6575460();
    xmmword_6F77460 = v8;
    qword_6F77470 = v9;
    byte_6F773FC = 1;
    if ( (v10[0] & 1) != 0 )
      result = sub_6575460();
  }
  if ( v12 )
  {
    v5 = v11;
    do
      result = pthread_mutex_unlock(v5);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25A6430(v10, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300((__int64)v10);
    }
  }
  return result;
}


================================================================================
Function: sub_6216928 (0x6216928)
================================================================================

__int64 *sub_6216928()
{
  return &qword_6F773E0;
}


================================================================================
Function: sub_62169F8 (0x62169F8)
================================================================================

__int64 __fastcall sub_62169F8(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        char a5,
        __int64 a6,
        char a7,
        char a8,
        char a9)
{
  unsigned int v17; // w0
  __int64 v18; // x19
  _QWORD *v19; // x0
  __int64 v20; // x8
  pthread_mutex_t *v21; // x19
  unsigned int v22; // w1
  unsigned __int64 *v23; // x19
  __int64 result; // x0
  __int64 v25; // x20
  _QWORD *v26; // x19
  _QWORD v27[2]; // [xsp+10h] [xbp-140h] BYREF
  __int64 v28; // [xsp+20h] [xbp-130h] BYREF
  _QWORD v29[2]; // [xsp+28h] [xbp-128h] BYREF
  __int64 v30; // [xsp+38h] [xbp-118h]
  char v31; // [xsp+44h] [xbp-10Ch] BYREF
  _QWORD v32[7]; // [xsp+48h] [xbp-108h] BYREF
  pthread_mutex_t *p_mutex; // [xsp+80h] [xbp-D0h] BYREF
  char v34; // [xsp+88h] [xbp-C8h]
  _BYTE v35[32]; // [xsp+90h] [xbp-C0h] BYREF
  _BYTE *v36; // [xsp+B0h] [xbp-A0h]
  pthread_mutex_t v37; // [xsp+C0h] [xbp-90h] BYREF
  pthread_cond_t v38; // [xsp+E8h] [xbp-68h] BYREF
  pthread_mutex_t mutex; // [xsp+118h] [xbp-38h] BYREF

  v17 = pthread_mutex_init(&mutex, 0LL);
  if ( v17 )
  {
    sub_25A21C8(&v37, v17, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)&v37);
  }
  sub_25A1F60((__int64)&v37);
  v31 = 0;
  v29[1] = a3;
  v18 = sub_6575418();
  *(_QWORD *)(v18 + 16) = 0LL;
  *(_QWORD *)(v18 + 24) = a3;
  v30 = v18;
  *(_QWORD *)v18 = off_6BA39D8;
  v27[0] = a3;
  v27[1] = v18;
  *(_QWORD *)(v18 + 8) = 0LL;
  v28 = 0LL;
  v29[0] = 0LL;
  sub_67F0410(1uLL, (atomic_ullong *)(v18 + 8));
  v19 = (_QWORD *)sub_6575418();
  v36 = v19;
  *v19 = off_6BA3A28;
  v19[1] = a6;
  v19[2] = v29;
  v19[3] = &v28;
  v19[4] = &mutex;
  v19[5] = &v31;
  v19[6] = &v37;
  sub_6216E04(a1, a2, v27, a4, a5 & 1, v35, a7 & 1, a8 & 1, a9 & 1);
  if ( v35 == v36 )
  {
    v20 = 4LL;
  }
  else
  {
    if ( !v36 )
      goto LABEL_7;
    v20 = 5LL;
  }
  (*(void (**)(void))(*(_QWORD *)v36 + 8 * v20))();
LABEL_7:
  if ( !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v18 + 8)) )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 16LL))(v18);
    sub_67D18A4((unsigned __int64 *)v18);
  }
  v34 = 0;
  p_mutex = &mutex;
  sub_25A70B8(&p_mutex);
  while ( !v31 )
    sub_25A6F10(&v37, &p_mutex);
  if ( v34 )
  {
    v21 = p_mutex;
    do
      v22 = pthread_mutex_unlock(v21);
    while ( v22 == 4 );
    if ( v22 )
    {
      sub_25A6430(v32, v22, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300((__int64)v32);
    }
  }
  if ( v29[0] )
  {
    v25 = sub_67EAFB8(40LL);
    sub_6217294(v25, v29[0]);
    sub_67EB030(v25, (__int64)&`typeinfo for'RBX::http_status_error, (__int64)sub_3BDE2A8);
  }
  if ( v28 )
  {
    v26 = (_QWORD *)sub_67EAFB8(16LL);
    sub_67D25E0(v26, v28);
    sub_67EB030((__int64)v26, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_67EE34C);
  }
  v23 = (unsigned __int64 *)v30;
  if ( v30 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v30 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v23 + 16))(v23);
    sub_67D18A4(v23);
  }
  while ( pthread_mutex_destroy(&v37) == 4 )
    ;
  while ( pthread_cond_destroy(&v38) == 4 )
    ;
  do
    result = pthread_mutex_destroy(&mutex);
  while ( (_DWORD)result == 4 );
  return result;
}


================================================================================
Function: sub_6216E04 (0x6216E04)
================================================================================

__int64 __fastcall sub_6216E04(
        __int64 a1,
        __int128 *a2,
        __int64 *a3,
        __int128 *a4,
        char a5,
        __int64 a6,
        char a7,
        char a8,
        char a9)
{
  _QWORD *v17; // x0
  __int64 v18; // x8
  __int64 v19; // x0
  _QWORD *v20; // x0
  __int64 v21; // x9
  __int64 v22; // x10
  _QWORD *v23; // x20
  __int64 v24; // x8
  __int64 v25; // x9
  _BYTE *v26; // x0
  char v27; // w8
  __int64 v28; // x8
  __int64 result; // x0
  __int64 v30; // x8
  unsigned __int64 *v31; // x19
  unsigned __int64 *v32; // x19
  unsigned __int64 *v33; // x19
  __int64 v34; // [xsp+8h] [xbp-F8h]
  __int64 v35; // [xsp+10h] [xbp-F0h] BYREF
  __int64 v36; // [xsp+18h] [xbp-E8h]
  __int64 v37; // [xsp+20h] [xbp-E0h]
  __int64 v38; // [xsp+28h] [xbp-D8h]
  __int128 v39; // [xsp+30h] [xbp-D0h] BYREF
  __int64 v40; // [xsp+48h] [xbp-B8h]
  __int64 v41; // [xsp+50h] [xbp-B0h]
  __int128 v42; // [xsp+58h] [xbp-A8h] BYREF
  char v43; // [xsp+70h] [xbp-90h]
  _BYTE v44[32]; // [xsp+80h] [xbp-80h] BYREF
  _BYTE *v45; // [xsp+A0h] [xbp-60h]
  __int16 v46; // [xsp+B0h] [xbp-50h]
  char v47; // [xsp+B2h] [xbp-4Eh]
  _BYTE v48[32]; // [xsp+C0h] [xbp-40h] BYREF
  _BYTE *v49; // [xsp+E0h] [xbp-20h]

  v17 = sub_6217980(&v35);
  if ( byte_71CF7B0 && byte_71CD990 && byte_6F76E20 && (a7 & 1) == 0 )
    v17 = (_QWORD *)sub_6217ADC(a1);
  v34 = sub_62759D8(v17);
  v37 = v35;
  v38 = v36;
  if ( v36 )
    sub_67F0410(1uLL, (atomic_ullong *)(v36 + 8));
  sub_67D2788((unsigned __int64 *)&v39, a2);
  v18 = a3[1];
  v40 = *a3;
  v41 = v18;
  if ( v18 )
    sub_67F0410(1uLL, (atomic_ullong *)(v18 + 8));
  sub_67D2788((unsigned __int64 *)&v42, a4);
  v19 = *(_QWORD *)(a6 + 32);
  v43 = a5 & 1;
  if ( !v19 )
    goto LABEL_13;
  if ( a6 != v19 )
  {
    v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 16LL))(v19);
LABEL_13:
    v45 = (_BYTE *)v19;
    goto LABEL_15;
  }
  v45 = v44;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 24LL))(v19);
LABEL_15:
  v49 = 0LL;
  LOBYTE(v46) = a7 & 1;
  HIBYTE(v46) = a8 & 1;
  v47 = a9 & 1;
  v20 = (_QWORD *)sub_6575418();
  v21 = v37;
  v22 = v38;
  v23 = v20;
  v37 = 0LL;
  v38 = 0LL;
  *v20 = off_6BA3BE8;
  v20[2] = v21;
  v20[3] = v22;
  sub_67D2788(v20 + 4, &v39);
  v24 = v40;
  v25 = v41;
  v40 = 0LL;
  v41 = 0LL;
  v23[7] = v24;
  v23[8] = v25;
  sub_67D2788(v23 + 9, &v42);
  v26 = v45;
  *((_BYTE *)v23 + 96) = v43;
  if ( v26 )
  {
    if ( v44 == v26 )
    {
      v23[18] = v23 + 14;
      (*(void (__fastcall **)(_BYTE *))(*(_QWORD *)v26 + 24LL))(v26);
    }
    else
    {
      v23[18] = v26;
      v45 = 0LL;
    }
  }
  else
  {
    v23[18] = 0LL;
  }
  v49 = v23;
  v27 = v47;
  *((_WORD *)v23 + 80) = v46;
  *((_BYTE *)v23 + 162) = v27;
  sub_651D4BC(v34, v48);
  if ( v48 == v49 )
  {
    v28 = 4LL;
  }
  else
  {
    if ( !v49 )
      goto LABEL_25;
    v28 = 5LL;
  }
  (*(void (**)(void))(*(_QWORD *)v49 + 8 * v28))();
LABEL_25:
  result = (__int64)v45;
  if ( v44 == v45 )
  {
    v30 = 4LL;
  }
  else
  {
    if ( !v45 )
      goto LABEL_30;
    v30 = 5LL;
  }
  result = (*(__int64 (**)(void))(*(_QWORD *)v45 + 8 * v30))();
LABEL_30:
  if ( (v42 & 1) != 0 )
    result = sub_6575460();
  v31 = (unsigned __int64 *)v41;
  if ( v41 )
  {
    result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v41 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v31 + 16))(v31);
      result = sub_67D18A4(v31);
      if ( (v39 & 1) == 0 )
        goto LABEL_36;
      goto LABEL_35;
    }
  }
  if ( (v39 & 1) != 0 )
LABEL_35:
    result = sub_6575460();
LABEL_36:
  v32 = (unsigned __int64 *)v38;
  if ( v38 )
  {
    result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v38 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v32 + 16))(v32);
      result = sub_67D18A4(v32);
    }
  }
  v33 = (unsigned __int64 *)v36;
  if ( v36 )
  {
    result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v36 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v33 + 16))(v33);
      return sub_67D18A4(v33);
    }
  }
  return result;
}


================================================================================
Function: sub_6217294 (0x6217294)
================================================================================

unsigned __int64 __fastcall sub_6217294(__int64 a1, __int64 a2)
{
  unsigned __int64 result; // x0
  __int64 v5; // x8
  __int64 v6; // x10

  result = sub_67D25E0((_QWORD *)a1, a2);
  v6 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)a1 = off_68E0140;
  *(_QWORD *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 24) = v5;
  if ( v5 )
    result = sub_67F0410(1uLL, (atomic_ullong *)(v5 + 8));
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  return result;
}


================================================================================
Function: sub_6217814 (0x6217814)
================================================================================

__int64 __usercall sub_6217814@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  _QWORD *v3; // x21
  __int64 v4; // x21
  _QWORD *v5; // x22
  __int64 result; // x0

  if ( byte_71CF7B0 )
    v2 = byte_7286120 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = (_QWORD *)sub_6575418();
    v3[1] = 0LL;
    v3[2] = 0LL;
    *v3 = off_6BA3AF8;
    result = sub_621DA6C(v3 + 3);
    *a1 = v3 + 3;
    a1[1] = v3;
  }
  else
  {
    v4 = sub_678E980();
    v5 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v4 + 16LL))(v4, 304LL, 8LL);
    v5[2] = 0LL;
    v5[3] = v4;
    *v5 = off_6BA3AA8;
    v5[1] = 0LL;
    result = sub_621DA6C(v5 + 4);
    *a1 = v5 + 4;
    a1[1] = v5;
  }
  return result;
}


================================================================================
Function: sub_6217980 (0x6217980)
================================================================================

__int64 __usercall sub_6217980@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  bool v4; // zf
  _QWORD *v5; // x21
  __int64 v6; // x21
  _QWORD *v7; // x22
  __int64 result; // x0

  if ( byte_71CF7B0 )
    v4 = byte_7286120 == 0;
  else
    v4 = 1;
  if ( v4 )
  {
    v5 = (_QWORD *)sub_6575418();
    v5[1] = 0LL;
    v5[2] = 0LL;
    *v5 = off_6BA3B98;
    result = sub_45FAF9C(v5 + 3, a1);
    *a2 = v5 + 3;
    a2[1] = v5;
  }
  else
  {
    v6 = sub_678E980();
    v7 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 16LL))(v6, 136LL, 8LL);
    v7[2] = 0LL;
    v7[3] = v6;
    *v7 = off_6BA3B48;
    v7[1] = 0LL;
    result = sub_45FAF9C(v7 + 4, a1);
    *a2 = v7 + 4;
    a2[1] = v7;
  }
  return result;
}


================================================================================
Function: sub_6217ADC (0x6217ADC)
================================================================================

__int64 __fastcall sub_6217ADC(__int64 a1)
{
  __int64 v2; // x21
  unsigned __int64 v3; // x8
  unsigned int v4; // w20
  size_t v5; // x2
  unsigned __int64 v6; // x8
  unsigned __int8 *v7; // x8
  char *v8; // x0
  unsigned __int8 *v9; // x1
  unsigned __int64 v10; // x9
  int v11; // w10
  int v12; // t1
  int v13; // w11
  int v14; // t1
  __int64 v16; // x22
  __int128 v17; // q0
  char *v18; // x8
  unsigned __int64 v19; // x8
  size_t v20; // x2
  unsigned __int64 v21; // x8
  unsigned __int8 *v22; // x8
  char *v23; // x0
  unsigned __int8 *v24; // x1
  unsigned __int64 v25; // x9
  int v26; // w10
  int v27; // t1
  int v28; // w11
  int v29; // t1
  __int64 v31; // x22
  __int128 v32; // q0
  char *v33; // x8
  unsigned __int64 v34; // x8
  size_t v35; // x2
  unsigned __int64 v36; // x8
  unsigned __int8 *v37; // x8
  char *v38; // x0
  unsigned __int8 *v39; // x1
  unsigned __int64 v40; // x9
  int v41; // w10
  int v42; // t1
  int v43; // w11
  int v44; // t1
  __int64 v46; // x22
  __int128 v47; // q0
  char *v48; // x8
  __int64 result; // x0
  unsigned __int64 v50; // x8
  __int64 v51; // x19
  unsigned int v52; // t1
  bool v53; // zf
  unsigned __int64 v54; // x8
  size_t v55; // x1
  __int64 *v56; // x0
  unsigned __int64 v57; // x9
  unsigned __int64 *v58; // x0
  char *v59; // x0
  unsigned __int64 v60; // x1
  unsigned __int8 v61; // w0
  int v62; // w8
  __int64 v63; // x21
  __int128 v64; // q0
  char *v65; // x8
  unsigned __int64 v66[2]; // [xsp+0h] [xbp-100h] BYREF
  __int128 v67; // [xsp+18h] [xbp-E8h] BYREF
  char *v68; // [xsp+28h] [xbp-D8h]
  __int128 v69; // [xsp+30h] [xbp-D0h] BYREF
  char *v70; // [xsp+40h] [xbp-C0h]
  __int128 v71; // [xsp+48h] [xbp-B8h] BYREF
  char *v72; // [xsp+58h] [xbp-A8h]
  __int128 v73; // [xsp+60h] [xbp-A0h] BYREF
  char *v74; // [xsp+70h] [xbp-90h]
  __int64 v75[2]; // [xsp+78h] [xbp-88h] BYREF
  char v76; // [xsp+90h] [xbp-70h]
  char v77; // [xsp+A8h] [xbp-58h]
  char v78; // [xsp+C0h] [xbp-40h]
  char v79; // [xsp+D8h] [xbp-28h]

  v2 = a1 + 40;
  sub_653EEEC(5u);
  if ( (v73 & 1) != 0 )
    v3 = *((_QWORD *)&v73 + 1);
  else
    v3 = (unsigned __int64)(unsigned __int8)v73 >> 1;
  if ( !v3 || sub_250E098(v2, &byte_6F76E88) )
  {
    v4 = 0;
    goto LABEL_37;
  }
  if ( !byte_6F76E00 )
    goto LABEL_33;
  if ( (v73 & 1) != 0 )
    v5 = *((_QWORD *)&v73 + 1);
  else
    v5 = (unsigned __int64)(unsigned __int8)v73 >> 1;
  v6 = (unsigned __int64)(unsigned __int8)xmmword_6F77320 >> 1;
  if ( (xmmword_6F77320 & 1) != 0 )
    v6 = *((_QWORD *)&xmmword_6F77320 + 1);
  if ( v5 == v6 )
  {
    v7 = (unsigned __int8 *)&v73 + 1;
    if ( (v73 & 1) != 0 )
      v8 = v74;
    else
      v8 = (char *)&v73 + 1;
    if ( (xmmword_6F77320 & 1) != 0 )
      v9 = (unsigned __int8 *)qword_6F77330;
    else
      v9 = (unsigned __int8 *)&xmmword_6F77320 + 1;
    if ( (v73 & 1) != 0 )
    {
      if ( !v5 || !memcmp(v8, v9, v5) )
      {
LABEL_33:
        v4 = 0;
        goto LABEL_34;
      }
    }
    else
    {
      if ( !v5 )
        goto LABEL_33;
      v10 = ((unsigned __int64)(unsigned __int8)v73 >> 1) - 1;
      do
      {
        v12 = *v7++;
        v11 = v12;
        v14 = *v9++;
        v13 = v14;
      }
      while ( v11 == v14 && v10-- != 0 );
      if ( v11 == v13 )
        goto LABEL_33;
    }
  }
  v4 = 128;
LABEL_34:
  v75[0] = (__int64)&byte_6F76E88;
  v16 = sub_2591944(v2, &byte_6F76E88, &unk_16A61EF, v75, &v71) + 40;
  if ( (*(_BYTE *)v16 & 1) != 0 )
    sub_6575460();
  v17 = v73;
  LOWORD(v73) = 0;
  v18 = v74;
  *(_OWORD *)v16 = v17;
  *(_QWORD *)(v16 + 16) = v18;
LABEL_37:
  sub_653EEEC(1u);
  if ( (v71 & 1) != 0 )
    v19 = *((_QWORD *)&v71 + 1);
  else
    v19 = (unsigned __int64)(unsigned __int8)v71 >> 1;
  if ( !v19 || sub_250E098(v2, &byte_6F76EA0) )
    goto LABEL_71;
  if ( byte_6F76E00 )
  {
    if ( (v71 & 1) != 0 )
      v20 = *((_QWORD *)&v71 + 1);
    else
      v20 = (unsigned __int64)(unsigned __int8)v71 >> 1;
    v21 = (unsigned __int64)(unsigned __int8)xmmword_6F77338 >> 1;
    if ( (xmmword_6F77338 & 1) != 0 )
      v21 = *((_QWORD *)&xmmword_6F77338 + 1);
    if ( v20 == v21 )
    {
      v22 = (unsigned __int8 *)&v71 + 1;
      if ( (v71 & 1) != 0 )
        v23 = v72;
      else
        v23 = (char *)&v71 + 1;
      if ( (xmmword_6F77338 & 1) != 0 )
        v24 = (unsigned __int8 *)qword_6F77348;
      else
        v24 = (unsigned __int8 *)&xmmword_6F77338 + 1;
      if ( (v71 & 1) != 0 )
      {
        if ( !v20 || !memcmp(v23, v24, v20) )
          goto LABEL_68;
      }
      else
      {
        if ( !v20 )
          goto LABEL_68;
        v25 = ((unsigned __int64)(unsigned __int8)v71 >> 1) - 1;
        do
        {
          v27 = *v22++;
          v26 = v27;
          v29 = *v24++;
          v28 = v29;
        }
        while ( v26 == v29 && v25-- != 0 );
        if ( v26 == v28 )
          goto LABEL_68;
      }
    }
    v4 |= 1u;
  }
LABEL_68:
  v75[0] = (__int64)&byte_6F76EA0;
  v31 = sub_2591944(v2, &byte_6F76EA0, &unk_16A61EF, v75, &v69) + 40;
  if ( (*(_BYTE *)v31 & 1) != 0 )
    sub_6575460();
  v32 = v71;
  LOWORD(v71) = 0;
  v33 = v72;
  *(_OWORD *)v31 = v32;
  *(_QWORD *)(v31 + 16) = v33;
LABEL_71:
  sub_653EEEC(2u);
  if ( (v69 & 1) != 0 )
    v34 = *((_QWORD *)&v69 + 1);
  else
    v34 = (unsigned __int64)(unsigned __int8)v69 >> 1;
  if ( !v34 || sub_250E098(v2, &byte_6F76EE8) )
    goto LABEL_105;
  if ( byte_6F76E00 )
  {
    if ( (v69 & 1) != 0 )
      v35 = *((_QWORD *)&v69 + 1);
    else
      v35 = (unsigned __int64)(unsigned __int8)v69 >> 1;
    v36 = (unsigned __int64)(unsigned __int8)xmmword_6F77350 >> 1;
    if ( (xmmword_6F77350 & 1) != 0 )
      v36 = *((_QWORD *)&xmmword_6F77350 + 1);
    if ( v35 == v36 )
    {
      v37 = (unsigned __int8 *)&v69 + 1;
      if ( (v69 & 1) != 0 )
        v38 = v70;
      else
        v38 = (char *)&v69 + 1;
      if ( (xmmword_6F77350 & 1) != 0 )
        v39 = (unsigned __int8 *)qword_6F77360;
      else
        v39 = (unsigned __int8 *)&xmmword_6F77350 + 1;
      if ( (v69 & 1) != 0 )
      {
        if ( !v35 || !memcmp(v38, v39, v35) )
          goto LABEL_102;
      }
      else
      {
        if ( !v35 )
          goto LABEL_102;
        v40 = ((unsigned __int64)(unsigned __int8)v69 >> 1) - 1;
        do
        {
          v42 = *v37++;
          v41 = v42;
          v44 = *v39++;
          v43 = v44;
        }
        while ( v41 == v44 && v40-- != 0 );
        if ( v41 == v43 )
          goto LABEL_102;
      }
    }
    v4 |= 2u;
  }
LABEL_102:
  v75[0] = (__int64)&byte_6F76EE8;
  v46 = sub_2591944(v2, &byte_6F76EE8, &unk_16A61EF, v75, &v67) + 40;
  if ( (*(_BYTE *)v46 & 1) != 0 )
    sub_6575460();
  v47 = v69;
  LOWORD(v69) = 0;
  v48 = v70;
  *(_OWORD *)v46 = v47;
  *(_QWORD *)(v46 + 16) = v48;
LABEL_105:
  result = sub_653EEEC(8u);
  if ( (v67 & 1) != 0 )
    v50 = *((_QWORD *)&v67 + 1);
  else
    v50 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  if ( !v50 || (result = sub_250E098(v2, &byte_6F76F78)) != 0 )
  {
    if ( !byte_6F76E00 )
      goto LABEL_152;
LABEL_111:
    v52 = *(unsigned __int8 *)(a1 + 16);
    v51 = a1 + 16;
    v53 = (v52 & 1) == 0;
    v54 = (unsigned __int64)v52 >> 1;
    if ( (v52 & 1) != 0 )
      v55 = *(_QWORD *)(v51 + 8);
    else
      v55 = v54;
    if ( v53 )
      v56 = (__int64 *)(v51 + 1);
    else
      v56 = *(__int64 **)(v51 + 16);
    sub_65186CC(v75, v56, v55);
    sub_621C6DC((unsigned __int8 *)v75, v66);
    if ( (v79 & 1) != 0 )
    {
      sub_6575460();
      if ( (v78 & 1) == 0 )
      {
LABEL_119:
        if ( (v77 & 1) == 0 )
          goto LABEL_120;
        goto LABEL_134;
      }
    }
    else if ( (v78 & 1) == 0 )
    {
      goto LABEL_119;
    }
    sub_6575460();
    if ( (v77 & 1) == 0 )
    {
LABEL_120:
      if ( (v76 & 1) == 0 )
        goto LABEL_121;
      goto LABEL_135;
    }
LABEL_134:
    sub_6575460();
    if ( (v76 & 1) == 0 )
    {
LABEL_121:
      if ( (v75[0] & 1) == 0 )
      {
LABEL_123:
        BYTE5(v75[0]) = 0;
        v57 = v66[1];
        if ( (v66[0] & 1) == 0 )
          v57 = (unsigned __int64)LOBYTE(v66[0]) >> 1;
        if ( v57 )
          v58 = v66;
        else
          v58 = (unsigned __int64 *)v51;
        LOBYTE(v75[0]) = 8;
        *(_DWORD *)((char *)v75 + 1) = 1886680136;
        result = sub_621D074(v58, v4, v75);
        if ( (v75[0] & 1) != 0 )
          result = sub_6575460();
        if ( (v66[0] & 1) != 0 )
          result = sub_6575460();
        goto LABEL_152;
      }
LABEL_122:
      sub_6575460();
      goto LABEL_123;
    }
LABEL_135:
    sub_6575460();
    if ( (v75[0] & 1) == 0 )
      goto LABEL_123;
    goto LABEL_122;
  }
  if ( (v67 & 1) != 0 )
    v59 = v68;
  else
    v59 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v60 = *((_QWORD *)&v67 + 1);
  else
    v60 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  v61 = sub_657FA34(v59, v60, 10LL, v75);
  if ( byte_6F76E00 )
  {
    v62 = (v61 & (v75[0] == SLODWORD(v75[0]))) != 0 ? LODWORD(v75[0]) : 0;
    if ( (v61 & (v75[0] == SLODWORD(v75[0])) & (v62 == dword_6F773F8)) == 0 )
      v4 |= 0x100u;
  }
  v75[0] = (__int64)&byte_6F76F78;
  result = sub_2591944(v2, &byte_6F76F78, &unk_16A61EF, v75, v66);
  v63 = result + 40;
  if ( (*(_BYTE *)(result + 40) & 1) != 0 )
    result = sub_6575460();
  v64 = v67;
  LOWORD(v67) = 0;
  v65 = v68;
  *(_OWORD *)v63 = v64;
  *(_QWORD *)(v63 + 16) = v65;
  if ( byte_6F76E00 )
    goto LABEL_111;
LABEL_152:
  if ( (v67 & 1) != 0 )
  {
    result = sub_6575460();
    if ( (v69 & 1) == 0 )
    {
LABEL_154:
      if ( (v71 & 1) == 0 )
        goto LABEL_155;
      goto LABEL_160;
    }
  }
  else if ( (v69 & 1) == 0 )
  {
    goto LABEL_154;
  }
  result = sub_6575460();
  if ( (v71 & 1) == 0 )
  {
LABEL_155:
    if ( (v73 & 1) == 0 )
      return result;
    return sub_6575460();
  }
LABEL_160:
  result = sub_6575460();
  if ( (v73 & 1) == 0 )
    return result;
  return sub_6575460();
}


================================================================================
Function: sub_62186C8 (0x62186C8)
================================================================================

__int64 __fastcall sub_62186C8(int a1, int a2, int a3, int a4, char a5)
{
  __int64 result; // x0
  _QWORD v6[3]; // [xsp+8h] [xbp-38h] BYREF
  char v7; // [xsp+20h] [xbp-20h] BYREF
  int v8; // [xsp+21h] [xbp-1Fh]

  v7 = 6;
  v8 = 5522759;
  memset(v6, 0, sizeof(v6));
  result = sub_62169F8(a1, (int)&v7, 0, (int)v6, 0, a2, a3, a4, a5);
  if ( (v6[0] & 1) != 0 )
    result = sub_6575460();
  if ( (v7 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_621C6DC (0x621C6DC)
================================================================================

__int64 __usercall sub_621C6DC@<X0>(unsigned __int8 *a1@<X0>, unsigned __int64 *a2@<X8>)
{
  __int64 result; // x0
  unsigned __int8 *v5; // x21
  unsigned __int8 *v6; // x26
  char v7; // w27
  char v8; // w24
  int v9; // w24
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x1
  unsigned __int8 *v12; // x23
  unsigned __int8 *j; // x26
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x8
  bool v16; // zf
  size_t v17; // x8
  void *v18; // x1
  size_t v19; // x2
  unsigned __int8 *v20; // x23
  char *v21; // x1
  size_t v22; // x2
  unsigned __int64 v23; // x8
  bool v24; // zf
  size_t v25; // x8
  unsigned __int64 v26; // x12
  size_t v27; // x1
  void *v28; // x0
  size_t v29; // x3
  void *v30; // x2
  char *v31; // x4
  size_t v32; // x5
  unsigned __int64 v33; // x10
  bool v34; // zf
  unsigned __int64 v35; // x12
  const void *v36; // x6
  size_t v37; // x9
  size_t v38; // x10
  size_t v39; // x7
  void *v40; // x9
  unsigned __int64 v41; // x8
  bool v42; // zf
  size_t v43; // x8
  unsigned __int64 v44; // x11
  size_t v45; // x1
  void *v46; // x0
  size_t v47; // x3
  void *v48; // x2
  unsigned __int64 v49; // x12
  char *v50; // x4
  size_t v51; // x5
  size_t v52; // x7
  char *v53; // x6
  void *v54; // x9
  size_t v55; // x10
  unsigned __int64 v56; // x8
  bool v57; // zf
  size_t v58; // x8
  unsigned __int64 v59; // x11
  unsigned __int64 v60; // x9
  bool v61; // zf
  size_t v62; // x9
  unsigned __int64 v63; // x12
  unsigned __int8 *v64; // x19
  unsigned __int8 *v65; // x20
  unsigned __int8 *v66; // x21
  unsigned __int8 *v67; // x21
  unsigned __int8 *v68; // x27
  char v69; // w26
  char v70; // w24
  unsigned __int8 *v71; // x21
  unsigned __int8 *v72; // x27
  char v73; // w24
  unsigned __int8 *v74; // x21
  unsigned __int8 *i; // x27
  char v76; // w24
  unsigned __int64 v77; // [xsp+10h] [xbp-D0h] BYREF
  unsigned __int64 v78; // [xsp+18h] [xbp-C8h]
  char *v79; // [xsp+20h] [xbp-C0h]
  unsigned __int8 *v80; // [xsp+28h] [xbp-B8h] BYREF
  unsigned __int8 *v81; // [xsp+30h] [xbp-B0h]
  __int64 v82; // [xsp+40h] [xbp-A0h] BYREF
  size_t v83; // [xsp+48h] [xbp-98h]
  char *v84; // [xsp+50h] [xbp-90h]
  __int64 v85[3]; // [xsp+58h] [xbp-88h] BYREF
  char v86; // [xsp+70h] [xbp-70h]
  char v87; // [xsp+88h] [xbp-58h]
  char v88; // [xsp+A0h] [xbp-40h]
  char v89; // [xsp+B8h] [xbp-28h]

  result = sub_6519A28(a1);
  if ( (result & 1) == 0 || !sub_6519F80(a1) && (result = sub_651A034(a1), (result & 1) == 0) )
  {
    *(_WORD *)a2 = 0;
    return result;
  }
  v82 = 0LL;
  v83 = 0LL;
  v84 = 0LL;
  sub_651ADD8(&v80, a1);
  if ( (sub_651A108(a1, "rbxcdn.com") & 1) == 0
    && (sub_651A108(a1, "rbxcdn.qq.com") & 1) == 0
    && (!byte_71CF7B0 || !byte_6F76C88 || (sub_651A108(a1, "roblox.cn") & 1) == 0) )
  {
    result = sub_651A108(a1, "c.robloxdev.cn");
    if ( (result & 1) == 0 )
    {
      v67 = v80;
      v68 = v81;
      if ( v80 == v81 )
      {
        v77 = 0LL;
        v78 = 0LL;
        v79 = 0LL;
      }
      else
      {
        v69 = 0;
        do
        {
          sub_67C4788(v85);
          v70 = sub_45DE50C(v67, &byte_6F774C0, v85);
          result = sub_67C482C(v85);
          if ( (v70 & 1) != 0 )
          {
            result = sub_67D3284((int)v67 + 24, "<REDACTED>");
            v69 = 1;
          }
          v67 += 48;
        }
        while ( v67 != v68 );
        v71 = v80;
        v72 = v81;
        if ( v80 != v81 )
        {
          do
          {
            sub_67C4788(v85);
            v73 = sub_45DE50C(v71, &byte_6F774D8, v85);
            result = sub_67C482C(v85);
            if ( (v73 & 1) != 0 )
            {
              result = sub_67D3284((int)v71 + 24, "<REDACTED>");
              v69 = 1;
            }
            v71 += 48;
          }
          while ( v71 != v72 );
          v74 = v80;
          for ( i = v81; v74 != i; v74 += 48 )
          {
            sub_67C4788(v85);
            v76 = sub_45DE50C(v74, &byte_6F774F0, v85);
            result = sub_67C482C(v85);
            if ( (v76 & 1) != 0 )
            {
              result = sub_67D3284((int)v74 + 24, "<REDACTED>");
              v69 = 1;
            }
          }
        }
        v77 = 0LL;
        v78 = 0LL;
        v79 = 0LL;
        if ( (v69 & 1) != 0 )
        {
          v9 = 0;
          goto LABEL_18;
        }
      }
      *(_WORD *)a2 = 0;
      if ( (v77 & 1) != 0 )
        goto LABEL_146;
LABEL_133:
      v64 = v80;
      if ( v80 )
        goto LABEL_134;
LABEL_147:
      if ( (v82 & 1) == 0 )
        return result;
      return sub_6575460();
    }
  }
  sub_67D3284((int)&v82, "<REDACTED>");
  v5 = v80;
  v6 = v81;
  if ( v80 == v81 )
  {
    v77 = 0LL;
    v78 = 0LL;
    v79 = 0LL;
LABEL_44:
    v23 = *a1;
    v24 = (v23 & 1) == 0;
    v25 = v23 >> 1;
    v26 = a1[24];
    if ( v24 )
      v27 = v25;
    else
      v27 = *((_QWORD *)a1 + 1);
    if ( v24 )
      v28 = a1 + 1;
    else
      v28 = (void *)*((_QWORD *)a1 + 2);
    if ( (v26 & 1) != 0 )
      v29 = *((_QWORD *)a1 + 4);
    else
      v29 = v26 >> 1;
    if ( (v26 & 1) != 0 )
      v30 = (void *)*((_QWORD *)a1 + 5);
    else
      v30 = a1 + 25;
    if ( (v82 & 1) != 0 )
      v31 = v84;
    else
      v31 = (char *)&v82 + 1;
    if ( (v82 & 1) != 0 )
      v32 = v83;
    else
      v32 = (unsigned __int64)(unsigned __int8)v82 >> 1;
    v33 = a1[72];
    v34 = (v33 & 1) == 0;
    v35 = a1[96];
    if ( (v33 & 1) != 0 )
      v36 = (const void *)*((_QWORD *)a1 + 11);
    else
      v36 = a1 + 73;
    v37 = v33 >> 1;
    v38 = *((_QWORD *)a1 + 13);
    if ( v34 )
      v39 = v37;
    else
      v39 = *((_QWORD *)a1 + 10);
    v40 = a1 + 97;
    if ( (v35 & 1) != 0 )
      v40 = (void *)*((_QWORD *)a1 + 14);
    else
      v38 = v35 >> 1;
    sub_651925C(v85, v28, v27, v30, v31, v29, v32, v36, v39, v40, v38);
    result = (__int64)sub_65197D4((unsigned __int8 *)v85, a2);
    goto LABEL_127;
  }
  v7 = 0;
  do
  {
    sub_67C4788(v85);
    v8 = sub_621CE94(v5, "Expires", v85);
    sub_67C482C(v85);
    if ( (v8 & 1) == 0 )
    {
      sub_67D3284((_DWORD)v5 + 24, "<REDACTED>");
      v7 = 1;
    }
    v5 += 48;
  }
  while ( v5 != v6 );
  v77 = 0LL;
  v78 = 0LL;
  v79 = 0LL;
  if ( (v7 & 1) == 0 )
    goto LABEL_44;
  v9 = 1;
LABEL_18:
  v10 = a1[72];
  if ( (v10 & 1) != 0 )
    v11 = *((_QWORD *)a1 + 10);
  else
    v11 = v10 >> 1;
  sub_658A084(&v77, v11);
  v12 = v80;
  for ( j = v81; v12 != j; v12 = v20 + 24 )
  {
    if ( (v77 & 1) != 0 )
      v14 = v78;
    else
      v14 = (unsigned __int64)(unsigned __int8)v77 >> 1;
    if ( v14 )
      sub_67D352C(&v77, "&");
    v15 = *v12;
    v16 = (v15 & 1) == 0;
    v17 = v15 >> 1;
    if ( v16 )
      v18 = v12 + 1;
    else
      v18 = (void *)*((_QWORD *)v12 + 2);
    if ( v16 )
      v19 = v17;
    else
      v19 = *((_QWORD *)v12 + 1);
    sub_6588400(&v77, v18, v19);
    v20 = v12 + 24;
    sub_67D4090(v85, "=", v20);
    if ( (v85[0] & 1) != 0 )
      v21 = (char *)v85[2];
    else
      v21 = (char *)v85 + 1;
    if ( (v85[0] & 1) != 0 )
      v22 = v85[1];
    else
      v22 = (unsigned __int64)LOBYTE(v85[0]) >> 1;
    sub_6588400(&v77, v21, v22);
    if ( (v85[0] & 1) != 0 )
      sub_6575460();
  }
  if ( v9 )
  {
    v41 = *a1;
    v42 = (v41 & 1) == 0;
    v43 = v41 >> 1;
    v44 = a1[24];
    if ( v42 )
      v45 = v43;
    else
      v45 = *((_QWORD *)a1 + 1);
    if ( v42 )
      v46 = a1 + 1;
    else
      v46 = (void *)*((_QWORD *)a1 + 2);
    if ( (v44 & 1) != 0 )
      v47 = *((_QWORD *)a1 + 4);
    else
      v47 = v44 >> 1;
    if ( (v44 & 1) != 0 )
      v48 = (void *)*((_QWORD *)a1 + 5);
    else
      v48 = a1 + 25;
    v49 = a1[96];
    if ( (v82 & 1) != 0 )
      v50 = v84;
    else
      v50 = (char *)&v82 + 1;
    if ( (v82 & 1) != 0 )
      v51 = v83;
    else
      v51 = (unsigned __int64)(unsigned __int8)v82 >> 1;
    if ( (v77 & 1) != 0 )
      v52 = v78;
    else
      v52 = (unsigned __int64)(unsigned __int8)v77 >> 1;
    if ( (v77 & 1) != 0 )
      v53 = v79;
    else
      v53 = (char *)&v77 + 1;
    v55 = *((_QWORD *)a1 + 13);
    v54 = (void *)*((_QWORD *)a1 + 14);
    if ( (v49 & 1) == 0 )
    {
      v55 = v49 >> 1;
      v54 = a1 + 97;
    }
  }
  else
  {
    v56 = *a1;
    v57 = (v56 & 1) == 0;
    v58 = v56 >> 1;
    v59 = a1[24];
    if ( v57 )
      v45 = v58;
    else
      v45 = *((_QWORD *)a1 + 1);
    if ( v57 )
      v46 = a1 + 1;
    else
      v46 = (void *)*((_QWORD *)a1 + 2);
    v60 = a1[48];
    if ( (v59 & 1) != 0 )
      v47 = *((_QWORD *)a1 + 4);
    else
      v47 = v59 >> 1;
    if ( (v59 & 1) != 0 )
      v48 = (void *)*((_QWORD *)a1 + 5);
    else
      v48 = a1 + 25;
    v61 = (v60 & 1) == 0;
    v62 = v60 >> 1;
    v63 = a1[96];
    if ( v61 )
      v51 = v62;
    else
      v51 = *((_QWORD *)a1 + 7);
    if ( v61 )
      v50 = (char *)(a1 + 49);
    else
      v50 = (char *)*((_QWORD *)a1 + 8);
    if ( (v77 & 1) != 0 )
      v52 = v78;
    else
      v52 = (unsigned __int64)(unsigned __int8)v77 >> 1;
    if ( (v77 & 1) != 0 )
      v53 = v79;
    else
      v53 = (char *)&v77 + 1;
    v55 = *((_QWORD *)a1 + 13);
    v54 = (void *)*((_QWORD *)a1 + 14);
    if ( (v63 & 1) == 0 )
    {
      v55 = v63 >> 1;
      v54 = a1 + 97;
    }
  }
  sub_651925C(v85, v46, v45, v48, v50, v47, v51, v53, v52, v54, v55);
  result = (__int64)sub_65197D4((unsigned __int8 *)v85, a2);
LABEL_127:
  if ( (v89 & 1) != 0 )
  {
    result = sub_6575460();
    if ( (v88 & 1) == 0 )
    {
LABEL_129:
      if ( (v87 & 1) == 0 )
        goto LABEL_130;
      goto LABEL_143;
    }
  }
  else if ( (v88 & 1) == 0 )
  {
    goto LABEL_129;
  }
  result = sub_6575460();
  if ( (v87 & 1) == 0 )
  {
LABEL_130:
    if ( (v86 & 1) == 0 )
      goto LABEL_131;
    goto LABEL_144;
  }
LABEL_143:
  result = sub_6575460();
  if ( (v86 & 1) == 0 )
  {
LABEL_131:
    if ( (v85[0] & 1) == 0 )
      goto LABEL_132;
    goto LABEL_145;
  }
LABEL_144:
  result = sub_6575460();
  if ( (v85[0] & 1) != 0 )
  {
LABEL_145:
    result = sub_6575460();
    if ( (v77 & 1) != 0 )
      goto LABEL_146;
    goto LABEL_133;
  }
LABEL_132:
  if ( (v77 & 1) == 0 )
    goto LABEL_133;
LABEL_146:
  result = sub_6575460();
  v64 = v80;
  if ( !v80 )
    goto LABEL_147;
LABEL_134:
  v65 = v81;
  if ( v81 != v64 )
  {
    do
    {
      if ( (*(v65 - 24) & 1) != 0 )
        sub_6575460();
      v66 = v65 - 48;
      if ( (*(v65 - 48) & 1) != 0 )
        sub_6575460();
      v65 -= 48;
    }
    while ( v66 != v64 );
  }
  v81 = v64;
  result = sub_6575460();
  if ( (v82 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_621CE94 (0x621CE94)
================================================================================

bool __fastcall sub_621CE94(unsigned __int8 *a1, const char *a2, __int64 *a3)
{
  unsigned __int64 v5; // x8
  bool v6; // zf
  unsigned __int64 v7; // x8
  unsigned __int8 *v8; // x27
  unsigned __int64 v9; // x26
  size_t v10; // x0
  __int64 v11; // x2
  size_t v12; // x20
  size_t v13; // x25
  unsigned __int64 v14; // x24
  const char *v15; // x28
  unsigned int v16; // w22
  __int64 *v17; // x0
  unsigned int v18; // w23
  __int64 v19; // x2
  __int64 *v20; // x0
  size_t v21; // x9
  _BOOL4 v22; // w19
  unsigned __int8 *v24; // [xsp+8h] [xbp-18h]
  __int64 v25; // [xsp+10h] [xbp-10h] BYREF

  sub_67C4814(&v25, a3);
  v5 = *a1;
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
    v8 = a1 + 1;
  else
    v8 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( v6 )
    v9 = v7;
  else
    v9 = *((_QWORD *)a1 + 1);
  v10 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
  v12 = v10;
  v24 = v8;
  if ( v9 && v10 )
  {
    v13 = v10 - 1;
    v14 = v9 - 1;
    v15 = a2;
    while ( 1 )
    {
      v16 = *v8;
      v17 = sub_67C4BB8(&v25, (__int64)&qword_795CE58, v11);
      LOBYTE(v16) = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*v17 + 24))(v17, v16);
      v18 = *(unsigned __int8 *)v15;
      v20 = sub_67C4BB8(&v25, (__int64)&qword_795CE58, v19);
      if ( (unsigned __int8)v16 != (*(unsigned __int8 (__fastcall **)(__int64 *, _QWORD))(*v20 + 24))(v20, v18) )
        break;
      ++v8;
      ++v15;
      if ( v14 )
      {
        v21 = v13;
        --v14;
        --v13;
        if ( v21 )
          continue;
      }
      goto LABEL_15;
    }
    v22 = 0;
  }
  else
  {
    v15 = a2;
LABEL_15:
    v22 = v15 == &a2[v12] && v8 == &v24[v9];
  }
  sub_67C482C(&v25);
  return v22;
}


================================================================================
Function: sub_621D074 (0x621D074)
================================================================================

__int64 __fastcall sub_621D074(__int64 result, int a2, __int64 a3)
{
  __int64 v5; // x21
  _QWORD v6[3]; // [xsp+8h] [xbp-1F8h] BYREF
  _BYTE v7[472]; // [xsp+20h] [xbp-1E0h] BYREF

  if ( a2 )
  {
    v5 = result;
    result = sub_657A0FC();
    if ( (unsigned int)result % 0x2710 < dword_6F76DE8 )
    {
      sub_6416B58((__int64)v7, -1, 0);
      if ( (a2 & 1) != 0 )
      {
        sub_653EEEC(1u);
        sub_641B25C((__int64)v7, (__int64)"PlaceIdFromContextInfo", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_6575460();
        sub_641B25C((__int64)v7, (__int64)"PlaceIdFromHttp", (__int64)&xmmword_6F77338);
      }
      if ( (a2 & 2) != 0 )
      {
        sub_653EEEC(2u);
        sub_641B25C((__int64)v7, (__int64)"UniverseIdFromContextInfo", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_6575460();
        sub_641B25C((__int64)v7, (__int64)"UniverseIdFromHttp", (__int64)&xmmword_6F77350);
      }
      if ( (a2 & 0x80) != 0 )
      {
        sub_653EEEC(5u);
        sub_641B25C((__int64)v7, (__int64)"GameIdFromContextInfo", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_6575460();
        sub_641B25C((__int64)v7, (__int64)"GameIdFromHttp", (__int64)&xmmword_6F77320);
      }
      if ( (a2 & 0x100) != 0 )
      {
        sub_653EEEC(8u);
        sub_641B25C((__int64)v7, (__int64)"PlayerCountFromContextInfo", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_6575460();
        sub_6579D18("%d", v6);
        sub_641B25C((__int64)v7, (__int64)"PlayerCountFromHttp", (__int64)v6);
        if ( (v6[0] & 1) != 0 )
          sub_6575460();
      }
      sub_653EF60(0);
      sub_641B25C((__int64)v7, (__int64)"PrimaryContext", (__int64)v6);
      if ( (v6[0] & 1) != 0 )
        sub_6575460();
      sub_653EEEC(0);
      sub_641B25C((__int64)v7, (__int64)"CurrentContext", (__int64)v6);
      if ( (v6[0] & 1) != 0 )
        sub_6575460();
      sub_641B25C((__int64)v7, (__int64)"RequestUrl", v5);
      sub_641B6E8((__int64)v7, "MismatchedFields", a2);
      sub_641B25C((__int64)v7, (__int64)"HttpType", a3);
      strcpy((char *)v6, "&ContextInfoMismatch");
      sub_641C358((__int64)v7, (__int64)v6, 10000, 0);
      if ( (v6[0] & 1) != 0 )
        sub_6575460();
      return sub_254B3DC((__int64)v7);
    }
  }
  return result;
}


================================================================================
Function: sub_621DA6C (0x621DA6C)
================================================================================

__int64 __fastcall sub_621DA6C(__int64 a1)
{
  __int64 v2; // x21

  v2 = a1 + 16;
  *(_QWORD *)(a1 + 120) = off_6810570;
  *(_QWORD *)a1 = off_6810548;
  *(_QWORD *)(a1 + 8) = 0LL;
  sub_67A8530(a1 + 120, a1 + 16);
  *(_QWORD *)(a1 + 256) = 0LL;
  *(_DWORD *)(a1 + 264) = -1;
  *(_QWORD *)a1 = off_68104D8;
  *(_QWORD *)(a1 + 120) = off_6810500;
  sub_67A5110(v2);
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 8;
  *(_QWORD *)(a1 + 16) = off_67FDA98;
  return sub_26B93A8(v2);
}


================================================================================
Function: sub_621EF7C (0x621EF7C)
================================================================================

_QWORD *__usercall sub_621EF7C@<X0>(
        __int64 a1@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        __int64 a4@<X3>,
        _QWORD *a5@<X8>)
{
  bool v10; // zf
  __int64 v11; // x24
  __int64 v12; // x0
  __int64 v13; // x25
  __int64 v14; // x24
  __int64 v15; // x8
  _QWORD *result; // x0
  __int64 v17; // x8
  __int64 v18; // x19
  __int64 v19; // x19
  unsigned __int64 *v20; // x19
  __int64 v21; // [xsp+0h] [xbp-70h] BYREF
  __int64 v22; // [xsp+8h] [xbp-68h]
  __int64 v23; // [xsp+10h] [xbp-60h]
  __int64 v24; // [xsp+18h] [xbp-58h]
  __int64 v25; // [xsp+20h] [xbp-50h]
  __int64 v26; // [xsp+28h] [xbp-48h]
  _QWORD v27[4]; // [xsp+30h] [xbp-40h] BYREF
  _QWORD *v28; // [xsp+50h] [xbp-20h]

  if ( byte_71CF7B0 )
    v10 = byte_7286120 == 0;
  else
    v10 = 1;
  if ( v10 )
  {
    v12 = sub_6575418();
    v13 = v12;
    *(_QWORD *)(v12 + 8) = 0LL;
    *(_QWORD *)(v12 + 16) = 0LL;
    *(_QWORD *)(v12 + 32) = 0LL;
    *(_QWORD *)v12 = off_68DFD68;
    *(_BYTE *)(v12 + 40) = 0;
    *(_QWORD *)(v12 + 24) = 0LL;
    v14 = v12 + 24;
  }
  else
  {
    v11 = sub_678E980();
    v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v11 + 16LL))(v11, 56LL, 8LL);
    *(_QWORD *)(v12 + 16) = 0LL;
    *(_QWORD *)(v12 + 24) = v11;
    v13 = v12;
    *(_QWORD *)(v12 + 40) = 0LL;
    *(_BYTE *)(v12 + 48) = 0;
    *(_QWORD *)v12 = off_68DFC18;
    *(_QWORD *)(v12 + 8) = 0LL;
    *(_QWORD *)(v12 + 32) = 0LL;
    v14 = v12 + 32;
  }
  v25 = v14;
  v26 = v12;
  sub_67F0410(1uLL, (atomic_ullong *)(v13 + 8));
  v23 = 0LL;
  v24 = 0LL;
  v27[2] = v13;
  v28 = v27;
  v27[0] = off_6BA3D38;
  v27[1] = v14;
  sub_621F244(a1, a2, a3, v27, a4);
  if ( v27 == v28 )
  {
    v15 = 4LL;
    goto LABEL_11;
  }
  if ( v28 )
  {
    v15 = 5LL;
LABEL_11:
    (*(void (**)(void))(*v28 + 8 * v15))();
  }
  result = sub_3BDB2E4(&v21, v14);
  v17 = v22;
  *a5 = v21;
  a5[1] = v17;
  if ( v17 )
  {
    result = (_QWORD *)sub_67F0380(1u, (atomic_uint *)(v17 + 8));
    v18 = v22;
    v21 = 0LL;
    v22 = 0LL;
    if ( v18 )
    {
      result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v18 + 8));
      if ( (_DWORD)result == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 16LL))(v18);
        result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v18 + 12));
        if ( (_DWORD)result == 1 )
          result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 24LL))(v18);
      }
      v19 = v22;
      if ( v22 )
      {
        result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v22 + 8));
        if ( (_DWORD)result == 1 )
        {
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16LL))(v19);
          result = (_QWORD *)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v19 + 12));
          if ( (_DWORD)result == 1 )
            result = (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v19 + 24LL))(v19);
        }
      }
    }
  }
  v20 = (unsigned __int64 *)v26;
  if ( v26 )
  {
    result = (_QWORD *)sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v26 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v20 + 16))(v20);
      return (_QWORD *)sub_67D18A4(v20);
    }
  }
  return result;
}


================================================================================
Function: sub_621F244 (0x621F244)
================================================================================

__int64 __fastcall sub_621F244(__int64 a1, __int64 a2, __int128 *a3, __int64 a4, __int64 a5)
{
  __int64 v9; // x1
  int v10; // w8
  __int64 v11; // x25
  __int64 v12; // x26
  __int64 v13; // x0
  __int64 v14; // x8
  unsigned __int64 *v15; // x19
  unsigned __int64 *v16; // x19
  __int64 **v17; // x19
  __int64 result; // x0
  __int64 *v19; // x20
  unsigned __int64 v20[3]; // [xsp+10h] [xbp-E0h] BYREF
  __int64 v21; // [xsp+28h] [xbp-C8h] BYREF
  __int64 v22; // [xsp+30h] [xbp-C0h]
  __int64 v23; // [xsp+38h] [xbp-B8h]
  __int64 v24; // [xsp+40h] [xbp-B0h]
  _DWORD v25[4]; // [xsp+48h] [xbp-A8h] BYREF
  char v26; // [xsp+58h] [xbp-98h]
  _QWORD v27[2]; // [xsp+70h] [xbp-80h] BYREF
  __int64 **v28; // [xsp+80h] [xbp-70h]
  int v29; // [xsp+90h] [xbp-60h]
  char v30; // [xsp+98h] [xbp-58h]
  _BYTE v31[32]; // [xsp+B0h] [xbp-40h] BYREF
  _BYTE *v32; // [xsp+D0h] [xbp-20h]

  sub_621636C((int)v25, a2);
  if ( v27 != (_QWORD *)a5 )
  {
    v9 = *(_QWORD *)(a5 + 16);
    v29 = *(_DWORD *)(a5 + 32);
    sub_3BCC250(v27, v9, 0LL);
  }
  v10 = *(_DWORD *)(a5 + 40);
  v23 = 0LL;
  v24 = 0LL;
  v25[0] = v10;
  if ( a3 )
  {
    v12 = *(_QWORD *)a3;
    v11 = *((_QWORD *)a3 + 1);
    if ( v11 )
    {
      sub_67F0410(1uLL, (atomic_ullong *)(v11 + 8));
      v23 = v12;
      v24 = v11;
    }
    else
    {
      v23 = *(_QWORD *)a3;
      v24 = 0LL;
    }
  }
  v21 = v23;
  v22 = v24;
  if ( v24 )
    sub_67F0410(1uLL, (atomic_ullong *)(v24 + 8));
  if ( a3 )
  {
    sub_67D2788(v20, a3 + 1);
    LODWORD(a3) = *((_BYTE *)a3 + 40) != 0;
    v13 = *(_QWORD *)(a4 + 32);
    if ( !v13 )
      goto LABEL_15;
  }
  else
  {
    memset(v20, 0, sizeof(v20));
    v13 = *(_QWORD *)(a4 + 32);
    if ( !v13 )
    {
LABEL_15:
      v32 = (_BYTE *)v13;
      goto LABEL_17;
    }
  }
  if ( a4 != v13 )
  {
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 16LL))(v13);
    goto LABEL_15;
  }
  v32 = v31;
  (*(void (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)v13 + 24LL))(v13, v31);
LABEL_17:
  sub_6216E04(v25, a1, &v21, v20, (unsigned int)a3, v31, *(unsigned __int8 *)(a5 + 48), 0LL, 1);
  if ( v31 == v32 )
  {
    v14 = 4LL;
  }
  else
  {
    if ( !v32 )
      goto LABEL_22;
    v14 = 5LL;
  }
  (*(void (**)(void))(*(_QWORD *)v32 + 8 * v14))();
LABEL_22:
  if ( (v20[0] & 1) != 0 )
    sub_6575460();
  v15 = (unsigned __int64 *)v22;
  if ( v22 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v22 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v15 + 16))(v15);
    sub_67D18A4(v15);
  }
  v16 = (unsigned __int64 *)v24;
  if ( !v24 || sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8)) )
  {
    if ( (v30 & 1) == 0 )
      goto LABEL_31;
    goto LABEL_30;
  }
  (*(void (__fastcall **)(unsigned __int64 *))(*v16 + 16))(v16);
  sub_67D18A4(v16);
  if ( (v30 & 1) != 0 )
LABEL_30:
    sub_6575460();
LABEL_31:
  v17 = v28;
  if ( v28 )
  {
    do
    {
      v19 = *v17;
      if ( ((_BYTE)v17[5] & 1) != 0 )
        sub_6575460();
      if ( ((_BYTE)v17[2] & 1) != 0 )
        sub_6575460();
      sub_6575460();
      v17 = (__int64 **)v19;
    }
    while ( v19 );
  }
  result = v27[0];
  v27[0] = 0LL;
  if ( result )
    result = sub_6575460();
  if ( (v26 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_621F58C (0x621F58C)
================================================================================

__int64 __fastcall sub_621F58C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // x0
  char v4; // [xsp+0h] [xbp-20h] BYREF
  char v5[15]; // [xsp+1h] [xbp-1Fh] BYREF

  v4 = 8;
  strcpy(v5, "POST");
  result = sub_621EF7C(&v4, a1, a2, a3);
  if ( (v4 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_6220478 (0x6220478)
================================================================================

__int64 __fastcall sub_6220478(__int64 a1, __int64 a2)
{
  unsigned int v4; // w0
  char v5; // w8
  __int64 result; // x0
  __int128 v7; // [xsp+8h] [xbp-58h] BYREF
  unsigned __int64 v8[2]; // [xsp+20h] [xbp-40h] BYREF

  v4 = pthread_mutex_init((pthread_mutex_t *)a1, 0LL);
  if ( v4 )
  {
    sub_25A21C8(v8, v4, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v8);
  }
  LOWORD(v7) = 0;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 40) = a1 + 48;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = a2;
  *(_DWORD *)(a1 + 80) = 0;
  sub_67D2788(v8, &v7);
  v5 = v8[0];
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  if ( (v5 & 1) != 0 )
    sub_6575460();
  *(_QWORD *)(a1 + 112) = 0LL;
  sub_67D2788((unsigned __int64 *)(a1 + 120), &v7);
  if ( (v7 & 1) != 0 )
    sub_6575460();
  result = pthread_mutex_init((pthread_mutex_t *)(a1 + 152), 0LL);
  if ( (_DWORD)result )
  {
    sub_25A21C8(v8, result, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v8);
  }
  return result;
}


================================================================================
Function: sub_6223288 (0x6223288)
================================================================================

__int64 __fastcall sub_6223288(__int64 a1, char a2)
{
  __int64 result; // x0
  __int64 v4; // x8
  __int64 v5; // x10
  __int64 v6; // x19
  __int128 v7; // q0
  __int128 v8; // q1
  int v9; // s2
  int v10; // s3
  pthread_mutex_t *v11; // x19
  __int64 v12; // x22
  __int64 v13; // x20
  pthread_mutex_t *v14[7]; // [xsp+0h] [xbp-80h] BYREF
  pthread_mutex_t *mutex; // [xsp+38h] [xbp-48h] BYREF
  unsigned __int8 v16; // [xsp+40h] [xbp-40h]
  _BYTE v17[8]; // [xsp+48h] [xbp-38h] BYREF
  __int128 v18; // [xsp+50h] [xbp-30h]
  int v19; // [xsp+60h] [xbp-20h]
  __int64 v20; // [xsp+68h] [xbp-18h]
  __int64 v21; // [xsp+70h] [xbp-10h]

  v17[0] = 0;
  v18 = xmmword_AF8AF0;
  v19 = 1065353216;
  v20 = 0LL;
  v21 = 0LL;
  if ( (a2 & 1) != 0 )
    sub_622342C(v17, 512LL);
  v16 = 0;
  mutex = (pthread_mutex_t *)(a1 + 64);
  result = sub_25A70B8((__int64)&mutex);
  v4 = v21;
  v5 = *(_QWORD *)(a1 + 48);
  v6 = *(_QWORD *)(a1 + 56);
  v7 = v18;
  v8 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 48) = v20;
  *(_QWORD *)(a1 + 56) = v4;
  v9 = *(_DWORD *)(a1 + 40);
  v10 = v19;
  *(_OWORD *)(a1 + 24) = v7;
  LODWORD(v4) = v16;
  v18 = v8;
  v19 = v9;
  *(_DWORD *)(a1 + 40) = v10;
  v20 = v5;
  v21 = v6;
  if ( (_DWORD)v4 )
  {
    v11 = mutex;
    do
      result = pthread_mutex_unlock(v11);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25A6430(v14, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300((__int64)v14);
    }
    v6 = v21;
  }
  if ( v6 )
  {
    if ( *((_QWORD *)&v18 + 1) )
    {
      v12 = v18;
      v13 = *(_QWORD *)(v6 + 8 * v18);
      do
      {
        *(_QWORD *)(v6 + 8 * v12) = *(_QWORD *)v13;
        if ( (*(_BYTE *)(v13 + 40) & 1) != 0 )
          sub_6575460();
        if ( (*(_BYTE *)(v13 + 16) & 1) != 0 )
          sub_6575460();
        sub_6575460();
        --*((_QWORD *)&v18 + 1);
        v13 = *(_QWORD *)(v6 + 8 * v12);
      }
      while ( v13 );
    }
    return sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_622342C (0x622342C)
================================================================================

__int64 __fastcall sub_622342C(__int64 result, unsigned __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 v3; // x8
  double v4; // d0
  unsigned __int64 v5; // x20
  double v6; // d0
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x8
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x8

  v2 = result;
  v3 = *(_QWORD *)(result + 16);
  v4 = *(float *)(result + 24);
  v5 = vcvtpd_u64_f64((double)a2 / v4);
  if ( v3 )
  {
    v6 = (double)v3 / v4;
    v7 = vcvtmd_u64_f64(v6);
    if ( floor(v6) < 1.84467441e19 )
      v8 = v7 + 1;
    else
      v8 = 0LL;
    if ( v8 <= v5 )
      v8 = v5;
    if ( v8 >= 5 )
    {
      v11 = (v8 - 1) | ((v8 - 1) >> 1) | (((v8 - 1) | ((v8 - 1) >> 1)) >> 2);
      v12 = v11 | (v11 >> 4) | ((v11 | (v11 >> 4)) >> 8);
      v9 = (v12 | (v12 >> 16) | ((v12 | (v12 >> 16)) >> 32)) + 1;
    }
    else
    {
      v9 = 4LL;
    }
    if ( v9 != *(_QWORD *)(result + 8) )
      return sub_6228494(result);
  }
  else
  {
    result = sub_62283FC(result);
    if ( v5 >= 5 )
    {
      v13 = (v5 - 1) | ((v5 - 1) >> 1) | (((v5 - 1) | ((v5 - 1) >> 1)) >> 2);
      v14 = v13 | (v13 >> 4) | ((v13 | (v13 >> 4)) >> 8);
      v10 = (v14 | (v14 >> 16) | ((v14 | (v14 >> 16)) >> 32)) + 1;
    }
    else
    {
      v10 = 4LL;
    }
    *(_QWORD *)(v2 + 8) = v10;
  }
  return result;
}


================================================================================
Function: sub_62249E8 (0x62249E8)
================================================================================

__int64 __fastcall sub_62249E8(__int64 a1)
{
  unsigned int v2; // w1
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  *(_QWORD *)a1 = "HttpRedirectCache";
  *(_QWORD *)(a1 + 8) = 17LL;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = xmmword_AF8AF0;
  *(_DWORD *)(a1 + 40) = 1065353216;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 64), 0LL);
  if ( v2 )
  {
    sub_25A21C8(v4, v2, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v4);
  }
  return sub_6223288(a1, 1LL);
}


================================================================================
Function: sub_62283FC (0x62283FC)
================================================================================

_QWORD *__fastcall sub_62283FC(_QWORD *result)
{
  __int64 v1; // x20
  _QWORD *v2; // x19
  __int64 v3; // x22
  __int64 v4; // x21

  v1 = result[5];
  if ( v1 )
  {
    v2 = result;
    if ( result[2] )
    {
      v3 = result[1];
      v4 = *(_QWORD *)(v1 + 8 * v3);
      do
      {
        *(_QWORD *)(v1 + 8 * v3) = *(_QWORD *)v4;
        if ( (*(_BYTE *)(v4 + 40) & 1) != 0 )
          sub_6575460();
        if ( (*(_BYTE *)(v4 + 16) & 1) != 0 )
          sub_6575460();
        sub_6575460();
        v4 = *(_QWORD *)(v1 + 8 * v3);
        --v2[2];
      }
      while ( v4 );
    }
    result = (_QWORD *)sub_6575460();
    v2[4] = 0LL;
    v2[5] = 0LL;
  }
  return result;
}


================================================================================
Function: sub_6228494 (0x6228494)
================================================================================

__int64 __fastcall sub_6228494(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x22
  _QWORD *v5; // x0
  _QWORD *v6; // x19
  __int64 result; // x0
  float v8; // s0
  _QWORD *v9; // x8
  double v10; // d0
  _QWORD *v11; // x10
  unsigned __int64 v12; // x9
  __int64 v13; // x11
  __int64 v14; // x11

  if ( (a2 + 1) >> 61 )
    sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v2 = 8 * (a2 + 1);
  v5 = (_QWORD *)sub_6575418();
  v6 = v5;
  if ( v2 )
    memset(v5, 0, 8 * a2 + 8);
  result = *(_QWORD *)(a1 + 40);
  if ( result )
  {
    v6[a2] = *(_QWORD *)(result + 8LL * *(_QWORD *)(a1 + 8));
    result = sub_6575460();
  }
  v8 = *(float *)(a1 + 24);
  *(_QWORD *)(a1 + 8) = a2;
  v9 = &v6[a2];
  v10 = (double)a2 * v8;
  v11 = (_QWORD *)*v9;
  v12 = vcvtpd_u64_f64(v10);
  if ( ceil(v10) >= 1.84467441e19 )
    v12 = -1LL;
  *(_QWORD *)(a1 + 32) = v12;
  for ( *(_QWORD *)(a1 + 40) = v6; v11; v11 = (_QWORD *)*v11 )
  {
    while ( 1 )
    {
      v14 = v11[1] & (a2 - 1);
      if ( !v6[v14] )
        break;
      v13 = v14;
      *v9 = *v11;
      *v11 = *(_QWORD *)v6[v13];
      *(_QWORD *)v6[v13] = v11;
      v11 = (_QWORD *)*v9;
      if ( !*v9 )
        return result;
    }
    v6[v14] = v9;
    v9 = v11;
  }
  return result;
}


================================================================================
Function: sub_6229ABC (0x6229ABC)
================================================================================

long double __fastcall sub_6229ABC(__int64 a1)
{
  __int64 v2; // x20
  unsigned __int8 v3; // w8
  __int64 v4; // x20
  unsigned __int8 v5; // w8
  __int64 v6; // x20
  long double result; // q0
  _BYTE v8[56]; // [xsp+88h] [xbp-48h] BYREF

  *(_QWORD *)a1 = "HttpClient";
  *(_QWORD *)(a1 + 8) = 10LL;
  *(_BYTE *)(a1 + 16) = 0;
  v2 = sub_6575418();
  sub_6246E88(v2, a1);
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)(a1 + 24) = v2;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 64) = 0LL;
  v3 = atomic_load(byte_6F784F8);
  if ( (v3 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6F784F8) )
  {
    qword_6F784B8 = (__int64)off_67F87E8;
    sub_67D19DC(&stru_6F784C0);
    qword_6F784E8 = 0LL;
    unk_6F784F0 = 0LL;
    qword_6F784B8 = (__int64)off_6BA4028;
    qword_6F78500 = (__int64)&qword_6F784B8;
    sub_67EB838(byte_6F784F8);
  }
  *(_QWORD *)(a1 + 72) = sub_623E2F8(&qword_6F784B8);
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_BYTE *)(a1 + 88) = 0;
  if ( pthread_mutex_init((pthread_mutex_t *)(a1 + 92), 0LL) )
  {
    sub_25A21C8(v8);
    sub_25A2098(v8);
  }
  sub_627AC2C();
  v4 = sub_6575418();
  sub_6278208(v4, a1);
  *(_QWORD *)(a1 + 168) = 0LL;
  *(_QWORD *)(a1 + 160) = a1 + 168;
  *(_QWORD *)(a1 + 152) = v4;
  *(_QWORD *)(a1 + 176) = 0LL;
  *(_QWORD *)(a1 + 192) = 0LL;
  *(_QWORD *)(a1 + 184) = a1 + 192;
  *(_QWORD *)(a1 + 200) = 0LL;
  *(_QWORD *)(a1 + 208) = 0LL;
  *(_QWORD *)(a1 + 240) = 0LL;
  *(_QWORD *)(a1 + 232) = a1 + 240;
  *(_QWORD *)(a1 + 216) = 0LL;
  *(_QWORD *)(a1 + 224) = 0LL;
  *(_QWORD *)(a1 + 568) = 0LL;
  *(_QWORD *)(a1 + 552) = a1 + 560;
  *(_QWORD *)(a1 + 560) = 0LL;
  *(_BYTE *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 248) = 0LL;
  *(_QWORD *)(a1 + 256) = 0LL;
  *(_QWORD *)(a1 + 584) = a1 + 592;
  *(_QWORD *)(a1 + 592) = 0LL;
  *(_QWORD *)(a1 + 264) = 0LL;
  *(_QWORD *)(a1 + 272) = 0LL;
  *(_DWORD *)(a1 + 544) = 0;
  *(_QWORD *)(a1 + 600) = 0LL;
  *(_QWORD *)(a1 + 608) = a1 + 616;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_QWORD *)(a1 + 632) = a1 + 640;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_DWORD *)(a1 + 576) = 0;
  *(_QWORD *)(a1 + 616) = 0LL;
  *(_QWORD *)(a1 + 624) = 0LL;
  *(_QWORD *)(a1 + 640) = 0LL;
  *(_QWORD *)(a1 + 648) = 0LL;
  *(_BYTE *)(a1 + 760) = 0;
  *(_DWORD *)(a1 + 764) = 0;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_DWORD *)(a1 + 752) = 0;
  v5 = atomic_load(byte_6D6C9B8);
  if ( (v5 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6D6C9B8) )
  {
    qword_6D6C978 = (__int64)off_67F87E8;
    sub_67D19DC(&stru_6D6C980);
    qword_6D6C9A8 = 0LL;
    unk_6D6C9B0 = 0LL;
    qword_6D6C978 = (__int64)off_68E1EE8;
    qword_6D6C9C0 = (__int64)&qword_6D6C978;
    sub_67EB838(byte_6D6C9B8);
  }
  *(_QWORD *)(a1 + 768) = sub_3C0ACD8(&qword_6D6C978);
  *(_OWORD *)(a1 + 776) = 0u;
  v6 = sub_6575418();
  sub_6261B0C();
  *(_QWORD *)(a1 + 792) = v6;
  *(_BYTE *)(a1 + 800) = 0;
  sub_622A1B8(a1);
  *(_DWORD *)(a1 + 824) = 0;
  sub_622A2D4(a1 + 832);
  *(_BYTE *)(a1 + 2416) = 0;
  *(_BYTE *)(a1 + 2464) = 0;
  *(_OWORD *)(a1 + 2368) = 0u;
  *(_OWORD *)(a1 + 2384) = 0u;
  *(_OWORD *)(a1 + 2396) = 0u;
  sub_25A1F60(a1 + 2480);
  sub_6766848(a1 + 2568);
  *(_QWORD *)(a1 + 2696) = a1 + 2704;
  *(_QWORD *)(a1 + 2584) = 0LL;
  *(_BYTE *)(a1 + 2592) = 0;
  *(_QWORD *)(a1 + 2712) = 0LL;
  *(_OWORD *)(a1 + 2680) = 0u;
  *(_QWORD *)(a1 + 2704) = 0LL;
  *(_OWORD *)(a1 + 2600) = 0u;
  *(_OWORD *)(a1 + 2616) = 0u;
  *(_OWORD *)(a1 + 2632) = 0u;
  *(_OWORD *)(a1 + 2648) = 0u;
  *(_QWORD *)(a1 + 2664) = 0LL;
  *(_OWORD *)(a1 + 2720) = 0u;
  *(_OWORD *)(a1 + 2736) = 0u;
  *(_OWORD *)(a1 + 2752) = 0u;
  *(_OWORD *)(a1 + 2768) = 0u;
  *(_OWORD *)(a1 + 2784) = 0u;
  *(_OWORD *)(a1 + 2800) = 0u;
  *(_OWORD *)(a1 + 2816) = 0u;
  *(_OWORD *)(a1 + 2832) = 0u;
  *(_OWORD *)(a1 + 2848) = 0u;
  *(_OWORD *)(a1 + 2864) = 0u;
  sub_6766848(a1 + 2880);
  *(_QWORD *)(a1 + 2928) = 0LL;
  *(_OWORD *)(a1 + 2912) = 0u;
  *(_OWORD *)(a1 + 2896) = 0u;
  sub_626DD14(a1 + 2936);
  *(_OWORD *)&result = 0uLL;
  *(_BYTE *)(a1 + 3536) = 0;
  *(_WORD *)(a1 + 3584) = 0;
  *(_OWORD *)(a1 + 3432) = 0u;
  *(_OWORD *)(a1 + 3448) = 0u;
  *(_OWORD *)(a1 + 3464) = 0u;
  *(_OWORD *)(a1 + 3473) = 0u;
  *(_OWORD *)(a1 + 3552) = 0u;
  *(_OWORD *)(a1 + 3568) = 0u;
  return result;
}


================================================================================
Function: sub_622A1B8 (0x622A1B8)
================================================================================

__int64 __usercall sub_622A1B8@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  bool v4; // zf
  _QWORD *v5; // x21
  __int64 v6; // x21
  _QWORD *v7; // x22
  __int64 result; // x0

  if ( byte_71CF7B0 )
    v4 = byte_7286120 == 0;
  else
    v4 = 1;
  if ( v4 )
  {
    v5 = (_QWORD *)sub_6575418();
    v5[1] = 0LL;
    v5[2] = 0LL;
    *v5 = off_6BA40C8;
    result = sub_6220478(v5 + 3, a1);
    *a2 = v5 + 3;
    a2[1] = v5;
  }
  else
  {
    v6 = sub_678E980();
    v7 = (_QWORD *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 16LL))(v6, 224LL, 8LL);
    v7[2] = 0LL;
    v7[3] = v6;
    *v7 = off_6BA4078;
    v7[1] = 0LL;
    result = sub_6220478(v7 + 4, a1);
    *a2 = v7 + 4;
    a2[1] = v7;
  }
  return result;
}


================================================================================
Function: sub_622A2D4 (0x622A2D4)
================================================================================

long double __fastcall sub_622A2D4(__int64 a1)
{
  int v2; // w0
  long double result; // q0
  unsigned int v4; // w20
  __int64 v5; // x19
  _QWORD v6[7]; // [xsp+0h] [xbp-40h] BYREF

  v2 = pthread_mutex_init((pthread_mutex_t *)a1, 0LL);
  if ( v2 )
  {
    v4 = v2;
    v5 = sub_6765A30();
    sub_67D2554((int)v6, "boost:: mutex constructor failed in pthread_mutex_init");
    v6[3] = v5;
    memset(&v6[4], 0, 24);
    v6[2] = v4;
    v6[0] = off_6800FA8;
    sub_25A2098((__int64)v6);
  }
  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)(a1 + 96) = 0LL;
  *(_DWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = a1 + 48;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_QWORD *)(a1 + 56) = a1 + 48;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 760) = 0u;
  *(_DWORD *)(a1 + 104) = 1065353216;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_DWORD *)(a1 + 152) = 1065353216;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_QWORD *)(a1 + 192) = 0LL;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_DWORD *)(a1 + 200) = 1065353216;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 1112) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 1128) = 0u;
  *(_DWORD *)(a1 + 240) = 1065353216;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 1356) = 0u;
  *(_DWORD *)(a1 + 280) = 1065353216;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_DWORD *)(a1 + 320) = 1065353216;
  *(_DWORD *)(a1 + 360) = 1065353216;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_DWORD *)(a1 + 400) = 1065353216;
  *(_DWORD *)(a1 + 440) = 1065353216;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 480) = 1065353216;
  *(_DWORD *)(a1 + 520) = 1065353216;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_DWORD *)(a1 + 560) = 1065353216;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_DWORD *)(a1 + 792) = 0;
  *(_DWORD *)(a1 + 832) = 1065353216;
  *(_DWORD *)(a1 + 840) = 0;
  *(_WORD *)(a1 + 872) = 0;
  *(_QWORD *)(a1 + 864) = 0LL;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_QWORD *)(a1 + 1056) = 0LL;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(_OWORD *)(a1 + 1008) = 0u;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(_OWORD *)(a1 + 944) = 0u;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 928) = 0u;
  *(_OWORD *)(a1 + 880) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_DWORD *)(a1 + 1064) = 1065353216;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_DWORD *)(a1 + 1104) = 1065353216;
  *(_DWORD *)(a1 + 1144) = 1065353216;
  *(_OWORD *)(a1 + 1392) = 0u;
  *(_OWORD *)(a1 + 1376) = 0u;
  *(_OWORD *)(a1 + 1344) = 0u;
  *(_OWORD *)(a1 + 1328) = 0u;
  *(_OWORD *)(a1 + 1312) = 0u;
  *(_OWORD *)(a1 + 1296) = 0u;
  *(_OWORD *)(a1 + 1280) = 0u;
  *(_OWORD *)(a1 + 1264) = 0u;
  *(_OWORD *)(a1 + 1248) = 0u;
  *(_OWORD *)(a1 + 1232) = 0u;
  *(_OWORD *)(a1 + 1216) = 0u;
  *(_OWORD *)(a1 + 1200) = 0u;
  *(_OWORD *)(a1 + 1184) = 0u;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(_OWORD *)(a1 + 1152) = 0u;
  *(_DWORD *)(a1 + 1408) = 1065353216;
  *(_DWORD *)(a1 + 1416) = 0;
  *(_OWORD *)(a1 + 1464) = 0u;
  *(_OWORD *)(a1 + 1480) = 0u;
  *(_DWORD *)(a1 + 1456) = 0;
  *(_OWORD *)(a1 + 1440) = 0u;
  *(_OWORD *)(a1 + 1424) = 0u;
  *(_DWORD *)(a1 + 1496) = 1065353216;
  *(_BYTE *)(a1 + 1504) = 0;
  *(_QWORD *)(a1 + 1528) = 0LL;
  *(_OWORD *)(a1 + 1512) = 0u;
  return result;
}


================================================================================
Function: sub_622C968 (0x622C968)
================================================================================

__int64 sub_622C968()
{
  unsigned __int8 v0; // w8
  _QWORD *v1; // x0
  __int64 v2; // x19

  v0 = atomic_load(byte_6C38350);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6C38350) )
  {
    qword_6C38310 = (__int64)off_67F87E8;
    sub_67D19DC((pthread_mutex_t *)algn_6C38318);
    qword_6C38340 = 0LL;
    unk_6C38348 = 0LL;
    qword_6C38310 = (__int64)off_67FAA40;
    qword_6C38358 = (__int64)&qword_6C38310;
    sub_67EB838(byte_6C38350);
  }
  v1 = (_QWORD *)sub_25138D8((__int64)&qword_6C38310);
  if ( !v1 )
    return 688LL;
  v2 = v1[6];
  (*(void (__fastcall **)(_QWORD *))(*v1 + 16LL))(v1);
  return v2 + 688;
}


================================================================================
Function: sub_6237CE4 (0x6237CE4)
================================================================================

__int64 __fastcall sub_6237CE4(__int64 a1, __int64 a2, float a3)
{
  __int64 result; // x0
  float v7; // s9
  bool v8; // nf
  bool v9; // cc
  long double v10; // q0
  pthread_mutex_t *v11; // x19
  int v12; // w8
  int v13; // w21
  __int64 v14; // x5
  __int64 v15; // x6
  __int64 v16; // x7
  long double v17; // q0
  long double v18; // q1
  long double v19; // q2
  long double v20; // q3
  int v21; // w8
  __int64 v22; // x5
  __int64 v23; // x6
  __int64 v24; // x7
  long double v25; // q0
  long double v26; // q1
  long double v27; // q2
  long double v28; // q3
  _QWORD *v29; // x21
  _QWORD *v30; // x21
  int v31; // w8
  _BOOL4 v32; // w8
  bool v33; // zf
  const char *v34; // x10
  const char *v35; // x4
  __int64 v36; // x22
  _QWORD *v37; // x9
  _QWORD *v38; // x8
  __int64 v39; // x9
  __int64 v40; // x10
  _QWORD *v41; // t1
  __int64 v42; // x0
  __int64 v43; // x21
  char *v44; // x4
  __int64 v45; // x22
  _QWORD *v46; // x9
  _QWORD *v47; // x8
  __int64 v48; // x9
  __int64 v49; // x10
  _QWORD *v50; // t1
  __int64 v51; // x0
  char v52; // w8
  __int64 v53[2]; // [xsp+0h] [xbp-90h] BYREF
  _QWORD v54[3]; // [xsp+10h] [xbp-80h] BYREF
  _BYTE v55[8]; // [xsp+28h] [xbp-68h] BYREF
  pthread_mutex_t *mutex; // [xsp+30h] [xbp-60h] BYREF
  char v57; // [xsp+38h] [xbp-58h]
  _QWORD v58[3]; // [xsp+40h] [xbp-50h] BYREF
  int v59; // [xsp+58h] [xbp-38h]

  mutex = (pthread_mutex_t *)(a1 + 92);
  v57 = 0;
  result = sub_25A70B8(&mutex);
  *(float *)&v10 = fabsf(a3);
  v7 = *(float *)(a2 + 80);
  v8 = *(float *)&v10 < INFINITY;
  v9 = *(float *)&v10 <= INFINITY;
  LODWORD(v10) = 2139095039;
  if ( v8 )
    *(float *)&v10 = a3;
  if ( v9 )
    a3 = *(float *)&v10;
  if ( v7 != a3 )
  {
    v12 = *(_DWORD *)(a2 + 464);
    *(float *)(a2 + 80) = a3;
    if ( (v12 | 2) == 3 )
    {
      sub_6256654(v54, a2, &mutex, v10);
      v13 = *(_DWORD *)(a2 + 452);
      memset(v58, 0, sizeof(v58));
      sub_67D3420((unsigned __int8 *)v58, (unsigned __int8 *)v54);
      v59 = v13;
      if ( (v54[0] & 1) != 0 )
        sub_6575460();
      if ( byte_71CF7B0 && byte_6F782F0 )
      {
        v21 = *(_DWORD *)(a2 + 464);
        LOWORD(v54[0]) = 0;
        if ( v21 == 1 )
        {
          if ( *(_BYTE *)(a2 + 710) )
          {
            sub_67D3284((int)v54, "queuedRequestsCacheChecks");
            v29 = (_QWORD *)(a1 + 232);
          }
          else
          {
            v53[0] = (__int64)v58;
            v43 = sub_6240970(a1 + 584, v58, &unk_16A6D8A, v53, v55);
            sub_67D3284((int)v54, "queuedRequests");
            v29 = (_QWORD *)(v43 + 64);
          }
        }
        else if ( *(_BYTE *)(a2 + 793) )
        {
          sub_67D3284((int)v54, "pausedRequests");
          v29 = (_QWORD *)(a1 + 632);
        }
        else
        {
          sub_67D3284((int)v54, "completedRequests");
          v29 = (_QWORD *)(a1 + 608);
        }
        if ( *(_DWORD *)(a2 + 464) == 1 && v7 == 0.0 )
          --*(_DWORD *)(a1 + 668);
        if ( byte_71CF7B0 && byte_71CF760 )
        {
          if ( (unsigned __int8)qword_6F77AE0 < 6u || BYTE1(qword_6F77AE0) < 3u )
            goto LABEL_66;
        }
        else if ( !(_BYTE)qword_6F77AE0 )
        {
LABEL_66:
          v45 = *(_QWORD *)(a2 + 472);
          v46 = *(_QWORD **)(v45 + 8);
          if ( v46 )
          {
            do
            {
              v47 = v46;
              v46 = (_QWORD *)*v46;
            }
            while ( v46 );
          }
          else
          {
            v48 = v45 + 16;
            v47 = *(_QWORD **)(v45 + 16);
            if ( *v47 != v45 )
            {
              do
              {
                v49 = *(_QWORD *)v48;
                v50 = *(_QWORD **)(*(_QWORD *)v48 + 16LL);
                v48 = *(_QWORD *)v48 + 16LL;
                v47 = v50;
              }
              while ( *v50 != v49 );
            }
          }
          if ( *v29 == v45 )
            *v29 = v47;
          v51 = v29[1];
          --v29[2];
          sub_25445A8(v51, v45);
          sub_6575460();
          v53[0] = __PAIR64__(*(_DWORD *)(a2 + 704), LODWORD(a3));
          v53[1] = a2;
          result = sub_6240DCC(v29, v53, v53);
          v52 = v54[0];
          *(_QWORD *)(a2 + 472) = result;
          if ( (v52 & 1) != 0 )
            result = sub_6575460();
LABEL_75:
          if ( a3 == 0.0 && *(_DWORD *)(a2 + 464) == 1 )
            ++*(_DWORD *)(a1 + 668);
          if ( (v58[0] & 1) != 0 )
            result = sub_6575460();
          goto LABEL_7;
        }
        if ( (v54[0] & 1) != 0 )
          v44 = (char *)v54[2];
        else
          v44 = (char *)v54 + 1;
        *(double *)&v25 = v7;
        *(double *)&v26 = a3;
        sub_654E814(
          qword_6F77AE0,
          qword_6F77AE8,
          "[DFLog::TrackHttpRequest] [httptrack] new priority (%f => %f) req:%p from %s",
          a2,
          (__int64)v44,
          v22,
          v23,
          v24,
          v25,
          v26,
          v27,
          v28,
          v53[0]);
        goto LABEL_66;
      }
      if ( *(_DWORD *)(a2 + 464) == 1 )
      {
        if ( *(_BYTE *)(a2 + 710) )
        {
          v30 = (_QWORD *)(a1 + 232);
          v31 = 1;
        }
        else
        {
          v54[0] = v58;
          v30 = (_QWORD *)(sub_6240970(a1 + 584, v58, &unk_16A6D8A, v54, v53) + 64);
          v31 = *(_DWORD *)(a2 + 464);
        }
        v33 = v31 == 1;
        v32 = v31 == 1;
        if ( v33 && v7 == 0.0 )
          --*(_DWORD *)(a1 + 668);
      }
      else
      {
        v32 = 0;
        v30 = (_QWORD *)(a1 + 608);
      }
      if ( byte_71CF7B0 && byte_71CF760 )
      {
        if ( (unsigned __int8)qword_6F77AE0 < 6u || BYTE1(qword_6F77AE0) < 3u )
          goto LABEL_43;
      }
      else if ( !(_BYTE)qword_6F77AE0 )
      {
LABEL_43:
        v36 = *(_QWORD *)(a2 + 472);
        v37 = *(_QWORD **)(v36 + 8);
        if ( v37 )
        {
          do
          {
            v38 = v37;
            v37 = (_QWORD *)*v37;
          }
          while ( v37 );
        }
        else
        {
          v39 = v36 + 16;
          v38 = *(_QWORD **)(v36 + 16);
          if ( *v38 != v36 )
          {
            do
            {
              v40 = *(_QWORD *)v39;
              v41 = *(_QWORD **)(*(_QWORD *)v39 + 16LL);
              v39 = *(_QWORD *)v39 + 16LL;
              v38 = v41;
            }
            while ( *v41 != v40 );
          }
        }
        if ( *v30 == v36 )
          *v30 = v38;
        v42 = v30[1];
        --v30[2];
        sub_25445A8(v42, v36);
        sub_6575460();
        v54[0] = __PAIR64__(*(_DWORD *)(a2 + 704), LODWORD(a3));
        v54[1] = a2;
        result = sub_6240DCC(v30, v54, v54);
        *(_QWORD *)(a2 + 472) = result;
        goto LABEL_75;
      }
      v34 = "queuedRequestsCacheChecks";
      if ( !*(_BYTE *)(a2 + 710) )
        v34 = "queuedRequests";
      if ( v32 )
        v35 = v34;
      else
        v35 = "completedRequests";
      *(double *)&v17 = v7;
      *(double *)&v18 = a3;
      sub_654E814(
        qword_6F77AE0,
        qword_6F77AE8,
        "[DFLog::TrackHttpRequest] [httptrack] new priority (%f => %f) req:%p from %s",
        a2,
        (__int64)v35,
        v14,
        v15,
        v16,
        v17,
        v18,
        v19,
        v20,
        v53[0]);
      goto LABEL_43;
    }
  }
LABEL_7:
  if ( v57 )
  {
    v11 = mutex;
    do
      result = pthread_mutex_unlock(v11);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25A6430(v58, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300((__int64)v58);
    }
  }
  return result;
}


================================================================================
Function: sub_6238278 (0x6238278)
================================================================================

bool __fastcall sub_6238278(__int64 a1, __int64 a2, int a3)
{
  int v6; // w19
  __int64 v7; // x0
  int v8; // w8
  _BOOL4 v9; // w22
  pthread_mutex_t *v10; // x20
  unsigned int v11; // w1
  __int64 v13; // x23
  __int64 v14; // x22
  __int64 v15; // x22
  __int64 v16; // x23
  __int64 v17; // x21
  __int64 v18; // x8
  __int64 v19; // x0
  _QWORD v20[7]; // [xsp+0h] [xbp-50h] BYREF
  pthread_mutex_t *v21; // [xsp+38h] [xbp-18h] BYREF
  char v22; // [xsp+40h] [xbp-10h]

  v6 = sub_6574924(dword_6F77A48);
  v22 = 0;
  v21 = (pthread_mutex_t *)(a1 + 92);
  v7 = sub_25A70B8(&v21);
  v8 = *(_DWORD *)(a2 + 464);
  if ( v8 == 6 )
  {
LABEL_2:
    v9 = 1;
    goto LABEL_3;
  }
  v9 = 0;
  if ( a3 && v8 )
  {
    if ( !*(_QWORD *)(a2 + 712) )
    {
      v13 = sub_6575418();
      v7 = sub_25A1F60(v13);
      v14 = *(_QWORD *)(a2 + 712);
      *(_QWORD *)(a2 + 712) = v13;
      if ( v14 )
      {
        while ( pthread_mutex_destroy((pthread_mutex_t *)v14) == 4 )
          ;
        while ( pthread_cond_destroy((pthread_cond_t *)(v14 + 40)) == 4 )
          ;
        v7 = sub_6575460();
      }
    }
    v15 = *(_QWORD *)(a2 + 712);
    if ( a3 < 1 )
    {
      while ( *(_DWORD *)(a2 + 464) != 6 )
        sub_25A6F10(v15, &v21);
    }
    else
    {
      v16 = sub_675F1F4(v7) + 1000000LL * (unsigned int)a3;
      while ( *(_DWORD *)(a2 + 464) != 6 )
      {
        v17 = sub_675F18C();
        v18 = v16 - sub_675F1F4(v17) + v17;
        v20[0] = v18 / 1000000000;
        v20[1] = v18 % 1000000000;
        v19 = sub_2CAC424(v15, &v21, v20);
        if ( sub_675F1F4(v19) >= v16 )
        {
          v9 = *(_DWORD *)(a2 + 464) == 6;
          goto LABEL_3;
        }
      }
    }
    goto LABEL_2;
  }
LABEL_3:
  if ( v22 )
  {
    v10 = v21;
    do
      v11 = pthread_mutex_unlock(v10);
    while ( v11 == 4 );
    if ( v11 )
    {
      sub_25A6430(v20, v11, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300((__int64)v20);
    }
  }
  sub_6574924(v6);
  return v9;
}


================================================================================
Function: sub_62384D0 (0x62384D0)
================================================================================

__int64 __fastcall sub_62384D0(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x20
  __int64 v4; // x0
  pthread_mutex_t *v5; // x20
  unsigned int v6; // w1
  _QWORD v7[7]; // [xsp+0h] [xbp-50h] BYREF
  pthread_mutex_t *v8; // [xsp+38h] [xbp-18h] BYREF
  char v9; // [xsp+40h] [xbp-10h]

  result = *(_QWORD *)(a1 + 784);
  if ( !result )
  {
    v9 = 0;
    v8 = (pthread_mutex_t *)(a1 + 92);
    sub_25A70B8((__int64)&v8);
    if ( !*(_QWORD *)(a1 + 784) )
    {
      v3 = sub_6575418();
      sub_651D404(v3, "HttpThreadPool", 1LL, 3LL, 0LL);
      v4 = *(_QWORD *)(a1 + 784);
      *(_QWORD *)(a1 + 784) = v3;
      if ( v4 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 8LL))(v4);
    }
    if ( v9 )
    {
      v5 = v8;
      do
        v6 = pthread_mutex_unlock(v5);
      while ( v6 == 4 );
      if ( v6 )
      {
        sub_25A6430(v7, v6, "boost: mutex unlock failed in pthread_mutex_unlock");
        sub_25A6300((__int64)v7);
      }
    }
    return *(_QWORD *)(a1 + 784);
  }
  return result;
}


================================================================================
Function: sub_623C140 (0x623C140)
================================================================================

__int64 __fastcall sub_623C140(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 *v4; // x21
  __int64 *v5; // x20
  __int64 *v6; // x22
  char v7; // t1

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = v2[6];
      v5 = *v2;
      if ( v4 )
      {
        if ( v2[7] != v4 )
        {
          v6 = v2[7];
          do
          {
            v7 = *((_BYTE *)v6 - 24);
            v6 -= 3;
            if ( (v7 & 1) != 0 )
              sub_6575460();
          }
          while ( v6 != v4 );
        }
        v2[7] = v4;
        sub_6575460();
      }
      if ( ((_BYTE)v2[3] & 1) != 0 )
        sub_6575460();
      result = sub_6575460();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_623C1E4 (0x623C1E4)
================================================================================

__int64 __fastcall sub_623C1E4(__int64 a1, __int64 **a2)
{
  __int64 **v2; // x19
  __int64 result; // x0
  __int64 **v4; // x20
  __int64 *v5; // x21
  __int64 *v6; // x0
  __int64 *v7; // x22

  if ( a2 )
  {
    v2 = a2;
    do
    {
      v4 = (__int64 **)v2[7];
      v5 = *v2;
      if ( v4 )
      {
        do
        {
          v7 = *v4;
          if ( ((_BYTE)v4[2] & 1) != 0 )
            sub_6575460();
          sub_6575460();
          v4 = (__int64 **)v7;
        }
        while ( v7 );
      }
      v6 = v2[5];
      v2[5] = 0LL;
      if ( v6 )
        sub_6575460();
      if ( ((_BYTE)v2[2] & 1) != 0 )
        sub_6575460();
      result = sub_6575460();
      v2 = (__int64 **)v5;
    }
    while ( v5 );
  }
  return result;
}


================================================================================
Function: sub_623E2F8 (0x623E2F8)
================================================================================

__int64 __fastcall sub_623E2F8(__int64 a1)
{
  unsigned __int64 v2; // x20
  __int64 v4; // x0
  __int64 v5; // x0

  v2 = sub_67F0440(1uLL, (atomic_ullong *)(a1 + 56));
  if ( (~v2 & 0x3FFFFFFFFFFFFFFFLL) == 0 )
    sub_65786C4(0);
  if ( v2 >> 62 != 2 )
  {
    sub_6577E74(a1 + 8);
    if ( !*(_QWORD *)(a1 + 48) )
    {
      v4 = atomic_load(&qword_7286220);
      v5 = sub_6585904(v4, a1);
      *(_QWORD *)(a1 + 48) = sub_623E540(v5);
      sub_67F05F0(0x8000000000000000LL, (atomic_ullong *)(a1 + 56));
    }
    sub_67D1AF4((pthread_mutex_t *)(a1 + 8));
  }
  return a1;
}


================================================================================
Function: sub_623E540 (0x623E540)
================================================================================

__int64 sub_623E540()
{
  __int64 v0; // x19

  v0 = sub_6575FA8(0xC8uLL, 8uLL);
  sub_632C70C();
  return v0;
}


================================================================================
Function: sub_6240970 (0x6240970)
================================================================================

__int64 __fastcall sub_6240970(__int64 a1, __int64 a2, __int64 a3, __int128 **a4)
{
  __int64 *v6; // x23
  __int64 *v7; // x24
  __int64 v9; // x21
  __int64 v10; // x0
  __int128 *v11; // x8
  __int128 v12; // q0
  int v13; // w10
  __int64 *v14; // x8
  __int64 v15; // x8
  __int64 v16; // x1

  v6 = (__int64 *)(a1 + 8);
  v7 = *(__int64 **)(a1 + 8);
  if ( v7 )
  {
    v6 = (__int64 *)(a1 + 8);
    while ( 1 )
    {
      while ( (sub_6240AA4(a2, v7 + 4) & 1) == 0 )
      {
        if ( (sub_6240AA4(v7 + 4, a2) & 1) == 0 )
          goto LABEL_10;
        v6 = v7 + 1;
        if ( !v7[1] )
          goto LABEL_10;
        v7 = (__int64 *)v7[1];
      }
      if ( !*v7 )
        break;
      v6 = v7;
      v7 = (__int64 *)*v7;
    }
    v6 = v7;
    goto LABEL_13;
  }
  v7 = (__int64 *)(a1 + 8);
LABEL_10:
  v9 = *v6;
  if ( !*v6 )
  {
LABEL_13:
    v10 = sub_6575418();
    v11 = *a4;
    v9 = v10;
    v12 = **a4;
    *(_QWORD *)(v10 + 48) = *((_QWORD *)*a4 + 2);
    *(_OWORD *)(v10 + 32) = v12;
    *((_QWORD *)v11 + 1) = 0LL;
    *((_QWORD *)v11 + 2) = 0LL;
    v13 = *((_DWORD *)v11 + 6);
    *(_QWORD *)v11 = 0LL;
    *(_QWORD *)(v10 + 80) = 0LL;
    *(_QWORD *)(v10 + 72) = 0LL;
    *(_QWORD *)(v10 + 64) = v10 + 72;
    *(_QWORD *)v10 = 0LL;
    *(_QWORD *)(v10 + 8) = 0LL;
    *(_QWORD *)(v10 + 16) = v7;
    *v6 = v10;
    v14 = *(__int64 **)a1;
    *(_DWORD *)(v10 + 56) = v13;
    v15 = *v14;
    if ( v15 )
    {
      *(_QWORD *)a1 = v15;
      v16 = *v6;
    }
    else
    {
      v16 = v10;
    }
    sub_2507ED0(*(_QWORD *)(a1 + 8), v16);
    ++*(_QWORD *)(a1 + 16);
  }
  return v9;
}


================================================================================
Function: sub_6240AA4 (0x6240AA4)
================================================================================

__int64 __fastcall sub_6240AA4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x23
  unsigned __int64 v5; // x24
  size_t v6; // x21
  unsigned __int64 v7; // x22
  size_t v8; // x25
  size_t v9; // x2
  unsigned __int8 *v10; // x1
  unsigned __int8 *v11; // x0
  int v12; // w0
  const void *v13; // x0
  unsigned __int8 *v14; // x1
  unsigned __int8 *i; // x8

  v2 = *a2;
  v5 = *a1;
  if ( (v2 & 1) != 0 )
    v6 = *((_QWORD *)a2 + 1);
  else
    v6 = v2 >> 1;
  v7 = v5 >> 1;
  if ( (v5 & 1) != 0 )
    v8 = *((_QWORD *)a1 + 1);
  else
    v8 = v5 >> 1;
  if ( v6 >= v8 )
    v9 = v8;
  else
    v9 = v6;
  if ( v9 )
  {
    v10 = (v2 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a2 + 2) : a2 + 1;
    v11 = (v5 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a1 + 2) : a1 + 1;
    v12 = memcmp(v11, v10, v9);
    if ( v12 )
    {
      if ( (v12 & 0x80000000) == 0 )
        goto LABEL_19;
      return 1LL;
    }
  }
  if ( v8 < v6 )
    return 1LL;
LABEL_19:
  if ( v8 != v6 )
    return 0LL;
  if ( (v5 & 1) != 0 )
    v13 = (const void *)*((_QWORD *)a1 + 2);
  else
    v13 = a1 + 1;
  if ( (v2 & 1) != 0 )
    v14 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v14 = a2 + 1;
  if ( (v5 & 1) != 0 )
  {
    if ( !v6 || !memcmp(v13, v14, v6) )
      return *((_DWORD *)a1 + 6) < *((_DWORD *)a2 + 6);
    return 0LL;
  }
  if ( v6 )
  {
    for ( i = a1 + 1; *i == *v14; ++i )
    {
      --v7;
      ++v14;
      if ( !v7 )
        return *((_DWORD *)a1 + 6) < *((_DWORD *)a2 + 6);
    }
    return 0LL;
  }
  return *((_DWORD *)a1 + 6) < *((_DWORD *)a2 + 6);
}


================================================================================
Function: sub_6240DCC (0x6240DCC)
================================================================================

__int64 __fastcall sub_6240DCC(__int64 **a1, __int64 a2, __int128 *a3)
{
  __int64 *v5; // x22
  __int64 v6; // x23
  float v7; // s0
  unsigned int v8; // w8
  float v9; // s1
  unsigned int v10; // w9
  __int64 v11; // x21
  __int64 v12; // x0
  __int128 v13; // q0
  __int64 *v14; // x8
  __int64 v15; // x1

  v5 = (__int64 *)(a1 + 1);
  v6 = (__int64)a1[1];
  if ( v6 )
  {
    v7 = *(float *)a2;
    v5 = (__int64 *)(a1 + 1);
    v8 = *(_DWORD *)(a2 + 4);
    while ( 1 )
    {
      v9 = *(float *)(v6 + 32);
      if ( v7 < v9 )
        goto LABEL_6;
      if ( v7 != v9 )
        break;
      v10 = *(_DWORD *)(v6 + 36);
      if ( v8 >= v10 )
      {
        if ( v9 >= v7 && v10 >= v8 )
          goto LABEL_15;
LABEL_12:
        v5 = (__int64 *)(v6 + 8);
        if ( !*(_QWORD *)(v6 + 8) )
          goto LABEL_15;
        v6 = *(_QWORD *)(v6 + 8);
      }
      else
      {
LABEL_6:
        if ( !*(_QWORD *)v6 )
        {
          v5 = (__int64 *)v6;
          goto LABEL_18;
        }
        v5 = (__int64 *)v6;
        v6 = *(_QWORD *)v6;
      }
    }
    if ( v9 >= v7 )
      goto LABEL_15;
    goto LABEL_12;
  }
  v6 = (__int64)(a1 + 1);
LABEL_15:
  v11 = *v5;
  if ( !*v5 )
  {
LABEL_18:
    v12 = sub_6575418();
    v13 = *a3;
    *(_QWORD *)v12 = 0LL;
    *(_QWORD *)(v12 + 8) = 0LL;
    *(_QWORD *)(v12 + 16) = v6;
    v11 = v12;
    *(_OWORD *)(v12 + 32) = v13;
    *v5 = v12;
    v14 = (__int64 *)**a1;
    if ( v14 )
    {
      *a1 = v14;
      v15 = *v5;
    }
    else
    {
      v15 = v12;
    }
    sub_2507ED0((__int64)a1[1], v15);
    a1[2] = (__int64 *)((char *)a1[2] + 1);
  }
  return v11;
}


================================================================================
Function: sub_6246E88 (0x6246E88)
================================================================================

long double __fastcall sub_6246E88(__int64 a1, __int64 a2)
{
  unsigned __int8 v3; // w8
  __int64 v4; // x0
  long double result; // q0

  *(_QWORD *)a1 = a2;
  v3 = atomic_load(byte_6D6C9B8);
  if ( (v3 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6D6C9B8) )
  {
    qword_6D6C978 = (__int64)off_67F87E8;
    sub_67D19DC(&stru_6D6C980);
    qword_6D6C9A8 = 0LL;
    unk_6D6C9B0 = 0LL;
    qword_6D6C978 = (__int64)off_68E1EE8;
    qword_6D6C9C0 = (__int64)&qword_6D6C978;
    sub_67EB838(byte_6D6C9B8);
  }
  v4 = sub_3C0ACD8(&qword_6D6C978);
  *(_OWORD *)&result = 0uLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_QWORD *)(a1 + 8) = v4;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  return result;
}


================================================================================
Function: sub_6253A74 (0x6253A74)
================================================================================

__int64 __fastcall sub_6253A74(__int64 result, int a2)
{
  *(_DWORD *)(result + 44) = a2;
  return result;
}


================================================================================
Function: sub_6253AD0 (0x6253AD0)
================================================================================

__int64 __fastcall sub_6253AD0(char *a1, __int64 a2, char *a3, __int64 a4)
{
  __int64 v4; // x9
  int v5; // w8
  int v6; // t1
  int v7; // w10
  int v8; // t1
  unsigned int v9; // w11
  bool v10; // zf
  _BOOL4 v11; // w8

  if ( a2 != a4 )
    return 0LL;
  if ( !a2 )
    return 1LL;
  v4 = a2 - 1;
  do
  {
    v6 = *a1++;
    v5 = v6;
    v8 = *a3++;
    v7 = v8;
    v9 = v8 - 65;
    if ( (unsigned int)(v5 - 65) < 0x1A )
      v5 |= 0x20u;
    if ( v9 < 0x1A )
      v7 |= 0x20u;
    v10 = v5 == v7;
    v11 = v5 == v7;
    if ( !v10 )
      break;
  }
  while ( v4-- );
  return v11;
}


================================================================================
Function: sub_62548C4 (0x62548C4)
================================================================================

unsigned __int64 *__fastcall sub_62548C4(__int64 a1, __int64 a2, __int128 *a3, char a4)
{
  __int64 v7; // x9
  unsigned __int64 *result; // x0
  _QWORD v9[2]; // [xsp+8h] [xbp-18h] BYREF

  sub_6217814(v9, a2);
  v7 = v9[1];
  *(_QWORD *)a1 = v9[0];
  *(_QWORD *)(a1 + 8) = v7;
  result = sub_67D2788((unsigned __int64 *)(a1 + 16), a3);
  *(_BYTE *)(a1 + 40) = a4 & 1;
  return result;
}


================================================================================
Function: sub_6254B64 (0x6254B64)
================================================================================

__int64 __usercall sub_6254B64@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  __int64 v3; // x5
  __int64 v4; // x6
  __int64 v5; // x7
  int v6; // w19
  long double v7; // q0
  long double v8; // q1
  long double v9; // q2
  long double v10; // q3
  unsigned __int64 v11; // x8
  __int64 v12; // x8
  int v13; // w9
  unsigned __int64 v14; // x10
  unsigned __int64 v15; // x11
  char *v16; // x3
  __int64 v17; // x9
  __int64 v19[2]; // [xsp+0h] [xbp-20h] BYREF
  int v20; // [xsp+14h] [xbp-Ch] BYREF

  v20 = a1;
  v6 = sub_6574924(dword_6F78AA0);
  if ( (word_6F78AE0 & 1) != 0 )
    v11 = qword_6F78AE8;
  else
    v11 = (unsigned __int64)(unsigned __int8)word_6F78AE0 >> 1;
  if ( v11 == 5 && !(unsigned int)sub_67D3100((int)&word_6F78AE0, 0, -1, "msxml") && (sub_625CE80() & 1) != 0 )
  {
    if ( (byte_6F78C10 & 1) != 0 )
      goto LABEL_37;
    byte_6F78C10 = 1;
    if ( byte_71CF7B0 && byte_71CF760 )
    {
      if ( (unsigned __int8)qword_6F77AC0 < 6u || BYTE1(qword_6F77AC0) < 3u )
LABEL_37:
        sub_6254E74(v19, &v20);
    }
    else if ( !(_BYTE)qword_6F77AC0 )
    {
      goto LABEL_37;
    }
    sub_654E814(
      qword_6F77AC0,
      qword_6F77AC8,
      "[DFLog::HttpTraceError] Warning: will use \"%s\" for HttpRequest, while default is \"%s\"",
      (__int64)"msxml",
      (__int64)"curl",
      v3,
      v4,
      v5,
      v7,
      v8,
      v9,
      v10,
      v19[0]);
    goto LABEL_37;
  }
  v12 = qword_6F78AE8;
  v13 = word_6F78AE0 & 1;
  v14 = (unsigned __int64)(unsigned __int8)word_6F78AE0 >> 1;
  if ( v13 )
    v15 = qword_6F78AE8;
  else
    v15 = (unsigned __int64)(unsigned __int8)word_6F78AE0 >> 1;
  if ( !v15 )
  {
    if ( !(unsigned int)sub_67D3100((int)&word_6F78AE0, 0, -1, &byte_CBCB6C) )
      goto LABEL_34;
    v12 = qword_6F78AE8;
    v13 = word_6F78AE0 & 1;
    v14 = (unsigned __int64)(unsigned __int8)word_6F78AE0 >> 1;
  }
  if ( !v13 )
    v12 = v14;
  if ( (v12 != 4 || (unsigned int)sub_67D3100((int)&word_6F78AE0, 0, -1, "curl")) && (byte_6F78C11 & 1) == 0 )
  {
    byte_6F78C11 = 1;
    if ( byte_71CF7B0 && byte_71CF760 )
    {
      if ( (unsigned __int8)qword_6F77AC0 < 6u || BYTE1(qword_6F77AC0) < 3u )
        goto LABEL_34;
    }
    else if ( !(_BYTE)qword_6F77AC0 )
    {
      goto LABEL_34;
    }
    if ( (word_6F78AE0 & 1) != 0 )
      v16 = (char *)qword_6F78AF0;
    else
      v16 = (char *)&word_6F78AE0 + 1;
    sub_654E814(
      qword_6F77AC0,
      qword_6F77AC8,
      "[DFLog::HttpTraceError] Warning: cannot use \"%s\" for HttpRequest, will use default \"%s\"",
      (__int64)v16,
      (__int64)"curl",
      v3,
      v4,
      v5,
      v7,
      v8,
      v9,
      v10,
      v19[0]);
  }
LABEL_34:
  sub_6255008(v19, &v20);
  v17 = v19[1];
  *a2 = v19[0];
  a2[1] = v17;
  return sub_6574924(v6);
}


================================================================================
Function: sub_6254E74 (0x6254E74)
================================================================================

void __fastcall __noreturn sub_6254E74(unsigned int *a1)
{
  bool v2; // zf
  _QWORD *v3; // x0
  __int64 v4; // x1
  __int64 v5; // [xsp+0h] [xbp-10h] BYREF

  if ( byte_71CF7B0 )
    v2 = byte_7286120 == 0;
  else
    v2 = 1;
  if ( !v2 )
  {
    v5 = sub_678E980();
    sub_625B0E0(&v5, a1);
  }
  v3 = (_QWORD *)sub_6575418();
  v4 = *a1;
  v3[2] = 0LL;
  v3[1] = 0LL;
  *v3 = off_6BA4E10;
  sub_625CE88(v3 + 4, v4);
}


================================================================================
Function: sub_6255008 (0x6255008)
================================================================================

unsigned __int64 __usercall sub_6255008@<X0>(unsigned int *a1@<X0>, _QWORD *a2@<X8>)
{
  bool v4; // zf
  unsigned __int64 *v5; // x19
  __int64 v6; // x1
  unsigned __int64 *v7; // x21
  unsigned __int64 *v8; // x23
  unsigned __int64 result; // x0
  __int64 v10; // [xsp+0h] [xbp-10h] BYREF

  if ( byte_71CF7B0 )
    v4 = byte_7286120 == 0;
  else
    v4 = 1;
  if ( !v4 )
  {
    v10 = sub_678E980();
    return sub_625B3D0(&v10, a1);
  }
  v5 = (unsigned __int64 *)sub_6575418();
  v6 = *a1;
  v7 = v5 + 4;
  v5[2] = 0LL;
  v5[1] = 0LL;
  *v5 = (unsigned __int64)off_6BA4EB0;
  result = sub_627CB6C(v5 + 4, v6);
  v8 = (unsigned __int64 *)v5[6];
  *a2 = v5 + 4;
  a2[1] = v5;
  if ( v8 )
  {
    if ( v8[1] != -1LL )
      return result;
    sub_67F0410(1uLL, (atomic_ullong *)(v5 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v5 + 2));
    v5[5] = (unsigned __int64)v7;
    v5[6] = (unsigned __int64)v5;
    sub_67D18A4(v8);
  }
  else
  {
    sub_67F0410(1uLL, (atomic_ullong *)(v5 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v5 + 2));
    v5[5] = (unsigned __int64)v7;
    v5[6] = (unsigned __int64)v5;
  }
  result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v5 + 1));
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v5 + 16))(v5);
    return sub_67D18A4(v5);
  }
  return result;
}


================================================================================
Function: sub_6255394 (0x6255394)
================================================================================

__int64 __fastcall sub_6255394(__int64 a1)
{
  __int64 v6; // x9
  __int64 v7; // x10
  unsigned __int8 v8; // w8
  __int64 v9; // x0
  unsigned __int8 *v10; // x0
  unsigned __int64 v11; // x8
  size_t v13; // x8
  void *v14; // x3
  size_t v15; // x4

  *(_DWORD *)(a1 + 80) = 2139095039;
  *(_QWORD *)a1 = off_6BA4B80;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_BYTE *)(a1 + 280) = 6;
  *(_DWORD *)(a1 + 281) = 5522759;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_QWORD *)(a1 + 368) = 0LL;
  *(_QWORD *)(a1 + 432) = 0LL;
  *(_QWORD *)(a1 + 440) = 0LL;
  *(_QWORD *)(a1 + 424) = 0LL;
  *(_QWORD *)(a1 + 320) = 0LL;
  *(_DWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 452) = 0xFFFFFFFF00000000LL;
  *(_QWORD *)(a1 + 304) = 0LL;
  *(_QWORD *)(a1 + 312) = 0LL;
  __asm { FMOV            V1.2D, #-1.0 }
  *(_BYTE *)(a1 + 416) = 0;
  v6 = dword_6C2CEB0;
  *(_DWORD *)(a1 + 464) = 0;
  v7 = dword_6C2CEAC;
  *(_DWORD *)(a1 + 820) = 0;
  *(_QWORD *)(a1 + 552) = 0LL;
  *(_QWORD *)(a1 + 384) = v6;
  *(_QWORD *)(a1 + 392) = 0LL;
  *(_QWORD *)(a1 + 400) = v7;
  *(_QWORD *)(a1 + 408) = 0LL;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 560) = _Q1;
  *(_OWORD *)(a1 + 576) = _Q1;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 592) = _Q1;
  *(_OWORD *)(a1 + 608) = _Q1;
  *(_QWORD *)(a1 + 624) = 0xBFF0000000000000LL;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 661) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_QWORD *)(a1 + 680) = 0LL;
  *(_QWORD *)(a1 + 688) = 0LL;
  *(_DWORD *)(a1 + 696) = -1;
  *(_QWORD *)(a1 + 808) = 0LL;
  *(_QWORD *)(a1 + 800) = 0LL;
  *(_OWORD *)(a1 + 780) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_WORD *)(a1 + 816) = 1;
  *(_BYTE *)(a1 + 818) = 0;
  *(_DWORD *)(a1 + 824) = 0;
  *(_QWORD *)(a1 + 840) = 0LL;
  *(_QWORD *)(a1 + 832) = 0LL;
  v8 = atomic_load(byte_6C38350);
  if ( (v8 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6C38350) )
  {
    qword_6C38310 = (__int64)off_67F87E8;
    sub_67D19DC((pthread_mutex_t *)algn_6C38318);
    qword_6C38340 = 0LL;
    unk_6C38348 = 0LL;
    qword_6C38310 = (__int64)off_67FAA40;
    qword_6C38358 = (__int64)&qword_6C38310;
    sub_67EB838(byte_6C38350);
  }
  *(_QWORD *)(a1 + 848) = sub_25138D8((__int64)&qword_6C38310);
  *(_DWORD *)(a1 + 856) = 0;
  sub_625CE00();
  sub_62556A4(a1, "Accept-Encoding", 0xFuLL, "gzip, deflate", 0xDuLL);
  sub_62556A4(a1, "Cache-Control", 0xDuLL, "no-cache", 8uLL);
  v9 = sub_62556A4(a1, "Connection", 0xAuLL, "keep-alive", 0xAuLL);
  v10 = (unsigned __int8 *)sub_6216928(v9);
  v11 = *v10;
  _ZF = (v11 & 1) == 0;
  v13 = v11 >> 1;
  if ( _ZF )
    v14 = v10 + 1;
  else
    v14 = (void *)*((_QWORD *)v10 + 2);
  if ( _ZF )
    v15 = v13;
  else
    v15 = *((_QWORD *)v10 + 1);
  return sub_62556A4(a1, "User-Agent", 0xAuLL, v14, v15);
}


================================================================================
Function: sub_62556A4 (0x62556A4)
================================================================================

__int64 __fastcall sub_62556A4(__int64 result, void *src, size_t n, void *a4, size_t a5)
{
  __int64 v7; // x19
  __int64 v10; // x8
  __int64 v11; // x20
  __int64 v12; // x26
  __int64 v13; // x25
  __int64 v14; // x28
  unsigned __int64 v15; // x8
  bool v16; // zf
  unsigned __int64 v17; // x8
  __int64 v18; // x2
  __int64 v19; // x3
  char *v20; // x25
  char *v21; // x23
  char *v22; // x8
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x9
  __int128 v25; // q0
  __int128 v26; // q0
  char *v27; // x9
  __int128 v28; // [xsp+0h] [xbp-70h] BYREF
  char *v29; // [xsp+10h] [xbp-60h]
  __int128 v30; // [xsp+18h] [xbp-58h] BYREF
  char *v31; // [xsp+28h] [xbp-48h]
  __int128 v32; // [xsp+30h] [xbp-40h] BYREF
  char *v33; // [xsp+40h] [xbp-30h]
  __int128 v34; // [xsp+48h] [xbp-28h]
  char *v35; // [xsp+58h] [xbp-18h]

  v7 = result;
  v10 = *(_QWORD *)(result + 32);
  v12 = *(_QWORD *)(result + 40);
  v11 = result + 32;
  if ( v10 == v12 )
  {
LABEL_11:
    if ( !src )
    {
      v30 = 0uLL;
      v31 = 0LL;
      if ( a4 )
        goto LABEL_22;
      goto LABEL_18;
    }
    if ( n >= 0xFFFFFFFFFFFFFFF0LL )
      sub_67D2618();
    if ( n >= 0x17 )
    {
      v20 = (char *)sub_6575418();
      *((_QWORD *)&v30 + 1) = n;
      v31 = v20;
      *(_QWORD *)&v30 = (n + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v20 = (char *)&v30 + 1;
      LOBYTE(v30) = 2 * n;
      if ( !n )
      {
LABEL_21:
        v20[n] = 0;
        if ( a4 )
        {
LABEL_22:
          if ( a5 >= 0xFFFFFFFFFFFFFFF0LL )
            sub_67D2618();
          if ( a5 >= 0x17 )
          {
            v21 = (char *)sub_6575418();
            *((_QWORD *)&v28 + 1) = a5;
            v29 = v21;
            *(_QWORD *)&v28 = (a5 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
          }
          else
          {
            v21 = (char *)&v28 + 1;
            LOBYTE(v28) = 2 * a5;
            if ( !a5 )
              goto LABEL_28;
          }
          result = (__int64)memcpy(v21, a4, a5);
LABEL_28:
          v21[a5] = 0;
LABEL_29:
          v22 = v31;
          v31 = 0LL;
          v33 = v22;
          v35 = v29;
          v23 = *(_QWORD *)(v7 + 40);
          v24 = *(_QWORD *)(v7 + 48);
          v32 = v30;
          v25 = v28;
          v29 = 0LL;
          v30 = 0uLL;
          v28 = 0uLL;
          v34 = v25;
          if ( v23 >= v24 )
          {
            result = sub_2568AA8(v11, &v32);
            if ( (v34 & 1) != 0 )
            {
              result = sub_6575460();
              if ( (v32 & 1) != 0 )
                goto LABEL_39;
            }
            else if ( (v32 & 1) != 0 )
            {
              goto LABEL_39;
            }
          }
          else
          {
            v26 = v32;
            *(_QWORD *)(v23 + 16) = v33;
            *(_OWORD *)v23 = v26;
            v27 = v35;
            v33 = 0LL;
            v32 = 0uLL;
            *(_OWORD *)(v23 + 24) = v34;
            *(_QWORD *)(v23 + 40) = v27;
            v35 = 0LL;
            v34 = 0uLL;
            *(_QWORD *)(v7 + 40) = v23 + 48;
            if ( (v32 & 1) != 0 )
            {
LABEL_39:
              result = sub_6575460();
              if ( (v28 & 1) != 0 )
              {
LABEL_40:
                result = sub_6575460();
                if ( (v30 & 1) == 0 )
                  return result;
                return sub_6575460();
              }
LABEL_35:
              if ( (v30 & 1) == 0 )
                return result;
              return sub_6575460();
            }
          }
          if ( (v28 & 1) != 0 )
            goto LABEL_40;
          goto LABEL_35;
        }
LABEL_18:
        v28 = 0uLL;
        v29 = 0LL;
        goto LABEL_29;
      }
    }
    result = (__int64)memcpy(v20, src, n);
    goto LABEL_21;
  }
  v13 = v10 + 24;
  while ( 1 )
  {
    v14 = v13 - 23;
    v15 = *(unsigned __int8 *)(v13 - 24);
    v16 = (v15 & 1) == 0;
    v17 = v15 >> 1;
    v18 = v16 ? v13 - 23 : *(_QWORD *)(v13 - 8);
    v19 = v16 ? v17 : *(_QWORD *)(v13 - 16);
    result = sub_6253AD0(src, n, v18, v19);
    if ( (result & 1) != 0 )
      return sub_6588260(v13, a4, a5);
    v13 += 48LL;
    if ( v14 + 47 == v12 )
      goto LABEL_11;
  }
}


================================================================================
Function: sub_6255DFC (0x6255DFC)
================================================================================

__int64 __fastcall sub_6255DFC(__int64 a1, void *a2, size_t a3)
{
  int v6; // w19
  void *v7; // x0
  char v8; // w0
  __int64 v10; // x8
  __int128 v11; // [xsp+0h] [xbp-A0h] BYREF
  __int64 v12; // [xsp+10h] [xbp-90h]
  __int64 v13[2]; // [xsp+18h] [xbp-88h] BYREF
  unsigned __int8 v14[16]; // [xsp+30h] [xbp-70h] BYREF
  char v15; // [xsp+48h] [xbp-58h]
  char v16; // [xsp+60h] [xbp-40h]
  char v17; // [xsp+78h] [xbp-28h]

  v6 = sub_6574924(dword_6F78AA0);
  sub_6588260(a1 + 88, a2, a3);
  sub_6256004(a1 + 88, a1 + 112);
  if ( (*(_BYTE *)(a1 + 112) & 1) != 0 )
    v7 = *(void **)(a1 + 128);
  else
    v7 = (void *)(a1 + 113);
  sub_65186CC(v13, v7);
  if ( (sub_6519F80(v13) & 1) != 0 )
    v8 = sub_6519A28(v13);
  else
    v8 = 0;
  *(_BYTE *)(a1 + 411) = v8 & 1;
  sub_67D3420((unsigned __int8 *)(a1 + 136), v14);
  if ( !byte_71CF7B0 || !byte_6F78B18 )
  {
LABEL_11:
    if ( (v17 & 1) == 0 )
      goto LABEL_12;
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 412) )
  {
    sub_67D3420((unsigned __int8 *)(a1 + 160), (unsigned __int8 *)(a1 + 136));
    goto LABEL_11;
  }
  sub_621C6DC(&v11, v13);
  if ( (*(_BYTE *)(a1 + 160) & 1) != 0 )
    sub_6575460();
  v10 = v12;
  *(_OWORD *)(a1 + 160) = v11;
  *(_QWORD *)(a1 + 176) = v10;
  if ( (v17 & 1) == 0 )
  {
LABEL_12:
    if ( (v16 & 1) == 0 )
      goto LABEL_13;
    goto LABEL_22;
  }
LABEL_21:
  sub_6575460();
  if ( (v16 & 1) == 0 )
  {
LABEL_13:
    if ( (v15 & 1) == 0 )
      goto LABEL_14;
    goto LABEL_23;
  }
LABEL_22:
  sub_6575460();
  if ( (v15 & 1) == 0 )
  {
LABEL_14:
    if ( (v14[0] & 1) == 0 )
      goto LABEL_15;
LABEL_24:
    sub_6575460();
    if ( (v13[0] & 1) == 0 )
      return sub_6574924(v6);
    goto LABEL_16;
  }
LABEL_23:
  sub_6575460();
  if ( (v14[0] & 1) != 0 )
    goto LABEL_24;
LABEL_15:
  if ( (v13[0] & 1) != 0 )
LABEL_16:
    sub_6575460();
  return sub_6574924(v6);
}


================================================================================
Function: sub_6256004 (0x6256004)
================================================================================

__int64 __fastcall sub_6256004(unsigned __int8 *a1, _QWORD *a2)
{
  unsigned __int64 v4; // x8
  bool v5; // zf
  unsigned __int64 v6; // x8
  unsigned __int8 *v7; // x21
  unsigned __int64 v8; // x23
  int v9; // w9
  unsigned __int64 v11; // x22
  int v12; // w10
  unsigned __int8 *v14; // x0
  unsigned __int16 *v15; // x24
  __int64 v16; // x8
  unsigned __int16 *v17; // x0
  unsigned __int64 v18; // x2
  __int64 result; // x0
  __int64 v20; // x21
  unsigned int v21; // w8
  unsigned __int8 *v22; // x25
  unsigned __int8 *v23; // x21
  unsigned __int8 *v24; // x24
  unsigned __int64 v25; // x20
  unsigned __int64 v26; // x1
  __int64 v27; // x3
  char v28; // w8
  unsigned int v29; // w8
  unsigned __int8 *v30; // x28
  unsigned __int8 *v31; // x26
  unsigned __int8 *v32; // x27
  unsigned __int64 v33; // x25
  unsigned __int64 v34; // x1
  __int64 v35; // x3
  char v36; // w8
  unsigned __int8 *v37; // x10
  unsigned __int64 v38; // x9
  char *v39; // x8
  unsigned __int8 *v40; // x12
  _OWORD *v41; // x10
  unsigned __int64 v42; // x13
  __int128 v43; // q0
  __int128 v44; // q1
  char v45; // t1
  unsigned __int8 *v46; // x8
  unsigned __int8 *v47; // x10
  unsigned __int64 v48; // x9
  char *v49; // x8
  unsigned __int8 *v50; // x12
  _OWORD *v51; // x10
  unsigned __int64 v52; // x13
  __int128 v53; // q0
  __int128 v54; // q1
  char v55; // t1

  v4 = *a1;
  v5 = (v4 & 1) == 0;
  if ( (v4 & 1) != 0 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v4 >> 1;
  if ( v5 )
    v7 = a1 + 1;
  else
    v7 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( !v6 )
  {
    v11 = 0LL;
    v8 = 0LL;
    goto LABEL_29;
  }
  v8 = 0LL;
  while ( 1 )
  {
    v9 = v7[v8];
    if ( v9 != 32 && v9 != 9 )
      break;
    if ( v6 == ++v8 )
    {
      v11 = v6;
      v8 = v6;
      goto LABEL_29;
    }
  }
  if ( v6 <= v8 )
  {
    v11 = v6;
    if ( v6 < v8 )
      goto LABEL_37;
    goto LABEL_29;
  }
  v11 = v6;
  while ( 1 )
  {
    v12 = v7[v11 - 1];
    if ( v12 != 32 && v12 != 9 )
      break;
    if ( --v11 <= v8 )
    {
      v11 = v8;
      break;
    }
  }
  if ( v6 >= v8 )
  {
LABEL_29:
    v14 = &v7[v8];
    v15 = (unsigned __int16 *)&v7[v6];
    v16 = v6 - v8;
    if ( v16 >= 3 )
    {
      do
      {
        v17 = (unsigned __int16 *)memchr(v14, 58, v16 - 2);
        if ( !v17 )
          break;
        if ( !(*v17 ^ 0x2F3A | *((unsigned __int8 *)v17 + 2) ^ 0x2F) )
        {
          if ( v17 != v15 && (char *)v17 - (char *)v7 != -1 )
          {
            v18 = (char *)v17 - (char *)v7 + 3;
            goto LABEL_38;
          }
          break;
        }
        v14 = (unsigned __int8 *)v17 + 1;
        v16 = (char *)v15 - (char *)v14;
      }
      while ( (char *)v15 - (char *)v14 >= 3 );
    }
  }
LABEL_37:
  v18 = v8;
LABEL_38:
  result = sub_67D2D94(a1, 0x2Fu, v18);
  if ( result == -1 )
  {
    v21 = *(unsigned __int8 *)a2;
    if ( (*a1 & 1) != 0 )
      v22 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    else
      v22 = a1 + 1;
    v23 = &v22[v8];
    v24 = &v22[v11];
    v25 = v11 - v8;
    if ( (v21 & 1) != 0 )
      v26 = (*a2 & 0xFFFFFFFFFFFFFFFELL) - 1;
    else
      v26 = 22LL;
    if ( v25 <= v26 )
    {
      v28 = *a2;
    }
    else
    {
      if ( (v21 & 1) != 0 )
        v27 = a2[1];
      else
        v27 = v21 >> 1;
      result = sub_67D29A8(a2, v26, v25 - v26, v27, 0LL, v27, 0LL);
      v28 = *(_BYTE *)a2;
    }
    if ( (v28 & 1) != 0 )
      v47 = (unsigned __int8 *)a2[2];
    else
      v47 = (unsigned __int8 *)a2 + 1;
    v48 = v11 - v8;
    if ( v11 == v8 )
    {
      v49 = (char *)v47;
    }
    else
    {
      if ( v48 < 0x20 || v47 < v24 && v23 < &v47[v48] )
        goto LABEL_97;
      v49 = (char *)&v47[v48 & 0xFFFFFFFFFFFFFFE0LL];
      v23 += v48 & 0xFFFFFFFFFFFFFFE0LL;
      v50 = &v22[v8 + 16];
      v51 = v47 + 16;
      v52 = v48 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v53 = *((_OWORD *)v50 - 1);
        v54 = *(_OWORD *)v50;
        v50 += 32;
        v52 -= 32LL;
        *(v51 - 1) = v53;
        *v51 = v54;
        v51 += 2;
      }
      while ( v52 );
      v47 = (unsigned __int8 *)v49;
      if ( v48 != (v48 & 0xFFFFFFFFFFFFFFE0LL) )
      {
LABEL_97:
        v49 = (char *)v47;
        do
        {
          v55 = *v23++;
          *v49++ = v55;
        }
        while ( v23 != v24 );
      }
    }
    *v49 = 0;
    if ( (*(_BYTE *)a2 & 1) != 0 )
      a2[1] = v25;
    else
      *(_BYTE *)a2 = 2 * v25;
  }
  else
  {
    v20 = result;
    if ( (*(_BYTE *)a2 & 1) != 0 )
    {
      *(_BYTE *)a2[2] = 0;
      a2[1] = 0LL;
    }
    else
    {
      *(_WORD *)a2 = 0;
    }
    sub_658A084(a2, v11 - v8 + 48);
    v29 = *(unsigned __int8 *)a2;
    if ( (*a1 & 1) != 0 )
      v30 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    else
      v30 = a1 + 1;
    v31 = &v30[v8];
    v32 = &v30[v20];
    v33 = v20 - v8;
    if ( (v29 & 1) != 0 )
      v34 = (*a2 & 0xFFFFFFFFFFFFFFFELL) - 1;
    else
      v34 = 22LL;
    if ( v33 <= v34 )
    {
      v36 = *a2;
    }
    else
    {
      if ( (v29 & 1) != 0 )
        v35 = a2[1];
      else
        v35 = v29 >> 1;
      sub_67D29A8(a2, v34, v33 - v34, v35, 0LL, v35, 0LL);
      v36 = *(_BYTE *)a2;
    }
    if ( (v36 & 1) != 0 )
      v37 = (unsigned __int8 *)a2[2];
    else
      v37 = (unsigned __int8 *)a2 + 1;
    v38 = v20 - v8;
    if ( v20 == v8 )
    {
      v39 = (char *)v37;
    }
    else
    {
      if ( v38 < 0x20 || v37 < v32 && v31 < &v37[v38] )
        goto LABEL_76;
      v39 = (char *)&v37[v38 & 0xFFFFFFFFFFFFFFE0LL];
      v31 += v38 & 0xFFFFFFFFFFFFFFE0LL;
      v40 = &v30[v8 + 16];
      v41 = v37 + 16;
      v42 = v38 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v43 = *((_OWORD *)v40 - 1);
        v44 = *(_OWORD *)v40;
        v40 += 32;
        v42 -= 32LL;
        *(v41 - 1) = v43;
        *v41 = v44;
        v41 += 2;
      }
      while ( v42 );
      v37 = (unsigned __int8 *)v39;
      if ( v38 != (v38 & 0xFFFFFFFFFFFFFFE0LL) )
      {
LABEL_76:
        v39 = (char *)v37;
        do
        {
          v45 = *v31++;
          *v39++ = v45;
        }
        while ( v31 != v32 );
      }
    }
    *v39 = 0;
    if ( (*(_BYTE *)a2 & 1) != 0 )
      a2[1] = v33;
    else
      *(_BYTE *)a2 = 2 * v33;
    if ( (*a1 & 1) != 0 )
      v46 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    else
      v46 = a1 + 1;
    return sub_6259DFC(a2, &v46[v20], v11 - v20);
  }
  return result;
}


================================================================================
Function: sub_6256654 (0x6256654)
================================================================================

unsigned __int64 *__usercall sub_6256654@<X0>(__int64 a1@<X0>, unsigned __int64 *a2@<X8>)
{
  return sub_67D2788(a2, (__int128 *)(a1 + 232));
}


================================================================================
Function: sub_62566A8 (0x62566A8)
================================================================================

__int64 __fastcall sub_62566A8(int a1)
{
  return sub_6588260(a1 + 280, "POST", 4uLL);
}


================================================================================
Function: sub_62569C0 (0x62569C0)
================================================================================

__int64 __fastcall sub_62569C0(__int64 a1)
{
  return sub_6237CE4(*(_QWORD *)(*(_QWORD *)(a1 + 848) + 48LL), a1, 0.0);
}


================================================================================
Function: sub_6256A9C (0x6256A9C)
================================================================================

__int64 __fastcall sub_6256A9C(__int64 a1, unsigned int a2)
{
  if ( *(_DWORD *)(a1 + 464) == 6 )
    return 1LL;
  else
    return sub_6238278(*(_QWORD *)(*(_QWORD *)(a1 + 848) + 48LL), a1, a2);
}


================================================================================
Function: sub_6256B04 (0x6256B04)
================================================================================

__int64 __fastcall sub_6256B04(__int64 a1, unsigned __int64 a2, unsigned __int8 *a3)
{
  __int64 result; // x0
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x10
  bool v10; // zf
  __int64 v11; // x8
  unsigned __int64 v12; // x23
  unsigned int v13; // w9
  unsigned __int8 *v14; // x10
  unsigned int v15; // w9
  unsigned __int64 v16; // x8
  unsigned int v17; // w0
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x8
  unsigned int v20; // w20
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x9
  unsigned __int8 *v23; // x8
  __int128 v24; // [xsp+0h] [xbp-80h] BYREF
  __int128 v25; // [xsp+10h] [xbp-70h]
  __int128 v26; // [xsp+20h] [xbp-60h]
  __int128 v27; // [xsp+30h] [xbp-50h]
  __int128 v28; // [xsp+40h] [xbp-40h]
  __int128 v29; // [xsp+50h] [xbp-30h]
  __int128 v30; // [xsp+60h] [xbp-20h]

  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v24 = 0u;
  result = ((__int64 (__fastcall *)(__int128 *, __int64, __int64, __int64, __int64, _QWORD, const char *, __int64))sub_67689E4)(
             &v24,
             0xFFFFFFFFLL,
             8LL,
             31LL,
             8LL,
             0LL,
             "1.2.11",
             112LL);
  if ( !(_DWORD)result )
  {
    v7 = *a3;
    v8 = *((_QWORD *)a3 + 1);
    *(_QWORD *)&v24 = a1;
    v9 = v7 >> 1;
    v10 = (v7 & 1) == 0;
    v11 = a2 + 32;
    if ( v10 )
      v12 = v9;
    else
      v12 = v8;
    if ( a2 > 0x8000 )
      v11 = 0x8000LL;
    DWORD2(v24) = a2;
    sub_67D36F0(a3, v12 + v11, 0);
    while ( 1 )
    {
      v13 = *a3;
      v14 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
      v10 = (v13 & 1) == 0;
      v15 = v13 >> 1;
      v16 = *((_QWORD *)&v26 + 1) + v12;
      if ( v10 )
        v14 = a3 + 1;
      else
        v15 = *((_DWORD *)a3 + 2);
      *((_QWORD *)&v25 + 1) = &v14[v16];
      LODWORD(v26) = v15 - v16;
      v17 = sub_676932C(&v24, 4LL);
      if ( v17 )
        break;
      v18 = *a3;
      if ( (v18 & 1) != 0 )
        v19 = *((_QWORD *)a3 + 1);
      else
        v19 = v18 >> 1;
      sub_67D36F0(a3, v19 + 0x8000, 0);
    }
    v20 = v17;
    if ( v17 == 1 )
    {
      sub_67D36F0(a3, *((_QWORD *)&v26 + 1) + v12, 0);
      v20 = 0;
    }
    LODWORD(result) = sub_6768C84(&v24);
    if ( v20 | (unsigned int)result )
    {
      if ( v20 )
        return v20;
      else
        return (unsigned int)result;
    }
    else
    {
      v21 = *a3;
      v22 = *((_QWORD *)a3 + 1);
      if ( (v21 & 1) == 0 )
        v22 = v21 >> 1;
      if ( v22 >= v12 + 10 )
      {
        result = 0LL;
        if ( (v21 & 1) != 0 )
          v23 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
        else
          v23 = a3 + 1;
        v23[v12 + 9] = -1;
      }
      else
      {
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6256DF0 (0x6256DF0)
================================================================================

__int64 __fastcall sub_6256DF0(__int64 a1, unsigned __int8 *a2, char a3)
{
  size_t v3; // x10
  unsigned __int64 v5; // x8
  bool v6; // zf
  size_t v7; // x8
  void *v8; // x1
  size_t v9; // x2
  unsigned __int64 v11; // x8
  size_t v12; // x8
  __int64 result; // x0
  void *src; // [xsp+0h] [xbp-40h] BYREF
  size_t n; // [xsp+8h] [xbp-38h]
  _QWORD v16[5]; // [xsp+10h] [xbp-30h] BYREF

  v3 = *((_QWORD *)a2 + 1);
  v5 = *a2;
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
    v8 = a2 + 1;
  else
    v8 = (void *)*((_QWORD *)a2 + 2);
  if ( v6 )
    v9 = v7;
  else
    v9 = v3;
  src = v8;
  n = v9;
  if ( (a3 & 1) == 0 )
    goto LABEL_21;
  if ( !byte_71CF7B0 || !byte_71CF760 )
  {
    if ( !(_BYTE)qword_6F78AA8 )
      goto LABEL_15;
    goto LABEL_14;
  }
  if ( (unsigned __int8)qword_6F78AA8 >= 6u && (qword_6F78AA8 & 0xFC00) != 0 )
  {
LABEL_14:
    v16[0] = a1;
    v16[1] = 0LL;
    v16[2] = &src;
    v16[3] = sub_254D2B0;
    sub_654E8B4(
      qword_6F78AA8,
      qword_6F78AB0,
      4u,
      (__int64)"[DFLog::DebugHttpTrace] HttpRequestCurl({}): Uncompressed post data: {}",
      71LL,
      254LL,
      (__int64)v16,
      1);
    v8 = src;
    v9 = n;
  }
LABEL_15:
  if ( (unsigned int)sub_6256B04(v8, v9, a1 + 304) )
  {
    v9 = n;
  }
  else
  {
    v11 = *(unsigned __int8 *)(a1 + 304);
    v9 = n;
    if ( (v11 & 1) != 0 )
      v12 = *(_QWORD *)(a1 + 312);
    else
      v12 = v11 >> 1;
    if ( v12 <= n )
    {
      result = sub_62556A4(a1, "Content-Encoding", 0x10uLL, "gzip", 4uLL);
      *(_BYTE *)(a1 + 410) = 1;
      goto LABEL_22;
    }
  }
LABEL_21:
  result = sub_6588260((int)a1 + 304, src, v9);
LABEL_22:
  *(_BYTE *)(a1 + 409) = 1;
  return result;
}


================================================================================
Function: sub_62596C0 (0x62596C0)
================================================================================

__int64 __fastcall sub_62596C0(__int64 a1)
{
  __int64 v2; // x0

  v2 = sub_622C968();
  return sub_259D768(v2, a1);
}


================================================================================
Function: sub_6259DFC (0x6259DFC)
================================================================================

unsigned __int64 *__fastcall sub_6259DFC(unsigned __int64 *result, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v4; // x19
  unsigned __int64 *v5; // x20
  unsigned __int64 v6; // x23
  unsigned __int64 v7; // x8
  unsigned __int8 *v8; // x9
  int v9; // t1
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x1
  char v13; // w9
  char s[4]; // [xsp+4h] [xbp-Ch] BYREF

  v4 = a2;
  v5 = result;
  v6 = (unsigned __int64)&a2[a3];
  v7 = a3;
  strcpy(s, "%00");
  if ( a3 > 4096 )
  {
    v8 = a2;
    v7 = a3;
    do
    {
      v9 = *v8++;
      if ( (unsigned int)(v9 - 127) < 0xFFFFFFA2 )
        v7 += 2LL;
    }
    while ( (unsigned __int64)v8 < v6 );
  }
  v10 = *(unsigned __int8 *)result;
  if ( (v10 & 1) != 0 )
    v11 = result[1];
  else
    v11 = v10 >> 1;
  if ( v7 < ~v11 )
  {
    result = sub_658A084(result, v11 + v7);
    if ( a3 >= 1 )
    {
      do
      {
        v12 = *v4;
        if ( (unsigned __int8)(v12 - 127) > 0xA1u )
        {
          result = sub_6589DEC(v5, v12);
        }
        else
        {
          v13 = a0123456789abcd[v12 & 0xF];
          s[1] = a0123456789abcd[v12 >> 4];
          s[2] = v13;
          result = sub_67D352C(v5, s);
        }
        ++v4;
      }
      while ( (unsigned __int64)v4 < v6 );
    }
  }
  return result;
}


================================================================================
Function: sub_625B0E0 (0x625B0E0)
================================================================================

void __fastcall __noreturn sub_625B0E0(_QWORD *a1)
{
  __int64 v2; // x8
  _QWORD *v3; // [xsp+8h] [xbp-28h]

  v3 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)*a1 + 16LL))(*a1, 944LL, 16LL);
  v2 = *a1;
  v3[1] = 0LL;
  v3[2] = 0LL;
  v3[4] = v2;
  *v3 = off_6BA4DC0;
  sub_625CE88(v3 + 6);
}


================================================================================
Function: sub_625B3D0 (0x625B3D0)
================================================================================

__int64 __usercall sub_625B3D0@<X0>(unsigned __int64 *a1@<X0>, int *a2@<X1>, _QWORD *a3@<X8>)
{
  unsigned __int64 *v6; // x19
  unsigned __int64 v7; // x8
  unsigned __int64 *v8; // x20
  __int64 result; // x0
  unsigned __int64 *v10; // x22

  v6 = (unsigned __int64 *)(*(__int64 (__fastcall **)(unsigned __int64, __int64, __int64))(*(_QWORD *)*a1 + 16LL))(
                             *a1,
                             1280LL,
                             16LL);
  v7 = *a1;
  v6[1] = 0LL;
  v6[2] = 0LL;
  v8 = v6 + 6;
  v6[4] = v7;
  *v6 = (unsigned __int64)off_6BA4E60;
  result = sub_627CB6C((__int64)(v6 + 6), *a2);
  v10 = (unsigned __int64 *)v6[8];
  *a3 = v6 + 6;
  a3[1] = v6;
  if ( v10 )
  {
    if ( v10[1] != -1LL )
      return result;
    sub_67F0410(1uLL, (atomic_ullong *)(v6 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v6 + 2));
    v6[7] = (unsigned __int64)v8;
    v6[8] = (unsigned __int64)v6;
    sub_67D18A4(v10);
  }
  else
  {
    sub_67F0410(1uLL, (atomic_ullong *)(v6 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v6 + 2));
    v6[7] = (unsigned __int64)v8;
    v6[8] = (unsigned __int64)v6;
  }
  result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v6 + 1));
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v6 + 16))(v6);
    return sub_67D18A4(v6);
  }
  return result;
}


================================================================================
Function: sub_625CE00 (0x625CE00)
================================================================================

_QWORD *__usercall sub_625CE00@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *result; // x0

  result = (_QWORD *)sub_6575418();
  *a1 = result;
  *result = off_6BA5168;
  return result;
}


================================================================================
Function: sub_625CE80 (0x625CE80)
================================================================================

__int64 sub_625CE80()
{
  return 0LL;
}


================================================================================
Function: sub_625CE88 (0x625CE88)
================================================================================

void __fastcall __noreturn sub_625CE88(_QWORD *a1)
{
  sub_6255394();
  a1[109] = 0LL;
  *a1 = off_6BA51C0;
  sub_6579C34("IXMLHTTPRequest2 is not available");
}


================================================================================
Function: sub_625F5C8 (0x625F5C8)
================================================================================

__int64 __fastcall sub_625F5C8(__int64 a1)
{
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 40) = a1 + 48;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  sub_259B1A8(a1 + 88);
  *(_BYTE *)(a1 + 400) = 0;
  return sub_625F678(a1);
}


================================================================================
Function: sub_625F678 (0x625F678)
================================================================================

_QWORD *__fastcall sub_625F678(__int64 a1)
{
  __int64 **v2; // x22
  __int64 v3; // x24
  __int64 *v4; // x20
  int v5; // w8
  __int64 v6; // x1
  __int64 v7; // x9
  __int64 v8; // x10
  __int64 v9; // x8
  unsigned __int64 *v10; // x20
  _QWORD *result; // x0
  __int64 *v12; // x8
  __int64 *v13; // x20
  int v14; // w9
  __int64 *v15; // x9
  __int64 v16; // x1
  __int64 v17; // x9
  __int64 v18; // x10
  __int64 v19; // x8
  unsigned __int64 *v20; // x19
  const char *v21; // [xsp+8h] [xbp-28h] BYREF
  __int64 v22; // [xsp+10h] [xbp-20h]
  __int64 v23; // [xsp+18h] [xbp-18h] BYREF
  __int64 v24; // [xsp+20h] [xbp-10h]

  v21 = "exponential";
  v22 = 11LL;
  sub_62668A8(&v23, &v21, 0xFFFFFFFFLL, -1.0);
  v2 = (__int64 **)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 48);
  if ( v3 )
  {
    v4 = (__int64 *)(a1 + 48);
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(v3 + 32);
        if ( v5 >= 430 )
          break;
        if ( v5 == 429 )
          goto LABEL_10;
        v4 = (__int64 *)(v3 + 8);
        if ( !*(_QWORD *)(v3 + 8) )
          goto LABEL_10;
        v3 = *(_QWORD *)(v3 + 8);
      }
      if ( !*(_QWORD *)v3 )
        break;
      v4 = (__int64 *)v3;
      v3 = *(_QWORD *)v3;
    }
    v4 = (__int64 *)v3;
    goto LABEL_11;
  }
  v3 = a1 + 48;
  v4 = (__int64 *)(a1 + 48);
LABEL_10:
  if ( !*v4 )
  {
LABEL_11:
    v6 = sub_6575418();
    v7 = v23;
    v8 = v24;
    v23 = 0LL;
    v24 = 0LL;
    *(_QWORD *)v6 = 0LL;
    *(_QWORD *)(v6 + 8) = 0LL;
    *(_QWORD *)(v6 + 16) = v3;
    *(_DWORD *)(v6 + 32) = 429;
    *(_QWORD *)(v6 + 40) = v7;
    *(_QWORD *)(v6 + 48) = v8;
    *v4 = v6;
    v9 = **(_QWORD **)(a1 + 40);
    if ( v9 )
    {
      *(_QWORD *)(a1 + 40) = v9;
      v6 = *v4;
    }
    sub_2507ED0(*(_QWORD *)(a1 + 48), v6);
    ++*(_QWORD *)(a1 + 56);
  }
  v10 = (unsigned __int64 *)v24;
  if ( v24 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8)) )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v10 + 16))(v10);
    sub_67D18A4(v10);
  }
  v21 = "exponential";
  v22 = 11LL;
  result = sub_62668A8(&v23, &v21, 0xFFFFFFFFLL, -1.0);
  v12 = *v2;
  if ( *v2 )
  {
    v13 = (__int64 *)(a1 + 48);
    while ( 1 )
    {
      v14 = *((_DWORD *)v12 + 8);
      if ( v14 < 504 )
      {
        if ( v14 == 503 || (v13 = v12 + 1, (v15 = (__int64 *)v12[1]) == 0LL) )
        {
          v2 = (__int64 **)v12;
          if ( *v13 )
            goto LABEL_33;
          goto LABEL_30;
        }
      }
      else
      {
        v15 = (__int64 *)*v12;
        if ( !*v12 )
        {
          v2 = (__int64 **)v12;
          v13 = v12;
          goto LABEL_30;
        }
        v13 = v12;
      }
      v12 = v15;
    }
  }
  v13 = (__int64 *)(a1 + 48);
LABEL_30:
  v16 = sub_6575418();
  v17 = v23;
  v18 = v24;
  v23 = 0LL;
  v24 = 0LL;
  *(_QWORD *)v16 = 0LL;
  *(_QWORD *)(v16 + 8) = 0LL;
  *(_QWORD *)(v16 + 16) = v2;
  *(_DWORD *)(v16 + 32) = 503;
  *(_QWORD *)(v16 + 40) = v17;
  *(_QWORD *)(v16 + 48) = v18;
  *v13 = v16;
  v19 = **(_QWORD **)(a1 + 40);
  if ( v19 )
  {
    *(_QWORD *)(a1 + 40) = v19;
    v16 = *v13;
  }
  result = (_QWORD *)sub_2507ED0(*(_QWORD *)(a1 + 48), v16);
  ++*(_QWORD *)(a1 + 56);
LABEL_33:
  v20 = (unsigned __int64 *)v24;
  if ( v24 )
  {
    result = (_QWORD *)sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v20 + 16))(v20);
      return (_QWORD *)sub_67D18A4(v20);
    }
  }
  return result;
}


================================================================================
Function: sub_6261B0C (0x6261B0C)
================================================================================

_QWORD *__fastcall sub_6261B0C(__int64 a1)
{
  unsigned int v2; // w1
  _QWORD v4[7]; // [xsp+0h] [xbp-40h] BYREF

  *(_QWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  sub_625F5C8(a1 + 32);
  v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 440), 0LL);
  if ( v2 )
  {
    sub_25A21C8(v4, v2, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v4);
  }
  return sub_642AE70((_QWORD *)(a1 + 480));
}


================================================================================
Function: sub_62668A8 (0x62668A8)
================================================================================

_QWORD *__usercall sub_62668A8@<X0>(__int64 a1@<X0>, int a2@<W1>, unsigned __int64 *a3@<X8>, double a4@<D0>)
{
  _QWORD *v6; // x0
  __int64 v7; // x2
  _QWORD *result; // x0
  size_t v10; // x9
  size_t v11; // x21
  __int64 v12; // x22
  __int64 v13; // x23
  _QWORD *v14; // x20
  char *v15; // x24
  size_t v16; // x9
  unsigned __int64 v17; // [xsp+0h] [xbp-30h] BYREF
  size_t v18; // [xsp+8h] [xbp-28h]
  char *v19; // [xsp+10h] [xbp-20h]
  int v20; // [xsp+1Ch] [xbp-14h] BYREF
  double v21; // [xsp+20h] [xbp-10h] BYREF

  v6 = *(_QWORD **)a1;
  v7 = *(_QWORD *)(a1 + 8);
  v21 = a4;
  v20 = a2;
  *a3 = 0LL;
  a3[1] = 0LL;
  if ( v7 == 6 )
  {
    if ( !memcmp(v6, "linear", 6uLL) )
    {
      result = sub_6266CD0(&v17, &v21, &v20);
      goto LABEL_21;
    }
  }
  else if ( v7 == 11 && !(*v6 ^ 0x746E656E6F707865LL | *(_QWORD *)((char *)v6 + 3) ^ 0x6C6169746E656E6FLL) )
  {
    result = sub_6266B00(&v17, &v21, &v20);
LABEL_21:
    v16 = v18;
    *a3 = v17;
    a3[1] = v16;
    return result;
  }
  result = sub_6266EA0(&v17);
  v10 = v18;
  v11 = *(_QWORD *)(a1 + 8);
  *a3 = v17;
  a3[1] = v10;
  if ( v11 != 4 || **(_DWORD **)a1 != 1701736302 )
  {
    v12 = qword_71CF660;
    v13 = qword_71CF668;
    if ( byte_71CF7B0 && byte_71CF760 )
    {
      if ( (unsigned __int8)qword_71CF660 < 6u || BYTE1(qword_71CF660) < 3u )
        return result;
    }
    else if ( !(_BYTE)qword_71CF660 )
    {
      return result;
    }
    v14 = *(_QWORD **)a1;
    if ( !v14 )
    {
      v17 = 0LL;
      v18 = 0LL;
      v19 = 0LL;
      goto LABEL_25;
    }
    if ( v11 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_67D2618();
    if ( v11 >= 0x17 )
    {
      v15 = (char *)sub_6575418();
      v18 = v11;
      v19 = v15;
      v17 = (v11 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v15 = (char *)&v17 + 1;
      LOBYTE(v17) = 2 * v11;
      if ( !v11 )
        goto LABEL_24;
    }
    memcpy(v15, v14, v11);
LABEL_24:
    v15[v11] = 0;
LABEL_25:
    result = (_QWORD *)sub_654ED80(
                         v12,
                         v13,
                         "[FLog::Error] RetryPolicyOverrides: Unknown retry strategy '%s'",
                         (const char *)&v17);
    if ( (v17 & 1) != 0 )
      return (_QWORD *)sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_6266B00 (0x6266B00)
================================================================================

unsigned __int64 __usercall sub_6266B00@<X0>(__int64 *a1@<X0>, _DWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  bool v6; // zf
  __int64 v7; // x0
  __int64 v8; // d0
  unsigned __int64 *v9; // x19
  atomic_ullong *v10; // x20
  __int64 v11; // x8
  __int64 v12; // x0
  unsigned __int64 result; // x0
  unsigned __int64 *v14; // x24
  unsigned __int64 *v15; // x22
  _QWORD v16[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v17; // [xsp+20h] [xbp-20h]

  if ( byte_71CF7B0 )
    v6 = byte_7286120 == 0;
  else
    v6 = 1;
  if ( !v6 )
  {
    v12 = sub_678E980();
    return sub_626738C(v12, a1, a2);
  }
  v7 = sub_6575418();
  v8 = *a1;
  v9 = (unsigned __int64 *)v7;
  *(_DWORD *)(v7 + 56) = *a2;
  *(_QWORD *)(v7 + 16) = 0LL;
  *(_QWORD *)v7 = off_6BA5530;
  *(_QWORD *)(v7 + 40) = 0LL;
  *(_QWORD *)(v7 + 48) = v8;
  *(_QWORD *)(v7 + 96) = 0LL;
  *(_QWORD *)(v7 + 8) = 0LL;
  v10 = (atomic_ullong *)(v7 + 8);
  *(_QWORD *)(v7 + 32) = 0LL;
  v16[0] = off_6BA53E0;
  v16[1] = v7 + 32;
  v17 = v16;
  sub_62670E0(v16, v7 + 64);
  result = (unsigned __int64)v17;
  if ( v16 == v17 )
  {
    v11 = 4LL;
  }
  else
  {
    if ( !v17 )
      goto LABEL_11;
    v11 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v17 + 8 * v11))();
LABEL_11:
  v14 = v9 + 4;
  v15 = (unsigned __int64 *)v9[5];
  *a3 = v9 + 4;
  a3[1] = v9;
  if ( v15 )
  {
    if ( v15[1] != -1LL )
      return result;
    sub_67F0410(1uLL, (atomic_ullong *)(v9 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v9 + 2));
    v9[4] = (unsigned __int64)v14;
    v9[5] = (unsigned __int64)v9;
    sub_67D18A4(v15);
  }
  else
  {
    sub_67F0410(1uLL, (atomic_ullong *)(v9 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v9 + 2));
    v9[4] = (unsigned __int64)v14;
    v9[5] = (unsigned __int64)v9;
  }
  result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, v10);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v9 + 16))(v9);
    return sub_67D18A4(v9);
  }
  return result;
}


================================================================================
Function: sub_6266CD0 (0x6266CD0)
================================================================================

unsigned __int64 __usercall sub_6266CD0@<X0>(__int64 *a1@<X0>, _DWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  bool v6; // zf
  __int64 v7; // x0
  __int64 v8; // d0
  unsigned __int64 *v9; // x19
  atomic_ullong *v10; // x20
  __int64 v11; // x8
  __int64 v12; // x0
  unsigned __int64 result; // x0
  unsigned __int64 *v14; // x24
  unsigned __int64 *v15; // x22
  _QWORD v16[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v17; // [xsp+20h] [xbp-20h]

  if ( byte_71CF7B0 )
    v6 = byte_7286120 == 0;
  else
    v6 = 1;
  if ( !v6 )
  {
    v12 = sub_678E980();
    return sub_62677A4(v12, a1, a2);
  }
  v7 = sub_6575418();
  v8 = *a1;
  v9 = (unsigned __int64 *)v7;
  *(_DWORD *)(v7 + 56) = *a2;
  *(_QWORD *)(v7 + 16) = 0LL;
  *(_QWORD *)v7 = off_6BA55D0;
  *(_QWORD *)(v7 + 40) = 0LL;
  *(_QWORD *)(v7 + 48) = v8;
  *(_QWORD *)(v7 + 96) = 0LL;
  *(_QWORD *)(v7 + 8) = 0LL;
  v10 = (atomic_ullong *)(v7 + 8);
  *(_QWORD *)(v7 + 32) = 0LL;
  v16[0] = off_6BA5350;
  v16[1] = v7 + 32;
  v17 = v16;
  sub_62670E0(v16, v7 + 64);
  result = (unsigned __int64)v17;
  if ( v16 == v17 )
  {
    v11 = 4LL;
  }
  else
  {
    if ( !v17 )
      goto LABEL_11;
    v11 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v17 + 8 * v11))();
LABEL_11:
  v14 = v9 + 4;
  v15 = (unsigned __int64 *)v9[5];
  *a3 = v9 + 4;
  a3[1] = v9;
  if ( v15 )
  {
    if ( v15[1] != -1LL )
      return result;
    sub_67F0410(1uLL, (atomic_ullong *)(v9 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v9 + 2));
    v9[4] = (unsigned __int64)v14;
    v9[5] = (unsigned __int64)v9;
    sub_67D18A4(v15);
  }
  else
  {
    sub_67F0410(1uLL, (atomic_ullong *)(v9 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v9 + 2));
    v9[4] = (unsigned __int64)v14;
    v9[5] = (unsigned __int64)v9;
  }
  result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, v10);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v9 + 16))(v9);
    return sub_67D18A4(v9);
  }
  return result;
}


================================================================================
Function: sub_6266EA0 (0x6266EA0)
================================================================================

unsigned __int64 __usercall sub_6266EA0@<X0>(_QWORD *a1@<X8>)
{
  bool v2; // zf
  unsigned __int64 *v3; // x19
  __int64 v4; // x8
  unsigned __int64 result; // x0
  unsigned __int64 *v6; // x24
  unsigned __int64 *v7; // x22
  _QWORD v8[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v9; // [xsp+20h] [xbp-20h]

  if ( byte_71CF7B0 )
    v2 = byte_7286120 == 0;
  else
    v2 = 1;
  if ( !v2 )
  {
    v8[0] = sub_678E980();
    return sub_6267BBC(v8);
  }
  v3 = (unsigned __int64 *)sub_6575418();
  v3[2] = 0LL;
  v3[6] = 0xBFF0000000000000LL;
  *v3 = (unsigned __int64)off_6BA5670;
  v3[4] = 0LL;
  v3[5] = 0LL;
  *((_DWORD *)v3 + 14) = 0;
  v3[12] = 0LL;
  v3[1] = 0LL;
  v8[0] = off_6BA5460;
  v9 = v8;
  sub_62670E0(v8, v3 + 8);
  result = (unsigned __int64)v9;
  if ( v8 == v9 )
  {
    v4 = 4LL;
  }
  else
  {
    if ( !v9 )
      goto LABEL_11;
    v4 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v9 + 8 * v4))();
LABEL_11:
  v6 = v3 + 4;
  v7 = (unsigned __int64 *)v3[5];
  *a1 = v3 + 4;
  a1[1] = v3;
  if ( v7 )
  {
    if ( v7[1] != -1LL )
      return result;
    sub_67F0410(1uLL, (atomic_ullong *)(v3 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v3 + 2));
    v3[4] = (unsigned __int64)v6;
    v3[5] = (unsigned __int64)v3;
    sub_67D18A4(v7);
  }
  else
  {
    sub_67F0410(1uLL, (atomic_ullong *)(v3 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v3 + 2));
    v3[4] = (unsigned __int64)v6;
    v3[5] = (unsigned __int64)v3;
  }
  result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v3 + 1));
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v3 + 16))(v3);
    return sub_67D18A4(v3);
  }
  return result;
}


================================================================================
Function: sub_62670E0 (0x62670E0)
================================================================================

_QWORD *__fastcall sub_62670E0(_QWORD *result, __int64 a2)
{
  _QWORD *v2; // x20
  __int64 v4; // x8
  __int64 v5; // x8
  _QWORD v6[5]; // [xsp+0h] [xbp-30h] BYREF

  if ( (_QWORD *)a2 != result )
  {
    v2 = result;
    result = (_QWORD *)result[4];
    if ( result == v2 )
    {
      if ( *(_QWORD *)(a2 + 32) == a2 )
      {
        (*(void (__fastcall **)(_QWORD *, _QWORD *))(*result + 24LL))(result, v6);
        (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v2[4] + 32LL))(v2[4]);
        v2[4] = 0LL;
        (*(void (__fastcall **)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 32) + 24LL))(*(_QWORD *)(a2 + 32), v2);
        (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 32) + 32LL))(*(_QWORD *)(a2 + 32));
        v5 = v6[0];
        *(_QWORD *)(a2 + 32) = 0LL;
        v2[4] = v2;
        (*(void (__fastcall **)(_QWORD *, __int64))(v5 + 24))(v6, a2);
        result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD *))(v6[0] + 32LL))(v6);
      }
      else
      {
        (*(void (__fastcall **)(_QWORD *, __int64))(*result + 24LL))(result, a2);
        result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v2[4] + 32LL))(v2[4]);
        v2[4] = *(_QWORD *)(a2 + 32);
      }
      *(_QWORD *)(a2 + 32) = a2;
    }
    else
    {
      v4 = *(_QWORD *)(a2 + 32);
      if ( a2 == v4 )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)v4 + 24LL))(*(_QWORD *)(a2 + 32), v2);
        result = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a2 + 32) + 32LL))(*(_QWORD *)(a2 + 32));
        *(_QWORD *)(a2 + 32) = v2[4];
        v2[4] = v2;
      }
      else
      {
        v2[4] = v4;
        *(_QWORD *)(a2 + 32) = result;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_626738C (0x626738C)
================================================================================

unsigned __int64 __usercall sub_626738C@<X0>(__int64 a1@<X0>, __int64 *a2@<X1>, int *a3@<X2>, __int64 *a4@<X8>)
{
  __int64 v8; // x0
  atomic_ullong *v9; // x20
  unsigned __int64 *v10; // x19
  __int64 v11; // d0
  int v12; // w8
  __int64 v13; // x24
  unsigned __int64 result; // x0
  __int64 v15; // x8
  unsigned __int64 *v16; // x22
  _QWORD v17[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v18; // [xsp+20h] [xbp-20h]

  v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 16LL))(a1, 128LL, 16LL);
  *(_QWORD *)(v8 + 16) = 0LL;
  *(_QWORD *)(v8 + 32) = a1;
  *(_QWORD *)(v8 + 8) = 0LL;
  v9 = (atomic_ullong *)(v8 + 8);
  *(_QWORD *)v8 = off_6BA54E0;
  v10 = (unsigned __int64 *)v8;
  v11 = *a2;
  v12 = *a3;
  *(_QWORD *)(v8 + 56) = 0LL;
  *(_QWORD *)(v8 + 112) = 0LL;
  *(_QWORD *)(v8 + 64) = v11;
  *(_DWORD *)(v8 + 72) = v12;
  *(_QWORD *)(v8 + 48) = 0LL;
  v13 = v8 + 48;
  v17[0] = off_6BA53E0;
  v17[1] = v8 + 48;
  v18 = v17;
  sub_62670E0(v17, v8 + 80);
  result = (unsigned __int64)v18;
  if ( v17 == v18 )
  {
    v15 = 4LL;
  }
  else
  {
    if ( !v18 )
      goto LABEL_6;
    v15 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v18 + 8 * v15))();
LABEL_6:
  v16 = (unsigned __int64 *)v10[7];
  *a4 = v13;
  a4[1] = (__int64)v10;
  if ( v16 )
  {
    if ( v16[1] != -1LL )
      return result;
    sub_67F0410(1uLL, (atomic_ullong *)(v10 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v10 + 2));
    v10[6] = v13;
    v10[7] = (unsigned __int64)v10;
    sub_67D18A4(v16);
  }
  else
  {
    sub_67F0410(1uLL, (atomic_ullong *)(v10 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v10 + 2));
    v10[6] = v13;
    v10[7] = (unsigned __int64)v10;
  }
  result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, v9);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v10 + 16))(v10);
    return sub_67D18A4(v10);
  }
  return result;
}


================================================================================
Function: sub_62677A4 (0x62677A4)
================================================================================

unsigned __int64 __usercall sub_62677A4@<X0>(__int64 a1@<X0>, __int64 *a2@<X1>, int *a3@<X2>, __int64 *a4@<X8>)
{
  __int64 v8; // x0
  atomic_ullong *v9; // x20
  unsigned __int64 *v10; // x19
  __int64 v11; // d0
  int v12; // w8
  __int64 v13; // x24
  unsigned __int64 result; // x0
  __int64 v15; // x8
  unsigned __int64 *v16; // x22
  _QWORD v17[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v18; // [xsp+20h] [xbp-20h]

  v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 16LL))(a1, 128LL, 16LL);
  *(_QWORD *)(v8 + 16) = 0LL;
  *(_QWORD *)(v8 + 32) = a1;
  *(_QWORD *)(v8 + 8) = 0LL;
  v9 = (atomic_ullong *)(v8 + 8);
  *(_QWORD *)v8 = off_6BA5580;
  v10 = (unsigned __int64 *)v8;
  v11 = *a2;
  v12 = *a3;
  *(_QWORD *)(v8 + 56) = 0LL;
  *(_QWORD *)(v8 + 112) = 0LL;
  *(_QWORD *)(v8 + 64) = v11;
  *(_DWORD *)(v8 + 72) = v12;
  *(_QWORD *)(v8 + 48) = 0LL;
  v13 = v8 + 48;
  v17[0] = off_6BA5350;
  v17[1] = v8 + 48;
  v18 = v17;
  sub_62670E0(v17, v8 + 80);
  result = (unsigned __int64)v18;
  if ( v17 == v18 )
  {
    v15 = 4LL;
  }
  else
  {
    if ( !v18 )
      goto LABEL_6;
    v15 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v18 + 8 * v15))();
LABEL_6:
  v16 = (unsigned __int64 *)v10[7];
  *a4 = v13;
  a4[1] = (__int64)v10;
  if ( v16 )
  {
    if ( v16[1] != -1LL )
      return result;
    sub_67F0410(1uLL, (atomic_ullong *)(v10 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v10 + 2));
    v10[6] = v13;
    v10[7] = (unsigned __int64)v10;
    sub_67D18A4(v16);
  }
  else
  {
    sub_67F0410(1uLL, (atomic_ullong *)(v10 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v10 + 2));
    v10[6] = v13;
    v10[7] = (unsigned __int64)v10;
  }
  result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, v9);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v10 + 16))(v10);
    return sub_67D18A4(v10);
  }
  return result;
}


================================================================================
Function: sub_6267BBC (0x6267BBC)
================================================================================

unsigned __int64 __usercall sub_6267BBC@<X0>(_QWORD *a1@<X0>, __int64 *a2@<X8>)
{
  __int64 v4; // x0
  __int64 v5; // x8
  unsigned __int64 *v6; // x19
  atomic_ullong *v7; // x20
  __int64 v8; // x24
  unsigned __int64 result; // x0
  __int64 v10; // x8
  unsigned __int64 *v11; // x22
  _QWORD v12[4]; // [xsp+0h] [xbp-40h] BYREF
  _QWORD *v13; // [xsp+20h] [xbp-20h]

  v4 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)*a1 + 16LL))(*a1, 128LL, 16LL);
  v5 = *a1;
  v6 = (unsigned __int64 *)v4;
  *(_QWORD *)(v4 + 16) = 0LL;
  *(_QWORD *)(v4 + 32) = v5;
  *(_QWORD *)v4 = off_6BA5620;
  *(_DWORD *)(v4 + 72) = 0;
  *(_QWORD *)(v4 + 56) = 0LL;
  *(_QWORD *)(v4 + 64) = 0xBFF0000000000000LL;
  *(_QWORD *)(v4 + 112) = 0LL;
  *(_QWORD *)(v4 + 8) = 0LL;
  v7 = (atomic_ullong *)(v4 + 8);
  *(_QWORD *)(v4 + 48) = 0LL;
  v8 = v4 + 48;
  v12[0] = off_6BA5460;
  v13 = v12;
  sub_62670E0(v12, v4 + 80);
  result = (unsigned __int64)v13;
  if ( v12 == v13 )
  {
    v10 = 4LL;
  }
  else
  {
    if ( !v13 )
      goto LABEL_6;
    v10 = 5LL;
  }
  result = (*(__int64 (**)(void))(*v13 + 8 * v10))();
LABEL_6:
  v11 = (unsigned __int64 *)v6[7];
  *a2 = v8;
  a2[1] = (__int64)v6;
  if ( v11 )
  {
    if ( v11[1] != -1LL )
      return result;
    sub_67F0410(1uLL, (atomic_ullong *)(v6 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v6 + 2));
    v6[6] = v8;
    v6[7] = (unsigned __int64)v6;
    sub_67D18A4(v11);
  }
  else
  {
    sub_67F0410(1uLL, (atomic_ullong *)(v6 + 1));
    sub_67F0410(1uLL, (atomic_ullong *)(v6 + 2));
    v6[6] = v8;
    v6[7] = (unsigned __int64)v6;
  }
  result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, v7);
  if ( !result )
  {
    (*(void (__fastcall **)(unsigned __int64 *))(*v6 + 16))(v6);
    return sub_67D18A4(v6);
  }
  return result;
}


================================================================================
Function: sub_626DD14 (0x626DD14)
================================================================================

__int64 __fastcall sub_626DD14(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x19
  __int64 v4; // x20
  char v5; // t1
  __int64 v6; // x19
  __int64 v7; // x20
  char v8; // t1
  __int64 v9; // x19
  __int64 v10; // x20
  char v11; // t1
  unsigned __int64 *v12; // x19
  unsigned __int64 *v13; // x20
  char v14; // t1
  unsigned __int64 *v15; // x19
  unsigned __int64 *v16; // x20
  char v17; // t1
  unsigned __int64 *v18; // x19
  unsigned __int64 *v19; // x20
  char v20; // t1
  unsigned __int64 *v21; // [xsp+8h] [xbp-2A8h] BYREF
  unsigned __int64 *v22; // [xsp+10h] [xbp-2A0h]
  unsigned __int64 *v23; // [xsp+18h] [xbp-298h]
  int v24; // [xsp+20h] [xbp-290h]
  __int128 v25; // [xsp+28h] [xbp-288h] BYREF
  unsigned __int64 *v26; // [xsp+40h] [xbp-270h] BYREF
  unsigned __int64 *v27; // [xsp+48h] [xbp-268h]
  unsigned __int64 *v28; // [xsp+50h] [xbp-260h]
  int v29; // [xsp+58h] [xbp-258h]
  __int128 v30; // [xsp+60h] [xbp-250h] BYREF
  unsigned __int64 *v31; // [xsp+78h] [xbp-238h] BYREF
  unsigned __int64 *v32; // [xsp+80h] [xbp-230h]
  unsigned __int64 *v33; // [xsp+88h] [xbp-228h]
  int v34; // [xsp+90h] [xbp-220h]
  _BYTE v35[17]; // [xsp+98h] [xbp-218h] BYREF
  __int128 v36; // [xsp+B0h] [xbp-200h] BYREF
  char *v37; // [xsp+C0h] [xbp-1F0h]
  char v38; // [xsp+C8h] [xbp-1E8h] BYREF
  __int128 v39; // [xsp+C9h] [xbp-1E7h]
  int v40; // [xsp+D9h] [xbp-1D7h]
  char v41; // [xsp+DDh] [xbp-1D3h]
  __int128 v42; // [xsp+E0h] [xbp-1D0h] BYREF
  char *v43; // [xsp+F0h] [xbp-1C0h]
  __int128 v44; // [xsp+F8h] [xbp-1B8h] BYREF
  __int128 v45; // [xsp+110h] [xbp-1A0h] BYREF
  char *v46; // [xsp+120h] [xbp-190h]
  __int128 v47; // [xsp+128h] [xbp-188h] BYREF
  char *v48; // [xsp+138h] [xbp-178h]
  __int128 v49; // [xsp+140h] [xbp-170h] BYREF
  _BYTE v50[24]; // [xsp+160h] [xbp-150h] BYREF
  _BYTE v51[24]; // [xsp+178h] [xbp-138h] BYREF
  char v52[24]; // [xsp+190h] [xbp-120h] BYREF
  _BYTE v53[24]; // [xsp+1A8h] [xbp-108h] BYREF
  __int128 v54; // [xsp+1C0h] [xbp-F0h] BYREF
  char *v55; // [xsp+1D0h] [xbp-E0h]
  __int128 v56; // [xsp+1D8h] [xbp-D8h] BYREF
  _OWORD v57[2]; // [xsp+1F0h] [xbp-C0h] BYREF
  __int128 v58; // [xsp+210h] [xbp-A0h] BYREF
  __int128 v59; // [xsp+220h] [xbp-90h]
  unsigned __int64 v60; // [xsp+230h] [xbp-80h] BYREF
  __int64 v61; // [xsp+238h] [xbp-78h] BYREF
  __int64 v62; // [xsp+248h] [xbp-68h] BYREF
  __int64 v63; // [xsp+250h] [xbp-60h]
  int v64; // [xsp+260h] [xbp-50h]
  unsigned __int64 v65; // [xsp+268h] [xbp-48h] BYREF
  __int64 v66; // [xsp+280h] [xbp-30h] BYREF
  __int64 v67; // [xsp+288h] [xbp-28h]
  _QWORD v68[3]; // [xsp+298h] [xbp-18h] BYREF

  *(_QWORD *)(a1 + 32) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_259B1A8(a1 + 40);
  *(_WORD *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_DWORD *)(a1 + 408) = 1065353216;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_DWORD *)(a1 + 448) = 1065353216;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_DWORD *)(a1 + 488) = 1065353216;
  sub_6271768(a1 + 416, 0LL, 0LL);
  v58 = xmmword_6BA5F30;
  v59 = *(_OWORD *)&off_6BA5F40;
  v60 = (unsigned __int64)&dword_0 + 2;
  v57[0] = off_6BA5F10;
  v57[1] = unk_6BA5F20;
  sub_6273048(a1 + 376, v57, &v61);
  v34 = 429;
  v35[0] = 30;
  strcpy(&v35[1], "gamepersistence");
  strcpy(v50, " /persistence/set");
  strcpy(v51, "$/persistence/getV2");
  strcpy(v52, ",/persistence/increment");
  strcpy(v53, "&/persistence/remove");
  v55 = (char *)sub_6575418();
  LOWORD(v56) = 12034;
  BYTE2(v56) = 0;
  strcpy(v55, "/persistence/getSortedValues");
  v54 = xmmword_AFE7E0;
  v31 = (unsigned __int64 *)sub_6575418();
  v33 = v31 + 18;
  sub_67D2788(v31, (__int128 *)v50);
  sub_67D2788(v31 + 3, (__int128 *)v51);
  sub_67D2788(v31 + 6, (__int128 *)v52);
  sub_67D2788(v31 + 9, (__int128 *)v53);
  sub_67D2788(v31 + 12, &v54);
  sub_67D2788(v31 + 15, &v56);
  v32 = v31 + 18;
  LODWORD(v57[0]) = 429;
  sub_67D2788((unsigned __int64 *)v57 + 1, (__int128 *)v35);
  sub_2513400(&v58, &v31);
  v29 = 429;
  LOBYTE(v30) = 12;
  strcpy((char *)&v30 + 1, "points");
  v46 = (char *)sub_6575418();
  v45 = xmmword_AF69E0;
  strcpy(v46, "/v1/universes/{universeId}/users/{userId}/all-time");
  v48 = (char *)sub_6575418();
  BYTE2(v49) = 0;
  strcpy(v48, "/v1/universes/{universeId}/users/{userId}");
  v47 = xmmword_AFC790;
  LOWORD(v49) = 12034;
  v26 = (unsigned __int64 *)sub_6575418();
  v28 = v26 + 9;
  sub_67D2788(v26, &v45);
  sub_67D2788(v26 + 3, &v47);
  sub_67D2788(v26 + 6, &v49);
  v27 = v26 + 9;
  DWORD2(v59) = 429;
  sub_67D2788(&v60, &v30);
  sub_2513400(&v62, &v26);
  v24 = 429;
  LOBYTE(v25) = 12;
  strcpy((char *)&v25 + 1, "badges");
  v37 = (char *)sub_6575418();
  v38 = 40;
  v41 = 0;
  strcpy(v37, "/v1/users/{userId}/badges/awarded-dates");
  v36 = xmmword_AFB5E0;
  v40 = 2103724389;
  v39 = *(_OWORD *)"/v1/badges/{badgeId}";
  v43 = (char *)sub_6575418();
  BYTE2(v44) = 0;
  strcpy(v43, "/v1/users/{userId}/badges/{badgeId}/award-badge");
  v42 = xmmword_AFBE40;
  LOWORD(v44) = 12034;
  v21 = (unsigned __int64 *)sub_6575418();
  v23 = v21 + 12;
  sub_67D2788(v21, &v36);
  sub_67D2788(v21 + 3, (__int128 *)&v38);
  sub_67D2788(v21 + 6, &v42);
  sub_67D2788(v21 + 9, &v44);
  v22 = v21 + 12;
  v64 = 429;
  sub_67D2788(&v65, &v25);
  sub_2513400(&v66, &v21);
  result = sub_6273940(a1 + 456, v57, v68);
  v3 = v66;
  if ( v66 )
  {
    if ( v67 != v66 )
    {
      v4 = v67;
      do
      {
        v5 = *(_BYTE *)(v4 - 24);
        v4 -= 24LL;
        if ( (v5 & 1) != 0 )
          sub_6575460();
      }
      while ( v4 != v3 );
    }
    v67 = v3;
    result = sub_6575460();
  }
  if ( (v65 & 1) != 0 )
    result = sub_6575460();
  v6 = v62;
  if ( v62 )
  {
    if ( v63 != v62 )
    {
      v7 = v63;
      do
      {
        v8 = *(_BYTE *)(v7 - 24);
        v7 -= 24LL;
        if ( (v8 & 1) != 0 )
          sub_6575460();
      }
      while ( v7 != v6 );
    }
    v63 = v6;
    result = sub_6575460();
  }
  if ( (v60 & 1) != 0 )
    result = sub_6575460();
  v9 = v58;
  if ( (_QWORD)v58 )
  {
    if ( *((_QWORD *)&v58 + 1) != (_QWORD)v58 )
    {
      v10 = *((_QWORD *)&v58 + 1);
      do
      {
        v11 = *(_BYTE *)(v10 - 24);
        v10 -= 24LL;
        if ( (v11 & 1) != 0 )
          sub_6575460();
      }
      while ( v10 != v9 );
    }
    *((_QWORD *)&v58 + 1) = v9;
    result = sub_6575460();
  }
  if ( (BYTE8(v57[0]) & 1) != 0 )
    result = sub_6575460();
  v12 = v21;
  if ( v21 )
  {
    if ( v22 != v21 )
    {
      v13 = v22;
      do
      {
        v14 = *((_BYTE *)v13 - 24);
        v13 -= 3;
        if ( (v14 & 1) != 0 )
          sub_6575460();
      }
      while ( v13 != v12 );
    }
    v22 = v12;
    result = sub_6575460();
  }
  if ( (v44 & 1) != 0 )
  {
    result = sub_6575460();
    if ( (v42 & 1) == 0 )
    {
LABEL_37:
      if ( (v38 & 1) == 0 )
        goto LABEL_38;
      goto LABEL_48;
    }
  }
  else if ( (v42 & 1) == 0 )
  {
    goto LABEL_37;
  }
  result = sub_6575460();
  if ( (v38 & 1) == 0 )
  {
LABEL_38:
    if ( (v36 & 1) == 0 )
      goto LABEL_39;
    goto LABEL_49;
  }
LABEL_48:
  result = sub_6575460();
  if ( (v36 & 1) == 0 )
  {
LABEL_39:
    if ( (v25 & 1) == 0 )
      goto LABEL_40;
    goto LABEL_50;
  }
LABEL_49:
  result = sub_6575460();
  if ( (v25 & 1) == 0 )
  {
LABEL_40:
    v15 = v26;
    if ( v26 )
      goto LABEL_41;
LABEL_51:
    if ( (v49 & 1) != 0 )
      goto LABEL_64;
LABEL_52:
    if ( (v47 & 1) != 0 )
      goto LABEL_65;
LABEL_53:
    if ( (v45 & 1) != 0 )
      goto LABEL_66;
LABEL_54:
    if ( (v30 & 1) != 0 )
      goto LABEL_67;
LABEL_55:
    v18 = v31;
    if ( !v31 )
      goto LABEL_68;
    goto LABEL_56;
  }
LABEL_50:
  result = sub_6575460();
  v15 = v26;
  if ( !v26 )
    goto LABEL_51;
LABEL_41:
  if ( v27 != v15 )
  {
    v16 = v27;
    do
    {
      v17 = *((_BYTE *)v16 - 24);
      v16 -= 3;
      if ( (v17 & 1) != 0 )
        sub_6575460();
    }
    while ( v16 != v15 );
  }
  v27 = v15;
  result = sub_6575460();
  if ( (v49 & 1) == 0 )
    goto LABEL_52;
LABEL_64:
  result = sub_6575460();
  if ( (v47 & 1) == 0 )
    goto LABEL_53;
LABEL_65:
  result = sub_6575460();
  if ( (v45 & 1) == 0 )
    goto LABEL_54;
LABEL_66:
  result = sub_6575460();
  if ( (v30 & 1) == 0 )
    goto LABEL_55;
LABEL_67:
  result = sub_6575460();
  v18 = v31;
  if ( !v31 )
  {
LABEL_68:
    if ( (v56 & 1) == 0 )
      goto LABEL_69;
    goto LABEL_78;
  }
LABEL_56:
  if ( v32 != v18 )
  {
    v19 = v32;
    do
    {
      v20 = *((_BYTE *)v19 - 24);
      v19 -= 3;
      if ( (v20 & 1) != 0 )
        sub_6575460();
    }
    while ( v19 != v18 );
  }
  v32 = v18;
  result = sub_6575460();
  if ( (v56 & 1) == 0 )
  {
LABEL_69:
    if ( (v54 & 1) == 0 )
      goto LABEL_70;
    goto LABEL_79;
  }
LABEL_78:
  result = sub_6575460();
  if ( (v54 & 1) == 0 )
  {
LABEL_70:
    if ( (v53[0] & 1) == 0 )
      goto LABEL_71;
    goto LABEL_80;
  }
LABEL_79:
  result = sub_6575460();
  if ( (v53[0] & 1) == 0 )
  {
LABEL_71:
    if ( (v52[0] & 1) == 0 )
      goto LABEL_72;
    goto LABEL_81;
  }
LABEL_80:
  result = sub_6575460();
  if ( (v52[0] & 1) == 0 )
  {
LABEL_72:
    if ( (v51[0] & 1) == 0 )
      goto LABEL_73;
    goto LABEL_82;
  }
LABEL_81:
  result = sub_6575460();
  if ( (v51[0] & 1) == 0 )
  {
LABEL_73:
    if ( (v50[0] & 1) == 0 )
      goto LABEL_74;
    goto LABEL_83;
  }
LABEL_82:
  result = sub_6575460();
  if ( (v50[0] & 1) == 0 )
  {
LABEL_74:
    if ( (v35[0] & 1) == 0 )
      return result;
    return sub_6575460();
  }
LABEL_83:
  result = sub_6575460();
  if ( (v35[0] & 1) == 0 )
    return result;
  return sub_6575460();
}


================================================================================
Function: sub_6271768 (0x6271768)
================================================================================

_QWORD *__fastcall sub_6271768(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x19
  __int64 v5; // x8
  __int64 v6; // x21
  __int64 i; // x9
  unsigned __int8 *v8; // x22
  __int64 v9; // x24
  unsigned __int8 *v10; // x23
  __int64 v11; // x25

  v4 = result;
  v5 = result[1];
  v6 = a2;
  if ( v5 )
  {
    for ( i = 0LL; i != v5; ++i )
      *(_QWORD *)(*result + 8 * i) = 0LL;
    v8 = (unsigned __int8 *)result[2];
    result[2] = 0LL;
    result[3] = 0LL;
    if ( !v8 || a2 == a3 )
    {
      v10 = v8;
      v11 = a2;
    }
    else
    {
      do
      {
        sub_67D3420(v8 + 16, (unsigned __int8 *)v6);
        v9 = v6 + 24;
        if ( (unsigned __int8 *)(v6 + 24) != v8 + 40 )
        {
          *((_DWORD *)v8 + 18) = *(_DWORD *)(v6 + 56);
          sub_62719F4();
        }
        v10 = *(unsigned __int8 **)v8;
        sub_6271898(v4, v8);
        v11 = v6 + 64;
        if ( !v10 )
          break;
        v6 += 64LL;
        v8 = v10;
      }
      while ( v9 + 40 != a3 );
    }
    result = (_QWORD *)sub_623C1E4(v4, v10);
    v6 = v11;
  }
  while ( v6 != a3 )
  {
    result = (_QWORD *)sub_6272884(v4, v6, v6);
    v6 += 64LL;
  }
  return result;
}


================================================================================
Function: sub_6271898 (0x6271898)
================================================================================

_QWORD *__fastcall sub_6271898(__int64 *a1, __int64 a2)
{
  _QWORD *v2; // x19
  unsigned __int64 v4; // x8
  bool v5; // zf
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x2
  __int64 *v8; // x1
  __int64 v9; // x0
  int8x8_t v10; // x8
  unsigned __int64 v11; // x10
  uint8x8_t v12; // d0
  _QWORD *v13; // x11
  __int64 v14; // x12
  unsigned __int64 v15; // x10
  __int64 v17; // [xsp+0h] [xbp-10h] BYREF

  v2 = (_QWORD *)a2;
  v4 = *(unsigned __int8 *)(a2 + 16);
  v5 = (v4 & 1) == 0;
  v6 = v4 >> 1;
  if ( v5 )
    v7 = v6;
  else
    v7 = *(_QWORD *)(a2 + 24);
  if ( v5 )
    v8 = (__int64 *)(a2 + 17);
  else
    v8 = *(__int64 **)(a2 + 32);
  v2[1] = sub_24DF128((__int64)&v17, v8, v7);
  v9 = sub_627238C(a1);
  if ( !v9 )
  {
    v10.n64_u64[0] = a1[1];
    v11 = v2[1];
    v12.n64_u64[0] = vcnt_s8(v10).n64_u64[0];
    v12.n64_u16[0] = vaddlv_u8(v12);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v11 >= v10.n64_u64[0] )
        v11 %= v10.n64_u64[0];
    }
    else
    {
      v11 &= v10.n64_u64[0] - 1;
    }
    v13 = *(_QWORD **)(*a1 + 8 * v11);
    if ( v13 )
    {
      *v2 = *v13;
    }
    else
    {
      *v2 = a1[2];
      v14 = *a1;
      a1[2] = (__int64)v2;
      *(_QWORD *)(v14 + 8 * v11) = a1 + 2;
      if ( !*v2 )
      {
LABEL_22:
        ++a1[3];
        return v2;
      }
      v15 = *(_QWORD *)(*v2 + 8LL);
      if ( v12.n64_u32[0] > 1uLL )
      {
        if ( v15 >= v10.n64_u64[0] )
          v15 %= v10.n64_u64[0];
      }
      else
      {
        v15 &= v10.n64_u64[0] - 1;
      }
      v13 = (_QWORD *)(*a1 + 8 * v15);
    }
    *v13 = v2;
    goto LABEL_22;
  }
  return (_QWORD *)v9;
}


================================================================================
Function: sub_62719F4 (0x62719F4)
================================================================================

_QWORD *__fastcall sub_62719F4(_QWORD *result, __int64 *a2, __int64 *a3)
{
  _QWORD *v4; // x19
  __int64 v6; // x8
  __int64 i; // x9
  __int64 *v8; // x22
  __int64 *v9; // x24
  __int128 v10; // q0
  __int128 v11; // q1
  __int128 v12; // q2
  __int64 *v13; // x19
  _QWORD v14[3]; // [xsp+0h] [xbp-20h] BYREF

  v4 = result;
  v6 = result[1];
  if ( !v6 )
    goto LABEL_9;
  for ( i = 0LL; i != v6; *(_QWORD *)(*result + 8 * i++) = 0LL )
    ;
  v8 = (__int64 *)result[2];
  result[2] = 0LL;
  result[3] = 0LL;
  if ( v8 )
  {
    while ( a2 != a3 )
    {
      sub_67D3420((unsigned __int8 *)v8 + 16, (unsigned __int8 *)a2 + 16);
      v9 = (__int64 *)*v8;
      *(_OWORD *)(v8 + 5) = *(_OWORD *)(a2 + 5);
      v10 = *(_OWORD *)(a2 + 11);
      v11 = *(_OWORD *)(a2 + 9);
      v12 = *(_OWORD *)(a2 + 7);
      *((_DWORD *)v8 + 26) = *((_DWORD *)a2 + 26);
      *(_OWORD *)(v8 + 11) = v10;
      *(_OWORD *)(v8 + 9) = v11;
      *(_OWORD *)(v8 + 7) = v12;
      result = (_QWORD *)sub_6271B94(v4, v8);
      a2 = (__int64 *)*a2;
      v8 = v9;
      if ( !v9 )
        goto LABEL_9;
    }
    do
    {
      v13 = (__int64 *)*v8;
      if ( (v8[2] & 1) != 0 )
        sub_6575460();
      result = (_QWORD *)sub_6575460();
      v8 = v13;
    }
    while ( v13 );
  }
  else
  {
LABEL_9:
    while ( a2 != a3 )
    {
      sub_6272250(v14, v4, a2 + 2);
      result = (_QWORD *)sub_6271B94(v4, v14[0]);
      a2 = (__int64 *)*a2;
    }
  }
  return result;
}


================================================================================
Function: sub_6271B94 (0x6271B94)
================================================================================

__int64 __fastcall sub_6271B94(__int64 *a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  bool v5; // zf
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x2
  __int64 *v8; // x1
  _QWORD *v9; // x0
  int8x8_t v10; // x8
  unsigned __int64 v11; // x9
  uint8x8_t v12; // d0
  unsigned __int64 v13; // x10
  __int64 v14; // x12
  __int64 v16; // [xsp+0h] [xbp-10h] BYREF

  v4 = *(unsigned __int8 *)(a2 + 16);
  v5 = (v4 & 1) == 0;
  v6 = v4 >> 1;
  if ( v5 )
    v7 = v6;
  else
    v7 = *(_QWORD *)(a2 + 24);
  if ( v5 )
    v8 = (__int64 *)(a2 + 17);
  else
    v8 = *(__int64 **)(a2 + 32);
  *(_QWORD *)(a2 + 8) = sub_24DF128((__int64)&v16, v8, v7);
  v9 = (_QWORD *)sub_6271D0C(a1);
  v10.n64_u64[0] = a1[1];
  v11 = *(_QWORD *)(a2 + 8);
  v12.n64_u64[0] = vcnt_s8(v10).n64_u64[0];
  v12.n64_u16[0] = vaddlv_u8(v12);
  if ( v12.n64_u32[0] > 1uLL )
  {
    if ( v11 >= v10.n64_u64[0] )
      v11 %= v10.n64_u64[0];
  }
  else
  {
    v11 &= v10.n64_u64[0] - 1;
  }
  if ( !v9 )
  {
    *(_QWORD *)a2 = a1[2];
    v14 = *a1;
    a1[2] = a2;
    *(_QWORD *)(v14 + 8 * v11) = a1 + 2;
    if ( !*(_QWORD *)a2 )
      goto LABEL_25;
    v13 = *(_QWORD *)(*(_QWORD *)a2 + 8LL);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v10.n64_u64[0] )
        v13 %= v10.n64_u64[0];
    }
    else
    {
      v13 &= v10.n64_u64[0] - 1;
    }
LABEL_24:
    *(_QWORD *)(*a1 + 8 * v13) = a2;
    goto LABEL_25;
  }
  *(_QWORD *)a2 = *v9;
  *v9 = a2;
  if ( *(_QWORD *)a2 )
  {
    v13 = *(_QWORD *)(*(_QWORD *)a2 + 8LL);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v10.n64_u64[0] )
        v13 %= v10.n64_u64[0];
    }
    else
    {
      v13 &= v10.n64_u64[0] - 1;
    }
    if ( v13 != v11 )
      goto LABEL_24;
  }
LABEL_25:
  ++a1[3];
  return a2;
}


================================================================================
Function: sub_6271D0C (0x6271D0C)
================================================================================

__int64 *__fastcall sub_6271D0C(unsigned __int64 a1, unsigned __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // x23
  float v7; // s1
  float v8; // s0
  _BOOL8 v9; // x9
  unsigned __int64 v10; // x10
  unsigned __int64 v11; // x1
  uint8x8_t v12; // d0
  unsigned __int64 v13; // x24
  unsigned __int64 v14; // x25
  __int64 *v15; // x26
  int v16; // w27
  unsigned __int64 v17; // x8
  size_t v18; // x21
  unsigned __int8 *v19; // x22
  _BOOL4 v20; // w8
  int v21; // w9
  __int64 *v22; // x20
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x9
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x11
  unsigned __int64 v27; // x10
  const void *v28; // x0
  unsigned __int8 *v29; // x9
  unsigned __int64 v30; // x10
  unsigned __int8 *v31; // x11
  int v32; // w8
  int v33; // t1
  int v34; // t1
  bool v35; // zf

  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(float *)(a1 + 32);
  v8 = (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL);
  if ( !v6 || (float)(v7 * (float)v6) < v8 )
  {
    v9 = v6 < 3 || (v6 & (v6 - 1)) != 0;
    v10 = vcvtps_u32_f32(v8 / v7);
    if ( (v9 | (2 * v6)) >= v10 )
      v11 = v9 | (2 * v6);
    else
      v11 = v10;
    sub_6271F0C(a1, v11);
    v6 = *(_QWORD *)(a1 + 8);
  }
  v12.n64_u64[0] = vcnt_s8((int8x8_t)v6).n64_u64[0];
  v12.n64_u16[0] = vaddlv_u8(v12);
  v13 = v12.n64_u32[0];
  if ( v12.n64_u32[0] > 1uLL )
  {
    v14 = a2;
    if ( v6 <= a2 )
      v14 = a2 % v6;
  }
  else
  {
    v14 = (v6 - 1) & a2;
  }
  v15 = *(__int64 **)(*(_QWORD *)a1 + 8 * v14);
  if ( v15 )
  {
    v16 = 0;
    v17 = *a3;
    if ( (v17 & 1) != 0 )
      v18 = *((_QWORD *)a3 + 1);
    else
      v18 = v17 >> 1;
    if ( (v17 & 1) != 0 )
      v19 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
    else
      v19 = a3 + 1;
    while ( 1 )
    {
      v22 = v15;
      v15 = (__int64 *)*v15;
      if ( !v15 )
        return v22;
      v23 = v15[1];
      if ( v13 > 1 )
      {
        v24 = v15[1];
        if ( v23 >= v6 )
          v24 = v23 % v6;
      }
      else
      {
        v24 = v23 & (v6 - 1);
      }
      if ( v24 != v14 )
        return v22;
      if ( v23 != a2 )
        goto LABEL_21;
      v25 = *((unsigned __int8 *)v15 + 16);
      v26 = v15[3];
      v27 = v25 >> 1;
      if ( (v25 & 1) == 0 )
        v26 = v25 >> 1;
      if ( v26 == v18 )
      {
        if ( (v25 & 1) != 0 )
          v28 = (const void *)v15[4];
        else
          v28 = (char *)v15 + 17;
        if ( (v25 & 1) == 0 )
        {
          if ( v18 )
          {
            v29 = (unsigned __int8 *)v15 + 17;
            v30 = v27 - 1;
            v31 = v19;
            do
            {
              v33 = *v29++;
              v32 = v33;
              v34 = *v31++;
              v35 = v32 == v34;
              v20 = v32 == v34;
              v35 = !v35 || v30-- == 0;
            }
            while ( !v35 );
            goto LABEL_22;
          }
LABEL_47:
          v20 = 1;
          goto LABEL_22;
        }
        if ( !v18 )
          goto LABEL_47;
        v20 = memcmp(v28, v19, v18) == 0;
      }
      else
      {
LABEL_21:
        v20 = 0;
      }
LABEL_22:
      v21 = v16 & !v20;
      v16 |= v20;
      if ( v21 == 1 )
        return v22;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_6271F0C (0x6271F0C)
================================================================================

unsigned __int64 __fastcall sub_6271F0C(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x13
  unsigned __int64 v10; // x11
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  __int64 *v13; // x26
  unsigned __int64 v14; // x12
  unsigned __int64 v15; // x27
  __int64 v16; // x8
  unsigned __int64 v17; // x24
  _QWORD *v18; // x28
  size_t v19; // x21
  _QWORD *v20; // x23
  __int64 v21; // x8
  char v22; // w9
  unsigned int v23; // t1
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x11
  unsigned __int8 *v26; // x1
  unsigned __int8 *v27; // x8
  unsigned __int64 v28; // x9
  unsigned __int64 v29; // [xsp+8h] [xbp-48h]
  _QWORD *v30; // [xsp+10h] [xbp-40h]
  unsigned __int64 v31; // [xsp+18h] [xbp-38h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_67A4870(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_67A4870(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_6575418();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_6575460();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = (__int64 *)*v9;
          if ( *v9 )
          {
            v14 = v3.n64_u64[0] - 1;
            v29 = v11.n64_u32[0];
            do
            {
              v15 = v13[1];
              if ( v12 > 1 )
              {
                if ( v15 >= v3.n64_u64[0] )
                  v15 %= v3.n64_u64[0];
              }
              else
              {
                v15 &= v14;
              }
              if ( v15 == v10 )
              {
                v9 = v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v15) )
              {
                v16 = *v13;
                if ( *v13 )
                {
                  v17 = *((unsigned __int8 *)v13 + 16);
                  v18 = v13;
                  v30 = v9;
                  v31 = v10;
                  if ( (v17 & 1) != 0 )
                    v19 = v13[3];
                  else
                    v19 = v17 >> 1;
                  while ( 1 )
                  {
                    v20 = v18;
                    v18 = (_QWORD *)v16;
                    v23 = *(unsigned __int8 *)(v16 + 16);
                    v21 = v16 + 16;
                    v22 = v23;
                    v24 = *(_QWORD *)(v21 + 8);
                    v25 = (unsigned __int64)v23 >> 1;
                    if ( (v23 & 1) == 0 )
                      v24 = v25;
                    if ( v19 != v24 )
                      break;
                    if ( (v17 & 1) != 0 )
                      result = v13[4];
                    else
                      result = (unsigned __int64)v13 + 17;
                    if ( (v22 & 1) != 0 )
                      v26 = (unsigned __int8 *)v18[4];
                    else
                      v26 = (unsigned __int8 *)(v21 + 1);
                    if ( (v17 & 1) != 0 )
                    {
                      if ( v19 )
                      {
                        result = memcmp((const void *)result, v26, v19);
                        if ( (_DWORD)result )
                          break;
                      }
                    }
                    else
                    {
                      v27 = (unsigned __int8 *)v13 + 17;
                      v28 = v17 >> 1;
                      if ( v19 )
                      {
                        while ( *v27 == *v26 )
                        {
                          --v28;
                          ++v27;
                          ++v26;
                          if ( !v28 )
                            goto LABEL_46;
                        }
                        break;
                      }
                    }
LABEL_46:
                    v16 = *v18;
                    if ( !*v18 )
                    {
                      v20 = v18;
                      v18 = 0LL;
                      break;
                    }
                  }
                  v14 = v3.n64_u64[0] - 1;
                  v12 = v29;
                  v10 = v31;
                  v9 = v30;
                }
                else
                {
                  v18 = 0LL;
                  v20 = v13;
                }
                *v9 = v18;
                *v20 = **(_QWORD **)(v2->n64_u64[0] + 8 * v15);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v15) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v15) = v9;
                v9 = v13;
                v10 = v15;
              }
              v13 = (__int64 *)*v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_6575460();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6272250 (0x6272250)
================================================================================

unsigned __int64 __usercall sub_6272250@<X0>(__int64 a1@<X0>, __int64 a2@<X1>, __int64 a3@<X8>)
{
  __int64 v4; // x23
  __int64 v6; // x19
  unsigned __int64 v7; // x9
  __int128 v8; // q0
  __int128 v9; // q1
  bool v10; // zf
  unsigned __int64 v11; // x8
  __int64 *v12; // x10
  unsigned __int64 v13; // x9
  __int128 v14; // q2
  __int128 v15; // q0
  __int64 v16; // x12
  unsigned __int64 v17; // x2
  __int64 *v18; // x1
  unsigned __int64 result; // x0
  __int64 v20; // [xsp+0h] [xbp-10h] BYREF

  v4 = a1 + 16;
  v6 = sub_6575418();
  *(_BYTE *)(a3 + 16) = 0;
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v4;
  sub_67D2788((unsigned __int64 *)(v6 + 16), (__int128 *)a2);
  v7 = *(unsigned __int8 *)(v6 + 16);
  v8 = *(_OWORD *)(a2 + 40);
  v9 = *(_OWORD *)(a2 + 56);
  *(_BYTE *)(a3 + 16) = 1;
  v10 = (v7 & 1) == 0;
  v11 = *(_QWORD *)(v6 + 24);
  v12 = *(__int64 **)(v6 + 32);
  *(_OWORD *)(v6 + 56) = v8;
  v13 = v7 >> 1;
  v14 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v6 + 72) = v9;
  v15 = *(_OWORD *)(a2 + 24);
  v16 = *(_QWORD *)(a2 + 88);
  if ( v10 )
    v17 = v13;
  else
    v17 = v11;
  if ( v10 )
    v18 = (__int64 *)(v6 + 17);
  else
    v18 = v12;
  *(_OWORD *)(v6 + 88) = v14;
  *(_OWORD *)(v6 + 40) = v15;
  *(_QWORD *)(v6 + 104) = v16;
  result = sub_24DF128((__int64)&v20, v18, v17);
  *(_QWORD *)v6 = 0LL;
  *(_QWORD *)(v6 + 8) = result;
  return result;
}


================================================================================
Function: sub_627238C (0x627238C)
================================================================================

__int64 **__fastcall sub_627238C(unsigned __int64 a1, unsigned __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v4; // x24
  unsigned __int64 v5; // x20
  uint8x8_t v6; // d0
  unsigned __int64 v7; // x25
  __int64 ***v8; // x8
  unsigned __int64 v9; // x9
  __int64 **v10; // x21
  size_t v11; // x22
  unsigned __int8 *i; // x23
  unsigned __int64 v13; // x8
  unsigned __int64 v14; // x10
  unsigned __int64 v15; // x11
  __int64 *v16; // x0
  __int64 v17; // x9
  float v18; // s1
  float v19; // s0
  float v20; // s0
  _BOOL8 v21; // x8
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x10
  unsigned __int64 v24; // x1

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    v5 = a2;
    v6.n64_u64[0] = vcnt_s8((int8x8_t)v4).n64_u64[0];
    v6.n64_u16[0] = vaddlv_u8(v6);
    v7 = v6.n64_u32[0];
    if ( v6.n64_u32[0] > 1uLL )
    {
      if ( v4 <= a2 )
        v5 = a2 % v4;
    }
    else
    {
      v5 = (v4 - 1) & a2;
    }
    v8 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v5);
    if ( v8 )
    {
      v9 = *a3;
      v10 = *v8;
      v11 = (v9 & 1) != 0 ? *((_QWORD *)a3 + 1) : v9 >> 1;
      for ( i = (v9 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a3 + 2) : a3 + 1; v10; v10 = (__int64 **)*v10 )
      {
        v13 = (unsigned __int64)v10[1];
        if ( v7 > 1 )
        {
          if ( v13 >= v4 )
            v13 %= v4;
        }
        else
        {
          v13 &= v4 - 1;
        }
        if ( v13 != v5 )
          break;
        v14 = *((unsigned __int8 *)v10 + 16);
        v15 = (unsigned __int64)v10[3];
        if ( (v14 & 1) == 0 )
          v15 = v14 >> 1;
        if ( v15 == v11 )
        {
          if ( (v14 & 1) != 0 )
            v16 = v10[4];
          else
            v16 = (__int64 *)((char *)v10 + 17);
          if ( (v14 & 1) != 0 )
          {
            if ( !v11 || !memcmp(v16, i, v11) )
              return v10;
          }
          else
          {
            if ( !v11 )
              return v10;
            v17 = 0LL;
            while ( *((unsigned __int8 *)v10 + v17 + 17) == i[v17] )
            {
              if ( v14 >> 1 == ++v17 )
                return v10;
            }
          }
        }
      }
    }
  }
  v18 = *(float *)(a1 + 32);
  v19 = (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL);
  if ( !v4 || (float)(v18 * (float)v4) < v19 )
  {
    v20 = v19 / v18;
    v21 = 1LL;
    if ( v4 >= 3 )
      v21 = (v4 & (v4 - 1)) != 0;
    v22 = v21 | (2 * v4);
    v23 = vcvtps_u32_f32(v20);
    if ( v22 >= v23 )
      v24 = v22;
    else
      v24 = v23;
    sub_6272540(a1, v24);
  }
  return 0LL;
}


================================================================================
Function: sub_6272540 (0x6272540)
================================================================================

unsigned __int64 __fastcall sub_6272540(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x13
  unsigned __int64 v10; // x11
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  __int64 *v13; // x26
  unsigned __int64 v14; // x12
  unsigned __int64 v15; // x27
  __int64 v16; // x8
  unsigned __int64 v17; // x24
  _QWORD *v18; // x28
  size_t v19; // x21
  _QWORD *v20; // x23
  __int64 v21; // x8
  char v22; // w9
  unsigned int v23; // t1
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x11
  unsigned __int8 *v26; // x1
  unsigned __int8 *v27; // x8
  unsigned __int64 v28; // x9
  unsigned __int64 v29; // [xsp+8h] [xbp-48h]
  _QWORD *v30; // [xsp+10h] [xbp-40h]
  unsigned __int64 v31; // [xsp+18h] [xbp-38h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_67A4870(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_67A4870(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_6575418();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_6575460();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = (__int64 *)*v9;
          if ( *v9 )
          {
            v14 = v3.n64_u64[0] - 1;
            v29 = v11.n64_u32[0];
            do
            {
              v15 = v13[1];
              if ( v12 > 1 )
              {
                if ( v15 >= v3.n64_u64[0] )
                  v15 %= v3.n64_u64[0];
              }
              else
              {
                v15 &= v14;
              }
              if ( v15 == v10 )
              {
                v9 = v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v15) )
              {
                v16 = *v13;
                if ( *v13 )
                {
                  v17 = *((unsigned __int8 *)v13 + 16);
                  v18 = v13;
                  v30 = v9;
                  v31 = v10;
                  if ( (v17 & 1) != 0 )
                    v19 = v13[3];
                  else
                    v19 = v17 >> 1;
                  while ( 1 )
                  {
                    v20 = v18;
                    v18 = (_QWORD *)v16;
                    v23 = *(unsigned __int8 *)(v16 + 16);
                    v21 = v16 + 16;
                    v22 = v23;
                    v24 = *(_QWORD *)(v21 + 8);
                    v25 = (unsigned __int64)v23 >> 1;
                    if ( (v23 & 1) == 0 )
                      v24 = v25;
                    if ( v19 != v24 )
                      break;
                    if ( (v17 & 1) != 0 )
                      result = v13[4];
                    else
                      result = (unsigned __int64)v13 + 17;
                    if ( (v22 & 1) != 0 )
                      v26 = (unsigned __int8 *)v18[4];
                    else
                      v26 = (unsigned __int8 *)(v21 + 1);
                    if ( (v17 & 1) != 0 )
                    {
                      if ( v19 )
                      {
                        result = memcmp((const void *)result, v26, v19);
                        if ( (_DWORD)result )
                          break;
                      }
                    }
                    else
                    {
                      v27 = (unsigned __int8 *)v13 + 17;
                      v28 = v17 >> 1;
                      if ( v19 )
                      {
                        while ( *v27 == *v26 )
                        {
                          --v28;
                          ++v27;
                          ++v26;
                          if ( !v28 )
                            goto LABEL_46;
                        }
                        break;
                      }
                    }
LABEL_46:
                    v16 = *v18;
                    if ( !*v18 )
                    {
                      v20 = v18;
                      v18 = 0LL;
                      break;
                    }
                  }
                  v14 = v3.n64_u64[0] - 1;
                  v12 = v29;
                  v10 = v31;
                  v9 = v30;
                }
                else
                {
                  v18 = 0LL;
                  v20 = v13;
                }
                *v9 = v18;
                *v20 = **(_QWORD **)(v2->n64_u64[0] + 8 * v15);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v15) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v15) = v9;
                v9 = v13;
                v10 = v15;
              }
              v13 = (__int64 *)*v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_6575460();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6272884 (0x6272884)
================================================================================

__int64 **__fastcall sub_6272884(__int64 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int64 v3; // x27
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  __int64 *v11; // x1
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x26
  uint8x8_t v16; // d0
  unsigned __int64 v17; // x28
  __int64 ***v18; // x8
  unsigned __int64 v19; // x10
  unsigned __int8 *v20; // x11
  unsigned __int8 *v21; // x12
  unsigned __int64 v22; // x9
  __int64 **v23; // x22
  size_t v24; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  __int64 *v29; // x0
  __int64 v30; // x9
  __int64 *v31; // x23
  _QWORD *v32; // x22
  __int64 v33; // x8
  float v34; // s1
  float v35; // s0
  _BOOL8 v36; // x9
  unsigned __int64 v37; // x10
  __int64 v38; // x1
  __int64 v39; // x8
  _QWORD *v40; // x9
  __int64 v41; // x9
  unsigned __int64 v42; // x9
  _QWORD v44[2]; // [xsp+0h] [xbp-20h] BYREF
  char v45; // [xsp+10h] [xbp-10h]

  v7 = *((_QWORD *)a2 + 1);
  v8 = *a2;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v11 = (__int64 *)(a2 + 1);
  else
    v11 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v9 )
    v12 = v10;
  else
    v12 = v7;
  v13 = sub_24DF128((__int64)v44, v11, v12);
  v14 = v13;
  v15 = a1[1];
  if ( v15 )
  {
    v16.n64_u64[0] = vcnt_s8((int8x8_t)v15).n64_u64[0];
    v16.n64_u16[0] = vaddlv_u8(v16);
    v17 = v16.n64_u32[0];
    if ( v16.n64_u32[0] > 1uLL )
    {
      v3 = v13;
      if ( v13 >= v15 )
        v3 = v13 % v15;
    }
    else
    {
      v3 = (v15 - 1) & v13;
    }
    v18 = *(__int64 ****)(*a1 + 8 * v3);
    if ( v18 )
    {
      v19 = *((_QWORD *)a2 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v21 = a2 + 1;
      v22 = *a2;
      v23 = *v18;
      v24 = (v22 & 1) != 0 ? v19 : v22 >> 1;
      for ( i = (v22 & 1) != 0 ? v20 : v21; v23; v23 = (__int64 **)*v23 )
      {
        v26 = (unsigned __int64)v23[1];
        if ( v26 != v14 )
        {
          if ( v17 > 1 )
          {
            if ( v26 >= v15 )
              v26 %= v15;
          }
          else
          {
            v26 &= v15 - 1;
          }
          if ( v26 != v3 )
            break;
        }
        v27 = *((unsigned __int8 *)v23 + 16);
        v28 = (unsigned __int64)v23[3];
        if ( (v27 & 1) == 0 )
          v28 = v27 >> 1;
        if ( v28 == v24 )
        {
          if ( (v27 & 1) != 0 )
            v29 = v23[4];
          else
            v29 = (__int64 *)((char *)v23 + 17);
          if ( (v27 & 1) != 0 )
          {
            if ( !v24 || !memcmp(v29, i, v24) )
              return v23;
          }
          else
          {
            if ( !v24 )
              return v23;
            v30 = 0LL;
            while ( *((unsigned __int8 *)v23 + v30 + 17) == i[v30] )
            {
              if ( v27 >> 1 == ++v30 )
                return v23;
            }
          }
        }
      }
    }
  }
  v31 = a1 + 2;
  v32 = (_QWORD *)sub_6575418();
  v45 = 0;
  v44[0] = v32;
  v44[1] = a1 + 2;
  sub_6272BC0(v32 + 2, a3);
  v33 = a1[3];
  v34 = *((float *)a1 + 8);
  *v32 = 0LL;
  v32[1] = v14;
  v45 = 1;
  v35 = (float)(unsigned __int64)(v33 + 1);
  if ( !v15 || (float)(v34 * (float)v15) < v35 )
  {
    v36 = v15 < 3 || (v15 & (v15 - 1)) != 0;
    v37 = vcvtps_u32_f32(v35 / v34);
    if ( (v36 | (2 * v15)) >= v37 )
      v38 = v36 | (2 * v15);
    else
      v38 = v37;
    sub_6272540(a1, v38);
    v15 = a1[1];
    if ( (v15 & (v15 - 1)) != 0 )
    {
      if ( v14 >= v15 )
        v3 = v14 % v15;
      else
        v3 = v14;
    }
    else
    {
      v3 = (v15 - 1) & v14;
    }
  }
  v39 = *a1;
  v40 = *(_QWORD **)(*a1 + 8 * v3);
  if ( v40 )
  {
    *v32 = *v40;
    *v40 = v32;
  }
  else
  {
    v41 = *v31;
    *v31 = (__int64)v32;
    *v32 = v41;
    *(_QWORD *)(v39 + 8 * v3) = v31;
    if ( *(_QWORD *)v44[0] )
    {
      v42 = *(_QWORD *)(*(_QWORD *)v44[0] + 8LL);
      if ( (v15 & (v15 - 1)) != 0 )
      {
        if ( v42 >= v15 )
          v42 %= v15;
      }
      else
      {
        v42 &= v15 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v42) = v44[0];
    }
  }
  v23 = (__int64 **)v44[0];
  ++a1[3];
  return v23;
}


================================================================================
Function: sub_6272BC0 (0x6272BC0)
================================================================================

__int64 __fastcall sub_6272BC0(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  _QWORD *i; // x21

  sub_67D2788((unsigned __int64 *)a1, (__int128 *)a2);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  result = sub_6271F0C(a1 + 24, *(_QWORD *)(a2 + 32));
  for ( i = *(_QWORD **)(a2 + 40); i; i = (_QWORD *)*i )
    result = sub_6272C58(a1 + 24, i + 2, i + 2);
  return result;
}


================================================================================
Function: sub_6272C58 (0x6272C58)
================================================================================

__int64 **__fastcall sub_6272C58(__int64 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int64 v3; // x27
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  __int64 *v11; // x1
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x26
  uint8x8_t v16; // d0
  unsigned __int64 v17; // x28
  __int64 ***v18; // x8
  unsigned __int64 v19; // x10
  unsigned __int8 *v20; // x11
  unsigned __int8 *v21; // x12
  unsigned __int64 v22; // x9
  __int64 **v23; // x22
  size_t v24; // x23
  unsigned __int8 *i; // x24
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  __int64 *v29; // x0
  __int64 v30; // x9
  __int64 *v31; // x23
  __int64 v32; // x22
  __int128 v33; // q0
  __int64 v34; // x8
  __int128 v35; // q1
  __int128 v36; // q0
  __int64 v37; // x9
  __int128 v38; // q1
  float v39; // s0
  float v40; // s1
  _BOOL8 v41; // x9
  unsigned __int64 v42; // x10
  __int64 v43; // x1
  __int64 v44; // x8
  __int64 *v45; // x9
  __int64 v46; // x9
  unsigned __int64 v47; // x9
  _QWORD v49[2]; // [xsp+0h] [xbp-20h] BYREF
  char v50; // [xsp+10h] [xbp-10h]

  v7 = *((_QWORD *)a2 + 1);
  v8 = *a2;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v11 = (__int64 *)(a2 + 1);
  else
    v11 = (__int64 *)*((_QWORD *)a2 + 2);
  if ( v9 )
    v12 = v10;
  else
    v12 = v7;
  v13 = sub_24DF128((__int64)v49, v11, v12);
  v14 = v13;
  v15 = a1[1];
  if ( v15 )
  {
    v16.n64_u64[0] = vcnt_s8((int8x8_t)v15).n64_u64[0];
    v16.n64_u16[0] = vaddlv_u8(v16);
    v17 = v16.n64_u32[0];
    if ( v16.n64_u32[0] > 1uLL )
    {
      v3 = v13;
      if ( v13 >= v15 )
        v3 = v13 % v15;
    }
    else
    {
      v3 = (v15 - 1) & v13;
    }
    v18 = *(__int64 ****)(*a1 + 8 * v3);
    if ( v18 )
    {
      v19 = *((_QWORD *)a2 + 1);
      v20 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      v21 = a2 + 1;
      v22 = *a2;
      v23 = *v18;
      v24 = (v22 & 1) != 0 ? v19 : v22 >> 1;
      for ( i = (v22 & 1) != 0 ? v20 : v21; v23; v23 = (__int64 **)*v23 )
      {
        v26 = (unsigned __int64)v23[1];
        if ( v26 != v14 )
        {
          if ( v17 > 1 )
          {
            if ( v26 >= v15 )
              v26 %= v15;
          }
          else
          {
            v26 &= v15 - 1;
          }
          if ( v26 != v3 )
            break;
        }
        v27 = *((unsigned __int8 *)v23 + 16);
        v28 = (unsigned __int64)v23[3];
        if ( (v27 & 1) == 0 )
          v28 = v27 >> 1;
        if ( v28 == v24 )
        {
          if ( (v27 & 1) != 0 )
            v29 = v23[4];
          else
            v29 = (__int64 *)((char *)v23 + 17);
          if ( (v27 & 1) != 0 )
          {
            if ( !v24 || !memcmp(v29, i, v24) )
              return v23;
          }
          else
          {
            if ( !v24 )
              return v23;
            v30 = 0LL;
            while ( *((unsigned __int8 *)v23 + v30 + 17) == i[v30] )
            {
              if ( v27 >> 1 == ++v30 )
                return v23;
            }
          }
        }
      }
    }
  }
  v31 = a1 + 2;
  v32 = sub_6575418();
  v50 = 0;
  v49[0] = v32;
  v49[1] = a1 + 2;
  sub_67D2788((unsigned __int64 *)(v32 + 16), (__int128 *)a3);
  v33 = *(_OWORD *)(a3 + 40);
  *(_QWORD *)v32 = 0LL;
  *(_QWORD *)(v32 + 8) = v14;
  v34 = a1[3];
  v35 = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(v32 + 56) = v33;
  v36 = *(_OWORD *)(a3 + 72);
  v37 = *(_QWORD *)(a3 + 88);
  *(_OWORD *)(v32 + 72) = v35;
  v38 = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(v32 + 88) = v36;
  v39 = (float)(unsigned __int64)(v34 + 1);
  *(_QWORD *)(v32 + 104) = v37;
  *(_OWORD *)(v32 + 40) = v38;
  v40 = *((float *)a1 + 8);
  v50 = 1;
  if ( !v15 || (float)(v40 * (float)v15) < v39 )
  {
    v41 = v15 < 3 || (v15 & (v15 - 1)) != 0;
    v42 = vcvtps_u32_f32(v39 / v40);
    if ( (v41 | (2 * v15)) >= v42 )
      v43 = v41 | (2 * v15);
    else
      v43 = v42;
    sub_6271F0C(a1, v43);
    v15 = a1[1];
    if ( (v15 & (v15 - 1)) != 0 )
    {
      if ( v14 >= v15 )
        v3 = v14 % v15;
      else
        v3 = v14;
    }
    else
    {
      v3 = (v15 - 1) & v14;
    }
  }
  v44 = *a1;
  v45 = *(__int64 **)(*a1 + 8 * v3);
  if ( v45 )
  {
    *(_QWORD *)v32 = *v45;
    *v45 = v32;
  }
  else
  {
    v46 = *v31;
    *v31 = v32;
    *(_QWORD *)v32 = v46;
    *(_QWORD *)(v44 + 8 * v3) = v31;
    if ( *(_QWORD *)v49[0] )
    {
      v47 = *(_QWORD *)(*(_QWORD *)v49[0] + 8LL);
      if ( (v15 & (v15 - 1)) != 0 )
      {
        if ( v47 >= v15 )
          v47 %= v15;
      }
      else
      {
        v47 &= v15 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v47) = v49[0];
    }
  }
  v23 = (__int64 **)v49[0];
  ++a1[3];
  return v23;
}


================================================================================
Function: sub_6273048 (0x6273048)
================================================================================

_QWORD *__fastcall sub_6273048(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x20
  __int64 v5; // x8
  __int64 v6; // x21
  __int64 i; // x9
  _QWORD *v8; // x22
  _QWORD *v9; // x23
  _QWORD *v10; // x22

  v4 = result;
  v5 = result[1];
  v6 = a2;
  if ( v5 )
  {
    for ( i = 0LL; i != v5; ++i )
      *(_QWORD *)(*result + 8 * i) = 0LL;
    v8 = (_QWORD *)result[2];
    result[2] = 0LL;
    result[3] = 0LL;
    if ( v8 )
    {
      if ( a2 == a3 )
      {
        v9 = v8;
      }
      else
      {
        do
        {
          v9 = (_QWORD *)*v8;
          *((_OWORD *)v8 + 1) = *(_OWORD *)v6;
          *((_DWORD *)v8 + 8) = *(_DWORD *)(v6 + 16);
          result = (_QWORD *)sub_6273160(v4, v8);
          v6 += 24LL;
          if ( !v9 )
            break;
          v8 = v9;
        }
        while ( v6 != a3 );
      }
      if ( v9 )
      {
        do
        {
          v10 = (_QWORD *)*v9;
          result = (_QWORD *)sub_6575460();
          v9 = v10;
        }
        while ( v10 );
      }
    }
  }
  while ( v6 != a3 )
  {
    result = (_QWORD *)sub_62736C0(v4, v6, v6);
    v6 += 24LL;
  }
  return result;
}


================================================================================
Function: sub_6273160 (0x6273160)
================================================================================

_QWORD *__fastcall sub_6273160(__int64 *a1, _QWORD *a2)
{
  _QWORD *v3; // x19
  unsigned __int64 v5; // x1
  char *v6; // x8
  __int64 i; // x9
  __int64 v8; // t1
  __int64 v9; // x0
  int8x8_t v10; // x8
  unsigned __int64 v11; // x10
  uint8x8_t v12; // d0
  _QWORD *v13; // x11
  __int64 v14; // x12
  unsigned __int64 v15; // x10

  v3 = a2;
  v5 = 0LL;
  v6 = (char *)a2[2];
  for ( i = a2[3]; i; v5 ^= (v5 << 6) + (v5 >> 2) + v8 + 2654435769u )
  {
    v8 = *v6++;
    --i;
  }
  v3[1] = v5;
  v9 = sub_6273290(a1);
  if ( !v9 )
  {
    v10.n64_u64[0] = a1[1];
    v11 = v3[1];
    v12.n64_u64[0] = vcnt_s8(v10).n64_u64[0];
    v12.n64_u16[0] = vaddlv_u8(v12);
    if ( v12.n64_u32[0] > 1uLL )
    {
      if ( v11 >= v10.n64_u64[0] )
        v11 %= v10.n64_u64[0];
    }
    else
    {
      v11 &= v10.n64_u64[0] - 1;
    }
    v13 = *(_QWORD **)(*a1 + 8 * v11);
    if ( v13 )
    {
      *v3 = *v13;
    }
    else
    {
      *v3 = a1[2];
      v14 = *a1;
      a1[2] = (__int64)v3;
      *(_QWORD *)(v14 + 8 * v11) = a1 + 2;
      if ( !*v3 )
      {
LABEL_18:
        ++a1[3];
        return v3;
      }
      v15 = *(_QWORD *)(*v3 + 8LL);
      if ( v12.n64_u32[0] > 1uLL )
      {
        if ( v15 >= v10.n64_u64[0] )
          v15 %= v10.n64_u64[0];
      }
      else
      {
        v15 &= v10.n64_u64[0] - 1;
      }
      v13 = (_QWORD *)(*a1 + 8 * v15);
    }
    *v13 = v3;
    goto LABEL_18;
  }
  return (_QWORD *)v9;
}


================================================================================
Function: sub_6273290 (0x6273290)
================================================================================

__int64 **__fastcall sub_6273290(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // x24
  unsigned __int64 v5; // x20
  uint8x8_t v6; // d0
  unsigned __int64 v7; // x25
  __int64 ***v8; // x8
  __int64 **v9; // x21
  const void *v10; // x22
  size_t v11; // x23
  unsigned __int64 v12; // x8
  float v13; // s1
  float v14; // s0
  float v15; // s0
  _BOOL8 v16; // x8
  unsigned __int64 v17; // x8
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x1

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    v5 = a2;
    v6.n64_u64[0] = vcnt_s8((int8x8_t)v4).n64_u64[0];
    v6.n64_u16[0] = vaddlv_u8(v6);
    v7 = v6.n64_u32[0];
    if ( v6.n64_u32[0] > 1uLL )
    {
      if ( v4 <= a2 )
        v5 = a2 % v4;
    }
    else
    {
      v5 = (v4 - 1) & a2;
    }
    v8 = *(__int64 ****)(*(_QWORD *)a1 + 8 * v5);
    if ( v8 )
    {
      v9 = *v8;
      if ( *v8 )
      {
        v10 = *(const void **)a3;
        v11 = *(_QWORD *)(a3 + 8);
        do
        {
          v12 = (unsigned __int64)v9[1];
          if ( v7 > 1 )
          {
            if ( v12 >= v4 )
              v12 %= v4;
          }
          else
          {
            v12 &= v4 - 1;
          }
          if ( v12 != v5 )
            break;
          if ( v9[3] == (__int64 *)v11 && (!v11 || !memcmp(v9[2], v10, v11)) )
            return v9;
          v9 = (__int64 **)*v9;
        }
        while ( v9 );
      }
    }
  }
  v13 = *(float *)(a1 + 32);
  v14 = (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL);
  if ( !v4 || (float)(v13 * (float)v4) < v14 )
  {
    v15 = v14 / v13;
    v16 = 1LL;
    if ( v4 >= 3 )
      v16 = (v4 & (v4 - 1)) != 0;
    v17 = v16 | (2 * v4);
    v18 = vcvtps_u32_f32(v15);
    if ( v17 >= v18 )
      v19 = v17;
    else
      v19 = v18;
    sub_62733E4(a1, v19);
  }
  return 0LL;
}


================================================================================
Function: sub_62733E4 (0x62733E4)
================================================================================

unsigned __int64 __fastcall sub_62733E4(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x24
  unsigned __int64 v10; // x25
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  _QWORD *v13; // x26
  unsigned __int64 v14; // x28
  _QWORD *v15; // x8
  size_t v16; // x21
  const void *v17; // x22
  _QWORD *v18; // x23
  _QWORD *v19; // x27
  unsigned __int64 v20; // [xsp+0h] [xbp-40h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_67A4870(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_67A4870(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_6575418();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_6575460();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = (_QWORD *)*v9;
          if ( *v9 )
          {
            v20 = v11.n64_u32[0];
            do
            {
              v14 = v13[1];
              if ( v12 > 1 )
              {
                if ( v14 >= v3.n64_u64[0] )
                  v14 %= v3.n64_u64[0];
              }
              else
              {
                v14 &= v3.n64_u64[0] - 1;
              }
              if ( v14 == v10 )
              {
                v9 = v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v14) )
              {
                v15 = (_QWORD *)*v13;
                if ( *v13 && (v16 = v13[3], v16 == v15[3]) )
                {
                  v17 = (const void *)v13[2];
                  v18 = v13;
                  while ( 1 )
                  {
                    v19 = v15;
                    if ( v16 )
                    {
                      result = memcmp(v17, (const void *)v15[2], v16);
                      if ( (_DWORD)result )
                        break;
                    }
                    v15 = (_QWORD *)*v19;
                    if ( !*v19 )
                    {
                      v18 = v19;
                      goto LABEL_51;
                    }
                    v18 = v19;
                    if ( v16 != v15[3] )
                      goto LABEL_51;
                  }
                  v15 = v19;
                }
                else
                {
                  v18 = v13;
                }
LABEL_51:
                *v9 = v15;
                v12 = v20;
                *v18 = **(_QWORD **)(v2->n64_u64[0] + 8 * v14);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v14) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v14) = v9;
                v9 = v13;
                v10 = v14;
              }
              v13 = (_QWORD *)*v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_6575460();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62736C0 (0x62736C0)
================================================================================

__int64 __fastcall sub_62736C0(float *a1, const void **a2, __int128 *a3)
{
  unsigned __int64 v3; // x26
  size_t v4; // x22
  const void *v5; // x23
  unsigned __int64 v8; // x25
  char *v9; // x9
  char *v10; // x10
  __int64 v11; // t1
  unsigned __int64 v12; // x24
  uint8x8_t v13; // d0
  unsigned __int64 v14; // x27
  __int64 *v15; // x8
  __int64 i; // x20
  unsigned __int64 v17; // x8
  __int64 v18; // x0
  __int64 v19; // x8
  __int128 v20; // q0
  __int64 v21; // x9
  float v22; // s1
  float v23; // s0
  float v24; // s0
  _BOOL8 v25; // x8
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x1
  __int64 v29; // x8
  __int64 *v30; // x9
  __int64 v31; // x10
  unsigned __int64 v32; // x8

  v5 = *a2;
  v4 = (size_t)a2[1];
  v8 = 0LL;
  if ( v4 )
  {
    v9 = (char *)a2[1];
    v10 = (char *)*a2;
    do
    {
      v11 = *v10++;
      --v9;
      v8 ^= (v8 << 6) + (v8 >> 2) + v11 + 2654435769u;
    }
    while ( v9 );
  }
  v12 = *((_QWORD *)a1 + 1);
  if ( v12 )
  {
    v13.n64_u64[0] = vcnt_s8((int8x8_t)v12).n64_u64[0];
    v13.n64_u16[0] = vaddlv_u8(v13);
    v14 = v13.n64_u32[0];
    if ( v13.n64_u32[0] > 1uLL )
    {
      v3 = v8;
      if ( v8 >= v12 )
        v3 = v8 % v12;
    }
    else
    {
      v3 = (v12 - 1) & v8;
    }
    v15 = *(__int64 **)(*(_QWORD *)a1 + 8 * v3);
    if ( v15 )
    {
      for ( i = *v15; i; i = *(_QWORD *)i )
      {
        v17 = *(_QWORD *)(i + 8);
        if ( v17 != v8 )
        {
          if ( v14 > 1 )
          {
            if ( v17 >= v12 )
              v17 %= v12;
          }
          else
          {
            v17 &= v12 - 1;
          }
          if ( v17 != v3 )
            break;
        }
        if ( *(_QWORD *)(i + 24) == v4 && (!v4 || !memcmp(*(const void **)(i + 16), v5, v4)) )
          return i;
      }
    }
  }
  v18 = sub_6575418();
  v19 = *((_QWORD *)a1 + 3);
  i = v18;
  v20 = *a3;
  *(_QWORD *)v18 = 0LL;
  *(_QWORD *)(v18 + 8) = v8;
  v21 = *((_QWORD *)a3 + 2);
  v22 = a1[8];
  *(_OWORD *)(v18 + 16) = v20;
  *(_QWORD *)(v18 + 32) = v21;
  v23 = (float)(unsigned __int64)(v19 + 1);
  if ( !v12 || (float)(v22 * (float)v12) < v23 )
  {
    v24 = v23 / v22;
    v25 = 1LL;
    if ( v12 >= 3 )
      v25 = (v12 & (v12 - 1)) != 0;
    v26 = v25 | (2 * v12);
    v27 = vcvtps_u32_f32(v24);
    if ( v26 >= v27 )
      v28 = v26;
    else
      v28 = v27;
    sub_62733E4(a1, v28);
    v12 = *((_QWORD *)a1 + 1);
    if ( (v12 & (v12 - 1)) != 0 )
    {
      if ( v8 >= v12 )
        v3 = v8 % v12;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v12 - 1) & v8;
    }
  }
  v29 = *(_QWORD *)a1;
  v30 = *(__int64 **)(*(_QWORD *)a1 + 8 * v3);
  if ( v30 )
  {
    *(_QWORD *)i = *v30;
    *v30 = i;
  }
  else
  {
    v31 = *((_QWORD *)a1 + 2);
    *((_QWORD *)a1 + 2) = i;
    *(_QWORD *)i = v31;
    *(_QWORD *)(v29 + 8 * v3) = a1 + 4;
    if ( *(_QWORD *)i )
    {
      v32 = *(_QWORD *)(*(_QWORD *)i + 8LL);
      if ( (v12 & (v12 - 1)) != 0 )
      {
        if ( v32 >= v12 )
          v32 %= v12;
      }
      else
      {
        v32 &= v12 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v32) = i;
    }
  }
  ++*((_QWORD *)a1 + 3);
  return i;
}


================================================================================
Function: sub_6273940 (0x6273940)
================================================================================

_QWORD *__fastcall sub_6273940(_QWORD *result, __int64 a2, __int64 a3)
{
  _QWORD *v4; // x19
  __int64 v5; // x8
  __int64 v6; // x21
  __int64 i; // x9
  __int64 *v8; // x22
  __int64 v9; // x24
  __int64 *v10; // x23
  __int64 v11; // x25

  v4 = result;
  v5 = result[1];
  v6 = a2;
  if ( v5 )
  {
    for ( i = 0LL; i != v5; ++i )
      *(_QWORD *)(*result + 8 * i) = 0LL;
    v8 = (__int64 *)result[2];
    result[2] = 0LL;
    result[3] = 0LL;
    if ( !v8 || a2 == a3 )
    {
      v10 = v8;
      v11 = a2;
    }
    else
    {
      do
      {
        *((_DWORD *)v8 + 4) = *(_DWORD *)v6;
        sub_67D3420((unsigned __int8 *)v8 + 24, (unsigned __int8 *)(v6 + 8));
        v9 = v6 + 32;
        if ( (__int64 *)(v6 + 32) != v8 + 6 )
          sub_25556AC();
        v10 = (__int64 *)*v8;
        sub_6273A70(v4, v8);
        v11 = v6 + 56;
        if ( !v10 )
          break;
        v6 += 56LL;
        v8 = v10;
      }
      while ( v9 + 24 != a3 );
    }
    result = (_QWORD *)sub_623C140(v4, v10);
    v6 = v11;
  }
  while ( v6 != a3 )
  {
    result = (_QWORD *)sub_62740E0(v4, v6, v6);
    v6 += 56LL;
  }
  return result;
}


================================================================================
Function: sub_6273A70 (0x6273A70)
================================================================================

_QWORD *__fastcall sub_6273A70(__int64 *a1, __int64 a2)
{
  __int64 v2; // x8
  _QWORD *v3; // x19
  unsigned __int64 v5; // x10
  bool v6; // zf
  unsigned __int64 v7; // x10
  char *v8; // x11
  unsigned __int64 v9; // x12
  __int64 v10; // t1
  __int64 v11; // x0
  int8x8_t v12; // x8
  unsigned __int64 v13; // x10
  uint8x8_t v14; // d0
  _QWORD *v15; // x11
  __int64 v16; // x12
  unsigned __int64 v17; // x10

  v2 = 2654435769LL;
  v3 = (_QWORD *)a2;
  v5 = *(unsigned __int8 *)(a2 + 24);
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
  {
    v8 = (char *)(a2 + 25);
  }
  else
  {
    v7 = *(_QWORD *)(a2 + 32);
    v8 = *(char **)(a2 + 40);
  }
  if ( v7 )
  {
    v9 = 0LL;
    do
    {
      v10 = *v8++;
      --v7;
      v9 ^= (v9 << 6) + 2654435769u + (v9 >> 2) + v10;
    }
    while ( v7 );
    v2 = v9 + 2654435769u;
  }
  *(_QWORD *)(a2 + 8) = (((unsigned __int64)(*(int *)(a2 + 16) + 2654435769LL) >> 2)
                       + ((*(int *)(a2 + 16) + 2654435769LL) << 6)
                       + v2) ^ (*(int *)(a2 + 16) + 2654435769LL);
  v11 = sub_6273BD0(a1);
  if ( !v11 )
  {
    v12.n64_u64[0] = a1[1];
    v13 = v3[1];
    v14.n64_u64[0] = vcnt_s8(v12).n64_u64[0];
    v14.n64_u16[0] = vaddlv_u8(v14);
    if ( v14.n64_u32[0] > 1uLL )
    {
      if ( v13 >= v12.n64_u64[0] )
        v13 %= v12.n64_u64[0];
    }
    else
    {
      v13 &= v12.n64_u64[0] - 1;
    }
    v15 = *(_QWORD **)(*a1 + 8 * v13);
    if ( v15 )
    {
      *v3 = *v15;
    }
    else
    {
      *v3 = a1[2];
      v16 = *a1;
      a1[2] = (__int64)v3;
      *(_QWORD *)(v16 + 8 * v13) = a1 + 2;
      if ( !*v3 )
      {
LABEL_23:
        ++a1[3];
        return v3;
      }
      v17 = *(_QWORD *)(*v3 + 8LL);
      if ( v14.n64_u32[0] > 1uLL )
      {
        if ( v17 >= v12.n64_u64[0] )
          v17 %= v12.n64_u64[0];
      }
      else
      {
        v17 &= v12.n64_u64[0] - 1;
      }
      v15 = (_QWORD *)(*a1 + 8 * v17);
    }
    *v15 = v3;
    goto LABEL_23;
  }
  return (_QWORD *)v11;
}


================================================================================
Function: sub_6273BD0 (0x6273BD0)
================================================================================

__int64 *__fastcall sub_6273BD0(unsigned __int64 a1, unsigned __int64 a2, int *a3)
{
  unsigned __int64 v4; // x24
  unsigned __int64 v5; // x20
  uint8x8_t v6; // d0
  unsigned __int64 v7; // x25
  __int64 **v8; // x8
  unsigned __int64 v9; // x9
  __int64 *v10; // x21
  size_t v11; // x22
  unsigned __int8 *v12; // x23
  int v13; // w27
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x11
  const void *v17; // x0
  __int64 v18; // x9
  float v19; // s1
  float v20; // s0
  float v21; // s0
  _BOOL8 v22; // x8
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x1

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    v5 = a2;
    v6.n64_u64[0] = vcnt_s8((int8x8_t)v4).n64_u64[0];
    v6.n64_u16[0] = vaddlv_u8(v6);
    v7 = v6.n64_u32[0];
    if ( v6.n64_u32[0] > 1uLL )
    {
      if ( v4 <= a2 )
        v5 = a2 % v4;
    }
    else
    {
      v5 = (v4 - 1) & a2;
    }
    v8 = *(__int64 ***)(*(_QWORD *)a1 + 8 * v5);
    if ( v8 )
    {
      v9 = *((unsigned __int8 *)a3 + 8);
      v10 = *v8;
      v11 = (v9 & 1) != 0 ? *((_QWORD *)a3 + 2) : v9 >> 1;
      v12 = (v9 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a3 + 3) : (unsigned __int8 *)a3 + 9;
      if ( v10 )
      {
        v13 = *a3;
        do
        {
          v14 = v10[1];
          if ( v7 > 1 )
          {
            if ( v14 >= v4 )
              v14 %= v4;
          }
          else
          {
            v14 &= v4 - 1;
          }
          if ( v14 != v5 )
            break;
          if ( *((_DWORD *)v10 + 4) == v13 )
          {
            v15 = *((unsigned __int8 *)v10 + 24);
            v16 = v10[4];
            if ( (v15 & 1) == 0 )
              v16 = v15 >> 1;
            if ( v16 == v11 )
            {
              if ( (v15 & 1) != 0 )
                v17 = (const void *)v10[5];
              else
                v17 = (char *)v10 + 25;
              if ( (v15 & 1) != 0 )
              {
                if ( !v11 || !memcmp(v17, v12, v11) )
                  return v10;
              }
              else
              {
                if ( !v11 )
                  return v10;
                v18 = 0LL;
                while ( *((unsigned __int8 *)v10 + v18 + 25) == v12[v18] )
                {
                  if ( v15 >> 1 == ++v18 )
                    return v10;
                }
              }
            }
          }
          v10 = (__int64 *)*v10;
        }
        while ( v10 );
      }
    }
  }
  v19 = *(float *)(a1 + 32);
  v20 = (float)(unsigned __int64)(*(_QWORD *)(a1 + 24) + 1LL);
  if ( !v4 || (float)(v19 * (float)v4) < v20 )
  {
    v21 = v20 / v19;
    v22 = 1LL;
    if ( v4 >= 3 )
      v22 = (v4 & (v4 - 1)) != 0;
    v23 = v22 | (2 * v4);
    v24 = vcvtps_u32_f32(v21);
    if ( v23 >= v24 )
      v25 = v23;
    else
      v25 = v24;
    sub_6273DA0(a1, v25);
  }
  return 0LL;
}


================================================================================
Function: sub_6273DA0 (0x6273DA0)
================================================================================

unsigned __int64 __fastcall sub_6273DA0(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  __int64 **v9; // x21
  unsigned __int64 v10; // x23
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x10
  __int64 *v13; // x25
  unsigned __int64 v14; // x11
  unsigned __int64 v15; // x26
  __int64 *v16; // x8
  int v17; // w22
  __int64 *v18; // x27
  __int64 *v19; // x28
  unsigned __int64 v20; // x10
  unsigned __int64 v21; // x11
  unsigned __int64 v22; // x8
  size_t v23; // x2
  unsigned __int64 v24; // x12
  unsigned __int8 *v25; // x1
  unsigned __int8 *v26; // x9
  unsigned __int64 v27; // [xsp+8h] [xbp-38h]

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_67A4870(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_67A4870(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_6575418();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_6575460();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (__int64 **)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = (unsigned __int64)v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          v12 = v11.n64_u32[0];
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          v13 = *v9;
          if ( *v9 )
          {
            v14 = v3.n64_u64[0] - 1;
            v27 = v11.n64_u32[0];
            do
            {
              v15 = v13[1];
              if ( v12 > 1 )
              {
                if ( v15 >= v3.n64_u64[0] )
                  v15 %= v3.n64_u64[0];
              }
              else
              {
                v15 &= v14;
              }
              if ( v15 == v10 )
              {
                v9 = (__int64 **)v13;
              }
              else if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v15) )
              {
                v16 = (__int64 *)*v13;
                if ( *v13 )
                {
                  v17 = *((_DWORD *)v13 + 4);
                  v18 = v13;
                  while ( 1 )
                  {
                    v19 = v18;
                    v18 = v16;
                    if ( v17 != *((_DWORD *)v16 + 4) )
                      break;
                    v20 = *((unsigned __int8 *)v13 + 24);
                    v21 = *((unsigned __int8 *)v16 + 24);
                    v22 = v20 >> 1;
                    if ( (v20 & 1) != 0 )
                      v23 = v13[4];
                    else
                      v23 = v20 >> 1;
                    v24 = v21 >> 1;
                    if ( (v21 & 1) != 0 )
                      v24 = v18[4];
                    if ( v23 != v24 )
                      break;
                    if ( (v20 & 1) != 0 )
                      result = v13[5];
                    else
                      result = (unsigned __int64)v13 + 25;
                    if ( (v21 & 1) != 0 )
                      v25 = (unsigned __int8 *)v18[5];
                    else
                      v25 = (unsigned __int8 *)v18 + 25;
                    if ( (v20 & 1) != 0 )
                    {
                      if ( v23 )
                      {
                        result = memcmp((const void *)result, v25, v23);
                        if ( (_DWORD)result )
                          break;
                      }
                    }
                    else
                    {
                      v26 = (unsigned __int8 *)v13 + 25;
                      if ( v23 )
                      {
                        while ( *v26 == *v25 )
                        {
                          --v22;
                          ++v26;
                          ++v25;
                          if ( !v22 )
                            goto LABEL_44;
                        }
                        break;
                      }
                    }
LABEL_44:
                    v16 = (__int64 *)*v18;
                    if ( !*v18 )
                    {
                      v19 = v18;
                      v18 = 0LL;
                      break;
                    }
                  }
                  v14 = v3.n64_u64[0] - 1;
                  v12 = v27;
                }
                else
                {
                  v18 = 0LL;
                  v19 = v13;
                }
                *v9 = v18;
                *v19 = **(_QWORD **)(v2->n64_u64[0] + 8 * v15);
                **(_QWORD **)(v2->n64_u64[0] + 8 * v15) = v13;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v15) = v9;
                v9 = (__int64 **)v13;
                v10 = v15;
              }
              v13 = *v9;
            }
            while ( *v9 );
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_6575460();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62740E0 (0x62740E0)
================================================================================

__int64 __fastcall sub_62740E0(__int64 *a1, int *a2, __int64 a3)
{
  unsigned __int64 v3; // x27
  __int64 v4; // x8
  unsigned __int64 v7; // x9
  __int64 v8; // x28
  bool v9; // zf
  size_t v10; // x9
  size_t v11; // x21
  unsigned __int64 v12; // x9
  char *v13; // x22
  unsigned __int64 v14; // x10
  size_t v15; // x11
  char *v16; // x12
  __int64 v17; // t1
  unsigned __int64 v18; // x25
  __int64 v19; // x8
  unsigned __int64 v20; // x26
  uint8x8_t v21; // d0
  unsigned __int64 v22; // x13
  __int64 *v23; // x8
  __int64 v24; // x23
  unsigned __int64 v25; // x12
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x11
  const void *v29; // x0
  __int64 v30; // x9
  __int64 v31; // x24
  unsigned __int64 v32; // x20
  unsigned __int64 v33; // x27
  int v34; // w0
  __int64 *v35; // x23
  __int64 v36; // x21
  __int64 v37; // x8
  float v38; // s1
  float v39; // s0
  _BOOL8 v40; // x9
  unsigned __int64 v41; // x10
  __int64 v42; // x1
  __int64 v43; // x8
  __int64 *v44; // x9
  __int64 v45; // x9
  unsigned __int64 v46; // x9
  unsigned __int64 v48; // [xsp+8h] [xbp-28h]

  v4 = 2654435769LL;
  v7 = *((unsigned __int8 *)a2 + 8);
  v8 = *a2;
  v9 = (v7 & 1) == 0;
  v10 = v7 >> 1;
  if ( v9 )
    v11 = v10;
  else
    v11 = *((_QWORD *)a2 + 2);
  v12 = v8 + 2654435769LL;
  if ( v9 )
    v13 = (char *)a2 + 9;
  else
    v13 = (char *)*((_QWORD *)a2 + 3);
  if ( v11 )
  {
    v14 = 0LL;
    v15 = v11;
    v16 = v13;
    do
    {
      v17 = *v16++;
      --v15;
      v14 ^= (v14 << 6) + 2654435769u + (v14 >> 2) + v17;
    }
    while ( v15 );
    v4 = v14 + 2654435769u;
  }
  v18 = a1[1];
  v19 = (v12 >> 2) + (v12 << 6) + v4;
  v20 = v19 ^ v12;
  if ( v18 )
  {
    v21.n64_u64[0] = vcnt_s8((int8x8_t)v18).n64_u64[0];
    v21.n64_u16[0] = vaddlv_u8(v21);
    v22 = v21.n64_u32[0];
    if ( v21.n64_u32[0] > 1uLL )
    {
      v3 = v19 ^ v12;
      if ( v20 >= v18 )
        v3 = v20 % v18;
    }
    else
    {
      v3 = (v18 - 1) & v20;
    }
    v23 = *(__int64 **)(*a1 + 8 * v3);
    if ( v23 )
    {
      v24 = *v23;
      if ( *v23 )
      {
        v25 = v18 - 1;
        v48 = v3;
        do
        {
          v26 = *(_QWORD *)(v24 + 8);
          if ( v26 != v20 )
          {
            if ( v22 > 1 )
            {
              if ( v26 >= v18 )
                v26 %= v18;
            }
            else
            {
              v26 &= v25;
            }
            if ( v26 != v3 )
              break;
          }
          if ( *(_DWORD *)(v24 + 16) == (_DWORD)v8 )
          {
            v27 = *(unsigned __int8 *)(v24 + 24);
            v28 = *(_QWORD *)(v24 + 32);
            if ( (v27 & 1) == 0 )
              v28 = v27 >> 1;
            if ( v28 == v11 )
            {
              if ( (v27 & 1) != 0 )
                v29 = *(const void **)(v24 + 40);
              else
                v29 = (const void *)(v24 + 25);
              if ( (v27 & 1) != 0 )
              {
                if ( !v11 )
                  return v24;
                v31 = a3;
                v32 = v25;
                v33 = v22;
                v34 = memcmp(v29, v13, v11);
                v22 = v33;
                v3 = v48;
                v25 = v32;
                a3 = v31;
                if ( !v34 )
                  return v24;
              }
              else
              {
                if ( !v11 )
                  return v24;
                v30 = 0LL;
                while ( *(unsigned __int8 *)(v24 + v30 + 25) == (unsigned __int8)v13[v30] )
                {
                  if ( v27 >> 1 == ++v30 )
                    return v24;
                }
              }
            }
          }
          v24 = *(_QWORD *)v24;
        }
        while ( v24 );
      }
    }
  }
  v35 = a1 + 2;
  v36 = sub_6575418();
  *(_DWORD *)(v36 + 16) = *(_DWORD *)a3;
  sub_67D2788((unsigned __int64 *)(v36 + 24), (__int128 *)(a3 + 8));
  sub_2513400((__int64 *)(v36 + 48), (__int128 **)(a3 + 32));
  v37 = a1[3];
  v38 = *((float *)a1 + 8);
  *(_QWORD *)v36 = 0LL;
  *(_QWORD *)(v36 + 8) = v20;
  v39 = (float)(unsigned __int64)(v37 + 1);
  if ( !v18 || (float)(v38 * (float)v18) < v39 )
  {
    v40 = v18 < 3 || (v18 & (v18 - 1)) != 0;
    v41 = vcvtps_u32_f32(v39 / v38);
    if ( (v40 | (2 * v18)) >= v41 )
      v42 = v40 | (2 * v18);
    else
      v42 = v41;
    sub_6273DA0(a1, v42);
    v18 = a1[1];
    if ( (v18 & (v18 - 1)) != 0 )
    {
      if ( v20 >= v18 )
        v3 = v20 % v18;
      else
        v3 = v20;
    }
    else
    {
      v3 = (v18 - 1) & v20;
    }
  }
  v43 = *a1;
  v44 = *(__int64 **)(*a1 + 8 * v3);
  if ( v44 )
  {
    *(_QWORD *)v36 = *v44;
    *v44 = v36;
  }
  else
  {
    v45 = *v35;
    *v35 = v36;
    *(_QWORD *)v36 = v45;
    *(_QWORD *)(v43 + 8 * v3) = v35;
    if ( *(_QWORD *)v36 )
    {
      v46 = *(_QWORD *)(*(_QWORD *)v36 + 8LL);
      if ( (v18 & (v18 - 1)) != 0 )
      {
        if ( v46 >= v18 )
          v46 %= v18;
      }
      else
      {
        v46 &= v18 - 1;
      }
      *(_QWORD *)(*a1 + 8 * v46) = v36;
    }
  }
  v24 = v36;
  ++a1[3];
  return v24;
}


================================================================================
Function: sub_62759D8 (0x62759D8)
================================================================================

__int64 sub_62759D8()
{
  unsigned __int8 v0; // w8
  _QWORD *v1; // x19
  __int64 v2; // x20

  v0 = atomic_load(byte_6C38350);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6C38350) )
  {
    qword_6C38310 = (__int64)off_67F87E8;
    sub_67D19DC((pthread_mutex_t *)algn_6C38318);
    qword_6C38340 = 0LL;
    unk_6C38348 = 0LL;
    qword_6C38310 = (__int64)off_67FAA40;
    qword_6C38358 = (__int64)&qword_6C38310;
    sub_67EB838(byte_6C38350);
  }
  v1 = (_QWORD *)sub_25138D8((__int64)&qword_6C38310);
  v2 = sub_62384D0(v1[6]);
  (*(void (__fastcall **)(_QWORD *))(*v1 + 16LL))(v1);
  return v2;
}


================================================================================
Function: sub_6278208 (0x6278208)
================================================================================

_QWORD *__fastcall sub_6278208(__int64 a1, __int64 a2)
{
  unsigned int v3; // w1
  _QWORD *result; // x0
  _QWORD v5[7]; // [xsp+0h] [xbp-40h] BYREF

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 80) = a2;
  v3 = pthread_mutex_init((pthread_mutex_t *)(a1 + 88), 0LL);
  if ( v3 )
  {
    sub_25A21C8(v5, v3, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v5);
  }
  sub_25A1F60(a1 + 128);
  result = sub_6766848((_QWORD *)(a1 + 216));
  *(_QWORD *)(a1 + 237) = 0LL;
  *(_QWORD *)(a1 + 232) = 0LL;
  return result;
}


================================================================================
Function: sub_627AC2C (0x627AC2C)
================================================================================

__int64 __usercall sub_627AC2C@<X0>(__int64 a1@<X8>)
{
  __int64 v2; // x20

  v2 = sub_6575418();
  sub_627F6A8();
  return sub_627F99C(a1, v2);
}


================================================================================
Function: sub_627CB6C (0x627CB6C)
================================================================================

__int64 __fastcall sub_627CB6C(__int64 a1, int a2)
{
  __int64 v4; // x6
  __int64 v5; // x7
  long double v6; // q1
  long double v7; // q2
  long double v8; // q3
  unsigned __int8 v9; // w8
  __int64 result; // x0
  __int64 v11; // x1
  char v12; // w11
  int v13; // w10
  unsigned int v14; // w8
  __int64 vars0; // [xsp+0h] [xbp+0h]

  sub_6255394();
  *(_BYTE *)(a1 + 888) = 0;
  *(_QWORD *)a1 = off_6BA61A8;
  *(_OWORD *)(a1 + 872) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 928) = 0u;
  *(_OWORD *)(a1 + 944) = 0u;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(_OWORD *)(a1 + 1008) = 0u;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_OWORD *)(a1 + 1104) = 0u;
  *(_OWORD *)(a1 + 1120) = 0u;
  *(_OWORD *)(a1 + 1136) = 0u;
  *(_OWORD *)(a1 + 1152) = 0u;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(_OWORD *)(a1 + 1184) = 0u;
  *(_OWORD *)(a1 + 1200) = 0u;
  *(_DWORD *)(a1 + 1216) = 0;
  v9 = atomic_load(byte_6F78430);
  *(_DWORD *)(a1 + 448) = a2;
  result = qword_6F77A80;
  v11 = qword_6F77A88;
  v12 = v9 & 1;
  v13 = (unsigned __int8)byte_71CF7B0;
  v14 = (unsigned __int8)qword_6F77A80;
  *(_BYTE *)(a1 + 1220) = v12;
  if ( !v13 || !byte_71CF760 )
  {
    if ( !v14 )
      return result;
    return sub_654E814(
             result,
             v11,
             "[DFLog::HttpTrace] HttpRequestCurl(%p, %d, %d)",
             a1,
             *(unsigned __int8 *)(a1 + 709),
             *(unsigned int *)(a1 + 328),
             v4,
             v5,
             COERCE_LONG_DOUBLE((unsigned __int128)0LL),
             v6,
             v7,
             v8,
             vars0);
  }
  if ( v14 >= 6 && BYTE1(result) >= 3u )
    return sub_654E814(
             result,
             v11,
             "[DFLog::HttpTrace] HttpRequestCurl(%p, %d, %d)",
             a1,
             *(unsigned __int8 *)(a1 + 709),
             *(unsigned int *)(a1 + 328),
             v4,
             v5,
             COERCE_LONG_DOUBLE((unsigned __int128)0LL),
             v6,
             v7,
             v8,
             vars0);
  return result;
}


================================================================================
Function: sub_627F6A8 (0x627F6A8)
================================================================================

__int64 __fastcall sub_627F6A8(__int64 a1)
{
  unsigned int v2; // w1
  unsigned int v3; // w1
  unsigned int v4; // w1
  _QWORD v6[7]; // [xsp+10h] [xbp-40h] BYREF

  v2 = pthread_mutex_init((pthread_mutex_t *)a1, 0LL);
  if ( v2
    || (v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 40), 0LL)) != 0
    || (v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 80), 0LL)) != 0
    || (v2 = pthread_mutex_init((pthread_mutex_t *)(a1 + 120), 0LL)) != 0 )
  {
    sub_25A21C8(v6, v2, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v6);
  }
  v3 = pthread_mutex_init((pthread_mutex_t *)(a1 + 160), 0LL);
  if ( v3 )
  {
    sub_25A21C8(v6, v3, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v6);
  }
  *(_QWORD *)(a1 + 208) = 0LL;
  *(_QWORD *)(a1 + 200) = a1 + 208;
  *(_QWORD *)(a1 + 216) = 0LL;
  *(_QWORD *)(a1 + 240) = 0LL;
  *(_QWORD *)(a1 + 232) = a1 + 240;
  *(_QWORD *)(a1 + 264) = 0LL;
  *(_QWORD *)(a1 + 256) = a1 + 264;
  *(_QWORD *)(a1 + 248) = 0LL;
  *(_QWORD *)(a1 + 272) = 0LL;
  *(_DWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 296) = a1 + 296;
  *(_QWORD *)(a1 + 304) = a1 + 296;
  *(_BYTE *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 312) = 0LL;
  v4 = pthread_mutex_init((pthread_mutex_t *)(a1 + 320), 0LL);
  if ( v4 )
  {
    sub_25A21C8(v6, v4, "boost:: mutex constructor failed in pthread_mutex_init");
    sub_25A2098((__int64)v6);
  }
  *(_QWORD *)(a1 + 368) = 0LL;
  *(_QWORD *)(a1 + 376) = 0LL;
  *(_QWORD *)(a1 + 360) = a1 + 368;
  sub_66F097C(sub_627FA0C, sub_627FA6C, sub_627FADC);
  sub_6284FD0(7LL, sub_627FAE0, sub_627FD3C, sub_627FD7C, sub_627FE60, sub_627FEB0);
  sub_627FF1C(a1);
  sub_627FFEC(a1, 0LL);
  return sub_6280170(a1);
}


================================================================================
Function: sub_627F99C (0x627F99C)
================================================================================

_QWORD *__fastcall sub_627F99C(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // x0

  *a1 = a2;
  result = (_QWORD *)sub_6575418();
  result[2] = 0LL;
  result[3] = a2;
  a1[1] = result;
  *result = off_6BA6238;
  result[1] = 0LL;
  return result;
}


================================================================================
Function: sub_627FF1C (0x627FF1C)
================================================================================

__int64 __fastcall sub_627FF1C(pthread_mutex_t *a1)
{
  __int64 result; // x0
  pthread_mutex_t *v2; // x19
  _QWORD v3[7]; // [xsp+0h] [xbp-50h] BYREF
  pthread_mutex_t *v4; // [xsp+38h] [xbp-18h] BYREF
  char v5; // [xsp+40h] [xbp-10h]

  v4 = a1 + 4;
  v5 = 0;
  sub_25A70B8(&v4);
  result = sub_66E313C(sub_6280650);
  if ( v5 )
  {
    v2 = v4;
    do
      result = pthread_mutex_unlock(v2);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25A6430(v3, result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300((__int64)v3);
    }
  }
  return result;
}


================================================================================
Function: sub_627FFEC (0x627FFEC)
================================================================================

__int64 __fastcall sub_627FFEC(_QWORD *a1, int a2)
{
  __int64 v4; // x19
  unsigned int v5; // w0
  unsigned int v6; // w0
  unsigned int v7; // w0
  unsigned int v8; // w0
  __int64 result; // x0
  __int64 *v10; // x23
  _QWORD *v11; // x24
  int v12; // w8
  __int64 v13; // x22
  __int64 v14; // x0
  __int64 *v15; // x8
  __int64 v16; // x8
  __int64 v17; // x1

  v4 = sub_62B9338();
  v5 = sub_62B9394(v4, 5LL, a1);
  sub_6280724("CURLSHOPT_USERDATA", v5, 1LL);
  v6 = sub_62B9394(v4, 3LL, sub_6280838);
  sub_6280724("CURLSHOPT_LOCKFUNC", v6, 1LL);
  v7 = sub_62B9394(v4, 4LL, sub_628099C);
  sub_6280724("CURLSHOPT_UNLOCKFUNC", v7, 1LL);
  v8 = sub_62B9394(v4, 1LL, 2LL);
  result = sub_6280724("CURLSHOPT_SHARE", v8, 1LL);
  v10 = a1 + 26;
  v11 = (_QWORD *)a1[26];
  if ( v11 )
  {
    v10 = a1 + 26;
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = *((_DWORD *)v11 + 8);
        if ( v12 > a2 )
          break;
        if ( v12 >= a2 )
          goto LABEL_10;
        v10 = v11 + 1;
        if ( !v11[1] )
          goto LABEL_10;
        v11 = (_QWORD *)v11[1];
      }
      if ( !*v11 )
        break;
      v10 = v11;
      v11 = (_QWORD *)*v11;
    }
    v10 = v11;
    goto LABEL_11;
  }
  v11 = a1 + 26;
LABEL_10:
  v13 = *v10;
  if ( !*v10 )
  {
LABEL_11:
    v14 = sub_6575418();
    *(_QWORD *)(v14 + 40) = 0LL;
    v13 = v14;
    *(_QWORD *)v14 = 0LL;
    *(_QWORD *)(v14 + 8) = 0LL;
    *(_QWORD *)(v14 + 16) = v11;
    *v10 = v14;
    v15 = (__int64 *)a1[25];
    *(_DWORD *)(v14 + 32) = a2;
    v16 = *v15;
    if ( v16 )
    {
      a1[25] = v16;
      v17 = *v10;
    }
    else
    {
      v17 = v14;
    }
    result = sub_2507ED0(a1[26], v17);
    ++a1[27];
  }
  *(_QWORD *)(v13 + 40) = v4;
  return result;
}


================================================================================
Function: sub_6280170 (0x6280170)
================================================================================

__int64 __fastcall sub_6280170(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x19
  _QWORD *v4; // x22
  _QWORD *v5; // x23
  _QWORD *v6; // x21
  _QWORD *v7; // x0
  __int64 v8; // x8
  _QWORD *v9; // x1

  result = sub_62AB7A8();
  v3 = result;
  v4 = (_QWORD *)(a1 + 240);
  v5 = *(_QWORD **)(a1 + 240);
  *(_QWORD *)(a1 + 224) = result;
  if ( v5 )
  {
    if ( !v5[4] )
    {
      v4 = (_QWORD *)(a1 + 240);
      v6 = *(_QWORD **)(a1 + 240);
      if ( v6 )
        goto LABEL_14;
      goto LABEL_8;
    }
    while ( 1 )
    {
      v4 = v5;
      v5 = (_QWORD *)*v5;
      if ( !v5 )
        break;
      if ( !v5[4] )
        goto LABEL_7;
    }
  }
  v5 = v4;
LABEL_7:
  v6 = (_QWORD *)*v4;
  if ( !*v4 )
  {
LABEL_8:
    v7 = (_QWORD *)sub_6575418();
    *v7 = 0LL;
    v7[1] = 0LL;
    v6 = v7;
    v7[4] = 0LL;
    v7[5] = 0LL;
    v7[2] = v5;
    *v4 = v7;
    v8 = **(_QWORD **)(a1 + 232);
    if ( v8 )
    {
      *(_QWORD *)(a1 + 232) = v8;
      v9 = (_QWORD *)*v4;
    }
    else
    {
      v9 = v7;
    }
    result = sub_2507ED0(*(_QWORD *)(a1 + 240), v9);
    ++*(_QWORD *)(a1 + 248);
  }
LABEL_14:
  v6[5] = v3;
  return result;
}


================================================================================
Function: sub_6280724 (0x6280724)
================================================================================

bool __fastcall sub_6280724(
        __int64 a1,
        unsigned int a2,
        char a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  __int64 v15; // [xsp+0h] [xbp+0h]

  if ( !a2 )
  {
    if ( byte_71CF7B0 && byte_71CF760 )
    {
      if ( (unsigned __int8)qword_6F77A80 < 6u || BYTE1(qword_6F77A80) < 3u )
        return a2 != 0;
    }
    else if ( !(_BYTE)qword_6F77A80 )
    {
      return a2 != 0;
    }
    sub_654E814(
      qword_6F77A80,
      qword_6F77A88,
      "[DFLog::HttpTrace] HttpRequestCurl curl op:%s",
      a1,
      a9,
      a10,
      a11,
      a12,
      a4,
      a5,
      a6,
      a7,
      v15);
    return a2 != 0;
  }
  if ( !byte_71CF7B0 || !byte_71CF760 )
  {
    if ( !(_BYTE)qword_6F77AC0 )
      goto LABEL_14;
    goto LABEL_13;
  }
  if ( (unsigned __int8)qword_6F77AC0 >= 6u && BYTE1(qword_6F77AC0) >= 3u )
LABEL_13:
    sub_654E814(
      qword_6F77AC0,
      qword_6F77AC8,
      "[DFLog::HttpTraceError] HttpRequestCurl curl error:%d op:%s",
      a2,
      a1,
      a10,
      a11,
      a12,
      a4,
      a5,
      a6,
      a7,
      v15);
LABEL_14:
  if ( (a3 & 1) != 0 )
    sub_6579C34("HttpRequestCurl curl error:%d op:%s");
  return a2 != 0;
}


================================================================================
Function: sub_6284FD0 (0x6284FD0)
================================================================================

__int64 __fastcall sub_6284FD0(
        __int64 a1,
        __int64 (__fastcall *a2)(),
        __int64 (__fastcall *a3)(),
        __int64 (__fastcall *a4)(),
        void *a5,
        __int64 (__fastcall *a6)())
{
  __int64 result; // x0
  int v12; // w8

  result = 2LL;
  if ( a2 && a3 && a4 && a5 && a6 )
  {
    while ( (unsigned int)sub_67F01A0(1LL, &dword_6F79500) )
    {
      while ( dword_6F79500 )
        __yield();
    }
    if ( dword_6F79504 )
    {
      result = 0LL;
      v12 = dword_6F79504 + 1;
    }
    else
    {
      off_6C2D118[0] = a2;
      off_6C2D120[0] = a3;
      off_6C2D130 = a5;
      off_6C2D128 = a4;
      off_6C2D138 = a6;
      dword_6F79504 = 1;
      if ( !(unsigned int)sub_6285F9C() )
      {
        if ( (unsigned int)sub_62C8664() )
        {
          result = sub_628DF98();
          if ( !(_DWORD)result )
            goto LABEL_16;
        }
      }
      result = 2LL;
      v12 = dword_6F79504 - 1;
    }
    dword_6F79504 = v12;
LABEL_16:
    atomic_store(0, (unsigned int *)&dword_6F79500);
  }
  return result;
}


================================================================================
Function: sub_6285170 (0x6285170)
================================================================================

__int64 sub_6285170()
{
  __int64 result; // x0
  __int64 v1; // [xsp+0h] [xbp-10h] BYREF

  while ( (unsigned int)sub_67F01A0(1u, (atomic_uint *)&dword_6F79500) )
  {
    while ( dword_6F79500 )
      __yield();
  }
  if ( !dword_6F79504
    && ((off_6C2D118[0] = (__int64 (__fastcall *)())sub_677CA08,
         off_6C2D120[0] = (__int64 (__fastcall *)())sub_677CBEC,
         off_6C2D128 = (__int64 (__fastcall *)())sub_677CB8C,
         off_6C2D130 = (char *(*)(const char *))&strdup,
         dword_6F79504 = 1,
         off_6C2D138 = (__int64 (__fastcall *)(_QWORD, _QWORD))sub_677CAA8,
         (unsigned int)sub_6285F9C())
     || !(unsigned int)sub_62C8664()
     || (unsigned int)sub_628DF98()) )
  {
    result = 0LL;
    --dword_6F79504;
    atomic_store(0, (unsigned int *)&dword_6F79500);
  }
  else
  {
    atomic_store(0, (unsigned int *)&dword_6F79500);
    if ( (unsigned int)sub_62BDADC(&v1) )
      return 0LL;
    else
      return v1;
  }
  return result;
}


================================================================================
Function: sub_6285740 (0x6285740)
================================================================================

size_t __fastcall sub_6285740(size_t result, unsigned int a2, const void *a3, size_t a4)
{
  size_t v6; // x19
  char v8; // w23

  if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
  {
    v6 = result;
    if ( *(_QWORD *)(result + 616) )
    {
      v8 = sub_62AE9A8(result);
      sub_62AE97C(v6, 1LL);
      (*(void (__fastcall **)(size_t, _QWORD, const void *, size_t, _QWORD))(v6 + 616))(
        v6,
        a2,
        a3,
        a4,
        *(_QWORD *)(v6 + 464));
      return sub_62AE97C(v6, v8 & 1);
    }
    else if ( a2 <= 2 )
    {
      fwrite(&asc_16A9898[3 * a2], 2uLL, 1uLL, *(FILE **)(result + 456));
      return fwrite(a3, a4, 1uLL, *(FILE **)(v6 + 456));
    }
  }
  return result;
}


================================================================================
Function: sub_6285834 (0x6285834)
================================================================================

size_t sub_6285834(size_t result, __int64 a2, ...)
{
  size_t v2; // x19
  int v3; // w20
  gcc_va_list va1; // [xsp+B0h] [xbp-150h] BYREF
  gcc_va_list va; // [xsp+D0h] [xbp-130h] BYREF
  char src[260]; // [xsp+F4h] [xbp-10Ch] BYREF

  v2 = result;
  if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 || *(_QWORD *)(result + 472) )
  {
    va_start(va, a2);
    va_copy(va1, va);
    v3 = sub_62A9DA8(src, 256LL, a2, (__int128 *)va1);
    if ( *(_QWORD *)(v2 + 472) )
    {
      if ( (*(_BYTE *)(v2 + 4692) & 8) == 0 )
      {
        strcpy(*(char **)(v2 + 472), src);
        *(_DWORD *)(v2 + 4692) |= 8u;
      }
    }
    *(_WORD *)&src[v3] = 10;
    return sub_6285740(v2, 0, src, v3 + 1LL);
  }
  return result;
}


================================================================================
Function: sub_628595C (0x628595C)
================================================================================

__int64 __fastcall sub_628595C(
        __int64 result,
        const char *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x19
  __int64 v11; // x8
  const char **v12; // x8
  int v13; // w21
  int v14; // w8
  int v15; // w9
  _BYTE *v16; // x11
  _QWORD v17[6]; // [xsp+80h] [xbp-8A0h] BYREF
  __int128 v18; // [xsp+B0h] [xbp-870h] BYREF
  __int128 v19; // [xsp+C0h] [xbp-860h]
  __int128 v20; // [xsp+D0h] [xbp-850h]
  __int128 v21; // [xsp+E0h] [xbp-840h]
  _OWORD v22[2]; // [xsp+F0h] [xbp-830h] BYREF
  _BYTE v23[2056]; // [xsp+110h] [xbp-810h] BYREF

  v17[3] = a6;
  v17[4] = a7;
  v17[1] = a4;
  v17[2] = a5;
  v17[0] = a3;
  v17[5] = a8;
  if ( result )
  {
    v9 = result;
    if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
    {
      v11 = *(_QWORD *)(result + 4576);
      if ( !v11 || *(int *)(v11 + 8) >= 1 )
      {
        *(_QWORD *)&v20 = &a9;
        *((_QWORD *)&v20 + 1) = &v18;
        v12 = *(const char ***)(result + 4576);
        *(_QWORD *)&v21 = v17;
        *((_QWORD *)&v21 + 1) = 0xFFFFFF80FFFFFFD0LL;
        v18 = v20;
        v19 = v21;
        if ( v12 )
          v13 = sub_62AB108(v23, 2049LL, "[%s] ", *v12);
        else
          v13 = 0;
        v22[0] = v18;
        v22[1] = v19;
        v14 = sub_62A9DA8(&v23[v13], 2049 - v13, a2, v22) + v13;
        if ( v14 >= 2048 )
        {
          v15 = v14 - 1;
          v16 = &v23[v14];
          v14 += 2;
          v23[v15] = 46;
          *v16 = 46;
          v16[1] = 46;
        }
        *(_WORD *)&v23[v14] = 10;
        return sub_6285740(v9, 0LL, v23, v14 + 1LL);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6285ACC (0x6285ACC)
================================================================================

size_t __fastcall sub_6285ACC(
        size_t result,
        const char ***a2,
        const char *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  size_t v9; // x19
  __int64 v12; // x8
  int v13; // w0
  __int64 v14; // x23
  int v15; // w4
  __int64 v16; // x1
  const char *v17; // x3
  int v18; // w0
  __int64 v19; // x9
  _QWORD v20[6]; // [xsp+80h] [xbp-880h] BYREF
  __int128 v21[2]; // [xsp+B0h] [xbp-850h] BYREF
  __int128 v22; // [xsp+D0h] [xbp-830h]
  __int128 v23; // [xsp+E0h] [xbp-820h]
  _BYTE v24[2052]; // [xsp+F4h] [xbp-80Ch] BYREF

  v20[3] = a6;
  v20[4] = a7;
  v20[1] = a4;
  v20[2] = a5;
  v20[5] = a8;
  if ( result )
  {
    v9 = result;
    if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
    {
      v12 = *(_QWORD *)(result + 4576);
      if ( v12 )
      {
        if ( !a2 || *(int *)(v12 + 8) <= 0 || *((int *)*a2 + 3) <= 0 )
          return result;
        v13 = sub_62AB108(v24, 2048LL, "[%s] ", *(const char **)v12);
      }
      else
      {
        if ( !a2 || *((int *)*a2 + 3) <= 0 )
          return result;
        v13 = 0;
      }
      v14 = v13;
      v15 = *((_DWORD *)a2 + 8);
      v16 = 2048 - v13;
      v17 = **a2;
      if ( v15 )
        v18 = sub_62AB108(&v24[v13], v16, "[%s-%d] ", v17, v15);
      else
        v18 = sub_62AB108(&v24[v13], v16, "[%s] ", v17);
      *(_QWORD *)&v23 = v20;
      *((_QWORD *)&v23 + 1) = 0xFFFFFF80FFFFFFD8LL;
      *(_QWORD *)&v22 = &a9;
      *((_QWORD *)&v22 + 1) = v21;
      v21[0] = v22;
      v21[1] = v23;
      v19 = (int)sub_62A9DA8(&v24[v14 + v18], 2048 - ((int)v14 + v18), (__int64)a3, v21) + (__int64)((int)v14 + v18);
      *(_WORD *)&v24[v19] = 10;
      return sub_6285740(v9, 0, v24, v19 + 1);
    }
  }
  return result;
}


================================================================================
Function: sub_6285C7C (0x6285C7C)
================================================================================

size_t __fastcall sub_6285C7C(
        size_t result,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  size_t v9; // x19
  __int64 v11; // x8
  int v12; // w21
  int v13; // w8
  int v14; // w9
  _BYTE *v15; // x11
  _QWORD v16[6]; // [xsp+80h] [xbp-8A0h] BYREF
  __int128 v17; // [xsp+B0h] [xbp-870h] BYREF
  __int128 v18; // [xsp+C0h] [xbp-860h]
  __int128 v19; // [xsp+D0h] [xbp-850h]
  __int128 v20; // [xsp+E0h] [xbp-840h]
  __int128 v21[2]; // [xsp+F0h] [xbp-830h] BYREF
  _BYTE v22[2056]; // [xsp+110h] [xbp-810h] BYREF

  v16[3] = a6;
  v16[4] = a7;
  v16[1] = a4;
  v16[2] = a5;
  v16[0] = a3;
  v16[5] = a8;
  if ( result )
  {
    v9 = result;
    if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
    {
      v11 = *(_QWORD *)(result + 4576);
      if ( v11 )
      {
        if ( *(int *)(v11 + 8) < 1 || dword_6C2D148 <= 0 )
          return result;
      }
      else if ( dword_6C2D148 < 1 )
      {
        return result;
      }
      *(_QWORD *)&v19 = &a9;
      *((_QWORD *)&v19 + 1) = &v17;
      *(_QWORD *)&v20 = v16;
      *((_QWORD *)&v20 + 1) = 0xFFFFFF80FFFFFFD0LL;
      v17 = v19;
      v18 = v20;
      v12 = sub_62AB108(v22, 2049LL, "[%s] ", off_6C2D140);
      v21[0] = v17;
      v21[1] = v18;
      v13 = sub_62A9DA8(&v22[v12], 2049 - v12, a2, v21) + v12;
      if ( v13 >= 2048 )
      {
        v14 = v13 - 1;
        v15 = &v22[v13];
        v13 += 2;
        v22[v14] = 46;
        *v15 = 46;
        v15[1] = 46;
      }
      *(_WORD *)&v22[v13] = 10;
      return sub_6285740(v9, 0, v22, v13 + 1LL);
    }
  }
  return result;
}


================================================================================
Function: sub_6285E0C (0x6285E0C)
================================================================================

size_t __fastcall sub_6285E0C(
        size_t result,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  size_t v9; // x19
  __int64 v11; // x8
  int v12; // w21
  int v13; // w8
  int v14; // w9
  _BYTE *v15; // x11
  _QWORD v16[6]; // [xsp+80h] [xbp-8A0h] BYREF
  __int128 v17; // [xsp+B0h] [xbp-870h] BYREF
  __int128 v18; // [xsp+C0h] [xbp-860h]
  __int128 v19; // [xsp+D0h] [xbp-850h]
  __int128 v20; // [xsp+E0h] [xbp-840h]
  __int128 v21[2]; // [xsp+F0h] [xbp-830h] BYREF
  _BYTE v22[2056]; // [xsp+110h] [xbp-810h] BYREF

  v16[3] = a6;
  v16[4] = a7;
  v16[1] = a4;
  v16[2] = a5;
  v16[0] = a3;
  v16[5] = a8;
  if ( result )
  {
    v9 = result;
    if ( (*(_DWORD *)(result + 2458) & 0x100000) != 0 )
    {
      v11 = *(_QWORD *)(result + 4576);
      if ( v11 )
      {
        if ( *(int *)(v11 + 8) < 1 || dword_6C2D158 <= 0 )
          return result;
      }
      else if ( dword_6C2D158 < 1 )
      {
        return result;
      }
      *(_QWORD *)&v19 = &a9;
      *((_QWORD *)&v19 + 1) = &v17;
      *(_QWORD *)&v20 = v16;
      *((_QWORD *)&v20 + 1) = 0xFFFFFF80FFFFFFD0LL;
      v17 = v19;
      v18 = v20;
      v12 = sub_62AB108(v22, 2049LL, "[%s] ", off_6C2D150);
      v21[0] = v17;
      v21[1] = v18;
      v13 = sub_62A9DA8(&v22[v12], 2049 - v12, a2, v21) + v12;
      if ( v13 >= 2048 )
      {
        v14 = v13 - 1;
        v15 = &v22[v13];
        v13 += 2;
        v22[v14] = 46;
        *v15 = 46;
        v15[1] = 46;
      }
      *(_WORD *)&v22[v13] = 10;
      return sub_6285740(v9, 0, v22, v13 + 1LL);
    }
  }
  return result;
}


================================================================================
Function: sub_6285F9C (0x6285F9C)
================================================================================

__int64 sub_6285F9C()
{
  return 0LL;
}


================================================================================
Function: sub_628856C (0x628856C)
================================================================================

unsigned __int64 __fastcall sub_628856C(unsigned __int64 result, __int64 a2, int a3)
{
  __int64 v3; // x8
  __int64 *v4; // x20
  unsigned __int64 v5; // x19
  __int64 v6; // x8
  __int64 *v7; // x22

  v3 = a2 + 8LL * a3;
  v4 = *(__int64 **)(v3 + 608);
  if ( v4 )
  {
    v5 = result;
    *(_QWORD *)(v3 + 608) = 0LL;
    do
    {
      v6 = *v4;
      v7 = (__int64 *)v4[1];
      v4[1] = 0LL;
      (*(void (__fastcall **)(__int64 *, unsigned __int64))(v6 + 16))(v4, v5);
      result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v4);
      v4 = v7;
    }
    while ( v7 );
  }
  return result;
}


================================================================================
Function: sub_62885D8 (0x62885D8)
================================================================================

__int64 __fastcall sub_62885D8(__int64 a1, int a2)
{
  __int64 v4; // x0
  __int64 result; // x0
  __int64 v6; // x8

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL * a2 + 608);
  if ( v4 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 32LL))(v4, a1);
  result = a1;
  v6 = *(_QWORD *)(a1 + 24) + 16LL * a2;
  *(_QWORD *)(v6 + 632) = 0LL;
  *(_QWORD *)(v6 + 624) = 0LL;
  return result;
}


================================================================================
Function: sub_6288620 (0x6288620)
================================================================================

__int64 __fastcall sub_6288620(__int64 a1, unsigned int a2, _BYTE *a3)
{
  __int64 *v4; // x20
  unsigned int v7; // w22
  __int64 v9; // x1
  _DWORD *v10; // x25
  __int64 v11; // x8
  __int64 v12; // x8
  __int64 v13; // x8
  __int64 v14; // x8
  _BYTE v15[4]; // [xsp+4h] [xbp-1Ch] BYREF
  _QWORD v16[2]; // [xsp+8h] [xbp-18h] BYREF

  v4 = *(__int64 **)(*(_QWORD *)(a1 + 24) + 8LL * (int)a2 + 608);
  if ( !v4 )
  {
LABEL_4:
    v7 = 0;
    *a3 = 1;
    return v7;
  }
  while ( (*((_BYTE *)v4 + 36) & 3) != 1 )
  {
    v4 = (__int64 *)v4[1];
    if ( !v4 )
      goto LABEL_4;
  }
  *a3 = 0;
  v16[0] = sub_62BBCF8();
  v16[1] = v9;
  if ( (sub_6289FD8(a1, a2) & 1) != 0 )
  {
    if ( sub_6289E30(*(_QWORD *)(a1 + 24), a2, v16) < 0 )
    {
      sub_6285834(a1, "SSL shutdown timeout");
      return 28;
    }
  }
  else
  {
    sub_6289DA4(a1, a2, v16);
  }
  v10 = (_DWORD *)(a1 + 2458);
  while ( 1 )
  {
    if ( (*((_BYTE *)v4 + 36) & 2) != 0 )
      goto LABEL_12;
    v11 = *v4;
    v15[0] = 0;
    v7 = (*(__int64 (__fastcall **)(__int64 *, __int64, _BYTE *))(v11 + 40))(v4, a1, v15);
    if ( v7 )
      break;
    if ( !v15[0] )
    {
      if ( a1 )
      {
        if ( (*v10 & 0x100000) != 0 )
        {
          v14 = *(_QWORD *)(a1 + 4576);
          if ( (!v14 || *(int *)(v14 + 8) >= 1) && *(int *)(*v4 + 12) >= 1 )
            sub_6285ACC(a1, v4, "shut down not done yet");
        }
      }
      return v7;
    }
    if ( a1 )
    {
      if ( (*v10 & 0x100000) != 0 )
      {
        v12 = *(_QWORD *)(a1 + 4576);
        if ( (!v12 || *(int *)(v12 + 8) >= 1) && *(int *)(*v4 + 12) >= 1 )
          sub_6285ACC(a1, v4, "shut down successfully");
      }
    }
    *((_BYTE *)v4 + 36) |= 2u;
LABEL_12:
    v4 = (__int64 *)v4[1];
    if ( !v4 )
      goto LABEL_4;
  }
  if ( a1 )
  {
    if ( (*v10 & 0x100000) != 0 )
    {
      v13 = *(_QWORD *)(a1 + 4576);
      if ( (!v13 || *(int *)(v13 + 8) >= 1) && *(int *)(*v4 + 12) >= 1 )
        sub_6285ACC(a1, v4, "shut down failed with %d", v7);
    }
  }
  return v7;
}


================================================================================
Function: sub_6288D84 (0x6288D84)
================================================================================

__int64 __fastcall sub_6288D84(__int64 a1, int a2)
{
  __int64 v3; // x9
  __int64 result; // x0
  int v5; // w0
  int v6; // [xsp+4h] [xbp-Ch] BYREF

  v3 = *(_QWORD *)(a1 + 24);
  v6 = 0;
  result = *(_QWORD *)(v3 + 8LL * a2 + 608);
  if ( result )
  {
    v5 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, int *, _QWORD))(*(_QWORD *)result + 112LL))(
           result,
           a1,
           7LL,
           &v6,
           0LL);
    return (v5 == 0) & (unsigned __int8)(v6 != 0);
  }
  return result;
}


================================================================================
Function: sub_6288E14 (0x6288E14)
================================================================================

__int64 __fastcall sub_6288E14(__int64 a1, int a2)
{
  _QWORD *v2; // x20
  __int64 (__fastcall *v4)(); // x8
  __int64 result; // x0

  v2 = *(_QWORD **)(*(_QWORD *)(a1 + 24) + 8LL * a2 + 608);
  if ( !v2 )
    return 0LL;
  while ( 1 )
  {
    v4 = *(__int64 (__fastcall **)())(*v2 + 88LL);
    if ( v4 != sub_6289284 )
    {
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v4)(v2, a1, 258LL, 0LL, 0LL);
      if ( (_DWORD)result )
        break;
    }
    v2 = (_QWORD *)v2[1];
    if ( !v2 )
      return 0LL;
  }
  return result;
}


================================================================================
Function: sub_6288F70 (0x6288F70)
================================================================================

__int64 __fastcall sub_6288F70(__int64 a1, int a2)
{
  __int64 v2; // x8

  v2 = *(_QWORD *)(a1 + 8LL * a2 + 608);
  if ( v2 )
    return *(_BYTE *)(v2 + 36) & 1;
  else
    return 0LL;
}


================================================================================
Function: sub_6288F90 (0x6288F90)
================================================================================

__int64 __fastcall sub_6288F90(__int64 a1, int a2)
{
  __int64 v2; // x8

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL * a2 + 608);
  if ( !v2 )
    return 0LL;
  while ( (*(_BYTE *)(v2 + 36) & 1) == 0 )
  {
    if ( (*(_BYTE *)(*(_QWORD *)v2 + 8LL) & 1) == 0 )
    {
      v2 = *(_QWORD *)(v2 + 8);
      if ( v2 )
        continue;
    }
    return 0LL;
  }
  return 1LL;
}


================================================================================
Function: sub_6289034 (0x6289034)
================================================================================

__int64 __fastcall sub_6289034(__int64 result, int a2)
{
  _QWORD *v2; // x8
  int v3; // w9

  if ( result )
  {
    v2 = *(_QWORD **)(result + 8LL * a2 + 608);
    if ( v2 )
    {
      while ( 1 )
      {
        v3 = *(_DWORD *)(*v2 + 8LL);
        if ( (v3 & 4) != 0 )
          break;
        if ( (v3 & 3) == 0 )
        {
          v2 = (_QWORD *)v2[1];
          if ( v2 )
            continue;
        }
        return 0LL;
      }
      return 1LL;
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}


================================================================================
Function: sub_62891A4 (0x62891A4)
================================================================================

__int64 __fastcall sub_62891A4(__int64 result, __int64 a2)
{
  __int64 v2; // x8
  __int64 v4; // x20
  __int64 v5; // x10
  __int64 v6; // x21
  char v7; // w9
  __int64 v8; // x9
  __int64 v9; // x21
  char v10; // w8

  v2 = *(_QWORD *)(result + 24);
  v4 = result;
  v5 = *(_QWORD *)(v2 + 608);
  while ( v5 )
  {
    v6 = v5;
    v7 = *(_BYTE *)(v5 + 36);
    if ( (v7 & 1) == 0 )
    {
      v5 = *(_QWORD *)(v5 + 8);
      if ( v5 )
      {
        if ( (*(_BYTE *)(v5 + 36) & 1) == 0 )
          continue;
      }
    }
    if ( (v7 & 2) != 0 )
    {
      while ( 1 )
      {
        v6 = *(_QWORD *)(v6 + 8);
        if ( !v6 )
          break;
        if ( (*(_BYTE *)(v6 + 36) & 2) == 0 )
          goto LABEL_9;
      }
    }
    else
    {
      do
      {
LABEL_9:
        result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 56LL))(v6, v4, a2);
        v6 = *(_QWORD *)(v6 + 8);
      }
      while ( v6 );
      v2 = *(_QWORD *)(v4 + 24);
    }
    break;
  }
  v8 = *(_QWORD *)(v2 + 616);
  while ( v8 )
  {
    v9 = v8;
    v10 = *(_BYTE *)(v8 + 36);
    if ( (v10 & 1) == 0 )
    {
      v8 = *(_QWORD *)(v8 + 8);
      if ( v8 )
      {
        if ( (*(_BYTE *)(v8 + 36) & 1) == 0 )
          continue;
      }
    }
    if ( (v10 & 2) != 0 )
    {
      while ( 1 )
      {
        v9 = *(_QWORD *)(v9 + 8);
        if ( !v9 )
          break;
        if ( (*(_BYTE *)(v9 + 36) & 2) == 0 )
          goto LABEL_19;
      }
    }
    else
    {
      do
      {
LABEL_19:
        result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v9 + 56LL))(v9, v4, a2);
        v9 = *(_QWORD *)(v9 + 8);
      }
      while ( v9 );
    }
    return result;
  }
  return result;
}


================================================================================
Function: sub_6289464 (0x6289464)
================================================================================

__int64 __fastcall sub_6289464(__int64 result, __int64 a2)
{
  __int64 v2; // x20
  _QWORD *i; // x21
  _QWORD *j; // x20
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8

  v2 = result;
  for ( i = *(_QWORD **)(result + 608); i; i = (_QWORD *)i[1] )
  {
    v6 = *(__int64 (__fastcall **)())(*i + 88LL);
    if ( v6 != sub_6289284 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v6)(i, a2, 1LL, 0LL, 0LL);
  }
  for ( j = *(_QWORD **)(v2 + 616); j; j = (_QWORD *)j[1] )
  {
    v7 = *(__int64 (__fastcall **)())(*j + 88LL);
    if ( v7 != sub_6289284 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v7)(j, a2, 1LL, 0LL, 0LL);
  }
  return result;
}


================================================================================
Function: sub_628950C (0x628950C)
================================================================================

__int64 __fastcall sub_628950C(__int64 result, __int64 a2)
{
  __int64 v2; // x20
  _QWORD *i; // x21
  _QWORD *j; // x20
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8

  v2 = result;
  for ( i = *(_QWORD **)(result + 608); i; i = (_QWORD *)i[1] )
  {
    v6 = *(__int64 (__fastcall **)())(*i + 88LL);
    if ( v6 != sub_6289284 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v6)(i, a2, 2LL, 0LL, 0LL);
  }
  for ( j = *(_QWORD **)(v2 + 616); j; j = (_QWORD *)j[1] )
  {
    v7 = *(__int64 (__fastcall **)())(*j + 88LL);
    if ( v7 != sub_6289284 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v7)(j, a2, 2LL, 0LL, 0LL);
  }
  return result;
}


================================================================================
Function: sub_628971C (0x628971C)
================================================================================

__int64 __fastcall sub_628971C(__int64 result)
{
  __int64 v1; // x22
  __int64 v2; // x19
  _QWORD *i; // x20
  _QWORD *j; // x20
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8

  v1 = *(_QWORD *)(result + 24);
  v2 = result;
  for ( i = *(_QWORD **)(v1 + 608); i; i = (_QWORD *)i[1] )
  {
    v5 = *(__int64 (__fastcall **)())(*i + 88LL);
    if ( v5 != sub_6289284 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v5)(i, v2, 8LL, 0LL, 0LL);
  }
  for ( j = *(_QWORD **)(v1 + 616); j; j = (_QWORD *)j[1] )
  {
    v6 = *(__int64 (__fastcall **)())(*j + 88LL);
    if ( v6 != sub_6289284 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v6)(j, v2, 8LL, 0LL, 0LL);
  }
  return result;
}


================================================================================
Function: sub_62897C4 (0x62897C4)
================================================================================

__int64 __fastcall sub_62897C4(__int64 result, char a2)
{
  __int64 v2; // x23
  __int64 v3; // x19
  unsigned int v4; // w20
  _QWORD *i; // x21
  _QWORD *j; // x21
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8

  v2 = *(_QWORD *)(result + 24);
  v3 = result;
  v4 = a2 & 1;
  for ( i = *(_QWORD **)(v2 + 608); i; i = (_QWORD *)i[1] )
  {
    v7 = *(__int64 (__fastcall **)())(*i + 88LL);
    if ( v7 != sub_6289284 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v7)(i, v3, 7LL, v4, 0LL);
  }
  for ( j = *(_QWORD **)(v2 + 616); j; j = (_QWORD *)j[1] )
  {
    v8 = *(__int64 (__fastcall **)())(*j + 88LL);
    if ( v8 != sub_6289284 )
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, __int64, _QWORD, _QWORD))v8)(j, v3, 7LL, v4, 0LL);
  }
  return result;
}


================================================================================
Function: sub_62899B8 (0x62899B8)
================================================================================

__int64 __fastcall sub_62899B8(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 *a6)
{
  __int64 v7; // x8
  __int64 v8; // x8
  __int64 result; // x0
  unsigned int v10; // [xsp+4h] [xbp-Ch]

  v7 = *(_QWORD *)(a1 + 24);
  v10 = 0;
  v8 = (*(__int64 (**)(void))(v7 + 8LL * a2 + 592))();
  result = v10;
  *a6 = v8 & ~(v8 >> 63);
  return result;
}


================================================================================
Function: sub_6289A28 (0x6289A28)
================================================================================

long double __fastcall sub_6289A28(__int64 a1, __int64 a2)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)a2 = -1LL;
  *(_QWORD *)(a2 + 8) = -1LL;
  *(_DWORD *)(a2 + 16) = -1;
  return result;
}


================================================================================
Function: sub_6289B14 (0x6289B14)
================================================================================

__int64 __fastcall sub_6289B14(__int64 a1, __int64 a2, __int64 (__fastcall *a3)(__int64, _DWORD *))
{
  __int64 result; // x0
  __int64 i; // x8
  int v6; // w14
  int v7; // w13
  __int64 v8; // x14
  __int64 v9; // x15
  __int64 v10; // x14
  __int64 j; // x15
  __int64 v12; // x15
  __int64 v13; // x15
  _DWORD v14[5]; // [xsp+4h] [xbp-1Ch] BYREF

  result = a3(a1, v14);
  if ( (_DWORD)result )
  {
    for ( i = 0LL; i != 5; ++i )
    {
      if ( (((unsigned int)result >> i) & 0x10001) == 0 )
        return result;
      v7 = v14[i];
      if ( v7 < 0 )
        return result;
      if ( ((1 << i) & (unsigned int)result) != 0 )
      {
        v8 = *(unsigned int *)(a2 + 20);
        if ( ((0x10000 << i) & (unsigned int)result) != 0 )
        {
          v9 = 0LL;
          if ( (_DWORD)v8 )
          {
            do
            {
              if ( *(_DWORD *)(a2 + 4 * v9) == v7 )
              {
                *(_BYTE *)(a2 + v9 + 24) |= 3u;
                goto LABEL_5;
              }
              ++v9;
            }
            while ( v8 != v9 );
            v9 = *(unsigned int *)(a2 + 20);
            if ( (unsigned int)v8 <= 4 )
              goto LABEL_3;
            continue;
          }
LABEL_3:
          v6 = v8 + 1;
          *(_DWORD *)(a2 + 4 * v9) = v7;
          *(_BYTE *)(a2 + v9 + 24) = 3;
        }
        else
        {
          v13 = 0LL;
          if ( (_DWORD)v8 )
          {
            do
            {
              if ( *(_DWORD *)(a2 + 4 * v13) == v7 )
              {
                *(_BYTE *)(a2 + v13 + 24) |= 1u;
                goto LABEL_5;
              }
              ++v13;
            }
            while ( v8 != v13 );
            v13 = *(unsigned int *)(a2 + 20);
            if ( (unsigned int)v8 > 4 )
              continue;
          }
          v6 = v8 + 1;
          *(_DWORD *)(a2 + 4 * v13) = v7;
          *(_BYTE *)(a2 + v13 + 24) = 1;
        }
      }
      else
      {
        v10 = *(unsigned int *)(a2 + 20);
        if ( (_DWORD)v10 )
        {
          for ( j = 0LL; j != v10; ++j )
          {
            if ( *(_DWORD *)(a2 + 4 * j) == v7 )
            {
              *(_BYTE *)(a2 + j + 24) |= 2u;
              goto LABEL_5;
            }
          }
          v12 = *(unsigned int *)(a2 + 20);
          if ( (unsigned int)v10 > 4 )
            continue;
        }
        else
        {
          v12 = 0LL;
        }
        v6 = v10 + 1;
        *(_DWORD *)(a2 + 4 * v12) = v7;
        *(_BYTE *)(a2 + v12 + 24) = 2;
      }
      *(_DWORD *)(a2 + 20) = v6;
LABEL_5:
      ;
    }
  }
  return result;
}


================================================================================
Function: sub_6289DA4 (0x6289DA4)
================================================================================

__time_t __fastcall sub_6289DA4(__time_t result, int a2, _OWORD *a3)
{
  __time_t v4; // x19
  __int64 v5; // x1
  int v6; // w8
  _QWORD v7[2]; // [xsp+8h] [xbp-18h] BYREF

  v4 = result;
  if ( !a3 )
  {
    result = sub_62BBCF8();
    a3 = v7;
    v7[0] = result;
    v7[1] = v5;
  }
  *(_OWORD *)(*(_QWORD *)(v4 + 24) + 16LL * a2 + 624) = *a3;
  v6 = *(_DWORD *)(v4 + 768);
  if ( !v6 )
    v6 = 2000;
  *(_DWORD *)(*(_QWORD *)(v4 + 24) + 656LL) = v6;
  return result;
}


================================================================================
Function: sub_6289E30 (0x6289E30)
================================================================================

__int64 __fastcall sub_6289E30(__int64 a1, int a2, __time_t *a3)
{
  __int64 v3; // x10
  __int64 v4; // x8
  unsigned int v6; // w9
  __int64 v7; // x20
  __time_t v8; // x0
  __time_t v9; // x1
  __int64 *v11; // x21
  __int64 v12; // x10
  __int64 v13; // x19
  __int64 v14; // x0

  v3 = a1 + 16LL * a2;
  v4 = *(_QWORD *)(v3 + 624);
  if ( !v4 )
    return 0LL;
  v6 = *(_DWORD *)(a1 + 656);
  if ( !v6 )
    return 0LL;
  v7 = a2;
  if ( a3 )
  {
    v8 = *a3;
    v9 = a3[1];
  }
  else
  {
    v11 = (__int64 *)(v3 + 624);
    v8 = sub_62BBCF8();
    v6 = *(_DWORD *)(a1 + 656);
    v4 = *v11;
  }
  v12 = a1 + 16 * v7;
  v13 = v6;
  v14 = sub_62BBD98(v8, v9, v4, *(_QWORD *)(v12 + 632));
  if ( v13 == v14 )
    return -1LL;
  else
    return v13 - v14;
}


================================================================================
Function: sub_6289EAC (0x6289EAC)
================================================================================

__int64 __fastcall sub_6289EAC(__int64 a1, __int64 *a2)
{
  __int64 *v3; // x21
  __int64 v4; // x2
  __time_t v5; // x0
  __int64 v6; // x1
  __int64 v7; // x20
  __int64 v8; // x0
  __int64 v9; // x20
  __int64 v10; // x2
  __int64 v11; // x23
  __time_t v12; // x0
  __int64 v13; // x1
  __int64 v14; // x0
  __int64 v15; // x8
  __time_t v18; // [xsp+8h] [xbp-18h] BYREF
  __int64 v19; // [xsp+10h] [xbp-10h]

  if ( !*(_DWORD *)(a1 + 656) )
    return 0LL;
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 624);
  if ( v4
    && (a2 || (v5 = sub_62BBCF8(), v4 = *(_QWORD *)(a1 + 624), v3 = &v18, v18 = v5, v19 = v6, v4))
    && (v7 = *(unsigned int *)(a1 + 656), (_DWORD)v7) )
  {
    v8 = sub_62BBD98(*v3, v3[1], v4, *(_QWORD *)(a1 + 632));
    if ( v7 == v8 )
      v9 = -1LL;
    else
      v9 = v7 - v8;
    if ( !*(_DWORD *)(a1 + 656) )
      return v9;
  }
  else
  {
    v9 = 0LL;
    if ( !*(_DWORD *)(a1 + 656) )
      return v9;
  }
  v10 = *(_QWORD *)(a1 + 640);
  if ( !v10 )
    return v9;
  if ( v3 )
  {
    v11 = *(unsigned int *)(a1 + 656);
    if ( !(_DWORD)v11 )
      return v9;
  }
  else
  {
    v12 = sub_62BBCF8();
    v10 = *(_QWORD *)(a1 + 640);
    v18 = v12;
    v19 = v13;
    if ( !v10 )
      return v9;
    v3 = &v18;
    v11 = *(unsigned int *)(a1 + 656);
    if ( !(_DWORD)v11 )
      return v9;
  }
  v14 = sub_62BBD98(*v3, v3[1], v10, *(_QWORD *)(a1 + 648));
  v15 = v11 - v14;
  if ( v11 == v14 )
    v15 = -1LL;
  if ( v15 < v9 || v9 == 0 )
    return v15;
  return v9;
}


================================================================================
Function: sub_6289FD8 (0x6289FD8)
================================================================================

bool __fastcall sub_6289FD8(__int64 a1, int a2)
{
  __int64 v2; // x8

  v2 = *(_QWORD *)(a1 + 24);
  return *(__int64 *)(v2 + 16LL * a2 + 624) > 0 || *(_DWORD *)(v2 + 16LL * a2 + 632) > 0;
}


================================================================================
Function: sub_628A0E0 (0x628A0E0)
================================================================================

__int64 __fastcall sub_628A0E0(__int64 a1, __int64 *a2)
{
  __int64 v4; // x0
  __int64 result; // x0

  if ( *(_QWORD *)(a1 + 2912) == -1LL )
    return 0xFFFFFFFFLL;
  v4 = sub_628DBB4();
  if ( v4 )
  {
    if ( a2 )
      *a2 = v4;
    return *(unsigned int *)(v4 + 568);
  }
  else
  {
    result = 0xFFFFFFFFLL;
    *(_QWORD *)(a1 + 2912) = -1LL;
  }
  return result;
}


================================================================================
Function: sub_628A13C (0x628A13C)
================================================================================

__int64 __fastcall sub_628A13C(__int64 a1, int a2)
{
  __int64 result; // x0
  int v5; // w8

  result = sub_6289034(a1, 0LL);
  if ( (a2 != 2 || (result & 1) == 0)
    && ((a2 == 1) | (a2 == 2) & ((unsigned int)result ^ 1)) == ((*(_DWORD *)(a1 + 920) & 0x20) == 0) )
  {
    if ( (a2 == 1) | (a2 == 2) & ((unsigned int)result ^ 1) )
      v5 = 32;
    else
      v5 = 0;
    *(_DWORD *)(a1 + 920) = *(_DWORD *)(a1 + 920) & 0xFFFFFFDF | v5;
  }
  return result;
}


================================================================================
Function: sub_628C19C (0x628C19C)
================================================================================

__int64 __fastcall sub_628C19C(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x8
  __int64 result; // x0
  __int64 v13; // x8

  sub_6298044(a1, a5, sub_62985C0, sub_62985F8, sub_628C23C);
  v9 = sub_62A734C(a1 + 11, 0LL);
  if ( !a2 )
    return 1LL;
  v10 = sub_6285170(v9);
  a1[15] = v10;
  if ( !v10 )
    return 1LL;
  v11 = v10;
  result = 0LL;
  *(_DWORD *)(v11 + 4692) |= 0x20000u;
  v13 = a1[15];
  a1[17] = a4;
  a1[18] = a2;
  a1[16] = a3;
  *(_QWORD *)(v13 + 208) = a3;
  *(_QWORD *)(v13 + 224) = a4;
  return result;
}


================================================================================
Function: sub_628C24C (0x628C24C)
================================================================================

unsigned __int64 __fastcall sub_628C24C(unsigned __int64 result)
{
  unsigned __int64 v1; // x19
  _QWORD *v2; // x20
  __int64 v3; // x8
  __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // x21
  unsigned int *v7; // x23
  unsigned __int64 v8; // x8
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x8
  unsigned int *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x9
  __int64 v15; // x23
  __int64 v16; // x0
  __int64 v17; // x1
  __int64 v18; // x21
  __int64 v19; // x22
  __int64 v20; // x0
  __int64 v21; // x0
  __int64 v22; // x0
  __int64 v23; // x24
  __int64 v24; // x0
  __int64 v25; // x0
  __int64 v26; // x0
  __int64 v27; // x0
  __int64 v28; // x1
  __int64 v29; // x0
  int v30; // w24
  int v31; // w8
  __int64 v32; // x0
  __int64 v33; // x21
  __int64 v34; // x22
  __int64 v35; // x0
  __int64 v36; // x22
  __int64 v37; // x23
  __int64 v38; // x8
  __int64 v39; // [xsp+8h] [xbp-A8h] BYREF
  unsigned int v40; // [xsp+10h] [xbp-A0h]
  struct sigaction act; // [xsp+20h] [xbp-90h] BYREF

  if ( result )
  {
    v1 = result;
    v2 = (_QWORD *)(result + 120);
    if ( *(_QWORD *)(result + 120) )
    {
      v3 = *(_QWORD *)(result + 136);
      act.sa_mask.__val[3] = 1LL;
      memset(&act, 0, 32);
      if ( v3 && (*(_BYTE *)(v3 + 4) & 0x20) != 0 )
        sub_62B9860();
      *(_BYTE *)(v1 + 152) |= 1u;
      sub_6298630(v1, &act.sa_mask.__val[5]);
      while ( 1 )
      {
        v4 = sub_629863C(&act.sa_mask.__val[5]);
        if ( !v4 )
          break;
        v5 = sub_62A75F0(*(_QWORD *)(v4 + 32));
        if ( v5 )
        {
          v4 = sub_62A7600(v5);
          if ( v4 )
          {
            v6 = v4;
LABEL_11:
            sub_628D144(v1, v6);
            v7 = (unsigned int *)(*(_QWORD *)(v1 + 120) + 2458LL);
            if ( ((*v7 >> 23) & 1) != LOBYTE(act.sa_mask.__val[3]) )
            {
              if ( LOBYTE(act.sa_mask.__val[3]) )
              {
                v8 = *v7 | ((unsigned __int64)*(unsigned __int16 *)(*(_QWORD *)(v1 + 120) + 2462LL) << 32);
                v9 = (v8 >> 23) & 0x1FFFFFF;
              }
              else
              {
                sigaction(13, &act, 0LL);
                v8 = *v7 | ((unsigned __int64)*((unsigned __int16 *)v7 + 2) << 32);
                v9 = v8 >> 23;
              }
              LOBYTE(act.sa_mask.__val[3]) = v9 & 1;
              if ( (v8 & 0x800000) == 0 )
              {
                sigaction(13, 0LL, &act);
                act.sa_mask.__val[5] = (unsigned __int64)act.sa_handler;
                *(_OWORD *)&act.sa_mask.__val[7] = *(_OWORD *)&act.sa_mask.__val[1];
                act.sa_mask.__val[6] = 1LL;
                sigaction(13, (const struct sigaction *)&act.sa_mask.__val[5], 0LL);
              }
            }
            sub_628A13C(v6, 1LL);
            sub_628D240(v1, *(_QWORD *)(v1 + 120), v6, 0LL);
            sub_6298630(v1, &act.sa_mask.__val[5]);
            while ( 1 )
            {
              v4 = sub_629863C(&act.sa_mask.__val[5]);
              if ( !v4 )
                break;
              v10 = sub_62A75F0(*(_QWORD *)(v4 + 32));
              if ( v10 )
              {
                v4 = sub_62A7600(v10);
                v6 = v4;
                if ( v4 )
                  goto LABEL_11;
                goto LABEL_21;
              }
            }
          }
          break;
        }
      }
LABEL_21:
      v11 = *(_QWORD *)(v1 + 136);
      *(_BYTE *)(v1 + 152) &= ~1u;
      if ( v11 && (*(_BYTE *)(v11 + 4) & 0x20) != 0 )
        v4 = sub_62B98A4(*v2, 5LL);
      v12 = (unsigned int *)(*v2 + 2458LL);
      if ( ((*v12 >> 23) & 1) != LOBYTE(act.sa_mask.__val[3]) )
      {
        if ( LOBYTE(act.sa_mask.__val[3]) )
        {
          v13 = *v12 | ((unsigned __int64)*(unsigned __int16 *)(*v2 + 2462LL) << 32);
          v14 = (v13 >> 23) & 0x1FFFFFF;
        }
        else
        {
          v4 = sigaction(13, &act, 0LL);
          v13 = *v12 | ((unsigned __int64)*((unsigned __int16 *)v12 + 2) << 32);
          v14 = v13 >> 23;
        }
        LOBYTE(act.sa_mask.__val[3]) = v14 & 1;
        if ( (v13 & 0x800000) == 0 )
        {
          sigaction(13, 0LL, &act);
          act.sa_mask.__val[5] = (unsigned __int64)act.sa_handler;
          *(_OWORD *)&act.sa_mask.__val[7] = *(_OWORD *)&act.sa_mask.__val[1];
          act.sa_mask.__val[6] = 1LL;
          v4 = sigaction(13, (const struct sigaction *)&act.sa_mask.__val[5], 0LL);
        }
      }
      v15 = *v2;
      v16 = sub_62BBCF8(v4);
      if ( v15 )
      {
        v18 = v16;
        v19 = v17;
        sub_6298630(v1, &act.sa_mask.__val[5]);
        while ( 1 )
        {
          v20 = sub_629863C(&act.sa_mask.__val[5]);
          if ( !v20 )
            break;
          v21 = sub_62A75F0(*(_QWORD *)(v20 + 32));
          if ( v21 )
          {
            v22 = sub_62A7600(v21);
            if ( v22 )
            {
              v23 = v22;
LABEL_36:
              sub_628D144(v1, v23);
              sub_628D240(v1, v15, v23, 0LL);
              sub_6298630(v1, &act.sa_mask.__val[5]);
              while ( 1 )
              {
                v24 = sub_629863C(&act.sa_mask.__val[5]);
                if ( !v24 )
                  break;
                v25 = sub_62A75F0(*(_QWORD *)(v24 + 32));
                if ( v25 )
                {
                  v23 = sub_62A7600(v25);
                  if ( v23 )
                    goto LABEL_36;
                  goto LABEL_40;
                }
              }
            }
            break;
          }
        }
LABEL_40:
        while ( sub_62A75F0(v1 + 88) )
        {
          sub_628D73C(v1);
          v26 = sub_62A75F0(v1 + 88);
          if ( !v26 )
            break;
          v27 = sub_62BBCF8(v26);
          v29 = sub_62BBD98(v27, v28, v18, v19);
          if ( (v29 & 0x8000000000000000LL) == 0 )
            break;
          v30 = v29;
          sub_62B1AE0(&v39, &act.sa_mask.__val[5], 10LL);
          if ( (unsigned int)sub_628D5D4(v1, &v39) )
          {
            sub_62B1AFC(&v39);
            break;
          }
          v31 = -v30;
          if ( -v30 >= 1000 )
            v31 = 1000;
          sub_62B17A0(v39, v40, v31);
          sub_62B1AFC(&v39);
        }
        v32 = sub_62A75F0(v1 + 88);
        if ( v32 )
        {
          v33 = v32;
          do
          {
            v34 = sub_62A7600(v33);
            sub_62A74BC(v33);
            sub_628D4D0(v1, v34, 0LL, 0LL);
            v33 = sub_62A75F0(v1 + 88);
          }
          while ( v33 );
        }
      }
      v35 = sub_62A75F0(v1 + 88);
      if ( v35 )
      {
        v36 = v35;
        do
        {
          v37 = sub_62A7600(v36);
          sub_62A74BC(v36);
          sub_628D4D0(v1, v37, 0LL, 0LL);
          v36 = sub_62A75F0(v1 + 88);
        }
        while ( v36 );
      }
      sub_629A0E0(*v2, *(_QWORD *)(*v2 + 192LL));
      if ( !LOBYTE(act.sa_mask.__val[3]) )
        sigaction(13, &act, 0LL);
      v38 = *v2;
      *(_QWORD *)(v38 + 208) = 0LL;
      *(_QWORD *)(v38 + 224) = 0LL;
      sub_62BD5E8(v2);
    }
    result = sub_62983C0((unsigned __int64 *)v1);
    *(_QWORD *)(v1 + 128) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_628CA0C (0x628CA0C)
================================================================================

_QWORD *__fastcall sub_628CA0C(_QWORD *result, __int64 a2, char a3)
{
  __int64 v4; // x20
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x19
  char v9; // w23
  __int64 v10; // x9
  char v11; // w8
  __int64 v12; // x3
  __int64 v13; // x4
  __int64 v14; // x5
  __int64 v15; // x6
  __int64 v16; // x7
  char v17; // w22
  __int64 v18; // x8
  int v19; // w9
  __int64 v20; // x9
  const char *v21; // x2
  __int64 v22; // x8
  __int64 v23; // x8
  __int64 v24; // [xsp+0h] [xbp+0h]

  if ( !result )
    return result;
  v4 = (__int64)result;
  v6 = result[28];
  if ( v6 && (*(_BYTE *)(v6 + 4) & 0x20) != 0 )
  {
    v8 = v6 + 40;
  }
  else
  {
    v7 = result[27];
    if ( !v7 )
    {
      v7 = result[26];
      if ( !v7 )
        return result;
    }
    v8 = v7 + 368;
  }
  result = (_QWORD *)sub_62A75F8(a2 + 968);
  if ( result && (a3 & 1) == 0 )
    return result;
  v9 = *(_BYTE *)(v8 + 152);
  if ( (v9 & 1) == 0 )
  {
    v10 = *(_QWORD *)(v8 + 136);
    v11 = *(_BYTE *)(v8 + 152);
    if ( v10 )
    {
      v11 = *(_BYTE *)(v8 + 152);
      if ( (*(_BYTE *)(v10 + 4) & 0x20) != 0 )
      {
        sub_62B9860(*(_QWORD *)(v8 + 120), 5);
        v11 = *(_BYTE *)(v8 + 152);
      }
    }
    *(_BYTE *)(v8 + 152) = v11 | 1;
  }
  if ( (*(_BYTE *)(a2 + 923) & 0x20) != 0 )
    sub_628D144(v8, a2);
  v17 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v8 + 144))(v4, a2, a3 & 1);
  v18 = *(_QWORD *)(v4 + 208);
  v19 = *(_DWORD *)(v4 + 2458);
  if ( v18 )
  {
    if ( (v19 & 0x100000) != 0 )
    {
      v20 = *(_QWORD *)(v4 + 4576);
      if ( !v20 || *(int *)(v20 + 8) >= 1 )
      {
        if ( (v17 & 1) != 0 )
          v21 = "closing";
        else
          v21 = "shutting down";
        sub_628595C(v4, "%s connection #%ld", (__int64)v21, *(_QWORD *)(a2 + 48), v13, v14, v15, v16, v24);
        v18 = *(_QWORD *)(v4 + 208);
      }
    }
    result = (_QWORD *)sub_628D240(v18 + 368, v4, a2, v17 & 1);
    if ( (v9 & 1) != 0 )
      return result;
LABEL_32:
    v23 = *(_QWORD *)(v8 + 136);
    *(_BYTE *)(v8 + 152) &= ~1u;
    if ( v23 )
    {
      if ( (*(_BYTE *)(v23 + 4) & 0x20) != 0 )
        return (_QWORD *)sub_62B98A4(*(_QWORD *)(v8 + 120), 5);
    }
    return result;
  }
  if ( (v19 & 0x100000) != 0 )
  {
    v22 = *(_QWORD *)(v4 + 4576);
    if ( !v22 || *(int *)(v22 + 8) >= 1 )
      sub_628595C(v4, "closing connection #%ld", *(_QWORD *)(a2 + 48), v12, v13, v14, v15, v16, v24);
  }
  result = (_QWORD *)sub_628D4D0(0LL, a2, v4, (v17 & 1) == 0);
  if ( (v9 & 1) == 0 )
    goto LABEL_32;
  return result;
}


================================================================================
Function: sub_628D144 (0x628D144)
================================================================================

__int64 __fastcall sub_628D144(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  __int64 v5; // x22
  __int64 v6; // x21
  _QWORD v7[3]; // [xsp+0h] [xbp-20h] BYREF

  result = sub_62A7610(a2);
  if ( result )
  {
    v5 = result;
    result = sub_6298318(a1, *(_QWORD *)(a2 + 56), *(_QWORD *)(a2 + 64));
    if ( result )
    {
      v6 = result;
      if ( v5 == result )
      {
        sub_62A74BC(a2);
        *(_DWORD *)(a2 + 920) &= ~0x20000000u;
        result = sub_62A75F8(v5);
        if ( !result && a1 )
        {
          sub_6298630(a1, v7);
          while ( 1 )
          {
            result = sub_629863C((__int64)v7);
            if ( !result )
              break;
            if ( *(_QWORD *)(result + 32) == v6 )
            {
              result = sub_6298264(a1, result + 56, *(_QWORD *)(result + 48));
              break;
            }
          }
        }
        *(_DWORD *)(a2 + 920) &= ~0x20000000u;
        --*(_QWORD *)(a1 + 48);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_628D240 (0x628D240)
================================================================================

__int64 __fastcall sub_628D240(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 result; // x0
  char v9; // w8
  int v10; // w10
  __int64 v11; // x8
  __int64 v12; // x23
  __int64 v13; // x0
  __int64 v14; // x23
  __int64 v15; // x22
  _DWORD *v16; // x8
  __int64 v17; // x8
  __int64 v18; // x24
  __int64 v19; // x23
  __int128 v20; // q1
  char v21[4]; // [xsp+Ch] [xbp-64h] BYREF
  struct sigaction oact; // [xsp+10h] [xbp-60h] BYREF

  v21[0] = 0;
  result = sub_62A75F8(a3 + 968);
  if ( !result || (a4 & 1) != 0 )
  {
    v9 = (*(_BYTE *)(a3 + 1109) != 0) | a4;
    if ( (*(_BYTE *)(a3 + 1109) != 0) | a4 & 1 )
      v10 = 0x4000000;
    else
      v10 = 0;
    *(_DWORD *)(a3 + 920) = v10 | *(_DWORD *)(a3 + 920) & 0xFBFFFFFF;
    if ( (v9 & 1) != 0 )
    {
      v21[0] = 1;
      return sub_628D4D0(a1, a3, a2, 0LL);
    }
    sub_62AC280(a2, a3);
    sub_628D868(a2, a3, v21);
    sub_62AC16C(a2);
    if ( v21[0] )
      return sub_628D4D0(a1, a3, a2, 0LL);
    v11 = *(_QWORD *)(a2 + 208);
    if ( v11 )
    {
      v12 = *(_QWORD *)(v11 + 544);
      if ( v12 >= 1 && v12 >= sub_62A75F8(a1 + 88) )
      {
        v13 = sub_62A75F0(a1 + 88);
        if ( v13 )
        {
          v14 = v13;
          v15 = sub_62A7600(v13);
          sub_62A74BC(v14);
          v16 = (_DWORD *)(*(_QWORD *)(a1 + 120) + 2458LL);
          oact.sa_mask.__val[3] = 1LL;
          memset(&oact, 0, 32);
          if ( (*v16 & 0x800000) == 0 )
          {
            LOBYTE(oact.sa_mask.__val[3]) = 0;
            sigaction(13, 0LL, &oact);
            oact.sa_mask.__val[5] = (unsigned __int64)oact.sa_handler;
            *(_OWORD *)&oact.sa_mask.__val[7] = *(_OWORD *)&oact.sa_mask.__val[1];
            oact.sa_mask.__val[6] = 1LL;
            sigaction(13, (const struct sigaction *)&oact.sa_mask.__val[5], 0LL);
          }
          sub_628D4D0(a1, v15, 0LL, 0LL);
          if ( !LOBYTE(oact.sa_mask.__val[3]) )
            sigaction(13, &oact, 0LL);
        }
      }
      v17 = *(_QWORD *)(a2 + 208);
      if ( v17 )
      {
        if ( *(_QWORD *)(v17 + 152) )
        {
          *(_OWORD *)(a3 + 664) = 0u;
          *(_OWORD *)(a3 + 680) = 0u;
          v18 = *(_QWORD *)(a1 + 120);
          memset(&oact, 0, 32);
          v19 = *(_QWORD *)(a2 + 208);
          sub_62AC280(v18, a3);
          sub_62891A4(v18, &oact);
          sub_62AC16C(v18);
          if ( (unsigned int)sub_62ADBC8(v19, v18, &oact, a3 + 664) )
            return sub_628D4D0(a1, a3, a2, 0LL);
          v20 = *(_OWORD *)&oact.sa_mask.__val[1];
          *(_OWORD *)(a3 + 664) = *(_OWORD *)&oact.sa_handler;
          *(_OWORD *)(a3 + 680) = v20;
        }
      }
    }
    return sub_62A73C8(a1 + 88, a3, a3);
  }
  return result;
}


================================================================================
Function: sub_628D4D0 (0x628D4D0)
================================================================================

__int64 __fastcall sub_628D4D0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v5; // x20
  __int64 v7; // x1
  __int64 v8; // x8
  void (__fastcall *v9)(__int64, __int64, _QWORD); // x8
  _BYTE v11[4]; // [xsp+4h] [xbp-Ch] BYREF

  v5 = a3;
  if ( !a3 )
    v5 = *(_QWORD *)(a1 + 120);
  sub_62AC280(v5, a2);
  if ( (*(_BYTE *)(a2 + 923) & 8) == 0 )
  {
    v7 = a2 + 72;
    if ( *(_QWORD *)(a2 + 72) )
      sub_6299FAC(v5, v7);
    sub_62A6564(a2, v7);
    v8 = *(_QWORD *)(a2 + 928);
    if ( v8 )
    {
      v9 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v8 + 96);
      if ( v9 )
        v9(v5, a2, (*(_DWORD *)(a2 + 920) >> 26) & 1);
    }
    sub_628DFFC(v5);
    *(_DWORD *)(a2 + 920) |= 0x8000000u;
  }
  if ( (a4 & 1) != 0 )
    sub_628D868(v5, a2, v11);
  sub_62885D8(v5, 1LL);
  sub_62885D8(v5, 0LL);
  sub_62AC16C(v5);
  return sub_62BDBD4(v5, a2);
}


================================================================================
Function: sub_628D5D4 (0x628D5D4)
================================================================================

__int64 __fastcall sub_628D5D4(__int64 a1, __int64 a2)
{
  __int64 v2; // x21
  __int64 v5; // x0
  __int64 v6; // x21
  __int64 v7; // x1
  __int64 v8; // x0
  unsigned int v9; // w0
  unsigned int v10; // w22
  _OWORD v12[2]; // [xsp+0h] [xbp-30h] BYREF

  v2 = a1 + 88;
  if ( sub_62A75F0(a1 + 88) && (v5 = sub_62A75F0(v2)) != 0 )
  {
    v6 = v5;
    while ( 1 )
    {
      v7 = sub_62A7600(v6);
      v8 = *(_QWORD *)(a1 + 120);
      memset(v12, 0, sizeof(v12));
      sub_62AC280(v8, v7);
      sub_62891A4(*(_QWORD *)(a1 + 120), v12);
      sub_62AC16C(*(_QWORD *)(a1 + 120));
      v9 = sub_62B1B3C(a2, v12);
      if ( v9 )
        break;
      v6 = sub_62A7608(v6);
      if ( !v6 )
        return 0;
    }
    v10 = v9;
    sub_62B1AFC(a2);
  }
  else
  {
    return 0;
  }
  return v10;
}


================================================================================
Function: sub_628D73C (0x628D73C)
================================================================================

__int64 __fastcall sub_628D73C(__int64 a1)
{
  __int64 v2; // x19
  __int64 result; // x0
  __int64 v4; // x24
  _QWORD *v5; // x22
  __int64 v6; // x21
  __int64 v7; // x23
  __int64 v8; // x25
  __int64 v9; // x0
  __int64 v10; // x1
  _BYTE v12[4]; // [xsp+4h] [xbp-1Ch] BYREF
  _QWORD v13[2]; // [xsp+8h] [xbp-18h] BYREF

  v2 = *(_QWORD *)(a1 + 120);
  result = sub_62A75F0(a1 + 88);
  if ( result )
  {
    v4 = result;
    v5 = 0LL;
    v6 = 0LL;
    do
    {
      while ( 1 )
      {
        v7 = sub_62A7608(v4);
        v8 = sub_62A7600(v4);
        sub_62AC280(v2, v8);
        sub_628D868(v2, v8, v12);
        v9 = sub_62AC16C(v2);
        if ( !v12[0] )
          break;
        sub_62A74BC(v4);
        result = sub_628D4D0(a1, v8, 0LL, 0LL);
        v4 = v7;
        if ( !v7 )
          goto LABEL_13;
      }
      if ( !v5 )
      {
        v5 = v13;
        v13[0] = sub_62BBCF8(v9);
        v13[1] = v10;
      }
      result = sub_6289EAC(v8, v5);
      if ( result < v6 && result != 0 )
        v6 = result;
      v4 = v7;
    }
    while ( v7 );
LABEL_13:
    if ( v6 )
      return sub_62ABB40(v2, v6, 8LL);
  }
  return result;
}


================================================================================
Function: sub_628D868 (0x628D868)
================================================================================

__int64 __fastcall sub_628D868(__int64 result, __int64 a2, _BYTE *a3)
{
  __int64 v5; // x21
  int v6; // w8
  __int64 v7; // x1
  __int64 v8; // x8
  void (__fastcall *v9)(__int64, __int64, _QWORD); // x8
  int v10; // w22
  _BOOL4 v11; // w8
  int v12; // w8
  char v13[4]; // [xsp+0h] [xbp-10h] BYREF
  char v14[4]; // [xsp+4h] [xbp-Ch] BYREF

  v5 = result;
  v6 = *(_DWORD *)(a2 + 920);
  if ( (v6 & 0x8000000) == 0 )
  {
    v7 = a2 + 72;
    if ( *(_QWORD *)(a2 + 72) )
      sub_6299FAC(result, v7);
    sub_62A6564(a2, v7);
    v8 = *(_QWORD *)(a2 + 928);
    if ( v8 )
    {
      v9 = *(void (__fastcall **)(__int64, __int64, _QWORD))(v8 + 96);
      if ( v9 )
        v9(v5, a2, (*(_DWORD *)(a2 + 920) >> 26) & 1);
    }
    result = sub_628DFFC(v5);
    v6 = *(_DWORD *)(a2 + 920) | 0x8000000;
    *(_DWORD *)(a2 + 920) = v6;
  }
  if ( (v6 & 0x10000000) != 0 )
  {
    *a3 = 1;
    return result;
  }
  if ( *(_BYTE *)(a2 + 1109) || (result = sub_6288F70(a2, 0LL), (result & 1) == 0) )
  {
    v10 = 0;
    v14[0] = 1;
    if ( *(_BYTE *)(a2 + 1109) )
      goto LABEL_18;
  }
  else
  {
    result = sub_6288620(v5, 0LL, v14);
    v10 = result;
    if ( *(_BYTE *)(a2 + 1109) )
      goto LABEL_18;
  }
  result = sub_6288F70(a2, 1LL);
  if ( (result & 1) != 0 )
  {
    result = sub_6288620(v5, 1LL, v13);
    v11 = result != 0;
    if ( v10 )
      goto LABEL_22;
    goto LABEL_19;
  }
LABEL_18:
  v11 = 0;
  v13[0] = 1;
  if ( v10 )
  {
LABEL_22:
    *a3 = 1;
    goto LABEL_23;
  }
LABEL_19:
  if ( v11 )
    goto LABEL_22;
  v12 = (v14[0] != 0) & v13[0];
  *a3 = v12;
  if ( v12 == 1 )
LABEL_23:
    *(_DWORD *)(a2 + 920) |= 0x10000000u;
  return result;
}


================================================================================
Function: sub_628DBB4 (0x628DBB4)
================================================================================

__int64 __fastcall sub_628DBB4(_QWORD *a1, __int64 a2)
{
  __int64 v3; // x8
  __int64 v4; // x8
  __int64 v5; // x19
  __int64 v6; // x8
  __int64 v7; // x21
  __int64 v8; // x0
  __int64 v9; // x22
  __int64 v10; // x21
  __int64 v11; // x23
  __int64 v12; // x8
  _QWORD v14[3]; // [xsp+0h] [xbp-20h] BYREF

  if ( !a1 )
    return 0LL;
  v3 = a1[28];
  if ( !v3 || (*(_BYTE *)(v3 + 4) & 0x20) == 0 )
  {
    v4 = a1[27];
    if ( v4 || (v4 = a1[26]) != 0 )
    {
      v5 = v4 + 368;
      v6 = *(_QWORD *)(v4 + 504);
      if ( !v6 )
        goto LABEL_12;
LABEL_10:
      if ( (*(_BYTE *)(v6 + 4) & 0x20) != 0 )
        sub_62B9860(*(_QWORD *)(v5 + 120), 5);
      goto LABEL_12;
    }
    return 0LL;
  }
  v5 = v3 + 40;
  v6 = *(_QWORD *)(v3 + 176);
  if ( v6 )
    goto LABEL_10;
LABEL_12:
  *(_BYTE *)(v5 + 152) |= 1u;
  sub_6298630(v5, v14);
  v8 = sub_629863C((__int64)v14);
  if ( v8 )
  {
    v9 = v8;
    do
    {
      v10 = *(_QWORD *)(v9 + 32);
      v9 = sub_629863C((__int64)v14);
      v11 = sub_62A75F0(v10);
      while ( v11 )
      {
        v7 = sub_62A7600(v11);
        v11 = sub_62A7608(v11);
        if ( *(_QWORD *)(v7 + 48) == a2 )
          goto LABEL_20;
      }
    }
    while ( v9 );
  }
  v7 = 0LL;
LABEL_20:
  v12 = *(_QWORD *)(v5 + 136);
  *(_BYTE *)(v5 + 152) &= ~1u;
  if ( v12 && (*(_BYTE *)(v12 + 4) & 0x20) != 0 )
    sub_62B98A4(*(_QWORD *)(v5 + 120), 5);
  return v7;
}


================================================================================
Function: sub_628DD10 (0x628DD10)
================================================================================

_QWORD *__fastcall sub_628DD10(
        _QWORD *result,
        __int64 a2,
        __int64 (__fastcall *a3)(__int64, _QWORD *, __int64),
        __int64 a4)
{
  _QWORD *v6; // x21
  __int64 v8; // x8
  __int64 v9; // x8
  __int64 v10; // x23
  __int64 v11; // x8
  __int64 v12; // x24
  __int64 v13; // x25
  __int64 v14; // x25
  __int64 v15; // x26
  __int64 v16; // x8
  _QWORD v17[3]; // [xsp+0h] [xbp-20h] BYREF

  if ( !result )
    return result;
  v6 = result;
  v8 = result[28];
  if ( !v8 || (*(_BYTE *)(v8 + 4) & 0x20) == 0 )
  {
    v9 = result[27];
    if ( !v9 )
    {
      v9 = result[26];
      if ( !v9 )
        return result;
    }
    v10 = v9 + 368;
    v11 = *(_QWORD *)(v9 + 504);
    if ( !v11 )
      goto LABEL_11;
    goto LABEL_9;
  }
  v10 = v8 + 40;
  v11 = *(_QWORD *)(v8 + 176);
  if ( v11 )
  {
LABEL_9:
    if ( (*(_BYTE *)(v11 + 4) & 0x20) != 0 )
      sub_62B9860(*(_QWORD *)(v10 + 120), 5);
  }
LABEL_11:
  *(_BYTE *)(v10 + 152) |= 1u;
  sub_6298630(v10, v17);
  result = (_QWORD *)sub_629863C((__int64)v17);
  if ( result )
  {
    v12 = (__int64)result;
    do
    {
      v13 = *(_QWORD *)(v12 + 32);
      v12 = sub_629863C((__int64)v17);
      result = (_QWORD *)sub_62A75F0(v13);
      v14 = (__int64)result;
      while ( v14 )
      {
        v15 = sub_62A7600(v14);
        result = (_QWORD *)sub_62A7608(v14);
        v14 = (__int64)result;
        if ( *(_QWORD *)(v15 + 48) == a2 )
        {
          result = (_QWORD *)a3(v15, v6, a4);
          goto LABEL_18;
        }
      }
    }
    while ( v12 );
  }
LABEL_18:
  v16 = *(_QWORD *)(v10 + 136);
  *(_BYTE *)(v10 + 152) &= ~1u;
  if ( v16 )
  {
    if ( (*(_BYTE *)(v16 + 4) & 0x20) != 0 )
      return (_QWORD *)sub_62B98A4(*(_QWORD *)(v10 + 120), 5);
  }
  return result;
}


================================================================================
Function: sub_628DE8C (0x628DE8C)
================================================================================

__int64 __fastcall sub_628DE8C(
        _QWORD *a1,
        __int64 a2,
        __int64 (__fastcall *a3)(__int64, _QWORD *, __int64),
        __int64 a4)
{
  __int64 (__fastcall *v5)(__int64, _QWORD *, __int64); // x3
  __int64 v8; // x8
  __int64 v9; // x8
  __int64 v10; // x22
  __int64 v11; // x8
  __int64 result; // x0
  __int64 v13; // x8

  v5 = a3;
  if ( !a1 )
    return a3(a2, a1, a4);
  v8 = a1[28];
  if ( v8 && (*(_BYTE *)(v8 + 4) & 0x20) != 0 )
  {
    v10 = v8 + 40;
    v11 = *(_QWORD *)(v8 + 176);
    if ( !v11 )
      goto LABEL_12;
LABEL_10:
    if ( (*(_BYTE *)(v11 + 4) & 0x20) != 0 )
    {
      sub_62B9860(*(_QWORD *)(v10 + 120), 5);
      v5 = a3;
    }
    goto LABEL_12;
  }
  v9 = a1[27];
  if ( !v9 )
  {
    v9 = a1[26];
    if ( !v9 )
      return a3(a2, a1, a4);
  }
  v10 = v9 + 368;
  v11 = *(_QWORD *)(v9 + 504);
  if ( v11 )
    goto LABEL_10;
LABEL_12:
  *(_BYTE *)(v10 + 152) |= 1u;
  result = v5(a2, a1, a4);
  v13 = *(_QWORD *)(v10 + 136);
  *(_BYTE *)(v10 + 152) &= ~1u;
  if ( v13 )
  {
    if ( (*(_BYTE *)(v13 + 4) & 0x20) != 0 )
      return sub_62B98A4(*(_QWORD *)(v10 + 120), 5);
  }
  return result;
}


================================================================================
Function: sub_628DF98 (0x628DF98)
================================================================================

__int64 sub_628DF98()
{
  return 0LL;
}


================================================================================
Function: sub_628DFA4 (0x628DFA4)
================================================================================

__int64 __fastcall sub_628DFA4(__int64 a1, __int64 *a2)
{
  __int64 v3; // x8
  __int64 result; // x0

  v3 = off_6C2D138(1LL, 16LL);
  if ( v3 )
    result = 0LL;
  else
    result = 27LL;
  *a2 = v3;
  return result;
}


================================================================================
Function: sub_628DFEC (0x628DFEC)
================================================================================

unsigned __int64 __fastcall sub_628DFEC(unsigned __int64 a1)
{
  return ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(a1);
}


================================================================================
Function: sub_628DFFC (0x628DFFC)
================================================================================

__int64 __fastcall sub_628DFFC(__int64 a1)
{
  _QWORD *v1; // x19
  __int64 *v2; // x22
  unsigned int v3; // w20
  __int64 v4; // x21
  pthread_mutex_t **v5; // x24
  pthread_mutex_t *v6; // x0
  int v7; // w25
  __int64 v8; // x0
  __int64 v9; // x0
  int v10; // w0
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 result; // x0

  v1 = (_QWORD *)(a1 + 3224);
  v2 = *(__int64 **)(a1 + 3240);
  if ( v2 )
  {
    v3 = *((_DWORD *)v2 + 14);
    v4 = v2[6];
    v5 = (pthread_mutex_t **)(v2 + 3);
    pthread_mutex_lock((pthread_mutex_t *)v2[3]);
    v6 = (pthread_mutex_t *)v2[3];
    v7 = *((_DWORD *)v2 + 8);
    *((_DWORD *)v2 + 8) = 1;
    pthread_mutex_unlock(v6);
    v8 = *v2;
    if ( v7 )
    {
      if ( v8 )
        sub_628E8D8(v2);
      if ( *v5 )
      {
        pthread_mutex_destroy(*v5);
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)*v5);
      }
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v2[5]);
      v9 = v2[9];
      if ( v9 )
        sub_628E92C(v9);
      v10 = *((_DWORD *)v2 + 15);
      if ( v10 != -1 )
        close(v10);
      v11 = off_6C2D120[0];
      *(_OWORD *)(v2 + 13) = 0u;
      *(_OWORD *)(v2 + 15) = 0u;
      *(_OWORD *)(v2 + 9) = 0u;
      *(_OWORD *)(v2 + 11) = 0u;
      *(_OWORD *)(v2 + 5) = 0u;
      *(_OWORD *)(v2 + 7) = 0u;
      *(_OWORD *)v5 = 0u;
      ((void (__fastcall *)(_QWORD))v11)(v1[2]);
    }
    else
    {
      sub_628E89C(v8);
    }
    sub_62AE038(v4, v3);
    close(v3);
  }
  v12 = off_6C2D120[0];
  v1[2] = 0LL;
  result = ((__int64 (__fastcall *)(_QWORD))v12)(*v1);
  *v1 = 0LL;
  return result;
}


================================================================================
Function: sub_628E114 (0x628E114)
================================================================================

void __fastcall sub_628E114(__int64 a1)
{
  pthread_t **v2; // x0

  v2 = *(pthread_t ***)(a1 + 3240);
  if ( v2 && *v2 && (*(_DWORD *)(a1 + 2458) & 0x20) == 0 )
  {
    sub_628E8D8(v2);
    *(_BYTE *)(a1 + 3264) |= 1u;
  }
  JUMPOUT(0x628E004LL);
}


================================================================================
Function: sub_628E89C (0x628E89C)
================================================================================

pthread_t *__fastcall sub_628E89C(pthread_t *result)
{
  unsigned __int64 v1; // x19

  if ( result )
  {
    v1 = (unsigned __int64)result;
    pthread_detach(*result);
    return (pthread_t *)((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1);
  }
  return result;
}


================================================================================
Function: sub_628E8D8 (0x628E8D8)
================================================================================

bool __fastcall sub_628E8D8(pthread_t **a1)
{
  _BOOL4 v2; // w20
  _BOOL8 result; // x0

  v2 = pthread_join(**a1, 0LL) == 0;
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)*a1);
  result = v2;
  *a1 = 0LL;
  return result;
}


================================================================================
Function: sub_628E92C (0x628E92C)
================================================================================

unsigned __int64 __fastcall sub_628E92C(unsigned __int64 result)
{
  unsigned __int64 v1; // x20

  if ( result )
  {
    do
    {
      v1 = *(_QWORD *)(result + 40);
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(result);
      result = v1;
    }
    while ( v1 );
  }
  return result;
}


================================================================================
Function: sub_628F4E0 (0x628F4E0)
================================================================================

_QWORD *__fastcall sub_628F4E0(_QWORD *result, __int64 a2)
{
  *result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = a2;
  return result;
}


================================================================================
Function: sub_628F4EC (0x628F4EC)
================================================================================

unsigned __int64 __fastcall sub_628F4EC(unsigned __int64 *a1)
{
  unsigned __int64 result; // x0

  result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(*a1);
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  return result;
}


================================================================================
Function: sub_628F524 (0x628F524)
================================================================================

__int64 __fastcall sub_628F524(__int64 result)
{
  if ( *(_QWORD *)(result + 8) )
    **(_BYTE **)result = 0;
  *(_QWORD *)(result + 8) = 0LL;
  return result;
}


================================================================================
Function: sub_628F53C (0x628F53C)
================================================================================

__int64 __fastcall sub_628F53C(__int64 a1, size_t n)
{
  size_t v2; // x8
  __int64 result; // x0
  _BYTE *v6; // x8

  v2 = *(_QWORD *)(a1 + 8);
  if ( v2 < n )
    return 43LL;
  if ( v2 == n )
    return 0LL;
  if ( n )
  {
    memmove(*(void **)a1, (const void *)(*(_QWORD *)a1 + v2 - n), n);
    result = 0LL;
    v6 = *(_BYTE **)a1;
    *(_QWORD *)(a1 + 8) = n;
    v6[n] = 0;
  }
  else
  {
    if ( v2 )
      **(_BYTE **)a1 = 0;
    result = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_628F5B8 (0x628F5B8)
================================================================================

__int64 __fastcall sub_628F5B8(unsigned __int64 *a1, void *src, size_t n)
{
  unsigned __int64 v3; // x24
  unsigned __int64 v5; // x22
  unsigned __int64 v6; // x23
  size_t v7; // x9
  __int64 result; // x0
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x11
  size_t v13; // x10
  __int64 v14; // x0
  __int64 v15; // x8

  v3 = a1[1];
  v5 = a1[3];
  v6 = v3 + n;
  v7 = v3 + n + 1;
  if ( v7 > v5 )
  {
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*a1);
    result = 100LL;
LABEL_3:
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
    return result;
  }
  v11 = a1[2];
  if ( v11 )
  {
    v12 = a1[2];
    do
    {
      v13 = v12;
      v12 *= 2LL;
    }
    while ( v13 < v7 );
    if ( v13 <= v5 )
      v5 = v13;
  }
  else if ( v5 >= 0x20 )
  {
    if ( v7 <= 0x20 )
      v5 = 32LL;
    else
      v5 = v3 + n + 1;
  }
  if ( v5 != v11 )
  {
    v14 = off_6C2D128(*a1, v5);
    if ( !v14 )
    {
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*a1);
      result = 27LL;
      goto LABEL_3;
    }
    *a1 = v14;
    a1[2] = v5;
  }
  if ( n )
    memcpy((void *)(*a1 + v3), src, n);
  result = 0LL;
  v15 = *a1;
  a1[1] = v6;
  *(_BYTE *)(v15 + v6) = 0;
  return result;
}


================================================================================
Function: sub_628F7BC (0x628F7BC)
================================================================================

__int64 __fastcall sub_628F7BC(__int64 a1)
{
  return *(_QWORD *)a1;
}


================================================================================
Function: sub_628F7CC (0x628F7CC)
================================================================================

__int64 __fastcall sub_628F7CC(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}


================================================================================
Function: sub_6291370 (0x6291370)
================================================================================

unsigned __int64 __fastcall sub_6291370(unsigned __int64 result)
{
  unsigned __int64 *v1; // x20
  unsigned __int64 v2; // x19
  _QWORD *v3; // x0

  v1 = *(unsigned __int64 **)(result + 440);
  if ( v1 )
  {
    v2 = result;
    sub_6291C54();
    sub_62B99E4(*v1);
    v3 = *(_QWORD **)(v2 + 440);
    *v3 = 0LL;
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v3);
    *(_QWORD *)(v2 + 440) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_6291C54 (0x6291C54)
================================================================================

__int64 __fastcall sub_6291C54(__int64 result)
{
  __int64 v1; // x21
  __int64 v2; // x19
  __int64 v3; // [xsp+0h] [xbp-10h] BYREF

  v1 = *(_QWORD *)(result + 440);
  if ( v1 )
  {
    v2 = result;
    result = *(_QWORD *)(result + 208);
    if ( result )
    {
      if ( (*(_QWORD *)(v1 + 8) & 0x8000000000000000LL) == 0 )
      {
        *(_QWORD *)(v1 + 8) = -1LL;
        result = ((__int64 (*)(void))sub_62AEB00)();
        v3 = result;
        if ( result )
        {
          sub_62ABCAC(*(_QWORD *)(v2 + 208), result);
          result = sub_62BD5E8((unsigned __int64 *)&v3);
        }
      }
      if ( (*(_QWORD *)(v1 + 576) & 0x8000000000000000LL) == 0 )
      {
        *(_QWORD *)(v1 + 576) = -1LL;
        result = *(_QWORD *)(v2 + 208);
        if ( result )
        {
          result = sub_62AEB00(result);
          v3 = result;
          if ( result )
          {
            sub_62ABCAC(*(_QWORD *)(v2 + 208), result);
            return sub_62BD5E8((unsigned __int64 *)&v3);
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6293F24 (0x6293F24)
================================================================================

unsigned __int64 **__fastcall sub_6293F24(unsigned __int64 **result)
{
  unsigned __int64 *v1; // x20
  unsigned __int64 **v2; // x19
  __int64 v3; // x0
  __int64 v4; // x21
  unsigned __int64 *v5; // x22

  v1 = *result;
  if ( *result )
  {
    v2 = result;
    v3 = sub_62A75F0((__int64)(v1 + 1));
    if ( v3 )
    {
      v4 = v3;
      do
      {
        v5 = (unsigned __int64 *)sub_62A7600(v4);
        v4 = sub_62A7608(v4);
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*v5);
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v5[2]);
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v5);
      }
      while ( v4 );
    }
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*v1);
    result = (unsigned __int64 **)((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v1);
    *v2 = 0LL;
  }
  return result;
}


================================================================================
Function: sub_6293FCC (0x6293FCC)
================================================================================

__int64 __fastcall sub_6293FCC(int a1, __int64 a2, char *a3)
{
  char *v3; // x19
  unsigned int v5; // w24
  __int64 v6; // x0
  __int64 v7; // x20
  const char *v8; // x7
  const char **v9; // x23
  unsigned int v10; // w0
  int v11; // w0
  const char *v12; // x24
  const char *v13; // x21
  int v14; // w0
  int v15; // w8
  const char *v16; // x3
  const char *v17; // x5
  const char *v18; // x2
  int v19; // w8
  FILE *v21; // [xsp+70h] [xbp-60h]
  _DWORD v22[14]; // [xsp+78h] [xbp-58h] BYREF
  _BYTE buf[16]; // [xsp+B0h] [xbp-20h] BYREF

  if ( !a2 )
    return 0;
  v3 = a3;
  if ( !a3 )
    v3 = *(char **)a2;
  v5 = 0;
  if ( (*(_BYTE *)(a2 + 40) & 4) != 0 || !v3 )
    return v5;
  if ( !*v3 )
    return 0;
  v5 = sub_629760C(a1, v3);
  if ( !v5 )
  {
    fwrite(
      "# Your alt-svc cache. https://curl.se/docs/alt-svc.html\n"
      "# This file was generated by libcurl! Edit at your own risk.\n",
      0x75uLL,
      1uLL,
      v21);
    v6 = sub_62A75F0(a2 + 8);
    if ( v6 )
    {
      v7 = v6;
      while ( 1 )
      {
        v9 = (const char **)sub_62A7600(v7);
        v7 = sub_62A7608(v7);
        v10 = sub_62AFABC(v9[4], v22);
        if ( v10 )
          break;
        v11 = inet_pton(10, v9[2], buf);
        if ( v11 == 1 )
          v12 = "[";
        else
          v12 = &byte_CBCB6C;
        if ( v11 == 1 )
          v13 = "]";
        else
          v13 = &byte_CBCB6C;
        v14 = inet_pton(10, *v9, buf);
        v15 = *((_DWORD *)v9 + 3);
        if ( v14 == 1 )
          v16 = "[";
        else
          v16 = &byte_CBCB6C;
        if ( v14 == 1 )
          v17 = "]";
        else
          v17 = &byte_CBCB6C;
        switch ( v15 )
        {
          case 8:
            v18 = "h1";
            break;
          case 32:
            v18 = "h3";
            break;
          case 16:
            v18 = "h2";
            break;
          default:
            v18 = &byte_CBCB6C;
            break;
        }
        v19 = *((_DWORD *)v9 + 7);
        switch ( v19 )
        {
          case 8:
            v8 = "h1";
            break;
          case 32:
            v8 = "h3";
            break;
          case 16:
            v8 = "h2";
            break;
          default:
            v8 = &byte_CBCB6C;
            break;
        }
        sub_62AB478(
          v21,
          "%s %s%s%s %u %s %s%s%s %u \"%d%02d%02d %02d:%02d:%02d\" %u %u\n",
          v18,
          v16,
          *v9,
          v17,
          *((unsigned __int16 *)v9 + 4),
          v8,
          v12,
          v9[2],
          v13,
          *((unsigned __int16 *)v9 + 12),
          v22[5] + 1900,
          v22[4] + 1,
          v22[3],
          v22[2],
          v22[1],
          v22[0],
          *((unsigned __int8 *)v9 + 40),
          *((_DWORD *)v9 + 11));
        if ( !v7 )
          goto LABEL_39;
      }
      v5 = v10;
    }
    else
    {
LABEL_39:
      v5 = 0;
    }
    fclose(v21);
  }
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(0LL);
  return v5;
}


================================================================================
Function: sub_6294EDC (0x6294EDC)
================================================================================

const char *__fastcall sub_6294EDC(int a1, FILE *a2)
{
  const char *result; // x0
  char *v5; // x21
  const char *v6; // x22
  char s[128]; // [xsp+8h] [xbp-88h] BYREF

  sub_628F524();
  while ( 1 )
  {
    result = fgets(s, 128, a2);
    if ( !result )
      break;
    v5 = (char *)result;
    result = (const char *)strlen(result);
    if ( !result )
      break;
    v6 = result;
    if ( (unsigned int)sub_628F5B8(a1, v5, (size_t)result) )
      return 0LL;
    if ( v5[(_QWORD)v6 - 1] == 10 )
      return (_BYTE *)(&dword_0 + 1);
    if ( feof(a2) )
      return (const char *)((unsigned int)sub_628F5B8(a1, "\n", 1uLL) == 0);
  }
  return result;
}


================================================================================
Function: sub_629507C (0x629507C)
================================================================================

__int64 __fastcall sub_629507C(__int64 a1, char *s1, __int64 a3, char a4)
{
  __int64 v5; // x19
  __int64 v8; // x0
  FILE *v9; // x0
  struct _IO_FILE *v10; // x21
  FILE *v11; // x22
  unsigned __int8 *v12; // x24
  int v13; // w0
  int v14; // w8
  __int64 v16; // x8
  _BYTE v18[32]; // [xsp+8h] [xbp-28h] BYREF

  v5 = a3;
  if ( a3 )
  {
LABEL_4:
    *(_BYTE *)(v5 + 521) = a4 & 1;
    if ( !a1 )
    {
LABEL_31:
      *(_BYTE *)(v5 + 520) = 1;
      return v5;
    }
    if ( s1 && *s1 )
    {
      if ( !strcmp(s1, "-") )
      {
        *(_BYTE *)(v5 + 520) = 0;
        v10 = stdin;
        if ( stdin )
        {
          v11 = 0LL;
          goto LABEL_12;
        }
LABEL_30:
        *(_DWORD *)(a1 + 4692) |= 0x800u;
        goto LABEL_31;
      }
      v9 = fopen(s1, "rb");
      if ( v9 )
      {
        v10 = v9;
        v11 = v9;
        *(_BYTE *)(v5 + 520) = 0;
LABEL_12:
        sub_628F4E0(v18, 5000LL);
        while ( (unsigned int)sub_6294EDC(v18, v10) )
        {
          v12 = (unsigned __int8 *)sub_628F7BC(v18);
          v13 = sub_62BB7E8(v12, "Set-Cookie:", 11LL);
          if ( v13 )
          {
            for ( v12 += 11; ; ++v12 )
            {
              v14 = *v12;
              if ( v14 != 32 && v14 != 9 )
                break;
            }
          }
          sub_629528C(a1, v5, v13 != 0, 1LL, v12, 0LL, 0LL, 1LL);
        }
        sub_628F4EC(v18);
        sub_6296558(v5);
        if ( v11 )
          fclose(v11);
        goto LABEL_30;
      }
      if ( (*(_DWORD *)(a1 + 2458) & 0x100000) != 0 )
      {
        v16 = *(_QWORD *)(a1 + 4576);
        if ( !v16 || *(int *)(v16 + 8) >= 1 )
          sub_628595C(a1, "WARNING: failed to open cookie file \"%s\"", s1);
      }
    }
    *(_BYTE *)(v5 + 520) = 0;
    goto LABEL_30;
  }
  v8 = off_6C2D138(1LL, 528LL);
  v5 = v8;
  if ( v8 )
  {
    *(_QWORD *)(v8 + 504) = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_4;
  }
  return v5;
}


================================================================================
Function: sub_629528C (0x629528C)
================================================================================

unsigned __int64 __fastcall sub_629528C(
        __int64 a1,
        __int64 a2,
        char a3,
        char a4,
        char *a5,
        const char *a6,
        const char *a7,
        int a8)
{
  time_t v14; // x0
  unsigned __int64 v15; // x27
  time_t v16; // x26
  __int64 v17; // x0
  unsigned __int64 v18; // x20
  char *v19; // x19
  char *i; // x28
  int v21; // w8
  bool v22; // zf
  size_t v23; // x0
  size_t v24; // x27
  unsigned __int64 v25; // x23
  int v26; // w8
  int v28; // w25
  int v29; // w24
  const char *v30; // x22
  size_t v31; // x0
  size_t v32; // x21
  const char *v33; // x8
  int v34; // w9
  size_t v36; // x27
  char v37; // w8
  __int64 j; // x9
  int v39; // w11
  __int64 v41; // x0
  __int64 v42; // x0
  __int64 v43; // x0
  unsigned __int64 v44; // x8
  const char *v45; // x0
  const char *v46; // x22
  _BOOL8 v47; // x9
  size_t v48; // x23
  _BYTE *v49; // x0
  char *v50; // x19
  char *v51; // x0
  char v52; // w27
  __int64 *v53; // x19
  const char *v54; // x0
  int v55; // w0
  char *v56; // x8
  __int64 v57; // x0
  __int64 v58; // x8
  __int64 v59; // x0
  __int64 v60; // x8
  int v61; // w8
  __int64 v62; // x8
  int v63; // w8
  char *v65; // x0
  char *v66; // x0
  char *v67; // x0
  const char *v68; // x28
  int v69; // w24
  int v70; // w22
  const char *v71; // x0
  char *v72; // x0
  char *v73; // x0
  __int64 v74; // x0
  char *v75; // x0
  char v76; // w8
  char *v77; // x0
  char *v78; // x0
  char *(*v79)(const char *); // x8
  _BOOL4 v80; // w19
  __int64 v81; // x0
  char *v82; // x0
  char *v83; // x0
  char v84; // w8
  int v85; // w8
  unsigned __int64 *v86; // x22
  unsigned __int64 v87; // x8
  char v88; // w19
  unsigned __int64 v89; // x21
  int v90; // w24
  unsigned __int64 v91; // x23
  __int64 v92; // x0
  __int64 v93; // x1
  __int64 v94; // x8
  char *v95; // x8
  const char *v96; // x0
  size_t v97; // x2
  __int64 v98; // x0
  __int64 v99; // x1
  bool v100; // zf
  int v101; // w8
  __int64 v102; // x0
  __int64 v103; // x1
  __int64 v104; // x8
  const char *v105; // x0
  char *v107; // x0
  char *v108; // x0
  _BYTE *v109; // x0
  __int128 v110; // q0
  __int64 v111; // x8
  __int128 v112; // q2
  __int64 v113; // x8
  __int64 v114; // x8
  unsigned __int64 *v115; // x8
  __int64 v116; // x8
  __int64 v117; // x8
  __int64 v118; // x8
  const char *v119; // x2
  __int64 v120; // x0
  __int64 v121; // x0
  __int64 *v122; // [xsp+10h] [xbp-D0h]
  _DWORD *v123; // [xsp+18h] [xbp-C8h]
  char v124; // [xsp+24h] [xbp-BCh]
  __int64 v125; // [xsp+28h] [xbp-B8h]
  __int64 v126; // [xsp+30h] [xbp-B0h]
  char v127; // [xsp+3Ch] [xbp-A4h]
  char *v129; // [xsp+48h] [xbp-98h]
  char *save_ptr[16]; // [xsp+50h] [xbp-90h] BYREF

  v129 = (char *)a6;
  v14 = time(0LL);
  v15 = 0LL;
  if ( *(unsigned __int8 *)(a1 + 448) > 0x31u )
    return v15;
  v125 = a1;
  v126 = a2;
  v16 = v14;
  v17 = off_6C2D138(1LL, 72LL);
  if ( !v17 )
    return 0LL;
  v18 = v17;
  v127 = a4;
  if ( (a3 & 1) == 0 )
  {
    save_ptr[0] = 0LL;
    if ( !strncmp(a5, "#HttpOnly_", 0xAuLL) )
    {
      a5 += 10;
      *(_BYTE *)(v18 + 59) = 1;
    }
    if ( *a5 == 35 )
      goto LABEL_141;
    v65 = strchr(a5, 13);
    if ( v65 )
      *v65 = 0;
    v66 = strchr(a5, 10);
    if ( v66 )
      *v66 = 0;
    LODWORD(v129) = a8;
    v67 = strtok_r(a5, "\t", save_ptr);
    if ( !v67 )
    {
      v70 = 0;
      v69 = 0;
      goto LABEL_187;
    }
    v68 = v67;
    v69 = 0;
    v70 = 0;
    while ( 1 )
    {
      switch ( v69 )
      {
        case 0:
          if ( *v68 == 46 )
            v71 = v68 + 1;
          else
            v71 = v68;
          v72 = off_6C2D130(v71);
          v69 = 0;
          *(_QWORD *)(v18 + 40) = v72;
          v70 |= v72 == 0LL;
          goto LABEL_176;
        case 1:
          v69 = 1;
          *(_BYTE *)(v18 + 56) = (unsigned int)sub_62BB770(v68, "TRUE") != 0;
          goto LABEL_176;
        case 2:
          if ( !strcmp("TRUE", v68) || !strcmp("FALSE", v68) )
          {
            v78 = off_6C2D130("/");
            v79 = off_6C2D130;
            *(_QWORD *)(v18 + 24) = v78;
            v80 = v78 == 0LL;
            v81 = (__int64)v79("/");
            *(_QWORD *)(v18 + 32) = v81;
            v70 |= v81 == 0 || v80;
            goto LABEL_164;
          }
          v73 = off_6C2D130(v68);
          *(_QWORD *)(v18 + 24) = v73;
          if ( v73 )
          {
            v74 = ((__int64 (*)(void))sub_62963FC)();
            v69 = 2;
            *(_QWORD *)(v18 + 32) = v74;
            v70 |= v74 == 0;
          }
          else
          {
            v69 = 2;
            v70 = 1;
          }
          goto LABEL_176;
        case 3:
LABEL_164:
          *(_BYTE *)(v18 + 57) = 0;
          if ( (unsigned int)sub_62BB770(v68, "TRUE") )
          {
            if ( ((unsigned __int8)v129 & 1) != 0 || *(_BYTE *)(v126 + 520) )
            {
              v69 = 3;
              *(_BYTE *)(v18 + 57) = 1;
            }
            else
            {
              v69 = 3;
              v70 = 1;
            }
          }
          else
          {
            v69 = 3;
          }
          goto LABEL_176;
        case 4:
          v69 = 4;
          v70 |= (unsigned int)sub_62BBBA0(v68, 0LL, 10LL, v18 + 48) != 0;
          goto LABEL_176;
        case 5:
          v75 = off_6C2D130(v68);
          *(_QWORD *)(v18 + 8) = v75;
          if ( !v75 )
          {
            v69 = 5;
            v70 = 1;
            goto LABEL_176;
          }
          if ( sub_62BB7E8((unsigned __int64)"__Secure-", (unsigned __int64)v75, 9LL) )
          {
            v76 = *(_BYTE *)(v18 + 64) | 1;
LABEL_172:
            v69 = 5;
            *(_BYTE *)(v18 + 64) = v76;
            goto LABEL_176;
          }
          if ( sub_62BB7E8((unsigned __int64)"__Host-", *(_QWORD *)(v18 + 8), 7LL) )
          {
            v76 = *(_BYTE *)(v18 + 64) | 2;
            goto LABEL_172;
          }
          v69 = 5;
LABEL_176:
          v82 = strtok_r(0LL, "\t", save_ptr);
          ++v69;
          if ( !v82 || (v68 = v82, (v70 & 1) != 0) )
          {
            if ( v69 == 6 )
            {
              v83 = off_6C2D130(&byte_CBCB6C);
              if ( v83 )
                v69 = 7;
              else
                v69 = 6;
              v70 |= v83 == 0LL;
              *(_QWORD *)(v18 + 16) = v83;
            }
LABEL_187:
            if ( (v70 & 1) != 0 || ((v69 != 7) & ~v70) != 0 )
              goto LABEL_246;
            LOBYTE(a8) = (_BYTE)v129;
            v84 = *(_BYTE *)(v18 + 64);
            if ( (v84 & 1) != 0 )
              goto LABEL_190;
LABEL_191:
            if ( (v84 & 2) != 0
              && (!*(_BYTE *)(v18 + 57)
               || (v105 = *(const char **)(v18 + 24)) == 0LL
               || strcmp(v105, "/")
               || *(_BYTE *)(v18 + 56)) )
            {
LABEL_246:
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 40));
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 24));
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 32));
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 8));
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 16));
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v18);
              return 0LL;
            }
            if ( !*(_BYTE *)(v126 + 520) && *(_BYTE *)(v126 + 521) && !*(_QWORD *)(v18 + 48) )
            {
LABEL_264:
              sub_6296394(v18);
              return 0LL;
            }
            *(_BYTE *)(v18 + 58) = *(_BYTE *)(v126 + 520);
            v85 = *(_DWORD *)(v126 + 516) + 1;
            *(_DWORD *)(v126 + 516) = v85;
            *(_DWORD *)(v18 + 60) = v85;
            if ( (a4 & 1) == 0 )
              sub_6296558(v126);
            v86 = (unsigned __int64 *)(v126 + 8 * sub_6296688(*(_QWORD *)(v18 + 40)));
            v87 = *v86;
            if ( *v86 )
            {
              v88 = a8;
              v89 = 0LL;
              v15 = 0LL;
              v90 = 0;
              while ( 1 )
              {
                v91 = v87;
                if ( !(unsigned int)sub_62BB770(*(_QWORD *)(v87 + 8), *(_QWORD *)(v18 + 8)) )
                  goto LABEL_198;
                v92 = *(_QWORD *)(v91 + 40);
                v93 = *(_QWORD *)(v18 + 40);
                if ( v92 )
                {
                  if ( !v93 || !(unsigned int)sub_62BB770(v92, v93) )
                    goto LABEL_198;
                }
                else if ( v93 )
                {
                  goto LABEL_198;
                }
                v94 = *(_QWORD *)(v91 + 32);
                if ( v94 && *(_QWORD *)(v18 + 32) && *(_BYTE *)(v91 + 57) && !*(_BYTE *)(v18 + 57) && (v88 & 1) == 0 )
                {
                  v95 = strchr((const char *)(v94 + 1), 47);
                  v96 = *(const char **)(v91 + 32);
                  if ( v95 )
                  {
                    v97 = v95 - v96;
                  }
                  else
                  {
                    v97 = strlen(v96);
                    v96 = *(const char **)(v91 + 32);
                  }
                  if ( sub_62BB7E8((unsigned __int64)v96, *(_QWORD *)(v18 + 32), v97) )
                  {
                    if ( v125 )
                    {
                      if ( (*(_DWORD *)(v125 + 2458) & 0x100000) != 0 )
                      {
                        v104 = *(_QWORD *)(v125 + 4576);
                        if ( !v104 || *(int *)(v104 + 8) >= 1 )
                          sub_628595C(
                            v125,
                            "cookie '%s' for domain '%s' dropped, would overlay an existing cookie",
                            *(const char **)(v18 + 8),
                            *(const char **)(v18 + 40));
                      }
                    }
                    goto LABEL_264;
                  }
                }
LABEL_198:
                if ( !v89 )
                {
                  if ( (unsigned int)sub_62BB770(*(_QWORD *)(v91 + 8), *(_QWORD *)(v18 + 8)) )
                  {
                    v98 = *(_QWORD *)(v91 + 40);
                    v99 = *(_QWORD *)(v18 + 40);
                    if ( v98 )
                    {
                      if ( v99 && (unsigned int)sub_62BB770(v98, v99) )
                      {
                        v100 = *(unsigned __int8 *)(v91 + 56) == *(unsigned __int8 *)(v18 + 56);
                        goto LABEL_219;
                      }
                      if ( (v90 & 1) == 0 )
                      {
LABEL_229:
                        v90 = 0;
                        goto LABEL_230;
                      }
                    }
                    else
                    {
                      v100 = v99 == 0;
LABEL_219:
                      v101 = v100;
                      if ( ((v101 | v90) & 1) == 0 )
                        goto LABEL_229;
                    }
                    v102 = *(_QWORD *)(v91 + 32);
                    v103 = *(_QWORD *)(v18 + 32);
                    if ( v102 )
                    {
                      if ( v103 )
                      {
                        if ( (unsigned int)sub_62BB770(v102, v103)
                          && (*(_QWORD *)(v91 + 32) != 0LL) != (*(_QWORD *)(v18 + 32) == 0LL) )
                        {
LABEL_232:
                          if ( !*(_BYTE *)(v18 + 58) && *(_BYTE *)(v91 + 58) )
                            goto LABEL_264;
                          v90 = 1;
                          v15 = v91;
                          v89 = v18;
                          goto LABEL_199;
                        }
                      }
                      else if ( *(_QWORD *)(v18 + 32) )
                      {
                        goto LABEL_232;
                      }
                    }
                    else if ( !v103 )
                    {
                      goto LABEL_232;
                    }
                    goto LABEL_229;
                  }
LABEL_230:
                  v89 = 0LL;
                }
LABEL_199:
                v87 = *(_QWORD *)v91;
                if ( !*(_QWORD *)v91 )
                {
                  if ( !v89 )
                    goto LABEL_270;
                  *(_QWORD *)v89 = *(_QWORD *)v15;
                  *(_DWORD *)(v89 + 60) = *(_DWORD *)(v15 + 60);
                  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v15 + 8));
                  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v15 + 16));
                  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v15 + 40));
                  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v15 + 24));
                  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v15 + 32));
                  *(_OWORD *)v15 = *(_OWORD *)v89;
                  v110 = *(_OWORD *)(v89 + 48);
                  v111 = *(_QWORD *)(v89 + 64);
                  v112 = *(_OWORD *)(v89 + 16);
                  *(_OWORD *)(v15 + 32) = *(_OWORD *)(v89 + 32);
                  *(_OWORD *)(v15 + 48) = v110;
                  *(_QWORD *)(v15 + 64) = v111;
                  *(_OWORD *)(v15 + 16) = v112;
                  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v89);
                  goto LABEL_271;
                }
              }
            }
            v91 = 0LL;
            LOBYTE(v90) = 0;
LABEL_270:
            v15 = v18;
LABEL_271:
            if ( v125
              && *(_BYTE *)(v126 + 520)
              && (*(_DWORD *)(v125 + 2458) & 0x100000) != 0
              && ((v118 = *(_QWORD *)(v125 + 4576)) == 0 || *(int *)(v118 + 8) >= 1) )
            {
              if ( (v90 & 1) != 0 )
                v119 = "Replaced";
              else
                v119 = "Added";
              sub_628595C(
                v125,
                "%s cookie %s=\"%s\" for domain %s, path %s, expire %ld",
                v119,
                *(const char **)(v15 + 8),
                *(const char **)(v15 + 16),
                *(const char **)(v15 + 40),
                *(const char **)(v15 + 24),
                *(_QWORD *)(v15 + 48));
              if ( (v90 & 1) != 0 )
              {
LABEL_279:
                v116 = *(_QWORD *)(v15 + 48);
                if ( v116 && v116 < *(_QWORD *)(v126 + 504) )
                  *(_QWORD *)(v126 + 504) = v116;
                return v15;
              }
            }
            else if ( (v90 & 1) != 0 )
            {
              goto LABEL_279;
            }
            if ( v91 )
              v115 = (unsigned __int64 *)v91;
            else
              v115 = v86;
            *v115 = v15;
            ++*(_DWORD *)(v126 + 512);
            goto LABEL_279;
          }
          break;
        case 6:
          v77 = off_6C2D130(v68);
          v69 = 6;
          *(_QWORD *)(v18 + 16) = v77;
          v70 |= v77 == 0LL;
          goto LABEL_176;
        default:
          goto LABEL_176;
      }
    }
  }
  if ( strlen(a5) > 0x1388 )
  {
LABEL_141:
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v18);
    return 0LL;
  }
  v124 = 0;
  v122 = (__int64 *)(v18 + 48);
  v123 = (_DWORD *)(a1 + 2458);
  while ( 1 )
  {
    v19 = a5 + 1;
    for ( i = a5; ; ++i )
    {
      v21 = (unsigned __int8)*i;
      v22 = v21 == 32 || v21 == 9;
      if ( !v22 )
        break;
      ++v19;
    }
    v23 = strcspn(i, ";\t\r\n=");
    if ( !v23 )
    {
      a5 = i;
      goto LABEL_129;
    }
    v24 = v23;
    a5 = &i[v23];
    v25 = v23;
    do
    {
      v26 = (unsigned __int8)i[v25 - 1];
      if ( v26 != 32 && v26 != 9 )
        break;
      --v25;
    }
    while ( v25 );
    v28 = a8;
    v29 = (unsigned __int8)*a5;
    if ( v29 == 61 )
    {
      v30 = &i[v23 + 1];
      v31 = strcspn(v30, ";\r\n");
      v32 = v24 + v31;
      if ( v31 )
      {
        v33 = &v19[v32];
        while ( 1 )
        {
          v34 = *((unsigned __int8 *)v33 - 1);
          if ( v34 != 32 && v34 != 9 )
            break;
          --v31;
          --v33;
          if ( !v31 )
            goto LABEL_30;
        }
        for ( j = 0LL; j != v31; ++j )
        {
          v39 = (unsigned __int8)v19[v24 + j];
          if ( v39 != 32 && v39 != 9 )
          {
            v56 = &v19[v24];
            v36 = v31 - j;
            v30 = &v56[j];
            goto LABEL_31;
          }
        }
        v36 = 0LL;
        v30 = v33;
      }
      else
      {
LABEL_30:
        v36 = 0LL;
      }
LABEL_31:
      if ( memchr(v30, 9, v36) )
      {
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 40));
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 24));
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 32));
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 8));
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 16));
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v18);
        if ( (*v123 & 0x100000) == 0 )
          return 0LL;
        v117 = *(_QWORD *)(v125 + 4576);
        if ( !v117 || *(int *)(v117 + 8) >= 1 )
          sub_628595C(v125, "cookie contains TAB, dropping");
        return 0LL;
      }
      a5 = &i[v32 + 1];
    }
    else
    {
      v36 = 0LL;
      v30 = 0LL;
    }
    if ( v25 > 0xFFE || v36 > 0xFFE || v36 + v25 > 0x1000 )
    {
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 40));
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 24));
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 32));
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 8));
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 16));
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v18);
      if ( (*v123 & 0x100000) == 0 )
        return 0LL;
      v113 = *(_QWORD *)(v125 + 4576);
      if ( !v113 || *(int *)(v113 + 8) >= 1 )
        sub_628595C(v125, "oversized cookie dropped, name/val %zu + %zu bytes", v25, v36);
      return 0LL;
    }
    if ( v25 >= 7 && *i == 95 && i[1] == 95 )
    {
      if ( sub_62BB7E8((unsigned __int64)"__Secure-", (unsigned __int64)i, 9LL) )
      {
        v37 = 1;
      }
      else
      {
        if ( !sub_62BB7E8((unsigned __int64)"__Host-", (unsigned __int64)i, 7LL) )
          goto LABEL_53;
        v37 = 2;
      }
      *(_BYTE *)(v18 + 64) |= v37;
    }
LABEL_53:
    if ( !*(_QWORD *)(v18 + 8) )
      break;
    if ( !v36 )
    {
      if ( v25 == 8 )
      {
        if ( sub_62BB7E8((unsigned __int64)"httponly", (unsigned __int64)i, 8LL) )
        {
          *(_BYTE *)(v18 + 59) = 1;
LABEL_95:
          a8 = v28;
          a4 = v127;
          goto LABEL_129;
        }
      }
      else if ( v25 == 6 && sub_62BB7E8((unsigned __int64)"secure", (unsigned __int64)i, 6LL) )
      {
        a8 = v28;
        a4 = v127;
        if ( (a8 & 1) == 0 && *(_BYTE *)(v126 + 520) )
          goto LABEL_184;
        *(_BYTE *)(v18 + 57) = 1;
        goto LABEL_129;
      }
      if ( v29 != 61 )
        goto LABEL_95;
    }
    if ( v25 == 7 )
    {
      a8 = v28;
      if ( sub_62BB7E8((unsigned __int64)"version", (unsigned __int64)i, 7LL) )
      {
        a4 = v127;
      }
      else if ( sub_62BB7E8((unsigned __int64)"max-age", (unsigned __int64)i, 7LL) )
      {
        v53 = (__int64 *)(v18 + 48);
        if ( *v30 == 34 )
          v54 = v30 + 1;
        else
          v54 = v30;
        v55 = sub_62BBBA0(v54, 0LL, 10LL, v122);
        if ( !v55 )
        {
          v62 = *v122;
          a4 = v127;
          if ( *v122 )
          {
            if ( 0x7FFFFFFFFFFFFFFFLL - v16 >= v62 )
              v60 = v62 + v16;
            else
LABEL_126:
              v60 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else
          {
LABEL_127:
            v60 = 1LL;
          }
LABEL_128:
          *v53 = v60;
          goto LABEL_129;
        }
        a4 = v127;
        if ( v55 == 2 )
          goto LABEL_127;
        if ( v55 == 1 )
          goto LABEL_126;
      }
      else
      {
        a4 = v127;
        if ( sub_62BB7E8((unsigned __int64)"expires", (unsigned __int64)i, 7LL) )
        {
          v53 = (__int64 *)(v18 + 48);
          if ( !*v122 && v36 <= 0x7F )
          {
            __memcpy_chk();
            *((_BYTE *)save_ptr + v36) = 0;
            v59 = sub_62AFA44(save_ptr);
            *v122 = v59;
            if ( !v59 )
              goto LABEL_127;
            if ( v59 < 0 )
            {
              v60 = 0LL;
              goto LABEL_128;
            }
          }
        }
      }
    }
    else
    {
      a8 = v28;
      if ( v25 != 6 )
      {
        a4 = v127;
        if ( v25 == 4 && sub_62BB7E8((unsigned __int64)"path", (unsigned __int64)i, 4LL) )
        {
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 24));
          v41 = sub_62BB9C0(v30, v36);
          *(_QWORD *)(v18 + 24) = v41;
          if ( !v41 )
            goto LABEL_184;
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 32));
          v42 = sub_62963FC(*(_QWORD *)(v18 + 24));
          *(_QWORD *)(v18 + 32) = v42;
          if ( !v42 )
            goto LABEL_184;
        }
        goto LABEL_129;
      }
      a4 = v127;
      if ( sub_62BB7E8((unsigned __int64)"domain", (unsigned __int64)i, 6LL) && v36 )
      {
        v47 = *(unsigned __int8 *)v30 == 46;
        if ( *v30 == 46 )
          ++v30;
        v48 = v36 - v47;
        if ( v36 - v47 == 9 && sub_62BB7E8((unsigned __int64)v30, (unsigned __int64)"localhost", 9LL)
          || (v49 = memchr(v30, 46, v48)) != 0LL && (unsigned __int64)(&v30[v48] - v49) > 1 )
        {
          v50 = v129;
          if ( v129 )
            v51 = v129;
          else
            v51 = (char *)v30;
          v52 = sub_62996A0(v51);
          if ( v50 )
          {
            if ( (v52 & 1) == 0 )
              goto LABEL_90;
LABEL_105:
            if ( strncmp(v30, v50, v48) || v48 != strlen(v50) )
            {
LABEL_111:
              v129 = v50;
              if ( (*v123 & 0x100000) != 0 )
              {
                v58 = *(_QWORD *)(v125 + 4576);
                if ( !v58 || *(int *)(v58 + 8) >= 1 )
                  sub_628595C(v125, "skipped cookie with bad tailmatch domain: %s", v30);
              }
              v124 = 1;
              goto LABEL_129;
            }
            v52 = 1;
          }
        }
        else
        {
          v50 = ":";
          if ( (sub_62996A0(":") & 1) != 0 )
            goto LABEL_105;
LABEL_90:
          if ( (sub_62964D8((int)v30, v48, v50) & 1) == 0 )
            goto LABEL_111;
          v52 = 0;
        }
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 40));
        v57 = sub_62BB9C0(v30, v48);
        *(_QWORD *)(v18 + 40) = v57;
        v129 = v50;
        if ( !v57 || (v52 & 1) != 0 )
        {
          if ( !v57 )
          {
            v61 = 6;
            v124 = 1;
            goto LABEL_135;
          }
        }
        else
        {
          *(_BYTE *)(v18 + 56) = 1;
        }
        goto LABEL_129;
      }
    }
    do
LABEL_129:
      v63 = (unsigned __int8)*a5++;
    while ( v63 == 32 || v63 == 9 );
    if ( v63 != 59 )
    {
LABEL_183:
      if ( (v124 & 1) != 0 )
        goto LABEL_184;
      if ( !*(_QWORD *)(v18 + 40) )
      {
        if ( v129 )
        {
          v107 = off_6C2D130(v129);
          *(_QWORD *)(v18 + 40) = v107;
          if ( !v107 )
            goto LABEL_184;
        }
      }
      if ( a7 && !*(_QWORD *)(v18 + 24) )
      {
        v108 = strchr(a7, 63);
        v109 = v108 ? memrchr(a7, 47, v108 - a7) : strrchr(a7, 47);
        if ( v109 )
        {
          v120 = sub_62BB9C0(a7, v109 - a7 + 1);
          *(_QWORD *)(v18 + 24) = v120;
          if ( !v120 )
            goto LABEL_184;
          v121 = sub_62963FC(v120);
          *(_QWORD *)(v18 + 32) = v121;
          if ( !v121 )
            goto LABEL_184;
        }
      }
      if ( !*(_QWORD *)(v18 + 8) )
        goto LABEL_184;
      ++*(_BYTE *)(v125 + 448);
      v84 = *(_BYTE *)(v18 + 64);
      if ( (v84 & 1) == 0 )
        goto LABEL_191;
LABEL_190:
      if ( *(_BYTE *)(v18 + 57) )
        goto LABEL_191;
      goto LABEL_264;
    }
    v61 = 0;
LABEL_135:
    if ( v61 )
      goto LABEL_183;
  }
  v22 = v29 == 61;
  a8 = v28;
  a4 = v127;
  if ( !v22 )
    goto LABEL_184;
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(0LL);
  v43 = sub_62BB9C0(i, v25);
  v44 = *(_QWORD *)(v18 + 16);
  *(_QWORD *)(v18 + 8) = v43;
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v44);
  v45 = (const char *)sub_62BB9C0(v30, v36);
  v46 = *(const char **)(v18 + 8);
  *(_QWORD *)(v18 + 16) = v45;
  if ( !v46 || !v45 )
    goto LABEL_184;
  if ( !v45[strcspn(v45, byte_16A993C)] && !v46[strcspn(v46, byte_16A993C)] )
    goto LABEL_129;
  if ( (*v123 & 0x100000) != 0 )
  {
    v114 = *(_QWORD *)(v125 + 4576);
    if ( !v114 || *(int *)(v114 + 8) >= 1 )
      sub_628595C(v125, "invalid octets in name/value, cookie dropped");
  }
LABEL_184:
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 40));
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 24));
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 32));
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 8));
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v18 + 16));
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v18);
  return 0LL;
}


================================================================================
Function: sub_6296394 (0x6296394)
================================================================================

unsigned __int64 __fastcall sub_6296394(_QWORD *a1)
{
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(a1[5]);
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(a1[3]);
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(a1[4]);
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(a1[1]);
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(a1[2]);
  return ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)a1);
}


================================================================================
Function: sub_62963FC (0x62963FC)
================================================================================

char *__fastcall sub_62963FC(const char *a1)
{
  const char *v1; // x0
  char *v2; // x19
  size_t v3; // x20
  size_t v4; // x8

  v1 = off_6C2D130(a1);
  v2 = (char *)v1;
  if ( !v1 )
    return v2;
  v3 = strlen(v1);
  if ( *v2 == 34 )
    memmove(v2, v2 + 1, v3--);
  if ( !v3 )
  {
    if ( *v2 != 47 )
      goto LABEL_13;
    return v2;
  }
  v4 = v3 - 1;
  if ( v2[v3 - 1] == 34 )
  {
    --v3;
    v2[v4] = 0;
  }
  if ( *v2 == 47 )
  {
    if ( v3 )
    {
      if ( v2[v3 - 1] == 47 )
        v2[v3 - 1] = 0;
    }
    return v2;
  }
LABEL_13:
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v2);
  return sub_62BB9C0("/", 1uLL);
}


================================================================================
Function: sub_62964D8 (0x62964D8)
================================================================================

bool __fastcall sub_62964D8(unsigned __int64 a1, unsigned __int64 a2, char *s)
{
  size_t v6; // x0
  _BOOL8 result; // x0
  size_t v8; // x20
  char *v9; // x21

  v6 = strlen(s);
  if ( v6 < a2 )
    return 0LL;
  v8 = v6;
  v9 = &s[v6 - a2];
  result = sub_62BB7E8(a1, (unsigned __int64)v9, a2);
  if ( result )
    return v8 == a2 || *(v9 - 1) == 46;
  return result;
}


================================================================================
Function: sub_6296558 (0x6296558)
================================================================================

time_t __fastcall sub_6296558(__int64 a1)
{
  time_t result; // x0
  time_t v3; // x8
  time_t v4; // x20
  __int64 v5; // x22
  _QWORD *v6; // x25
  _QWORD *v7; // x26
  int v8; // w9
  _QWORD *v9; // x8
  int v10; // w8
  __int64 (__fastcall *v11)(); // x9
  __int64 v12; // x0
  _QWORD *v13; // x21
  time_t v14; // x8

  result = time(0LL);
  v3 = *(_QWORD *)(a1 + 504);
  v4 = result;
  if ( result >= v3 || v3 == 0x7FFFFFFFFFFFFFFFLL )
  {
    v5 = 0LL;
    *(_QWORD *)(a1 + 504) = 0x7FFFFFFFFFFFFFFFLL;
    do
    {
      v6 = *(_QWORD **)(a1 + 8 * v5);
      if ( v6 )
      {
        v7 = 0LL;
        do
        {
          v13 = v6;
          v14 = v6[6];
          v6 = (_QWORD *)*v6;
          if ( v14 && v14 < v4 )
          {
            v8 = *(_DWORD *)(a1 + 512);
            if ( v7 )
              v9 = v7;
            else
              v9 = (_QWORD *)(a1 + 8 * v5);
            *v9 = v6;
            v10 = v8 - 1;
            v11 = off_6C2D120[0];
            v12 = v13[5];
            *(_DWORD *)(a1 + 512) = v10;
            ((void (__fastcall *)(__int64))v11)(v12);
            ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v13[3]);
            ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v13[4]);
            ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v13[1]);
            ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v13[2]);
            result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v13);
          }
          else if ( v14 )
          {
            v7 = v13;
            if ( v14 < *(_QWORD *)(a1 + 504) )
              *(_QWORD *)(a1 + 504) = v14;
          }
          else
          {
            v7 = v13;
          }
        }
        while ( v6 );
      }
      ++v5;
    }
    while ( v5 != 63 );
  }
  return result;
}


================================================================================
Function: sub_6296688 (0x6296688)
================================================================================

char *__fastcall sub_6296688(char *result)
{
  const char *v1; // x19
  __int64 v2; // x20
  _BYTE *v3; // x0
  _BYTE *v4; // x0
  const char *v5; // x8
  const char *v6; // x21
  unsigned __int64 v7; // x20
  unsigned int v8; // t1

  if ( result )
  {
    v1 = result;
    if ( (sub_62996A0(result) & 1) != 0 )
    {
      return 0LL;
    }
    else
    {
      v2 = strlen(v1);
      v3 = memrchr(v1, 46, v2);
      if ( v3 && (v4 = memrchr(v1, 46, v3 - v1)) != 0LL )
      {
        v5 = v4 + 1;
        v2 = &v1[v2] - (v4 + 1);
      }
      else
      {
        v5 = 0LL;
      }
      if ( v5 )
        v1 = v5;
      if ( v2 < 1 )
      {
        return (_BYTE *)(&qword_18 + 2);
      }
      else
      {
        v6 = &v1[v2];
        v7 = 5381LL;
        do
        {
          v8 = *(unsigned __int8 *)v1++;
          v7 = (33 * v7) ^ (char)sub_62BB748(v8);
        }
        while ( v1 < v6 );
        return (char *)(v7 % 0x3F);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6296F48 (0x6296F48)
================================================================================

unsigned __int64 __fastcall sub_6296F48(unsigned __int64 result)
{
  unsigned __int64 v1; // x19
  __int64 i; // x21
  _QWORD *v3; // x20
  _QWORD *v4; // x23

  if ( result )
  {
    v1 = result;
    for ( i = 0LL; i != 63; ++i )
    {
      v3 = *(_QWORD **)(v1 + 8 * i);
      if ( v3 )
      {
        do
        {
          v4 = (_QWORD *)*v3;
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v3[5]);
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v3[3]);
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v3[4]);
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v3[1]);
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v3[2]);
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v3);
          v3 = v4;
        }
        while ( v4 );
      }
    }
    return ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1);
  }
  return result;
}


================================================================================
Function: sub_6297194 (0x6297194)
================================================================================

__int64 __fastcall sub_6297194(__int64 a1, char a2)
{
  __int64 v4; // x21
  __int64 v5; // x25
  char *v6; // x22
  int v7; // w21
  unsigned int v8; // w23
  FILE *v9; // x3
  __int64 v10; // x8
  _QWORD *v11; // x0
  unsigned __int64 v12; // x23
  __int64 v13; // x8
  size_t v14; // x24
  _QWORD *i; // x9
  size_t j; // x28
  __int64 v17; // x8
  _BYTE *v18; // x9
  const char *v19; // x4
  const char *v20; // x2
  const char *v21; // x3
  const char *v22; // x5
  const char *v23; // x10
  const char *v24; // x6
  const char *v25; // x1
  const char *v26; // x0
  unsigned __int64 v27; // x27
  FILE *v28; // x0
  __int64 v29; // x8
  __int64 v30; // x21
  __int64 v31; // x0
  __int64 v32; // x4
  __int64 v33; // x5
  __int64 v34; // x6
  __int64 v35; // x7
  __int64 v36; // x8
  unsigned __int64 v37; // x20
  __int64 k; // x22
  _QWORD *v39; // x21
  _QWORD *v40; // x24
  __int64 v42; // [xsp+0h] [xbp-30h]
  FILE *v43; // [xsp+20h] [xbp-10h]

  v4 = *(_QWORD *)(a1 + 2000);
  sub_62B9860(a1, 2);
  if ( !v4 )
    goto LABEL_56;
  v5 = *(_QWORD *)(a1 + 2464);
  v43 = 0LL;
  v6 = *(char **)(a1 + 2000);
  if ( !v5 )
    goto LABEL_56;
  sub_6296558(v5);
  v7 = strcmp("-", v6);
  if ( v7 )
  {
    v8 = sub_629760C(a1, v6);
    if ( v8 )
      goto LABEL_48;
    v9 = 0LL;
  }
  else
  {
    v9 = stdout;
    v43 = stdout;
  }
  fwrite(
    "# Netscape HTTP Cookie File\n"
    "# https://curl.se/docs/http-cookies.html\n"
    "# This file was generated by libcurl! Edit at your own risk.\n"
    "\n",
    0x83uLL,
    1uLL,
    v9);
  v10 = *(int *)(v5 + 512);
  if ( !(_DWORD)v10 )
  {
LABEL_44:
    if ( v7 )
      fclose(v43);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(0LL);
    goto LABEL_56;
  }
  v11 = (_QWORD *)off_6C2D138(1LL, 8 * v10);
  if ( v11 )
  {
    v12 = (unsigned __int64)v11;
    v13 = 0LL;
    v14 = 0LL;
    do
    {
      for ( i = *(_QWORD **)(v5 + 8 * v13); i; i = (_QWORD *)*i )
      {
        if ( i[5] )
          v11[v14++] = i;
      }
      ++v13;
    }
    while ( v13 != 63 );
    qsort(v11, v14, 8uLL, (__compar_fn_t)sub_62975EC);
    if ( v14 )
    {
      for ( j = 0LL; j < v14; j = (unsigned int)(j + 1) )
      {
        v17 = *(_QWORD *)(v12 + 8 * j);
        v18 = *(_BYTE **)(v17 + 40);
        if ( *(_BYTE *)(v17 + 56) )
        {
          if ( v18 )
          {
            v19 = "TRUE";
            if ( *v18 == 46 )
              v20 = &byte_CBCB6C;
            else
              v20 = ".";
            goto LABEL_26;
          }
          v19 = "TRUE";
        }
        else
        {
          v19 = "FALSE";
        }
        v20 = &byte_CBCB6C;
LABEL_26:
        if ( v18 )
          v21 = *(const char **)(v17 + 40);
        else
          v21 = "unknown";
        if ( *(_QWORD *)(v17 + 24) )
          v22 = *(const char **)(v17 + 24);
        else
          v22 = "/";
        if ( *(_QWORD *)(v17 + 16) )
          v23 = *(const char **)(v17 + 16);
        else
          v23 = &byte_CBCB6C;
        if ( *(_BYTE *)(v17 + 57) )
          v24 = "TRUE";
        else
          v24 = "FALSE";
        if ( *(_BYTE *)(v17 + 59) )
          v25 = "#HttpOnly_";
        else
          v25 = &byte_CBCB6C;
        v26 = (const char *)sub_62AB3BC(
                              "%s%s%s\t%s\t%s\t%s\t%ld\t%s\t%s",
                              v25,
                              v20,
                              v21,
                              v19,
                              v22,
                              v24,
                              *(_QWORD *)(v17 + 48),
                              *(const char **)(v17 + 8),
                              v23);
        if ( !v26 )
        {
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v12);
          v8 = 27;
          v28 = v43;
          if ( !v43 )
            goto LABEL_51;
          goto LABEL_49;
        }
        v27 = (unsigned __int64)v26;
        sub_62AB478(v43, "%s\n", v26);
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v27);
      }
    }
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v12);
    goto LABEL_44;
  }
  v8 = 27;
LABEL_48:
  v28 = v43;
  if ( !v43 )
    goto LABEL_51;
LABEL_49:
  if ( v7 )
    fclose(v28);
LABEL_51:
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(0LL);
  if ( a1 )
  {
    if ( (*(_DWORD *)(a1 + 2458) & 0x100000) != 0 )
    {
      v29 = *(_QWORD *)(a1 + 4576);
      if ( !v29 || *(int *)(v29 + 8) >= 1 )
      {
        v30 = *(_QWORD *)(a1 + 2000);
        v31 = sub_62BBA78(v8);
        sub_628595C(a1, "WARNING: failed to save cookies in %s: %s", v30, v31, v32, v33, v34, v35, v42);
      }
    }
  }
LABEL_56:
  if ( (a2 & 1) != 0 )
  {
    v36 = *(_QWORD *)(a1 + 224);
    v37 = *(_QWORD *)(a1 + 2464);
    if ( !v36 || v37 != *(_QWORD *)(v36 + 248) )
    {
      if ( v37 )
      {
        for ( k = 0LL; k != 63; ++k )
        {
          v39 = *(_QWORD **)(v37 + 8 * k);
          if ( v39 )
          {
            do
            {
              v40 = (_QWORD *)*v39;
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v39[5]);
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v39[3]);
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v39[4]);
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v39[1]);
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v39[2]);
              ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v39);
              v39 = v40;
            }
            while ( v40 );
          }
        }
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v37);
      }
      *(_QWORD *)(a1 + 2464) = 0LL;
    }
  }
  return sub_62B98A4(a1, 2);
}


================================================================================
Function: sub_629760C (0x629760C)
================================================================================

__int64 __fastcall sub_629760C(__int64 a1, char *filename, FILE **a3, const char **a4)
{
  FILE *v8; // x0
  int v9; // w0
  int v10; // w24
  unsigned int v11; // w0
  unsigned int v12; // w22
  const char *v13; // x21
  size_t v15; // x0
  char *v16; // x8
  size_t v17; // x9
  int v18; // w10
  int v19; // w11
  size_t v20; // x10
  size_t v21; // x22
  const char *v22; // x0
  unsigned __int64 v23; // x22
  int v24; // w0
  int v25; // w22
  FILE *v26; // x0
  char v27[16]; // [xsp+8h] [xbp-D8h] BYREF
  int v28; // [xsp+18h] [xbp-C8h]
  unsigned __int64 v29[4]; // [xsp+88h] [xbp-58h] BYREF
  char v30[44]; // [xsp+ACh] [xbp-34h] BYREF

  *a4 = 0LL;
  v8 = fopen(filename, "w");
  *a3 = v8;
  if ( !v8 )
  {
    v13 = 0LL;
    goto LABEL_8;
  }
  v9 = fileno(v8);
  if ( fstat(v9, (struct stat *)v27) != -1 )
  {
    v10 = v28;
    if ( (v28 & 0xF000) == 0x8000 )
    {
      fclose(*a3);
      *a3 = 0LL;
      v11 = sub_62B0964(a1, v30, 41LL);
      if ( v11 )
      {
        v12 = v11;
        v13 = 0LL;
LABEL_9:
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v13);
        return v12;
      }
      sub_628F4E0(v29, 8000000LL);
      v15 = strlen(filename);
      if ( v15 )
      {
        v16 = filename - 1;
        do
        {
          v17 = v15;
          if ( !v15 )
            break;
          v18 = (unsigned __int8)v16[v15--];
        }
        while ( v18 != 47 );
        while ( v17 )
        {
          v19 = (unsigned __int8)v16[v17];
          v20 = --v17;
          if ( v19 != 47 )
          {
            v21 = v20 + 1;
            goto LABEL_20;
          }
        }
      }
      v21 = 0LL;
LABEL_20:
      if ( (unsigned int)sub_628F5B8(v29, filename, v21)
        || v21 && (unsigned int)sub_628F5B8(v29, "/", 1uLL)
        || (v22 = (const char *)sub_628F7BC((__int64)v29)) == 0LL )
      {
        v13 = 0LL;
        v12 = 27;
        goto LABEL_9;
      }
      v23 = (unsigned __int64)v22;
      v13 = (const char *)sub_62AB3BC("%s%s.tmp", v22, v30);
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v23);
      if ( !v13 )
      {
        v12 = 27;
        goto LABEL_9;
      }
      v24 = open(v13, 193, v10 | 0x180u);
      if ( v24 != -1 )
      {
        v25 = v24;
        v26 = fdopen(v24, "w");
        *a3 = v26;
        if ( v26 )
        {
          v12 = 0;
          *a4 = v13;
          return v12;
        }
        close(v25);
        unlink(v13);
      }
LABEL_8:
      v12 = 23;
      goto LABEL_9;
    }
  }
  return 0;
}


================================================================================
Function: sub_6297840 (0x6297840)
================================================================================

__int64 __fastcall sub_6297840(__int64 a1)
{
  __int64 v1; // x21
  char v3; // w8
  char v4; // w9
  __int64 (__fastcall *v5)(); // x8
  __int64 v6; // x0
  __int64 (__fastcall *v7)(); // x8

  v1 = a1 + 4696;
  v3 = *(_BYTE *)(a1 + 2892) & 0xFD;
  v4 = *(_BYTE *)(a1 + 4924);
  *(_QWORD *)(a1 + 2608) = 0LL;
  *(_BYTE *)(a1 + 2892) = v3;
  *(_QWORD *)(a1 + 2672) = 0LL;
  *(_DWORD *)(a1 + 4704) = 0;
  *(_OWORD *)(a1 + 2624) = 0u;
  *(_OWORD *)(a1 + 2640) = 0u;
  *(_OWORD *)(a1 + 2656) = 0u;
  *(_QWORD *)(a1 + 4696) = 0LL;
  *(_QWORD *)(a1 + 4712) = -1LL;
  v5 = off_6C2D120[0];
  *(_DWORD *)(a1 + 4776) = 0;
  v6 = *(_QWORD *)(a1 + 4752);
  *(_BYTE *)(v1 + 228) = v4 & 0xFE;
  *(_OWORD *)(a1 + 4720) = 0u;
  *(_OWORD *)(a1 + 4736) = 0u;
  ((void (__fastcall *)(__int64))v5)(v6);
  v7 = off_6C2D120[0];
  *(_QWORD *)(a1 + 4752) = 0LL;
  ((void (__fastcall *)(_QWORD))v7)(*(_QWORD *)(a1 + 4760));
  *(_QWORD *)(a1 + 4768) = 0LL;
  *(_QWORD *)(a1 + 4760) = 0LL;
  *(_DWORD *)(v1 + 180) = 0;
  *(_OWORD *)(v1 + 164) = 0u;
  *(_OWORD *)(v1 + 84) = 0u;
  *(_OWORD *)(v1 + 100) = 0u;
  *(_OWORD *)(v1 + 116) = 0u;
  *(_OWORD *)(v1 + 132) = 0u;
  *(_OWORD *)(v1 + 148) = 0u;
  *(_QWORD *)(a1 + 4872) = -1LL;
  *(_QWORD *)(a1 + 4888) = 0LL;
  *(_DWORD *)(a1 + 4896) = 0;
  sub_62C9218(a1);
  return 0LL;
}


================================================================================
Function: sub_6298044 (0x6298044)
================================================================================

_QWORD *__fastcall sub_6298044(_QWORD *result, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  *result = 0LL;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  result[4] = a2;
  result[5] = 0LL;
  return result;
}


================================================================================
Function: sub_6298054 (0x6298054)
================================================================================

__int64 __fastcall sub_6298054(__int64 a1, const void *a2, size_t a3, __int64 a4, __int64 a5)
{
  __int64 v10; // x24
  unsigned __int64 v11; // x2
  _QWORD *v12; // x0
  unsigned __int64 v13; // x25
  __int64 v14; // x27
  __int64 *v15; // x24
  __int64 v16; // x0
  __int64 v17; // x25
  __int64 v18; // x0
  __int64 v19; // x0
  __int64 *v20; // x25

  v10 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 )
  {
    v11 = *(_QWORD *)(a1 + 32);
  }
  else
  {
    v12 = (_QWORD *)((__int64 (__fastcall *)(unsigned __int64))off_6C2D118[0])(32LL * *(_QWORD *)(a1 + 32));
    *(_QWORD *)a1 = v12;
    if ( !v12 )
      return 0LL;
    if ( *(_QWORD *)(a1 + 32) )
    {
      sub_62A734C(v12, (__int64)sub_62981FC);
      v11 = *(_QWORD *)(a1 + 32);
      if ( v11 >= 2 )
      {
        v13 = 1LL;
        v14 = 32LL;
        do
        {
          sub_62A734C((_QWORD *)(*(_QWORD *)a1 + v14), (__int64)sub_62981FC);
          v11 = *(_QWORD *)(a1 + 32);
          ++v13;
          v14 += 32LL;
        }
        while ( v13 < v11 );
      }
    }
    else
    {
      v11 = 0LL;
    }
    v10 = *(_QWORD *)a1;
  }
  v15 = (__int64 *)(v10 + 32 * (*(__int64 (__fastcall **)(const void *, size_t, unsigned __int64))(a1 + 8))(a2, a3, v11));
  v16 = sub_62A75F0((__int64)v15);
  if ( v16 )
  {
    v17 = v16;
    while ( 1 )
    {
      v18 = sub_62A7600(v17);
      if ( (*(__int64 (__fastcall **)(__int64, _QWORD, const void *, size_t))(a1 + 16))(
             v18 + 56,
             *(_QWORD *)(v18 + 48),
             a2,
             a3) )
      {
        break;
      }
      v17 = sub_62A7608(v17);
      if ( !v17 )
        goto LABEL_17;
    }
    sub_62A743C(v17, a1);
    --*(_QWORD *)(a1 + 40);
  }
LABEL_17:
  v19 = ((__int64 (__fastcall *)(unsigned __int64))off_6C2D118[0])(a3 + 64);
  if ( !v19 )
    return 0LL;
  v20 = (__int64 *)v19;
  memcpy((void *)(v19 + 56), a2, a3);
  v20[5] = a5;
  v20[6] = a3;
  v20[4] = a4;
  sub_62A73C8(v15, v20, (__int64 **)v20);
  ++*(_QWORD *)(a1 + 40);
  return a4;
}


================================================================================
Function: sub_629825C (0x629825C)
================================================================================

__int64 __fastcall sub_629825C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_6298054(a1, a2, a3, a4, 0LL);
}


================================================================================
Function: sub_6298264 (0x6298264)
================================================================================

__int64 __fastcall sub_6298264(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x22
  __int64 v7; // x0
  __int64 v8; // x0
  __int64 v9; // x22
  __int64 v10; // x0
  __int64 result; // x0

  v3 = *a1;
  if ( !*a1 )
    return 1LL;
  v7 = ((__int64 (__fastcall *)(__int64, __int64, __int64))a1[1])(a2, a3, a1[4]);
  v8 = sub_62A75F0(v3 + 32 * v7);
  if ( !v8 )
    return 1LL;
  v9 = v8;
  while ( 1 )
  {
    v10 = sub_62A7600(v9);
    if ( ((__int64 (__fastcall *)(__int64, _QWORD, __int64, __int64))a1[2])(v10 + 56, *(_QWORD *)(v10 + 48), a2, a3) )
      break;
    v9 = sub_62A7608(v9);
    if ( !v9 )
      return 1LL;
  }
  sub_62A743C(v9, a1);
  result = 0LL;
  --a1[5];
  return result;
}


================================================================================
Function: sub_6298318 (0x6298318)
================================================================================

__int64 __fastcall sub_6298318(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x22
  __int64 v7; // x0
  __int64 result; // x0
  __int64 v9; // x22
  __int64 v10; // x23

  v3 = *a1;
  if ( !*a1 )
    return 0LL;
  v7 = ((__int64 (__fastcall *)(__int64, __int64, __int64))a1[1])(a2, a3, a1[4]);
  result = sub_62A75F0(v3 + 32 * v7);
  if ( result )
  {
    v9 = result;
    while ( 1 )
    {
      v10 = sub_62A7600(v9);
      if ( ((__int64 (__fastcall *)(__int64, _QWORD, __int64, __int64))a1[2])(v10 + 56, *(_QWORD *)(v10 + 48), a2, a3) )
        break;
      result = sub_62A7608(v9);
      v9 = result;
      if ( !result )
        return result;
    }
    return *(_QWORD *)(v10 + 32);
  }
  return result;
}


================================================================================
Function: sub_62983C0 (0x62983C0)
================================================================================

unsigned __int64 __fastcall sub_62983C0(unsigned __int64 *a1)
{
  unsigned __int64 result; // x0
  unsigned __int64 v3; // x20
  __int64 v4; // x21

  result = *a1;
  if ( result )
  {
    if ( a1[4] )
    {
      ((void (*)(void))sub_62A7538)();
      if ( a1[4] >= 2 )
      {
        v3 = 1LL;
        v4 = 32LL;
        do
        {
          sub_62A7538(*a1 + v4, a1);
          ++v3;
          v4 += 32LL;
        }
        while ( v3 < a1[4] );
      }
      result = *a1;
    }
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(result);
    *a1 = 0LL;
  }
  a1[4] = 0LL;
  a1[5] = 0LL;
  return result;
}


================================================================================
Function: sub_6298450 (0x6298450)
================================================================================

__int64 *__fastcall sub_6298450(__int64 *result)
{
  __int64 *v1; // x19
  __int64 v2; // x8
  __int64 v3; // x22
  __int64 v4; // x20
  __int64 v5; // x21

  if ( result )
  {
    v1 = result;
    v2 = *result;
    if ( *result )
    {
      if ( result[4] )
      {
        v3 = 0LL;
        while ( 1 )
        {
          result = (__int64 *)sub_62A75F0(v2 + 32 * v3);
          if ( result )
          {
            v4 = (__int64)result;
            do
            {
              sub_62A7600(v4);
              v5 = sub_62A7608(v4);
              result = (__int64 *)sub_62A743C(v4, v1);
              v4 = v5;
              --v1[5];
            }
            while ( v5 );
          }
          if ( ++v3 >= (unsigned __int64)v1[4] )
            break;
          v2 = *v1;
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6298630 (0x6298630)
================================================================================

__int64 __fastcall sub_6298630(__int64 result, _QWORD *a2)
{
  a2[1] = 0LL;
  a2[2] = 0LL;
  *a2 = result;
  return result;
}


================================================================================
Function: sub_629863C (0x629863C)
================================================================================

__int64 __fastcall sub_629863C(__int64 a1)
{
  _QWORD *v1; // x20
  __int64 v3; // x0
  __int64 v4; // x0
  unsigned __int64 v5; // x21
  __int64 i; // x22

  v1 = *(_QWORD **)a1;
  if ( **(_QWORD **)a1 )
  {
    v3 = *(_QWORD *)(a1 + 16);
    if ( v3 )
    {
      v4 = sub_62A7608(v3);
      *(_QWORD *)(a1 + 16) = v4;
      if ( v4 )
        return sub_62A7600(v4);
    }
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 < v1[4] )
    {
      for ( i = 32 * v5; !sub_62A75F0(*v1 + i); i += 32LL )
      {
        if ( ++v5 >= v1[4] )
        {
          v4 = *(_QWORD *)(a1 + 16);
          if ( !v4 )
            return 0LL;
          return sub_62A7600(v4);
        }
      }
      v4 = sub_62A75F0(*v1 + i);
      *(_QWORD *)(a1 + 8) = v5 + 1;
      *(_QWORD *)(a1 + 16) = v4;
      if ( v4 )
        return sub_62A7600(v4);
    }
  }
  return 0LL;
}


================================================================================
Function: sub_6298C9C (0x6298C9C)
================================================================================

__int64 __fastcall sub_6298C9C(__int64 a1)
{
  _QWORD *v2; // x20
  __int64 v3; // x0
  __int64 v4; // x21
  __int64 v5; // x22

  v2 = (_QWORD *)(a1 + 4424);
  v3 = sub_62A75F0(a1 + 4424);
  if ( v3 )
  {
    v4 = v3;
    do
    {
      v5 = sub_62A7600(v4);
      v4 = sub_62A7608(v4);
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v5);
    }
    while ( v4 );
  }
  sub_62A734C(v2, 0LL);
  *(_QWORD *)(a1 + 4552) = 0LL;
  return 0LL;
}


================================================================================
Function: sub_62996A0 (0x62996A0)
================================================================================

bool __fastcall sub_62996A0(char *cp)
{
  __int64 v3; // [xsp+0h] [xbp-20h] BYREF
  _BYTE buf[16]; // [xsp+8h] [xbp-18h] BYREF

  return inet_pton(2, cp, &v3) > 0 || inet_pton(10, cp, buf) > 0;
}


================================================================================
Function: sub_6299FAC (0x6299FAC)
================================================================================

unsigned __int64 __fastcall sub_6299FAC(unsigned __int64 result, _QWORD *a2)
{
  _QWORD *v2; // x19
  __int64 v3; // x20
  __int64 v4; // x8
  __int64 v5; // x8

  v2 = (_QWORD *)*a2;
  *a2 = 0LL;
  if ( result )
  {
    v3 = result;
    if ( *(_QWORD *)(result + 224) )
      result = sub_62B9860(result, 3);
    v4 = v2[2] - 1LL;
    v2[2] = v4;
    if ( v4 )
    {
      if ( !*(_QWORD *)(v3 + 224) )
        return result;
    }
    else
    {
      sub_628E92C(*v2);
      result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v2);
      if ( !*(_QWORD *)(v3 + 224) )
        return result;
    }
    return sub_62B98A4(v3, 3);
  }
  v5 = v2[2] - 1LL;
  v2[2] = v5;
  if ( !v5 )
  {
    sub_628E92C(*v2);
    return ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v2);
  }
  return result;
}


================================================================================
Function: sub_629A0C4 (0x629A0C4)
================================================================================

__int64 __fastcall sub_629A0C4(__int64 a1, __int64 a2)
{
  return sub_6298044(a1, a2, sub_62985C0, sub_62985F8, sub_629A074);
}


================================================================================
Function: sub_629A0E0 (0x629A0E0)
================================================================================

__int64 __fastcall sub_629A0E0(__int64 a1, __int64 a2)
{
  __int64 result; // x0

  if ( !a1 )
    return sub_6298450(a2);
  if ( *(_QWORD *)(a1 + 224) )
    sub_62B9860(a1, 3);
  result = sub_6298450(a2);
  if ( *(_QWORD *)(a1 + 224) )
    return sub_62B98A4(a1, 3);
  return result;
}


================================================================================
Function: sub_629A7DC (0x629A7DC)
================================================================================

__int64 sub_629A7DC()
{
  __int64 v0; // x0
  __int64 v1; // x19

  v0 = off_6C2D138(1LL, 48LL);
  v1 = v0;
  if ( v0 )
    sub_62A734C(v0, 0LL);
  return v1;
}


================================================================================
Function: sub_629A824 (0x629A824)
================================================================================

unsigned __int64 *__fastcall sub_629A824(unsigned __int64 *result)
{
  unsigned __int64 v1; // x20
  unsigned __int64 *v2; // x19
  __int64 v3; // x0
  __int64 v4; // x21
  __int64 v5; // x22

  v1 = *result;
  if ( *result )
  {
    v2 = result;
    v3 = sub_62A75F0(*result);
    if ( v3 )
    {
      v4 = v3;
      do
      {
        v5 = sub_62A7600(v4);
        v4 = sub_62A7608(v4);
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v5 + 32));
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v5);
      }
      while ( v4 );
    }
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v1 + 32));
    result = (unsigned __int64 *)((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1);
    *v2 = 0LL;
  }
  return result;
}


================================================================================
Function: sub_629AD1C (0x629AD1C)
================================================================================

__int64 __fastcall sub_629AD1C(__int64 a1, __int64 a2, char *filename)
{
  char *v3; // x21
  unsigned int v6; // w22
  __int64 v7; // x0
  __int64 v8; // x23
  char *v9; // x2
  __int64 v10; // x28
  __int64 v11; // x0
  unsigned int v12; // w0
  const char *v13; // x2
  __int64 v14; // x0
  __int64 v15; // x20
  __int64 v16; // x22
  const char *v17; // x8
  __int64 v18; // x0
  char v19; // w9
  unsigned int v20; // w0
  int v21; // w0
  _QWORD v23[2]; // [xsp+18h] [xbp-88h] BYREF
  char *name; // [xsp+28h] [xbp-78h]
  FILE *s; // [xsp+30h] [xbp-70h]
  int v26; // [xsp+38h] [xbp-68h] BYREF
  int v27; // [xsp+3Ch] [xbp-64h]
  int v28; // [xsp+40h] [xbp-60h]
  int v29; // [xsp+44h] [xbp-5Ch]
  int v30; // [xsp+48h] [xbp-58h]
  int v31; // [xsp+4Ch] [xbp-54h]
  const char *v32[2]; // [xsp+70h] [xbp-30h] BYREF
  char v33; // [xsp+80h] [xbp-20h]
  char v34[23]; // [xsp+81h] [xbp-1Fh] BYREF

  name = 0LL;
  if ( a2 )
  {
    v3 = filename;
    if ( !filename )
      v3 = *(char **)(a2 + 32);
    v6 = 0;
    if ( (*(_BYTE *)(a2 + 40) & 2) == 0 && v3 )
    {
      if ( *v3 )
      {
        v6 = sub_629760C(a1, v3);
        if ( !v6 )
        {
          fwrite(
            "# Your HSTS cache. https://curl.se/docs/hsts.html\n"
            "# This file was generated by libcurl! Edit at your own risk.\n",
            0x6FuLL,
            1uLL,
            s);
          v7 = sub_62A75F0(a2);
          if ( v7 )
          {
            v8 = v7;
            while ( 1 )
            {
              while ( 1 )
              {
                v10 = sub_62A7600(v8);
                v8 = sub_62A7608(v8);
                v11 = *(_QWORD *)(v10 + 48);
                if ( v11 != 0x7FFFFFFFFFFFFFFFLL )
                  break;
                if ( *(_BYTE *)(v10 + 40) )
                  v9 = ".";
                else
                  v9 = &byte_CBCB6C;
                sub_62AB478(s, "%s%s \"%s\"\n", v9, *(_QWORD *)(v10 + 32), "unlimited");
                if ( !v8 )
                {
LABEL_20:
                  v6 = 0;
                  goto LABEL_24;
                }
              }
              v12 = sub_62AFABC(v11, &v26);
              if ( v12 )
                break;
              if ( *(_BYTE *)(v10 + 40) )
                v13 = ".";
              else
                v13 = &byte_CBCB6C;
              sub_62AB478(
                s,
                "%s%s \"%d%02d%02d %02d:%02d:%02d\"\n",
                v13,
                *(const char **)(v10 + 32),
                v31 + 1900,
                v30 + 1,
                v29,
                v28,
                v27,
                v26);
              if ( !v8 )
                goto LABEL_20;
            }
            v6 = v12;
          }
          else
          {
            v6 = 0;
          }
LABEL_24:
          fclose(s);
        }
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)name);
      }
      else
      {
        v6 = 0;
      }
    }
    if ( *(_QWORD *)(a1 + 720) )
    {
      v23[0] = 0LL;
      v23[1] = sub_62A75F8(a2);
      v14 = sub_62A75F0(a2);
      if ( v14 )
      {
        v15 = v14;
        while ( 1 )
        {
          v16 = sub_62A7600(v15);
          v15 = sub_62A7608(v15);
          v32[0] = *(const char **)(v16 + 32);
          v17 = (const char *)strlen(v32[0]);
          v18 = *(_QWORD *)(v16 + 48);
          v19 = *(_BYTE *)(v16 + 40);
          v32[1] = v17;
          v33 = v19;
          if ( v18 == 0x7FFFFFFFFFFFFFFFLL )
          {
            strcpy(v34, "unlimited");
          }
          else
          {
            v20 = sub_62AFABC(v18, &v26);
            if ( v20 )
              return v20;
            sub_62AB108(v34, 18LL, "%d%02d%02d %02d:%02d:%02d", v31 + 1900, v30 + 1, v29, v28, v27, v26);
          }
          v21 = (*(__int64 (__fastcall **)(__int64, const char **, _QWORD *, _QWORD))(a1 + 720))(
                  a1,
                  v32,
                  v23,
                  *(_QWORD *)(a1 + 728));
          if ( v21 )
            break;
          ++v23[0];
          if ( !v15 )
            return 0;
        }
        if ( v21 == 2 )
          return 43;
        else
          return 0;
      }
    }
  }
  else
  {
    return 0;
  }
  return v6;
}


================================================================================
Function: sub_62A58C0 (0x62A58C0)
================================================================================

_QWORD *__fastcall sub_62A58C0(__int64 a1)
{
  _QWORD *v2; // x0
  void (*v3)(void); // x9
  _QWORD *result; // x0

  v2 = *(_QWORD **)a1;
  if ( v2 )
  {
    do
    {
      *(_QWORD *)a1 = *v2;
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v2);
      v2 = *(_QWORD **)a1;
    }
    while ( *(_QWORD *)a1 );
  }
  while ( 1 )
  {
    result = *(_QWORD **)(a1 + 16);
    if ( !result )
      break;
    v3 = (void (*)(void))off_6C2D120[0];
    *(_QWORD *)(a1 + 16) = *result;
    v3();
  }
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  return result;
}


================================================================================
Function: sub_62A5928 (0x62A5928)
================================================================================

__int64 __fastcall sub_62A5928(__int64 result)
{
  _QWORD *v1; // x8
  _QWORD *v2; // x9
  _QWORD *v3; // x10

  v1 = *(_QWORD **)result;
  if ( *(_QWORD *)result )
  {
    v2 = *(_QWORD **)(result + 16);
    do
    {
      v3 = v1;
      v1 = (_QWORD *)*v1;
      *v3 = v2;
      v2 = v3;
    }
    while ( v1 );
    *(_QWORD *)result = 0LL;
    *(_QWORD *)(result + 16) = v3;
  }
  *(_QWORD *)(result + 8) = 0LL;
  return result;
}


================================================================================
Function: sub_62A5958 (0x62A5958)
================================================================================

__int64 __fastcall sub_62A5958(_QWORD *a1)
{
  _QWORD *v1; // x8
  __int64 result; // x0
  __int64 v3; // x9
  __int64 v4; // x10

  v1 = (_QWORD *)*a1;
  if ( !*a1 )
    return 0LL;
  result = 0LL;
  do
  {
    v4 = v1[2];
    v3 = v1[3];
    v1 = (_QWORD *)*v1;
    result = v3 + result - v4;
  }
  while ( v1 );
  return result;
}


================================================================================
Function: sub_62A5984 (0x62A5984)
================================================================================

bool __fastcall sub_62A5984(__int64 a1)
{
  return !*(_QWORD *)a1 || *(_QWORD *)(*(_QWORD *)a1 + 16LL) >= *(_QWORD *)(*(_QWORD *)a1 + 24LL);
}


================================================================================
Function: sub_62A5CEC (0x62A5CEC)
================================================================================

__int64 *__fastcall sub_62A5CEC(__int64 a1)
{
  __int64 *result; // x0
  __int64 *v3; // x10
  __int64 v4; // x9
  __int64 *v5; // x9
  __int64 v6; // x8
  __int64 v7; // x10
  __int64 v8; // x8

  result = *(__int64 **)a1;
  if ( result )
  {
    while ( 1 )
    {
      if ( result[2] < (unsigned __int64)result[3] )
        return result;
      v3 = *(__int64 **)(a1 + 8);
      v4 = *result;
      *(_QWORD *)a1 = *result;
      if ( v3 == result )
      {
        *(_QWORD *)(a1 + 8) = v4;
        v5 = *(__int64 **)(a1 + 24);
        if ( !v5 )
          goto LABEL_8;
LABEL_5:
        if ( v5[2] >= (unsigned __int64)v5[3] )
          goto LABEL_12;
        result[2] = 0LL;
        result[3] = 0LL;
        v6 = v5[2];
        v7 = *v5;
        *v5 = (__int64)result;
        *result = v7;
        v5[2] = v6 + 1;
LABEL_13:
        --*(_QWORD *)(a1 + 32);
        result = *(__int64 **)a1;
        if ( !*(_QWORD *)a1 )
          return result;
      }
      else
      {
        v5 = *(__int64 **)(a1 + 24);
        if ( v5 )
          goto LABEL_5;
LABEL_8:
        if ( *(_QWORD *)(a1 + 32) > *(_QWORD *)(a1 + 40) || (*(_BYTE *)(a1 + 56) & 2) != 0 )
        {
LABEL_12:
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)result);
          goto LABEL_13;
        }
        v8 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = result;
        *result = v8;
        result = *(__int64 **)a1;
        if ( !*(_QWORD *)a1 )
          return result;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62A5EA4 (0x62A5EA4)
================================================================================

__int64 __fastcall sub_62A5EA4(__int64 *a1, _QWORD *a2, unsigned __int64 *a3)
{
  __int64 v4; // x8
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x10
  bool v9; // cc
  unsigned __int64 v10; // x9
  __int64 result; // x0

  v4 = *a1;
  if ( *a1
    && (*(_QWORD *)(v4 + 16) < *(_QWORD *)(v4 + 24) || (sub_62A5CEC(), (v4 = *a1) != 0))
    && (v8 = *(_QWORD *)(v4 + 16), v7 = *(_QWORD *)(v4 + 24), v9 = v7 > v8, v10 = v7 - v8, v9) )
  {
    result = 1LL;
    *a2 = v4 + v8 + 32;
  }
  else
  {
    v10 = 0LL;
    result = 0LL;
    *a2 = 0LL;
  }
  *a3 = v10;
  return result;
}


================================================================================
Function: sub_62A62F4 (0x62A62F4)
================================================================================

__int64 __fastcall sub_62A62F4(__int64 a1)
{
  sub_62C5D94(a1 + 3048);
  return sub_62C5D94(a1 + 3104);
}


================================================================================
Function: sub_62A6564 (0x62A6564)
================================================================================

__int64 __fastcall sub_62A6564(__int64 a1)
{
  sub_62C6AD8(a1 + 1008);
  return sub_62C6AD8(a1 + 1032);
}


================================================================================
Function: sub_62A734C (0x62A734C)
================================================================================

_QWORD *__fastcall sub_62A734C(_QWORD *result, __int64 a2)
{
  result[2] = a2;
  result[3] = 0LL;
  *result = 0LL;
  result[1] = 0LL;
  return result;
}


================================================================================
Function: sub_62A7358 (0x62A7358)
================================================================================

__int64 *__fastcall sub_62A7358(__int64 *result, __int64 *a2, __int64 *a3, __int64 **a4)
{
  __int64 v4; // x8
  __int64 *v5; // x9
  __int64 *v6; // x10
  __int64 *v7; // x10
  __int64 ***v8; // x10

  v4 = result[3];
  a4[1] = a3;
  *a4 = result;
  if ( v4 )
  {
    v5 = a2 + 3;
    if ( a2 )
      v6 = a2 + 3;
    else
      v6 = result;
    v7 = (__int64 *)*v6;
    a4[2] = a2;
    a4[3] = v7;
    if ( a2 )
    {
      if ( *v5 )
        v8 = (__int64 ***)(*v5 + 16);
      else
        v8 = (__int64 ***)(result + 1);
      *v8 = a4;
    }
    else
    {
      v5 = result;
      *(_QWORD *)(*result + 16) = a4;
    }
  }
  else
  {
    *result = (__int64)a4;
    v5 = result + 1;
    a4[2] = 0LL;
    a4[3] = 0LL;
  }
  *v5 = (__int64)a4;
  result[3] = v4 + 1;
  return result;
}


================================================================================
Function: sub_62A73C8 (0x62A73C8)
================================================================================

__int64 *__fastcall sub_62A73C8(__int64 *result, __int64 *a2, __int64 **a3)
{
  __int64 v3; // x8
  __int64 *v4; // x9
  __int64 *v5; // x11
  __int64 *v6; // x10
  __int64 *v7; // x12
  __int64 *v8; // x12
  __int64 ***v9; // x11

  v3 = result[3];
  a3[1] = a2;
  *a3 = result;
  v4 = result + 1;
  v5 = (__int64 *)result[1];
  if ( v3 )
  {
    v6 = v5 + 3;
    if ( v5 )
      v7 = v5 + 3;
    else
      v7 = result;
    v8 = (__int64 *)*v7;
    a3[2] = v5;
    a3[3] = v8;
    if ( v5 )
    {
      if ( *v6 )
        v9 = (__int64 ***)(*v6 + 16);
      else
        v9 = (__int64 ***)(result + 1);
      v4 = v6;
      *v9 = a3;
    }
    else
    {
      v4 = result;
      *(_QWORD *)(*result + 16) = a3;
    }
  }
  else
  {
    *result = (__int64)a3;
    a3[2] = 0LL;
    a3[3] = 0LL;
  }
  *v4 = (__int64)a3;
  result[3] = v3 + 1;
  return result;
}


================================================================================
Function: sub_62A743C (0x62A743C)
================================================================================

__int64 __fastcall sub_62A743C(__int64 result, __int64 a2)
{
  _QWORD *v2; // x9
  __int64 v3; // x8
  __int64 v4; // x10
  __int64 v5; // x8
  __int64 v6; // x8
  __int64 (__fastcall *v7)(__int64, __int64); // x2

  if ( result )
  {
    v2 = *(_QWORD **)result;
    if ( **(_QWORD **)result == result )
    {
      v5 = *(_QWORD *)(result + 24);
      *v2 = v5;
      if ( v5 )
        *(_QWORD *)(v5 + 16) = 0LL;
      else
        v2[1] = 0LL;
    }
    else
    {
      v3 = *(_QWORD *)(result + 16);
      if ( v3 )
        *(_QWORD *)(v3 + 24) = *(_QWORD *)(result + 24);
      v4 = *(_QWORD *)(result + 24);
      if ( v4 )
        *(_QWORD *)(v4 + 16) = v3;
      else
        v2[1] = v3;
    }
    v6 = *(_QWORD *)(result + 8);
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    v7 = (__int64 (__fastcall *)(__int64, __int64))v2[2];
    --v2[3];
    if ( v7 )
      return v7(a2, v6);
  }
  return result;
}


================================================================================
Function: sub_62A74BC (0x62A74BC)
================================================================================

__int64 __fastcall sub_62A74BC(__int64 result)
{
  _QWORD *v1; // x8
  __int64 v2; // x9
  __int64 v3; // x10
  __int64 v4; // x9
  __int64 v5; // x1
  __int64 (__fastcall *v6)(_QWORD, __int64); // x2

  if ( result )
  {
    v1 = *(_QWORD **)result;
    if ( **(_QWORD **)result == result )
    {
      v4 = *(_QWORD *)(result + 24);
      *v1 = v4;
      if ( v4 )
        *(_QWORD *)(v4 + 16) = 0LL;
      else
        v1[1] = 0LL;
    }
    else
    {
      v2 = *(_QWORD *)(result + 16);
      if ( v2 )
        *(_QWORD *)(v2 + 24) = *(_QWORD *)(result + 24);
      v3 = *(_QWORD *)(result + 24);
      if ( v3 )
        *(_QWORD *)(v3 + 16) = v2;
      else
        v1[1] = v2;
    }
    v5 = *(_QWORD *)(result + 8);
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    v6 = (__int64 (__fastcall *)(_QWORD, __int64))v1[2];
    --v1[3];
    if ( v6 )
      return v6(0LL, v5);
  }
  return result;
}


================================================================================
Function: sub_62A7538 (0x62A7538)
================================================================================

__int64 __fastcall sub_62A7538(__int64 result, __int64 a2)
{
  __int64 v2; // x19
  __int64 v4; // x8
  _QWORD *v5; // x9
  __int64 v6; // x10
  __int64 v7; // x11
  __int64 v8; // x10
  __int64 v9; // x1
  __int64 (__fastcall *v10)(__int64, __int64); // x8

  if ( result )
  {
    v2 = result;
    while ( *(_QWORD *)(v2 + 24) )
    {
      v4 = *(_QWORD *)(v2 + 8);
      if ( v4 )
      {
        v5 = *(_QWORD **)v4;
        if ( **(_QWORD **)v4 == v4 )
        {
          v8 = *(_QWORD *)(v4 + 24);
          *v5 = v8;
          if ( v8 )
            *(_QWORD *)(v8 + 16) = 0LL;
          else
            v5[1] = 0LL;
        }
        else
        {
          v6 = *(_QWORD *)(v4 + 16);
          if ( v6 )
            *(_QWORD *)(v6 + 24) = *(_QWORD *)(v4 + 24);
          v7 = *(_QWORD *)(v4 + 24);
          if ( v7 )
            *(_QWORD *)(v7 + 16) = v6;
          else
            v5[1] = v6;
        }
        v9 = *(_QWORD *)(v4 + 8);
        *(_OWORD *)v4 = 0u;
        *(_OWORD *)(v4 + 16) = 0u;
        v10 = (__int64 (__fastcall *)(__int64, __int64))v5[2];
        --v5[3];
        if ( v10 )
          result = v10(a2, v9);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62A75F0 (0x62A75F0)
================================================================================

__int64 __fastcall sub_62A75F0(__int64 a1)
{
  return *(_QWORD *)a1;
}


================================================================================
Function: sub_62A75F8 (0x62A75F8)
================================================================================

__int64 __fastcall sub_62A75F8(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}


================================================================================
Function: sub_62A7600 (0x62A7600)
================================================================================

__int64 __fastcall sub_62A7600(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}


================================================================================
Function: sub_62A7608 (0x62A7608)
================================================================================

__int64 __fastcall sub_62A7608(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}


================================================================================
Function: sub_62A7610 (0x62A7610)
================================================================================

__int64 __fastcall sub_62A7610(__int64 a1)
{
  return *(_QWORD *)a1;
}


================================================================================
Function: sub_62A7618 (0x62A7618)
================================================================================

long double __fastcall sub_62A7618(__int64 a1)
{
  void (__fastcall *v2)(_QWORD); // x8
  int v3; // w8
  __int64 v4; // x0
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  long double result; // q0

  if ( a1 )
  {
    v2 = *(void (__fastcall **)(_QWORD))(a1 + 48);
    if ( v2 )
      v2(*(_QWORD *)(a1 + 56));
    v3 = *(_DWORD *)(a1 + 20);
    *(_QWORD *)(a1 + 40) = 0LL;
    *(_QWORD *)(a1 + 48) = 0LL;
    v4 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
    *(_QWORD *)(a1 + 56) = a1;
    *(_QWORD *)(a1 + 64) = 0LL;
    *(_QWORD *)(a1 + 112) = 0LL;
    *(_QWORD *)(a1 + 160) = 0LL;
    *(_QWORD *)(a1 + 168) = 0LL;
    *(_QWORD *)(a1 + 152) = 0LL;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = v3 & 0xFFFFFFFB;
    *(_DWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 432) = 1LL;
    sub_62B99E4(v4);
    if ( (*(_BYTE *)(a1 + 20) & 1) != 0 )
      sub_62B99E4(*(_QWORD *)(a1 + 80));
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 88));
    v5 = off_6C2D120[0];
    *(_QWORD *)(a1 + 88) = 0LL;
    ((void (__fastcall *)(_QWORD))v5)(*(_QWORD *)(a1 + 104));
    v6 = off_6C2D120[0];
    *(_QWORD *)(a1 + 104) = 0LL;
    ((void (__fastcall *)(_QWORD))v6)(*(_QWORD *)(a1 + 96));
    *(_OWORD *)&result = 0uLL;
    *(_QWORD *)(a1 + 432) = 0LL;
    *(_QWORD *)(a1 + 432) = 1LL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    *(_OWORD *)(a1 + 240) = 0u;
    *(_OWORD *)(a1 + 256) = 0u;
    *(_OWORD *)(a1 + 272) = 0u;
    *(_OWORD *)(a1 + 288) = 0u;
    *(_OWORD *)(a1 + 304) = 0u;
    *(_OWORD *)(a1 + 320) = 0u;
    *(_OWORD *)(a1 + 336) = 0u;
    *(_OWORD *)(a1 + 352) = 0u;
    *(_OWORD *)(a1 + 368) = 0u;
    *(_OWORD *)(a1 + 384) = 0u;
    *(_OWORD *)(a1 + 400) = 0u;
    *(_OWORD *)(a1 + 416) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_DWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0LL;
    *(_QWORD *)(a1 + 136) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_62A7714 (0x62A7714)
================================================================================

long double __fastcall sub_62A7714(__int64 a1)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)(a1 + 432) = 0LL;
  *(_QWORD *)(a1 + 432) = 1LL;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0LL;
  *(_QWORD *)(a1 + 136) = 0LL;
  return result;
}


================================================================================
Function: sub_62A9DA8 (0x62A9DA8)
================================================================================

__int64 __fastcall sub_62A9DA8(_BYTE *a1, __int64 a2, __int64 a3, __int128 *a4)
{
  __int128 v4; // q0
  __int128 v5; // q1
  __int64 result; // x0
  _OWORD v7[2]; // [xsp+0h] [xbp-40h] BYREF
  _BYTE *v8; // [xsp+20h] [xbp-20h] BYREF
  __int64 v9; // [xsp+28h] [xbp-18h]
  __int64 v10; // [xsp+30h] [xbp-10h]

  v4 = *a4;
  v5 = a4[1];
  v10 = a2;
  v8 = a1;
  v9 = 0LL;
  v7[0] = v4;
  v7[1] = v5;
  result = sub_62A9E34(&v8, sub_62AB0D0, a3, v7);
  if ( v10 )
  {
    if ( v10 == v9 )
    {
      result = (unsigned int)(result - 1);
      *(v8 - 1) = 0;
    }
    else
    {
      *v8 = 0;
    }
  }
  return result;
}


================================================================================
Function: sub_62A9E34 (0x62A9E34)
================================================================================

__int64 __fastcall sub_62A9E34(
        __int64 a1,
        unsigned int (__fastcall *a2)(long double),
        char *a3,
        int **a4,
        long double a5)
{
  int v5; // w8
  int v6; // w17
  int v7; // w16
  int v8; // w14
  int *v9; // x9
  int *v10; // x12
  int *v11; // x10
  unsigned int v12; // w11
  unsigned int v13; // w13
  char *v14; // x4
  unsigned __int8 *i; // x24
  int v16; // w6
  char *v17; // x22
  int v18; // w23
  int v19; // w5
  int v20; // w5
  int v21; // w7
  int v22; // t1
  int v23; // w7
  char *v24; // x7
  unsigned int v25; // w6
  int v26; // w21
  int v27; // w7
  char v28; // w25
  int v29; // t1
  char v30; // w2
  int v31; // w7
  int v32; // t1
  int v33; // w7
  int v34; // w25
  int v35; // w24
  int v36; // t1
  int v37; // w24
  int v38; // w21
  int v39; // w25
  int v40; // w21
  int v41; // w24
  int v42; // t1
  int v43; // w24
  __int64 v44; // x25
  int v45; // w25
  char *v46; // x24
  int v47; // w24
  int v48; // w24
  int v49; // t1
  __int64 v50; // x5
  _QWORD *v51; // x5
  char *v52; // x22
  int v53; // w23
  unsigned __int64 v54; // x23
  int v55; // w24
  unsigned __int64 v56; // x23
  unsigned __int64 v57; // x23
  int v58; // w24
  __int64 v59; // x24
  char v60; // w28
  int v61; // w19
  __int64 v62; // x19
  char v63; // w25
  int v64; // w24
  int v65; // w19
  __int64 v66; // x19
  char v67; // w26
  __int64 v68; // x19
  _BYTE *v69; // x19
  __int64 v70; // x16
  _QWORD *v71; // x16
  __int64 v72; // x15
  __int64 v73; // x14
  _QWORD *v74; // x16
  unsigned int v75; // w1
  int *v76; // x2
  __int64 v77; // x3
  unsigned int v78; // w1
  int *v79; // x2
  __int64 v80; // x1
  unsigned int (__fastcall *v81)(long double); // x16
  __int64 v82; // x28
  unsigned int v83; // w21
  const char *v84; // x22
  _BYTE *v85; // x22
  __int64 v86; // x24
  unsigned int v87; // w23
  _BYTE *v88; // x25
  unsigned int v89; // w26
  int v90; // w24
  unsigned __int64 v91; // x26
  __int64 v92; // x25
  int v93; // w12
  const char *v94; // x19
  __int64 v95; // x25
  _BOOL4 v96; // w2
  unsigned __int64 v97; // x9
  _BOOL4 v98; // w8
  int v99; // w11
  _BYTE *v100; // x10
  unsigned __int64 v101; // x26
  bool v102; // cf
  int v103; // w13
  unsigned int v104; // w22
  int v105; // w9
  int v106; // w11
  unsigned __int64 v107; // x10
  char *v108; // x25
  _BYTE *v109; // x8
  size_t v110; // x0
  int v111; // w2
  char *v112; // x22
  __int64 v113; // x1
  __int64 v114; // x19
  int v115; // w0
  bool v116; // cc
  double v117; // d0
  int v118; // w8
  int v119; // w8
  char v120; // w8
  _BYTE *v121; // x13
  int v122; // w12
  unsigned __int64 v123; // x15
  unsigned int v124; // w13
  unsigned int v125; // w10
  int v126; // w12
  unsigned int v127; // w22
  int v128; // w23
  __int64 v129; // x9
  bool v130; // zf
  char v131; // w9
  int v132; // w22
  unsigned int v133; // w24
  unsigned int v134; // w12
  char v135; // w25
  unsigned int v136; // w9
  int v137; // w24
  __int64 v138; // x0
  bool v139; // w19
  __int64 v140; // x0
  unsigned int v141; // w22
  unsigned __int8 *v142; // x22
  unsigned int v143; // w25
  _BYTE *v144; // x26
  int v145; // w23
  unsigned __int8 *v146; // x22
  size_t v148; // x0
  int v149; // w22
  __int64 v150; // x20
  unsigned int (__fastcall *v151)(long double); // x19
  unsigned int v152; // w23
  int v153; // w22
  int v154; // w19
  int v155; // w22
  unsigned int v156; // w24
  unsigned int v157; // w24
  unsigned int v158; // w23
  int v159; // w22
  unsigned int v161; // [xsp+4h] [xbp-19DCh]
  __int64 v162; // [xsp+28h] [xbp-19B8h]
  const char *v163; // [xsp+30h] [xbp-19B0h]
  char format[16]; // [xsp+50h] [xbp-1990h] BYREF
  __int128 v167; // [xsp+60h] [xbp-1980h]
  char v168; // [xsp+78h] [xbp-1968h] BYREF
  _BYTE v169[7]; // [xsp+79h] [xbp-1967h] BYREF
  _BYTE v170[12]; // [xsp+1BCh] [xbp-1824h] BYREF
  _BYTE v171[6136]; // [xsp+1C8h] [xbp-1818h] BYREF

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = -1;
  *(_QWORD *)&a5 = 0x100000LL;
  v10 = *a4;
  v9 = a4[1];
  v11 = a4[2];
  memset(format, 0, sizeof(format));
  v13 = *((_DWORD *)a4 + 6);
  v12 = *((_DWORD *)a4 + 7);
LABEL_2:
  v14 = a3;
  for ( i = (unsigned __int8 *)a3; ; ++i )
  {
LABEL_3:
    while ( *i == 37 )
    {
      v17 = (char *)(i + 1);
      v16 = i[1];
      if ( v16 != 37 )
      {
        if ( v6 == 1 )
        {
          v18 = 0;
          v19 = -1;
          a3 = (char *)(i + 1);
LABEL_20:
          v25 = 0;
          v26 = 0;
          v27 = 0;
          while ( 1 )
          {
            i = (unsigned __int8 *)a3;
            v29 = *a3++;
            v28 = v29;
            switch ( v29 )
            {
              case ' ':
                v25 |= 1u;
                continue;
              case '#':
                v25 |= 8u;
                continue;
              case '*':
                v25 |= 0x4000u;
                v27 = -1;
                if ( v18 )
                {
                  v33 = (unsigned __int8)*a3;
                  if ( (unsigned int)(v33 - 48) > 9 )
                    return 0;
                  v34 = 0;
                  a3 = (char *)(i + 2);
                  do
                  {
                    v35 = v33 + 10 * v34;
                    v36 = (unsigned __int8)*a3++;
                    v33 = v36;
                    v37 = v35 - 48;
                    if ( v34 < 128 )
                      v34 = v37;
                  }
                  while ( (unsigned int)(v33 - 48) < 0xA );
                  if ( !v34 )
                    return 0;
                  if ( v34 > 128 )
                    return 0;
                  if ( v33 != 36 )
                    return 0;
                  v27 = v34 - 1;
                  if ( v34 < 1 )
                    return 0;
                }
                continue;
              case '+':
                v25 |= 2u;
                continue;
              case '-':
                v25 = v25 & 0xFFFFFEFB | 4;
                continue;
              case '.':
                v38 = (unsigned __int8)*a3;
                if ( v38 == 42 )
                {
                  v25 |= 0x10000u;
                  a3 = (char *)(i + 2);
                  if ( v18 )
                  {
                    v39 = (unsigned __int8)*a3;
                    if ( (unsigned int)(v39 - 48) > 9 )
                      return 0;
                    v40 = 0;
                    a3 = (char *)(i + 3);
                    do
                    {
                      v41 = v39 + 10 * v40;
                      v42 = (unsigned __int8)*a3++;
                      v39 = v42;
                      v43 = v41 - 48;
                      if ( v40 < 128 )
                        v40 = v43;
                    }
                    while ( (unsigned int)(v39 - 48) < 0xA );
                    if ( !v40 || v40 > 128 || v39 != 36 || v40 < 1 )
                      return 0;
                    v26 = v40 - 1;
                  }
                  else
                  {
                    v26 = -1;
                  }
                }
                else
                {
                  v44 = 1LL;
                  if ( v38 == 45 )
                    v44 = 2LL;
                  v45 = i[v44];
                  v46 = (char *)(i + 2);
                  if ( v38 == 45 )
                    a3 = v46;
                  if ( (unsigned int)(v45 - 48) <= 9 )
                  {
                    v47 = 0;
                    while ( v47 <= 214748364 )
                    {
                      v48 = v45 + 10 * v47;
                      v49 = (unsigned __int8)*++a3;
                      v45 = v49;
                      v47 = v48 - 48;
                      if ( (unsigned int)(v49 - 48) >= 0xA )
                        goto LABEL_72;
                    }
                    return 0;
                  }
                  v47 = 0;
LABEL_72:
                  v25 |= 0x8000u;
                  if ( v38 == 45 )
                    v26 = -v47;
                  else
                    v26 = v47;
                }
                if ( (~v25 & 0x18000) == 0 )
                  return 0;
                break;
              case '0':
                v25 |= ~(v25 << 6) & 0x100;
                goto LABEL_22;
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
LABEL_22:
                v27 = 0;
                v30 = v28;
                v25 |= 0x2000u;
                do
                {
                  if ( v27 > 214748364 )
                    return 0;
                  v31 = 10 * v27 + v30;
                  v32 = *++i;
                  v30 = v32;
                  v27 = v31 - 48;
                }
                while ( (unsigned int)(v32 - 48) < 0xA );
                a3 = (char *)i;
                continue;
              case 'E':
                v52 = &v17[~(unsigned __int64)v14];
                v25 |= 0x41000u;
                v53 = 9;
                goto LABEL_111;
              case 'G':
                v52 = &v17[~(unsigned __int64)v14];
                v25 |= 0x81000u;
                v53 = 9;
                goto LABEL_111;
              case 'L':
                v25 |= 0x80u;
                continue;
              case 'O':
              case 'z':
                v25 |= 0x20u;
                continue;
              case 'S':
                v53 = 0;
                v52 = &v17[~(unsigned __int64)v14];
                v25 |= 8u;
                goto LABEL_111;
              case 'X':
                v54 = ~(unsigned __int64)v14;
                v55 = 6656;
                goto LABEL_109;
              case 'c':
                v56 = ~(unsigned __int64)v14;
                v25 |= 0x20000u;
                goto LABEL_100;
              case 'd':
              case 'i':
                v52 = &v17[~(unsigned __int64)v14];
                if ( (v25 & 0x40) != 0 )
                {
                  v53 = 5;
                }
                else if ( (v25 & 0x20) != 0 )
                {
                  v53 = 4;
                }
                else
                {
                  v53 = 3;
                }
                goto LABEL_111;
              case 'e':
                v57 = ~(unsigned __int64)v14;
                v25 |= 0x40000u;
                goto LABEL_97;
              case 'f':
                v57 = ~(unsigned __int64)v14;
                goto LABEL_97;
              case 'g':
                v57 = ~(unsigned __int64)v14;
                v25 |= 0x80000u;
LABEL_97:
                v52 = &v17[v57];
                v53 = 9;
                goto LABEL_111;
              case 'h':
                v25 |= 0x10u;
                continue;
              case 'l':
                if ( (v25 & 0x20) != 0 )
                  v25 |= 0x40u;
                else
                  v25 |= 0x20u;
                continue;
              case 'n':
                v52 = &v17[~(unsigned __int64)v14];
                v53 = 2;
                goto LABEL_111;
              case 'o':
                v56 = ~(unsigned __int64)v14;
                v25 |= 0x400u;
LABEL_100:
                v52 = &v17[v56];
                v53 = 3;
                goto LABEL_111;
              case 'p':
                v52 = &v17[~(unsigned __int64)v14];
                v53 = 1;
                goto LABEL_111;
              case 'q':
                v25 |= 0x40u;
                continue;
              case 's':
                v53 = 0;
                v52 = &v17[~(unsigned __int64)v14];
                goto LABEL_111;
              case 'u':
                v52 = &v17[~(unsigned __int64)v14];
                if ( (v25 & 0x20) != 0 )
                  v53 = 7;
                else
                  v53 = 6;
                v130 = (v25 & 0x40) == 0;
                v25 |= 0x200u;
                if ( !v130 )
                  v53 = 8;
                goto LABEL_111;
              case 'x':
                v54 = ~(unsigned __int64)v14;
                v55 = 2560;
LABEL_109:
                v52 = &v17[v54];
                v25 |= v55;
                v53 = 6;
LABEL_111:
                if ( (v25 & 0x4000) == 0 )
                  goto LABEL_122;
                if ( v27 < 0 )
                {
                  v27 = v7++;
                }
                else if ( (((unsigned __int8)format[(unsigned __int64)(unsigned int)v27 >> 3] >> (v27 & 7)) & 1) != 0 )
                {
                  return 0;
                }
                if ( v27 > 127 )
                  return 0;
                v58 = v27 + 7;
                if ( v27 >= v8 )
                  v8 = v27;
                if ( v27 >= 0 )
                  v58 = v27;
                v59 = (__int64)v58 >> 3;
                v60 = format[v59];
                *(_DWORD *)&v170[16 * v27 + 4] = 11;
                format[v59] = v60 | (1 << (v27 & 7));
LABEL_122:
                if ( (v25 & 0x10000) == 0 )
                  goto LABEL_133;
                if ( v26 < 0 )
                {
                  v26 = v7++;
                }
                else if ( (((unsigned __int8)format[(unsigned __int64)(unsigned int)v26 >> 3] >> (v26 & 7)) & 1) != 0 )
                {
                  return 0;
                }
                if ( v26 > 127 )
                  return 0;
                v61 = v26 + 7;
                if ( v26 >= v8 )
                  v8 = v26;
                if ( v26 >= 0 )
                  v61 = v26;
                v62 = (__int64)v61 >> 3;
                v63 = format[v62];
                *(_DWORD *)&v170[16 * v26 + 4] = 12;
                format[v62] = v63 | (1 << (v26 & 7));
LABEL_133:
                if ( v19 >= 0 )
                  v64 = v19;
                else
                  v64 = v7;
                if ( v64 > 127 )
                  return 0;
                v65 = v64 + 7;
                if ( v64 >= 0 )
                  v65 = v64;
                v66 = (__int64)v65 >> 3;
                v67 = format[v66];
                *(_DWORD *)&v170[16 * v64 + 4] = v53;
                format[v66] = v67 | (1 << (v64 & 7));
                if ( v5 > 127 )
                  return 0;
                v68 = v5;
                v7 += (unsigned int)v19 >> 31;
                ++v5;
                v69 = &v171[32 * v68 + 2040];
                if ( v64 >= v8 )
                  v8 = v64;
                *((_DWORD *)v69 + 2) = v25;
                *((_DWORD *)v69 + 3) = v64;
                *(_DWORD *)v69 = v27;
                *((_DWORD *)v69 + 1) = v26;
                *((_QWORD *)v69 + 2) = v14;
                *((_QWORD *)v69 + 3) = v52;
                goto LABEL_2;
              default:
                goto LABEL_3;
            }
          }
        }
        if ( (unsigned int)(v16 - 48) > 9 )
        {
          v24 = (char *)(i + 1);
        }
        else
        {
          v20 = 0;
          a3 = (char *)(i + 2);
          do
          {
            v21 = v16 + 10 * v20;
            v22 = (unsigned __int8)*a3++;
            v16 = v22;
            v23 = v21 - 48;
            if ( v20 < 128 )
              v20 = v23;
          }
          while ( (unsigned int)(v16 - 48) < 0xA );
          v24 = (char *)(i + 1);
          if ( v20 && v20 <= 128 && v16 == 36 )
          {
            if ( v20 > 0 )
            {
              v19 = v20 - 1;
              v6 = 2;
              v18 = 1;
              goto LABEL_20;
            }
            v24 = a3;
            if ( v6 == 2 )
              return 0;
LABEL_19:
            v18 = 0;
            v6 = 1;
            v19 = -1;
            a3 = v24;
            goto LABEL_20;
          }
        }
        if ( v6 == 2 )
          return 0;
        goto LABEL_19;
      }
      if ( &v17[~(unsigned __int64)v14] )
      {
        if ( v5 > 127 )
          return 0;
        v50 = v5++;
        v51 = &v171[32 * v50 + 2040];
        v51[1] = 0x100000LL;
        v51[2] = v14;
        v51[3] = &v17[~(unsigned __int64)v14];
      }
      i += 2;
      v14 = v17;
    }
    if ( !*i )
      break;
  }
  if ( i != (unsigned __int8 *)v14 )
  {
    if ( v5 > 127 )
      return 0;
    v70 = v5++;
    v71 = &v171[32 * v70 + 2040];
    v71[1] = 0x100000LL;
    v71[2] = v14;
    v71[3] = i - (unsigned __int8 *)v14;
  }
  if ( (v8 & 0x80000000) == 0 )
  {
    v72 = 0LL;
    v73 = (unsigned int)(v8 + 1);
    v74 = v171;
    while ( 2 )
    {
      if ( (((unsigned __int8)format[(unsigned int)v72 >> 3] >> (v72 & 7)) & 1) == 0 )
        return 0;
      switch ( *((_DWORD *)v74 - 2) )
      {
        case 0:
        case 1:
        case 2:
        case 4:
        case 5:
        case 7:
        case 8:
          if ( (v13 & 0x80000000) != 0 )
          {
            v75 = v13 + 8;
            if ( v13 <= 0xFFFFFFF8 )
            {
              v76 = v10;
              v10 = (int *)((char *)v9 + (int)v13);
              goto LABEL_150;
            }
          }
          else
          {
            v75 = v13;
          }
          v76 = v10 + 2;
LABEL_150:
          v77 = *(_QWORD *)v10;
          goto LABEL_151;
        case 3:
        case 0xB:
        case 0xC:
          if ( (v13 & 0x80000000) != 0 )
          {
            v75 = v13 + 8;
            if ( v13 <= 0xFFFFFFF8 )
            {
              v76 = v10;
              v77 = *(int *)((char *)v9 + (int)v13);
              goto LABEL_151;
            }
          }
          else
          {
            v75 = v13;
          }
          v77 = *v10;
          v76 = v10 + 2;
          goto LABEL_151;
        case 6:
          if ( (v13 & 0x80000000) != 0 )
          {
            v75 = v13 + 8;
            if ( v13 <= 0xFFFFFFF8 )
            {
              v76 = v10;
              v77 = *(unsigned int *)((char *)v9 + (int)v13);
              goto LABEL_151;
            }
          }
          else
          {
            v75 = v13;
          }
          v77 = (unsigned int)*v10;
          v76 = v10 + 2;
LABEL_151:
          v13 = v75;
          v10 = v76;
          *v74 = v77;
          goto LABEL_152;
        case 9:
          if ( (v12 & 0x80000000) != 0 )
          {
            v78 = v12 + 16;
            if ( v12 <= 0xFFFFFFF0 )
            {
              v79 = v10;
              v10 = (int *)((char *)v11 + (int)v12);
              goto LABEL_173;
            }
          }
          else
          {
            v78 = v12;
          }
          v79 = v10 + 2;
LABEL_173:
          *(_QWORD *)&a5 = *(_QWORD *)v10;
          v12 = v78;
          v10 = v79;
          *v74 = *(_QWORD *)&a5;
LABEL_152:
          ++v72;
          v74 += 2;
          if ( v73 != v72 )
            continue;
          goto LABEL_174;
        default:
          goto LABEL_152;
      }
    }
  }
LABEL_174:
  if ( v5 < 1 )
    return 0;
  v80 = a1;
  v81 = a2;
  v82 = 0LL;
  v83 = 0;
  v84 = "0123456789abcdefghijklmnopqrstuvwxyz";
  v162 = (unsigned int)v5;
  while ( 2 )
  {
    v163 = v84;
    v85 = &v171[32 * v82 + 2040];
    v86 = *((_QWORD *)v85 + 3);
    v87 = *((_DWORD *)v85 + 2);
    if ( v86 )
    {
      v88 = (_BYTE *)*((_QWORD *)v85 + 2);
      v89 = v83 + v86;
      while ( *v88 )
      {
        if ( v81(a5) )
          return v83;
        v80 = a1;
        v81 = a2;
        ++v88;
        ++v83;
        if ( !--v86 )
        {
          v83 = v89;
          break;
        }
      }
      if ( (v87 & 0x100000) != 0 )
      {
        v84 = v163;
LABEL_415:
        if ( ++v82 == v162 )
          return v83;
        continue;
      }
    }
    break;
  }
  v90 = *(_DWORD *)v85;
  if ( (v87 & 0x4000) != 0 )
  {
    v90 = *(_DWORD *)&v170[16 * v90 + 12];
    if ( v90 < 0 )
    {
      if ( v90 == 0x80000000 )
        v90 = 0x7FFFFFFF;
      else
        v90 = -v90;
      v87 = v87 & 0xFFFFFEFB | 4;
    }
  }
  if ( (v87 & 0x10000) != 0 )
  {
    if ( *(int *)&v170[16 * *(int *)&v171[32 * v82 + 2044] + 12] < 0 )
      LODWORD(v91) = -1;
    else
      LODWORD(v91) = *(_DWORD *)&v170[16 * *(int *)&v171[32 * v82 + 2044] + 12];
  }
  else if ( (v87 & 0x8000) != 0 )
  {
    LODWORD(v91) = *(_DWORD *)&v171[32 * v82 + 2044];
  }
  else
  {
    LODWORD(v91) = -1;
  }
  v92 = *(unsigned int *)&v171[32 * v82 + 2052];
  v93 = v87 & 8;
  switch ( *(_DWORD *)&v170[16 * v92 + 4] )
  {
    case 0:
      v108 = *(char **)&v170[16 * v92 + 12];
      if ( v108 )
      {
        if ( (_DWORD)v91 == -1 )
        {
          if ( !*v108 )
          {
            v91 = 0LL;
            goto LABEL_384;
          }
          v148 = strlen(v108);
          v80 = a1;
          v81 = a2;
          v91 = v148;
          v93 = v87 & 8;
        }
        else
        {
          v91 = (int)v91;
        }
        if ( v91 > 0x7FFFFFFE )
        {
          v149 = 0x7FFFFFFF;
          goto LABEL_385;
        }
      }
      else if ( (_DWORD)v91 == -1 || (int)v91 >= 5 )
      {
        v93 = 0;
        LOBYTE(v87) = v87 & 0xF7;
        v91 = 5LL;
        v108 = "(nil)";
      }
      else
      {
        v91 = 0LL;
        v108 = &byte_CBCB6C;
      }
LABEL_384:
      v149 = v91;
LABEL_385:
      v154 = v93;
      if ( !v93 )
        goto LABEL_388;
      if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(34LL, v80, a5) )
        return v83;
      ++v83;
      v93 = v154;
LABEL_388:
      v155 = v90 - v149;
      if ( (v87 & 4) != 0 )
      {
        v80 = a1;
        v81 = a2;
      }
      else
      {
        v80 = a1;
        v81 = a2;
        if ( v155 < 1 )
        {
          --v155;
        }
        else
        {
          v156 = v155 + v83;
          do
          {
            if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(32LL, v80, a5) )
              return v83;
            v80 = a1;
            v81 = a2;
            ++v83;
            --v155;
          }
          while ( v155 > 0 );
          v155 = -1;
          v83 = v156;
          v93 = v154;
        }
      }
      if ( !v91 )
        goto LABEL_403;
      v157 = v83 + v91;
      while ( *v108 )
      {
        if ( ((unsigned int (*)(void))v81)() )
          return v83;
        v80 = a1;
        v81 = a2;
        ++v108;
        ++v83;
        if ( !--v91 )
        {
          v83 = v157;
          break;
        }
      }
      v93 = v154;
LABEL_403:
      if ( (v87 & 4) != 0 && v155 >= 1 )
      {
        v158 = v83 + v155;
        v159 = v155 + 1;
        do
        {
          if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(32LL, v80) )
            return v83;
          v80 = a1;
          v81 = a2;
          ++v83;
          --v159;
        }
        while ( v159 > 1 );
        v83 = v158;
        v93 = v154;
      }
      v84 = v163;
      if ( !v93 )
        goto LABEL_415;
      if ( !((unsigned int (__fastcall *)(__int64, __int64))v81)(34LL, v80) )
      {
        v80 = a1;
        v81 = a2;
        ++v83;
        goto LABEL_415;
      }
      return v83;
    case 1:
      v95 = *(_QWORD *)&v170[16 * v92 + 12];
      if ( v95 )
      {
        v106 = 0;
        v105 = 1;
        if ( (v87 & 0x1000) != 0 )
          v94 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        else
          v94 = "0123456789abcdefghijklmnopqrstuvwxyz";
        v107 = 16LL;
        v98 = 1;
LABEL_264:
        v121 = v170;
        if ( (_DWORD)v91 == -1 )
          v122 = 1;
        else
          v122 = v91;
        v101 = (unsigned __int64)v170;
        if ( v95 )
        {
          do
          {
            LODWORD(v121) = (_DWORD)v121 - 1;
            v116 = v107 > v95;
            v123 = v95 % v107;
            v95 /= v107;
            *(_BYTE *)v101-- = v94[v123];
          }
          while ( !v116 );
        }
        else
        {
          LODWORD(v121) = (unsigned int)v170;
          v101 = (unsigned __int64)v170;
        }
        v124 = (unsigned int)v170 - (_DWORD)v121;
        v96 = 0;
        v125 = v90 - v124;
        v126 = v122 - v124;
        if ( (v106 & v98) == 1 && v126 <= 0 )
        {
          v96 = 0;
          --v125;
          v98 = 1;
          v163 = v94;
          *(_BYTE *)v101-- = 48;
        }
        else
        {
LABEL_304:
          v163 = v94;
          if ( v126 >= 1 )
          {
            v125 -= v126;
            while ( v101 >= (unsigned __int64)&v168 )
            {
              *(_BYTE *)v101-- = 48;
              if ( (unsigned int)v126 < 2 )
                break;
              --v126;
            }
          }
        }
        v135 = v98 & v105;
        if ( (v98 & v105) != 0 )
          v136 = v125 - 2;
        else
          v136 = v125;
        v137 = v136 - ((v96 | (v87 >> 1) | v87) & 1);
        if ( (v87 & 0x104) == 0 )
        {
          if ( v137 < 1 )
          {
            --v137;
          }
          else
          {
            v139 = v96;
            v161 = v137 + v83;
            do
            {
              if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(32LL, v80, a5) )
                return v83;
              v80 = a1;
              v81 = a2;
              ++v83;
              --v137;
            }
            while ( v137 > 0 );
            v137 = -1;
            v83 = v161;
            LOBYTE(v96) = v139;
          }
        }
        if ( v96 )
        {
          v138 = 45LL;
        }
        else if ( (v87 & 2) != 0 )
        {
          v138 = 43LL;
        }
        else
        {
          if ( (v87 & 1) == 0 )
            goto LABEL_326;
          v138 = 32LL;
        }
        if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(v138, v80) )
          return v83;
        v80 = a1;
        v81 = a2;
        ++v83;
LABEL_326:
        if ( (v135 & 1) != 0 )
        {
          if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(48LL, v80) )
            return v83;
          if ( (v87 & 0x1000) != 0 )
            v140 = 88LL;
          else
            v140 = 120LL;
          if ( ((unsigned int (__fastcall *)(__int64, __int64))a2)(v140, a1) )
            return ++v83;
          v80 = a1;
          v81 = a2;
          v83 += 2;
        }
        if ( (v87 & 0x104) == 0x100 )
        {
          if ( v137 < 1 )
          {
            --v137;
          }
          else
          {
            v141 = v83 + v137;
            do
            {
              if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(48LL, v80) )
                return v83;
              v80 = a1;
              v81 = a2;
              ++v83;
              --v137;
            }
            while ( v137 > 0 );
            v137 = -1;
            v83 = v141;
          }
        }
        v142 = (unsigned __int8 *)(v101 + 1);
        if ( v101 + 1 <= (unsigned __int64)v170 )
        {
          v143 = (unsigned int)v170 - v101 + v83;
          v144 = &v170[-v101];
          do
          {
            if ( ((unsigned int (__fastcall *)(_QWORD, __int64))v81)(*v142, v80) )
              return v83;
            v80 = a1;
            v81 = a2;
            ++v83;
            ++v142;
            --v144;
          }
          while ( v144 );
          v83 = v143;
        }
        v84 = v163;
        if ( (v87 & 4) != 0 && v137 >= 1 )
        {
          v127 = v83 + v137;
          v145 = v137 + 1;
          do
          {
            if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(32LL, v80) )
              return v83;
            v80 = a1;
            v81 = a2;
            ++v83;
            --v145;
          }
          while ( v145 > 1 );
LABEL_351:
          v83 = v127;
LABEL_364:
          v84 = v163;
        }
        goto LABEL_415;
      }
      v132 = v90 - 5;
      if ( (v87 & 4) != 0 )
      {
        if ( v90 < 6 )
        {
          v132 = v90 - 6;
        }
        else
        {
          v133 = v132 + v83;
          do
          {
            if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(32LL, v80, a5) )
              return v83;
            v80 = a1;
            v81 = a2;
            ++v83;
            --v132;
          }
          while ( v132 > 0 );
          v132 = -1;
          v83 = v133;
        }
      }
      v150 = v80;
      v151 = v81;
      if ( !((unsigned int (__fastcall *)(__int64, long double))v81)(40LL, a5) )
      {
        if ( ((unsigned int (__fastcall *)(__int64, __int64))v151)(110LL, v150) )
          return ++v83;
        if ( ((unsigned int (__fastcall *)(__int64, __int64))v151)(105LL, v150) )
        {
          v83 += 2;
        }
        else if ( ((unsigned int (__fastcall *)(__int64, __int64))v151)(108LL, v150) )
        {
          v83 += 3;
        }
        else if ( ((unsigned int (__fastcall *)(__int64, __int64))v151)(41LL, v150) )
        {
          v83 += 4;
        }
        else
        {
          v83 += 5;
          if ( (v87 & 4) != 0 )
          {
            v80 = a1;
            v81 = a2;
            goto LABEL_414;
          }
          v80 = a1;
          v81 = a2;
          if ( v132 < 1 )
            goto LABEL_414;
          v152 = v83 + v132;
          v153 = v132 + 1;
          while ( !((unsigned int (__fastcall *)(__int64, __int64))v81)(32LL, v80) )
          {
            v80 = a1;
            v81 = a2;
            ++v83;
            if ( --v153 <= 1 )
            {
              v83 = v152;
              goto LABEL_414;
            }
          }
        }
      }
      return v83;
    case 2:
      v84 = v163;
      v109 = &v170[16 * v92 + 4];
      if ( (v87 & 0x40) != 0 )
      {
        v129 = (int)v83;
LABEL_354:
        **((_QWORD **)v109 + 1) = v129;
        goto LABEL_415;
      }
      if ( (v87 & 0x20) != 0 )
      {
        v129 = (int)v83;
        goto LABEL_354;
      }
      if ( (v87 & 0x10) != 0 )
        **((_WORD **)v109 + 1) = v83;
      else
        **((_DWORD **)v109 + 1) = v83;
      goto LABEL_415;
    case 3:
    case 4:
    case 5:
      goto LABEL_199;
    case 6:
    case 7:
    case 8:
      v87 |= 0x200u;
LABEL_199:
      v94 = v163;
      v95 = *(_QWORD *)&v170[16 * v92 + 12];
      if ( (v87 & 0x20000) != 0 )
      {
        if ( (v87 & 4) == 0 )
        {
          if ( v90 >= 2 )
          {
            v104 = v90 - 1 + v83;
            do
            {
              if ( ((unsigned int (__fastcall *)(__int64, __int64, long double))v81)(32LL, v80, a5) )
                return v83;
              v80 = a1;
              v81 = a2;
              ++v83;
              --v90;
            }
            while ( v90 > 1 );
            v90 = 0;
            goto LABEL_277;
          }
          --v90;
        }
        v104 = v83;
LABEL_277:
        if ( ((unsigned int (__fastcall *)(_QWORD, __int64))v81)((unsigned int)v95, v80) )
          return v104;
        v83 = v104 + 1;
        if ( (v87 & 4) == 0 )
        {
          v80 = a1;
          v81 = a2;
          goto LABEL_364;
        }
        v80 = a1;
        v81 = a2;
        if ( v90 < 2 )
          goto LABEL_364;
        v127 = v104 + v90;
        v128 = v90 + 1;
        do
        {
          if ( ((unsigned int (__fastcall *)(__int64, __int64))v81)(32LL, v80) )
            return v83;
          v80 = a1;
          v81 = a2;
          ++v83;
          --v128;
        }
        while ( v128 > 2 );
        goto LABEL_351;
      }
      if ( (v87 & 0x400) != 0 )
      {
        v105 = 0;
        v98 = v93 != 0;
        v106 = 1;
        v107 = 8LL;
        goto LABEL_264;
      }
      if ( (v87 & 0x800) == 0 )
      {
        v96 = (v87 & 0x200) == 0 && v95 < 0;
        if ( (v87 & 0x200) == 0 && v95 < 0 )
          v97 = -v95;
        else
          v97 = v95;
        v98 = v93 != 0;
        if ( (_DWORD)v91 == -1 )
          v99 = 1;
        else
          v99 = v91;
        if ( v97 )
        {
          v100 = v170;
          v101 = (unsigned __int64)v170;
          do
          {
            LODWORD(v100) = (_DWORD)v100 - 1;
            v102 = v97 >= 0xA;
            v103 = v97 % 0xA;
            v97 /= 0xAuLL;
            *(_BYTE *)v101-- = v103 | 0x30;
          }
          while ( v102 );
        }
        else
        {
          LODWORD(v100) = (unsigned int)v170;
          v101 = (unsigned __int64)v170;
        }
        v134 = (unsigned int)v170 - (_DWORD)v100;
        v105 = 0;
        v125 = v90 - v134;
        v126 = v99 - v134;
        goto LABEL_304;
      }
      v106 = 0;
      if ( (v87 & 0x1000) != 0 )
        v94 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      else
        v94 = "0123456789abcdefghijklmnopqrstuvwxyz";
      v98 = v93 != 0;
      v105 = 1;
      v107 = 16LL;
      goto LABEL_264;
    case 9:
      *(_OWORD *)format = xmmword_D13620;
      v167 = *(_OWORD *)algn_D13630;
      v110 = __strlen_chk(format, 0x20uLL);
      if ( (v87 & 0x2000) != 0 )
        v90 = *(_DWORD *)v85;
      if ( (v87 & 0x8000) != 0 )
        LODWORD(v91) = *(_DWORD *)&v171[32 * v82 + 2044];
      v112 = &format[1];
      if ( (v87 & 4) != 0 )
      {
        v112 = &format[2];
        format[1] = 45;
        if ( (v87 & 2) == 0 )
        {
LABEL_237:
          if ( (v87 & 1) == 0 )
            goto LABEL_238;
          goto LABEL_289;
        }
      }
      else if ( (v87 & 2) == 0 )
      {
        goto LABEL_237;
      }
      *v112++ = 43;
      if ( (v87 & 1) == 0 )
      {
LABEL_238:
        v113 = 32 - v110;
        if ( (v87 & 8) == 0 )
          goto LABEL_239;
        goto LABEL_290;
      }
LABEL_289:
      *v112++ = 32;
      v113 = 32 - v110;
      if ( (v87 & 8) == 0 )
      {
LABEL_239:
        *v112 = 0;
        if ( v90 < 0 )
          goto LABEL_243;
        goto LABEL_240;
      }
LABEL_290:
      *v112++ = 35;
      *v112 = 0;
      if ( v90 < 0 )
        goto LABEL_243;
LABEL_240:
      if ( (unsigned int)v90 >= 0x145 )
        v90 = 325;
      v114 = v113;
      v115 = sub_62AB108(v112, v113, "%d", v90);
      v112 += v115;
      v113 = v114 - v115;
LABEL_243:
      if ( (v91 & 0x80000000) == 0 )
      {
        v116 = (int)v91 > v90 || v90 < 1;
        v117 = *(double *)&v170[16 * v92 + 12];
        v118 = 324 - v90;
        if ( v116 )
          v118 = 324;
        for ( ; v117 >= 10.0; --v118 )
          v117 = v117 / 10.0;
        if ( (int)v91 <= v118 )
          v119 = v91;
        else
          v119 = v118 - 1;
        v112 += (int)sub_62AB108(v112, v113, ".%d", v119 & (unsigned int)~(v119 >> 31));
      }
      if ( (v87 & 0x20) != 0 )
        *v112++ = 108;
      if ( (v87 & 0x40000) != 0 )
      {
        v130 = (v87 & 0x1000) == 0;
        v120 = 69;
        v131 = 101;
      }
      else
      {
        if ( (v87 & 0x80000) == 0 )
        {
          v120 = 102;
          goto LABEL_358;
        }
        v120 = 71;
        v131 = 103;
        v130 = (v87 & 0x1000) == 0;
      }
      if ( v130 )
        v120 = v131;
LABEL_358:
      *v112 = v120;
      v112[1] = 0;
      sub_62AB524((int)&v168, v113, v111, format);
      if ( v168 )
      {
        v81 = a2;
        v146 = v169;
        do
        {
          if ( ((unsigned int (*)(void))v81)() )
            return v83;
          v80 = a1;
          v81 = a2;
          ++v83;
        }
        while ( *v146++ );
      }
      else
      {
        v80 = a1;
        v81 = a2;
      }
      goto LABEL_364;
    default:
LABEL_414:
      v84 = v163;
      goto LABEL_415;
  }
}


================================================================================
Function: sub_62AB108 (0x62AB108)
================================================================================

__int64 sub_62AB108(_BYTE *a1, __int64 a2, const char *a3, ...)
{
  __int64 result; // x0
  gcc_va_list va; // [xsp+B0h] [xbp-60h] BYREF
  gcc_va_list va1; // [xsp+D0h] [xbp-40h] BYREF
  _BYTE *v6; // [xsp+F0h] [xbp-20h] BYREF
  __int64 v7; // [xsp+F8h] [xbp-18h]
  __int64 v8; // [xsp+100h] [xbp-10h]

  va_start(va, a3);
  v8 = a2;
  v6 = a1;
  v7 = 0LL;
  va_copy(va1, va);
  result = sub_62A9E34(&v6, sub_62AB0D0, a3, va1);
  if ( v8 )
  {
    if ( v8 == v7 )
    {
      result = (unsigned int)(result - 1);
      *(v6 - 1) = 0;
    }
    else
    {
      *v6 = 0;
    }
  }
  return result;
}


================================================================================
Function: sub_62AB2E8 (0x62AB2E8)
================================================================================

char *__fastcall sub_62AB2E8(char *a1, long double *a2)
{
  long double v4; // q0
  __int128 v5; // q1
  _OWORD v7[2]; // [xsp+0h] [xbp-60h] BYREF
  _QWORD v8[4]; // [xsp+28h] [xbp-38h] BYREF
  unsigned __int64 *v9; // [xsp+48h] [xbp-18h] BYREF
  char v10; // [xsp+50h] [xbp-10h]

  v9 = v8;
  sub_628F4E0(v8, 8000000LL);
  v4 = *a2;
  v5 = *((_OWORD *)a2 + 1);
  v10 = 0;
  *(long double *)v7 = v4;
  v7[1] = v5;
  sub_62A9E34((__int64)&v9, (unsigned int (__fastcall *)(long double))sub_62AB260, a1, (int **)v7, v4);
  if ( v10 )
  {
    sub_628F4EC(v9);
    return 0LL;
  }
  else if ( sub_628F7CC(v9) )
  {
    return (char *)sub_628F7BC((__int64)v9);
  }
  else
  {
    return off_6C2D130(&byte_CBCB6C);
  }
}


================================================================================
Function: sub_62AB3BC (0x62AB3BC)
================================================================================

__int64 sub_62AB3BC(const char *a1, ...)
{
  gcc_va_list va1; // [xsp+C0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-28h] BYREF

  va_start(va, a1);
  va_copy(va1, va);
  return sub_62AB2E8(a1, va1);
}


================================================================================
Function: sub_62AB478 (0x62AB478)
================================================================================

__int64 sub_62AB478(__int64 a1, char *a2, ...)
{
  gcc_va_list va1; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-28h] BYREF

  va_start(va, a2);
  va_copy(va1, va);
  return sub_62A9E34(
           a1,
           (unsigned int (__fastcall *)(long double))sub_62AB458,
           a2,
           (int **)va1,
           *(long double *)&va[0].__stack);
}


================================================================================
Function: sub_62AB524 (0x62AB524)
================================================================================

__int64 sub_62AB524(char *a1, __int64 a2, __int64 a3, char *format, ...)
{
  gcc_va_list arg; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, format);
  va_copy(arg, va);
  return vsnprintf(a1, 0x146uLL, format, arg);
}


================================================================================
Function: sub_62AB5C4 (0x62AB5C4)
================================================================================

__int64 __fastcall sub_62AB5C4(__int64 a1, __int64 a2, __int64 a3)
{
  _DWORD *v6; // x0
  __int64 v7; // x19
  __int64 v8; // x0
  char v9; // w8
  _BYTE v11[24]; // [xsp+0h] [xbp-20h] BYREF

  v6 = (_DWORD *)off_6C2D138(1LL, 616LL);
  v7 = (__int64)v6;
  if ( v6 )
  {
    *v6 = 764702;
    sub_629A0C4((__int64)(v6 + 46), a3);
    sub_6298044(v7 + 272, a1, sub_62AEBD0, sub_62AEBE4, sub_62AEBF8);
    sub_6298044(v7 + 320, 23LL, sub_62985C0, sub_62985F8, nullsub_267);
    if ( (unsigned int)sub_628C19C((_QWORD *)(v7 + 368), (__int64)sub_62BDD44, v7, 0LL, a2) )
    {
      sub_6298630(v7 + 272, v11);
      while ( 1 )
      {
        v8 = sub_629863C(v11);
        if ( !v8 )
          break;
        sub_62983C0(*(_QWORD *)(v8 + 32));
      }
      sub_62983C0(v7 + 272);
      sub_62983C0(v7 + 320);
      sub_62983C0(v7 + 184);
      sub_628C24C(v7 + 368);
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v7);
      return 0LL;
    }
    else
    {
      sub_62A734C(v7 + 16, 0LL);
      sub_62A734C(v7 + 48, 0LL);
      sub_62A734C(v7 + 80, 0LL);
      sub_62A734C(v7 + 112, 0LL);
      v9 = *(_BYTE *)(v7 + 609) | 1;
      *(_DWORD *)(v7 + 600) = 100;
      *(_QWORD *)(v7 + 568) = -1LL;
      *(_BYTE *)(v7 + 609) = v9;
      if ( (sub_62B9A38(v7 + 592, 1LL) & 0x80000000) != 0 )
        *(_QWORD *)(v7 + 592) = -1LL;
    }
  }
  return v7;
}


================================================================================
Function: sub_62AB7A8 (0x62AB7A8)
================================================================================

__int64 sub_62AB7A8()
{
  return sub_62AB5C4(911LL, 97LL, 71LL);
}


================================================================================
Function: sub_62AB918 (0x62AB918)
================================================================================

__int64 __fastcall sub_62AB918(__int64 a1)
{
  __int64 v2; // x0
  __int64 v3; // x21
  __int64 v4; // x0
  __int64 **v5; // x23
  __int64 *v6; // x22
  __int64 v8; // x0
  __int64 v9; // x20
  _DWORD *v10; // x0
  __int64 v11; // x21
  __int64 v12; // x0
  char v13; // w8
  __int64 (__fastcall *v14)(); // x9
  __int64 v15; // x0
  char v16; // w8
  __int64 (__fastcall *v17)(); // x9
  _QWORD v18[3]; // [xsp+0h] [xbp-20h] BYREF

  if ( !a1 || *(_DWORD *)a1 != 764702 )
    return 1LL;
  if ( (*(_BYTE *)(a1 + 609) & 4) != 0 )
    return 8LL;
  *(_DWORD *)a1 = 0;
  v2 = sub_62A75F0(a1 + 112);
  if ( v2 )
  {
    v3 = v2;
    do
    {
      v4 = sub_62A7600(v3);
      if ( v4 )
      {
        v5 = (__int64 **)(v4 + 32);
        v6 = (__int64 *)v4;
        sub_62A74BC(v4 + 32);
        sub_62A73C8((__int64 *)(a1 + 48), v6, v5);
      }
      v3 = sub_62A7608(v3);
    }
    while ( v3 );
  }
  sub_62AC1B8(a1);
  v8 = sub_62A75F0(a1 + 48);
  if ( v8 )
  {
    v9 = v8;
    do
    {
      v10 = (_DWORD *)sub_62A7600(v9);
      if ( !v10 )
        return 1LL;
      v11 = (__int64)v10;
      if ( *v10 != -1059136595 )
        return 1LL;
      v9 = sub_62A7608(v9);
      if ( (*(_BYTE *)(v11 + 4693) & 4) == 0 && *(_QWORD *)(v11 + 24) )
        sub_62ABECC(v11, 0LL, 1LL);
      if ( *(_DWORD *)(v11 + 200) == 1 )
      {
        sub_629A0E0(v11, *(_QWORD *)(v11 + 192));
        *(_QWORD *)(v11 + 192) = 0LL;
        *(_DWORD *)(v11 + 200) = 0;
      }
      *(_QWORD *)(v11 + 208) = 0LL;
    }
    while ( v9 );
  }
  sub_628C24C(a1 + 368);
  sub_6298630(a1 + 272, v18);
  while ( 1 )
  {
    v12 = sub_629863C((__int64)v18);
    if ( !v12 )
      break;
    sub_62983C0(*(unsigned __int64 **)(v12 + 32));
  }
  sub_62983C0((unsigned __int64 *)(a1 + 272));
  sub_62983C0((unsigned __int64 *)(a1 + 320));
  sub_62983C0((unsigned __int64 *)(a1 + 184));
  close(*(_DWORD *)(a1 + 592));
  close(*(_DWORD *)(a1 + 596));
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 240));
  v13 = *(_BYTE *)(a1 + 609);
  *(_QWORD *)(a1 + 240) = 0LL;
  *(_QWORD *)(a1 + 248) = 0LL;
  v14 = off_6C2D120[0];
  v15 = *(_QWORD *)(a1 + 256);
  *(_BYTE *)(a1 + 609) = v13 & 0xDF;
  ((void (__fastcall *)(__int64))v14)(v15);
  v16 = *(_BYTE *)(a1 + 609);
  v17 = off_6C2D120[0];
  *(_QWORD *)(a1 + 256) = 0LL;
  *(_QWORD *)(a1 + 264) = 0LL;
  *(_BYTE *)(a1 + 609) = v16 & 0xBF;
  ((void (__fastcall *)(__int64))v17)(a1);
  return 0LL;
}


================================================================================
Function: sub_62ABB40 (0x62ABB40)
================================================================================

__int64 __fastcall sub_62ABB40(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v6; // x1
  _QWORD v8[2]; // [xsp+8h] [xbp-18h] BYREF

  v8[0] = sub_62BBCF8();
  v8[1] = v6;
  return sub_62AE698(a1, v8, a2, a3);
}


================================================================================
Function: sub_62ABBB4 (0x62ABBB4)
================================================================================

__int64 __fastcall sub_62ABBB4(__int64 a1)
{
  __int64 v2; // x20
  __int64 v3; // x8
  __int64 result; // x0
  char v5; // w8
  __int128 v6; // q0
  __int64 (__fastcall *v7)(__int64, __int64, __int64); // x9
  __int64 v8; // x2
  int v9; // w0
  char v10; // w8
  __int64 v11; // [xsp+0h] [xbp-20h] BYREF
  __int128 v12; // [xsp+8h] [xbp-18h] BYREF

  if ( !*(_QWORD *)(a1 + 552) || (*(_BYTE *)(a1 + 609) & 0x10) != 0 )
    return 0LL;
  sub_62AE5CC(a1, &v12, &v11);
  v2 = v11;
  v3 = *(_QWORD *)(a1 + 568);
  if ( v11 < 0 )
  {
    if ( v3 < 0 )
      return 0LL;
    v2 = -1LL;
    v11 = -1LL;
LABEL_9:
    v5 = *(_BYTE *)(a1 + 609);
    v6 = v12;
    v7 = *(__int64 (__fastcall **)(__int64, __int64, __int64))(a1 + 552);
    *(_QWORD *)(a1 + 568) = v2;
    v8 = *(_QWORD *)(a1 + 560);
    *(_OWORD *)(a1 + 576) = v6;
    *(_BYTE *)(a1 + 609) = v5 | 4;
    v9 = v7(a1, v2, v8);
    v10 = *(_BYTE *)(a1 + 609) & 0xFB;
    *(_BYTE *)(a1 + 609) = v10;
    if ( v9 == -1 )
    {
      result = 11LL;
      *(_BYTE *)(a1 + 609) = v10 | 0x10;
      return result;
    }
    return 0LL;
  }
  if ( v3 < 0 )
    goto LABEL_9;
  result = sub_62BBE7C(*(_QWORD *)(a1 + 576), *(_QWORD *)(a1 + 584), v12, *((_QWORD *)&v12 + 1));
  if ( result )
    goto LABEL_9;
  return result;
}


================================================================================
Function: sub_62ABCAC (0x62ABCAC)
================================================================================

__int64 __fastcall sub_62ABCAC(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  __int64 result; // x0
  unsigned int v6; // w21
  __int64 v7; // x0
  char v8; // w21
  __int64 v9; // x1
  __int64 v10; // x0
  __int64 v11; // x22
  __int64 v12; // [xsp+0h] [xbp-10h] BYREF

  if ( !a1 || *(_DWORD *)a1 != 764702 )
    return 1LL;
  if ( !a2 || *(_DWORD *)a2 != -1059136595 || !*(_DWORD *)(a1 + 4) )
    return 2LL;
  v4 = *(_QWORD *)(a2 + 208);
  if ( !v4 )
    return 0LL;
  if ( v4 != a1 )
    return 2LL;
  if ( (*(_BYTE *)(a1 + 609) & 4) != 0 )
    return 8LL;
  v6 = *(_DWORD *)(a2 + 96);
  if ( v6 <= 0xF )
    --*(_DWORD *)(a1 + 8);
  v7 = *(_QWORD *)(a2 + 24);
  if ( v7 )
  {
    if ( v6 - 10 > 5 || (sub_628A13C(v7, 2), *(_QWORD *)(a2 + 24)) )
      sub_62ABECC(a2, *(unsigned int *)(a2 + 100), v6 < 0x10);
  }
  v8 = sub_62AC040(a2);
  sub_62A74BC(a2 + 32);
  if ( *(_DWORD *)(a2 + 200) == 1 )
  {
    *(_QWORD *)(a2 + 192) = 0LL;
    *(_DWORD *)(a2 + 200) = 0;
  }
  *(_DWORD *)(a2 + 96) = 16;
  sub_62AC0E4(a1, a2);
  sub_62AC16C(a2);
  if ( *(_BYTE *)(a2 + 2457) && !*(_QWORD *)(a2 + 216) && (unsigned int)sub_628A0E0(a2, &v12) != -1 && v12 )
    sub_628CA0C(a2, v12, 1LL);
  v9 = *(_QWORD *)(a2 + 2912);
  if ( v9 != -1 )
    sub_628DD10(a2, v9, sub_62AC1A4, 0LL);
  v10 = sub_62A75F0(a1 + 16);
  if ( v10 )
  {
    v11 = v10;
    while ( *(_QWORD *)(sub_62A7600(v11) + 40) != a2 )
    {
      v11 = sub_62A7608(v11);
      if ( !v11 )
        goto LABEL_34;
    }
    sub_62A74BC(v11);
  }
LABEL_34:
  *(_QWORD *)(a2 + 208) = 0LL;
  *(_QWORD *)(a2 + 16) = -1LL;
  --*(_DWORD *)(a1 + 4);
  sub_62AC1B8(a1);
  if ( (v8 & 1) == 0 )
    return 0LL;
  result = sub_62ABBB4(a1);
  if ( !(_DWORD)result )
    return 0LL;
  return result;
}


================================================================================
Function: sub_62ABECC (0x62ABECC)
================================================================================

__int64 __fastcall sub_62ABECC(__int64 a1, unsigned int a2, char a3)
{
  unsigned int v3; // w22
  char v4; // w8
  __int64 v5; // x24
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(__int64, _QWORD, _QWORD); // x8
  bool v11; // zf
  unsigned int v12; // w20
  unsigned int v13; // w0
  bool v14; // zf
  __int64 v15; // x1
  int v17; // [xsp+4h] [xbp-Ch] BYREF

  v3 = 0;
  v4 = *(_BYTE *)(a1 + 4693);
  v17 = 0;
  v5 = *(_QWORD *)(a1 + 24);
  if ( (v4 & 4) == 0 )
  {
    sub_628E114();
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 424));
    v9 = off_6C2D120[0];
    *(_QWORD *)(a1 + 424) = 0LL;
    ((void (__fastcall *)(_QWORD))v9)(*(_QWORD *)(a1 + 416));
    *(_QWORD *)(a1 + 416) = 0LL;
    if ( a2 <= 0x2A && ((1LL << a2) & 0x40004800000LL) != 0 )
      a3 = 1;
    v10 = *(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)(v5 + 928) + 24LL);
    if ( v10 )
      a2 = v10(a1, a2, a3 & 1);
    v3 = 42;
    if ( a2 != 42 )
    {
      if ( (unsigned int)sub_62AFB18(a1) )
        v11 = a2 == 0;
      else
        v11 = 0;
      if ( v11 )
        v3 = 42;
      else
        v3 = a2;
    }
    v12 = a3 & 1;
    v13 = sub_62BD350(a1, v12);
    if ( v3 )
      v14 = 1;
    else
      v14 = v13 == 0;
    if ( !v14 )
      v3 = v13;
    sub_62897C4(a1, v12);
    sub_62AC1B8(*(_QWORD *)(a1 + 208));
    if ( !v3 )
      v3 = sub_62B0B64(a1 + 232, a1, v12);
    v15 = *(_QWORD *)(a1 + 24);
    LOBYTE(v17) = v12;
    sub_628DE8C(a1, v15, sub_62AECD4, &v17);
  }
  return v3;
}


================================================================================
Function: sub_62AC040 (0x62AC040)
================================================================================

__int64 __fastcall sub_62AC040(__int64 a1)
{
  __int64 v1; // x2
  unsigned int v3; // w0
  __int64 v4; // x3
  __int64 v5; // x4
  __int64 v6; // x5
  __int64 v7; // x6
  __int64 v8; // x7
  __int64 v9; // x8
  __int64 result; // x0
  __int64 vars0; // [xsp+0h] [xbp+0h]

  v1 = *(_QWORD *)(a1 + 208);
  if ( !v1 || !*(_QWORD *)(a1 + 3280) && !*(_DWORD *)(a1 + 3288) )
    return 0LL;
  v3 = sub_62BB648(*(_QWORD *)(v1 + 232), a1 + 3296, v1 + 232);
  if ( v3 )
  {
    if ( (*(_DWORD *)(a1 + 2458) & 0x100000) != 0 )
    {
      v9 = *(_QWORD *)(a1 + 4576);
      if ( !v9 || *(int *)(v9 + 8) >= 1 )
        sub_628595C(a1, "Internal error clearing splay node = %d", v3, v4, v5, v6, v7, v8, vars0);
    }
  }
  sub_62A7538(a1 + 3352, 0LL);
  result = 1LL;
  *(_QWORD *)(a1 + 3280) = 0LL;
  *(_DWORD *)(a1 + 3288) = 0;
  return result;
}


================================================================================
Function: sub_62AC0E4 (0x62AC0E4)
================================================================================

long double __fastcall sub_62AC0E4(__int64 a1, __int64 a2)
{
  long double result; // q0
  __int128 v5; // q1
  _OWORD v6[2]; // [xsp+8h] [xbp-28h] BYREF

  sub_62AC2D8(a2, v6);
  if ( !(unsigned int)sub_62ADBC8(a1, a2, v6, (unsigned int *)(a2 + 160)) )
  {
    result = *(long double *)v6;
    v5 = v6[1];
    *(_OWORD *)(a2 + 160) = v6[0];
    *(_OWORD *)(a2 + 176) = v5;
  }
  return result;
}


================================================================================
Function: sub_62AC16C (0x62AC16C)
================================================================================

__int64 __fastcall sub_62AC16C(__int64 a1)
{
  __int64 result; // x0

  result = *(_QWORD *)(a1 + 24);
  if ( result )
  {
    sub_628950C(result, a1);
    result = sub_62A74BC(a1 + 64);
  }
  *(_QWORD *)(a1 + 24) = 0LL;
  return result;
}


================================================================================
Function: sub_62AC1B8 (0x62AC1B8)
================================================================================

__int64 __fastcall sub_62AC1B8(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x0
  __int64 **v4; // x21
  __int64 v5; // x19
  __int64 v6; // x1
  __int128 v7; // [xsp+8h] [xbp-18h] BYREF

  result = sub_62A75F0(a1 + 80);
  if ( result )
  {
    v3 = sub_62A7600(result);
    v4 = (__int64 **)(v3 + 32);
    v5 = v3;
    sub_62A74BC(v3 + 32);
    sub_62A73C8((__int64 *)(a1 + 48), (__int64 *)v5, v4);
    if ( *(_DWORD *)(v5 + 96) != 3 )
    {
      *(_DWORD *)(v5 + 96) = 3;
      sub_62BC5A8(v5);
    }
    *(_QWORD *)&v7 = sub_62BBCF8();
    *((_QWORD *)&v7 + 1) = v6;
    return sub_62AE698(v5, &v7, 0LL, 8u);
  }
  return result;
}


================================================================================
Function: sub_62AC280 (0x62AC280)
================================================================================

__int64 __fastcall sub_62AC280(__int64 a1, __int64 a2)
{
  __int64 v4; // x8
  void (__fastcall *v5)(__int64, __int64); // x8

  *(_QWORD *)(a1 + 24) = a2;
  sub_62A73C8(a2 + 968, a1, a1 + 64);
  v4 = *(_QWORD *)(a2 + 928);
  if ( v4 )
  {
    v5 = *(void (__fastcall **)(__int64, __int64))(v4 + 128);
    if ( v5 )
      v5(a1, a2);
  }
  return sub_6289464(a2, a1);
}


================================================================================
Function: sub_62AC2D8 (0x62AC2D8)
================================================================================

__int64 __fastcall sub_62AC2D8(
        size_t a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 result; // x0
  __int64 (__fastcall *v12)(); // x2
  __int64 v13; // x2
  __int64 v14; // x3
  __int64 v15; // x4
  __int64 v16; // x5
  __int64 v17; // x6
  __int64 v18; // x7
  __int64 v19; // x8

  result = sub_6289A28();
  if ( *(_QWORD *)(a1 + 24) )
  {
    v12 = sub_62AEE68;
    switch ( *(_DWORD *)(a1 + 96) )
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
        return result;
      case 4:
        return sub_6289B14(a1, a2, sub_629A6AC);
      case 5:
      case 6:
        goto LABEL_9;
      case 7:
      case 8:
        v12 = sub_62AEEB0;
        goto LABEL_9;
      case 9:
      case 0xA:
        v12 = sub_62AEF18;
        goto LABEL_9;
      case 0xB:
        v12 = sub_62AEF58;
        goto LABEL_9;
      case 0xC:
      case 0xD:
        v12 = sub_62AEF98;
LABEL_9:
        sub_6289B14(a1, a2, v12);
        result = sub_62891A4(a1, a2);
        if ( !*(_DWORD *)(a2 + 20) && (*(_BYTE *)(a1 + 312) & 0x30) == 0 )
        {
          result = sub_6288F90(a1, 0LL);
          if ( (result & 1) != 0 && (*(_DWORD *)(a1 + 2458) & 0x100000) != 0 )
          {
            v19 = *(_QWORD *)(a1 + 4576);
            if ( !v19 || *(int *)(v19 + 8) >= 1 )
              result = sub_628595C(
                         a1,
                         "WARNING: no socket in pollset, transfer may stall!",
                         v13,
                         v14,
                         v15,
                         v16,
                         v17,
                         v18,
                         a9);
          }
        }
        break;
      default:
        result = sub_6285834(a1, (__int64)"multi_getsock: unexpected multi state %d", (unsigned int)sub_62AEE68);
        break;
    }
  }
  return result;
}


================================================================================
Function: sub_62ADBC8 (0x62ADBC8)
================================================================================

__int64 __fastcall sub_62ADBC8(__int64 a1, __int64 a2, _DWORD *a3, unsigned int *a4)
{
  __int64 v7; // x22
  unsigned __int64 v8; // x8
  __int64 v9; // x23
  unsigned int v10; // w26
  int v11; // w28
  __int64 v12; // x0
  __int64 v13; // x27
  __int64 v14; // x8
  __int64 v15; // x9
  _QWORD *v16; // x0
  int v17; // w8
  char v18; // w8
  unsigned int v19; // w28
  __int64 (__fastcall *v20)(__int64, _QWORD, _QWORD, __int64, _QWORD); // x8
  __int64 v21; // x0
  __int64 v22; // x3
  int v23; // w0
  char v24; // w8
  __int64 v25; // x26
  unsigned int v26; // w23
  _DWORD *v27; // x9
  __int64 v28; // x0
  unsigned __int64 *v29; // x24
  char v30; // w9
  int v31; // w8
  unsigned int *v32; // x1
  __int64 v33; // x2
  __int64 (__fastcall *v34)(__int64, _QWORD, __int64, __int64, unsigned __int64); // x8
  __int64 v35; // x0
  __int64 v36; // x3
  int v37; // w0
  char v38; // w8
  int v39; // w25
  __int64 result; // x0
  __int64 v41; // [xsp+8h] [xbp-18h] BYREF
  int v42; // [xsp+10h] [xbp-10h] BYREF
  unsigned int v43; // [xsp+14h] [xbp-Ch] BYREF

  v7 = a1 + 272;
  LODWORD(v8) = a3[5];
  v41 = a2;
  if ( !(_DWORD)v8 )
  {
LABEL_41:
    if ( a4[5] )
    {
      v25 = 0LL;
      v26 = *a4;
      if ( (_DWORD)v8 )
        goto LABEL_43;
LABEL_46:
      v43 = v26;
      if ( v26 != -1 )
      {
        v28 = sub_6298318(v7, &v43, 4LL);
        if ( v28 )
        {
          v29 = (unsigned __int64 *)v28;
          v30 = *((_BYTE *)a4 + v25 + 24);
          v31 = *(_DWORD *)(v28 + 52) - 1;
          *(_DWORD *)(v28 + 52) = v31;
          if ( (v30 & 2) != 0 )
          {
            --*(_DWORD *)(v28 + 68);
            if ( (v30 & 1) == 0 )
            {
LABEL_50:
              if ( v31 )
              {
LABEL_51:
                v32 = (unsigned int *)&v41;
                v33 = 8LL;
                goto LABEL_52;
              }
LABEL_55:
              v34 = *(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, unsigned __int64))(a1 + 152);
              if ( v34 )
              {
                v35 = v41;
                v36 = *(_QWORD *)(a1 + 160);
                *(_BYTE *)(a1 + 609) |= 4u;
                v37 = v34(v35, v26, 4LL, v36, v29[7]);
                v38 = *(_BYTE *)(a1 + 609);
                v39 = v37;
                v43 = v26;
                *(_BYTE *)(a1 + 609) = v38 & 0xFB;
                sub_62983C0(v29);
                sub_6298264(v7, &v43, 4LL);
                if ( v39 != -1 )
                  goto LABEL_57;
                result = 11LL;
                *(_BYTE *)(a1 + 609) |= 0x10u;
                return result;
              }
              v43 = v26;
              sub_62983C0((unsigned __int64 *)v28);
              v32 = &v43;
              v28 = v7;
              v33 = 4LL;
LABEL_52:
              sub_6298264(v28, v32, v33);
              goto LABEL_57;
            }
          }
          else if ( (v30 & 1) == 0 )
          {
            goto LABEL_50;
          }
          --*(_DWORD *)(v28 + 64);
          if ( v31 )
            goto LABEL_51;
          goto LABEL_55;
        }
      }
LABEL_57:
      while ( ++v25 < (unsigned __int64)a4[5] )
      {
        LODWORD(v8) = a3[5];
        v26 = a4[v25];
        if ( !(_DWORD)v8 )
          goto LABEL_46;
LABEL_43:
        v8 = (unsigned int)v8;
        v27 = a3;
        while ( v26 != *v27 )
        {
          ++v27;
          if ( !--v8 )
            goto LABEL_46;
        }
      }
    }
    return 0LL;
  }
  v9 = 0LL;
  while ( 1 )
  {
    v11 = *((unsigned __int8 *)a3 + v9 + 24);
    v43 = a3[v9];
    v10 = v43;
    if ( v43 == -1 )
    {
      v42 = -1;
      goto LABEL_13;
    }
    v12 = sub_6298318(v7, &v43, 4LL);
    if ( !v12 )
      break;
    v13 = v12;
    v14 = a4[5];
    if ( !(_DWORD)v14 )
      goto LABEL_25;
    v15 = 0LL;
    while ( v10 != a4[v15] )
    {
      if ( v14 == ++v15 )
        goto LABEL_25;
    }
    v17 = *((unsigned __int8 *)a4 + v15 + 24);
    if ( !*((_BYTE *)a4 + v15 + 24) )
      goto LABEL_25;
    if ( v17 != v11 )
    {
      if ( (v17 & 1) != 0 )
      {
        --*(_DWORD *)(v12 + 64);
        if ( (v17 & 2) == 0 )
          goto LABEL_22;
      }
      else if ( (v17 & 2) == 0 )
      {
LABEL_22:
        if ( (v11 & 1) != 0 )
          goto LABEL_39;
LABEL_23:
        if ( (v11 & 2) != 0 )
          goto LABEL_40;
        goto LABEL_24;
      }
      --*(_DWORD *)(v12 + 68);
      if ( (v11 & 1) != 0 )
      {
LABEL_39:
        ++*(_DWORD *)(v12 + 64);
        if ( (v11 & 2) != 0 )
        {
LABEL_40:
          v18 = 0;
          ++*(_DWORD *)(v12 + 68);
          goto LABEL_32;
        }
        goto LABEL_24;
      }
      goto LABEL_23;
    }
LABEL_24:
    v18 = 0;
LABEL_32:
    v19 = (*(_DWORD *)(v13 + 64) != 0) | (2 * (*(_DWORD *)(v13 + 68) != 0));
    if ( (v18 & 1) != 0 || *(_DWORD *)(v13 + 48) != v19 )
    {
      v20 = *(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, __int64, _QWORD))(a1 + 152);
      if ( v20 )
      {
        v21 = v41;
        v22 = *(_QWORD *)(a1 + 160);
        *(_BYTE *)(a1 + 609) |= 4u;
        v23 = v20(v21, v10, v19, v22, *(_QWORD *)(v13 + 56));
        v24 = *(_BYTE *)(a1 + 609) & 0xFB;
        *(_BYTE *)(a1 + 609) = v24;
        if ( v23 == -1 )
        {
          result = 11LL;
          *(_BYTE *)(a1 + 609) = v24 | 0x10;
          return result;
        }
      }
      *(_DWORD *)(v13 + 48) = v19;
    }
    v8 = (unsigned int)a3[5];
    if ( ++v9 >= v8 )
      goto LABEL_41;
  }
  v42 = v10;
  v43 = v10;
  v13 = sub_6298318(v7, &v43, 4LL);
  if ( v13 )
    goto LABEL_25;
LABEL_13:
  v16 = (_QWORD *)off_6C2D138(1LL, 72LL);
  if ( !v16 )
    return 3LL;
  v13 = (__int64)v16;
  sub_6298044(v16, 13LL, (__int64)sub_62AF068, (__int64)sub_62AF078, (__int64)nullsub_1367);
  if ( !sub_629825C(v7, &v42, 4LL, v13) )
  {
    sub_62983C0((unsigned __int64 *)v13);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v13);
    return 3LL;
  }
LABEL_25:
  if ( sub_6298318(v13, &v41, 8LL) )
    goto LABEL_31;
  ++*(_DWORD *)(v13 + 52);
  if ( (v11 & 1) != 0 )
    ++*(_DWORD *)(v13 + 64);
  if ( (v11 & 2) != 0 )
    ++*(_DWORD *)(v13 + 68);
  if ( sub_629825C(v13, &v41, 8LL, v41) )
  {
LABEL_31:
    v18 = 1;
    goto LABEL_32;
  }
  sub_62983C0((unsigned __int64 *)v13);
  return 3LL;
}


================================================================================
Function: sub_62AE038 (0x62AE038)
================================================================================

unsigned __int64 *__fastcall sub_62AE038(unsigned __int64 *result, unsigned int a2)
{
  unsigned __int64 *v2; // x21
  unsigned __int64 v3; // x24
  unsigned __int64 *v5; // x22
  __int64 (__fastcall *v6)(unsigned __int64 *, _QWORD, __int64, __int64, unsigned __int64); // x8
  __int64 v7; // x3
  int v8; // w0
  char v9; // w8
  int v10; // w21
  unsigned int v11; // [xsp+4h] [xbp-Ch] BYREF

  if ( result )
  {
    v2 = result;
    v3 = result[26];
    if ( v3 )
    {
      v11 = a2;
      if ( a2 != -1 )
      {
        result = (unsigned __int64 *)sub_6298318((__int64 *)(v3 + 272), (__int64)&v11, 4LL);
        if ( result )
        {
          v5 = result;
          v6 = *(__int64 (__fastcall **)(unsigned __int64 *, _QWORD, __int64, __int64, unsigned __int64))(v3 + 152);
          if ( v6 )
          {
            v7 = *(_QWORD *)(v3 + 160);
            *(_BYTE *)(v3 + 609) |= 4u;
            v8 = v6(v2, a2, 4LL, v7, result[7]);
            v9 = *(_BYTE *)(v3 + 609);
            v10 = v8;
            v11 = a2;
            *(_BYTE *)(v3 + 609) = v9 & 0xFB;
            sub_62983C0(v5);
            result = (unsigned __int64 *)sub_6298264((__int64 *)(v3 + 272), (__int64)&v11, 4LL);
            if ( v10 == -1 )
              *(_BYTE *)(v3 + 609) |= 0x10u;
          }
          else
          {
            v11 = a2;
            sub_62983C0(result);
            return (unsigned __int64 *)sub_6298264((__int64 *)(v3 + 272), (__int64)&v11, 4LL);
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62AE5CC (0x62AE5CC)
================================================================================

__int64 __fastcall sub_62AE5CC(__int64 a1, __int64 a2, __int64 *a3)
{
  __time_t v6; // x21
  __int64 v7; // x1
  __int64 v8; // x22
  __int64 v9; // x0
  __int64 v10; // x8
  __int64 result; // x0

  if ( (*(_BYTE *)(a1 + 609) & 0x10) != 0 )
    goto LABEL_10;
  if ( *(_QWORD *)(a1 + 232) )
  {
    v6 = sub_62BBCF8();
    v8 = v7;
    v9 = sub_62BB370(0LL, 0LL, *(_QWORD *)(a1 + 232));
    *(_QWORD *)(a1 + 232) = v9;
    if ( v9 )
    {
      *(_OWORD *)a2 = *(_OWORD *)(v9 + 32);
      v10 = *(_QWORD *)(a1 + 232);
      if ( !v10 )
        goto LABEL_10;
    }
    else
    {
      *(_QWORD *)a2 = 0LL;
      *(_QWORD *)(a2 + 8) = 0LL;
      v10 = *(_QWORD *)(a1 + 232);
      if ( !v10 )
        goto LABEL_10;
    }
    if ( sub_62BBE7C(*(_QWORD *)(v10 + 32), *(_QWORD *)(v10 + 40), v6, v8) >= 1 )
    {
      result = sub_62BBE08(*(_QWORD *)(*(_QWORD *)(a1 + 232) + 32LL), *(_QWORD *)(*(_QWORD *)(a1 + 232) + 40LL), v6, v8);
      goto LABEL_11;
    }
LABEL_10:
    result = 0LL;
    goto LABEL_11;
  }
  result = -1LL;
  *(_QWORD *)a2 = 0LL;
  *(_QWORD *)(a2 + 8) = 0LL;
LABEL_11:
  *a3 = result;
  return result;
}


================================================================================
Function: sub_62AE698 (0x62AE698)
================================================================================

__int64 __fastcall sub_62AE698(__int64 result, __int128 *a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // x26
  __int64 v6; // x19
  __int64 v7; // x20
  int v8; // w8
  __int64 v9; // x0
  __int64 v10; // x23
  __int64 *v11; // x27
  __int64 v12; // x8
  __int64 *v13; // x28
  __int64 v14; // x23
  __int64 v15; // x0
  __int64 v16; // x24
  _QWORD *v17; // x25
  __int64 v18; // x0
  __int64 v19; // x22
  unsigned int v20; // w0
  __int64 v21; // x3
  __int64 v22; // x4
  __int64 v23; // x5
  __int64 v24; // x6
  __int64 v25; // x7
  __int64 v26; // x8
  __int64 v27; // x0
  __int64 v28; // x0
  __int128 v29; // [xsp+0h] [xbp-20h]

  v4 = *(_QWORD *)(result + 208);
  if ( v4 )
  {
    v6 = result;
    v29 = *a2;
    v7 = *(_QWORD *)a2 + a3 / 1000;
    *(_QWORD *)&v29 = v7;
    v8 = *((_QWORD *)a2 + 1) + 1000 * (a3 % 1000);
    DWORD2(v29) = v8;
    if ( v8 >= 1000000 )
    {
      *(_QWORD *)&v29 = ++v7;
      DWORD2(v29) = v8 - 1000000;
    }
    v9 = sub_62A75F0(result + 3352);
    if ( v9 )
    {
      v10 = v9;
      while ( *(_DWORD *)(sub_62A7600(v10) + 48) != a4 )
      {
        v10 = sub_62A7608(v10);
        if ( !v10 )
          goto LABEL_10;
      }
      sub_62A74BC(v10);
    }
LABEL_10:
    v11 = (__int64 *)(v6 + 3280);
    v12 = v6 + 56LL * a4;
    v13 = (__int64 *)(v12 + 3416);
    v14 = v12 + 3384;
    *(_DWORD *)(v12 + 3432) = a4;
    *(_OWORD *)(v12 + 3416) = v29;
    if ( sub_62A75F8(v6 + 3352)
      && (v15 = sub_62A75F0(v6 + 3352)) != 0
      && (v16 = v15,
          v17 = (_QWORD *)(v6 + 56LL * a4 + 3424),
          v18 = sub_62A7600(v15),
          sub_62BBD98(*(_QWORD *)(v18 + 32), *(_QWORD *)(v18 + 40), *v13, *v17) <= 0) )
    {
      do
      {
        v19 = v16;
        v28 = sub_62A7608(v16);
        if ( !v28 )
          break;
        v16 = v28;
        v27 = sub_62A7600(v28);
      }
      while ( sub_62BBD98(*(_QWORD *)(v27 + 32), *(_QWORD *)(v27 + 40), *v13, *v17) <= 0 );
    }
    else
    {
      v19 = 0LL;
    }
    sub_62A7358(v6 + 3352, v19, v14, v14);
    if ( *v11 || *(_DWORD *)(v6 + 3288) )
    {
      result = sub_62BBD98(v7, SDWORD2(v29), *v11, *(_QWORD *)(v6 + 3288));
      if ( result > 0 )
        return result;
      v20 = sub_62BB648(*(_QWORD *)(v4 + 232), v6 + 3296, v4 + 232);
      if ( v20 )
      {
        if ( (*(_DWORD *)(v6 + 2458) & 0x100000) != 0 )
        {
          v26 = *(_QWORD *)(v6 + 4576);
          if ( !v26 || *(int *)(v26 + 8) >= 1 )
            sub_628595C(v6, "Internal error removing splay node = %d", v20, v21, v22, v23, v24, v25, v29);
        }
      }
    }
    *(_OWORD *)v11 = v29;
    sub_62BB738(v6 + 3296, v6);
    result = sub_62BB4C4(*(_QWORD *)(v6 + 3280), *(_QWORD *)(v6 + 3288), *(_QWORD *)(v4 + 232), v6 + 3296);
    *(_QWORD *)(v4 + 232) = result;
  }
  return result;
}


================================================================================
Function: sub_62AE97C (0x62AE97C)
================================================================================

__int64 __fastcall sub_62AE97C(__int64 result, char a2)
{
  __int64 v2; // x8
  char v3; // w10

  if ( result )
  {
    v2 = *(_QWORD *)(result + 208);
    if ( v2 )
    {
      if ( (a2 & 1) != 0 )
        v3 = 4;
      else
        v3 = 0;
      *(_BYTE *)(v2 + 609) = *(_BYTE *)(v2 + 609) & 0xFB | v3;
    }
  }
  return result;
}


================================================================================
Function: sub_62AE9A8 (0x62AE9A8)
================================================================================

__int64 __fastcall sub_62AE9A8(__int64 result)
{
  __int64 v1; // x8

  if ( result )
  {
    v1 = *(_QWORD *)(result + 208);
    if ( v1 )
      return (*(unsigned __int8 *)(v1 + 609) >> 2) & 1;
    else
      return 0LL;
  }
  return result;
}


================================================================================
Function: sub_62AEB00 (0x62AEB00)
================================================================================

__int64 __fastcall sub_62AEB00(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 v5; // x21
  __int64 result; // x0
  __int64 v7; // x0
  __int64 v8; // x21
  __int64 v9; // x20

  if ( a2 < 0 )
    return 0LL;
  v4 = sub_62A75F0(a1 + 48);
  if ( v4 )
  {
    v5 = v4;
    while ( 1 )
    {
      result = sub_62A7600(v5);
      if ( *(_QWORD *)(result + 16) == a2 )
        break;
      v5 = sub_62A7608(v5);
      if ( !v5 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v7 = sub_62A75F0(a1 + 112);
    if ( v7 )
    {
      v8 = v7;
      while ( 1 )
      {
        result = sub_62A7600(v8);
        if ( *(_QWORD *)(result + 16) == a2 )
          break;
        v8 = sub_62A7608(v8);
        if ( !v8 )
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      result = sub_62A75F0(a1 + 80);
      if ( result )
      {
        v9 = result;
        do
        {
          result = sub_62A7600(v9);
          if ( *(_QWORD *)(result + 16) == a2 )
            break;
          result = sub_62A7608(v9);
          v9 = result;
        }
        while ( result );
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62AF0A4 (0x62AF0A4)
================================================================================

__int64 __fastcall sub_62AF0A4(int a1, int a2)
{
  int v4; // w0

  v4 = fcntl(a1, 3, 0LL);
  if ( v4 < 0 )
    return 0xFFFFFFFFLL;
  if ( (a2 != 0) != ((v4 & 0x800) == 0) )
    return 0LL;
  return fcntl(a1, 4, v4 & 0xFFFFF7FF | ((a2 != 0) << 11));
}


================================================================================
Function: sub_62AF11C (0x62AF11C)
================================================================================

__int64 __fastcall sub_62AF11C(__int64 a1, _QWORD *a2)
{
  unsigned int v2; // w8
  unsigned int v3; // w21
  int v4; // w28
  signed int v5; // w23
  int v6; // w24
  int v7; // w22
  unsigned __int64 v8; // x20
  unsigned int v9; // t1
  unsigned int v10; // w9
  bool v12; // cf
  unsigned __int64 v14; // x26
  unsigned __int64 v15; // x8
  int v16; // w19
  unsigned int v17; // w8
  unsigned int v18; // w10
  _BYTE *v19; // x11
  int v20; // w9
  unsigned int v21; // w10
  char *v22; // x8
  int v23; // w12
  unsigned int v24; // w11
  int v25; // w13
  int *v26; // x26
  int v27; // w25
  __int64 v28; // x0
  int v29; // w8
  int v30; // w9
  int v31; // w14
  int v32; // w13
  int v33; // w10
  int v34; // w9
  char **v35; // x28
  const char *v36; // x25
  const char *v37; // x25
  int v38; // w9
  int v39; // w9
  const char *v40; // x25
  const char *v41; // x25
  const char *v42; // x25
  const char *v43; // x25
  const char *v44; // x25
  __int64 result; // x0
  __int64 v46; // x28
  int v47; // w8
  int v48; // w10
  int v49; // w9
  __int64 v50; // x9
  int v51; // w10
  unsigned __int64 v52; // [xsp+8h] [xbp-38h]
  int v54; // [xsp+1Ch] [xbp-24h]
  int v55; // [xsp+20h] [xbp-20h]
  _BOOL4 v56; // [xsp+24h] [xbp-1Ch]
  int v57; // [xsp+28h] [xbp-18h]
  int v58; // [xsp+2Ch] [xbp-14h]
  char *endptr; // [xsp+30h] [xbp-10h] BYREF

  v2 = *(unsigned __int8 *)a1;
  if ( !*(_BYTE *)a1 )
  {
    v7 = -1;
    v6 = -1;
    v5 = -1;
    v54 = -1;
    v55 = -1;
    v57 = -1;
    v58 = -1;
LABEL_151:
    v47 = v57;
    result = 0xFFFFFFFFLL;
    if ( v57 == -1 )
      v48 = 0;
    else
      v48 = v55;
    v49 = v54;
    if ( v57 == -1 )
    {
      v47 = 0;
      v49 = 0;
    }
    if ( v6 != -1 && v5 != -1 && v7 > 1582 )
    {
      result = 0xFFFFFFFFLL;
      if ( v6 <= 31 && v5 <= 11 )
      {
        result = 0LL;
        v50 = 60
            * (24
             * (v6
              + 365LL * (v7 - 1970)
              + (int)(((v7 - (unsigned int)(v5 < 2)) >> 2)
                    - (v7 - (unsigned int)(v5 < 2)) / 0x64
                    + (v7 - (unsigned int)(v5 < 2)) / 0x190
                    - 477)
              + dword_16AA0B0[v5])
             + v48)
            + v49;
        if ( v58 == -1 )
          v51 = 0;
        else
          v51 = v58;
        *a2 = v51 + (__int64)v47 + 60 * (v50 - 1440);
      }
    }
    return result;
  }
  v3 = 0;
  v4 = -1;
  v5 = -1;
  v58 = -1;
  v6 = -1;
  v7 = -1;
  v8 = a1;
  v56 = 0;
  v57 = -1;
  v52 = a1;
  v54 = -1;
  v55 = -1;
  while ( 2 )
  {
    if ( v2 - 97 >= 0x1A && v2 - 48 >= 0xA && v2 - 65 >= 0x1A )
    {
      do
      {
        v9 = *(unsigned __int8 *)++v8;
        v2 = v9;
        v10 = v9 - 48;
        v12 = v9 - 97 >= 0x1A && v2 != 0 && v10 >= 0xA;
      }
      while ( v12 && v2 - 65 > 0x19 );
    }
    if ( (v2 & 0xDF) - 65 > 0x19 )
    {
      v17 = v2 - 48;
      if ( v17 > 9 )
        goto LABEL_144;
      if ( v57 != -1 )
        goto LABEL_49;
      v18 = *(unsigned __int8 *)(v8 + 1) - 48;
      v19 = (_BYTE *)(v18 >= 0xA ? v8 + 1 : v8 + 2);
      v20 = v18 >= 0xA ? v17 : v18 + 10 * v17;
      if ( v20 > 23 )
        goto LABEL_49;
      if ( *v19 != 58 )
        goto LABEL_49;
      v21 = (unsigned __int8)v19[1] - 48;
      if ( v21 > 9 )
        goto LABEL_49;
      v22 = v19 + 2;
      v23 = (unsigned __int8)v19[2];
      if ( (unsigned int)(v23 - 48) <= 9 )
      {
        v21 = v23 + 10 * v21 - 48;
        if ( v21 > 0x3B )
          goto LABEL_49;
        v22 = v19 + 3;
        v23 = (unsigned __int8)v19[3];
      }
      if ( v23 != 58 || (v24 = (unsigned __int8)v22[1] - 48, v24 > 9) )
      {
        v57 = 0;
        v54 = v21;
        v55 = v20;
        goto LABEL_103;
      }
      v25 = (unsigned __int8)v22[2];
      if ( (unsigned int)(v25 - 48) > 9 )
      {
        v22 += 2;
        goto LABEL_122;
      }
      v24 = v25 + 10 * v24 - 48;
      if ( v24 < 0x3D )
      {
        v22 += 3;
LABEL_122:
        v54 = v21;
        v55 = v20;
        v57 = v24;
        goto LABEL_103;
      }
LABEL_49:
      v26 = (int *)__errno(a1);
      v27 = *v26;
      *v26 = 0;
      v28 = strtol((const char *)v8, &endptr, 10);
      v29 = *v26;
      if ( *v26 != v27 )
        *v26 = v27;
      if ( v29 || (unsigned __int64)(v28 - 0x80000000LL) < 0xFFFFFFFF00000000LL )
        return 0xFFFFFFFFLL;
      a1 = sub_62C57A4();
      v22 = endptr;
      if ( v58 == -1 )
      {
        v30 = 0;
        v58 = -1;
        if ( v8 > v52 && &endptr[-v8] == &byte_4 && (int)a1 <= 1400 )
        {
          v38 = *(unsigned __int8 *)(v8 - 1);
          if ( v38 == 45 || v38 == 43 )
          {
            if ( v38 == 43 )
              v39 = -60 * ((int)a1 % 100 + 60 * ((int)a1 / 100));
            else
              v39 = 60 * ((int)a1 % 100 + 60 * ((int)a1 / 100));
            v58 = v39;
            v30 = 1;
          }
          else
          {
            v30 = 0;
            v58 = -1;
          }
        }
      }
      else
      {
        v30 = 0;
      }
      if ( &endptr[-v8] == &byte_8 )
      {
        v31 = v56;
        if ( v7 == -1 && v5 == -1 && v6 == -1 )
        {
          v7 = (int)a1 / 10000;
          v5 = ((5243 * ((int)a1 % 10000)) >> 19) + ((unsigned int)(5243 * ((int)a1 % 10000)) >> 31) - 1;
          v30 = 1;
          v6 = (int)a1 % 100;
        }
      }
      else
      {
        v31 = v56;
      }
      if ( (unsigned int)(a1 - 1) >= 0x1F )
        v32 = -1;
      else
        v32 = a1;
      v33 = (v31 == 0) & (unsigned __int8)~(_BYTE)v30 & (v6 == -1) & ((unsigned int)(a1 - 1) < 0x1F);
      if ( ((v31 == 0) & (unsigned __int8)~(_BYTE)v30 & (v6 == -1)) != 0 )
      {
        v31 = 1;
        v6 = v32;
      }
      v34 = v30 | v33;
      if ( v34 != 1 && v31 == 1 && v7 == -1 )
      {
        if ( (int)a1 <= 99 )
        {
          if ( (int)a1 < 71 )
            a1 = (unsigned int)(a1 + 2000);
          else
            a1 = (unsigned int)(a1 + 1900);
        }
        v7 = a1;
        v56 = v6 != -1;
        goto LABEL_103;
      }
      v56 = v31;
      if ( !v34 )
        return 0xFFFFFFFFLL;
LABEL_103:
      v8 = (unsigned __int64)v22;
      goto LABEL_144;
    }
    v14 = 0LL;
    while ( v2 - 97 < 0x1A )
    {
      if ( v14 > 0xB )
        goto LABEL_24;
LABEL_19:
      v15 = v8 + v14++;
      v2 = *(unsigned __int8 *)(v15 + 1);
    }
    if ( (char)v2 >= 65 && v2 <= 0x5A && v14 < 0xC )
      goto LABEL_19;
LABEL_24:
    if ( v14 == 12 )
      return 0xFFFFFFFFLL;
    v16 = v4;
    if ( v4 == -1 )
    {
      v35 = off_6BA6AD8;
      if ( v14 > 3 || (v35 = off_6BA6A40, v14 == 3) )
      {
        v36 = *v35;
        if ( strlen(*v35) == v14 )
        {
          a1 = sub_62BB7E8(v8, (unsigned __int64)v36, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 0;
            goto LABEL_143;
          }
        }
        v37 = v35[1];
        if ( strlen(v37) == v14 )
        {
          a1 = sub_62BB7E8(v8, (unsigned __int64)v37, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 1;
            goto LABEL_143;
          }
        }
        v40 = v35[2];
        if ( strlen(v40) == v14 )
        {
          a1 = sub_62BB7E8(v8, (unsigned __int64)v40, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 2;
            goto LABEL_143;
          }
        }
        v41 = v35[3];
        if ( strlen(v41) == v14 )
        {
          a1 = sub_62BB7E8(v8, (unsigned __int64)v41, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 3;
            goto LABEL_143;
          }
        }
        v42 = v35[4];
        if ( strlen(v42) == v14 )
        {
          a1 = sub_62BB7E8(v8, (unsigned __int64)v42, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 4;
            goto LABEL_143;
          }
        }
        v43 = v35[5];
        if ( strlen(v43) == v14 )
        {
          a1 = sub_62BB7E8(v8, (unsigned __int64)v43, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 5;
            goto LABEL_143;
          }
        }
        v44 = v35[6];
        if ( strlen(v44) == v14 )
        {
          a1 = sub_62BB7E8(v8, (unsigned __int64)v44, v14);
          if ( (_DWORD)a1 )
          {
            v4 = 6;
            goto LABEL_143;
          }
        }
      }
    }
    if ( v5 != -1 || v14 != 3 )
      goto LABEL_135;
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Jan", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 0;
      goto LABEL_142;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Feb", 3LL);
    v4 = v16;
    if ( (_DWORD)a1 )
    {
      v5 = 1;
      goto LABEL_143;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Mar", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 2;
      goto LABEL_143;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Apr", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 3;
      goto LABEL_143;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"May", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 4;
      goto LABEL_143;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Jun", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 5;
      goto LABEL_143;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Jul", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 6;
      goto LABEL_143;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Aug", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 7;
      goto LABEL_143;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Sep", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 8;
      goto LABEL_143;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Oct", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 9;
      goto LABEL_143;
    }
    a1 = sub_62BB7E8(v8, (unsigned __int64)"Nov", 3LL);
    if ( (_DWORD)a1 )
    {
      v5 = 10;
LABEL_142:
      v4 = v16;
LABEL_143:
      v8 += v14;
LABEL_144:
      v2 = *(unsigned __int8 *)v8;
      if ( !*(_BYTE *)v8 )
        goto LABEL_151;
      v12 = v3++ >= 5;
      if ( v12 )
        goto LABEL_151;
      continue;
    }
    break;
  }
  a1 = sub_62BB7E8(v8, (unsigned __int64)"Dec", 3LL);
  if ( (_DWORD)a1 )
  {
    v5 = 11;
    goto LABEL_142;
  }
LABEL_135:
  result = 0xFFFFFFFFLL;
  if ( v58 == -1 && v14 <= 4 )
  {
    v46 = 0LL;
    while ( 1 )
    {
      if ( strlen(&byte_16A9D74[v46]) == v14 )
      {
        a1 = sub_62BB7E8(v8, (unsigned __int64)&byte_16A9D74[v46], v14);
        if ( (_DWORD)a1 )
          break;
      }
      v46 += 12LL;
      if ( (_DWORD)v46 == 828 )
        return 0xFFFFFFFFLL;
    }
    v58 = 60 * *(_DWORD *)&byte_16A9D74[v46 + 8];
    goto LABEL_142;
  }
  return result;
}


================================================================================
Function: sub_62AFA44 (0x62AFA44)
================================================================================

__int64 __fastcall sub_62AFA44(__int64 a1)
{
  __int64 v1; // x19
  int v2; // w0
  __int64 v4; // [xsp+0h] [xbp-10h] BYREF

  v1 = -1LL;
  v4 = -1LL;
  v2 = sub_62AF11C(a1, &v4);
  if ( v2 == 1 )
    return v4;
  if ( !v2 )
  {
    if ( v4 == -1 )
      return 0LL;
    else
      return v4;
  }
  return v1;
}


================================================================================
Function: sub_62AFABC (0x62AFABC)
================================================================================

__int64 __fastcall sub_62AFABC(time_t a1, struct tm *a2)
{
  time_t v3; // [xsp+0h] [xbp-10h] BYREF

  v3 = a1;
  if ( gmtime_r(&v3, a2) )
    return 0LL;
  else
    return 43LL;
}


================================================================================
Function: sub_62AFB18 (0x62AFB18)
================================================================================

__int64 __fastcall sub_62AFB18(__int64 a1)
{
  unsigned int v2; // w20

  *(_QWORD *)(a1 + 2488) = 0LL;
  v2 = sub_62AFB6C();
  if ( !v2 )
  {
    if ( (*(_BYTE *)(a1 + 2604) & 0x10) == 0 && (*(_BYTE *)(a1 + 2892) & 1) == 0 )
      sub_62AB478(*(_QWORD *)(a1 + 456), "\n");
    *(_DWORD *)(a1 + 2888) = 0;
  }
  return v2;
}


================================================================================
Function: sub_62AFB6C (0x62AFB6C)
================================================================================

__int64 __fastcall sub_62AFB6C(size_t a1)
{
  __time_t v2; // x0
  __int64 v3; // x1
  char v4; // w0
  char v5; // w20
  unsigned int v6; // w0
  unsigned int v7; // w21
  __int64 v8; // x20
  int v9; // w9
  __int64 v10; // x2
  __int64 v11; // x8
  __int64 v12; // x10
  __int64 v13; // x11
  __int64 v14; // x8
  __int64 v15; // x9
  __int64 v16; // x10
  __int64 v17; // x11
  __int64 v18; // x9
  __int64 v19; // x21
  __int64 v20; // x23
  unsigned __int64 v21; // x1
  int v22; // w8
  __int64 v23; // x9
  __int64 v24; // x8
  __int64 v25; // x0
  __int64 v26; // x8
  __int64 v27; // x20
  __int64 v28; // x24
  __int64 v30; // [xsp+30h] [xbp-70h]
  char v31[12]; // [xsp+38h] [xbp-68h] BYREF
  char v32[12]; // [xsp+44h] [xbp-5Ch] BYREF
  char v33[12]; // [xsp+50h] [xbp-50h] BYREF
  char v34[10]; // [xsp+5Ch] [xbp-44h] BYREF
  char v35[10]; // [xsp+66h] [xbp-3Ah] BYREF
  char v36[10]; // [xsp+70h] [xbp-30h] BYREF
  char v37[10]; // [xsp+7Ah] [xbp-26h] BYREF
  char v38[10]; // [xsp+84h] [xbp-1Ch] BYREF
  char v39[10]; // [xsp+8Eh] [xbp-12h] BYREF

  v2 = sub_62BBCF8();
  v4 = sub_62B035C(a1, v2, v3);
  if ( (*(_BYTE *)(a1 + 2604) & 0x10) != 0 )
    return 0;
  v5 = v4;
  if ( *(_QWORD *)(a1 + 608) )
  {
    sub_62AE97C(a1, 1);
    v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 608))(
           *(_QWORD *)(a1 + 736),
           *(_QWORD *)(a1 + 2544),
           *(_QWORD *)(a1 + 2552),
           *(_QWORD *)(a1 + 2496),
           *(_QWORD *)(a1 + 2504));
  }
  else
  {
    if ( !*(_QWORD *)(a1 + 600) )
      goto LABEL_8;
    sub_62AE97C(a1, 1);
    v6 = (*(__int64 (__fastcall **)(_QWORD, double, double, double, double))(a1 + 600))(
           *(_QWORD *)(a1 + 736),
           (double)*(__int64 *)(a1 + 2544),
           (double)*(__int64 *)(a1 + 2552),
           (double)*(__int64 *)(a1 + 2496),
           (double)*(__int64 *)(a1 + 2504));
  }
  v7 = v6;
  sub_62AE97C(a1, 0);
  if ( v7 )
  {
    if ( v7 == 268435457 )
    {
LABEL_8:
      if ( (v5 & 1) != 0 )
      {
        v8 = (unsigned __int128)(*(__int64 *)(a1 + 2608) * (__int128)0x431BDE82D7B634DBLL) >> 64;
        v9 = *(_DWORD *)(a1 + 2604);
        if ( (v9 & 0x80) == 0 )
        {
          v10 = *(_QWORD *)(a1 + 4240);
          if ( v10 )
            sub_62AB478(*(_QWORD *)(a1 + 456), "** Resuming transfer from byte position %ld\n", v10);
          sub_62AB478(
            *(_QWORD *)(a1 + 456),
            "  %% Total    %% Received %% Xferd  Average Speed   Time    Time     Time  Current\n"
            "                                 Dload  Upload   Total   Spent    Left  Speed\n");
          v9 = *(_DWORD *)(a1 + 2604) | 0x80;
          *(_DWORD *)(a1 + 2604) = v9;
        }
        if ( (v9 & 0x20) != 0 && (v11 = *(_QWORD *)(a1 + 2512), v11 >= 1) )
        {
          v12 = *(_QWORD *)(a1 + 2496);
          v13 = *(_QWORD *)(a1 + 2504);
          v14 = v12 / v11;
          if ( v12 >= 10001 )
          {
            v12 /= 0x64uLL;
            goto LABEL_22;
          }
          if ( v12 >= 1 )
          {
            v13 *= 100LL;
LABEL_22:
            v30 = v13 / v12;
            if ( (v9 & 0x40) == 0 )
              goto LABEL_30;
            goto LABEL_23;
          }
          v30 = 0LL;
          if ( (v9 & 0x40) == 0 )
            goto LABEL_30;
        }
        else
        {
          v14 = 0LL;
          v30 = 0LL;
          if ( (v9 & 0x40) == 0 )
            goto LABEL_30;
        }
LABEL_23:
        v15 = *(_QWORD *)(a1 + 2560);
        if ( v15 >= 1 )
        {
          v16 = *(_QWORD *)(a1 + 2544);
          v17 = *(_QWORD *)(a1 + 2552);
          v18 = v16 / v15;
          if ( v16 >= 10001 )
          {
            v16 /= 0x64uLL;
LABEL_28:
            v19 = v17 / v16;
LABEL_32:
            if ( v14 <= v18 )
              v20 = v18;
            else
              v20 = v14;
            if ( v20 <= 0 )
              v21 = 0LL;
            else
              v21 = v20 - ((v8 >> 18) + ((unsigned __int64)v8 >> 63));
            sub_62B057C(v33, v21);
            sub_62B057C(v32, v20);
            sub_62B057C(v31, (v8 >> 18) + ((unsigned __int64)v8 >> 63));
            v22 = *(_DWORD *)(a1 + 2604);
            v23 = 2496LL;
            if ( (v22 & 0x20) == 0 )
              v23 = 2504LL;
            if ( (v22 & 0x40) != 0 )
              v24 = 2544LL;
            else
              v24 = 2552LL;
            v25 = *(_QWORD *)(a1 + v24) + *(_QWORD *)(a1 + v23);
            v26 = *(_QWORD *)(a1 + 2504) + *(_QWORD *)(a1 + 2552);
            if ( v25 < 10001 )
            {
              if ( v25 < 1 )
                v27 = 0LL;
              else
                v27 = 100 * v26 / v25;
            }
            else
            {
              v27 = v26 / (__int64)(v25 / 0x64uLL);
            }
            v28 = *(_QWORD *)(a1 + 456);
            ((void (*)(void))sub_62B0670)();
            sub_62B0670(*(_QWORD *)(a1 + 2552), v34);
            sub_62B0670(*(_QWORD *)(a1 + 2504), v35);
            sub_62B0670(*(_QWORD *)(a1 + 2560), v37);
            sub_62B0670(*(_QWORD *)(a1 + 2512), v38);
            sub_62B0670(*(_QWORD *)(a1 + 2592), v39);
            sub_62AB478(
              v28,
              "\r%3ld %s  %3ld %s  %3ld %s  %s  %s %s %s %s %s",
              v27,
              v36,
              v19,
              v34,
              v30,
              v35,
              v37,
              v38,
              v32,
              v31,
              v33,
              v39);
            fflush(*(FILE **)(a1 + 456));
            return 0;
          }
          if ( v16 >= 1 )
          {
            v17 *= 100LL;
            goto LABEL_28;
          }
LABEL_31:
          v19 = 0LL;
          goto LABEL_32;
        }
LABEL_30:
        v18 = 0LL;
        goto LABEL_31;
      }
      return 0;
    }
    sub_6285834(a1, (__int64)"Callback aborted");
  }
  return v7;
}


================================================================================
Function: sub_62AFFC4 (0x62AFFC4)
================================================================================

__int64 __fastcall sub_62AFFC4(__int64 result, int a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x19
  _QWORD *v5; // x20
  char v6; // w8
  __int64 v7; // x9

  v4 = result;
  switch ( a2 )
  {
    case 1:
      *(_QWORD *)(result + 2712) = a3;
      *(_QWORD *)(result + 2720) = a4;
      return result;
    case 2:
      v6 = *(_BYTE *)(result + 2892);
      *(_QWORD *)(result + 2696) = a3;
      *(_QWORD *)(result + 2704) = a4;
      *(_BYTE *)(result + 2892) = v6 & 0xFD;
      return result;
    case 3:
      result = sub_62BBE7C(a3, a4, *(_QWORD *)(result + 2712), *(_QWORD *)(result + 2720));
      *(_QWORD *)(v4 + 2616) = result;
      return result;
    case 4:
      v5 = (_QWORD *)(result + 2624);
      goto LABEL_13;
    case 5:
      v5 = (_QWORD *)(result + 2632);
      goto LABEL_13;
    case 6:
      v5 = (_QWORD *)(result + 2640);
      goto LABEL_13;
    case 7:
      v5 = (_QWORD *)(result + 2648);
      goto LABEL_13;
    case 8:
      if ( (*(_BYTE *)(result + 2892) & 2) != 0 )
        return result;
      v5 = (_QWORD *)(result + 2664);
      *(_BYTE *)(result + 2892) |= 2u;
LABEL_13:
      result = sub_62BBE7C(a3, a4, *(_QWORD *)(result + 2696), *(_QWORD *)(result + 2704));
      if ( result <= 1 )
        v7 = 1LL;
      else
        v7 = result;
      *v5 += v7;
      return result;
    case 9:
      v5 = (_QWORD *)(result + 2656);
      goto LABEL_13;
    case 10:
      *(_QWORD *)(result + 2728) = a3;
      *(_QWORD *)(result + 2736) = a4;
      return result;
    case 11:
      result = sub_62BBE7C(a3, a4, *(_QWORD *)(result + 2680), *(_QWORD *)(result + 2688));
      *(_QWORD *)(v4 + 2672) = result;
      return result;
    default:
      return result;
  }
}


================================================================================
Function: sub_62B00E8 (0x62B00E8)
================================================================================

__time_t __fastcall sub_62B00E8(__int64 a1, unsigned int a2)
{
  __time_t v4; // x21
  __int64 v5; // x1

  v4 = sub_62BBCF8();
  sub_62AFFC4(a1, a2, v4, v5);
  return v4;
}


================================================================================
Function: sub_62B0354 (0x62B0354)
================================================================================

__int64 __fastcall sub_62B0354(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 2504) = a2;
  return result;
}


================================================================================
Function: sub_62B035C (0x62B035C)
================================================================================

bool __fastcall sub_62B035C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x0
  __int64 v7; // x8
  __int64 v8; // x9
  __int64 v9; // x10
  __int64 v10; // x11
  __int64 v11; // x22
  int v12; // w12
  __int64 v13; // x23
  __int64 v14; // x10
  __int64 v15; // x8
  __int64 v16; // x15
  _QWORD *v17; // x25
  unsigned int v18; // w24
  __int64 v19; // x0
  __int64 v20; // x9
  __int64 v21; // x8
  __int64 v22; // x8

  v6 = sub_62BBE7C(a2, a3, *(_QWORD *)(a1 + 2680), *(_QWORD *)(a1 + 2688));
  v7 = *(_QWORD *)(a1 + 2552);
  *(_QWORD *)(a1 + 2608) = v6;
  if ( v6 < 1 )
  {
    v8 = 1000000 * v7;
    v9 = *(_QWORD *)(a1 + 2504);
    v10 = 1000000 * v9;
    *(_QWORD *)(a1 + 2560) = 1000000 * v7;
  }
  else
  {
    if ( v7 >= 0x8637BD05AF6LL )
    {
      if ( (unsigned __int64)v6 <= 0xF423F )
        v8 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v8 = v7 / (v6 / 0xF4240uLL);
    }
    else
    {
      v8 = 1000000 * v7 / v6;
    }
    v9 = *(_QWORD *)(a1 + 2504);
    *(_QWORD *)(a1 + 2560) = v8;
    if ( v9 >= 0x8637BD05AF6LL )
    {
      if ( (unsigned __int64)v6 <= 0xF423F )
        v10 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v10 = v9 / (v6 / 0xF4240uLL);
    }
    else
    {
      v10 = 1000000 * v9 / v6;
    }
  }
  v11 = *(_QWORD *)(a1 + 2488);
  *(_QWORD *)(a1 + 2512) = v10;
  if ( v11 != a2 )
  {
    v12 = *(_DWORD *)(a1 + 2888);
    v13 = a1 + 2488;
    v14 = v9 + v7;
    *(_QWORD *)(a1 + 2488) = a2;
    v15 = a1 + 2488 + 8LL * (v12 % 6);
    v16 = a1 + 2488 + 16LL * (v12 % 6);
    *(_QWORD *)(v15 + 256) = v14;
    *(_QWORD *)(v16 + 304) = a2;
    *(_QWORD *)(v16 + 312) = a3;
    *(_DWORD *)(a1 + 2888) = v12 + 1;
    if ( v12 )
    {
      v17 = (_QWORD *)(v15 + 256);
      if ( v12 <= 4 )
        v18 = 0;
      else
        v18 = (v12 + 1) % 6;
      v19 = sub_62BBD98(a2, a3, *(_QWORD *)(v13 + 16LL * v18 + 304), *(_QWORD *)(v13 + 16LL * v18 + 312));
      if ( v19 )
        v20 = v19;
      else
        v20 = 1LL;
      v21 = *v17 - *(_QWORD *)(v13 + 8LL * v18 + 256);
      if ( v21 < 4294968 )
        v22 = 1000 * v21 / v20;
      else
        v22 = (__int64)((double)v21 / ((double)v20 / 1000.0));
    }
    else
    {
      v22 = v10 + v8;
    }
    *(_QWORD *)(a1 + 2592) = v22;
  }
  return v11 != a2;
}


================================================================================
Function: sub_62B057C (0x62B057C)
================================================================================

char *__fastcall sub_62B057C(char *result, unsigned __int64 a2)
{
  unsigned __int64 v2; // x3

  if ( (__int64)a2 <= 0 )
  {
    strcpy(result, "--:--:--");
  }
  else if ( a2 > 0x57E3F )
  {
    v2 = a2 / 0x15180;
    if ( a2 > 0x5265BFF )
      return (char *)sub_62AB108(result, 9LL, "%7ldd", v2);
    else
      return (char *)sub_62AB108(result, 9LL, "%3ldd %02ldh", v2, (__int64)(a2 % 0x15180) / 3600);
  }
  else
  {
    return (char *)sub_62AB108(
                     result,
                     9LL,
                     "%2ld:%02ld:%02ld",
                     a2 / 0xE10,
                     (__int64)(a2 % 0xE10) / 60,
                     (__int64)(a2 % 0xE10) % 60);
  }
  return result;
}


================================================================================
Function: sub_62B0670 (0x62B0670)
================================================================================

_BYTE *__fastcall sub_62B0670(unsigned __int64 a1, _BYTE *a2)
{
  if ( (__int64)a1 > 99999 )
  {
    if ( a1 >> 14 > 0x270 )
    {
      if ( a1 >> 22 > 0x18 )
      {
        if ( a1 >> 24 > 0x270 )
        {
          if ( HIDWORD(a1) > 0x18 )
          {
            if ( a1 >> 34 > 0x270 )
            {
              if ( a1 >> 44 > 0x270 )
                sub_62AB108(a2, 6LL, "%4ldP", a1 >> 50);
              else
                sub_62AB108(a2, 6LL, "%4ldT", a1 >> 40);
            }
            else
            {
              sub_62AB108(a2, 6LL, "%4ldG", a1 >> 30);
            }
          }
          else
          {
            sub_62AB108(
              a2,
              6LL,
              "%2ld.%0ldG",
              a1 >> 30,
              (2684354571u * (unsigned __int64)(((unsigned int)a1 >> 1) & 0x1FFFFFFF)) >> 57);
          }
        }
        else
        {
          sub_62AB108(a2, 6LL, "%4ldM", a1 >> 20);
        }
      }
      else
      {
        sub_62AB108(a2, 6LL, "%2ld.%0ldM", a1 >> 20, (a1 & 0xFFFFF) / 0x19999);
      }
    }
    else
    {
      sub_62AB108(a2, 6LL, "%4ldk", a1 >> 10);
    }
  }
  else
  {
    sub_62AB108(a2, 6LL, "%5ld", a1);
  }
  return a2;
}


================================================================================
Function: sub_62B0964 (0x62B0964)
================================================================================

__int64 __fastcall sub_62B0964(__int64 a1, _BYTE *a2, __int64 a3)
{
  __int64 v4; // x22
  __int64 result; // x0
  unsigned int v7; // [xsp+4h] [xbp-Ch] BYREF

  v4 = a3 - 1;
  if ( a3 == 1 )
  {
LABEL_5:
    result = 0LL;
    *a2 = 0;
  }
  else
  {
    while ( 1 )
    {
      result = sub_62C9454(a1, &v7, 4LL);
      if ( (_DWORD)result )
        break;
      if ( v7 <= 0xFFFFFFFB )
      {
        --v4;
        *a2++ = aAbcdefghijklmn_1[v7 % 0x3E];
        if ( !v4 )
          goto LABEL_5;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_62B0A48 (0x62B0A48)
================================================================================

long double __fastcall sub_62B0A48(_OWORD *a1)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}


================================================================================
Function: sub_62B0B64 (0x62B0B64)
================================================================================

__int64 __fastcall sub_62B0B64(__int64 a1, __int64 a2, char a3)
{
  if ( (a3 & 1) == 0 )
    sub_62B0BA0(a2);
  sub_62B205C(a2);
  sub_6291C54(a2);
  return 0LL;
}


================================================================================
Function: sub_62B0BA0 (0x62B0BA0)
================================================================================

__int64 __fastcall sub_62B0BA0(__int64 a1)
{
  unsigned __int64 v2; // x21
  unsigned __int64 v3; // x10
  int v4; // w8
  int v5; // w8
  int v6; // w10
  __int64 result; // x0
  unsigned __int64 v8; // [xsp+0h] [xbp-20h]
  unsigned __int64 v9; // [xsp+8h] [xbp-18h] BYREF
  __int64 v10; // [xsp+10h] [xbp-10h] BYREF

  if ( !a1 || !*(_QWORD *)(a1 + 24) )
    return 2LL;
  if ( (sub_62A5984(a1 + 336) & 1) != 0 )
  {
    if ( (sub_62BD354(a1) & 1) != 0 )
      return sub_6288E14();
  }
  else
  {
    do
    {
      if ( (sub_62A5EA4(a1 + 336, &v10, &v9) & 1) == 0 )
        break;
      if ( *(_QWORD *)(a1 + 400) >= v9 )
        v2 = v9;
      else
        v2 = *(_QWORD *)(a1 + 400);
      result = sub_62B1170(a1, v10);
      if ( (_DWORD)result )
        return result;
      ((void (__fastcall *)(__int64))sub_62A5F20)(a1 + 336);
      if ( v2 )
      {
        if ( v2 >= v8 )
          v3 = v8;
        else
          v3 = v2;
        *(_QWORD *)(a1 + 400) -= v3;
      }
    }
    while ( v8 >= v9 );
    if ( (sub_62A5984(a1 + 336) & 1) == 0 )
      return 81LL;
  }
  v4 = *(_DWORD *)(a1 + 449);
  if ( (v4 & 0x60) == 0x20 )
  {
    result = sub_62B1170(a1, &v9);
    if ( (_DWORD)result )
      return result;
    v4 = *(_DWORD *)(a1 + 449);
  }
  if ( (v4 & 0x160) != 0x60 )
    return 0LL;
  if ( (v4 & 0x100000) == 0 )
    return sub_62B0E94(a1);
  LODWORD(result) = sub_62BBFF8(a1, &v10);
  v5 = result;
  v6 = (_BYTE)v10 ? 0 : 81;
  result = (_DWORD)result ? (unsigned int)result : (unsigned int)v6;
  if ( !v5 && (_BYTE)v10 )
    return sub_62B0E94(a1);
  return result;
}


================================================================================
Function: sub_62B0E28 (0x62B0E28)
================================================================================

__int64 __fastcall sub_62B0E28(__int64 a1, __int64 a2)
{
  __int64 (__fastcall *v4)(); // x8
  char v5; // w8

  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 200));
  v4 = off_6C2D120[0];
  *(_QWORD *)(a1 + 200) = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(*(_QWORD *)(a1 + 192));
  v5 = *(_BYTE *)(a1 + 219);
  *(_QWORD *)(a1 + 192) = 0LL;
  if ( (v5 & 8) != 0 )
    sub_62A58C0(a1 + 104);
  sub_62B1FC4(a2);
  return sub_6291370(a2);
}


================================================================================
Function: sub_62B0E94 (0x62B0E94)
================================================================================

__int64 __fastcall sub_62B0E94(__int64 a1)
{
  _DWORD *v1; // x21
  int *v3; // x20
  int v4; // w9
  __int64 v5; // x3
  __int64 v6; // x4
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  __int64 v10; // x2
  __int64 v11; // x8
  const char *v12; // x1
  int v13; // w8
  __int64 v14; // x8
  __int64 v15; // x8
  __int64 v16; // x8
  __int64 v18; // [xsp+0h] [xbp+0h]

  v1 = (_DWORD *)(a1 + 449);
  v3 = (int *)(a1 + 2458);
  v4 = *(_DWORD *)(a1 + 449) | 0x100;
  *(_DWORD *)(a1 + 312) &= 0xFFFFFFBD;
  *(_DWORD *)(a1 + 449) = v4;
  sub_62B00E8();
  sub_62B2EC4(a1, (*v1 >> 9) & 1);
  if ( (*v1 & 0x200) != 0 )
  {
    sub_62A5928(a1 + 336);
    v10 = *(_QWORD *)(a1 + 256);
    v13 = *v3;
    if ( v10 )
    {
      if ( (v13 & 0x100000) != 0 )
      {
        v14 = *(_QWORD *)(a1 + 4576);
        if ( !v14 || *(int *)(v14 + 8) >= 1 )
        {
          v12 = "abort upload after having sent %ld bytes";
          goto LABEL_23;
        }
      }
    }
    else if ( (v13 & 0x100000) != 0 )
    {
      v16 = *(_QWORD *)(a1 + 4576);
      if ( !v16 || *(int *)(v16 + 8) >= 1 )
      {
        v12 = "abort upload";
        goto LABEL_23;
      }
    }
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 256);
    if ( v10 )
    {
      if ( (*v3 & 0x100000) != 0 )
      {
        v11 = *(_QWORD *)(a1 + 4576);
        if ( !v11 || *(int *)(v11 + 8) >= 1 )
        {
          v12 = "upload completely sent off: %ld bytes";
LABEL_23:
          sub_628595C(a1, v12, v10, v5, v6, v7, v8, v9, v18);
        }
      }
    }
    else if ( (*v1 & 8) == 0 && (*v3 & 0x100000) != 0 )
    {
      v15 = *(_QWORD *)(a1 + 4576);
      if ( !v15 || *(int *)(v15 + 8) >= 1 )
      {
        if ( sub_62B2DF0(a1) )
          v12 = "We are completely uploaded and fine";
        else
          v12 = "Request completely sent off";
        goto LABEL_23;
      }
    }
  }
  return sub_62BD43C(a1);
}


================================================================================
Function: sub_62B1170 (0x62B1170)
================================================================================

__int64 __fastcall sub_62B1170(size_t a1, char *a2, size_t a3, size_t a4, size_t *a5)
{
  signed __int64 v5; // x9
  size_t v10; // x8
  size_t v11; // x23
  __int64 result; // x0
  size_t v13; // x8
  size_t v14; // x3
  size_t v15; // x22

  *a5 = 0LL;
  v5 = *(_QWORD *)(a1 + 816);
  if ( (__int64)(a3 - a4) <= v5 )
    v10 = a3;
  else
    v10 = v5 + a4;
  if ( v5 )
    v11 = v10;
  else
    v11 = a3;
  if ( (*(_BYTE *)(a1 + 449) & 0x20) != 0 && (sub_62A5984(a1 + 336) || sub_62A5958(a1 + 336) == v11) )
  {
    result = sub_62BD3A4(a1, a2, v11, 1LL, a5);
    if ( (_DWORD)result )
      return result;
    v13 = *a5;
    if ( v11 != *a5 )
      goto LABEL_15;
    *(_DWORD *)(a1 + 449) |= 0x40u;
  }
  else
  {
    result = sub_62BD3A4(a1, a2, v11, 0LL, a5);
    if ( (_DWORD)result )
      return result;
  }
  v13 = *a5;
LABEL_15:
  if ( v13 )
  {
    if ( a4 )
    {
      if ( v13 <= a4 )
        v14 = v13;
      else
        v14 = a4;
      sub_6285740(a1, 2u, a2, v14);
      v13 = *a5;
    }
    v15 = v13 - a4;
    if ( v13 > a4 )
    {
      sub_6285740(a1, 4u, &a2[a4], v13 - a4);
      *(_QWORD *)(a1 + 256) += v15;
      sub_62B0354(a1);
    }
  }
  return 0LL;
}


================================================================================
Function: sub_62B17A0 (0x62B17A0)
================================================================================

__int64 __fastcall sub_62B17A0(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // x21
  __int64 v4; // x20
  __int64 v5; // x23
  __int64 v7; // x8
  _DWORD *v8; // x9
  struct timeval *v9; // x0
  __int64 v10; // x0
  __int16 *v11; // x25
  int v12; // w24
  __int64 v13; // x0
  __int16 v14; // w8
  struct timeval *v15; // x0
  __int64 v16; // x0
  _WORD *v17; // x19
  __int64 v18; // x0
  __int16 v19; // w8
  __int16 v20; // w8
  __int16 v21; // w8
  __int64 v23; // [xsp+0h] [xbp-1A0h] BYREF
  fd_set exceptfds; // [xsp+10h] [xbp-190h] BYREF
  fd_set writefds; // [xsp+90h] [xbp-110h] BYREF
  fd_set readfds; // [xsp+110h] [xbp-90h] BYREF

  v3 = a3;
  if ( a1 && (LODWORD(v4) = a2) != 0 )
  {
    v5 = a2;
    v7 = a2;
    v8 = (_DWORD *)a1;
    while ( *v8 == -1 )
    {
      v8 += 2;
      if ( !--v7 )
        goto LABEL_6;
    }
    v11 = (__int16 *)(a1 + 4);
    v12 = -1;
    memset(&readfds, 0, sizeof(readfds));
    memset(&writefds, 0, sizeof(writefds));
    memset(&exceptfds, 0, sizeof(exceptfds));
    do
    {
      v13 = *((unsigned int *)v11 - 1);
      v11[1] = 0;
      if ( (_DWORD)v13 != -1 )
      {
        if ( (unsigned int)v13 >= 0x400 )
        {
          LODWORD(v3) = -1;
          *(_DWORD *)__errno(v13) = 22;
          return (unsigned int)v3;
        }
        v14 = *v11;
        if ( (*v11 & 0x1C7) != 0 )
        {
          if ( (int)v13 > v12 )
            v12 = v13;
          if ( (v14 & 0x41) != 0 )
          {
            ((void (*)(void))__FD_SET_chk)();
            v14 = *v11;
          }
          if ( (v14 & 0x104) != 0 )
          {
            __FD_SET_chk(*((unsigned int *)v11 - 1), &writefds, 128LL);
            v14 = *v11;
          }
          if ( (v14 & 0x82) != 0 )
            __FD_SET_chk(*((unsigned int *)v11 - 1), &exceptfds, 128LL);
        }
      }
      v11 += 4;
      --v5;
    }
    while ( v5 );
    v15 = (struct timeval *)sub_62BBCA8(&v23, v3);
    v16 = select(v12 + 1, &readfds, &writefds, &exceptfds, v15);
    if ( (int)v16 < 1 )
    {
      LODWORD(v3) = v16;
      if ( (_DWORD)v16 == -1 )
      {
        if ( *(_DWORD *)__errno(v16) == 4 )
          LODWORD(v3) = 0;
        else
          LODWORD(v3) = -1;
      }
    }
    else
    {
      LODWORD(v3) = 0;
      if ( (unsigned int)v4 <= 1 )
        v4 = 1LL;
      else
        v4 = (unsigned int)v4;
      v17 = (_WORD *)(a1 + 6);
      do
      {
        v18 = *(unsigned int *)(v17 - 3);
        *v17 = 0;
        if ( (_DWORD)v18 != -1 )
        {
          if ( (unsigned int)__FD_ISSET_chk(v18, &readfds, 128LL) )
          {
            v19 = *(v17 - 1);
            if ( (v19 & 0x40) != 0 )
              *v17 |= 0x40u;
            if ( (v19 & 1) != 0 )
              *v17 |= 1u;
          }
          if ( (unsigned int)__FD_ISSET_chk(*(unsigned int *)(v17 - 3), &writefds, 128LL) )
          {
            v20 = *(v17 - 1);
            if ( (v20 & 0x100) != 0 )
              *v17 |= 0x100u;
            if ( (v20 & 4) != 0 )
              *v17 |= 4u;
          }
          if ( (unsigned int)__FD_ISSET_chk(*(unsigned int *)(v17 - 3), &exceptfds, 128LL) )
          {
            v21 = *(v17 - 1);
            if ( (v21 & 0x80) != 0 )
              *v17 |= 0x80u;
            if ( (v21 & 2) != 0 )
              *v17 |= 2u;
          }
          if ( *v17 )
            LODWORD(v3) = v3 + 1;
        }
        v17 += 4;
        --v4;
      }
      while ( v4 );
    }
  }
  else
  {
LABEL_6:
    if ( a3 )
    {
      if ( a3 < 0 )
      {
        LODWORD(v3) = -1;
        *(_DWORD *)__errno(a1) = 22;
      }
      else
      {
        v9 = (struct timeval *)sub_62BBCA8(&readfds, a3);
        v10 = select(0, 0LL, 0LL, 0LL, v9);
        LODWORD(v3) = v10;
        if ( (_DWORD)v10 )
        {
          if ( (_DWORD)v10 == -1 && *(_DWORD *)__errno(v10) == 4 )
            LODWORD(v3) = 0;
          else
            LODWORD(v3) = -1;
        }
      }
    }
  }
  return (unsigned int)v3;
}


================================================================================
Function: sub_62B1AE0 (0x62B1AE0)
================================================================================

__int64 __fastcall sub_62B1AE0(__int64 result, __int64 a2, int a3)
{
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = 0LL;
  *(_QWORD *)(result + 16) = 0LL;
  if ( a2 )
  {
    if ( a3 )
    {
      *(_QWORD *)result = a2;
      *(_DWORD *)(result + 12) = a3;
    }
  }
  return result;
}


================================================================================
Function: sub_62B1AFC (0x62B1AFC)
================================================================================

unsigned __int64 __fastcall sub_62B1AFC(unsigned __int64 result)
{
  _QWORD *v1; // x19

  v1 = (_QWORD *)result;
  if ( (*(_BYTE *)(result + 16) & 1) != 0 )
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)result);
  *v1 = 0LL;
  v1[1] = 0LL;
  v1[2] = 0LL;
  return result;
}


================================================================================
Function: sub_62B1B3C (0x62B1B3C)
================================================================================

__int64 __fastcall sub_62B1B3C(unsigned __int64 *a1, __int64 a2)
{
  unsigned int v2; // w8
  unsigned __int64 i; // x23
  char *v6; // x21
  char *v7; // x10
  int v8; // w26
  int v9; // w27
  unsigned int v10; // w9
  __int64 v11; // x10
  unsigned int v13; // w10
  unsigned int v14; // w22
  char *v15; // x0
  char v16; // w8

  v2 = *(_DWORD *)(a2 + 20);
  if ( v2 )
  {
    for ( i = 0LL; i < v2; ++i )
    {
      v8 = *(_BYTE *)(a2 + i + 24) & 1 | (4 * ((*(unsigned __int8 *)(a2 + i + 24) >> 1) & 1));
      if ( v8 )
      {
        v9 = *(_DWORD *)(a2 + 4 * i);
        v10 = *((_DWORD *)a1 + 2);
        if ( (v10 & 0x80000000) == 0 )
        {
          v11 = *((unsigned int *)a1 + 2);
          while ( v11-- >= 1 )
          {
            if ( *(_DWORD *)(*a1 + 8LL * (unsigned int)v11) == v9 )
            {
              *(_WORD *)(*a1 + 8LL * (unsigned int)v11 + 4) |= v8;
              goto LABEL_5;
            }
          }
        }
        v13 = *((_DWORD *)a1 + 3);
        if ( v10 < v13 )
        {
          v6 = (char *)*a1;
        }
        else
        {
          v14 = v13 + 100;
          v15 = (char *)off_6C2D138(v13 + 100, 8LL);
          if ( !v15 )
            return 27LL;
          v6 = v15;
          memcpy(v15, (const void *)*a1, 8LL * *((unsigned int *)a1 + 3));
          v16 = *((_BYTE *)a1 + 16);
          if ( (v16 & 1) != 0 )
          {
            ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*a1);
            v16 = *((_BYTE *)a1 + 16);
          }
          v10 = *((_DWORD *)a1 + 2);
          *a1 = (unsigned __int64)v6;
          *((_DWORD *)a1 + 3) = v14;
          *((_BYTE *)a1 + 16) = v16 | 1;
          v2 = *(_DWORD *)(a2 + 20);
        }
        v7 = &v6[8 * v10];
        *(_DWORD *)v7 = v9;
        *((_WORD *)v7 + 2) = v8;
        *((_DWORD *)a1 + 2) = v10 + 1;
      }
LABEL_5:
      ;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_62B1FC4 (0x62B1FC4)
================================================================================

unsigned __int64 __fastcall sub_62B1FC4(unsigned __int64 result)
{
  unsigned __int64 v1; // x19
  _QWORD *i; // x20
  void (__fastcall *v3)(unsigned __int64, _QWORD *); // x8
  __int64 v4; // x1
  void (__fastcall *v5)(unsigned __int64, __int64); // x8
  _QWORD *v6; // x20

  v1 = result;
  for ( i = *(_QWORD **)(result + 328); i; i = *(_QWORD **)(v1 + 328) )
  {
    v3 = *(void (__fastcall **)(unsigned __int64, _QWORD *))(*i + 24LL);
    *(_QWORD *)(v1 + 328) = i[1];
    v3(v1, i);
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)i);
  }
  while ( 1 )
  {
    v6 = *(_QWORD **)(v1 + 320);
    if ( !v6 )
      break;
    v4 = *(_QWORD *)(v1 + 320);
    v5 = *(void (__fastcall **)(unsigned __int64, __int64))(*v6 + 32LL);
    *(_QWORD *)(v1 + 320) = v6[1];
    v5(v1, v4);
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v6);
  }
  *(_QWORD *)(v1 + 248) = 0LL;
  *(_DWORD *)(v1 + 292) = 0;
  return result;
}


================================================================================
Function: sub_62B205C (0x62B205C)
================================================================================

__int64 __fastcall sub_62B205C(__int64 result)
{
  __int64 v1; // x19
  int v2; // w8
  __int64 v3; // x8
  _QWORD *i; // x20
  void (__fastcall *v5)(__int64, _QWORD *); // x8
  __int64 v6; // x8
  _QWORD *j; // x20
  void (__fastcall *v8)(__int64, _QWORD *); // x8

  v1 = result;
  v2 = *(_DWORD *)(result + 2458);
  if ( (*(_BYTE *)(result + 449) & 0x80) != 0 )
  {
    if ( (v2 & 0x100000) == 0 )
      goto LABEL_15;
    v6 = *(_QWORD *)(result + 4576);
    if ( v6 )
    {
      if ( *(int *)(v6 + 8) < 1 || dword_6C2D148 <= 0 )
        goto LABEL_15;
    }
    else if ( dword_6C2D148 < 1 )
    {
      goto LABEL_15;
    }
    result = sub_6285C7C(result, "client_reset, will rewind reader");
    goto LABEL_15;
  }
  if ( (v2 & 0x100000) != 0 )
  {
    v3 = *(_QWORD *)(result + 4576);
    if ( v3 )
    {
      if ( *(int *)(v3 + 8) >= 1 && dword_6C2D148 > 0 )
        goto LABEL_6;
    }
    else if ( dword_6C2D148 >= 1 )
    {
LABEL_6:
      result = sub_6285C7C(result, "client_reset, clear readers");
    }
  }
  for ( i = *(_QWORD **)(v1 + 328); i; i = *(_QWORD **)(v1 + 328) )
  {
    v5 = *(void (__fastcall **)(__int64, _QWORD *))(*i + 24LL);
    *(_QWORD *)(v1 + 328) = i[1];
    v5(v1, i);
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)i);
  }
LABEL_15:
  for ( j = *(_QWORD **)(v1 + 320); j; j = *(_QWORD **)(v1 + 320) )
  {
    v8 = *(void (__fastcall **)(__int64, _QWORD *))(*j + 32LL);
    *(_QWORD *)(v1 + 320) = j[1];
    v8(v1, j);
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)j);
  }
  *(_QWORD *)(v1 + 248) = 0LL;
  *(_DWORD *)(v1 + 292) = 0;
  return result;
}


================================================================================
Function: sub_62B2520 (0x62B2520)
================================================================================

_QWORD *__fastcall sub_62B2520(__int64 a1, __int64 a2)
{
  _QWORD *result; // x0

  for ( result = *(_QWORD **)(a1 + 320); result; result = (_QWORD *)result[1] )
  {
    if ( *result == a2 )
      break;
  }
  return result;
}


================================================================================
Function: sub_62B2DF0 (0x62B2DF0)
================================================================================

__int64 __fastcall sub_62B2DF0(__int64 a1)
{
  __int64 v1; // x1

  v1 = *(_QWORD *)(a1 + 328);
  if ( v1 )
    return (*(__int64 (**)(void))(*(_QWORD *)v1 + 40LL))();
  else
    return -1LL;
}


================================================================================
Function: sub_62B2EC4 (0x62B2EC4)
================================================================================

__int64 __fastcall sub_62B2EC4(__int64 result, unsigned int a2)
{
  _QWORD *v2; // x20
  __int64 v3; // x19

  v2 = *(_QWORD **)(result + 328);
  if ( v2 )
  {
    v3 = result;
    do
    {
      result = (*(__int64 (__fastcall **)(__int64, _QWORD *, _QWORD))(*v2 + 80LL))(v3, v2, a2);
      v2 = (_QWORD *)v2[1];
    }
    while ( v2 );
  }
  return result;
}


================================================================================
Function: sub_62B42F0 (0x62B42F0)
================================================================================

__int64 __fastcall sub_62B42F0(__int64 a1)
{
  __int64 v2; // x8
  __int64 v3; // x0
  __int64 v4; // x21
  _QWORD *v5; // x20
  unsigned int v6; // w19
  _QWORD *v7; // x22
  _QWORD *v8; // x23

  if ( !a1 || (*(_DWORD *)(a1 + 2458) & 0x100000) == 0 )
    goto LABEL_7;
  v2 = *(_QWORD *)(a1 + 4576);
  if ( v2 )
  {
    if ( *(int *)(v2 + 8) < 1 || dword_6C2D158 <= 0 )
      goto LABEL_7;
  }
  else if ( dword_6C2D158 < 1 )
  {
    goto LABEL_7;
  }
  sub_6285E0C(a1, "cw-out done");
LABEL_7:
  v3 = sub_62B2520(a1, &off_6C2D530);
  if ( !v3 )
    return 0;
  v4 = v3;
  if ( (*(_BYTE *)(v3 + 40) & 2) != 0 )
    return 23;
  if ( (*(_BYTE *)(v3 + 40) & 1) != 0 )
  {
    return 0;
  }
  else
  {
    v5 = (_QWORD *)(v3 + 32);
    v6 = sub_62B46DC(v3, a1, v3 + 32, 1LL);
    if ( v6 )
    {
      v7 = *(_QWORD **)(v4 + 32);
      *(_BYTE *)(v4 + 40) |= 2u;
      if ( v7 )
      {
        do
        {
          v8 = (_QWORD *)*v7;
          sub_628F4EC(v7 + 1);
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v7);
          v7 = v8;
          *v5 = v8;
        }
        while ( v8 );
      }
    }
  }
  return v6;
}


================================================================================
Function: sub_62B46DC (0x62B46DC)
================================================================================

__int64 __fastcall sub_62B46DC(__int64 a1, __int64 a2, unsigned __int64 *a3, char a4)
{
  unsigned __int64 v4; // x20
  _QWORD *v9; // x8
  _QWORD *v10; // x9
  _QWORD *v11; // x21
  __int64 result; // x0
  unsigned int v13; // w25
  __int64 v14; // x26
  __int64 v15; // x0
  __int64 v16; // x22
  __int64 v17; // x0
  __int64 v18; // [xsp+0h] [xbp-10h] BYREF

  v4 = *a3;
  if ( *a3 && (*(_BYTE *)(a1 + 40) & 1) == 0 )
  {
    while ( 1 )
    {
      v9 = *(_QWORD **)v4;
      if ( !*(_QWORD *)v4 )
        break;
      v10 = (_QWORD *)v4;
      do
      {
        v11 = v10;
        v10 = v9;
        v9 = (_QWORD *)*v9;
      }
      while ( v9 );
      result = sub_62B46DC(a1, a2, v11, a4 & 1);
      if ( (_DWORD)result )
        return result;
      if ( *v11 )
        return 0LL;
    }
    if ( sub_628F7CC(v4 + 8) )
    {
      v13 = *(_DWORD *)(v4 + 40);
      v14 = sub_628F7BC(v4 + 8);
      v15 = sub_628F7CC(v4 + 8);
      result = sub_62B4860(a1, a2, v13, a4 & 1, v14, v15, &v18);
      if ( (_DWORD)result )
        return result;
      v16 = v18;
      if ( v18 )
      {
        if ( v16 == sub_628F7CC(v4 + 8) )
        {
          sub_628F4EC((unsigned __int64 *)(v4 + 8));
        }
        else
        {
          v17 = sub_628F7CC(v4 + 8);
          result = sub_628F53C((int)v4 + 8, v17 - v16);
          if ( (_DWORD)result )
            return result;
        }
      }
    }
    if ( !sub_628F7CC(v4 + 8) )
    {
      sub_628F4EC((unsigned __int64 *)(v4 + 8));
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v4);
      result = 0LL;
      *a3 = 0LL;
      return result;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_62B4860 (0x62B4860)
================================================================================

__int64 __fastcall sub_62B4860(
        __int64 a1,
        size_t a2,
        int a3,
        __int64 a4,
        __int64 a5,
        unsigned __int64 a6,
        unsigned __int64 *a7)
{
  unsigned __int64 v8; // x22
  __int64 (__fastcall *v12)(__int64, __int64, __int64, __int64); // x26
  __int64 *v13; // x8
  unsigned __int64 v14; // x25
  __int64 v15; // x11
  const char *v16; // x8
  _DWORD *v17; // x24
  __int64 v18; // x27
  __int64 v19; // x28
  __int64 v20; // x2
  __int64 v21; // x3
  __int64 v22; // x4
  __int64 v23; // x5
  __int64 v24; // x6
  __int64 v25; // x7
  __int64 v26; // x8
  __int64 result; // x0
  __int64 v28; // x8
  __int64 v29; // x8
  __int64 v30; // [xsp+0h] [xbp-20h]
  __int64 v31; // [xsp+8h] [xbp-18h]
  __int64 v32; // [xsp+10h] [xbp-10h]
  int v33; // [xsp+1Ch] [xbp-4h]

  if ( (*(_BYTE *)(a1 + 40) & 2) != 0 )
    return 23LL;
  v8 = a6;
  if ( a3 == 2 )
  {
    v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(a2 + 576);
    if ( !v12 )
    {
      if ( *(_QWORD *)(a2 + 496) )
        v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(a2 + 568);
      else
        v12 = 0LL;
    }
    v14 = 0LL;
    v13 = (__int64 *)(a2 + 496);
    v33 = 1;
    if ( v12 )
      goto LABEL_5;
LABEL_41:
    result = 0LL;
    *a7 = a6;
    return result;
  }
  if ( a3 != 1 )
    goto LABEL_41;
  v12 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(a2 + 568);
  v33 = 0;
  v13 = (__int64 *)(a2 + 480);
  v14 = 0x4000LL;
  if ( !v12 )
    goto LABEL_41;
LABEL_5:
  v15 = *v13;
  if ( a3 == 1 )
    v16 = "body";
  else
    v16 = "header";
  *a7 = 0LL;
  v31 = (__int64)v16;
  v32 = v15;
  if ( !a6 )
    return 0LL;
  v17 = (_DWORD *)(a2 + 2458);
  while ( 1 )
  {
    if ( (*(_BYTE *)(a1 + 40) & 1) != 0 )
      return 0LL;
    if ( v33 | (v8 < v14) )
      v18 = v8;
    else
      v18 = v14;
    sub_62AE97C(a2, 1);
    v19 = v12(a5, 1LL, v18, v32);
    sub_62AE97C(a2, 0);
    if ( (*v17 & 0x100000) != 0 )
    {
      v26 = *(_QWORD *)(a2 + 4576);
      if ( v26 )
      {
        if ( *(int *)(v26 + 8) >= 1 && dword_6C2D158 > 0 )
LABEL_18:
          sub_6285E0C(a2, (__int64)"cw_out, wrote %zu %s bytes -> %zu", v18, v31, v19, v23, v24, v25, v30);
      }
      else if ( dword_6C2D158 >= 1 )
      {
        goto LABEL_18;
      }
    }
    if ( v19 == 0xFFFFFFFFLL )
    {
      sub_6285834(a2, (__int64)"client returned ERROR on write of %zu bytes", v18);
      return 23LL;
    }
    if ( v19 == 268435457 )
      break;
    if ( v19 != v18 )
    {
      sub_6285834(a2, (__int64)"Failure writing output to destination, passed %zu returned %zd", v18, v19);
      return 23LL;
    }
    result = 0LL;
    v8 -= v18;
    a5 += v18;
    *a7 += v18;
    if ( !v8 )
      return result;
  }
  v28 = *(_QWORD *)(a2 + 24);
  if ( v28 && (*(_BYTE *)(*(_QWORD *)(v28 + 928) + 148LL) & 0x10) != 0 )
  {
    sub_6285834(a2, (__int64)"Write callback asked for PAUSE when not supported");
    return 23LL;
  }
  *(_DWORD *)(a2 + 312) |= 0x10u;
  *(_BYTE *)(a1 + 40) |= 1u;
  if ( (*v17 & 0x100000) == 0 )
    return 0LL;
  v29 = *(_QWORD *)(a2 + 4576);
  if ( !v29 )
  {
    if ( dword_6C2D158 < 1 )
      return 0LL;
    goto LABEL_44;
  }
  result = 0LL;
  if ( *(int *)(v29 + 8) >= 1 && dword_6C2D158 > 0 )
  {
LABEL_44:
    sub_6285E0C(a2, (__int64)"cw_out, PAUSE requested by client", v20, v21, v22, v23, v24, v25, v30);
    return 0LL;
  }
  return result;
}


================================================================================
Function: sub_62B9338 (0x62B9338)
================================================================================

_DWORD *sub_62B9338()
{
  _DWORD *v0; // x0
  _DWORD *v1; // x19
  int v2; // w8

  v0 = (_DWORD *)off_6C2D138(1LL, 288LL);
  v1 = v0;
  if ( v0 )
  {
    v2 = v0[1] | 2;
    *v0 = 2115074590;
    v0[1] = v2;
    sub_629A0C4(v0 + 50, 23LL);
  }
  return v1;
}


================================================================================
Function: sub_62B9394 (0x62B9394)
================================================================================

__int64 __fastcall sub_62B9394(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        long double a9,
        long double a10,
        long double a11,
        long double a12,
        __int64 a13)
{
  __int64 result; // x0
  __int64 v15; // x8
  int *v16; // x8
  __int64 v17; // x8
  __int64 *v18; // x8
  __int64 v19; // x8
  __int64 *v20; // x8
  __int64 v21; // x8
  int *v22; // x8
  __int64 v23; // x8
  __int64 *v24; // x8
  int v25; // w21
  __int64 v26; // x0
  int v27; // w8
  __int64 v28; // x0
  __int64 v29; // x0
  _QWORD v30[7]; // [xsp+80h] [xbp-60h] BYREF
  __int64 *v31; // [xsp+B8h] [xbp-28h] BYREF
  __int64 **v32; // [xsp+C0h] [xbp-20h]
  _QWORD *v33; // [xsp+C8h] [xbp-18h]
  unsigned __int64 v34; // [xsp+D0h] [xbp-10h]

  v30[4] = a6;
  v30[5] = a7;
  v30[2] = a4;
  v30[3] = a5;
  v30[1] = a3;
  v30[6] = a8;
  if ( !a1 || *(_DWORD *)a1 != 2115074590 )
    return 3LL;
  if ( *(_DWORD *)(a1 + 8) )
    return 2LL;
  v33 = v30;
  v34 = 0xFFFFFF80FFFFFFD0LL;
  v31 = &a13;
  v32 = &v31;
  switch ( (int)a2 )
  {
    case 1:
      v15 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v15 > 0xFFFFFFF8 )
        v16 = (int *)v31++;
      else
        v16 = (int *)((char *)v32 + v15);
      v25 = *v16;
      result = 5LL;
      switch ( *v16 )
      {
        case 2:
          if ( !*(_QWORD *)(a1 + 248) )
          {
            v26 = sub_629507C(0, 0LL);
            *(_QWORD *)(a1 + 248) = v26;
            if ( !v26 )
              goto LABEL_47;
          }
          goto LABEL_46;
        case 3:
          goto LABEL_46;
        case 4:
          if ( !*(_QWORD *)(a1 + 264) )
          {
            *(_QWORD *)(a1 + 272) = 8LL;
            v28 = off_6C2D138(8LL, 184LL);
            *(_QWORD *)(a1 + 280) = 0LL;
            *(_QWORD *)(a1 + 264) = v28;
            if ( !v28 )
              goto LABEL_47;
          }
          goto LABEL_46;
        case 5:
          if ( *(_QWORD *)(a1 + 160) || !(unsigned int)sub_628C19C(a1 + 40, sub_62BDD44, 0LL, a1, 103LL) )
            goto LABEL_46;
          goto LABEL_47;
        case 6:
          return result;
        case 7:
          if ( *(_QWORD *)(a1 + 256) || (v29 = sub_629A7DC(5LL), (*(_QWORD *)(a1 + 256) = v29) != 0LL) )
          {
LABEL_46:
            result = 0LL;
            *(_DWORD *)(a1 + 4) |= 1 << v25;
          }
          else
          {
LABEL_47:
            result = 4LL;
          }
          break;
        default:
          goto LABEL_31;
      }
      break;
    case 2:
      v21 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v21 > 0xFFFFFFF8 )
        v22 = (int *)v31++;
      else
        v22 = (int *)((char *)v32 + v21);
      v27 = *v22;
      *(_DWORD *)(a1 + 4) &= ~(1 << v27);
      result = 0LL;
      switch ( v27 )
      {
        case 2:
          result = *(_QWORD *)(a1 + 248);
          if ( result )
          {
            sub_6296F48(
              result,
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              *(_QWORD *)&a9,
              *((_QWORD *)&a9 + 1),
              *(_QWORD *)&a10,
              *((_QWORD *)&a10 + 1),
              *(_QWORD *)&a11,
              *((_QWORD *)&a11 + 1),
              *(_QWORD *)&a12,
              *((_QWORD *)&a12 + 1));
            result = 0LL;
            *(_QWORD *)(a1 + 248) = 0LL;
          }
          break;
        case 3:
        case 5:
          return result;
        case 4:
          ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 264));
          result = 0LL;
          *(_QWORD *)(a1 + 264) = 0LL;
          break;
        case 7:
          if ( *(_QWORD *)(a1 + 256) )
            sub_629A824(a1 + 256);
          result = 0LL;
          break;
        default:
          goto LABEL_31;
      }
      break;
    case 3:
      v17 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v17 > 0xFFFFFFF8 )
        v18 = v31++;
      else
        v18 = (__int64 *)((char *)v32 + v17);
      result = 0LL;
      *(_QWORD *)(a1 + 16) = *v18;
      break;
    case 4:
      v23 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v23 > 0xFFFFFFF8 )
        v24 = v31++;
      else
        v24 = (__int64 *)((char *)v32 + v23);
      result = 0LL;
      *(_QWORD *)(a1 + 24) = *v24;
      break;
    case 5:
      v19 = (int)v34;
      LODWORD(v34) = v34 + 8;
      if ( (unsigned int)v19 > 0xFFFFFFF8 )
        v20 = v31++;
      else
        v20 = (__int64 *)((char *)v32 + v19);
      result = 0LL;
      *(_QWORD *)(a1 + 32) = *v20;
      break;
    default:
LABEL_31:
      result = 1LL;
      break;
  }
  return result;
}


================================================================================
Function: sub_62B9860 (0x62B9860)
================================================================================

__int64 __fastcall sub_62B9860(__int64 a1, char a2)
{
  __int64 v2; // x8
  void (*v3)(void); // x9

  v2 = *(_QWORD *)(a1 + 224);
  if ( !v2 )
    return 3LL;
  if ( ((*(_DWORD *)(v2 + 4) >> a2) & 1) != 0 )
  {
    v3 = *(void (**)(void))(v2 + 16);
    if ( v3 )
      v3();
  }
  return 0LL;
}


================================================================================
Function: sub_62B98A4 (0x62B98A4)
================================================================================

__int64 __fastcall sub_62B98A4(__int64 a1, char a2)
{
  __int64 v2; // x8
  void (*v3)(void); // x9

  v2 = *(_QWORD *)(a1 + 224);
  if ( !v2 )
    return 3LL;
  if ( ((*(_DWORD *)(v2 + 4) >> a2) & 1) != 0 )
  {
    v3 = *(void (**)(void))(v2 + 24);
    if ( v3 )
      v3();
  }
  return 0LL;
}


================================================================================
Function: sub_62B99E4 (0x62B99E4)
================================================================================

unsigned __int64 __fastcall sub_62B99E4(unsigned __int64 result)
{
  unsigned __int64 *v1; // x19
  unsigned __int64 *v2; // x21

  if ( result )
  {
    v1 = (unsigned __int64 *)result;
    do
    {
      v2 = (unsigned __int64 *)v1[1];
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*v1);
      *v1 = 0LL;
      result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v1);
      v1 = v2;
    }
    while ( v2 );
  }
  return result;
}


================================================================================
Function: sub_62B9A38 (0x62B9A38)
================================================================================

__int64 __fastcall sub_62B9A38(int *a1, char a2)
{
  __int64 result; // x0

  if ( pipe(a1) )
    return 0xFFFFFFFFLL;
  if ( !fcntl(*a1, 2, 1LL)
    && !fcntl(a1[1], 2, 1LL)
    && ((a2 & 1) == 0
     || (sub_62AF0A4((unsigned int)*a1, 1LL) & 0x80000000) == 0
     && (sub_62AF0A4((unsigned int)a1[1], 1LL) & 0x80000000) == 0) )
  {
    return 0LL;
  }
  close(*a1);
  close(a1[1]);
  result = 0xFFFFFFFFLL;
  *(_QWORD *)a1 = -1LL;
  return result;
}


================================================================================
Function: sub_62BB370 (0x62BB370)
================================================================================

__int64 *__fastcall sub_62BB370(__int64 a1, int a2, __int64 *a3)
{
  __int64 *v3; // x19
  __int64 *v6; // x23
  __int64 *v7; // x24
  __int64 v8; // x0
  __int64 v9; // x8
  __int64 *result; // x0
  __int64 v11; // x8
  __int64 v12; // x8
  __int64 v13; // [xsp+0h] [xbp-40h] BYREF
  __int64 v14; // [xsp+8h] [xbp-38h]

  if ( !a3 )
    return 0LL;
  v3 = a3;
  v6 = &v13;
  v7 = &v13;
  v13 = 0LL;
  v14 = 0LL;
  while ( 1 )
  {
    while ( 1 )
    {
      v8 = sub_62BBE7C(a1, a2, v3[4], v3[5]);
      if ( (v8 & 0x8000000000000000LL) == 0 )
        break;
      if ( !*v3 )
        goto LABEL_14;
      if ( sub_62BBE7C(a1, a2, *(_QWORD *)(*v3 + 32), *(_QWORD *)(*v3 + 40)) < 0 )
      {
        result = (__int64 *)*v3;
        *v3 = *(_QWORD *)(*v3 + 8);
        v12 = *result;
        result[1] = (__int64)v3;
        v3 = result;
        if ( !v12 )
          goto LABEL_15;
      }
      *v7 = (__int64)v3;
      v7 = v3;
      v3 = (__int64 *)*v3;
    }
    if ( !v8 )
      break;
    v9 = v3[1];
    if ( !v9 )
      break;
    if ( sub_62BBE7C(a1, a2, *(_QWORD *)(v9 + 32), *(_QWORD *)(v9 + 40)) >= 1 )
    {
      result = (__int64 *)v3[1];
      v3[1] = *result;
      v11 = result[1];
      *result = (__int64)v3;
      v3 = result;
      if ( !v11 )
        goto LABEL_15;
    }
    v6[1] = (__int64)v3;
    v6 = v3;
    v3 = (__int64 *)v3[1];
  }
LABEL_14:
  result = v3;
LABEL_15:
  v6[1] = *result;
  *v7 = result[1];
  *result = v14;
  result[1] = v13;
  return result;
}


================================================================================
Function: sub_62BB4C4 (0x62BB4C4)
================================================================================

_QWORD *__fastcall sub_62BB4C4(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v7; // x22
  __int64 v8; // x8
  _QWORD *result; // x0

  if ( !a3 )
  {
    *a4 = 0LL;
    a4[1] = 0LL;
LABEL_8:
    v7 = a4;
    a4[4] = a1;
    a4[5] = a2;
    a4[2] = a4;
    goto LABEL_9;
  }
  v7 = (_QWORD *)sub_62BB370(a1, a2, a3);
  if ( sub_62BBE7C(a1, a2, v7[4], v7[5]) )
  {
    if ( sub_62BBE7C(a1, a2, v7[4], v7[5]) < 0 )
    {
      *a4 = *v7;
      a4[1] = v7;
      *v7 = 0LL;
    }
    else
    {
      v8 = v7[1];
      *a4 = v7;
      a4[1] = v8;
      v7[1] = 0LL;
    }
    goto LABEL_8;
  }
  a4[2] = v7;
  a4[4] = -1LL;
  a4[5] = -1LL;
  a4[3] = v7[3];
  *(_QWORD *)(v7[3] + 16LL) = a4;
LABEL_9:
  result = v7;
  v7[3] = a4;
  return result;
}


================================================================================
Function: sub_62BB648 (0x62BB648)
================================================================================

__int64 __fastcall sub_62BB648(__int64 a1, _QWORD *a2, __int64 *a3)
{
  __int64 v4; // x21
  __int64 result; // x0
  _QWORD *v7; // x8
  __int64 v8; // x9
  __int64 v9; // x8
  __int64 v10; // x9
  __int64 v11; // x10
  __int64 v12; // x8

  if ( !a1 )
    return 1LL;
  v4 = a1;
  if ( sub_62BBE7C(-1LL, 0xFFFFFFFFLL, a2[4], a2[5]) )
  {
    if ( (_QWORD *)sub_62BB370(a2[4], a2[5], v4) != a2 )
      return 2LL;
    v4 = a2[2];
    if ( (_QWORD *)v4 == a2 )
    {
      if ( *a2 )
      {
        v4 = sub_62BB370(a2[4], a2[5], *a2);
        *(_QWORD *)(v4 + 8) = a2[1];
      }
      else
      {
        v4 = a2[1];
      }
    }
    else
    {
      *(_OWORD *)(v4 + 32) = *((_OWORD *)a2 + 2);
      v11 = *a2;
      v10 = a2[1];
      *(_QWORD *)(v4 + 24) = a2[3];
      v12 = a2[3];
      *(_QWORD *)v4 = v11;
      *(_QWORD *)(v4 + 8) = v10;
      *(_QWORD *)(v12 + 16) = v4;
    }
  }
  else
  {
    v7 = (_QWORD *)a2[2];
    if ( v7 == a2 )
      return 3LL;
    v8 = a2[3];
    *(_QWORD *)(v8 + 16) = v7;
    v9 = a2[2];
    a2[2] = a2;
    *(_QWORD *)(v9 + 24) = v8;
  }
  result = 0LL;
  *a3 = v4;
  return result;
}


================================================================================
Function: sub_62BB738 (0x62BB738)
================================================================================

__int64 __fastcall sub_62BB738(__int64 result, __int64 a2)
{
  *(_QWORD *)(result + 48) = a2;
  return result;
}


================================================================================
Function: sub_62BB748 (0x62BB748)
================================================================================

__int64 __fastcall sub_62BB748(unsigned __int8 a1)
{
  return byte_16AA780[a1];
}


================================================================================
Function: sub_62BB770 (0x62BB770)
================================================================================

bool __fastcall sub_62BB770(unsigned __int64 a1, unsigned __int64 a2)
{
  int v2; // w8
  unsigned __int8 *v3; // x9
  int v4; // t1

  if ( !a1 || !a2 )
    return (a1 | a2) == 0;
  v2 = *(unsigned __int8 *)a1;
  if ( *(_BYTE *)a1 )
  {
    v3 = (unsigned __int8 *)(a1 + 1);
    while ( *(_BYTE *)a2 )
    {
      if ( byte_16AA780[(unsigned __int8)v2] != byte_16AA780[*(unsigned __int8 *)a2] )
        return 0LL;
      v4 = *v3++;
      v2 = v4;
      ++a2;
      if ( !v4 )
        return (v2 != 0) ^ (*(_BYTE *)a2 == 0);
    }
  }
  return (v2 != 0) ^ (*(_BYTE *)a2 == 0);
}


================================================================================
Function: sub_62BB7E8 (0x62BB7E8)
================================================================================

bool __fastcall sub_62BB7E8(unsigned __int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int8 v3; // w9
  unsigned __int8 *v4; // x10
  int v5; // t1

  if ( !a1 || !a2 )
    return (a1 | a2) == 0 && a3 != 0;
  v3 = *(_BYTE *)a1;
  if ( *(_BYTE *)a1 )
  {
    v4 = (unsigned __int8 *)(a1 + 1);
    while ( *(_BYTE *)a2 && a3 )
    {
      if ( byte_16AA780[v3] != byte_16AA780[*(unsigned __int8 *)a2] )
        return 0LL;
      v5 = *v4++;
      v3 = v5;
      --a3;
      ++a2;
      if ( !v5 )
        break;
    }
  }
  return !a3 || byte_16AA780[v3] == byte_16AA780[*(unsigned __int8 *)a2];
}


================================================================================
Function: sub_62BB9C0 (0x62BB9C0)
================================================================================

_BYTE *__fastcall sub_62BB9C0(const void *a1, size_t a2)
{
  _BYTE *v4; // x0
  _BYTE *v5; // x21

  v4 = (_BYTE *)((__int64 (__fastcall *)(unsigned __int64))off_6C2D118[0])(a2 + 1);
  v5 = v4;
  if ( v4 )
  {
    memcpy(v4, a1, a2);
    v5[a2] = 0;
  }
  return v5;
}


================================================================================
Function: sub_62BBA78 (0x62BBA78)
================================================================================

const char *__fastcall sub_62BBA78(unsigned int a1)
{
  if ( a1 > 0x65 )
    return "Unknown error";
  else
    return (char *)dword_16AA980 + dword_16AA980[a1];
}


================================================================================
Function: sub_62BBBA0 (0x62BBBA0)
================================================================================

__int64 __fastcall sub_62BBBA0(const char *a1, const char **a2, int a3, __int64 *a4)
{
  const char *v7; // x20
  _DWORD *v8; // x23
  int v9; // w8
  __int64 result; // x0
  __int64 v11; // x8
  char *v12; // [xsp+0h] [xbp-10h] BYREF

  v7 = a1;
  v12 = 0LL;
  v8 = (_DWORD *)__errno(a1);
  *v8 = 0;
  *a4 = 0LL;
  while ( 1 )
  {
    v9 = *(unsigned __int8 *)v7;
    if ( v9 != 9 && v9 != 32 )
      break;
    ++v7;
  }
  if ( v9 == 45 || (unsigned int)(v9 - 10) <= 3 )
  {
    result = 2LL;
    if ( a2 )
      *a2 = v7;
  }
  else
  {
    v11 = strtol(v7, &v12, a3);
    if ( a2 )
      *a2 = v12;
    if ( *v8 == 34 )
    {
      return 1LL;
    }
    else if ( v7 == v12 )
    {
      return 2LL;
    }
    else
    {
      result = 0LL;
      *a4 = v11;
    }
  }
  return result;
}


================================================================================
Function: sub_62BBCA8 (0x62BBCA8)
================================================================================

unsigned __int64 *__fastcall sub_62BBCA8(unsigned __int64 *result, unsigned __int64 a2)
{
  unsigned __int64 *v2; // x2

  v2 = 0LL;
  if ( result && (a2 & 0x8000000000000000LL) == 0 )
  {
    if ( a2 )
    {
      *result = a2 / 0x3E8;
      result[1] = 1000 * (a2 % 0x3E8);
      return result;
    }
    v2 = result;
    *result = 0LL;
    result[1] = 0LL;
  }
  return v2;
}


================================================================================
Function: sub_62BBCF8 (0x62BBCF8)
================================================================================

__time_t sub_62BBCF8()
{
  __int64 v1; // [xsp+8h] [xbp-28h] BYREF
  struct timeval tv; // [xsp+18h] [xbp-18h] BYREF

  if ( !clock_gettime(4, (struct timespec *)&v1) || !clock_gettime(1, (struct timespec *)&v1) )
    return v1;
  gettimeofday(&tv, 0LL);
  return tv.tv_sec;
}


================================================================================
Function: sub_62BBD98 (0x62BBD98)
================================================================================

__int64 __fastcall sub_62BBD98(__int64 a1, int a2, __int64 a3, int a4)
{
  signed __int64 v4; // x8

  v4 = a1 - a3;
  if ( a1 - a3 > 0x20C49BA5E353F6LL )
    return 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 >= (__int64)0xFFDF3B645A1CAC0ALL )
    return 1000 * v4 + (a2 - a4) / 1000;
  return 0x8000000000000000LL;
}


================================================================================
Function: sub_62BBE08 (0x62BBE08)
================================================================================

__int64 __fastcall sub_62BBE08(__int64 a1, int a2, __int64 a3, int a4)
{
  signed __int64 v4; // x8

  v4 = a1 - a3;
  if ( a1 - a3 > 0x20C49BA5E353F6LL )
    return 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 >= (__int64)0xFFDF3B645A1CAC0ALL )
    return 1000 * v4 + (a2 - a4 + 999) / 1000;
  return 0x8000000000000000LL;
}


================================================================================
Function: sub_62BBE7C (0x62BBE7C)
================================================================================

__int64 __fastcall sub_62BBE7C(__int64 a1, int a2, __int64 a3, int a4)
{
  signed __int64 v4; // x8

  v4 = a1 - a3;
  if ( a1 - a3 > 0x8637BD05AF5LL )
    return 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 >= (__int64)0xFFFFF79C842FA50BLL )
    return 1000000 * v4 + a2 - a4;
  return 0x8000000000000000LL;
}


================================================================================
Function: sub_62BBFF8 (0x62BBFF8)
================================================================================

__int64 __fastcall sub_62BBFF8(__int64 a1, _BYTE *a2)
{
  __int64 v2; // x8
  int v3; // w9

  if ( a1 && (v2 = *(_QWORD *)(a1 + 24)) != 0 && (v3 = *(_DWORD *)(v2 + 964), v3 != -1) )
    return sub_6288620(a1, v3 == *(_DWORD *)(v2 + 572), a2);
  else
    return 2LL;
}


================================================================================
Function: sub_62BC5A8 (0x62BC5A8)
================================================================================

__int64 __fastcall sub_62BC5A8(__int64 result)
{
  int v1; // w9
  __int64 v2; // x11
  int v3; // w8

  v1 = *(_DWORD *)(result + 4692);
  v2 = *(_QWORD *)(result + 488);
  v3 = *(unsigned __int8 *)(result + 4690);
  *(_QWORD *)(result + 4256) = *(_QWORD *)(result + 592);
  *(_QWORD *)(result + 4264) = v2;
  *(_DWORD *)(result + 4692) = v1 & 0xFFFEFFFF | ((v3 == 4) << 16);
  return result;
}


================================================================================
Function: sub_62BD350 (0x62BD350)
================================================================================

// attributes: thunk
__int64 __fastcall sub_62BD350(__int64 a1, __int64 a2)
{
  return sub_62B42F0(a1, a2);
}


================================================================================
Function: sub_62BD354 (0x62BD354)
================================================================================

__int64 sub_62BD354()
{
  return sub_6288D84();
}


================================================================================
Function: sub_62BD3A4 (0x62BD3A4)
================================================================================

__int64 __fastcall sub_62BD3A4(__int64 a1, __int64 a2, __int64 a3, char a4, _QWORD *a5)
{
  __int64 v5; // x9
  int v10; // w10
  _BOOL8 v11; // x1
  __int64 result; // x0

  v5 = *(_QWORD *)(a1 + 24);
  v10 = *(_DWORD *)(v5 + 964);
  v11 = v10 != -1 && v10 == *(_DWORD *)(v5 + 572);
  result = sub_62899B8(a1, v11, a2, a3, a4 & 1, a5);
  if ( (_DWORD)result )
  {
    if ( (_DWORD)result == 81 )
    {
      result = 0LL;
      *a5 = 0LL;
    }
  }
  else
  {
    result = 0LL;
    if ( *a5 )
      *(_QWORD *)(a1 + 4720) += *a5;
  }
  return result;
}


================================================================================
Function: sub_62BD43C (0x62BD43C)
================================================================================

__int64 sub_62BD43C()
{
  sub_628971C();
  return 0LL;
}


================================================================================
Function: sub_62BD4C0 (0x62BD4C0)
================================================================================

__int64 __fastcall sub_62BD4C0(__int64 a1)
{
  __int64 v2; // x21
  __int64 v3; // x22
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  unsigned int v11; // w8
  __int64 result; // x0

  v2 = 0LL;
  v3 = a1 + 1784;
  do
  {
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v3 + v2));
    *(_QWORD *)(v3 + v2) = 0LL;
    v2 += 8LL;
  }
  while ( v2 != 496 );
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 2280));
  v4 = off_6C2D120[0];
  *(_QWORD *)(a1 + 2280) = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(*(_QWORD *)(a1 + 2288));
  v5 = off_6C2D120[0];
  *(_QWORD *)(a1 + 2288) = 0LL;
  ((void (__fastcall *)(_QWORD))v5)(*(_QWORD *)(a1 + 2296));
  v6 = off_6C2D120[0];
  *(_QWORD *)(a1 + 2296) = 0LL;
  ((void (__fastcall *)(_QWORD))v6)(*(_QWORD *)(a1 + 2304));
  v7 = off_6C2D120[0];
  *(_QWORD *)(a1 + 2304) = 0LL;
  ((void (__fastcall *)(_QWORD))v7)(*(_QWORD *)(a1 + 2312));
  v8 = off_6C2D120[0];
  *(_QWORD *)(a1 + 2312) = 0LL;
  ((void (__fastcall *)(_QWORD))v8)(*(_QWORD *)(a1 + 2320));
  v9 = off_6C2D120[0];
  *(_QWORD *)(a1 + 2320) = 0LL;
  ((void (__fastcall *)(_QWORD))v9)(*(_QWORD *)(a1 + 2328));
  v10 = off_6C2D120[0];
  *(_QWORD *)(a1 + 2328) = 0LL;
  ((void (__fastcall *)(_QWORD))v10)(*(_QWORD *)(a1 + 2336));
  v11 = *(_DWORD *)(a1 + 4692);
  *(_QWORD *)(a1 + 2336) = 0LL;
  if ( (v11 & 0x4000) != 0 )
  {
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 4352));
    v11 = *(_DWORD *)(a1 + 4692) & 0xFFFFBFFF;
    *(_DWORD *)(a1 + 4692) = v11;
  }
  *(_QWORD *)(a1 + 4352) = 0LL;
  if ( (v11 & 0x2000) != 0 )
  {
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 4344));
    *(_DWORD *)(a1 + 4692) &= ~0x2000u;
  }
  *(_QWORD *)(a1 + 4344) = 0LL;
  sub_62A7618(a1 + 856);
  result = sub_62B99E4(*(_QWORD *)(a1 + 4568));
  *(_QWORD *)(a1 + 4568) = 0LL;
  return result;
}


================================================================================
Function: sub_62BD5E8 (0x62BD5E8)
================================================================================

__int64 __fastcall sub_62BD5E8(unsigned __int64 *a1)
{
  unsigned __int64 v1; // x19
  __int64 v2; // x0
  char v3; // w8
  int v4; // w8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 v13; // x0
  __int64 v14; // x8
  __int64 (__fastcall *v15)(); // x8
  __int64 (__fastcall *v16)(); // x8
  __int64 (__fastcall *v17)(); // x8
  __int64 (__fastcall *v18)(); // x8
  __int64 (__fastcall *v19)(); // x8
  __int64 (__fastcall *v20)(); // x8
  __int64 (__fastcall *v21)(); // x8
  __int64 (__fastcall *v22)(); // x8
  __int64 (__fastcall *v23)(); // x8
  __int64 (__fastcall *v24)(); // x8
  __int64 (__fastcall *v25)(); // x8
  __int64 (__fastcall *v26)(); // x8
  __int64 (__fastcall *v27)(); // x8
  __int64 v28; // x0

  if ( a1 )
  {
    v1 = *a1;
    if ( *a1 )
    {
      *a1 = 0LL;
      sub_62AC16C(v1);
      if ( (*(_BYTE *)(v1 + 4694) & 2) == 0 )
      {
        v2 = *(_QWORD *)(v1 + 208);
        if ( v2 )
          sub_62ABCAC(v2, v1);
        if ( *(_QWORD *)(v1 + 216) )
        {
          sub_62AB918();
          *(_QWORD *)(v1 + 216) = 0LL;
        }
      }
      sub_62AC040(v1);
      v3 = *(_BYTE *)(v1 + 4693);
      *(_DWORD *)v1 = 0;
      if ( (v3 & 2) != 0 )
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v1 + 4232));
      sub_62B0E28(v1 + 232, v1);
      sub_62C8F90(v1);
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v1 + 2976));
      *(_QWORD *)(v1 + 2976) = 0LL;
      sub_62C9218(v1);
      if ( (*(_BYTE *)(v1 + 4693) & 0x40) != 0 )
      {
        ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v1 + 4352));
        v4 = *(_DWORD *)(v1 + 4692);
        *(_QWORD *)(v1 + 4352) = 0LL;
        *(_DWORD *)(v1 + 4692) = v4 & 0xFFFFBFFF;
      }
      v5 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4352) = 0LL;
      ((void (__fastcall *)(_QWORD))v5)(*(_QWORD *)(v1 + 4280));
      v6 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4280) = 0LL;
      ((void (__fastcall *)(_QWORD))v6)(*(_QWORD *)(v1 + 4288));
      v7 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4288) = 0LL;
      ((void (__fastcall *)(_QWORD))v7)(*(_QWORD *)(v1 + 4296));
      v8 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4296) = 0LL;
      ((void (__fastcall *)(_QWORD))v8)(*(_QWORD *)(v1 + 4304));
      v9 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4304) = 0LL;
      ((void (__fastcall *)(_QWORD))v9)(*(_QWORD *)(v1 + 4312));
      v10 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4312) = 0LL;
      ((void (__fastcall *)(_QWORD))v10)(*(_QWORD *)(v1 + 4320));
      v11 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4320) = 0LL;
      ((void (__fastcall *)(_QWORD))v11)(*(_QWORD *)(v1 + 4328));
      v12 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4328) = 0LL;
      ((void (__fastcall *)(_QWORD))v12)(*(_QWORD *)(v1 + 4336));
      v13 = *(_QWORD *)(v1 + 4272);
      *(_QWORD *)(v1 + 4336) = 0LL;
      sub_62C2DD4(v13);
      *(_QWORD *)(v1 + 4272) = 0LL;
      sub_628F4EC((unsigned __int64 *)(v1 + 2928));
      sub_6297194(v1, 1LL);
      sub_6293FCC(v1, *(_QWORD *)(v1 + 2480), *(_QWORD *)(v1 + 2200));
      sub_6293F24(v1 + 2480);
      sub_629AD1C(v1, *(_QWORD *)(v1 + 2472), *(char **)(v1 + 2208));
      v14 = *(_QWORD *)(v1 + 224);
      if ( !v14 || !*(_QWORD *)(v14 + 256) )
        sub_629A824((unsigned __int64 *)(v1 + 2472));
      sub_62B99E4(*(_QWORD *)(v1 + 2960));
      sub_62A62F4(v1);
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v1 + 4752));
      v15 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4752) = 0LL;
      ((void (__fastcall *)(_QWORD))v15)(*(_QWORD *)(v1 + 4760));
      *(_QWORD *)(v1 + 4760) = 0LL;
      sub_628DFFC(v1);
      sub_628DFEC(*(_QWORD *)(v1 + 3248));
      if ( *(_QWORD *)(v1 + 224) )
      {
        sub_62B9860(v1, 1);
        --*(_DWORD *)(*(_QWORD *)(v1 + 224) + 8LL);
        sub_62B98A4(v1, 1);
      }
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v1 + 4664));
      v16 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4664) = 0LL;
      ((void (__fastcall *)(_QWORD))v16)(*(_QWORD *)(v1 + 4584));
      v17 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4584) = 0LL;
      ((void (__fastcall *)(_QWORD))v17)(*(_QWORD *)(v1 + 4600));
      v18 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4600) = 0LL;
      ((void (__fastcall *)(_QWORD))v18)(*(_QWORD *)(v1 + 4592));
      v19 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4592) = 0LL;
      ((void (__fastcall *)(_QWORD))v19)(*(_QWORD *)(v1 + 4640));
      v20 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4640) = 0LL;
      ((void (__fastcall *)(_QWORD))v20)(*(_QWORD *)(v1 + 4608));
      v21 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4608) = 0LL;
      ((void (__fastcall *)(_QWORD))v21)(*(_QWORD *)(v1 + 4616));
      v22 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4616) = 0LL;
      ((void (__fastcall *)(_QWORD))v22)(*(_QWORD *)(v1 + 4624));
      v23 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4624) = 0LL;
      ((void (__fastcall *)(_QWORD))v23)(*(_QWORD *)(v1 + 4632));
      v24 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4632) = 0LL;
      ((void (__fastcall *)(_QWORD))v24)(*(_QWORD *)(v1 + 4648));
      v25 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4648) = 0LL;
      ((void (__fastcall *)(_QWORD))v25)(*(_QWORD *)(v1 + 4656));
      v26 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4656) = 0LL;
      ((void (__fastcall *)(_QWORD))v26)(*(_QWORD *)(v1 + 4672));
      v27 = off_6C2D120[0];
      *(_QWORD *)(v1 + 4672) = 0LL;
      ((void (__fastcall *)(_QWORD))v27)(*(_QWORD *)(v1 + 4680));
      v28 = *(_QWORD *)(v1 + 4376);
      *(_QWORD *)(v1 + 4680) = 0LL;
      sub_62A7618(v28);
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v1 + 4376));
      *(_QWORD *)(v1 + 4376) = 0LL;
      sub_62BD4C0(v1);
      sub_6298C9C(v1);
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1);
    }
  }
  return 0LL;
}


================================================================================
Function: sub_62BD930 (0x62BD930)
================================================================================

long double __fastcall sub_62BD930(__int64 a1)
{
  int *v1; // x20
  __int64 v3; // x22
  struct _IO_FILE *v4; // x10
  struct _IO_FILE *v5; // x9
  int v6; // w12
  __int64 v7; // x0
  __int16 v8; // w8
  __int64 v9; // x0
  int v10; // w10
  unsigned __int16 v11; // w8
  long double result; // q0

  v1 = (int *)(a1 + 2458);
  v3 = a1 + 776;
  v4 = stdin;
  *(_QWORD *)(a1 + 480) = stdout;
  *(_QWORD *)(a1 + 488) = v4;
  v5 = stderr;
  *(_QWORD *)(a1 + 792) = -1LL;
  *(_QWORD *)(a1 + 552) = -1LL;
  *(_QWORD *)(a1 + 456) = v5;
  LOWORD(v5) = *(_WORD *)(a1 + 2462);
  *(_QWORD *)(a1 + 568) = &fwrite;
  v6 = *(_DWORD *)(a1 + 2458);
  *(_QWORD *)(a1 + 592) = &fread;
  *(_DWORD *)(a1 + 1720) = 86400;
  *(_QWORD *)(a1 + 696) = 0LL;
  *(_QWORD *)(a1 + 528) = 30LL;
  *(_DWORD *)(a1 + 1728) = 60;
  *(_BYTE *)(a1 + 1321) = 0;
  *(_QWORD *)(a1 + 1712) = 5LL;
  *(_WORD *)(a1 + 1704) = 0;
  *(_BYTE *)(a1 + 1706) = 0;
  *(int64x2_t *)(a1 + 512) = vdupq_n_s64(1uLL);
  *(_BYTE *)(a1 + 1707) = 5;
  *(_WORD *)(a1 + 2462) = (_WORD)v5;
  *(_DWORD *)(a1 + 2458) = v6 & 0xFFFFFBFD | 0x400;
  sub_62A7714(a1 + 856);
  v7 = sub_62C7D54(a1);
  v8 = *((_WORD *)v1 + 2) | 0x600;
  *(_DWORD *)(a1 + 1780) = 420;
  *((_WORD *)v1 + 2) = v8;
  *(_QWORD *)(a1 + 2348) = 0xFFFFFFFFFLL;
  v9 = sub_62C8550(v7);
  if ( (_DWORD)v9 != 8 )
    sub_62C8550(v9);
  v10 = *v1;
  *(_DWORD *)(a1 + 2452) = 5;
  v11 = *((_WORD *)v1 + 2);
  *(_QWORD *)(a1 + 2376) = 1000LL;
  *(_DWORD *)(a1 + 2368) = 9;
  *(_QWORD *)(v3 + 956) = 0x1000000004000LL;
  *(_DWORD *)(a1 + 760) = 200;
  *(_QWORD *)(a1 + 2360) = 0x3C0000003CLL;
  result = *(long double *)&xmmword_AFE360;
  *(_QWORD *)(a1 + 2400) = 60000LL;
  *(_BYTE *)(a1 + 1322) = 2;
  *(_OWORD *)v3 = xmmword_AFE360;
  *v1 = v10 & 0x3EFFFFDB | 0x1000004;
  *((_WORD *)v1 + 2) = (v10 & 0x3EFFFFDB | ((unsigned __int64)v11 << 32) & 0xEFFE3EFFFFDBLL | 0x101000004LL) >> 32;
  return result;
}


================================================================================
Function: sub_62BDADC (0x62BDADC)
================================================================================

__int64 __fastcall sub_62BDADC(unsigned __int64 *a1)
{
  _DWORD *v2; // x0
  unsigned __int64 v3; // x20
  _DWORD *v4; // x22
  unsigned int v5; // w21
  int v6; // w9

  v2 = (_DWORD *)off_6C2D138(1LL, 4944LL);
  if ( v2 )
  {
    v3 = (unsigned __int64)v2;
    *v2 = -1059136595;
    v4 = v2 + 58;
    sub_62B0A48(v2 + 58);
    v5 = sub_628DFA4(v3, v3 + 3248);
    if ( v5 )
    {
      sub_62B0E28(v4, v3);
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v3);
    }
    else
    {
      sub_62BD930(v3);
      sub_628F4E0((_QWORD *)(v3 + 2928), 102400LL);
      sub_6297840(v3);
      v6 = *(_DWORD *)(v3 + 2604) | 0x10;
      *(_QWORD *)(v3 + 2416) = -1LL;
      *(_QWORD *)(v3 + 8) = -1LL;
      *(_QWORD *)(v3 + 16) = -1LL;
      *(_QWORD *)(v3 + 2912) = -1LL;
      *(_QWORD *)(v3 + 2920) = -1LL;
      *(_DWORD *)(v3 + 2604) = v6;
      *(_QWORD *)(v3 + 2968) = -1LL;
      sub_62A734C((_QWORD *)(v3 + 4424), 0LL);
      *a1 = v3;
    }
  }
  else
  {
    return 27;
  }
  return v5;
}


================================================================================
Function: sub_62BDBD4 (0x62BDBD4)
================================================================================

__int64 __fastcall sub_62BDBD4(__int64 a1, _QWORD *a2)
{
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 (__fastcall *v13)(); // x8
  __int64 (__fastcall *v14)(); // x8
  __int64 (__fastcall *v15)(); // x8
  __int64 (__fastcall *v16)(); // x8
  __int64 (__fastcall *v17)(); // x8
  __int64 (__fastcall *v18)(); // x8
  __int64 (__fastcall *v19)(); // x8
  __int64 (__fastcall *v20)(); // x1

  sub_628856C(a1, a2, 0LL);
  sub_628856C(a1, a2, 1LL);
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(a2[33]);
  v4 = off_6C2D120[0];
  a2[33] = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(a2[26]);
  v5 = off_6C2D120[0];
  a2[26] = 0LL;
  ((void (__fastcall *)(_QWORD))v5)(a2[34]);
  v6 = off_6C2D120[0];
  a2[34] = 0LL;
  ((void (__fastcall *)(_QWORD))v6)(a2[27]);
  v7 = off_6C2D120[0];
  a2[27] = 0LL;
  ((void (__fastcall *)(_QWORD))v7)(a2[28]);
  v8 = off_6C2D120[0];
  a2[28] = 0LL;
  ((void (__fastcall *)(_QWORD))v8)(a2[21]);
  v9 = off_6C2D120[0];
  a2[21] = 0LL;
  ((void (__fastcall *)(_QWORD))v9)(a2[60]);
  v10 = off_6C2D120[0];
  a2[60] = 0LL;
  ((void (__fastcall *)(_QWORD))v10)(a2[61]);
  v11 = off_6C2D120[0];
  a2[61] = 0LL;
  ((void (__fastcall *)(_QWORD))v11)(a2[63]);
  v12 = off_6C2D120[0];
  a2[63] = 0LL;
  ((void (__fastcall *)(_QWORD))v12)(a2[62]);
  v13 = off_6C2D120[0];
  a2[62] = 0LL;
  ((void (__fastcall *)(_QWORD))v13)(a2[64]);
  v14 = off_6C2D120[0];
  a2[64] = 0LL;
  ((void (__fastcall *)(_QWORD))v14)(a2[11]);
  v15 = off_6C2D120[0];
  a2[11] = 0LL;
  ((void (__fastcall *)(_QWORD))v15)(a2[17]);
  v16 = off_6C2D120[0];
  a2[17] = 0LL;
  ((void (__fastcall *)(_QWORD))v16)(a2[15]);
  v17 = off_6C2D120[0];
  a2[15] = 0LL;
  ((void (__fastcall *)(_QWORD))v17)(a2[16]);
  v18 = off_6C2D120[0];
  a2[16] = 0LL;
  ((void (__fastcall *)(_QWORD))v18)(a2[134]);
  a2[134] = 0LL;
  sub_62C8350(a2);
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(a2[133]);
  v19 = off_6C2D120[0];
  a2[133] = 0LL;
  ((void (__fastcall *)(_QWORD))v19)(a2[7]);
  v20 = off_6C2D120[0];
  a2[7] = 0LL;
  return ((__int64 (__fastcall *)(_QWORD *))v20)(a2);
}


================================================================================
Function: sub_62C1FB0 (0x62C1FB0)
================================================================================

char *__fastcall sub_62C1FB0(const char *a1)
{
  char *v1; // x0

  v1 = getenv(a1);
  if ( v1 && *v1 )
    return off_6C2D130(v1);
  else
    return 0LL;
}


================================================================================
Function: sub_62C2DD4 (0x62C2DD4)
================================================================================

unsigned __int64 *__fastcall sub_62C2DD4(unsigned __int64 *result)
{
  unsigned __int64 *v1; // x19

  if ( result )
  {
    v1 = result;
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*result);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1[1]);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1[2]);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1[3]);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1[4]);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1[5]);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1[6]);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1[7]);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1[8]);
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v1[9]);
    return (unsigned __int64 *)((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])((unsigned __int64)v1);
  }
  return result;
}


================================================================================
Function: sub_62C57A4 (0x62C57A4)
================================================================================

__int64 __fastcall sub_62C57A4(int a1)
{
  return a1 & 0x7FFFFFFF;
}


================================================================================
Function: sub_62C5D94 (0x62C5D94)
================================================================================

__int64 __fastcall sub_62C5D94(__int64 a1)
{
  __int64 (__fastcall *v2)(); // x8
  __int64 (__fastcall *v3)(); // x8
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 result; // x0
  char v7; // w8

  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)a1);
  *(_QWORD *)a1 = 0LL;
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 8));
  v2 = off_6C2D120[0];
  *(_QWORD *)(a1 + 8) = 0LL;
  ((void (__fastcall *)(_QWORD))v2)(*(_QWORD *)(a1 + 16));
  v3 = off_6C2D120[0];
  *(_QWORD *)(a1 + 16) = 0LL;
  ((void (__fastcall *)(_QWORD))v3)(*(_QWORD *)(a1 + 24));
  v4 = off_6C2D120[0];
  *(_QWORD *)(a1 + 24) = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(*(_QWORD *)(a1 + 32));
  v5 = off_6C2D120[0];
  *(_QWORD *)(a1 + 32) = 0LL;
  result = ((__int64 (__fastcall *)(_QWORD))v5)(*(_QWORD *)(a1 + 40));
  v7 = *(_BYTE *)(a1 + 53);
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = v7 & 0xFC;
  return result;
}


================================================================================
Function: sub_62C6AD8 (0x62C6AD8)
================================================================================

unsigned __int64 __fastcall sub_62C6AD8(__int64 a1)
{
  unsigned __int64 result; // x0

  result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}


================================================================================
Function: sub_62C7D54 (0x62C7D54)
================================================================================

long double __fastcall sub_62C7D54(__int64 a1)
{
  __int128 v1; // q0
  __int128 v2; // q1
  __int128 v3; // q2
  __int128 v4; // q0
  __int128 v5; // q1
  __int128 v6; // q0
  __int128 v7; // q2
  __int128 v8; // q1
  __int128 v9; // q0
  __int64 v10; // x10
  __int128 v11; // q1
  long double result; // q0

  v1 = *(_OWORD *)(a1 + 1392);
  v2 = *(_OWORD *)(a1 + 1408);
  v3 = *(_OWORD *)(a1 + 1328);
  *(_BYTE *)(a1 + 1433) |= 0xBu;
  *(_OWORD *)(a1 + 1576) = v1;
  v4 = *(_OWORD *)(a1 + 1456);
  *(_OWORD *)(a1 + 1512) = v3;
  *(_OWORD *)(a1 + 1592) = v2;
  v5 = *(_OWORD *)(a1 + 1472);
  *(_OWORD *)(a1 + 1640) = v4;
  v6 = *(_OWORD *)(a1 + 1488);
  v7 = *(_OWORD *)(a1 + 1440);
  *(_OWORD *)(a1 + 1656) = v5;
  v8 = *(_OWORD *)(a1 + 1344);
  *(_OWORD *)(a1 + 1672) = v6;
  v9 = *(_OWORD *)(a1 + 1360);
  *(_OWORD *)(a1 + 1624) = v7;
  v10 = *(_QWORD *)(a1 + 1504);
  *(_OWORD *)(a1 + 1528) = v8;
  v11 = *(_OWORD *)(a1 + 1376);
  *(_OWORD *)(a1 + 1544) = v9;
  result = *(long double *)(a1 + 1424);
  *(_QWORD *)(a1 + 1688) = v10;
  *(_OWORD *)(a1 + 1560) = v11;
  *(long double *)(a1 + 1608) = result;
  return result;
}


================================================================================
Function: sub_62C8350 (0x62C8350)
================================================================================

__int64 __fastcall sub_62C8350(_QWORD *a1)
{
  __int64 (__fastcall *v2)(); // x8
  __int64 (__fastcall *v3)(); // x8
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 (__fastcall *v13)(); // x8
  __int64 (__fastcall *v14)(); // x8
  __int64 (__fastcall *v15)(); // x8
  __int64 (__fastcall *v16)(); // x8
  __int64 (__fastcall *v17)(); // x8
  __int64 (__fastcall *v18)(); // x8
  __int64 (__fastcall *v19)(); // x8
  __int64 (__fastcall *v20)(); // x8
  __int64 (__fastcall *v21)(); // x8
  __int64 (__fastcall *v22)(); // x8
  __int64 (__fastcall *v23)(); // x8
  __int64 (__fastcall *v24)(); // x8
  __int64 result; // x0

  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(a1[87]);
  v2 = off_6C2D120[0];
  a1[87] = 0LL;
  ((void (__fastcall *)(_QWORD))v2)(a1[88]);
  v3 = off_6C2D120[0];
  a1[88] = 0LL;
  ((void (__fastcall *)(_QWORD))v3)(a1[89]);
  v4 = off_6C2D120[0];
  a1[89] = 0LL;
  ((void (__fastcall *)(_QWORD))v4)(a1[90]);
  v5 = off_6C2D120[0];
  a1[90] = 0LL;
  ((void (__fastcall *)(_QWORD))v5)(a1[91]);
  v6 = off_6C2D120[0];
  a1[91] = 0LL;
  ((void (__fastcall *)(_QWORD))v6)(a1[92]);
  v7 = off_6C2D120[0];
  a1[92] = 0LL;
  ((void (__fastcall *)(_QWORD))v7)(a1[93]);
  v8 = off_6C2D120[0];
  a1[93] = 0LL;
  ((void (__fastcall *)(_QWORD))v8)(a1[95]);
  v9 = off_6C2D120[0];
  a1[95] = 0LL;
  ((void (__fastcall *)(_QWORD))v9)(a1[96]);
  v10 = off_6C2D120[0];
  a1[96] = 0LL;
  ((void (__fastcall *)(_QWORD))v10)(a1[97]);
  v11 = off_6C2D120[0];
  a1[97] = 0LL;
  ((void (__fastcall *)(_QWORD))v11)(a1[98]);
  v12 = off_6C2D120[0];
  a1[98] = 0LL;
  ((void (__fastcall *)(_QWORD))v12)(a1[94]);
  v13 = off_6C2D120[0];
  a1[94] = 0LL;
  ((void (__fastcall *)(_QWORD))v13)(a1[101]);
  v14 = off_6C2D120[0];
  a1[101] = 0LL;
  ((void (__fastcall *)(_QWORD))v14)(a1[102]);
  v15 = off_6C2D120[0];
  a1[102] = 0LL;
  ((void (__fastcall *)(_QWORD))v15)(a1[103]);
  v16 = off_6C2D120[0];
  a1[103] = 0LL;
  ((void (__fastcall *)(_QWORD))v16)(a1[104]);
  v17 = off_6C2D120[0];
  a1[104] = 0LL;
  ((void (__fastcall *)(_QWORD))v17)(a1[105]);
  v18 = off_6C2D120[0];
  a1[105] = 0LL;
  ((void (__fastcall *)(_QWORD))v18)(a1[106]);
  v19 = off_6C2D120[0];
  a1[106] = 0LL;
  ((void (__fastcall *)(_QWORD))v19)(a1[107]);
  v20 = off_6C2D120[0];
  a1[107] = 0LL;
  ((void (__fastcall *)(_QWORD))v20)(a1[109]);
  v21 = off_6C2D120[0];
  a1[109] = 0LL;
  ((void (__fastcall *)(_QWORD))v21)(a1[110]);
  v22 = off_6C2D120[0];
  a1[110] = 0LL;
  ((void (__fastcall *)(_QWORD))v22)(a1[111]);
  v23 = off_6C2D120[0];
  a1[111] = 0LL;
  ((void (__fastcall *)(_QWORD))v23)(a1[112]);
  v24 = off_6C2D120[0];
  a1[112] = 0LL;
  result = ((__int64 (__fastcall *)(_QWORD))v24)(a1[108]);
  a1[108] = 0LL;
  return result;
}


================================================================================
Function: sub_62C8550 (0x62C8550)
================================================================================

__int64 sub_62C8550()
{
  sub_62C8574(0LL);
  return (unsigned int)*off_6C2D6B0;
}


================================================================================
Function: sub_62C8574 (0x62C8574)
================================================================================

__int64 __fastcall sub_62C8574(__int64 a1)
{
  __int64 result; // x0
  unsigned __int64 v3; // x0
  unsigned __int64 v4; // x19
  __int64 v5; // x8
  _QWORD *v6; // x22
  __int64 v7; // x8

  if ( (_UNKNOWN *)off_6C2D6B0 != &unk_6BA70A8 )
    return 1LL;
  if ( a1 )
  {
    result = 0LL;
    off_6C2D6B0 = a1;
    return result;
  }
  if ( !off_6C2D6B8 )
    return 1LL;
  v3 = sub_62C1FB0("CURL_SSL_BACKEND");
  v4 = v3;
  v5 = off_6C2D6B8;
  if ( !v3 || !off_6C2D6B8 )
    goto LABEL_13;
  v6 = &off_6C2D6B8;
  if ( !sub_62BB770(v3, *(_QWORD *)&byte_8[off_6C2D6B8]) )
  {
    while ( 1 )
    {
      v7 = v6[1];
      if ( !v7 )
        break;
      ++v6;
      if ( sub_62BB770(v4, *(_QWORD *)(v7 + 8)) )
        goto LABEL_9;
    }
    v5 = off_6C2D6B8;
LABEL_13:
    off_6C2D6B0 = v5;
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v4);
    return 0LL;
  }
LABEL_9:
  off_6C2D6B0 = *v6;
  ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v4);
  return 0LL;
}


================================================================================
Function: sub_62C8664 (0x62C8664)
================================================================================

__int64 sub_62C8664()
{
  if ( (byte_6F79610 & 1) != 0 )
    return 1LL;
  byte_6F79610 = 1;
  return (*(__int64 (**)(void))((char *)&qword_20 + off_6C2D6B0))();
}


================================================================================
Function: sub_62C899C (0x62C899C)
================================================================================

unsigned __int64 __fastcall sub_62C899C(__int64 a1)
{
  unsigned __int64 result; // x0
  unsigned __int64 v3; // x0
  __int64 (__fastcall *v4)(); // x8
  __int64 (__fastcall *v5)(); // x8
  __int64 (__fastcall *v6)(); // x8
  __int64 (__fastcall *v7)(); // x8
  __int64 (__fastcall *v8)(); // x8
  __int64 (__fastcall *v9)(); // x8
  __int64 (__fastcall *v10)(); // x8
  __int64 (__fastcall *v11)(); // x8
  __int64 (__fastcall *v12)(); // x8
  __int64 (__fastcall *v13)(); // x8
  __int64 (__fastcall *v14)(); // x8
  __int64 (__fastcall *v15)(); // x8

  result = *(_QWORD *)(a1 + 24);
  if ( result )
  {
    (*(void (__fastcall **)(unsigned __int64, _QWORD))(a1 + 40))(result, *(_QWORD *)(a1 + 32));
    *(_QWORD *)(a1 + 24) = 0LL;
    v3 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 40) = 0LL;
    *(_QWORD *)(a1 + 48) = 0LL;
    ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v3);
    v4 = off_6C2D120[0];
    *(_QWORD *)(a1 + 72) = 0LL;
    ((void (__fastcall *)(_QWORD))v4)(*(_QWORD *)(a1 + 80));
    v5 = off_6C2D120[0];
    *(_QWORD *)(a1 + 80) = 0LL;
    ((void (__fastcall *)(_QWORD))v5)(*(_QWORD *)(a1 + 88));
    v6 = off_6C2D120[0];
    *(_QWORD *)(a1 + 88) = 0LL;
    ((void (__fastcall *)(_QWORD))v6)(*(_QWORD *)(a1 + 96));
    v7 = off_6C2D120[0];
    *(_QWORD *)(a1 + 96) = 0LL;
    ((void (__fastcall *)(_QWORD))v7)(*(_QWORD *)(a1 + 104));
    v8 = off_6C2D120[0];
    *(_QWORD *)(a1 + 104) = 0LL;
    ((void (__fastcall *)(_QWORD))v8)(*(_QWORD *)(a1 + 112));
    v9 = off_6C2D120[0];
    *(_QWORD *)(a1 + 112) = 0LL;
    ((void (__fastcall *)(_QWORD))v9)(*(_QWORD *)(a1 + 120));
    v10 = off_6C2D120[0];
    *(_QWORD *)(a1 + 120) = 0LL;
    ((void (__fastcall *)(_QWORD))v10)(*(_QWORD *)(a1 + 136));
    v11 = off_6C2D120[0];
    *(_QWORD *)(a1 + 136) = 0LL;
    ((void (__fastcall *)(_QWORD))v11)(*(_QWORD *)(a1 + 144));
    v12 = off_6C2D120[0];
    *(_QWORD *)(a1 + 144) = 0LL;
    ((void (__fastcall *)(_QWORD))v12)(*(_QWORD *)(a1 + 152));
    v13 = off_6C2D120[0];
    *(_QWORD *)(a1 + 152) = 0LL;
    ((void (__fastcall *)(_QWORD))v13)(*(_QWORD *)(a1 + 160));
    v14 = off_6C2D120[0];
    *(_QWORD *)(a1 + 160) = 0LL;
    ((void (__fastcall *)(_QWORD))v14)(*(_QWORD *)(a1 + 128));
    v15 = off_6C2D120[0];
    *(_QWORD *)(a1 + 128) = 0LL;
    ((void (__fastcall *)(_QWORD))v15)(*(_QWORD *)a1);
    *(_QWORD *)a1 = 0LL;
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(a1 + 8));
    *(_QWORD *)(a1 + 8) = 0LL;
  }
  return result;
}


================================================================================
Function: sub_62C8F90 (0x62C8F90)
================================================================================

__int64 __fastcall sub_62C8F90(_QWORD *a1)
{
  unsigned __int64 v2; // x0
  __int64 v3; // x8
  unsigned __int64 v4; // x20
  __int64 v5; // x21

  v2 = a1[375];
  if ( v2 )
  {
    v3 = a1[28];
    if ( !v3 || (*(_BYTE *)(v3 + 4) & 0x10) == 0 )
    {
      if ( a1[214] )
      {
        ((void (*)(void))sub_62C899C)();
        if ( a1[214] >= 2uLL )
        {
          v4 = 1LL;
          v5 = 184LL;
          do
          {
            sub_62C899C(a1[375] + v5);
            ++v4;
            v5 += 184LL;
          }
          while ( v4 < a1[214] );
        }
        v2 = a1[375];
      }
      ((void (__fastcall *)(unsigned __int64))off_6C2D120[0])(v2);
      a1[375] = 0LL;
    }
  }
  return (*(__int64 (__fastcall **)(_QWORD *))((char *)off_88 + off_6C2D6B0))(a1);
}


================================================================================
Function: sub_62C9218 (0x62C9218)
================================================================================

unsigned __int64 __fastcall sub_62C9218(unsigned __int64 result)
{
  int v1; // w8
  unsigned __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x21
  __int64 v5; // x8

  v1 = *(_DWORD *)(result + 4904);
  if ( v1 )
  {
    v2 = result;
    if ( v1 >= 1 )
    {
      v3 = 0LL;
      do
      {
        v4 = 8 * v3;
        sub_62B99E4(*(_QWORD *)(*(_QWORD *)(v2 + 4912) + 8 * v3));
        v5 = *(int *)(v2 + 4904);
        ++v3;
        *(_QWORD *)(*(_QWORD *)(v2 + 4912) + v4) = 0LL;
      }
      while ( v3 < v5 );
    }
    result = ((unsigned __int64 (__fastcall *)(unsigned __int64))off_6C2D120[0])(*(_QWORD *)(v2 + 4912));
    *(_QWORD *)(v2 + 4912) = 0LL;
    *(_DWORD *)(v2 + 4904) = 0;
  }
  return result;
}


================================================================================
Function: sub_62C9454 (0x62C9454)
================================================================================

__int64 sub_62C9454()
{
  __int64 (*v0)(void); // x3

  v0 = *(__int64 (**)(void))((char *)off_50 + off_6C2D6B0);
  if ( v0 )
    return v0();
  else
    return 4LL;
}


================================================================================
Function: sub_632C70C (0x632C70C)
================================================================================

long double __fastcall sub_632C70C(__int64 a1)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_WORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 116) = 0;
  *(_QWORD *)a1 = "RbxStorage";
  *(_QWORD *)(a1 + 8) = 10LL;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 97) = 0u;
  *(_QWORD *)(a1 + 120) = 0LL;
  *(_BYTE *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0LL;
  *(_QWORD *)(a1 + 144) = 0LL;
  *(_QWORD *)(a1 + 152) = 0LL;
  *(_QWORD *)(a1 + 160) = 0LL;
  *(_QWORD *)(a1 + 168) = 0LL;
  *(_QWORD *)(a1 + 176) = 0LL;
  *(_QWORD *)(a1 + 184) = 0LL;
  *(_QWORD *)(a1 + 192) = 0LL;
  return result;
}


================================================================================
Function: sub_6416168 (0x6416168)
================================================================================

size_t __usercall sub_6416168@<X0>(__int128 *a1@<X0>, unsigned __int64 *a2@<X8>)
{
  size_t v3; // x22
  size_t v4; // x0
  unsigned __int64 v5; // x8
  bool v6; // zf
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x11
  char *v9; // x4
  char *v10; // x8
  char *v11; // x9
  unsigned __int64 v12; // x11
  __int64 v13; // x12
  __int64 v14; // x14
  char *v15; // x5
  size_t v16; // x22
  size_t v17; // x0
  unsigned __int64 v18; // x8
  bool v19; // zf
  unsigned __int64 v20; // x8
  unsigned __int64 v21; // x11
  char *v22; // x4
  char *v23; // x8
  char *v24; // x9
  unsigned __int64 v25; // x11
  __int64 v26; // x12
  __int64 v27; // x14
  char *v28; // x5
  size_t v29; // x22
  size_t result; // x0
  unsigned __int64 v31; // x8
  bool v32; // zf
  unsigned __int64 v33; // x8
  unsigned __int64 v34; // x11
  char *v35; // x4
  char *v36; // x8
  char *v37; // x9
  unsigned __int64 v38; // x11
  __int64 v39; // x12
  __int64 v40; // x14
  char *v41; // x5
  const char *v42; // [xsp+0h] [xbp-20h] BYREF
  char *v43; // [xsp+8h] [xbp-18h]

  sub_67D2788(a2, a1);
  v3 = __strlen_chk(" ", 2uLL);
  v4 = __strlen_chk("\\ ", 3uLL);
  v5 = *(unsigned __int8 *)a2;
  v6 = (v5 & 1) == 0;
  v7 = v5 >> 1;
  if ( v6 )
    v8 = v7;
  else
    v8 = a2[1];
  if ( v6 )
    v9 = (char *)a2 + 1;
  else
    v9 = (char *)a2[2];
  if ( v8 && v3 )
  {
    v10 = &asc_B51E2C[v3];
    v11 = &v9[v8];
    v12 = v8 - 1;
    while ( 2 )
    {
      v13 = 0LL;
      do
      {
        if ( v9[v13] != asc_B51E2C[v13] )
        {
          v15 = &v9[v13];
          if ( &asc_B51E2C[v13] == v10 )
            goto LABEL_20;
          goto LABEL_18;
        }
        v14 = v13 + 1;
        if ( v12 == v13 )
          break;
        v6 = v3 - 1 == v13++;
      }
      while ( !v6 );
      v15 = &v9[v14];
      if ( &asc_B51E2C[v14] == v10 )
      {
LABEL_20:
        if ( v9 != v15 )
        {
          v42 = " ";
          v43 = &asc_B51E2C[v3];
          sub_2D35AC0(a2, &v42, "\\ ", &asc_C9AB55[v4], v9, v15, "\\ ", &asc_C9AB55[v4]);
        }
        break;
      }
LABEL_18:
      ++v9;
      --v12;
      if ( v9 != v11 )
        continue;
      break;
    }
  }
  v16 = __strlen_chk(",", 2uLL);
  v17 = __strlen_chk("\\,", 3uLL);
  v18 = *(unsigned __int8 *)a2;
  v19 = (v18 & 1) == 0;
  v20 = v18 >> 1;
  if ( v19 )
    v21 = v20;
  else
    v21 = a2[1];
  if ( v19 )
    v22 = (char *)a2 + 1;
  else
    v22 = (char *)a2[2];
  if ( v21 && v16 )
  {
    v23 = &asc_BA4898[v16];
    v24 = &v22[v21];
    v25 = v21 - 1;
    while ( 2 )
    {
      v26 = 0LL;
      do
      {
        if ( v22[v26] != asc_BA4898[v26] )
        {
          v28 = &v22[v26];
          if ( &asc_BA4898[v26] == v23 )
            goto LABEL_41;
          goto LABEL_39;
        }
        v27 = v26 + 1;
        if ( v25 == v26 )
          break;
        v6 = v16 - 1 == v26++;
      }
      while ( !v6 );
      v28 = &v22[v27];
      if ( &asc_BA4898[v27] == v23 )
      {
LABEL_41:
        if ( v22 != v28 )
        {
          v42 = ",";
          v43 = &asc_BA4898[v16];
          sub_2D35AC0(a2, &v42, "\\,", &asc_BD4465[v17], v22, v28, "\\,", &asc_BD4465[v17]);
        }
        break;
      }
LABEL_39:
      ++v22;
      --v25;
      if ( v22 != v24 )
        continue;
      break;
    }
  }
  v29 = __strlen_chk("=", 2uLL);
  result = __strlen_chk("\\=", 3uLL);
  v31 = *(unsigned __int8 *)a2;
  v32 = (v31 & 1) == 0;
  v33 = v31 >> 1;
  if ( v32 )
    v34 = v33;
  else
    v34 = a2[1];
  if ( v32 )
    v35 = (char *)a2 + 1;
  else
    v35 = (char *)a2[2];
  if ( v34 && v29 )
  {
    v36 = &asc_C19E5D[v29];
    v37 = &v35[v34];
    v38 = v34 - 1;
    while ( 2 )
    {
      v39 = 0LL;
      do
      {
        if ( v35[v39] != asc_C19E5D[v39] )
        {
          v41 = &v35[v39];
          if ( &asc_C19E5D[v39] == v36 )
            goto LABEL_62;
          goto LABEL_60;
        }
        v40 = v39 + 1;
        if ( v38 == v39 )
          break;
        v6 = v29 - 1 == v39++;
      }
      while ( !v6 );
      v41 = &v35[v40];
      if ( &asc_C19E5D[v40] == v36 )
      {
LABEL_62:
        if ( v35 != v41 )
        {
          v42 = "=";
          v43 = &asc_C19E5D[v29];
          return sub_2D35AC0(a2, &v42, "\\=", &asc_BE5B64[result], v35, v41, "\\=", &asc_BE5B64[result]);
        }
        return result;
      }
LABEL_60:
      ++v35;
      --v38;
      if ( v35 != v37 )
        continue;
      break;
    }
  }
  return result;
}


================================================================================
Function: sub_6416518 (0x6416518)
================================================================================

__int64 __fastcall sub_6416518(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x9
  __int64 v3; // x8
  unsigned __int64 v4; // x10
  size_t v5; // x19
  const char *v6; // x21
  unsigned __int8 *v7; // x20
  unsigned __int64 v8; // x22
  char *v9; // x0
  char *v10; // x23

  v2 = *a2;
  v3 = *((_QWORD *)a2 + 1);
  if ( (v2 & 1) == 0 )
    v3 = v2 >> 1;
  if ( !v3 )
    return 1LL;
  v4 = *a1;
  if ( (v4 & 1) != 0 )
    v5 = *((_QWORD *)a1 + 1);
  else
    v5 = v4 >> 1;
  if ( v5 )
  {
    v6 = (v2 & 1) != 0 ? (const char *)*((_QWORD *)a2 + 2) : (const char *)(a2 + 1);
    v7 = (v4 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a1 + 2) : a1 + 1;
    if ( v3 >= 1 )
    {
      v8 = (unsigned __int64)&v6[v3];
      while ( 1 )
      {
        v9 = strchr(v6, 59);
        v10 = v9 ? v9 : (char *)v8;
        if ( v5 == (_DWORD)v10 - (_DWORD)v6 && (!((v10 - v6) << 32) || !memcmp(v6, v7, v5)) )
          break;
        v6 = v10 + 1;
        if ( (unsigned __int64)(v10 + 1) >= v8 )
          return 0LL;
      }
      return 1LL;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_6416634 (0x6416634)
================================================================================

__int64 __fastcall sub_6416634(__int64 a1, _BYTE *a2, __int64 a3)
{
  __int64 v4; // x20
  __int64 v7; // x1

  v4 = a3;
  sub_658A084(a1, a3 + 10);
  sub_6589DEC(a1, 34LL);
  for ( ; v4; ++a2 )
  {
    v7 = (unsigned __int8)*a2;
    if ( !*a2 )
      break;
    if ( (unsigned __int8)(v7 - 127) < 0xA1u )
    {
      v7 = 32LL;
    }
    else if ( (_DWORD)v7 == 92 || (_DWORD)v7 == 34 )
    {
      sub_6589DEC(a1, 92LL);
      v7 = (unsigned __int8)*a2;
    }
    sub_6589DEC(a1, v7);
    --v4;
  }
  return sub_6589DEC(a1, 34LL);
}


================================================================================
Function: sub_64166D4 (0x64166D4)
================================================================================

__int64 __fastcall sub_64166D4(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x9
  bool v3; // zf
  unsigned __int64 v4; // x9
  _BYTE *v5; // x1
  __int64 v6; // x2

  v2 = *a2;
  v3 = (v2 & 1) == 0;
  if ( (v2 & 1) != 0 )
    v4 = *((_QWORD *)a2 + 1);
  else
    v4 = v2 >> 1;
  if ( v3 )
    v5 = a2 + 1;
  else
    v5 = (_BYTE *)*((_QWORD *)a2 + 2);
  if ( v4 >= 0xF000 )
    v6 = 61440LL;
  else
    v6 = v4;
  return sub_6416634(a1, v5, v6);
}


================================================================================
Function: sub_6416790 (0x6416790)
================================================================================

long double __fastcall sub_6416790(__int64 a1)
{
  long double result; // q0
  __int64 v3; // x8
  long double v4; // [xsp+0h] [xbp-20h] BYREF
  __int64 v5; // [xsp+10h] [xbp-10h]

  sub_6579D18("%di", &v4);
  if ( (*(_BYTE *)a1 & 1) != 0 )
    sub_6575460();
  result = v4;
  v3 = v5;
  *(long double *)a1 = v4;
  *(_QWORD *)(a1 + 16) = v3;
  return result;
}


================================================================================
Function: sub_6416970 (0x6416970)
================================================================================

unsigned __int8 *__fastcall sub_6416970(unsigned __int8 *result)
{
  int v1; // w8
  __int64 i; // x8
  int v3; // w11
  bool v4; // cf
  bool v5; // cf

  if ( result )
  {
    v1 = *result;
    if ( (unsigned int)(v1 - 48) < 0xA || (unsigned int)(v1 - 65) < 0x1A || (unsigned int)(v1 - 97) <= 0x19 )
    {
      for ( i = 1LL; ; ++i )
      {
        v3 = result[i];
        v4 = (unsigned int)(v3 - 48) >= 0xA && (unsigned int)(v3 - 65) >= 0x1A;
        v5 = v4 && (unsigned int)(v3 - 97) >= 0x1A;
        if ( v5 && ((unsigned int)(v3 - 37) > 0x3A || ((1LL << ((unsigned __int8)v3 - 37)) & 0x400000000200701LL) == 0) )
          break;
      }
      return (unsigned __int8 *)((v3 == 0) & (unsigned __int8)((unsigned int)i < 0x81));
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}


================================================================================
Function: sub_6416B58 (0x6416B58)
================================================================================

__int64 __fastcall sub_6416B58(__int64 a1, signed int a2, int a3)
{
  __int64 v6; // x0
  signed int v7; // w8
  bool v8; // w8

  v6 = sub_25D550C(a1, 0LL);
  *(_QWORD *)(a1 + 392) = 0LL;
  *(_QWORD *)(a1 + 400) = 0LL;
  *(_QWORD *)(a1 + 408) = 0LL;
  *(_DWORD *)(a1 + 416) = a3;
  if ( a2 == -1 )
  {
    v8 = 1;
  }
  else
  {
    v7 = dword_6C2FC88;
    if ( dword_6C2FC88 == -1 )
    {
      v6 = sub_657A0FC(v6);
      v7 = (unsigned int)v6 % 0x2710;
      dword_6C2FC88 = (unsigned int)v6 % 0x2710;
    }
    v8 = v7 < a2;
  }
  *(_BYTE *)(a1 + 420) = v8;
  *(_QWORD *)(a1 + 432) = 0LL;
  *(_QWORD *)(a1 + 440) = 0LL;
  *(_QWORD *)(a1 + 424) = 0LL;
  *(_DWORD *)(a1 + 452) = 0;
  return sub_6537108(v6);
}


================================================================================
Function: sub_6416C3C (0x6416C3C)
================================================================================

__int64 __usercall sub_6416C3C@<X0>(
        unsigned __int8 *a1@<X0>,
        __int64 a2@<X1>,
        unsigned __int8 *a3@<X2>,
        int a4@<W3>,
        unsigned __int64 *a5@<X8>)
{
  unsigned __int8 v8; // w9
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x8
  bool v11; // zf
  size_t v12; // x8
  void *v13; // x1
  size_t v14; // x2
  unsigned __int64 v15; // x8
  bool v16; // zf
  size_t v17; // x8
  __int128 *v18; // x8
  char *v19; // x1
  size_t v20; // x2
  __int64 v21; // x0
  unsigned __int8 *v22; // x0
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x8
  _QWORD *v25; // x0
  __int64 v26; // x0
  __int128 *v27; // x1
  size_t v28; // x2
  _QWORD *v29; // x0
  __int64 v30; // x0
  char *v31; // x1
  size_t v32; // x2
  __int64 v33; // x0
  char *v34; // x1
  size_t v35; // x2
  __int64 v36; // x0
  char *v37; // x1
  size_t v38; // x2
  __int64 v39; // x0
  char *v40; // x1
  size_t v41; // x2
  unsigned __int64 *v42; // x0
  unsigned __int64 v43; // x8
  char *v44; // x1
  size_t v45; // x2
  unsigned __int64 v46; // x8
  char v47; // w21
  size_t v48; // x2
  unsigned __int64 v49; // x8
  unsigned __int8 *v50; // x8
  unsigned __int8 *v51; // x1
  unsigned __int64 v52; // x9
  int v53; // w10
  int v54; // t1
  int v55; // t1
  _BOOL4 v56; // w22
  __int128 *v58; // x1
  size_t v59; // x2
  __int128 *v60; // x1
  size_t v61; // x2
  __int64 v62; // x0
  unsigned __int64 v63; // x8
  unsigned __int64 v64; // x8
  char *v65; // x1
  size_t v66; // x2
  int v67; // w21
  unsigned __int64 v68; // x8
  unsigned __int64 v69; // x8
  __int128 *v70; // x1
  size_t v71; // x2
  __int64 v72; // x0
  unsigned __int64 v73; // x8
  char *v74; // x1
  size_t v75; // x2
  char v76; // w0
  char v77; // w9
  int v78; // w21
  size_t v79; // x10
  unsigned __int64 v80; // x8
  __int64 v81; // x11
  size_t v82; // x2
  unsigned __int64 v83; // x9
  unsigned __int8 *v84; // x9
  const char *v85; // x0
  unsigned __int8 *v86; // x1
  unsigned __int64 v87; // x8
  int v88; // w10
  int v89; // t1
  int v90; // w11
  int v91; // t1
  __int64 v93; // x0
  unsigned __int64 v94; // x8
  __int128 *v95; // x1
  size_t v96; // x2
  unsigned __int64 v97; // x8
  __int128 *v98; // x1
  size_t v99; // x2
  char *v100; // x1
  size_t v101; // x2
  unsigned __int64 *v102; // x0
  char *v103; // x0
  char *v104; // x0
  unsigned __int64 *v105; // x0
  unsigned __int64 v106; // x8
  char *v107; // x1
  size_t v108; // x2
  unsigned __int64 v109; // x8
  char *v110; // x22
  size_t v111; // x0
  unsigned __int64 v112; // x8
  unsigned __int8 v113; // w8
  unsigned __int8 *i; // x21
  unsigned __int64 v115; // x8
  unsigned __int64 v116; // x8
  unsigned __int64 v117; // x8
  bool v118; // zf
  unsigned __int64 v119; // x8
  char *v120; // x1
  size_t v121; // x2
  __int128 *v122; // x1
  size_t v123; // x2
  __int128 *v124; // x8
  char *v125; // x1
  size_t v126; // x2
  __int64 v127; // x22
  _QWORD *v128; // x8
  _QWORD *v129; // x28
  unsigned int v130; // w9
  unsigned int *v131; // x21
  int v132; // w10
  unsigned int v133; // w11
  __int64 v134; // x13
  _QWORD *v135; // x24
  char *v136; // x1
  size_t v137; // x2
  int v138; // w8
  unsigned __int64 v139; // x9
  char *v140; // x1
  size_t v141; // x2
  __int64 **j; // x22
  unsigned __int64 v143; // x8
  bool v144; // zf
  size_t v145; // x8
  __int64 *v146; // x1
  size_t v147; // x2
  unsigned __int64 v148; // x8
  bool v149; // zf
  size_t v150; // x8
  __int64 *v151; // x1
  size_t v152; // x2
  unsigned __int64 v153; // x8
  bool v154; // zf
  unsigned __int64 v155; // x8
  const char *v156; // x24
  unsigned __int64 v157; // x10
  size_t v158; // x0
  size_t v159; // x25
  char *v160; // x22
  unsigned __int64 v161; // x27
  const char *v162; // x0
  const char *v163; // x0
  __int64 v164; // x0
  _QWORD *v165; // x22
  _QWORD *v166; // x8
  unsigned int v167; // w9
  int v168; // w10
  unsigned int v169; // w11
  _QWORD *v170; // x13
  _QWORD *v171; // x24
  unsigned __int64 v172; // x9
  const char *v173; // x0
  unsigned int v174; // w8
  unsigned __int64 v175; // x9
  const char *v176; // x8
  const char *v177; // x25
  size_t v178; // x0
  size_t v179; // x24
  char *v180; // x22
  unsigned __int64 v181; // x9
  const char *v182; // x0
  unsigned int v183; // w8
  unsigned __int64 v184; // x27
  const char *v185; // x0
  char *v186; // x1
  size_t v187; // x2
  bool v188; // zf
  size_t v189; // x8
  size_t v190; // x2
  char *v191; // x1
  bool v192; // zf
  size_t v193; // x8
  size_t v194; // x2
  char *v195; // x1
  _QWORD *v196; // x0
  __int64 v197; // x0
  unsigned __int64 v198; // x8
  unsigned __int64 v199; // x9
  const char *v200; // x0
  unsigned int v201; // w8
  bool v202; // zf
  size_t v203; // x8
  size_t v204; // x2
  char *v205; // x1
  char v206; // w9
  int v207; // w24
  size_t v208; // x10
  unsigned __int64 v209; // x8
  __int64 v210; // x11
  size_t v211; // x2
  unsigned __int64 v212; // x9
  unsigned __int8 *v213; // x9
  unsigned __int8 *v214; // x1
  unsigned __int64 v215; // x8
  int v216; // w10
  int v217; // t1
  int v218; // w11
  int v219; // t1
  int v221; // w8
  __int64 v222; // x0
  __int64 v223; // x0
  unsigned __int64 v224; // x9
  char *v225; // x1
  size_t v226; // x2
  unsigned __int64 v227; // x8
  char *v228; // x1
  size_t v229; // x2
  unsigned __int64 v230; // x8
  __int64 v231; // x0
  unsigned __int64 v232; // x8
  int v233; // w9
  unsigned __int64 v234; // x10
  unsigned __int64 v235; // x11
  char *v236; // x1
  size_t v237; // x2
  char v238; // w9
  int v239; // w24
  size_t v240; // x10
  unsigned __int64 v241; // x8
  __int64 v242; // x11
  size_t v243; // x2
  unsigned __int64 v244; // x9
  unsigned __int8 *v245; // x9
  unsigned __int8 *v246; // x1
  unsigned __int64 v247; // x8
  int v248; // w10
  int v249; // t1
  int v250; // w11
  int v251; // t1
  unsigned __int64 v253; // x8
  char *v254; // x1
  size_t v255; // x2
  unsigned __int64 v256; // x8
  char *v257; // x1
  size_t v258; // x2
  char *v259; // x1
  size_t v260; // x2
  char *v261; // x1
  size_t v262; // x2
  __int64 v263; // x0
  char *v264; // x1
  size_t v265; // x2
  unsigned __int64 v266; // x8
  char *v267; // x1
  size_t v268; // x2
  char *v269; // x1
  size_t v270; // x2
  char *v271; // x1
  size_t v272; // x2
  __int64 v273; // x0
  __int64 v274; // x4
  __int64 v275; // x5
  __int64 v276; // x6
  __int64 v277; // x7
  long double v278; // q0
  long double v279; // q1
  long double v280; // q2
  long double v281; // q3
  int v282; // w8
  unsigned int v283; // w10
  unsigned __int8 *v284; // x9
  unsigned int v285; // w11
  _QWORD *v286; // x13
  unsigned __int8 *v287; // x21
  unsigned __int8 *v288; // x22
  unsigned int v289; // w11
  unsigned __int64 v290; // x13
  unsigned __int64 v291; // x14
  unsigned __int64 v292; // x12
  __int64 v293; // x13
  bool v294; // zf
  unsigned int v295; // w8
  unsigned __int8 *v296; // x23
  unsigned __int64 v297; // x8
  bool v298; // zf
  size_t v299; // x8
  void *v300; // x1
  size_t v301; // x2
  unsigned __int64 v302; // x9
  char *v303; // x10
  char *v304; // x8
  _BYTE *v305; // x12
  unsigned __int64 v306; // x13
  unsigned __int64 v307; // d0
  __int128 v308; // q0
  const char *v309; // x8
  char *v310; // x1
  size_t v311; // x2
  unsigned __int64 v312; // x9
  unsigned __int64 v313; // x10
  unsigned __int64 v314; // x8
  unsigned __int8 *v315; // x9
  unsigned __int8 *v316; // x10
  char *v317; // x9
  __int64 v318; // x1
  __int64 v319; // x3
  char *v320; // x1
  size_t v321; // x2
  char *v322; // x1
  size_t v323; // x2
  __int64 result; // x0
  __int64 v325; // [xsp+0h] [xbp-180h]
  unsigned int v328; // [xsp+24h] [xbp-15Ch]
  _QWORD *v329; // [xsp+28h] [xbp-158h]
  __int128 *v330; // [xsp+30h] [xbp-150h]
  unsigned __int64 v331[2]; // [xsp+38h] [xbp-148h] BYREF
  char v332; // [xsp+50h] [xbp-130h] BYREF
  char v333[12]; // [xsp+51h] [xbp-12Fh] BYREF
  __int128 v334; // [xsp+68h] [xbp-118h] BYREF
  char *v335; // [xsp+78h] [xbp-108h]
  unsigned __int64 v336[2]; // [xsp+80h] [xbp-100h] BYREF
  unsigned __int64 v337[2]; // [xsp+98h] [xbp-E8h] BYREF
  _BYTE v338[16]; // [xsp+B0h] [xbp-D0h] BYREF
  unsigned __int64 v339[2]; // [xsp+C8h] [xbp-B8h] BYREF
  __int64 v340; // [xsp+E0h] [xbp-A0h] BYREF
  size_t v341; // [xsp+E8h] [xbp-98h]
  const char *v342; // [xsp+F0h] [xbp-90h]
  unsigned __int64 v343[2]; // [xsp+F8h] [xbp-88h] BYREF
  unsigned __int64 v344[2]; // [xsp+110h] [xbp-70h] BYREF
  __int128 v345; // [xsp+128h] [xbp-58h] BYREF
  char *v346; // [xsp+138h] [xbp-48h]
  __int128 v347; // [xsp+140h] [xbp-40h] BYREF
  const char *v348; // [xsp+150h] [xbp-30h]

  v8 = atomic_load(byte_6F76810);
  if ( (v8 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6F76810) )
  {
    qword_6F767D0 = (__int64)off_67F87E8;
    sub_67D19DC((pthread_mutex_t *)algn_6F767D8);
    qword_6F76800 = 0LL;
    unk_6F76808 = 0LL;
    qword_6F767D0 = (__int64)off_6BA3740;
    qword_6F76818 = (__int64)&qword_6F767D0;
    sub_67EB838(byte_6F76810);
  }
  v330 = (__int128 *)sub_621054C(&qword_6F767D0);
  a5[1] = 0LL;
  a5[2] = 0LL;
  *a5 = 0LL;
  sub_658A084(a5, 0x400uLL);
  if ( !byte_71CF7B0 || !byte_71C5168 )
    goto LABEL_13;
  v9 = qword_6F7A5F8;
  if ( (word_6F7A5F0 & 1) == 0 )
    v9 = (unsigned __int64)(unsigned __int8)word_6F7A5F0 >> 1;
  if ( v9 )
  {
    sub_67D352C(a5, "romark-");
    v10 = *a1;
    v11 = (v10 & 1) == 0;
    v12 = v10 >> 1;
    if ( v11 )
      v13 = a1 + 1;
    else
      v13 = (void *)*((_QWORD *)a1 + 2);
    if ( v11 )
      v14 = v12;
    else
      v14 = *((_QWORD *)a1 + 1);
  }
  else
  {
LABEL_13:
    v15 = *a1;
    v16 = (v15 & 1) == 0;
    v17 = v15 >> 1;
    if ( v16 )
      v13 = a1 + 1;
    else
      v13 = (void *)*((_QWORD *)a1 + 2);
    if ( v16 )
      v14 = v17;
    else
      v14 = *((_QWORD *)a1 + 1);
  }
  sub_6588400(a5, v13, v14);
  sub_67D352C(a5, ",");
  v18 = v330;
  if ( v330 )
    v18 = (__int128 *)*((_QWORD *)v330 + 6);
  sub_67D2788((unsigned __int64 *)&v347, v18 + 1);
  if ( (v347 & 1) != 0 )
    v19 = (char *)v348;
  else
    v19 = (char *)&v347 + 1;
  if ( (v347 & 1) != 0 )
    v20 = *((_QWORD *)&v347 + 1);
  else
    v20 = (unsigned __int64)(unsigned __int8)v347 >> 1;
  v21 = (__int64)sub_6588400(a5, v19, v20);
  if ( (v347 & 1) != 0 )
    v21 = sub_6575460();
  v22 = (unsigned __int8 *)sub_6425260(v21);
  v23 = *v22;
  if ( (v23 & 1) != 0 )
    v24 = *((_QWORD *)v22 + 1);
  else
    v24 = v23 >> 1;
  if ( v24 )
  {
    v25 = sub_67D352C(a5, ",baseurl=");
    v26 = sub_6425260(v25);
    sub_6416168(&v347, v26);
    v27 = (v347 & 1) != 0 ? (__int128 *)v348 : (__int128 *)((char *)&v347 + 1);
    v28 = (v347 & 1) != 0 ? *((_QWORD *)&v347 + 1) : (unsigned __int64)(unsigned __int8)v347 >> 1;
    sub_6588400(a5, v27, v28);
    if ( (v347 & 1) != 0 )
      sub_6575460();
  }
  v29 = sub_67D352C(a5, ",channel=");
  v30 = sub_6424E14(v29);
  sub_6416168(&v347, v30);
  if ( (v347 & 1) != 0 )
    v31 = (char *)v348;
  else
    v31 = (char *)&v347 + 1;
  if ( (v347 & 1) != 0 )
    v32 = *((_QWORD *)&v347 + 1);
  else
    v32 = (unsigned __int64)(unsigned __int8)v347 >> 1;
  v33 = (__int64)sub_6588400(a5, v31, v32);
  if ( (v347 & 1) != 0 )
    v33 = sub_6575460();
  if ( (sub_641FF64(v33) & 1) != 0 )
  {
    v347 = 0uLL;
    v348 = 0LL;
    if ( (sub_6420004() & 1) != 0 )
    {
      sub_653EEEC(&v345, 3LL);
      if ( (v347 & 1) != 0 )
        sub_6575460();
      v347 = v345;
      v348 = v346;
      sub_67D352C(a5, ",datacenterid=");
      if ( (v347 & 1) != 0 )
        v34 = (char *)v348;
      else
        v34 = (char *)&v347 + 1;
      if ( (v347 & 1) != 0 )
        v35 = *((_QWORD *)&v347 + 1);
      else
        v35 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      v36 = (__int64)sub_6588400(a5, v34, v35);
    }
    else
    {
      sub_67D352C(a5, ",datacenterid=");
      sub_6579D18("%d", &v345);
      if ( (v345 & 1) != 0 )
        v40 = v346;
      else
        v40 = (char *)&v345 + 1;
      if ( (v345 & 1) != 0 )
        v41 = *((_QWORD *)&v345 + 1);
      else
        v41 = (unsigned __int64)(unsigned __int8)v345 >> 1;
      v36 = (__int64)sub_6588400(a5, v40, v41);
      if ( (v345 & 1) != 0 )
        v36 = sub_6575460();
    }
    v42 = (unsigned __int64 *)sub_641FFC4(v36);
    if ( ((unsigned __int8)v42 & 1) != 0 )
    {
      if ( (v347 & 1) != 0 )
        v43 = *((_QWORD *)&v347 + 1);
      else
        v43 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      if ( !v43 )
      {
        sub_653EEEC(&v345, 3LL);
        if ( (v347 & 1) != 0 )
          sub_6575460();
        v347 = v345;
        v348 = v346;
      }
      sub_67D352C(a5, ",datacenterid_fromcontext=");
      if ( (v347 & 1) != 0 )
        v44 = (char *)v348;
      else
        v44 = (char *)&v347 + 1;
      if ( (v347 & 1) != 0 )
        v45 = *((_QWORD *)&v347 + 1);
      else
        v45 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      v42 = sub_6588400(a5, v44, v45);
    }
    v39 = sub_6420044(v42);
    if ( (v39 & 1) == 0 )
    {
      v328 = 0;
      if ( (v347 & 1) == 0 )
        goto LABEL_123;
      goto LABEL_122;
    }
    if ( (v347 & 1) != 0 )
      v46 = *((_QWORD *)&v347 + 1);
    else
      v46 = (unsigned __int64)(unsigned __int8)v347 >> 1;
    if ( !v46 )
    {
      sub_653EF60(&v345, 3LL);
      if ( (v347 & 1) != 0 )
        sub_6575460();
      v347 = v345;
      v348 = v346;
    }
    v39 = (__int64)sub_67D4DB0(&v345, (unsigned int)dword_6C2FCA4);
    v47 = v345;
    if ( (v347 & 1) != 0 )
      v48 = *((_QWORD *)&v347 + 1);
    else
      v48 = (unsigned __int64)(unsigned __int8)v347 >> 1;
    v49 = (unsigned __int64)(unsigned __int8)v345 >> 1;
    if ( (v345 & 1) != 0 )
      v49 = *((_QWORD *)&v345 + 1);
    if ( v48 != v49 )
    {
      v56 = 1;
      goto LABEL_567;
    }
    v50 = (unsigned __int8 *)&v347 + 1;
    if ( (v347 & 1) != 0 )
      v39 = (__int64)v348;
    else
      v39 = (__int64)&v347 + 1;
    if ( (v345 & 1) != 0 )
      v51 = (unsigned __int8 *)v346;
    else
      v51 = (unsigned __int8 *)&v345 + 1;
    if ( (v347 & 1) != 0 )
    {
      if ( v48 )
      {
        v39 = memcmp((const void *)v39, v51, v48);
        v56 = v39 != 0;
        goto LABEL_567;
      }
    }
    else if ( v48 )
    {
      v52 = ((unsigned __int64)(unsigned __int8)v347 >> 1) - 1;
      do
      {
        v54 = *v50++;
        v53 = v54;
        v55 = *v51++;
        v56 = v53 != v55;
      }
      while ( v53 == v55 && v52-- != 0 );
LABEL_567:
      if ( (v47 & 1) != 0 )
        v39 = sub_6575460();
      if ( v56 )
        v221 = 4;
      else
        v221 = 0;
      v328 = v221;
      if ( (v347 & 1) == 0 )
        goto LABEL_123;
LABEL_122:
      v39 = sub_6575460();
      goto LABEL_123;
    }
    v56 = 0;
    goto LABEL_567;
  }
  sub_67D352C(a5, ",datacenterid=");
  sub_6579D18("%d", &v347);
  if ( (v347 & 1) != 0 )
    v37 = (char *)v348;
  else
    v37 = (char *)&v347 + 1;
  if ( (v347 & 1) != 0 )
    v38 = *((_QWORD *)&v347 + 1);
  else
    v38 = (unsigned __int64)(unsigned __int8)v347 >> 1;
  v39 = (__int64)sub_6588400(a5, v37, v38);
  if ( (v347 & 1) != 0 )
    v39 = sub_6575460();
  v328 = 0;
LABEL_123:
  if ( byte_71CF7B0 && byte_6F7A700 )
  {
    if ( dword_6C2FCA8 != 0x80000000 )
    {
      sub_67D352C(a5, ",serverpartitionid=");
      sub_6579D18("%d", &v347);
      v58 = (v347 & 1) != 0 ? (__int128 *)v348 : (__int128 *)((char *)&v347 + 1);
      v59 = (v347 & 1) != 0 ? *((_QWORD *)&v347 + 1) : (unsigned __int64)(unsigned __int8)v347 >> 1;
      v39 = (__int64)sub_6588400(a5, v58, v59);
      if ( (v347 & 1) != 0 )
        v39 = sub_6575460();
    }
    if ( dword_6C2FCAC != 0x80000000 )
    {
      sub_67D352C(a5, ",gameinstanceisolationtag=");
      sub_6579D18("%d", &v347);
      v60 = (v347 & 1) != 0 ? (__int128 *)v348 : (__int128 *)((char *)&v347 + 1);
      v61 = (v347 & 1) != 0 ? *((_QWORD *)&v347 + 1) : (unsigned __int64)(unsigned __int8)v347 >> 1;
      v39 = (__int64)sub_6588400(a5, v60, v61);
      if ( (v347 & 1) != 0 )
        v39 = sub_6575460();
    }
  }
  if ( (sub_641FF64(v39) & 1) != 0 )
  {
    v347 = 0uLL;
    v348 = 0LL;
    v62 = sub_6420004();
    if ( (v62 & 1) == 0 )
      goto LABEL_179;
    v62 = (__int64)sub_653EEEC(&v345, 2LL);
    if ( (v347 & 1) != 0 )
      v62 = sub_6575460();
    v347 = v345;
    v63 = qword_6F7A5B0;
    if ( (word_6F7A5A8 & 1) == 0 )
      v63 = (unsigned __int64)(unsigned __int8)word_6F7A5A8 >> 1;
    v348 = v346;
    if ( v63
      && ((v347 & 1) != 0 ? (v64 = *((_QWORD *)&v347 + 1)) : (v64 = (unsigned __int64)(unsigned __int8)v347 >> 1),
          v64 && (v62 = sub_6416518(&v347, &word_6F7A5A8), (v62 & 1) != 0)) )
    {
      sub_67D352C(a5, ",selecteduniverseid=");
      sub_6416168(&v345, &v347);
      if ( (v345 & 1) != 0 )
        v65 = v346;
      else
        v65 = (char *)&v345 + 1;
      if ( (v345 & 1) != 0 )
        v66 = *((_QWORD *)&v345 + 1);
      else
        v66 = (unsigned __int64)(unsigned __int8)v345 >> 1;
      v62 = (__int64)sub_6588400(a5, v65, v66);
      if ( (v345 & 1) != 0 )
        v62 = sub_6575460();
      v67 = 1;
    }
    else
    {
LABEL_179:
      v67 = 0;
    }
    v72 = sub_641FFC4(v62);
    if ( (v72 & 1) == 0 )
      goto LABEL_199;
    if ( (v347 & 1) != 0 )
      v73 = *((_QWORD *)&v347 + 1);
    else
      v73 = (unsigned __int64)(unsigned __int8)v347 >> 1;
    if ( v73 )
    {
      if ( !v67 )
      {
LABEL_199:
        v76 = sub_6420044(v72);
        v77 = v347;
        v78 = v347 & 1;
        if ( (v76 & 1) == 0 )
          goto LABEL_234;
        v79 = *((_QWORD *)&v347 + 1);
        v80 = (unsigned __int8)v347 >> 1;
        if ( (v347 & 1) != 0 )
          v81 = *((_QWORD *)&v347 + 1);
        else
          v81 = (unsigned __int8)v347 >> 1;
        if ( !v81 )
        {
          sub_653EF60(&v345, 2LL);
          if ( (v347 & 1) != 0 )
            sub_6575460();
          v347 = v345;
          v77 = v345;
          v348 = v346;
          v79 = *((_QWORD *)&v345 + 1);
          v80 = (unsigned __int64)(unsigned __int8)v345 >> 1;
        }
        v78 = v77 & 1;
        if ( (v77 & 1) != 0 )
          v82 = v79;
        else
          v82 = v80;
        v83 = *((_QWORD *)&xmmword_6F7AA50 + 1);
        if ( (xmmword_6F7AA50 & 1) == 0 )
          v83 = (unsigned __int64)(unsigned __int8)xmmword_6F7AA50 >> 1;
        if ( v82 != v83 )
          goto LABEL_233;
        v84 = (unsigned __int8 *)&v347 + 1;
        if ( v78 )
          v85 = v348;
        else
          v85 = (char *)&v347 + 1;
        if ( (xmmword_6F7AA50 & 1) != 0 )
          v86 = (unsigned __int8 *)qword_6F7AA60;
        else
          v86 = (unsigned __int8 *)&xmmword_6F7AA50 + 1;
        if ( !v78 )
        {
          if ( !v82 )
            goto LABEL_236;
          v87 = v80 - 1;
          do
          {
            v89 = *v84++;
            v88 = v89;
            v91 = *v86++;
            v90 = v91;
          }
          while ( v88 == v91 && v87-- != 0 );
          if ( v88 == v90 )
            goto LABEL_236;
          goto LABEL_233;
        }
        if ( v82 && memcmp(v85, v86, v82) )
        {
LABEL_233:
          v328 |= 2u;
LABEL_234:
          if ( !v78 )
            goto LABEL_236;
        }
LABEL_235:
        sub_6575460();
        goto LABEL_236;
      }
    }
    else
    {
      v72 = (__int64)sub_653EEEC(&v345, 2LL);
      if ( (v347 & 1) != 0 )
        v72 = sub_6575460();
      v347 = v345;
      v348 = v346;
      if ( !v67 )
        goto LABEL_199;
    }
    sub_67D352C(a5, ",selecteduniverseid_fromcontext=");
    sub_6416168(&v345, &v347);
    if ( (v345 & 1) != 0 )
      v74 = v346;
    else
      v74 = (char *)&v345 + 1;
    if ( (v345 & 1) != 0 )
      v75 = *((_QWORD *)&v345 + 1);
    else
      v75 = (unsigned __int64)(unsigned __int8)v345 >> 1;
    v72 = (__int64)sub_6588400(a5, v74, v75);
    if ( (v345 & 1) != 0 )
      v72 = sub_6575460();
    goto LABEL_199;
  }
  v68 = qword_6F7A5B0;
  if ( (word_6F7A5A8 & 1) == 0 )
    v68 = (unsigned __int64)(unsigned __int8)word_6F7A5A8 >> 1;
  if ( v68 )
  {
    v69 = *((_QWORD *)&xmmword_6F7AA50 + 1);
    if ( (xmmword_6F7AA50 & 1) == 0 )
      v69 = (unsigned __int64)(unsigned __int8)xmmword_6F7AA50 >> 1;
    if ( v69 && (sub_6416518(&xmmword_6F7AA50, &word_6F7A5A8) & 1) != 0 )
    {
      sub_67D352C(a5, ",selecteduniverseid=");
      sub_6416168(&v347, &xmmword_6F7AA50);
      v70 = (v347 & 1) != 0 ? (__int128 *)v348 : (__int128 *)((char *)&v347 + 1);
      v71 = (v347 & 1) != 0 ? *((_QWORD *)&v347 + 1) : (unsigned __int64)(unsigned __int8)v347 >> 1;
      sub_6588400(a5, v70, v71);
      if ( (v347 & 1) != 0 )
        goto LABEL_235;
    }
  }
LABEL_236:
  if ( a4 == 4 )
  {
    v93 = (__int64)sub_67D352C(a5, ",type=statistic");
  }
  else if ( a4 == 5 )
  {
    v93 = (__int64)sub_67D352C(a5, ",type=counter");
  }
  else
  {
    v93 = (__int64)sub_67D352C(a5, ",type=event");
  }
  if ( byte_71CF7B0 && byte_6F7A5D0 )
  {
    v94 = qword_6F7A5F8;
    if ( (word_6F7A5F0 & 1) == 0 )
      v94 = (unsigned __int64)(unsigned __int8)word_6F7A5F0 >> 1;
    if ( v94 )
    {
      sub_67D352C(a5, ",playtestid=");
      sub_6416168(&v347, &word_6F7A5F0);
      v95 = (v347 & 1) != 0 ? (__int128 *)v348 : (__int128 *)((char *)&v347 + 1);
      v96 = (v347 & 1) != 0 ? *((_QWORD *)&v347 + 1) : (unsigned __int64)(unsigned __int8)v347 >> 1;
      v93 = (__int64)sub_6588400(a5, v95, v96);
      if ( (v347 & 1) != 0 )
        v93 = sub_6575460();
    }
    v97 = qword_6F7A620;
    if ( (word_6F7A618 & 1) == 0 )
      v97 = (unsigned __int64)(unsigned __int8)word_6F7A618 >> 1;
    if ( v97 )
    {
      sub_67D352C(a5, ",runteamcityid=");
      sub_6416168(&v347, &word_6F7A618);
      v98 = (v347 & 1) != 0 ? (__int128 *)v348 : (__int128 *)((char *)&v347 + 1);
      v99 = (v347 & 1) != 0 ? *((_QWORD *)&v347 + 1) : (unsigned __int64)(unsigned __int8)v347 >> 1;
      v93 = (__int64)sub_6588400(a5, v98, v99);
      if ( (v347 & 1) != 0 )
        v93 = sub_6575460();
    }
  }
  if ( (sub_641FF64(v93) & 1) != 0 )
  {
    v347 = 0uLL;
    v348 = 0LL;
    if ( (sub_6420004() & 1) != 0 )
    {
      sub_653EEEC(&v345, 12LL);
      if ( (v347 & 1) != 0 )
        sub_6575460();
      v347 = v345;
      v348 = v346;
      sub_67D352C(a5, ",streamingenabled=");
      if ( (v347 & 1) != 0 )
        v100 = (char *)v348;
      else
        v100 = (char *)&v347 + 1;
      if ( (v347 & 1) != 0 )
        v101 = *((_QWORD *)&v347 + 1);
      else
        v101 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      v102 = sub_6588400(a5, v100, v101);
    }
    else
    {
      sub_67D352C(a5, ",streamingenabled=");
      v104 = (char *)sub_641F6E0((unsigned int)dword_6F7AA80);
      v102 = sub_67D352C(a5, v104);
    }
    v105 = (unsigned __int64 *)sub_641FFC4(v102);
    if ( ((unsigned __int8)v105 & 1) != 0 )
    {
      if ( (v347 & 1) != 0 )
        v106 = *((_QWORD *)&v347 + 1);
      else
        v106 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      if ( !v106 )
      {
        sub_653EEEC(&v345, 12LL);
        if ( (v347 & 1) != 0 )
          sub_6575460();
        v347 = v345;
        v348 = v346;
      }
      sub_67D352C(a5, ",streamingenabled_fromcontext=");
      if ( (v347 & 1) != 0 )
        v107 = (char *)v348;
      else
        v107 = (char *)&v347 + 1;
      if ( (v347 & 1) != 0 )
        v108 = *((_QWORD *)&v347 + 1);
      else
        v108 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      v105 = sub_6588400(a5, v107, v108);
    }
    if ( (sub_6420044(v105) & 1) != 0 )
    {
      if ( (v347 & 1) != 0 )
        v109 = *((_QWORD *)&v347 + 1);
      else
        v109 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      if ( !v109 )
      {
        sub_653EF60(&v345, 12LL);
        if ( (v347 & 1) != 0 )
          sub_6575460();
        v347 = v345;
        v348 = v346;
      }
      v110 = (char *)sub_641F6E0((unsigned int)dword_6F7AA80);
      v111 = strlen(v110);
      if ( (v347 & 1) != 0 )
        v112 = *((_QWORD *)&v347 + 1);
      else
        v112 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      if ( v111 != v112 || (unsigned int)sub_67D3100((unsigned __int8 *)&v347, 0LL, 0xFFFFFFFFFFFFFFFFLL, v110, v111) )
        v328 |= 0x40u;
    }
    if ( (v347 & 1) != 0 )
      sub_6575460();
  }
  else
  {
    sub_67D352C(a5, ",streamingenabled=");
    v103 = (char *)sub_641F6E0((unsigned int)dword_6F7AA80);
    sub_67D352C(a5, v103);
  }
  v113 = atomic_load(byte_6D1B678);
  if ( (v113 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6D1B678) )
  {
    qword_6D1B638 = (__int64)off_67F87E8;
    sub_67D19DC(&stru_6D1B640);
    qword_6D1B668 = 0LL;
    unk_6D1B670 = 0LL;
    qword_6D1B638 = (__int64)off_6897788;
    qword_6C382D8 = (__int64)&qword_6D1B638;
    sub_67EB838(byte_6D1B678);
  }
  v329 = (_QWORD *)sub_32F11B4(&qword_6D1B638);
  for ( i = *(unsigned __int8 **)(sub_642052C(v329[6]) + 16); i; i = *(unsigned __int8 **)i )
  {
    v115 = i[16];
    if ( (v115 & 1) != 0 )
      v116 = *((_QWORD *)i + 3);
    else
      v116 = v115 >> 1;
    if ( v116 != 11 || (unsigned int)sub_67D3100(i + 16, 0LL, 0xFFFFFFFFFFFFFFFFLL, "application", 0xBuLL) )
    {
      sub_67D352C(a5, ",");
      v117 = i[16];
      v118 = (v117 & 1) == 0;
      v119 = v117 >> 1;
      v120 = v118 ? (char *)(i + 17) : (char *)*((_QWORD *)i + 4);
      v121 = v118 ? v119 : *((_QWORD *)i + 3);
      sub_6588400(a5, v120, v121);
      sub_67D352C(a5, "=");
      sub_6416168(&v347, i + 40);
      v122 = (v347 & 1) != 0 ? (__int128 *)v348 : (__int128 *)((char *)&v347 + 1);
      v123 = (v347 & 1) != 0 ? *((_QWORD *)&v347 + 1) : (unsigned __int64)(unsigned __int8)v347 >> 1;
      sub_6588400(a5, v122, v123);
      if ( (v347 & 1) != 0 )
        sub_6575460();
    }
  }
  sub_6589DEC(a5, 32);
  v124 = v330;
  if ( v330 )
    v124 = (__int128 *)*((_QWORD *)v330 + 6);
  sub_67D2788((unsigned __int64 *)&v347, (__int128 *)((char *)v124 + 40));
  if ( (v347 & 1) != 0 )
    v125 = (char *)v348;
  else
    v125 = (char *)&v347 + 1;
  if ( (v347 & 1) != 0 )
    v126 = *((_QWORD *)&v347 + 1);
  else
    v126 = (unsigned __int64)(unsigned __int8)v347 >> 1;
  sub_6588400(a5, v125, v126);
  if ( (v347 & 1) != 0 )
    sub_6575460();
  LOBYTE(v347) = 16;
  strcpy((char *)&v347 + 1, "location");
  if ( (sub_641E054(a2, (unsigned __int8 *)&v347, &v345) & 1) != 0 )
  {
    v127 = v345;
    v129 = (_QWORD *)(a2 + 8);
    v128 = *(_QWORD **)(a2 + 8);
    v131 = (unsigned int *)(a2 + 16);
    v130 = *(_DWORD *)(a2 + 16);
    v132 = *(_DWORD *)a2 & 1;
  }
  else
  {
    v131 = (unsigned int *)(a2 + 16);
    v130 = *(_DWORD *)(a2 + 16);
    v129 = (_QWORD *)(a2 + 8);
    v128 = *(_QWORD **)(a2 + 8);
    v132 = *(_DWORD *)a2 & 1;
    if ( v132 )
      v133 = 8;
    else
      v133 = *(_DWORD *)(a2 + 16);
    if ( (*(_DWORD *)a2 & 1) != 0 )
      v134 = a2 + 8;
    else
      v134 = *(_QWORD *)(a2 + 8);
    v127 = v134 + 48LL * v133;
  }
  if ( v132 )
  {
    v130 = 8;
    v128 = v129;
  }
  v135 = &v128[6 * v130];
  if ( (v347 & 1) != 0 )
    sub_6575460();
  if ( (_QWORD *)v127 == v135 )
  {
    sub_67D352C(a5, ",location=");
    sub_67D2788(v344, &xmmword_6F7A9A8);
    sub_6419634(&v347, v344);
    if ( (v347 & 1) != 0 )
      v136 = (char *)v348;
    else
      v136 = (char *)&v347 + 1;
    if ( (v347 & 1) != 0 )
      v137 = *((_QWORD *)&v347 + 1);
    else
      v137 = (unsigned __int64)(unsigned __int8)v347 >> 1;
    sub_6588400(a5, v136, v137);
    if ( (v347 & 1) != 0 )
      sub_6575460();
    if ( (v344[0] & 1) != 0 )
      sub_6575460();
  }
  if ( byte_71CF7B0 && byte_6F7CAD8 )
  {
    sub_653EEEC(&v347, 7LL);
    v138 = v347 & 1;
    v139 = (unsigned __int64)(unsigned __int8)v347 >> 1;
    if ( v138 )
      v139 = *((_QWORD *)&v347 + 1);
    if ( v139 )
    {
      sub_67D352C(a5, ",playSessionId=");
      sub_67D2788(v343, &v347);
      sub_6419634(&v345, v343);
      if ( (v345 & 1) != 0 )
        v140 = v346;
      else
        v140 = (char *)&v345 + 1;
      if ( (v345 & 1) != 0 )
        v141 = *((_QWORD *)&v345 + 1);
      else
        v141 = (unsigned __int64)(unsigned __int8)v345 >> 1;
      sub_6588400(a5, v140, v141);
      if ( (v345 & 1) != 0 )
        sub_6575460();
      if ( (v343[0] & 1) != 0 )
        sub_6575460();
      v138 = v347 & 1;
    }
    if ( v138 )
      sub_6575460();
  }
  for ( j = *(__int64 ***)(sub_6420534(v329[6]) + 16); j; j = (__int64 **)*j )
  {
    sub_67D352C(a5, ",");
    v143 = *((unsigned __int8 *)j + 16);
    v144 = (v143 & 1) == 0;
    v145 = v143 >> 1;
    if ( v144 )
      v146 = (__int64 *)((char *)j + 17);
    else
      v146 = j[4];
    if ( v144 )
      v147 = v145;
    else
      v147 = (size_t)j[3];
    sub_6588400(a5, v146, v147);
    sub_67D352C(a5, "=");
    v148 = *((unsigned __int8 *)j + 40);
    v149 = (v148 & 1) == 0;
    v150 = v148 >> 1;
    if ( v149 )
      v151 = (__int64 *)((char *)j + 41);
    else
      v151 = j[7];
    if ( v149 )
      v152 = v150;
    else
      v152 = (size_t)j[6];
    sub_6588400(a5, v151, v152);
  }
  v153 = *a3;
  v154 = (v153 & 1) == 0;
  if ( (v153 & 1) != 0 )
    v155 = *((_QWORD *)a3 + 1);
  else
    v155 = v153 >> 1;
  if ( v155 )
  {
    if ( v154 )
      v156 = (const char *)(a3 + 1);
    else
      v156 = (const char *)*((_QWORD *)a3 + 2);
  }
  else
  {
    v157 = qword_6F7A9C8;
    if ( (qword_6F7A9C0 & 1) == 0 )
      v157 = (unsigned __int64)(unsigned __int8)qword_6F7A9C0 >> 1;
    if ( v157 )
    {
      if ( (qword_6F7A9C0 & 1) != 0 )
        v156 = (const char *)qword_6F7A9D0;
      else
        v156 = (char *)&qword_6F7A9C0 + 1;
    }
    else
    {
      v156 = "0";
    }
  }
  v158 = strlen(v156);
  if ( v158 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v159 = v158;
  if ( v158 >= 0x17 )
  {
    v161 = (v158 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v160 = (char *)sub_6575418();
    v341 = v159;
    v342 = v160;
    v340 = v161 | 1;
    goto LABEL_417;
  }
  v160 = (char *)&v340 + 1;
  LOBYTE(v340) = 2 * v158;
  if ( v158 )
LABEL_417:
    memcpy(v160, v156, v159);
  v160[v159] = 0;
  if ( (v340 & 1) != 0 )
    v162 = v342;
  else
    v162 = (char *)&v340 + 1;
  if ( strtoll(v162, 0LL, 10) < 0 )
  {
    sub_67D3284((int)&v340, "-1");
  }
  else
  {
    if ( (v340 & 1) != 0 )
      v163 = v342;
    else
      v163 = (char *)&v340 + 1;
    if ( !strtoll(v163, 0LL, 10) )
      sub_67D3284((int)&v340, "0");
  }
  LOBYTE(v347) = 14;
  strcpy((char *)&v347 + 1, "placeid");
  v164 = sub_641E054(a2, (unsigned __int8 *)&v347, &v345);
  if ( (v164 & 1) != 0 )
  {
    v165 = (_QWORD *)v345;
    v166 = *(_QWORD **)(a2 + 8);
    v167 = *(_DWORD *)(a2 + 16);
    v168 = *(_DWORD *)a2 & 1;
  }
  else
  {
    v167 = *(_DWORD *)(a2 + 16);
    v166 = *(_QWORD **)(a2 + 8);
    v168 = *(_DWORD *)a2 & 1;
    if ( v168 )
      v169 = 8;
    else
      v169 = *(_DWORD *)(a2 + 16);
    if ( (*(_DWORD *)a2 & 1) != 0 )
      v170 = v129;
    else
      v170 = *(_QWORD **)(a2 + 8);
    v165 = &v170[6 * v169];
  }
  if ( v168 )
  {
    v167 = 8;
    v166 = v129;
  }
  v171 = &v166[6 * v167];
  if ( (v347 & 1) != 0 )
    v164 = sub_6575460();
  if ( v165 != v171 )
    goto LABEL_579;
  if ( (sub_641FF64(v164) & 1) != 0 )
  {
    v347 = 0uLL;
    v348 = 0LL;
    if ( (sub_6420004() & 1) != 0 )
    {
      sub_653EEEC(&v345, 1LL);
      if ( (v347 & 1) != 0 )
        sub_6575460();
      v347 = v345;
      v348 = v346;
      sub_67D352C(a5, ",placeid=");
      v172 = *((_QWORD *)&v347 + 1);
      if ( (v347 & 1) == 0 )
        v172 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      if ( v172 && ((v347 & 1) != 0 ? (v173 = v348) : (v173 = (char *)&v347 + 1), strtoll(v173, 0LL, 10) > 0) )
      {
        sub_67D2788((unsigned __int64 *)&v345, &v347);
        v174 = (unsigned __int8)v345;
      }
      else
      {
        v174 = 2;
        BYTE2(v345) = 0;
        LOWORD(v345) = 12290;
      }
      v192 = (v174 & 1) == 0;
      v193 = v174 >> 1;
      if ( v192 )
        v194 = v193;
      else
        v194 = *((_QWORD *)&v345 + 1);
      if ( v192 )
        v195 = (char *)&v345 + 1;
      else
        v195 = v346;
      sub_6588400(a5, v195, v194);
      if ( (v345 & 1) != 0 )
        sub_6575460();
    }
    else
    {
      sub_67D352C(a5, ",placeid=");
      if ( (xmmword_6F7A9D8 & 1) != 0 )
        v181 = *((_QWORD *)&xmmword_6F7A9D8 + 1);
      else
        v181 = (unsigned __int64)(unsigned __int8)xmmword_6F7A9D8 >> 1;
      if ( v181
        && ((xmmword_6F7A9D8 & 1) == 0 ? (v182 = (char *)&xmmword_6F7A9D8 + 1) : (v182 = (const char *)qword_6F7A9E8),
            strtoll(v182, 0LL, 10) > 0) )
      {
        sub_67D2788((unsigned __int64 *)&v345, &xmmword_6F7A9D8);
        v183 = (unsigned __int8)v345;
      }
      else
      {
        v183 = 2;
        BYTE2(v345) = 0;
        LOWORD(v345) = 12290;
      }
      v188 = (v183 & 1) == 0;
      v189 = v183 >> 1;
      if ( v188 )
        v190 = v189;
      else
        v190 = *((_QWORD *)&v345 + 1);
      if ( v188 )
        v191 = (char *)&v345 + 1;
      else
        v191 = v346;
      sub_6588400(a5, v191, v190);
      if ( (v345 & 1) != 0 )
        sub_6575460();
    }
    v196 = sub_67D352C(a5, "i");
    v197 = sub_641FFC4(v196);
    if ( (v197 & 1) != 0 )
    {
      if ( (v347 & 1) != 0 )
        v198 = *((_QWORD *)&v347 + 1);
      else
        v198 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      if ( !v198 )
      {
        sub_653EEEC(&v345, 1LL);
        if ( (v347 & 1) != 0 )
          sub_6575460();
        v347 = v345;
        v348 = v346;
      }
      sub_67D352C(a5, ",placeid_fromcontext=");
      v199 = *((_QWORD *)&v347 + 1);
      if ( (v347 & 1) == 0 )
        v199 = (unsigned __int64)(unsigned __int8)v347 >> 1;
      if ( v199 && ((v347 & 1) != 0 ? (v200 = v348) : (v200 = (char *)&v347 + 1), strtoll(v200, 0LL, 10) > 0) )
      {
        sub_67D2788((unsigned __int64 *)&v345, &v347);
        v201 = (unsigned __int8)v345;
      }
      else
      {
        v201 = 2;
        BYTE2(v345) = 0;
        LOWORD(v345) = 12290;
      }
      v202 = (v201 & 1) == 0;
      v203 = v201 >> 1;
      if ( v202 )
        v204 = v203;
      else
        v204 = *((_QWORD *)&v345 + 1);
      if ( v202 )
        v205 = (char *)&v345 + 1;
      else
        v205 = v346;
      sub_6588400(a5, v205, v204);
      if ( (v345 & 1) != 0 )
        sub_6575460();
      v197 = (__int64)sub_67D352C(a5, "i");
    }
    v164 = sub_6420044(v197);
    v206 = v347;
    v207 = v347 & 1;
    if ( (v164 & 1) == 0 )
    {
LABEL_577:
      if ( !v207 )
        goto LABEL_579;
      goto LABEL_578;
    }
    v208 = *((_QWORD *)&v347 + 1);
    v209 = (unsigned __int8)v347 >> 1;
    if ( (v347 & 1) != 0 )
      v210 = *((_QWORD *)&v347 + 1);
    else
      v210 = (unsigned __int8)v347 >> 1;
    if ( !v210 )
    {
      v164 = (__int64)sub_653EF60(&v345, 1LL);
      if ( (v347 & 1) != 0 )
        v164 = sub_6575460();
      v347 = v345;
      v206 = v345;
      v348 = v346;
      v208 = *((_QWORD *)&v345 + 1);
      v209 = (unsigned __int64)(unsigned __int8)v345 >> 1;
    }
    v207 = v206 & 1;
    if ( (v206 & 1) != 0 )
      v211 = v208;
    else
      v211 = v209;
    v212 = *((_QWORD *)&xmmword_6F7A9D8 + 1);
    if ( (xmmword_6F7A9D8 & 1) == 0 )
      v212 = (unsigned __int64)(unsigned __int8)xmmword_6F7A9D8 >> 1;
    if ( v211 != v212 )
      goto LABEL_576;
    v213 = (unsigned __int8 *)&v347 + 1;
    if ( v207 )
      v164 = (__int64)v348;
    else
      v164 = (__int64)&v347 + 1;
    if ( (xmmword_6F7A9D8 & 1) != 0 )
      v214 = (unsigned __int8 *)qword_6F7A9E8;
    else
      v214 = (unsigned __int8 *)&xmmword_6F7A9D8 + 1;
    if ( !v207 )
    {
      if ( !v211 )
        goto LABEL_579;
      v215 = v209 - 1;
      do
      {
        v217 = *v213++;
        v216 = v217;
        v219 = *v214++;
        v218 = v219;
      }
      while ( v216 == v219 && v215-- != 0 );
      if ( v216 == v218 )
        goto LABEL_579;
      goto LABEL_576;
    }
    if ( v211 )
    {
      v164 = memcmp((const void *)v164, v214, v211);
      if ( (_DWORD)v164 )
      {
LABEL_576:
        v328 |= 1u;
        goto LABEL_577;
      }
    }
LABEL_578:
    v164 = sub_6575460();
    goto LABEL_579;
  }
  if ( (xmmword_6F7A9D8 & 1) != 0 )
    v175 = *((_QWORD *)&xmmword_6F7A9D8 + 1);
  else
    v175 = (unsigned __int64)(unsigned __int8)xmmword_6F7A9D8 >> 1;
  if ( (xmmword_6F7A9D8 & 1) != 0 )
    v176 = (const char *)qword_6F7A9E8;
  else
    v176 = (char *)&xmmword_6F7A9D8 + 1;
  if ( v175 )
    v177 = v176;
  else
    v177 = "0";
  v178 = strlen(v177);
  if ( v178 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v179 = v178;
  if ( v178 >= 0x17 )
  {
    v184 = (v178 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v180 = (char *)sub_6575418();
    *((_QWORD *)&v347 + 1) = v179;
    v348 = v180;
    *(_QWORD *)&v347 = v184 | 1;
    goto LABEL_477;
  }
  v180 = (char *)&v347 + 1;
  LOBYTE(v347) = 2 * v178;
  if ( v178 )
LABEL_477:
    memcpy(v180, v177, v179);
  v180[v179] = 0;
  if ( (v347 & 1) != 0 )
    v185 = v348;
  else
    v185 = (char *)&v347 + 1;
  if ( strtoll(v185, 0LL, 10) <= 0 )
    sub_67D3284((int)&v347, "0");
  sub_67D352C(a5, ",placeid=");
  if ( (v347 & 1) != 0 )
    v186 = (char *)v348;
  else
    v186 = (char *)&v347 + 1;
  if ( (v347 & 1) != 0 )
    v187 = *((_QWORD *)&v347 + 1);
  else
    v187 = (unsigned __int64)(unsigned __int8)v347 >> 1;
  sub_6588400(a5, v186, v187);
  v164 = (__int64)sub_67D352C(a5, "i");
  if ( (v347 & 1) != 0 )
    goto LABEL_578;
LABEL_579:
  v222 = sub_641FF64(v164);
  if ( (v222 & 1) != 0 )
  {
    if ( !byte_71CF7B0 )
      goto LABEL_682;
    if ( byte_6F7A6A0 )
    {
      v347 = 0uLL;
      v348 = 0LL;
      v223 = sub_6420004();
      if ( (v223 & 1) != 0 )
      {
        v223 = (__int64)sub_653EEEC(&v345, 9LL);
        if ( (v347 & 1) != 0 )
          v223 = sub_6575460();
        v347 = v345;
        v224 = *((_QWORD *)&v345 + 1);
        if ( (v345 & 1) == 0 )
          v224 = (unsigned __int64)(unsigned __int8)v347 >> 1;
        v348 = v346;
        if ( v224 )
        {
          sub_67D352C(a5, ",placeversion=");
          if ( (v347 & 1) != 0 )
            v225 = (char *)v348;
          else
            v225 = (char *)&v347 + 1;
          if ( (v347 & 1) != 0 )
            v226 = *((_QWORD *)&v347 + 1);
          else
            v226 = (unsigned __int64)(unsigned __int8)v347 >> 1;
LABEL_617:
          sub_6588400(a5, v225, v226);
          v223 = (__int64)sub_67D352C(a5, "i");
        }
      }
      else
      {
        if ( (xmmword_6F7A9F0 & 1) != 0 )
          v230 = *((_QWORD *)&xmmword_6F7A9F0 + 1);
        else
          v230 = (unsigned __int64)(unsigned __int8)xmmword_6F7A9F0 >> 1;
        if ( v230 )
        {
          sub_67D352C(a5, ",placeversion=");
          if ( (xmmword_6F7A9F0 & 1) != 0 )
            v225 = (char *)qword_6F7AA00;
          else
            v225 = (char *)&xmmword_6F7A9F0 + 1;
          if ( (xmmword_6F7A9F0 & 1) != 0 )
            v226 = *((_QWORD *)&xmmword_6F7A9F0 + 1);
          else
            v226 = (unsigned __int64)(unsigned __int8)xmmword_6F7A9F0 >> 1;
          goto LABEL_617;
        }
      }
      v231 = sub_641FFC4(v223);
      if ( (v231 & 1) != 0 )
      {
        v232 = *((_QWORD *)&v347 + 1);
        v233 = v347 & 1;
        v234 = (unsigned __int64)(unsigned __int8)v347 >> 1;
        if ( v233 )
          v235 = *((_QWORD *)&v347 + 1);
        else
          v235 = (unsigned __int64)(unsigned __int8)v347 >> 1;
        if ( !v235 )
        {
          v231 = (__int64)sub_653EEEC(&v345, 9LL);
          if ( (v347 & 1) != 0 )
            v231 = sub_6575460();
          v347 = v345;
          v348 = v346;
          v232 = *((_QWORD *)&v345 + 1);
          v233 = v345 & 1;
          v234 = (unsigned __int64)(unsigned __int8)v345 >> 1;
        }
        if ( !v233 )
          v232 = v234;
        if ( v232 )
        {
          sub_67D352C(a5, ",placeversion_fromcontext=");
          if ( (v347 & 1) != 0 )
            v236 = (char *)v348;
          else
            v236 = (char *)&v347 + 1;
          if ( (v347 & 1) != 0 )
            v237 = *((_QWORD *)&v347 + 1);
          else
            v237 = (unsigned __int64)(unsigned __int8)v347 >> 1;
          sub_6588400(a5, v236, v237);
          v231 = (__int64)sub_67D352C(a5, "i");
        }
      }
      v222 = sub_6420044(v231);
      v238 = v347;
      v239 = v347 & 1;
      if ( (v222 & 1) != 0 )
      {
        v240 = *((_QWORD *)&v347 + 1);
        v241 = (unsigned __int8)v347 >> 1;
        if ( (v347 & 1) != 0 )
          v242 = *((_QWORD *)&v347 + 1);
        else
          v242 = (unsigned __int8)v347 >> 1;
        if ( !v242 )
        {
          v222 = (__int64)sub_653EF60(&v345, 9LL);
          if ( (v347 & 1) != 0 )
            v222 = sub_6575460();
          v347 = v345;
          v238 = v345;
          v348 = v346;
          v240 = *((_QWORD *)&v345 + 1);
          v241 = (unsigned __int64)(unsigned __int8)v345 >> 1;
        }
        v239 = v238 & 1;
        if ( (v238 & 1) != 0 )
          v243 = v240;
        else
          v243 = v241;
        v244 = *((_QWORD *)&xmmword_6F7A9F0 + 1);
        if ( (xmmword_6F7A9F0 & 1) == 0 )
          v244 = (unsigned __int64)(unsigned __int8)xmmword_6F7A9F0 >> 1;
        if ( v243 == v244 )
        {
          v245 = (unsigned __int8 *)&v347 + 1;
          if ( v239 )
            v222 = (__int64)v348;
          else
            v222 = (__int64)&v347 + 1;
          if ( (xmmword_6F7A9F0 & 1) != 0 )
            v246 = (unsigned __int8 *)qword_6F7AA00;
          else
            v246 = (unsigned __int8 *)&xmmword_6F7A9F0 + 1;
          if ( v239 )
          {
            if ( !v243 || (v222 = memcmp((const void *)v222, v246, v243), !(_DWORD)v222) )
            {
LABEL_670:
              v222 = sub_6575460();
              goto LABEL_671;
            }
          }
          else
          {
            if ( !v243 )
              goto LABEL_671;
            v247 = v241 - 1;
            do
            {
              v249 = *v245++;
              v248 = v249;
              v251 = *v246++;
              v250 = v251;
            }
            while ( v248 == v251 && v247-- != 0 );
            if ( v248 == v250 )
              goto LABEL_671;
          }
        }
        v328 |= 8u;
      }
      if ( !v239 )
        goto LABEL_671;
      goto LABEL_670;
    }
  }
  else
  {
    if ( !byte_71CF7B0 )
      goto LABEL_682;
    if ( byte_6F7A6A0 )
    {
      if ( (xmmword_6F7A9F0 & 1) != 0 )
        v227 = *((_QWORD *)&xmmword_6F7A9F0 + 1);
      else
        v227 = (unsigned __int64)(unsigned __int8)xmmword_6F7A9F0 >> 1;
      if ( v227 )
      {
        sub_67D352C(a5, ",placeversion=");
        if ( (xmmword_6F7A9F0 & 1) != 0 )
          v228 = (char *)qword_6F7AA00;
        else
          v228 = (char *)&xmmword_6F7A9F0 + 1;
        if ( (xmmword_6F7A9F0 & 1) != 0 )
          v229 = *((_QWORD *)&xmmword_6F7A9F0 + 1);
        else
          v229 = (unsigned __int64)(unsigned __int8)xmmword_6F7A9F0 >> 1;
        sub_6588400(a5, v228, v229);
        v222 = (__int64)sub_67D352C(a5, "i");
      }
LABEL_671:
      if ( !byte_71CF7B0 )
        goto LABEL_682;
    }
  }
  v253 = qword_6F7A5F8;
  if ( (word_6F7A5F0 & 1) == 0 )
    v253 = (unsigned __int64)(unsigned __int8)word_6F7A5F0 >> 1;
  if ( v253 )
  {
    sub_67D352C(a5, ",userid=");
    if ( (v340 & 1) != 0 )
      v254 = (char *)v342;
    else
      v254 = (char *)&v340 + 1;
    if ( (v340 & 1) != 0 )
      v255 = v341;
    else
      v255 = (unsigned __int64)(unsigned __int8)v340 >> 1;
    sub_6588400(a5, v254, v255);
    v222 = (__int64)sub_67D352C(a5, "i");
  }
LABEL_682:
  if ( (qword_6F7AA20 & 1) != 0 )
    v256 = qword_6F7AA28;
  else
    v256 = (unsigned __int64)(unsigned __int8)qword_6F7AA20 >> 1;
  if ( v256 )
  {
    sub_67D352C(a5, ",logguid=");
    v347 = 0uLL;
    v348 = 0LL;
    sub_67D3284((int)&v347, "0");
    sub_67D352C(&v347, "/");
    if ( (qword_6F7AA20 & 1) != 0 )
      v257 = (char *)qword_6F7AA30;
    else
      v257 = (char *)&qword_6F7AA20 + 1;
    if ( (qword_6F7AA20 & 1) != 0 )
      v258 = qword_6F7AA28;
    else
      v258 = (unsigned __int64)(unsigned __int8)qword_6F7AA20 >> 1;
    sub_6588400((unsigned __int64 *)&v347, v257, v258);
    sub_67D352C(&v347, "_last.log");
    sub_67D2788(v339, &v347);
    sub_6419634(&v345, v339);
    if ( (v345 & 1) != 0 )
      v259 = v346;
    else
      v259 = (char *)&v345 + 1;
    if ( (v345 & 1) != 0 )
      v260 = *((_QWORD *)&v345 + 1);
    else
      v260 = (unsigned __int64)(unsigned __int8)v345 >> 1;
    v222 = (__int64)sub_6588400(a5, v259, v260);
    if ( (v345 & 1) != 0 )
    {
      v222 = sub_6575460();
      if ( (v339[0] & 1) == 0 )
      {
LABEL_700:
        if ( (v347 & 1) == 0 )
          goto LABEL_702;
        goto LABEL_701;
      }
    }
    else if ( (v339[0] & 1) == 0 )
    {
      goto LABEL_700;
    }
    v222 = sub_6575460();
    if ( (v347 & 1) != 0 )
LABEL_701:
      v222 = sub_6575460();
  }
LABEL_702:
  sub_641FF44(v222);
  sub_67D352C(a5, ",sessionDuration=");
  sub_6579D18("%f", &v347);
  if ( (v347 & 1) != 0 )
    v261 = (char *)v348;
  else
    v261 = (char *)&v347 + 1;
  if ( (v347 & 1) != 0 )
    v262 = *((_QWORD *)&v347 + 1);
  else
    v262 = (unsigned __int64)(unsigned __int8)v347 >> 1;
  sub_6588400(a5, v261, v262);
  if ( (v347 & 1) != 0 )
    sub_6575460();
  sub_67D352C(a5, ",clientTimestamp=");
  v263 = sub_6580530();
  sub_6580FD4(v263, (__int64)v338);
  sub_6419634(&v347, v338);
  if ( (v347 & 1) != 0 )
    v264 = (char *)v348;
  else
    v264 = (char *)&v347 + 1;
  if ( (v347 & 1) != 0 )
    v265 = *((_QWORD *)&v347 + 1);
  else
    v265 = (unsigned __int64)(unsigned __int8)v347 >> 1;
  sub_6588400(a5, v264, v265);
  if ( (v347 & 1) != 0 )
    sub_6575460();
  if ( (v338[0] & 1) != 0 )
    sub_6575460();
  v266 = qword_6F7AA10;
  if ( (qword_6F7AA08 & 1) == 0 )
    v266 = (unsigned __int64)(unsigned __int8)qword_6F7AA08 >> 1;
  if ( v266 && dword_6C2FCA0 != -1 )
  {
    sub_67D352C(a5, ",serverIp=");
    sub_67D2788(v337, (__int128 *)&qword_6F7AA08);
    sub_6419634(&v347, v337);
    if ( (v347 & 1) != 0 )
      v267 = (char *)v348;
    else
      v267 = (char *)&v347 + 1;
    if ( (v347 & 1) != 0 )
      v268 = *((_QWORD *)&v347 + 1);
    else
      v268 = (unsigned __int64)(unsigned __int8)v347 >> 1;
    sub_6588400(a5, v267, v268);
    if ( (v347 & 1) != 0 )
      sub_6575460();
    if ( (v337[0] & 1) != 0 )
      sub_6575460();
    sub_6579D18("%d", &v347);
    sub_67D352C(a5, ",port=");
    sub_67D2788(v336, &v347);
    sub_6419634(&v345, v336);
    if ( (v345 & 1) != 0 )
      v269 = v346;
    else
      v269 = (char *)&v345 + 1;
    if ( (v345 & 1) != 0 )
      v270 = *((_QWORD *)&v345 + 1);
    else
      v270 = (unsigned __int64)(unsigned __int8)v345 >> 1;
    sub_6588400(a5, v269, v270);
    if ( (v345 & 1) != 0 )
    {
      sub_6575460();
      if ( (v336[0] & 1) == 0 )
      {
LABEL_742:
        if ( (v347 & 1) == 0 )
          goto LABEL_744;
        goto LABEL_743;
      }
    }
    else if ( (v336[0] & 1) == 0 )
    {
      goto LABEL_742;
    }
    sub_6575460();
    if ( (v347 & 1) != 0 )
LABEL_743:
      sub_6575460();
  }
LABEL_744:
  sub_67D352C(a5, ",mult=");
  sub_6579D18("%f", &v347);
  if ( (v347 & 1) != 0 )
    v271 = (char *)v348;
  else
    v271 = (char *)&v347 + 1;
  if ( (v347 & 1) != 0 )
    v272 = *((_QWORD *)&v347 + 1);
  else
    v272 = (unsigned __int64)(unsigned __int8)v347 >> 1;
  v273 = (__int64)sub_6588400(a5, v271, v272);
  if ( (v347 & 1) != 0 )
    v273 = sub_6575460();
  v282 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 <= 1u )
  {
    v283 = *v131;
    v284 = (unsigned __int8 *)*v129;
    if ( v282 )
      v285 = 8;
    else
      v285 = *v131;
    if ( v282 )
      v286 = v129;
    else
      v286 = (_QWORD *)*v129;
    v287 = (unsigned __int8 *)&v286[6 * v285];
    v288 = v287;
    goto LABEL_786;
  }
  v283 = *v131;
  v282 = *(_DWORD *)a2 & 1;
  v284 = (unsigned __int8 *)*v129;
  if ( v282 )
    v289 = 8;
  else
    v289 = *v131;
  BYTE2(v347) = 0;
  if ( v282 )
    v287 = (unsigned __int8 *)v129;
  else
    v287 = v284;
  v288 = &v287[48 * v289];
  LOWORD(v347) = 24322;
  if ( v289 )
  {
    while ( 1 )
    {
      v290 = *v287;
      v291 = *((_QWORD *)v287 + 1);
      v292 = v290 >> 1;
      if ( (v290 & 1) == 0 )
        v291 = v290 >> 1;
      if ( v291 )
      {
        if ( v291 != 1 )
          break;
        if ( (v290 & 1) == 0 )
        {
          v293 = 0LL;
          while ( v287[v293 + 1] == *((unsigned __int8 *)&v347 + v293 + 1) )
          {
            if ( v292 == ++v293 )
              goto LABEL_769;
          }
          break;
        }
        if ( **((_BYTE **)v287 + 2) != 95 )
          break;
      }
LABEL_769:
      v287 += 48;
      if ( v287 == v288 )
      {
        v287 = v288;
        break;
      }
    }
  }
LABEL_786:
  v294 = v282 == 0;
  if ( v282 )
    v295 = 8;
  else
    v295 = v283;
  if ( !v294 )
    v284 = (unsigned __int8 *)v129;
  v296 = &v284[48 * v295];
  if ( v296 != v287 )
  {
LABEL_795:
    sub_6589DEC(a5, 44);
    v297 = *v287;
    v298 = (v297 & 1) == 0;
    v299 = v297 >> 1;
    if ( v298 )
      v300 = v287 + 1;
    else
      v300 = (void *)*((_QWORD *)v287 + 2);
    if ( v298 )
      v301 = v299;
    else
      v301 = *((_QWORD *)v287 + 1);
    sub_6588400(a5, v300, v301);
    sub_6589DEC(a5, 61);
    sub_67D2788((unsigned __int64 *)&v334, (__int128 *)(v287 + 24));
    v302 = *((_QWORD *)&v334 + 1);
    v303 = v335;
    if ( (v334 & 1) == 0 )
    {
      v302 = (unsigned __int64)(unsigned __int8)v334 >> 1;
      v303 = (char *)&v334 + 1;
    }
    if ( !v302 )
      goto LABEL_825;
    v304 = v303;
    if ( v302 < 8 )
    {
LABEL_848:
      v317 = &v303[v302];
      do
      {
        if ( *v304 == 44 )
          *v304 = 95;
        ++v304;
      }
      while ( v304 != v317 );
      goto LABEL_825;
    }
    v305 = v303 + 3;
    v304 = &v303[v302 & 0xFFFFFFFFFFFFFFF8LL];
    v306 = v302 & 0xFFFFFFFFFFFFFFF8LL;
    while ( 1 )
    {
      v307 = vceq_s8(*(int8x8_t *)(v305 - 3), (int8x8_t)0x2C2C2C2C2C2C2C2CLL).n64_u64[0];
      if ( (v307 & 1) != 0 )
      {
        *(v305 - 3) = 95;
        if ( (v307 & 0x100) == 0 )
          goto LABEL_809;
      }
      else if ( (v307 & 0x100) == 0 )
      {
LABEL_809:
        if ( (v307 & 0x10000) != 0 )
          goto LABEL_810;
        goto LABEL_818;
      }
      *(v305 - 2) = 95;
      if ( (v307 & 0x10000) != 0 )
      {
LABEL_810:
        *(v305 - 1) = 95;
        if ( (v307 & 0x1000000) == 0 )
          goto LABEL_811;
        goto LABEL_819;
      }
LABEL_818:
      if ( (v307 & 0x1000000) == 0 )
      {
LABEL_811:
        if ( (v307 & 0x100000000LL) != 0 )
          goto LABEL_812;
        goto LABEL_820;
      }
LABEL_819:
      *v305 = 95;
      if ( (v307 & 0x100000000LL) != 0 )
      {
LABEL_812:
        v305[1] = 95;
        if ( (v307 & 0x10000000000LL) == 0 )
          goto LABEL_813;
        goto LABEL_821;
      }
LABEL_820:
      if ( (v307 & 0x10000000000LL) == 0 )
      {
LABEL_813:
        if ( (v307 & 0x1000000000000LL) != 0 )
          goto LABEL_814;
        goto LABEL_822;
      }
LABEL_821:
      v305[2] = 95;
      if ( (v307 & 0x1000000000000LL) != 0 )
      {
LABEL_814:
        v305[3] = 95;
        if ( (v307 & 0x100000000000000LL) != 0 )
          goto LABEL_823;
        goto LABEL_806;
      }
LABEL_822:
      if ( (v307 & 0x100000000000000LL) != 0 )
LABEL_823:
        v305[4] = 95;
LABEL_806:
      v306 -= 8LL;
      v305 += 8;
      if ( !v306 )
      {
        if ( v302 != (v302 & 0xFFFFFFFFFFFFFFF8LL) )
          goto LABEL_848;
LABEL_825:
        v308 = v334;
        v334 = 0uLL;
        v309 = v335;
        v335 = 0LL;
        v347 = v308;
        v348 = v309;
        if ( (v308 & 1) != 0 )
          v310 = (char *)v309;
        else
          v310 = (char *)&v347 + 1;
        if ( (v347 & 1) != 0 )
          v311 = *((_QWORD *)&v347 + 1);
        else
          v311 = (unsigned __int64)(unsigned __int8)v347 >> 1;
        v273 = (__int64)sub_6588400(a5, v310, v311);
        if ( (v347 & 1) != 0 )
          v273 = sub_6575460();
        if ( (v334 & 1) != 0 )
          v273 = sub_6575460();
        v287 += 48;
        LOWORD(v347) = 24322;
        BYTE2(v347) = 0;
        if ( v287 == v288 )
        {
LABEL_793:
          v287 = v288;
          goto LABEL_794;
        }
        while ( 2 )
        {
          v312 = *v287;
          v313 = *((_QWORD *)v287 + 1);
          v314 = v312 >> 1;
          if ( (v312 & 1) == 0 )
            v313 = v312 >> 1;
          if ( !v313 )
            goto LABEL_838;
          if ( v313 != 1 )
            goto LABEL_794;
          if ( (v312 & 1) != 0 )
          {
            if ( **((_BYTE **)v287 + 2) != 95 )
              goto LABEL_794;
LABEL_838:
            v287 += 48;
            if ( v287 == v288 )
              goto LABEL_793;
            continue;
          }
          break;
        }
        v315 = v287 + 1;
        v316 = (unsigned __int8 *)&v347 + 1;
        while ( *v315 == *v316 )
        {
          --v314;
          ++v315;
          ++v316;
          if ( !v314 )
            goto LABEL_838;
        }
LABEL_794:
        if ( v287 == v296 )
          break;
        goto LABEL_795;
      }
    }
  }
  if ( !byte_71CF7B0 )
  {
    v273 = qword_6F7A450;
    v318 = qword_6F7A458;
    if ( !(_BYTE)qword_6F7A450 )
      goto LABEL_874;
    goto LABEL_866;
  }
  if ( !byte_6F7A588 )
  {
    v273 = qword_6F7A450;
    v318 = qword_6F7A458;
    if ( byte_71CF760 )
    {
      if ( (unsigned __int8)qword_6F7A450 < 6u || BYTE1(qword_6F7A450) < 3u )
        goto LABEL_874;
    }
    else if ( !(_BYTE)qword_6F7A450 )
    {
      goto LABEL_874;
    }
LABEL_866:
    if ( (*(_BYTE *)a5 & 1) != 0 )
      v319 = a5[2];
    else
      v319 = (__int64)a5 + 1;
    goto LABEL_873;
  }
  if ( a4 != 3 )
  {
    v273 = qword_6F7A450;
    v318 = qword_6F7A458;
    if ( byte_71CF760 )
    {
      if ( (unsigned __int8)qword_6F7A450 < 6u || BYTE1(qword_6F7A450) < 3u )
        goto LABEL_874;
      goto LABEL_870;
    }
    if ( (_BYTE)qword_6F7A450 )
    {
LABEL_870:
      if ( (*(_BYTE *)a5 & 1) != 0 )
        v319 = a5[2];
      else
        v319 = (__int64)a5 + 1;
LABEL_873:
      v273 = sub_654E814(
               v273,
               v318,
               "[DFLog::InfluxTrace] Influx[%s]",
               v319,
               v274,
               v275,
               v276,
               v277,
               v278,
               v279,
               v280,
               v281,
               v325);
    }
  }
LABEL_874:
  if ( byte_71CF7B0 )
  {
    if ( !byte_6F7A730 )
      goto LABEL_887;
    sub_67D352C(a5, ",engineversion=");
    v332 = 22;
    strcpy(v333, "2.662.0.537");
    sub_6419634(&v347, &v332);
    if ( (v347 & 1) != 0 )
      v320 = (char *)v348;
    else
      v320 = (char *)&v347 + 1;
    if ( (v347 & 1) != 0 )
      v321 = *((_QWORD *)&v347 + 1);
    else
      v321 = (unsigned __int64)(unsigned __int8)v347 >> 1;
    v273 = (__int64)sub_6588400(a5, v320, v321);
    if ( (v347 & 1) != 0 )
      v273 = sub_6575460();
    if ( (v332 & 1) != 0 )
      v273 = sub_6575460();
    if ( byte_71CF7B0 )
    {
LABEL_887:
      if ( byte_6F7A750 )
      {
        sub_67D352C(a5, ",sessionid=");
        sub_67D2788(v331, (__int128 *)&qword_6F7AA20);
        sub_6419634(&v347, v331);
        if ( (v347 & 1) != 0 )
          v322 = (char *)v348;
        else
          v322 = (char *)&v347 + 1;
        if ( (v347 & 1) != 0 )
          v323 = *((_QWORD *)&v347 + 1);
        else
          v323 = (unsigned __int64)(unsigned __int8)v347 >> 1;
        v273 = (__int64)sub_6588400(a5, v322, v323);
        if ( (v347 & 1) != 0 )
          v273 = sub_6575460();
        if ( (v331[0] & 1) != 0 )
          v273 = sub_6575460();
      }
    }
  }
  if ( (sub_6420044(v273) & 1) != 0 )
    sub_6420084(a1, v328);
  if ( (v340 & 1) != 0 )
    sub_6575460();
  if ( v329 )
    (*(void (__fastcall **)(_QWORD *))(*v329 + 16LL))(v329);
  result = (__int64)v330;
  if ( v330 )
    return (*(__int64 (__fastcall **)(__int128 *))(*(_QWORD *)v330 + 16LL))(v330);
  return result;
}


================================================================================
Function: sub_6419634 (0x6419634)
================================================================================

__int64 __usercall sub_6419634@<X0>(unsigned __int8 *a1@<X0>, __int64 a2@<X8>)
{
  unsigned __int8 *v4; // x22
  unsigned __int8 *v5; // x8
  size_t v6; // x9
  unsigned __int64 v7; // x11
  int v8; // w10
  size_t v9; // x11
  size_t v10; // x12
  unsigned __int8 *v11; // x4
  unsigned __int8 *v12; // x13
  int v13; // t1
  unsigned __int64 v14; // x11
  size_t v15; // x12
  unsigned __int8 *v16; // x4
  unsigned __int8 *v17; // x13
  int v18; // t1
  unsigned __int64 v19; // x11
  unsigned __int8 *v20; // x1
  size_t v21; // x2
  unsigned __int64 *v22; // x0
  __int128 v23; // q0
  __int64 result; // x0
  __int64 v25; // x8
  __int128 v26; // q0
  char v27; // w9
  unsigned __int64 v28; // [xsp+8h] [xbp-38h] BYREF
  __int128 v29; // [xsp+20h] [xbp-20h] BYREF
  unsigned __int64 v30; // [xsp+30h] [xbp-10h]

  v4 = a1 + 1;
  v6 = *((_QWORD *)a1 + 1);
  v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  v7 = *a1;
  v8 = v7 & 1;
  v9 = v7 >> 1;
  if ( v8 )
    v10 = *((_QWORD *)a1 + 1);
  else
    v10 = v9;
  if ( v8 )
    v11 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  else
    v11 = a1 + 1;
  if ( v10 )
  {
    v12 = v11;
    while ( 1 )
    {
      v13 = *v12++;
      if ( v13 == 92 )
        break;
      ++v11;
      if ( !--v10 )
        goto LABEL_13;
    }
    *(_QWORD *)&v29 = "\\";
    *((_QWORD *)&v29 + 1) = "";
    sub_2D35AC0(a1, &v29, "\\\\", "", v11, v11 + 1, "\\\\", "");
    v14 = *a1;
    v6 = *((_QWORD *)a1 + 1);
    v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    v8 = v14 & 1;
    v9 = v14 >> 1;
  }
LABEL_13:
  if ( v8 )
    v15 = v6;
  else
    v15 = v9;
  if ( v8 )
    v16 = v5;
  else
    v16 = v4;
  if ( v15 )
  {
    v17 = v16;
    while ( 1 )
    {
      v18 = *v17++;
      if ( v18 == 34 )
        break;
      ++v16;
      if ( !--v15 )
        goto LABEL_25;
    }
    *(_QWORD *)&v29 = "\"";
    *((_QWORD *)&v29 + 1) = "";
    sub_2D35AC0(a1, &v29, "\\\"", "", v16, v16 + 1, "\\\"", "");
    v19 = *a1;
    v6 = *((_QWORD *)a1 + 1);
    v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    v8 = v19 & 1;
    v9 = v19 >> 1;
  }
LABEL_25:
  if ( v8 )
    v20 = v5;
  else
    v20 = v4;
  if ( v8 )
    v21 = v6;
  else
    v21 = v9;
  BYTE2(v28) = 0;
  LOWORD(v28) = 8706;
  v22 = sub_6588400(&v28, v20, v21);
  v23 = *(_OWORD *)v22;
  v30 = v22[2];
  v29 = v23;
  v22[1] = 0LL;
  v22[2] = 0LL;
  *v22 = 0LL;
  result = (__int64)sub_67D352C(&v29, "\"");
  v25 = *(_QWORD *)(result + 16);
  v26 = *(_OWORD *)result;
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = 0LL;
  *(_QWORD *)(result + 16) = 0LL;
  v27 = v29;
  *(_QWORD *)(a2 + 16) = v25;
  *(_OWORD *)a2 = v26;
  if ( (v27 & 1) != 0 )
    result = sub_6575460();
  if ( (v28 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_6419C34 (0x6419C34)
================================================================================

__int64 __usercall sub_6419C34@<X0>(__int64 a1@<X0>, __int128 *a2@<X1>, __int64 a3@<X8>)
{
  __int64 result; // x0
  __int64 v7; // x21
  char v8; // w8
  __int128 *v9; // x24
  __int128 v10; // q0
  __int64 v11; // x8
  __int128 v12; // q0
  char v13; // w10
  unsigned int v14; // w11
  __int64 v15; // x9
  bool v16; // zf
  unsigned int v17; // w10
  __int64 v18; // [xsp+0h] [xbp-10h] BYREF

  result = sub_641E054(a1, a2, &v18);
  v7 = v18;
  if ( (result & 1) != 0 )
  {
    v8 = 0;
  }
  else
  {
    v9 = (__int128 *)((char *)a2 + 24);
    result = sub_641E354(a1, a2, a2, v18);
    v7 = result;
    if ( (*(_BYTE *)result & 1) != 0 )
      result = sub_6575460();
    v10 = *a2;
    *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v7 = v10;
    v11 = *((_QWORD *)a2 + 5);
    *(_WORD *)a2 = 0;
    v12 = *v9;
    *(_QWORD *)(v7 + 40) = v11;
    v8 = 1;
    *(_OWORD *)(v7 + 24) = v12;
    *((_QWORD *)a2 + 4) = 0LL;
    *((_QWORD *)a2 + 5) = 0LL;
    *(_QWORD *)v9 = 0LL;
  }
  v13 = *(_DWORD *)a1;
  v14 = *(_DWORD *)(a1 + 16);
  *(_BYTE *)(a3 + 16) = v8;
  v15 = a1 + 8;
  v16 = (v13 & 1) == 0;
  if ( (v13 & 1) != 0 )
    v17 = 8;
  else
    v17 = v14;
  if ( v16 )
    v15 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a3 = v7;
  *(_QWORD *)(a3 + 8) = v15 + 48LL * v17;
  return result;
}


================================================================================
Function: sub_6419D44 (0x6419D44)
================================================================================

__int64 __fastcall sub_6419D44(__int64 a1, __int64 a2, unsigned int a3, char a4, char a5)
{
  signed int v9; // w8
  bool v10; // w24
  __int64 v11; // x8
  __int64 v12; // x10
  __int64 v13; // x11
  unsigned __int64 v14; // x8
  char v16; // w0
  __int64 v17; // x23
  unsigned __int64 v18; // x8
  char v20; // w0
  __int64 v21; // x23
  __int128 v22; // q0
  __int64 v23; // x8
  _WORD *v24; // x26
  unsigned __int64 v25; // x8
  _BYTE *v26; // x1
  unsigned __int64 v27; // x8
  __int64 v28; // x2
  __int64 v29; // x23
  unsigned __int64 *v30; // x19
  unsigned __int64 *v31; // x19
  __int128 v32; // q0
  __int64 v33; // x8
  _WORD *v34; // x26
  unsigned __int64 v35; // x8
  _BYTE *v36; // x1
  unsigned __int64 v37; // x8
  __int64 v38; // x2
  __int64 v39; // x23
  __int64 result; // x0
  __int64 v41; // [xsp+8h] [xbp-1E8h] BYREF
  __int64 v42; // [xsp+10h] [xbp-1E0h]
  __int128 v43; // [xsp+18h] [xbp-1D8h] BYREF
  __int64 v44; // [xsp+28h] [xbp-1C8h]
  __int128 v45; // [xsp+30h] [xbp-1C0h]
  __int64 v46; // [xsp+40h] [xbp-1B0h]
  __int64 v47; // [xsp+48h] [xbp-1A8h] BYREF
  __int64 v48; // [xsp+50h] [xbp-1A0h]
  __int64 v49; // [xsp+58h] [xbp-198h] BYREF
  char v50[8]; // [xsp+60h] [xbp-190h] BYREF

  if ( (a4 & 1) != 0 )
  {
    v9 = dword_6C2FC88;
    if ( dword_6C2FC88 == -1 )
    {
      v9 = (unsigned int)sub_657A0FC() % 0x2710;
      dword_6C2FC88 = v9;
    }
    v10 = v9 >= (int)a3;
  }
  else
  {
    v10 = 0;
  }
  sub_25D550C((__int64)v50, 0);
  sub_641A2A0((__int64)v50, a1);
  if ( byte_71CF7B0 )
  {
    if ( byte_6F7A788 )
    {
      sub_6537108(&v47);
      v11 = v47;
      if ( v47 && *(_QWORD *)(a1 + 456) )
      {
        v12 = *(_QWORD *)(a1 + 464);
        v13 = v48;
        v47 = *(_QWORD *)(a1 + 456);
        v48 = v12;
        *(_QWORD *)(a1 + 456) = v11;
        *(_QWORD *)(a1 + 464) = v13;
      }
      if ( byte_71CF7B0 && byte_6F7A6E0 )
      {
        v14 = *(unsigned __int8 *)(a1 + 424);
        if ( (v14 & 1) != 0 ? *(_QWORD *)(a1 + 432) : v14 >> 1 )
        {
          BYTE12(v43) = 0;
          LOBYTE(v43) = 22;
          DWORD2(v43) = 1735746149;
          LOBYTE(v45) = 0;
          *(_QWORD *)((char *)&v43 + 1) = *(_QWORD *)"pointsdebug";
          *(_QWORD *)((char *)&v45 + 1) = 0LL;
          *((_QWORD *)&v45 + 1) = 0LL;
          v46 = 0LL;
          v16 = sub_641E054(v50, &v43, &v49);
          v17 = v49;
          if ( (v16 & 1) != 0 )
          {
            if ( (v45 & 1) != 0 )
              sub_6575460();
          }
          else
          {
            v17 = sub_641E354(v50, &v43, &v43, v49);
            if ( (*(_BYTE *)v17 & 1) != 0 )
              sub_6575460();
            v22 = v43;
            *(_QWORD *)(v17 + 16) = v44;
            *(_OWORD *)v17 = v22;
            LOWORD(v43) = 0;
            v23 = v46;
            *(_OWORD *)(v17 + 24) = v45;
            *(_QWORD *)(v17 + 40) = v23;
            v46 = 0LL;
            v45 = 0uLL;
          }
          v24 = (_WORD *)(a1 + 424);
          if ( (v43 & 1) != 0 )
            sub_6575460();
          v25 = *(unsigned __int8 *)(a1 + 424);
          if ( (v25 & 1) != 0 )
            v26 = *(_BYTE **)(a1 + 440);
          else
            v26 = (_BYTE *)(a1 + 425);
          if ( (v25 & 1) != 0 )
            v27 = *(_QWORD *)(a1 + 432);
          else
            v27 = v25 >> 1;
          if ( v27 >= 0xF000 )
            v28 = 61440LL;
          else
            v28 = v27;
          sub_6416634(v17 + 24, v26, v28);
          if ( v47 )
            (*(void (**)(void))(*(_QWORD *)v47 + 24LL))();
          if ( (*(_BYTE *)v24 & 1) != 0 )
          {
            **(_BYTE **)(a1 + 440) = 0;
            *(_QWORD *)(a1 + 432) = 0LL;
          }
          else
          {
            *v24 = 0;
          }
        }
      }
      if ( !v10 && *(_BYTE *)(a1 + 420) != 0 )
      {
        v29 = *(unsigned int *)(a1 + 416);
        if ( sub_641A838(*(_DWORD *)(a1 + 416)) )
        {
          v41 = v47;
          v42 = v48;
          if ( v48 )
            sub_67F0410(1uLL, (atomic_ullong *)(v48 + 8));
          sub_641A918(a2, v50, a5 & 1, a1 + 392, v29, a3, &v41, *(unsigned int *)(a1 + 416));
          v30 = (unsigned __int64 *)v42;
          if ( v42 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v42 + 8)) )
          {
            (*(void (__fastcall **)(unsigned __int64 *))(*v30 + 16))(v30);
            sub_67D18A4(v30);
          }
        }
      }
      v31 = (unsigned __int64 *)v48;
      if ( v48 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v48 + 8)) )
      {
        (*(void (__fastcall **)(unsigned __int64 *))(*v31 + 16))(v31);
        sub_67D18A4(v31);
      }
      goto LABEL_77;
    }
    if ( byte_6F7A6E0 )
    {
      v18 = *(unsigned __int8 *)(a1 + 424);
      if ( (v18 & 1) != 0 ? *(_QWORD *)(a1 + 432) : v18 >> 1 )
      {
        BYTE12(v43) = 0;
        LOBYTE(v43) = 22;
        DWORD2(v43) = 1735746149;
        LOBYTE(v45) = 0;
        *(_QWORD *)((char *)&v43 + 1) = *(_QWORD *)"pointsdebug";
        *(_QWORD *)((char *)&v45 + 1) = 0LL;
        *((_QWORD *)&v45 + 1) = 0LL;
        v46 = 0LL;
        v20 = sub_641E054(v50, &v43, &v47);
        v21 = v47;
        if ( (v20 & 1) != 0 )
        {
          if ( (v45 & 1) != 0 )
            sub_6575460();
        }
        else
        {
          v21 = sub_641E354(v50, &v43, &v43, v47);
          if ( (*(_BYTE *)v21 & 1) != 0 )
            sub_6575460();
          v32 = v43;
          *(_QWORD *)(v21 + 16) = v44;
          *(_OWORD *)v21 = v32;
          LOWORD(v43) = 0;
          v33 = v46;
          *(_OWORD *)(v21 + 24) = v45;
          *(_QWORD *)(v21 + 40) = v33;
          v46 = 0LL;
          v45 = 0uLL;
        }
        v34 = (_WORD *)(a1 + 424);
        if ( (v43 & 1) != 0 )
          sub_6575460();
        v35 = *(unsigned __int8 *)(a1 + 424);
        if ( (v35 & 1) != 0 )
          v36 = *(_BYTE **)(a1 + 440);
        else
          v36 = (_BYTE *)(a1 + 425);
        if ( (v35 & 1) != 0 )
          v37 = *(_QWORD *)(a1 + 432);
        else
          v37 = v35 >> 1;
        if ( v37 >= 0xF000 )
          v38 = 61440LL;
        else
          v38 = v37;
        sub_6416634(v21 + 24, v36, v38);
        if ( (*(_BYTE *)v34 & 1) != 0 )
        {
          **(_BYTE **)(a1 + 440) = 0;
          *(_QWORD *)(a1 + 432) = 0LL;
        }
        else
        {
          *v34 = 0;
        }
      }
    }
  }
  if ( !v10 && *(_BYTE *)(a1 + 420) != 0 )
  {
    v39 = *(unsigned int *)(a1 + 416);
    if ( sub_641A838(*(_DWORD *)(a1 + 416)) )
      sub_641ADD0(a2, v50, a5 & 1, a1 + 392, v39, a3);
  }
LABEL_77:
  result = sub_254B784((__int64)v50);
  if ( (v50[0] & 1) == 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_641A2A0 (0x641A2A0)
================================================================================

__int64 __fastcall sub_641A2A0(__int64 result, __int64 a2)
{
  int v2; // w8
  int v3; // w10
  int v4; // w8
  int v5; // w9
  __int64 v6; // x9
  __int64 v7; // x13
  __int64 v8; // x8
  __int64 v9; // x10
  int v10; // w14
  _OWORD *v11; // x9
  int v12; // w11
  _OWORD *v13; // x14
  __int64 v14; // x13
  __int128 v15; // q0
  _OWORD *v16; // x15
  unsigned __int8 *v17; // x14
  __int128 v18; // q0
  unsigned __int64 v19; // x15
  unsigned __int64 v20; // x16
  unsigned __int64 v21; // x13
  unsigned __int8 *v22; // x14
  unsigned __int8 *v23; // x15
  unsigned int v24; // w8
  __int64 v25; // x21
  __int64 v26; // x22
  __int64 v27; // x23
  __int64 v28; // x9
  __int64 v29; // x8
  __int128 v30; // q0
  unsigned __int8 *v31; // x8
  unsigned __int64 v32; // x26
  unsigned __int64 v33; // x11
  int v34; // w9
  unsigned __int8 *v35; // x11
  __int64 v36; // x12
  unsigned __int8 *v37; // x13
  int v38; // w9
  int v39; // t1
  int v40; // t1
  bool v41; // zf
  unsigned __int8 *v42; // x27
  unsigned __int64 v43; // x12
  unsigned __int64 v44; // x11
  unsigned __int64 v45; // x13
  int v46; // w10
  unsigned __int8 *v47; // x10
  unsigned __int8 *v48; // x12
  char v49; // w11
  unsigned __int8 v50; // w20
  unsigned __int8 v51; // w9
  __int64 v52; // x19
  __int64 v53; // x10
  __int64 v54; // x11
  __int64 v55; // x12
  _QWORD *v56; // x19
  char v57; // w24
  char v58; // t1
  __int64 v59; // x25
  __int64 v60; // x13
  __int64 v61; // x13
  __int64 v62; // x14
  __int128 v63; // q0
  __int128 *v64; // x28
  __int128 v65; // q0
  char v66; // w8
  __int64 v67; // x8
  __int64 v68; // x9
  __int64 v69; // x11
  __int128 v70; // q1
  __int64 v71; // x12
  __int64 v72; // x8
  __int64 v73; // x9
  char v74; // w10
  __int64 v75; // x8
  __int64 v76; // x9
  int v77; // [xsp+14h] [xbp-7Ch]
  __int64 v78; // [xsp+18h] [xbp-78h]
  unsigned __int8 v79; // [xsp+24h] [xbp-6Ch]
  __int16 v80; // [xsp+28h] [xbp-68h] BYREF
  char v81; // [xsp+2Ah] [xbp-66h]
  __int128 v82; // [xsp+60h] [xbp-30h]
  _QWORD v83[2]; // [xsp+78h] [xbp-18h]

  v2 = *(_DWORD *)a2;
  v81 = 0;
  *(_DWORD *)a2 = *(_DWORD *)result & 0xFFFFFFFE | v2 & 1;
  v3 = *(_DWORD *)(result + 4);
  *(_DWORD *)result = v2 & 0xFFFFFFFE | *(_DWORD *)result & 1;
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 4) = v3;
  v4 = *(_DWORD *)result;
  v5 = *(_DWORD *)a2;
  HIBYTE(v80) = 95;
  if ( (v4 & 1) == 0 )
  {
    if ( (v5 & 1) == 0 )
    {
      v6 = *(_QWORD *)(result + 8);
      *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 8) = v6;
      LODWORD(v6) = *(_DWORD *)(result + 16);
      *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = v6;
      return result;
    }
    v5 = v4;
    v7 = result;
    result = a2;
    goto LABEL_7;
  }
  if ( (v5 & 1) == 0 )
  {
    v7 = a2;
LABEL_7:
    v8 = 0LL;
    v9 = v7 + 8;
    v10 = v5 | 1;
    v11 = (_OWORD *)(result + 8);
    v12 = HIBYTE(v80);
    v82 = *(_OWORD *)(v7 + 8);
    *(_DWORD *)v7 = v10;
    while ( 1 )
    {
      v16 = &v11[3 * v8];
      v17 = (unsigned __int8 *)(v9 + 48 * v8);
      v18 = *v16;
      *((_QWORD *)v17 + 2) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v17 = v18;
      *((_QWORD *)v16 + 1) = 0LL;
      *((_QWORD *)v16 + 2) = 0LL;
      *(_QWORD *)v16 = 0LL;
      v19 = *v17;
      v20 = *((_QWORD *)v17 + 1);
      v21 = v19 >> 1;
      if ( (v19 & 1) == 0 )
        v20 = v19 >> 1;
      if ( !v20 )
        goto LABEL_9;
      if ( v20 == 1 )
      {
        if ( (v19 & 1) != 0 )
        {
          if ( **(unsigned __int8 **)(v9 + 48 * v8 + 16) == v12 )
            goto LABEL_9;
        }
        else
        {
          v22 = v17 + 1;
          v23 = (unsigned __int8 *)&v80 + 1;
          while ( *v22 == *v23 )
          {
            --v21;
            ++v22;
            ++v23;
            if ( !v21 )
              goto LABEL_9;
          }
        }
      }
      v13 = &v11[3 * v8];
      v14 = v9 + 48 * v8;
      v15 = *(_OWORD *)((char *)v13 + 24);
      *(_QWORD *)(v14 + 40) = *((_QWORD *)v13 + 5);
      *(_OWORD *)(v14 + 24) = v15;
      *((_QWORD *)v13 + 4) = 0LL;
      *((_QWORD *)v13 + 5) = 0LL;
      *((_QWORD *)v13 + 3) = 0LL;
LABEL_9:
      if ( ++v8 == 8 )
      {
        v24 = *(_DWORD *)result & 0xFFFFFFFE;
        *v11 = v82;
        *(_DWORD *)result = v24;
        return result;
      }
    }
  }
  v25 = 0LL;
  v26 = result + 8;
  v27 = a2 + 8;
  v77 = HIBYTE(v80);
  do
  {
    v31 = (unsigned __int8 *)(v26 + 48 * v25);
    v32 = *v31;
    if ( (v32 & 1) != 0 )
      v33 = *((_QWORD *)v31 + 1);
    else
      v33 = v32 >> 1;
    v34 = 0;
    if ( v33 )
    {
      if ( v33 == 1 )
      {
        if ( (v32 & 1) != 0 )
        {
          v34 = **(unsigned __int8 **)(v26 + 48 * v25 + 16) == v77;
        }
        else
        {
          v35 = v31 + 1;
          v36 = (v32 >> 1) - 1;
          v37 = (unsigned __int8 *)&v80 + 1;
          do
          {
            v39 = *v35++;
            v38 = v39;
            v40 = *v37++;
            v41 = v38 == v40;
            v34 = v38 == v40;
            v41 = !v41 || v36-- == 0;
          }
          while ( !v41 );
        }
      }
      v34 ^= 1u;
    }
    v42 = (unsigned __int8 *)(v27 + 48 * v25);
    v43 = *v42;
    v44 = v43 >> 1;
    if ( (v43 & 1) != 0 )
      v45 = *(_QWORD *)(v27 + 48 * v25 + 8);
    else
      v45 = v43 >> 1;
    v46 = 0;
    if ( !v45 )
      goto LABEL_60;
    if ( v45 == 1 )
    {
      if ( (v43 & 1) != 0 )
      {
        v46 = **(unsigned __int8 **)(v27 + 48 * v25 + 16) == v77;
      }
      else
      {
        v47 = v42 + 1;
        v48 = (unsigned __int8 *)&v80 + 1;
        while ( *v47 == *v48 )
        {
          --v44;
          ++v47;
          ++v48;
          if ( !v44 )
          {
            v46 = 0;
            goto LABEL_60;
          }
        }
        v46 = 0;
      }
    }
    v49 = v46;
    v46 ^= 1u;
    if ( (v49 & 1) != 0 || ((v34 ^ 1) & 1) != 0 )
    {
LABEL_60:
      v69 = *((_QWORD *)v42 + 2);
      v70 = *(_OWORD *)v31;
      v71 = *((_QWORD *)v31 + 2);
      *(_OWORD *)v31 = *(_OWORD *)v42;
      *((_QWORD *)v31 + 2) = v69;
      *(_OWORD *)v42 = v70;
      *((_QWORD *)v42 + 2) = v71;
      if ( v34 )
      {
        v28 = v26 + 48 * v25;
        v29 = v27 + 48 * v25;
LABEL_25:
        v30 = *(_OWORD *)(v28 + 24);
        *(_QWORD *)(v29 + 40) = *(_QWORD *)(v28 + 40);
        *(_OWORD *)(v29 + 24) = v30;
        *(_QWORD *)(v28 + 32) = 0LL;
        *(_QWORD *)(v28 + 40) = 0LL;
        *(_QWORD *)(v28 + 24) = 0LL;
        goto LABEL_26;
      }
      if ( v46 )
      {
        v28 = v27 + 48 * v25;
        v29 = v26 + 48 * v25;
        goto LABEL_25;
      }
    }
    else
    {
      v50 = v31[1];
      v51 = v31[25];
      v52 = v26 + 48 * v25;
      v53 = *(_QWORD *)(v31 + 2);
      v54 = *((_QWORD *)v31 + 1);
      *(_QWORD *)v31 = 0LL;
      *((_QWORD *)v31 + 1) = 0LL;
      v79 = v51;
      v55 = *(_QWORD *)(v31 + 26);
      v58 = *(_BYTE *)(v52 + 24);
      v56 = (_QWORD *)(v52 + 24);
      v57 = v58;
      v59 = *(v56 - 1);
      *((_QWORD *)v31 + 2) = 0LL;
      *(_QWORD *)&v82 = v53;
      v60 = v56[2];
      *(_QWORD *)((char *)&v82 + 6) = v54;
      v83[0] = v55;
      v78 = v60;
      v61 = *((_QWORD *)v31 + 4);
      *v56 = 0LL;
      v56[1] = 0LL;
      v56[2] = 0LL;
      v62 = *((_QWORD *)v42 + 2);
      *(_QWORD *)((char *)v83 + 6) = v61;
      v63 = *(_OWORD *)v42;
      *((_QWORD *)v31 + 2) = v62;
      *(_OWORD *)v31 = v63;
      *(_WORD *)v42 = 0;
      if ( (*(_BYTE *)v56 & 1) != 0 )
        result = sub_6575460();
      v64 = (__int128 *)(v27 + 48 * v25 + 24);
      v65 = *v64;
      v56[2] = *(_QWORD *)(v27 + 48 * v25 + 40);
      *(_OWORD *)v56 = v65;
      v66 = *v42;
      *(_WORD *)v64 = 0;
      if ( (v66 & 1) != 0 )
      {
        result = sub_6575460();
        v72 = v82;
        v73 = *(_QWORD *)((char *)&v82 + 6);
        *(_QWORD *)(v27 + 48 * v25 + 16) = v59;
        v74 = *(_BYTE *)v64;
        *v42 = v32;
        v42[1] = v50;
        *(_QWORD *)(v42 + 2) = v72;
        *((_QWORD *)v42 + 1) = v73;
        if ( (v74 & 1) != 0 )
          result = sub_6575460();
      }
      else
      {
        v67 = v82;
        v68 = *(_QWORD *)((char *)&v82 + 6);
        *v42 = v32;
        v42[1] = v50;
        *(_QWORD *)(v42 + 2) = v67;
        *((_QWORD *)v42 + 1) = v68;
        *(_QWORD *)(v27 + 48 * v25 + 16) = v59;
      }
      v75 = v83[0];
      v76 = *(_QWORD *)((char *)v83 + 6);
      *(_BYTE *)v64 = v57;
      *(_QWORD *)(v42 + 26) = v75;
      *((_QWORD *)v42 + 4) = v76;
      v42[25] = v79;
      *(_QWORD *)(v27 + 48 * v25 + 40) = v78;
    }
LABEL_26:
    ++v25;
  }
  while ( v25 != 8 );
  return result;
}


================================================================================
Function: sub_641A780 (0x641A780)
================================================================================

long double __fastcall sub_641A780(__int64 a1, char *s, __int64 a3)
{
  size_t v6; // x0
  size_t v7; // x21
  void *v8; // x23
  unsigned __int64 v9; // x24
  long double result; // q0

  v6 = strlen(s);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v9 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (void *)sub_6575418();
    *(_QWORD *)(a1 + 8) = v7;
    *(_QWORD *)(a1 + 16) = v8;
    *(_QWORD *)a1 = v9 | 1;
  }
  else
  {
    *(_BYTE *)a1 = 2 * v6;
    v8 = (void *)(a1 + 1);
    if ( !v6 )
      goto LABEL_7;
  }
  memcpy(v8, s, v7);
LABEL_7:
  *((_BYTE *)v8 + v7) = 0;
  result = *(long double *)a3;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a3 + 16);
  *(long double *)(a1 + 24) = result;
  *(_QWORD *)(a3 + 8) = 0LL;
  *(_QWORD *)(a3 + 16) = 0LL;
  *(_QWORD *)a3 = 0LL;
  return result;
}


================================================================================
Function: sub_641A838 (0x641A838)
================================================================================

bool __fastcall sub_641A838(int a1)
{
  __int64 v2; // x0
  unsigned __int64 v4; // x8
  unsigned __int8 v5; // w8

  v2 = sub_645C2F0();
  if ( (sub_645C530(v2) & 1) == 0 )
    return 0LL;
  if ( a1 != 1 || byte_71CF7B0 && byte_6F7A660 )
    return 1LL;
  v4 = *((_QWORD *)&xmmword_6F7A9D8 + 1);
  if ( (xmmword_6F7A9D8 & 1) == 0 )
    v4 = (unsigned __int64)(unsigned __int8)xmmword_6F7A9D8 >> 1;
  if ( !v4 )
    return 0LL;
  v5 = atomic_load(byte_6F7A7D8);
  if ( (v5 & 1) == 0 )
  {
    if ( (unsigned int)sub_67EB6E0((__int64)byte_6F7A7D8) )
    {
      byte_6F7A7D0 = sub_641C87C() & 1;
      sub_67EB838(byte_6F7A7D8);
    }
  }
  return byte_6F7A7D0 != 0;
}


================================================================================
Function: sub_641A918 (0x641A918)
================================================================================

__int64 __fastcall sub_641A918(
        unsigned __int8 *a1,
        __int64 a2,
        char a3,
        __int64 a4,
        unsigned int a5,
        unsigned int a6,
        _QWORD *a7,
        unsigned int a8)
{
  unsigned __int8 v16; // w8
  void (__fastcall ***v17)(_QWORD, _QWORD *, _QWORD); // x27
  __int64 result; // x0
  unsigned __int64 v19; // x8
  bool v20; // zf
  size_t v21; // x8
  const void *v22; // x22
  size_t v23; // x23
  char *v24; // x10
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x8
  __int64 v29; // x26
  unsigned __int64 v30; // x25
  int v31; // w22
  char *v32; // x1
  size_t v33; // x2
  unsigned __int64 *v34; // x19
  unsigned __int64 *v35; // x19
  char s2; // [xsp+8h] [xbp-98h] BYREF
  _BYTE v37[15]; // [xsp+9h] [xbp-97h] BYREF
  __int64 v38; // [xsp+20h] [xbp-80h] BYREF
  unsigned __int64 v39; // [xsp+28h] [xbp-78h]
  char *v40; // [xsp+30h] [xbp-70h]
  unsigned __int64 v41[3]; // [xsp+38h] [xbp-68h] BYREF
  char v42; // [xsp+50h] [xbp-50h]
  _QWORD v43[4]; // [xsp+70h] [xbp-30h] BYREF
  __int64 v44; // [xsp+90h] [xbp-10h]

  v16 = atomic_load(byte_6F7A818);
  if ( (v16 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6F7A818) )
  {
    sub_641D6DC();
    __cxa_atexit((void (*)(void *))sub_641D81C, &qword_6F7A7E0, &off_67F7780);
    sub_67EB838(byte_6F7A818);
  }
  sub_67D1968((pthread_mutex_t *)&xmmword_6F7A7F0);
  v17 = (void (__fastcall ***)(_QWORD, _QWORD *, _QWORD))qword_6F7A7E0;
  v43[3] = qword_6F7A7E0;
  v44 = qword_6F7A7E8;
  if ( qword_6F7A7E8 )
    sub_67F0410(1uLL, (atomic_ullong *)(qword_6F7A7E8 + 8));
  result = sub_67D19BC((pthread_mutex_t *)&xmmword_6F7A7F0);
  if ( !v17 )
    goto LABEL_58;
  sub_6416C3C(v43, a1, a2, a4, a5, a6);
  (**v17)(v17, v43, a3 & 1);
  v19 = *a1;
  v20 = (v19 & 1) == 0;
  v21 = v19 >> 1;
  if ( v20 )
    v22 = a1 + 1;
  else
    v22 = (const void *)*((_QWORD *)a1 + 2);
  if ( v20 )
    v23 = v21;
  else
    v23 = *((_QWORD *)a1 + 1);
  result = (__int64)sub_67D2788(v41, (__int128 *)&word_6F7A7A8);
  v24 = (char *)v41[2];
  v25 = (unsigned __int64)LOBYTE(v41[0]) >> 1;
  if ( (v41[0] & 1) != 0 )
    v25 = v41[1];
  else
    v24 = (char *)v41 + 1;
  v38 = (__int64)v24;
  v39 = v25;
  if ( !v25 )
  {
    v31 = 0;
    if ( (v41[0] & 1) != 0 )
      goto LABEL_34;
    goto LABEL_35;
  }
  do
  {
    s2 = 44;
    v26 = sub_657ECD8((int)&v38, &s2, 1uLL);
    if ( v26 == -1LL )
    {
      result = v38;
      v29 = 0LL;
      v30 = 0LL;
      if ( v39 != v23 )
        goto LABEL_16;
    }
    else
    {
      result = v38;
      if ( v39 >= v26 )
        v27 = v26;
      else
        v27 = v39;
      if ( v39 >= v26 + 1 )
        v28 = v26 + 1;
      else
        v28 = v39;
      v29 = v38 + v28;
      v30 = v39 - v28;
      if ( v27 != v23 )
        goto LABEL_16;
    }
    if ( !v23 || (result = memcmp((const void *)result, v22, v23), !(_DWORD)result) )
    {
      v31 = 1;
      goto LABEL_33;
    }
LABEL_16:
    v38 = v29;
    v39 = v30;
  }
  while ( v30 );
  v31 = 0;
LABEL_33:
  if ( (v41[0] & 1) != 0 )
LABEL_34:
    result = sub_6575460();
LABEL_35:
  if ( v31 )
  {
    sub_67D4090(&v38, "pointsv2_dualwrite_", a1);
    v37[7] = 0;
    s2 = 14;
    if ( (v38 & 1) != 0 )
      v32 = v40;
    else
      v32 = (char *)&v38 + 1;
    if ( (v38 & 1) != 0 )
      v33 = v39;
    else
      v33 = (unsigned __int64)(unsigned __int8)v38 >> 1;
    qmemcpy(v37, "default", 7);
    sub_258083C((int)v41, v32, v33, (int)&unk_6F7A770, v37, 7uLL);
    if ( (s2 & 1) != 0 )
      sub_6575460();
    if ( (v38 & 1) != 0 )
      sub_6575460();
    sub_6536F58(&v38, v41);
    result = v38;
    if ( v38 && *a7 )
    {
      (*(void (**)(void))(*(_QWORD *)v38 + 96LL))();
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v38 + 88LL))(v38, a8);
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v38 + 48LL))(v38);
    }
    v34 = (unsigned __int64 *)v39;
    if ( v39 )
    {
      result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v39 + 8));
      if ( !result )
      {
        (*(void (__fastcall **)(unsigned __int64 *))(*v34 + 16))(v34);
        result = sub_67D18A4(v34);
      }
    }
    if ( (v42 & 1) != 0 )
      result = sub_6575460();
    if ( (v41[0] & 1) != 0 )
      result = sub_6575460();
  }
  if ( (v43[0] & 1) != 0 )
    result = sub_6575460();
LABEL_58:
  v35 = (unsigned __int64 *)v44;
  if ( v44 )
  {
    result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v44 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v35 + 16))(v35);
      return sub_67D18A4(v35);
    }
  }
  return result;
}


================================================================================
Function: sub_641AD80 (0x641AD80)
================================================================================

unsigned __int64 __fastcall sub_641AD80(unsigned __int64 result)
{
  unsigned __int64 *v1; // x19

  v1 = *(unsigned __int64 **)(result + 8);
  if ( v1 )
  {
    result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v1 + 1));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v1 + 16))(v1);
      return sub_67D18A4(v1);
    }
  }
  return result;
}


================================================================================
Function: sub_641ADD0 (0x641ADD0)
================================================================================

__int64 __fastcall sub_641ADD0(__int64 a1, __int64 a2, char a3, __int64 a4, unsigned int a5, unsigned int a6)
{
  unsigned __int8 v12; // w8
  __int64 (__fastcall ***v13)(_QWORD, _QWORD *, _QWORD); // x25
  __int64 result; // x0
  unsigned __int64 *v15; // x19
  _QWORD v16[4]; // [xsp+0h] [xbp-30h] BYREF
  __int64 v17; // [xsp+20h] [xbp-10h]

  v12 = atomic_load(byte_6F7A818);
  if ( (v12 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6F7A818) )
  {
    sub_641D6DC();
    __cxa_atexit((void (*)(void *))sub_641D81C, &qword_6F7A7E0, &off_67F7780);
    sub_67EB838(byte_6F7A818);
  }
  sub_67D1968((pthread_mutex_t *)&xmmword_6F7A7F0);
  v13 = (__int64 (__fastcall ***)(_QWORD, _QWORD *, _QWORD))qword_6F7A7E0;
  v16[3] = qword_6F7A7E0;
  v17 = qword_6F7A7E8;
  if ( qword_6F7A7E8 )
    sub_67F0410(1uLL, (atomic_ullong *)(qword_6F7A7E8 + 8));
  result = sub_67D19BC((pthread_mutex_t *)&xmmword_6F7A7F0);
  if ( v13 )
  {
    sub_6416C3C(v16, a1, a2, a4, a5, a6);
    result = (**v13)(v13, v16, a3 & 1);
    if ( (v16[0] & 1) != 0 )
      result = sub_6575460();
  }
  v15 = (unsigned __int64 *)v17;
  if ( v17 )
  {
    result = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v17 + 8));
    if ( !result )
    {
      (*(void (__fastcall **)(unsigned __int64 *))(*v15 + 16))(v15);
      return sub_67D18A4(v15);
    }
  }
  return result;
}


================================================================================
Function: sub_641B178 (0x641B178)
================================================================================

__int64 __fastcall sub_641B178(
        __int64 result,
        char *a2,
        char *a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  __int64 v14; // x22
  __int64 v15; // x23
  char *v16; // x24
  size_t v17; // x0
  __int64 v18; // x2
  __int64 v19; // x22
  size_t v20; // x0

  if ( a2 )
  {
    v14 = result;
    result = (__int64)sub_641BD30(result, a2, 0, a4, a5, a6, a7, 0LL, a9, a10, a11, a12);
    if ( result )
    {
      v15 = result;
      if ( a3 )
        v16 = a3;
      else
        v16 = &byte_CBCB6C;
      v17 = strlen(v16);
      if ( v17 >= 0xF000 )
        v18 = 61440LL;
      else
        v18 = v17;
      result = sub_6416634(v15, v16, v18);
      if ( byte_71CF7B0 && byte_6F7A788 )
      {
        v19 = *(_QWORD *)(v14 + 456);
        if ( v19 )
        {
          v20 = strlen(a2);
          return (*(__int64 (__fastcall **)(__int64, char *, size_t, char *, __int64))(*(_QWORD *)v19 + 32LL))(
                   v19,
                   a2,
                   v20,
                   a3,
                   1LL);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_641B25C (0x641B25C)
================================================================================

__int64 __fastcall sub_641B25C(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_641B264(a1, a2, a3, 0LL);
}


================================================================================
Function: sub_641B264 (0x641B264)
================================================================================

__int64 __fastcall sub_641B264(
        __int64 result,
        char *a2,
        unsigned __int8 *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        long double a9,
        long double a10,
        long double a11,
        long double a12)
{
  char v13; // w20
  __int64 v15; // x22
  unsigned __int64 v16; // x8
  bool v17; // zf
  unsigned __int64 v18; // x8
  unsigned __int8 *v19; // x1
  __int64 v20; // x2
  __int64 v21; // x22
  size_t v22; // x2
  unsigned __int64 v23; // x8
  bool v24; // zf
  unsigned __int64 v25; // x8
  unsigned __int8 *v26; // x3
  unsigned __int64 v27; // x4

  if ( a2 )
  {
    v13 = a4;
    v15 = result;
    result = (__int64)sub_641BD30(result, a2, a4 & 1, a9, a10, a11, a12, a4, a5, a6, a7, a8);
    if ( result )
    {
      v16 = *a3;
      v17 = (v16 & 1) == 0;
      v18 = (v16 & 1) != 0 ? *((_QWORD *)a3 + 1) : v16 >> 1;
      v19 = v17 ? a3 + 1 : (unsigned __int8 *)*((_QWORD *)a3 + 2);
      v20 = v18 >= 0xF000 ? 61440LL : v18;
      result = sub_6416634(result, v19, v20);
      if ( byte_71CF7B0 )
      {
        if ( byte_6F7A788 )
        {
          v21 = *(_QWORD *)(v15 + 456);
          if ( v21 )
          {
            v22 = strlen(a2);
            v23 = *a3;
            v24 = (v23 & 1) == 0;
            v25 = v23 >> 1;
            if ( v24 )
              v26 = a3 + 1;
            else
              v26 = (unsigned __int8 *)*((_QWORD *)a3 + 2);
            if ( v24 )
              v27 = v25;
            else
              v27 = *((_QWORD *)a3 + 1);
            return (*(__int64 (__fastcall **)(__int64, char *, size_t, unsigned __int8 *, unsigned __int64, bool))(*(_QWORD *)v21 + 24LL))(
                     v21,
                     a2,
                     v22,
                     v26,
                     v27,
                     (v13 & 1) == 0);
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_641B574 (0x641B574)
================================================================================

__int64 __fastcall sub_641B574(__int64 a1, __int64 a2)
{
  return sub_641B57C(a1, a2, 0LL);
}


================================================================================
Function: sub_641B57C (0x641B57C)
================================================================================

__int64 __fastcall sub_641B57C(
        __int64 a1,
        char *a2,
        char a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        long double a9,
        long double a10,
        long double a11,
        long double a12)
{
  double v12; // d8
  __int64 result; // x0
  __int64 v17; // x22
  __int128 v18; // q0
  __int64 v19; // x21
  size_t v20; // x2
  __int128 v21; // [xsp+0h] [xbp-30h] BYREF
  __int64 v22; // [xsp+10h] [xbp-20h]

  v12 = *(double *)&a9;
  result = (__int64)sub_641BD30(a1, a2, a3 & 1, a9, a10, a11, a12, a4, a5, a6, a7, a8);
  if ( result )
  {
    v17 = result;
    result = sub_6579D18("%f", &v21);
    if ( (*(_BYTE *)v17 & 1) != 0 )
      result = sub_6575460();
    v18 = v21;
    *(_QWORD *)(v17 + 16) = v22;
    *(_OWORD *)v17 = v18;
    if ( byte_71CF7B0 )
    {
      if ( byte_6F7A788 )
      {
        v19 = *(_QWORD *)(a1 + 456);
        if ( v19 )
        {
          if ( a2 )
            v20 = strlen(a2);
          else
            v20 = 0LL;
          return (*(__int64 (__fastcall **)(__int64, char *, size_t, bool, double))(*(_QWORD *)v19 + 16LL))(
                   v19,
                   a2,
                   v20,
                   (a3 & 1) == 0,
                   v12);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_641B6E8 (0x641B6E8)
================================================================================

__int64 __fastcall sub_641B6E8(__int64 a1, char *a2, int a3)
{
  __int64 result; // x0
  __int64 v7; // x23
  __int128 v8; // q0
  __int64 (__fastcall ***v9)(_QWORD, char *, size_t, _QWORD, __int64); // x22
  size_t v10; // x2
  __int128 v11; // [xsp+0h] [xbp-20h] BYREF
  __int64 v12; // [xsp+10h] [xbp-10h]

  result = sub_641BD30(a1, a2);
  if ( result )
  {
    v7 = result;
    result = sub_6579D18("%di", &v11);
    if ( (*(_BYTE *)v7 & 1) != 0 )
      result = sub_6575460();
    v8 = v11;
    *(_QWORD *)(v7 + 16) = v12;
    *(_OWORD *)v7 = v8;
    if ( byte_71CF7B0 )
    {
      if ( byte_6F7A788 )
      {
        v9 = *(__int64 (__fastcall ****)(_QWORD, char *, size_t, _QWORD, __int64))(a1 + 456);
        if ( v9 )
        {
          if ( a2 )
            v10 = strlen(a2);
          else
            v10 = 0LL;
          return (**v9)(v9, a2, v10, a3, 1LL);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_641BD30 (0x641BD30)
================================================================================

_WORD *__fastcall sub_641BD30(
        __int64 a1,
        char *s,
        char a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12)
{
  int v15; // w8
  _WORD *v16; // x8
  size_t v17; // x0
  size_t v18; // x22
  char *v19; // x23
  const char *v20; // x3
  __int64 i; // x8
  int v22; // w11
  bool v23; // cf
  bool v24; // cf
  size_t v25; // x0
  size_t v26; // x22
  char *v27; // x23
  unsigned __int64 v28; // x24
  __int64 v29; // x8
  char v30; // w22
  unsigned __int8 *v31; // x21
  __int128 v32; // q0
  __int64 v33; // x8
  unsigned __int64 v35; // x24
  __int64 v36; // x8
  char v37; // w22
  __int128 v38; // q0
  __int64 v39; // x8
  __int128 v40; // [xsp+0h] [xbp-50h] BYREF
  char *v41; // [xsp+10h] [xbp-40h]
  __int128 v42; // [xsp+18h] [xbp-38h]
  __int64 v43; // [xsp+28h] [xbp-28h]
  unsigned __int8 *v44; // [xsp+30h] [xbp-20h] BYREF
  _QWORD v45[2]; // [xsp+38h] [xbp-18h] BYREF

  if ( !*(_BYTE *)(a1 + 420) )
    return 0LL;
  if ( !byte_71CF7B0 || !byte_6F7A640 )
  {
    if ( !*s )
      return 0LL;
    memset(v45, 0, 15);
    v17 = strlen(s);
    if ( v17 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_67D2618();
    v18 = v17;
    if ( v17 >= 0x17 )
    {
      v28 = (v17 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v19 = (char *)sub_6575418();
      *((_QWORD *)&v40 + 1) = v18;
      v41 = v19;
      *(_QWORD *)&v40 = v28 | 1;
    }
    else
    {
      v19 = (char *)&v40 + 1;
      LOBYTE(v40) = 2 * v17;
      if ( !v17 )
      {
LABEL_44:
        v29 = v45[0];
        v19[v18] = 0;
        LOBYTE(v42) = 0;
        *(_QWORD *)((char *)&v42 + 1) = v29;
        *((_QWORD *)&v42 + 1) = *(_QWORD *)((char *)v45 + 7);
        v43 = 0LL;
        v30 = sub_641E054(a1, (unsigned __int8 *)&v40, &v44);
        v31 = v44;
        if ( (v30 & 1) != 0 )
        {
          if ( (v42 & 1) == 0 )
          {
            if ( (v40 & 1) == 0 )
              goto LABEL_47;
LABEL_52:
            sub_6575460();
            if ( (v30 & 1) == 0 )
              goto LABEL_70;
LABEL_53:
            if ( (a3 & 1) != 0 )
              goto LABEL_70;
            return 0LL;
          }
          sub_6575460();
          if ( (v40 & 1) != 0 )
            goto LABEL_52;
        }
        else
        {
          v31 = sub_641E354((_DWORD *)a1, (__int64)&v40, (unsigned __int8 *)&v40, v44);
          if ( (*v31 & 1) != 0 )
            sub_6575460();
          v32 = v40;
          *((_QWORD *)v31 + 2) = v41;
          *(_OWORD *)v31 = v32;
          LOWORD(v40) = 0;
          v33 = v43;
          *(_OWORD *)(v31 + 24) = v42;
          *((_QWORD *)v31 + 5) = v33;
          v43 = 0LL;
          v42 = 0uLL;
          if ( (v40 & 1) != 0 )
            goto LABEL_52;
        }
LABEL_47:
        if ( (v30 & 1) == 0 )
          goto LABEL_70;
        goto LABEL_53;
      }
    }
    memcpy(v19, s, v18);
    goto LABEL_44;
  }
  if ( s )
  {
    v15 = (unsigned __int8)*s;
    if ( (unsigned int)(v15 - 48) < 0xA || (unsigned int)(v15 - 65) < 0x1A || (unsigned int)(v15 - 97) <= 0x19 )
    {
      for ( i = 1LL; ; ++i )
      {
        v22 = (unsigned __int8)s[i];
        v23 = (unsigned int)(v22 - 48) >= 0xA && (unsigned int)(v22 - 65) >= 0x1A;
        v24 = v23 && (unsigned int)(v22 - 97) >= 0x1A;
        if ( v24
          && ((unsigned int)(v22 - 37) > 0x3A || ((1LL << ((unsigned __int8)v22 - 37)) & 0x400000000200701LL) == 0) )
        {
          break;
        }
      }
      if ( !s[i] && (unsigned int)i < 0x81 )
      {
        memset(v45, 0, 15);
        v25 = strlen(s);
        if ( v25 >= 0xFFFFFFFFFFFFFFF0LL )
          sub_67D2618();
        v26 = v25;
        if ( v25 >= 0x17 )
        {
          v35 = (v25 + 16) & 0xFFFFFFFFFFFFFFF0LL;
          v27 = (char *)sub_6575418();
          *((_QWORD *)&v40 + 1) = v26;
          v41 = v27;
          *(_QWORD *)&v40 = v35 | 1;
        }
        else
        {
          v27 = (char *)&v40 + 1;
          LOBYTE(v40) = 2 * v25;
          if ( !v25 )
          {
LABEL_60:
            v36 = v45[0];
            v27[v26] = 0;
            LOBYTE(v42) = 0;
            *(_QWORD *)((char *)&v42 + 1) = v36;
            *((_QWORD *)&v42 + 1) = *(_QWORD *)((char *)v45 + 7);
            v43 = 0LL;
            v37 = sub_641E054(a1, (unsigned __int8 *)&v40, &v44);
            v31 = v44;
            if ( (v37 & 1) != 0 )
            {
              if ( (v42 & 1) == 0 )
              {
                if ( (v40 & 1) == 0 )
                  goto LABEL_63;
LABEL_68:
                sub_6575460();
                if ( (v37 & 1) == 0 )
                  goto LABEL_70;
LABEL_69:
                if ( (a3 & 1) != 0 )
                  goto LABEL_70;
                return 0LL;
              }
              sub_6575460();
              if ( (v40 & 1) != 0 )
                goto LABEL_68;
            }
            else
            {
              v31 = sub_641E354((_DWORD *)a1, (__int64)&v40, (unsigned __int8 *)&v40, v44);
              if ( (*v31 & 1) != 0 )
                sub_6575460();
              v38 = v40;
              *((_QWORD *)v31 + 2) = v41;
              *(_OWORD *)v31 = v38;
              LOWORD(v40) = 0;
              v39 = v43;
              *(_OWORD *)(v31 + 24) = v42;
              *((_QWORD *)v31 + 5) = v39;
              v43 = 0LL;
              v42 = 0uLL;
              if ( (v40 & 1) != 0 )
                goto LABEL_68;
            }
LABEL_63:
            if ( (v37 & 1) == 0 )
            {
LABEL_70:
              v16 = v31 + 24;
              if ( (v31[24] & 1) != 0 )
              {
                **((_BYTE **)v31 + 5) = 0;
                *((_QWORD *)v31 + 4) = 0LL;
              }
              else
              {
                *v16 = 0;
              }
              return v16;
            }
            goto LABEL_69;
          }
        }
        memcpy(v27, s, v26);
        goto LABEL_60;
      }
    }
  }
  if ( *(_BYTE *)(a1 + 448) )
    ++*(_DWORD *)(a1 + 452);
  if ( byte_71CF760 )
  {
    v16 = 0LL;
    if ( (unsigned __int8)qword_6F7A450 < 6u || BYTE1(qword_6F7A450) < 3u )
      return v16;
  }
  else if ( !(_BYTE)qword_6F7A450 )
  {
    return 0LL;
  }
  if ( s )
    v20 = s;
  else
    v20 = "NULL";
  sub_654E814(
    qword_6F7A450,
    qword_6F7A458,
    "[DFLog::InfluxTrace] Rejected invalid key name: %s",
    (__int64)v20,
    a9,
    a10,
    a11,
    a12,
    a4,
    a5,
    a6,
    a7,
    v40);
  return 0LL;
}


================================================================================
Function: sub_641C358 (0x641C358)
================================================================================

__int64 __fastcall sub_641C358(__int64 a1, __int64 a2, int a3, char a4)
{
  __int64 result; // x0
  __int64 v9; // x0
  __int64 v10; // x0
  __int64 v11; // x8
  __int64 v12; // x10
  __int64 v13; // x11
  unsigned __int64 v14; // x8
  _WORD *v16; // x23
  unsigned __int64 v17; // x8
  char v19; // w0
  __int64 v20; // x23
  __int64 v21; // x23
  unsigned __int64 *v22; // x19
  __int128 v23; // q0
  __int64 v24; // x8
  _WORD *v25; // x24
  unsigned __int64 v26; // x8
  __int64 v27; // x1
  unsigned __int64 v28; // x8
  __int64 v29; // x2
  __int64 v30; // x23
  _QWORD v31[5]; // [xsp+0h] [xbp-210h] BYREF
  __int128 v32; // [xsp+28h] [xbp-1E8h] BYREF
  __int64 v33; // [xsp+38h] [xbp-1D8h]
  __int128 v34; // [xsp+40h] [xbp-1D0h]
  __int64 v35; // [xsp+50h] [xbp-1C0h]
  __int64 v36; // [xsp+58h] [xbp-1B8h]
  __int64 v37; // [xsp+60h] [xbp-1B0h]
  _QWORD v38[3]; // [xsp+68h] [xbp-1A8h] BYREF
  char v39[8]; // [xsp+80h] [xbp-190h] BYREF

  if ( byte_71C5038 )
    return sub_6419D44(a1, a2, (unsigned int)a3, 1LL, a4 & 1);
  sub_25D550C(v39, 0LL);
  v9 = sub_641A2A0(v39, a1);
  if ( byte_71CF7B0 )
  {
    if ( byte_6F7A788 )
    {
      v10 = sub_6537108(v9);
      v11 = v36;
      if ( v36 && *(_QWORD *)(a1 + 456) )
      {
        v12 = *(_QWORD *)(a1 + 464);
        v13 = v37;
        v36 = *(_QWORD *)(a1 + 456);
        v37 = v12;
        *(_QWORD *)(a1 + 456) = v11;
        *(_QWORD *)(a1 + 464) = v13;
      }
      if ( byte_71CF7B0 && byte_6F7A6E0 )
      {
        v14 = *(unsigned __int8 *)(a1 + 424);
        if ( (v14 & 1) != 0 ? *(_QWORD *)(a1 + 432) : v14 >> 1 )
        {
          memset(&v31[2], 0, 24);
          sub_641A780((int)&v32, "pointsdebug");
          sub_6419C34(v38, v39, &v32);
          v16 = (_WORD *)(a1 + 424);
          sub_2502DA8(&v32);
          sub_64166D4(v38[0] + 24LL, a1 + 424);
          v10 = v36;
          if ( v36 )
            v10 = (*(__int64 (**)(void))(*(_QWORD *)v36 + 24LL))();
          if ( (*(_BYTE *)v16 & 1) != 0 )
          {
            **(_BYTE **)(a1 + 440) = 0;
            *(_QWORD *)(a1 + 432) = 0LL;
          }
          else
          {
            *v16 = 0;
          }
        }
      }
      if ( !*(_BYTE *)(a1 + 420) )
        goto LABEL_36;
      v21 = *(unsigned int *)(a1 + 416);
      if ( dword_6C2FC88 == -1 )
      {
        dword_6C2FC88 = (unsigned int)sub_657A0FC(v10) % 0x2710;
        if ( dword_6C2FC88 >= a3 )
        {
LABEL_36:
          v22 = (unsigned __int64 *)v37;
          if ( v37 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v37 + 8)) )
          {
            (*(void (__fastcall **)(unsigned __int64 *))(*v22 + 16))(v22);
            sub_67D18A4(v22);
          }
          goto LABEL_63;
        }
      }
      else if ( dword_6C2FC88 >= a3 )
      {
        goto LABEL_36;
      }
      if ( (sub_641A838(*(unsigned int *)(a1 + 416)) & 1) != 0 )
      {
        v31[0] = v36;
        v31[1] = v37;
        if ( v37 )
          sub_67F0410(1uLL, (atomic_ullong *)(v37 + 8));
        ((void (__fastcall *)(__int64, char *, _QWORD, __int64, __int64, _QWORD, _QWORD *, _QWORD))sub_641A918)(
          a2,
          v39,
          a4 & 1,
          a1 + 392,
          v21,
          (unsigned int)a3,
          v31,
          *(unsigned int *)(a1 + 416));
        sub_641AD80(v31);
      }
      goto LABEL_36;
    }
    if ( byte_6F7A6E0 )
    {
      v17 = *(unsigned __int8 *)(a1 + 424);
      if ( (v17 & 1) != 0 ? *(_QWORD *)(a1 + 432) : v17 >> 1 )
      {
        BYTE12(v32) = 0;
        LOBYTE(v32) = 22;
        DWORD2(v32) = 1735746149;
        LOBYTE(v34) = 0;
        *(_QWORD *)((char *)&v32 + 1) = *(_QWORD *)"pointsdebug";
        *(_QWORD *)((char *)&v34 + 1) = 0LL;
        *((_QWORD *)&v34 + 1) = 0LL;
        v35 = 0LL;
        v19 = sub_641E054(v39, &v32, v38);
        v20 = v38[0];
        if ( (v19 & 1) != 0 )
        {
          if ( (v34 & 1) != 0 )
            sub_6575460();
        }
        else
        {
          v20 = sub_641E354(v39, &v32, &v32, v38[0]);
          if ( (*(_BYTE *)v20 & 1) != 0 )
            sub_6575460();
          v23 = v32;
          *(_QWORD *)(v20 + 16) = v33;
          *(_OWORD *)v20 = v23;
          LOWORD(v32) = 0;
          v24 = v35;
          *(_OWORD *)(v20 + 24) = v34;
          *(_QWORD *)(v20 + 40) = v24;
          v35 = 0LL;
          v34 = 0uLL;
        }
        v25 = (_WORD *)(a1 + 424);
        if ( (v32 & 1) != 0 )
          sub_6575460();
        v26 = *(unsigned __int8 *)(a1 + 424);
        if ( (v26 & 1) != 0 )
          v27 = *(_QWORD *)(a1 + 440);
        else
          v27 = a1 + 425;
        if ( (v26 & 1) != 0 )
          v28 = *(_QWORD *)(a1 + 432);
        else
          v28 = v26 >> 1;
        if ( v28 >= 0xF000 )
          v29 = 61440LL;
        else
          v29 = v28;
        v9 = sub_6416634(v20 + 24, v27, v29);
        if ( (*(_BYTE *)v25 & 1) != 0 )
        {
          **(_BYTE **)(a1 + 440) = 0;
          *(_QWORD *)(a1 + 432) = 0LL;
        }
        else
        {
          *v25 = 0;
        }
      }
    }
  }
  if ( *(_BYTE *)(a1 + 420) )
  {
    v30 = *(unsigned int *)(a1 + 416);
    if ( dword_6C2FC88 == -1 )
    {
      dword_6C2FC88 = (unsigned int)sub_657A0FC(v9) % 0x2710;
      if ( dword_6C2FC88 >= a3 )
        goto LABEL_63;
    }
    else if ( dword_6C2FC88 >= a3 )
    {
      goto LABEL_63;
    }
    if ( (sub_641A838(*(unsigned int *)(a1 + 416)) & 1) != 0 )
      sub_641ADD0(a2, v39, a4 & 1, a1 + 392, v30, (unsigned int)a3);
  }
LABEL_63:
  result = sub_254B784(v39);
  if ( (v39[0] & 1) == 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_641C87C (0x641C87C)
================================================================================

__int64 sub_641C87C()
{
  char v0; // w19
  char v1; // w19
  char v2; // w20
  char v3; // w21
  char v4; // w22
  char v5; // w23
  char v6; // w24
  char v7; // w19
  _QWORD v9[2]; // [xsp+8h] [xbp-38h] BYREF
  _QWORD v10[2]; // [xsp+20h] [xbp-20h] BYREF

  if ( (int)((unsigned int)sub_657A0FC() % 0x2710) <= dword_6F7A570 )
  {
    sub_6539F88(v10);
    v1 = sub_6416518(&xmmword_6F7A9D8, &word_6F7A470);
    v2 = sub_6416518(v10, &word_6F7A498);
    v3 = sub_6416518(&xmmword_6F7A978, &word_6F7A4C0);
    sub_6539FE0(v9);
    v4 = sub_6416518(v9, &word_6F7A4E8);
    if ( (v9[0] & 1) != 0 )
      sub_6575460();
    v5 = sub_6416518(&xmmword_6F7A9A8, &word_6F7A510);
    sub_653A254(v9);
    v6 = sub_6416518(v9, &word_6F7A538);
    v7 = v1 & v2 & v3 & v4 & v5;
    if ( (v9[0] & 1) != 0 )
      sub_6575460();
    v0 = v7 & v6;
    if ( (v10[0] & 1) != 0 )
      sub_6575460();
  }
  else
  {
    v0 = 0;
  }
  return v0 & 1;
}


================================================================================
Function: sub_641D6DC (0x641D6DC)
================================================================================

long double sub_641D6DC()
{
  bool v0; // zf
  __int64 v1; // x0
  __int64 v2; // x20
  __int64 v3; // x19
  __int64 v4; // x20
  __int64 v5; // x0
  long double result; // q0

  if ( byte_71CF7B0 )
    v0 = byte_7286120 == 0;
  else
    v0 = 1;
  if ( v0 )
  {
    v3 = sub_6575418();
    *(_QWORD *)(v3 + 128) = 0LL;
    *(_QWORD *)v3 = off_6BA97E8;
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_QWORD *)(v3 + 24) = off_6BA9790;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    v1 = sub_6577314(0x6000uLL);
    v4 = v3 + 24;
    *(_QWORD *)(v3 + 128) = 0LL;
    *(_QWORD *)(v3 + 64) = v1;
    *(_QWORD *)(v3 + 72) = 1024LL;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
  }
  else
  {
    v2 = sub_678E980();
    v3 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v2 + 16LL))(v2, 144LL, 8LL);
    *(_QWORD *)(v3 + 16) = 0LL;
    *(_QWORD *)(v3 + 24) = v2;
    *(_QWORD *)(v3 + 136) = 0LL;
    *(_QWORD *)v3 = off_6BA9740;
    *(_QWORD *)(v3 + 8) = 0LL;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
    *(_QWORD *)(v3 + 32) = off_6BA9790;
    v4 = v3 + 32;
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    v5 = sub_6577314(0x6000uLL);
    *(_QWORD *)(v3 + 136) = 0LL;
    *(_QWORD *)(v3 + 72) = v5;
    *(_QWORD *)(v3 + 80) = 1024LL;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 104) = 0u;
    *(_OWORD *)(v3 + 120) = 0u;
  }
  *(_OWORD *)&result = 0uLL;
  qword_6F7A7E0 = v4;
  qword_6F7A7E8 = v3;
  xmmword_6F7A7F0 = 0u;
  unk_6F7A800 = 0u;
  qword_6F7A810 = 0LL;
  return result;
}


================================================================================
Function: sub_641E054 (0x641E054)
================================================================================

__int64 __fastcall sub_641E054(__int64 a1, unsigned __int8 *a2, _QWORD *a3)
{
  void *v4; // x22
  int v5; // w11
  __int64 v6; // x23
  size_t v7; // x9
  char *v8; // x10
  unsigned __int64 v10; // x8
  unsigned __int8 *v11; // x24
  unsigned __int64 v12; // x12
  char *v13; // x13
  unsigned __int64 v14; // x10
  __int64 v15; // t1
  unsigned int v16; // w20
  unsigned __int8 *v17; // x13
  int v18; // w26
  int i; // w28
  __int64 v20; // x25
  __int64 v21; // x10
  unsigned __int8 *v22; // x21
  size_t v23; // x2
  unsigned __int64 v24; // x11
  unsigned __int64 v25; // x9
  unsigned __int8 *v26; // x0
  unsigned __int8 *v27; // x1
  unsigned __int8 *v28; // x8
  void *v29; // x27
  int v30; // w22
  unsigned __int8 *v31; // x28
  int v32; // w0
  char v33; // w0
  char v34; // w8
  unsigned __int8 *v36; // [xsp+0h] [xbp-40h]
  __int16 v37; // [xsp+8h] [xbp-38h] BYREF
  char v38; // [xsp+Ah] [xbp-36h]
  __int16 v39[8]; // [xsp+20h] [xbp-20h] BYREF

  v4 = &_stack_chk_guard;
  v5 = *(_DWORD *)(a1 + 16);
  if ( (*(_DWORD *)a1 & 1) != 0 )
  {
    v5 = 8;
    v6 = a1 + 8;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 8);
  }
  if ( v5 )
  {
    v7 = *((_QWORD *)a2 + 1);
    v8 = (char *)*((_QWORD *)a2 + 2);
    v10 = *a2;
    v11 = a2 + 1;
    v39[0] = 0;
    v37 = 24322;
    v12 = v10 >> 1;
    if ( (v10 & 1) != 0 )
    {
      v12 = v7;
      v13 = v8;
    }
    else
    {
      v13 = (char *)(a2 + 1);
    }
    v38 = 0;
    if ( v12 )
    {
      v14 = 0LL;
      do
      {
        v15 = *v13++;
        --v12;
        v14 ^= (v14 << 6) + (v14 >> 2) + v15 + 2654435769u;
      }
      while ( v12 );
    }
    else
    {
      LODWORD(v14) = 0;
    }
    v17 = 0LL;
    v18 = v5 - 1;
    for ( i = 1; ; ++i )
    {
      v20 = (unsigned int)v14 & v18;
      v21 = (unsigned __int8)(v10 >> 1);
      v22 = (unsigned __int8 *)(v6 + 48LL * (unsigned int)v20);
      if ( (v10 & 1) != 0 )
        v23 = v7;
      else
        v23 = (unsigned __int8)(v10 >> 1);
      v24 = *v22;
      v25 = v24 >> 1;
      if ( (v24 & 1) != 0 )
        v25 = *((_QWORD *)v22 + 1);
      if ( v23 == v25 )
      {
        if ( (v10 & 1) != 0 )
          v26 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
        else
          v26 = v11;
        if ( (v24 & 1) != 0 )
          v27 = *(unsigned __int8 **)(v6 + 48 * v20 + 16);
        else
          v27 = v22 + 1;
        if ( (v10 & 1) != 0 )
        {
          if ( !v23 || (v29 = v4, v30 = i, v31 = v17, v32 = memcmp(v26, v27, v23), v17 = v31, i = v30, v4 = v29, !v32) )
          {
LABEL_37:
            v16 = 1;
            goto LABEL_38;
          }
        }
        else
        {
          v28 = v11;
          if ( !v23 )
            goto LABEL_37;
          while ( *v28 == *v27 )
          {
            --v21;
            ++v28;
            ++v27;
            if ( !v21 )
              goto LABEL_37;
          }
        }
      }
      v36 = v17;
      if ( (sub_641E298(v6 + 48LL * (unsigned int)v20, v39) & 1) != 0 )
        break;
      v33 = sub_641E298(v6 + 48LL * (unsigned int)v20, &v37);
      v17 = v36;
      v7 = *((_QWORD *)a2 + 1);
      LODWORD(v14) = v20 + i;
      v10 = *a2;
      if ( v36 == 0LL && (v33 & 1) != 0 )
        v17 = (unsigned __int8 *)(v6 + 48LL * (unsigned int)v20);
    }
    v16 = 0;
    if ( v36 )
      v22 = v36;
LABEL_38:
    v34 = v37;
    *a3 = v22;
    if ( (v34 & 1) != 0 )
      sub_6575460();
    if ( (v39[0] & 1) != 0 )
      sub_6575460();
  }
  else
  {
    v16 = 0;
    *a3 = 0LL;
  }
  return v16;
}


================================================================================
Function: sub_641E298 (0x641E298)
================================================================================

bool __fastcall sub_641E298(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x9
  unsigned __int64 v3; // x11
  size_t v4; // x2
  unsigned __int64 v5; // x8
  const void *v6; // x8
  unsigned __int8 *v7; // x1
  unsigned __int8 *v8; // x8
  __int64 v9; // x9
  int v10; // w10
  int v11; // t1
  int v12; // t1
  _BOOL8 result; // x0

  v2 = *a1;
  v3 = *a2;
  if ( (v2 & 1) != 0 )
    v4 = *((_QWORD *)a1 + 1);
  else
    v4 = v2 >> 1;
  v5 = v3 >> 1;
  if ( (v3 & 1) != 0 )
    v5 = *((_QWORD *)a2 + 1);
  if ( v4 != v5 )
    return 0LL;
  v6 = (const void *)*((_QWORD *)a1 + 2);
  if ( (v2 & 1) == 0 )
    v6 = a1 + 1;
  if ( (v3 & 1) != 0 )
    v7 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v7 = a2 + 1;
  if ( (v2 & 1) != 0 )
  {
    if ( v4 )
      return memcmp(v6, v7, v4) == 0;
    return 1LL;
  }
  if ( !v4 )
    return 1LL;
  v8 = a1 + 1;
  v9 = (v2 >> 1) - 1;
  do
  {
    v11 = *v8++;
    v10 = v11;
    v12 = *v7++;
    result = v10 == v12;
  }
  while ( v10 == v12 && v9-- != 0 );
  return result;
}


================================================================================
Function: sub_641E354 (0x641E354)
================================================================================

unsigned __int8 *__fastcall sub_641E354(_DWORD *a1, __int64 a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int v6; // w8
  __int64 v7; // x1
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x8
  unsigned __int8 *v11; // [xsp+0h] [xbp-10h] BYREF

  v6 = *a1 >> 1;
  if ( (*a1 & 1) != 0 )
    v7 = 8LL;
  else
    v7 = (unsigned int)a1[4];
  if ( 4 * v6 + 4 >= (unsigned int)(3 * v7) )
  {
    v7 = (unsigned int)(2 * v7);
  }
  else if ( (int)v7 + ~v6 - a1[1] > (unsigned int)v7 >> 3 )
  {
    goto LABEL_6;
  }
  sub_641E444(a1, v7);
  sub_641E054((__int64)a1, a3, &v11);
  a4 = v11;
LABEL_6:
  *a1 += 2;
  v8 = *a4;
  if ( (v8 & 1) != 0 )
    v9 = *((_QWORD *)a4 + 1);
  else
    v9 = v8 >> 1;
  if ( v9 )
    --a1[1];
  return a4;
}


================================================================================
Function: sub_641E444 (0x641E444)
================================================================================

__int64 __fastcall sub_641E444(__int64 result, unsigned int a2)
{
  unsigned int v2; // w20
  __int64 v3; // x25
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x8
  int v7; // w8
  __int64 v8; // x21
  __int64 v9; // x19
  unsigned __int64 v10; // x9
  __int64 v11; // x23
  unsigned __int64 v12; // x8
  __int64 v13; // x24
  _BYTE *v14; // x21
  unsigned __int8 *v15; // x25
  unsigned __int64 v16; // x19
  unsigned __int64 v17; // x27
  size_t v18; // x22
  const void *v19; // x0
  unsigned __int8 *v20; // x1
  unsigned __int8 *v21; // x8
  unsigned __int64 v22; // x9
  unsigned __int64 v23; // x9
  const void *v24; // x0
  unsigned __int8 *v25; // x1
  unsigned __int8 *v26; // x8
  __int64 v27; // x9
  __int128 v28; // q0
  __int128 v29; // q0
  char v30; // w8
  __int64 v31; // [xsp+0h] [xbp-1D0h]
  __int16 v32; // [xsp+10h] [xbp-1C0h] BYREF
  char v33; // [xsp+12h] [xbp-1BEh]
  unsigned __int64 v34; // [xsp+18h] [xbp-1B8h]
  __int16 v35; // [xsp+28h] [xbp-1A8h] BYREF
  char *v36; // [xsp+30h] [xbp-1A0h]
  unsigned __int8 *v37; // [xsp+38h] [xbp-198h]
  _BYTE v38[384]; // [xsp+40h] [xbp-190h] BYREF

  v2 = a2;
  v3 = result;
  if ( a2 >= 8 )
  {
    v4 = (a2 - 1) | ((unsigned __int64)(a2 - 1) >> 1);
    v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    v6 = v5 | (v5 >> 8) | ((v5 | (v5 >> 8)) >> 16);
    v7 = HIDWORD(v6) | v6;
    if ( (unsigned int)(v7 + 1) > 0x10 )
      v2 = v7 + 1;
    else
      v2 = 16;
  }
  if ( (*(_DWORD *)result & 1) == 0 )
  {
    v8 = *(_QWORD *)(result + 8);
    v9 = *(unsigned int *)(result + 16);
    if ( v2 > 8 )
    {
      *(_QWORD *)(result + 8) = sub_6575418();
      *(_QWORD *)(v3 + 16) = v2;
    }
    else
    {
      *(_DWORD *)result |= 1u;
    }
    sub_641E7C0(v3, v8, v8 + 48 * v9);
    return sub_6575460();
  }
  if ( v2 < 8 )
    return result;
  v10 = (unsigned __int64)&v32 + 1;
  v11 = result + 8;
  v12 = 0LL;
  v13 = 0LL;
  v14 = v38;
  v31 = result;
  v15 = (unsigned __int8 *)(result + 8);
  v35 = 0;
  v32 = 24322;
  v33 = 0;
  while ( 1 )
  {
    v16 = *v15;
    v17 = v16 >> 1;
    if ( (v16 & 1) != 0 )
      v18 = *(_QWORD *)(v11 + 48 * v13 + 8);
    else
      v18 = v16 >> 1;
    if ( (v12 & 1) == 0 )
      v10 = (unsigned __int8)(v12 >> 1);
    if ( v18 == v10 )
    {
      if ( (v16 & 1) != 0 )
        v19 = *(const void **)(v11 + 48 * v13 + 16);
      else
        v19 = v15 + 1;
      if ( (v12 & 1) != 0 )
        v20 = v37;
      else
        v20 = (unsigned __int8 *)&v35 + 1;
      if ( (v16 & 1) != 0 )
      {
        if ( !v18 || !memcmp(v19, v20, v18) )
          goto LABEL_45;
      }
      else
      {
        if ( !v18 )
          goto LABEL_46;
        v21 = v15 + 1;
        v22 = v16 >> 1;
        while ( *v21 == *v20 )
        {
          --v22;
          ++v21;
          ++v20;
          if ( !v22 )
            goto LABEL_46;
        }
      }
    }
    v23 = v34;
    if ( (v32 & 1) == 0 )
      v23 = (unsigned __int64)(unsigned __int8)v32 >> 1;
    if ( v18 != v23 )
      goto LABEL_44;
    if ( (v16 & 1) != 0 )
      v24 = *(const void **)(v11 + 48 * v13 + 16);
    else
      v24 = v15 + 1;
    v25 = (unsigned __int8 *)&v32 + 1;
    if ( (v16 & 1) == 0 )
    {
      if ( !v18 )
        goto LABEL_46;
      v26 = v15 + 1;
      while ( *v26 == *v25 )
      {
        --v17;
        ++v26;
        ++v25;
        if ( !v17 )
          goto LABEL_46;
      }
LABEL_44:
      v27 = v11 + 48 * v13;
      v28 = *(_OWORD *)v15;
      *((_QWORD *)v14 + 2) = *((_QWORD *)v15 + 2);
      *(_OWORD *)v14 = v28;
      *(_QWORD *)v15 = 0LL;
      *((_QWORD *)v15 + 1) = 0LL;
      *((_QWORD *)v15 + 2) = 0LL;
      v29 = *(_OWORD *)(v27 + 24);
      *((_QWORD *)v14 + 5) = *(_QWORD *)(v27 + 40);
      *(_OWORD *)(v14 + 24) = v29;
      v14 += 48;
      *(_QWORD *)(v27 + 32) = 0LL;
      *(_QWORD *)(v27 + 40) = 0LL;
      v30 = *v15;
      *(_QWORD *)(v27 + 24) = 0LL;
      if ( (v30 & 1) == 0 )
        goto LABEL_46;
      goto LABEL_45;
    }
    if ( v18 && memcmp(v24, (char *)&v32 + 1, v18) )
      goto LABEL_44;
LABEL_45:
    sub_6575460();
LABEL_46:
    if ( ++v13 == 8 )
      break;
    v12 = (unsigned __int8)v35;
    v15 = (unsigned __int8 *)(v11 + 48 * v13);
    v10 = (unsigned __int64)v36;
  }
  *(_DWORD *)v31 &= ~1u;
  *(_QWORD *)(v31 + 8) = sub_6575418();
  *(_QWORD *)(v31 + 16) = v2;
  result = sub_641E7C0(v31, v38, v14);
  if ( (v32 & 1) != 0 )
    result = sub_6575460();
  if ( (v35 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_641E7C0 (0x641E7C0)
================================================================================

__int64 __fastcall sub_641E7C0(__int64 result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  _DWORD *v5; // x21
  char v6; // w10
  int v7; // w10
  unsigned __int64 *v8; // x22
  __int64 v9; // x8
  __int64 v10; // x24
  int v11; // w24
  unsigned __int64 v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x8
  __int64 v15; // x9
  _BYTE *v16; // x25
  __int128 v17; // q0
  __int64 v18; // x8
  __int128 v19; // q0
  __int128 v20; // [xsp+8h] [xbp-28h] BYREF
  _BYTE *v21; // [xsp+20h] [xbp-10h] BYREF

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  LOWORD(v20) = 0;
  v7 = v6 & 1;
  if ( v7 )
    v8 = (unsigned __int64 *)(result + 8);
  else
    v8 = *(unsigned __int64 **)(result + 8);
  if ( v7 )
    v9 = 8LL;
  else
    v9 = *(unsigned int *)(result + 16);
  *(_DWORD *)result = v7;
  *(_DWORD *)(result + 4) = 0;
  if ( (_DWORD)v9 )
  {
    v10 = 48 * v9;
    do
    {
      result = (__int64)sub_67D2788(v8, &v20);
      v8 += 6;
      v10 -= 48LL;
    }
    while ( v10 );
    if ( (v20 & 1) != 0 )
      result = sub_6575460();
  }
  BYTE2(v20) = 0;
  LOWORD(v20) = 24322;
  if ( a2 != a3 )
  {
    v11 = BYTE1(v20);
    while ( 1 )
    {
      v12 = *a2;
      v13 = *((_QWORD *)a2 + 1);
      v14 = v12 >> 1;
      if ( (v12 & 1) == 0 )
        v13 = v12 >> 1;
      if ( !v13 )
        goto LABEL_29;
      if ( v13 != 1 )
        goto LABEL_25;
      if ( (v12 & 1) == 0 )
        break;
      if ( **((unsigned __int8 **)a2 + 2) != v11 )
        goto LABEL_25;
LABEL_29:
      if ( (*a2 & 1) != 0 )
        result = sub_6575460();
      a2 += 48;
      if ( a2 == a3 )
        return result;
    }
    v15 = 0LL;
    while ( a2[v15 + 1] == *((unsigned __int8 *)&v20 + v15 + 1) )
    {
      if ( v14 == ++v15 )
        goto LABEL_29;
    }
LABEL_25:
    result = sub_641E054((__int64)v5, a2, &v21);
    v16 = v21;
    if ( (*v21 & 1) != 0 )
      result = sub_6575460();
    v17 = *(_OWORD *)a2;
    *((_QWORD *)v16 + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v16 = v17;
    v18 = *((_QWORD *)a2 + 5);
    *(_WORD *)a2 = 0;
    v19 = *(_OWORD *)(a2 + 24);
    *((_QWORD *)v16 + 5) = v18;
    *(_OWORD *)(v16 + 24) = v19;
    *((_QWORD *)a2 + 4) = 0LL;
    *((_QWORD *)a2 + 5) = 0LL;
    *((_QWORD *)a2 + 3) = 0LL;
    *v5 += 2;
    if ( (a2[24] & 1) != 0 )
      result = sub_6575460();
    goto LABEL_29;
  }
  return result;
}


================================================================================
Function: sub_641F6E0 (0x641F6E0)
================================================================================

char *__fastcall sub_641F6E0(unsigned int a1)
{
  if ( a1 > 2 )
    return &byte_CBCB6C;
  else
    return off_6BA9828[a1];
}


================================================================================
Function: sub_641FF44 (0x641FF44)
================================================================================

double sub_641FF44()
{
  return sub_6580A00() - *(double *)&qword_6F7AAA0;
}


================================================================================
Function: sub_641FF64 (0x641FF64)
================================================================================

bool sub_641FF64()
{
  bool v0; // zf

  if ( byte_71CF7B0 )
    v0 = byte_71CD990 == 0;
  else
    v0 = 1;
  if ( v0 )
    return 0LL;
  if ( (unsigned __int8)byte_6F7A918 | (unsigned __int8)byte_6F7A938 )
    return 1LL;
  return byte_6F7A958 != 0;
}


================================================================================
Function: sub_641FFC4 (0x641FFC4)
================================================================================

bool sub_641FFC4()
{
  bool v0; // zf

  if ( byte_71CF7B0 )
    v0 = byte_71CD990 == 0;
  else
    v0 = 1;
  return !v0 && byte_6F7A918 != 0;
}


================================================================================
Function: sub_6420004 (0x6420004)
================================================================================

bool sub_6420004()
{
  bool v0; // zf

  if ( byte_71CF7B0 )
    v0 = byte_71CD990 == 0;
  else
    v0 = 1;
  return !v0 && byte_6F7A938 != 0;
}


================================================================================
Function: sub_6420044 (0x6420044)
================================================================================

bool sub_6420044()
{
  bool v0; // zf

  if ( byte_71CF7B0 )
    v0 = byte_71CD990 == 0;
  else
    v0 = 1;
  return !v0 && byte_6F7A958 != 0;
}


================================================================================
Function: sub_6420084 (0x6420084)
================================================================================

unsigned __int8 *__fastcall sub_6420084(unsigned __int8 *result, int a2)
{
  unsigned __int8 *v3; // x20
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x8
  bool v6; // w8
  char *v7; // x2
  _QWORD v8[3]; // [xsp+8h] [xbp-1F8h] BYREF
  _BYTE v9[472]; // [xsp+20h] [xbp-1E0h] BYREF

  v3 = result;
  v4 = *result;
  if ( (v4 & 1) != 0 )
    v5 = *((_QWORD *)result + 1);
  else
    v5 = v4 >> 1;
  if ( v5 == 19 )
  {
    result = (unsigned __int8 *)sub_67D3100(result, 0LL, 0xFFFFFFFFFFFFFFFFLL, "ContextInfoMismatch", 0x13uLL);
    v6 = (_DWORD)result == 0;
    if ( !a2 )
      return result;
  }
  else
  {
    v6 = 0;
    if ( !a2 )
      return result;
  }
  if ( !v6 )
  {
    result = (unsigned __int8 *)sub_657A0FC();
    if ( (unsigned int)result % 0x2710 < dword_6F7A900 )
    {
      sub_6416B58((__int64)v9, -1, 0);
      if ( (a2 & 1) != 0 )
      {
        sub_653EEEC(v8, 1LL);
        sub_641B25C(v9, "PlaceIdFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_6575460();
        sub_641B25C(v9, "PlaceIdFromAnalytics", &xmmword_6F7A9D8);
      }
      if ( (a2 & 8) != 0 )
      {
        sub_653EEEC(v8, 9LL);
        sub_641B25C(v9, "PlaceVersionFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_6575460();
        sub_641B25C(v9, "PlaceVersionFromAnalytics", &xmmword_6F7A9F0);
      }
      if ( (a2 & 2) != 0 )
      {
        sub_653EEEC(v8, 2LL);
        sub_641B25C(v9, "UniverseIdFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_6575460();
        sub_641B25C(v9, "UniverseIdFromAnalytics", &xmmword_6F7AA50);
      }
      if ( (a2 & 4) != 0 )
      {
        sub_653EEEC(v8, 3LL);
        sub_641B25C(v9, "DatacenterIdFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_6575460();
        sub_641B6E8((__int64)v9, "DatacenterIdFromAnalytics", dword_6C2FCA4);
      }
      if ( (a2 & 0x10) != 0 )
      {
        sub_653EEEC(v8, 10LL);
        sub_641B25C(v9, "ServerIpFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_6575460();
        sub_641B25C(v9, "ServerIpFromAnalytics", &qword_6F7AA08);
      }
      if ( (a2 & 0x20) != 0 )
      {
        sub_653EEEC(v8, 11LL);
        sub_641B25C(v9, "ServerPortFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_6575460();
        sub_641B6E8((__int64)v9, "ServerPortFromAnalytics", dword_6C2FCA0);
      }
      if ( (a2 & 0x40) != 0 )
      {
        sub_653EEEC(v8, 12LL);
        sub_641B25C(v9, "StreamingEnabledFromContextInfo", v8);
        if ( (v8[0] & 1) != 0 )
          sub_6575460();
        if ( (unsigned int)dword_6F7AA80 > 2 )
          v7 = &byte_CBCB6C;
        else
          v7 = off_6BA9828[dword_6F7AA80];
        sub_641B178(v9, "StreamingEnabledFromAnalytics", v7);
      }
      sub_641B25C(v9, "EventName", v3);
      sub_653EF60(v8, 0LL);
      sub_641B25C(v9, "PrimaryContext", v8);
      if ( (v8[0] & 1) != 0 )
        sub_6575460();
      sub_653EEEC(v8, 0LL);
      sub_641B25C(v9, "CurrentContext", v8);
      if ( (v8[0] & 1) != 0 )
        sub_6575460();
      sub_641B6E8((__int64)v9, "MismatchedFields", a2);
      strcpy((char *)v8, "&ContextInfoMismatch");
      sub_641C358((__int64)v9, (__int64)v8, 10000, 0);
      if ( (v8[0] & 1) != 0 )
        sub_6575460();
      return (unsigned __int8 *)sub_254B3DC((__int64)v9);
    }
  }
  return result;
}


================================================================================
Function: sub_64204F4 (0x64204F4)
================================================================================

long double __fastcall sub_64204F4(__int64 a1)
{
  long double result; // q0

  *(_QWORD *)(a1 + 128) = 0LL;
  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)a1 = "TelemetryInformation";
  *(_QWORD *)(a1 + 8) = 20LL;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 1065353216;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 88) = 1065353216;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  return result;
}


================================================================================
Function: sub_642052C (0x642052C)
================================================================================

__int64 __fastcall sub_642052C(__int64 a1)
{
  return a1 + 16;
}


================================================================================
Function: sub_6420534 (0x6420534)
================================================================================

__int64 __fastcall sub_6420534(__int64 a1)
{
  return a1 + 56;
}


================================================================================
Function: sub_64206EC (0x64206EC)
================================================================================

__int64 __fastcall sub_64206EC(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  __int64 v6; // x0
  __int64 result; // x0
  __int64 **v8; // x0
  _QWORD v9[3]; // [xsp+0h] [xbp-30h] BYREF
  __int128 *v10; // [xsp+20h] [xbp-10h] BYREF

  if ( (*(_BYTE *)a2 & 1) != 0 )
    v6 = *(_QWORD *)(a2 + 16);
  else
    v6 = a2 + 1;
  result = sub_6416970(v6);
  if ( (result & 1) != 0 )
  {
    sub_67D1968((pthread_mutex_t *)(a1 + 96));
    memset(v9, 0, sizeof(v9));
    sub_64166D4((__int64)v9, a3);
    v10 = (__int128 *)a2;
    v8 = sub_2591944((__int64 *)(a1 + 56), (unsigned __int8 *)a2, (__int64)&unk_16B39E4, &v10);
    sub_67D3420((unsigned __int8 *)v8 + 40, (unsigned __int8 *)v9);
    if ( (v9[0] & 1) != 0 )
      sub_6575460();
    return sub_67D19BC((pthread_mutex_t *)(a1 + 96));
  }
  return result;
}


================================================================================
Function: sub_64207EC (0x64207EC)
================================================================================

__int64 __fastcall sub_64207EC(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v6; // x0
  __int64 result; // x0
  __int64 **v8; // x0
  _QWORD v9[3]; // [xsp+0h] [xbp-30h] BYREF
  __int128 *v10; // [xsp+20h] [xbp-10h] BYREF

  if ( (*(_BYTE *)a2 & 1) != 0 )
    v6 = *(_QWORD *)(a2 + 16);
  else
    v6 = a2 + 1;
  result = sub_6416970(v6);
  if ( (result & 1) != 0 )
  {
    sub_67D1968((pthread_mutex_t *)(a1 + 96));
    memset(v9, 0, sizeof(v9));
    sub_6416790(v9, a3);
    v10 = (__int128 *)a2;
    v8 = sub_2591944((__int64 *)(a1 + 56), (unsigned __int8 *)a2, (__int64)&unk_16B39E4, &v10);
    sub_67D3420((unsigned __int8 *)v8 + 40, (unsigned __int8 *)v9);
    if ( (v9[0] & 1) != 0 )
      sub_6575460();
    return sub_67D19BC((pthread_mutex_t *)(a1 + 96));
  }
  return result;
}


================================================================================
Function: sub_6421008 (0x6421008)
================================================================================

__int64 __fastcall sub_6421008(__int64 a1)
{
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)a1 = "AnalyticsStaticAttributes";
  *(_QWORD *)(a1 + 8) = 25LL;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_64210B4();
  return sub_6421544(a1);
}


================================================================================
Function: sub_64210B4 (0x64210B4)
================================================================================

__int64 __fastcall sub_64210B4(__int64 a1)
{
  unsigned __int64 *v1; // x20
  unsigned __int8 v2; // w8
  __int64 *v3; // x19
  __int64 v4; // x0
  __int64 v5; // x21
  __int64 v6; // x0
  __int64 v7; // x0
  char *v8; // x1
  size_t v9; // x2
  __int64 v10; // x0
  unsigned __int64 v11; // x21
  char *v12; // x1
  size_t v13; // x2
  unsigned __int64 v14; // x21
  _QWORD *v15; // x0
  char *v16; // x1
  size_t v17; // x2
  char *v18; // x1
  size_t v19; // x2
  __int64 result; // x0
  __int128 v21; // [xsp+8h] [xbp-58h] BYREF
  unsigned __int8 v22; // [xsp+20h] [xbp-40h] BYREF
  char v23[15]; // [xsp+21h] [xbp-3Fh] BYREF
  char *v24; // [xsp+30h] [xbp-30h]
  __int128 v25; // [xsp+38h] [xbp-28h] BYREF
  _BYTE v26[8]; // [xsp+50h] [xbp-10h] BYREF

  v1 = (unsigned __int64 *)(a1 + 16);
  sub_658A084((unsigned __int64 *)(a1 + 16), 0x200uLL);
  sub_67D3284(v1, "application");
  sub_6589DEC(v1, 61);
  LOBYTE(v25) = 12;
  strcpy((char *)&v25 + 1, "Client");
  v2 = atomic_load(byte_6D1B678);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6D1B678) )
  {
    qword_6D1B638 = (__int64)off_67F87E8;
    sub_67D19DC(&stru_6D1B640);
    qword_6D1B668 = 0LL;
    unk_6D1B670 = 0LL;
    qword_6D1B638 = (__int64)off_6897788;
    qword_6C382D8 = (__int64)&qword_6D1B638;
    sub_67EB838(byte_6D1B678);
  }
  v3 = (__int64 *)sub_32F11B4((__int64)&qword_6D1B638);
  v4 = sub_642052C(v3[6]);
  v22 = 22;
  strcpy(v23, "application");
  v5 = sub_261941C(v4, &v22);
  if ( (v22 & 1) != 0 )
    sub_6575460();
  if ( v5 )
  {
    v6 = sub_642052C(v3[6]);
    v22 = 22;
    strcpy(v23, "application");
    *(_QWORD *)&v21 = &v22;
    v7 = sub_250E25C(v6, &v22, &unk_16B39E5, &v21, v26);
    sub_67D3420((unsigned __int8 *)&v25, (unsigned __int8 *)(v7 + 40));
    if ( (v22 & 1) != 0 )
      sub_6575460();
  }
  sub_6416168(&v25, (unsigned __int64 *)&v22);
  if ( (v22 & 1) != 0 )
    v8 = v24;
  else
    v8 = v23;
  if ( (v22 & 1) != 0 )
    v9 = *(_QWORD *)&v23[7];
  else
    v9 = (unsigned __int64)v22 >> 1;
  sub_6588400(v1, v8, v9);
  if ( (v22 & 1) != 0 )
    sub_6575460();
  sub_6539F88(&v22);
  if ( (v22 & 1) != 0 )
    v11 = *(_QWORD *)&v23[7];
  else
    v11 = (unsigned __int64)v22 >> 1;
  if ( (v22 & 1) != 0 )
    v10 = sub_6575460();
  if ( v11 )
  {
    sub_67D352C(v1, ",ostype=");
    sub_6539F88(&v21);
    sub_6416168(&v21, (unsigned __int64 *)&v22);
    if ( (v22 & 1) != 0 )
      v12 = v24;
    else
      v12 = v23;
    if ( (v22 & 1) != 0 )
      v13 = *(_QWORD *)&v23[7];
    else
      v13 = (unsigned __int64)v22 >> 1;
    v10 = (__int64)sub_6588400(v1, v12, v13);
    if ( (v22 & 1) != 0 )
      v10 = sub_6575460();
    if ( (v21 & 1) != 0 )
      v10 = sub_6575460();
  }
  sub_6539FB0(&v22, v10);
  if ( (v22 & 1) != 0 )
    v14 = *(_QWORD *)&v23[7];
  else
    v14 = (unsigned __int64)v22 >> 1;
  if ( (v22 & 1) != 0 )
    sub_6575460();
  if ( v14 )
  {
    v15 = sub_67D352C(v1, ",osname=");
    sub_6539FB0(&v21, v15);
    sub_6416168(&v21, (unsigned __int64 *)&v22);
    if ( (v22 & 1) != 0 )
      v16 = v24;
    else
      v16 = v23;
    if ( (v22 & 1) != 0 )
      v17 = *(_QWORD *)&v23[7];
    else
      v17 = (unsigned __int64)v22 >> 1;
    sub_6588400(v1, v16, v17);
    if ( (v22 & 1) != 0 )
      sub_6575460();
    if ( (v21 & 1) != 0 )
      sub_6575460();
  }
  sub_67D352C(v1, ",appversion=");
  LOBYTE(v21) = 22;
  strcpy((char *)&v21 + 1, "2.662.0.537");
  sub_6416168(&v21, (unsigned __int64 *)&v22);
  if ( (v22 & 1) != 0 )
    v18 = v24;
  else
    v18 = v23;
  if ( (v22 & 1) != 0 )
    v19 = *(_QWORD *)&v23[7];
  else
    v19 = (unsigned __int64)v22 >> 1;
  sub_6588400(v1, v18, v19);
  if ( (v22 & 1) != 0 )
    sub_6575460();
  if ( (v21 & 1) != 0 )
    sub_6575460();
  result = (*(__int64 (__fastcall **)(__int64 *))(*v3 + 16))(v3);
  if ( (v25 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_6421544 (0x6421544)
================================================================================

__int64 __fastcall sub_6421544(__int64 a1)
{
  unsigned __int64 *v1; // x20
  char *v3; // x1
  size_t v4; // x2
  char *v5; // x1
  size_t v6; // x2
  _QWORD *v7; // x0
  char v8; // w0
  char *v9; // x1
  size_t v10; // x2
  unsigned __int8 *v11; // x19
  _QWORD *v12; // x0
  __int64 v13; // x0
  char *v14; // x1
  size_t v15; // x2
  _QWORD *v16; // x0
  char *v17; // x1
  size_t v18; // x2
  _QWORD *v19; // x0
  __int64 v20; // x0
  const char *v21; // x21
  size_t v22; // x0
  size_t v23; // x20
  char *v24; // x22
  unsigned __int64 v25; // x23
  char *v26; // x1
  size_t v27; // x2
  _QWORD *v28; // x0
  __int64 v29; // x0
  char *v30; // x1
  size_t v31; // x2
  _QWORD *v32; // x0
  __int64 v33; // x0
  char *v34; // x1
  size_t v35; // x2
  _QWORD *v36; // x0
  __int64 v37; // x0
  char *v38; // x1
  size_t v39; // x2
  __int64 v40; // x0
  _QWORD *v41; // x0
  unsigned __int64 v42; // x20
  _QWORD *v43; // x0
  char *v44; // x1
  size_t v45; // x2
  unsigned __int64 v46; // x20
  _QWORD *v47; // x0
  char *v48; // x1
  size_t v49; // x2
  _QWORD *v50; // x0
  __int64 v51; // x0
  char *v52; // x1
  size_t v53; // x2
  __int64 result; // x0
  _QWORD v55[2]; // [xsp+0h] [xbp-140h] BYREF
  _QWORD v56[2]; // [xsp+18h] [xbp-128h] BYREF
  _QWORD v57[2]; // [xsp+30h] [xbp-110h] BYREF
  _QWORD v58[2]; // [xsp+48h] [xbp-F8h] BYREF
  _QWORD v59[2]; // [xsp+60h] [xbp-E0h] BYREF
  _QWORD v60[2]; // [xsp+78h] [xbp-C8h] BYREF
  _QWORD v61[3]; // [xsp+90h] [xbp-B0h] BYREF
  _QWORD v62[2]; // [xsp+A8h] [xbp-98h] BYREF
  unsigned __int64 v63[2]; // [xsp+C0h] [xbp-80h] BYREF
  unsigned __int64 v64[2]; // [xsp+D8h] [xbp-68h] BYREF
  unsigned __int64 v65[2]; // [xsp+F0h] [xbp-50h] BYREF
  unsigned __int64 v66[2]; // [xsp+108h] [xbp-38h] BYREF
  __int64 v67; // [xsp+120h] [xbp-20h] BYREF
  size_t v68; // [xsp+128h] [xbp-18h]
  char *v69; // [xsp+130h] [xbp-10h]

  v1 = (unsigned __int64 *)(a1 + 40);
  sub_67D3284((_QWORD *)(a1 + 40), &byte_CBCB6C);
  sub_658A084(v1, 0x200uLL);
  sub_67D352C(v1, "device=");
  sub_653A254(v66);
  sub_6421DF0(&v67, v66);
  if ( (v67 & 1) != 0 )
    v3 = v69;
  else
    v3 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v4 = v68;
  else
    v4 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_6588400(v1, v3, v4);
  if ( (v67 & 1) != 0 )
    sub_6575460();
  if ( (v66[0] & 1) != 0 )
    sub_6575460();
  sub_67D352C(v1, ",osversion=");
  sub_6539FE0(v65);
  sub_6421DF0(&v67, v65);
  if ( (v67 & 1) != 0 )
    v5 = v69;
  else
    v5 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v6 = v68;
  else
    v6 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_6588400(v1, v5, v6);
  if ( (v67 & 1) != 0 )
    sub_6575460();
  if ( (v65[0] & 1) != 0 )
    sub_6575460();
  v7 = sub_67D352C(v1, ",64bit=");
  v8 = sub_6539A08(v7);
  sub_67D4DB0(v8 & 1, v64);
  sub_6421DF0(&v67, v64);
  if ( (v67 & 1) != 0 )
    v9 = v69;
  else
    v9 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v10 = v68;
  else
    v10 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_6588400(v1, v9, v10);
  if ( (v67 & 1) != 0 )
    sub_6575460();
  if ( (v64[0] & 1) != 0 )
    sub_6575460();
  v11 = (unsigned __int8 *)(a1 + 64);
  sub_67D3420(v11, (unsigned __int8 *)v1);
  v12 = sub_67D352C(v11, ",platformid=");
  v13 = sub_6539FD8(v12);
  sub_67D4DB0(v13, v63);
  sub_6421DF0(&v67, v63);
  if ( (v67 & 1) != 0 )
    v14 = v69;
  else
    v14 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v15 = v68;
  else
    v15 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_6588400((unsigned __int64 *)v11, v14, v15);
  if ( (v67 & 1) != 0 )
    sub_6575460();
  if ( (v63[0] & 1) != 0 )
    sub_6575460();
  v16 = sub_67D352C(v11, ",cpu=");
  sub_6539844(v62, v16);
  sub_6421DF0(&v67, v62);
  if ( (v67 & 1) != 0 )
    v17 = v69;
  else
    v17 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v18 = v68;
  else
    v18 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_6588400((unsigned __int64 *)v11, v17, v18);
  if ( (v67 & 1) != 0 )
    sub_6575460();
  if ( (v62[0] & 1) != 0 )
    sub_6575460();
  if ( byte_71CCD98 )
  {
    v19 = sub_67D352C(v11, ",binary_arch=");
    v20 = sub_6586B90(v19);
    v21 = (const char *)sub_6586B98(v20);
    v22 = strlen(v21);
    if ( v22 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_67D2618();
    v23 = v22;
    if ( v22 >= 0x17 )
    {
      v25 = (v22 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v24 = (char *)sub_6575418();
      v61[1] = v23;
      v61[2] = v24;
      v61[0] = v25 | 1;
    }
    else
    {
      v24 = (char *)v61 + 1;
      LOBYTE(v61[0]) = 2 * v22;
      if ( !v22 )
        goto LABEL_58;
    }
    memcpy(v24, v21, v23);
LABEL_58:
    v24[v23] = 0;
    sub_6421DF0(&v67, v61);
    if ( (v67 & 1) != 0 )
      v26 = v69;
    else
      v26 = (char *)&v67 + 1;
    if ( (v67 & 1) != 0 )
      v27 = v68;
    else
      v27 = (unsigned __int64)(unsigned __int8)v67 >> 1;
    sub_6588400((unsigned __int64 *)v11, v26, v27);
    if ( (v67 & 1) != 0 )
      sub_6575460();
    if ( (v61[0] & 1) != 0 )
      sub_6575460();
  }
  v28 = sub_67D352C(v11, ",coretotal=");
  v29 = sub_65399E4(v28);
  sub_67D523C(v60, v29);
  sub_6421DF0(&v67, v60);
  if ( (v67 & 1) != 0 )
    v30 = v69;
  else
    v30 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v31 = v68;
  else
    v31 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_6588400((unsigned __int64 *)v11, v30, v31);
  if ( (v67 & 1) != 0 )
    sub_6575460();
  if ( (v60[0] & 1) != 0 )
    sub_6575460();
  v32 = sub_67D352C(v11, ",corelogical=");
  v33 = sub_65399CC(v32);
  sub_67D523C(v59, v33);
  sub_6421DF0(&v67, v59);
  if ( (v67 & 1) != 0 )
    v34 = v69;
  else
    v34 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v35 = v68;
  else
    v35 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  sub_6588400((unsigned __int64 *)v11, v34, v35);
  if ( (v67 & 1) != 0 )
    sub_6575460();
  if ( (v59[0] & 1) != 0 )
    sub_6575460();
  v36 = sub_67D352C(v11, ",corephysical=");
  v37 = sub_65399B0(v36);
  sub_67D523C(v58, v37);
  sub_6421DF0(&v67, v58);
  if ( (v67 & 1) != 0 )
    v38 = v69;
  else
    v38 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v39 = v68;
  else
    v39 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  v40 = (__int64)sub_6588400((unsigned __int64 *)v11, v38, v39);
  if ( (v67 & 1) != 0 )
    v40 = sub_6575460();
  if ( (v58[0] & 1) != 0 )
    v40 = sub_6575460();
  v41 = sub_653A2FC(&v67, v40);
  if ( (v67 & 1) != 0 )
    v42 = v68;
  else
    v42 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  if ( (v67 & 1) != 0 )
    v41 = (_QWORD *)sub_6575460();
  if ( v42 )
  {
    v43 = sub_67D352C(v11, ",manufacturer=");
    sub_653A2FC(v57, v43);
    sub_6421DF0(&v67, v57);
    if ( (v67 & 1) != 0 )
      v44 = v69;
    else
      v44 = (char *)&v67 + 1;
    if ( (v67 & 1) != 0 )
      v45 = v68;
    else
      v45 = (unsigned __int64)(unsigned __int8)v67 >> 1;
    v41 = sub_6588400((unsigned __int64 *)v11, v44, v45);
    if ( (v67 & 1) != 0 )
      v41 = (_QWORD *)sub_6575460();
    if ( (v57[0] & 1) != 0 )
      v41 = (_QWORD *)sub_6575460();
  }
  sub_653A30C(&v67, v41);
  if ( (v67 & 1) != 0 )
    v46 = v68;
  else
    v46 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  if ( (v67 & 1) != 0 )
    sub_6575460();
  if ( v46 )
  {
    v47 = sub_67D352C(v11, ",gpu=");
    sub_653A30C(v56, v47);
    sub_6421DF0(&v67, v56);
    if ( (v67 & 1) != 0 )
      v48 = v69;
    else
      v48 = (char *)&v67 + 1;
    if ( (v67 & 1) != 0 )
      v49 = v68;
    else
      v49 = (unsigned __int64)(unsigned __int8)v67 >> 1;
    sub_6588400((unsigned __int64 *)v11, v48, v49);
    if ( (v67 & 1) != 0 )
      sub_6575460();
    if ( (v56[0] & 1) != 0 )
      sub_6575460();
  }
  v50 = sub_67D352C(v11, ",rammb=");
  v51 = sub_6539F0C(v50);
  sub_67D523C(v55, v51);
  sub_6421DF0(&v67, v55);
  if ( (v67 & 1) != 0 )
    v52 = v69;
  else
    v52 = (char *)&v67 + 1;
  if ( (v67 & 1) != 0 )
    v53 = v68;
  else
    v53 = (unsigned __int64)(unsigned __int8)v67 >> 1;
  result = (__int64)sub_6588400((unsigned __int64 *)v11, v52, v53);
  if ( (v67 & 1) != 0 )
    result = sub_6575460();
  if ( (v55[0] & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_6421DF0 (0x6421DF0)
================================================================================

__int64 __usercall sub_6421DF0@<X0>(unsigned __int8 *a1@<X0>, __int64 a2@<X8>)
{
  char *v4; // x22
  char *v5; // x8
  size_t v6; // x9
  unsigned __int64 v7; // x11
  int v8; // w10
  unsigned __int64 v9; // x11
  unsigned __int64 v10; // x12
  unsigned __int8 *v11; // x13
  unsigned __int8 *v12; // x8
  _BYTE *v13; // x10
  unsigned __int64 v14; // x14
  unsigned __int64 v15; // d1
  unsigned __int64 v16; // x11
  size_t v17; // x12
  char *v18; // x4
  char *v19; // x13
  int v20; // t1
  unsigned __int64 v21; // x11
  size_t v22; // x12
  char *v23; // x4
  char *v24; // x13
  int v25; // t1
  unsigned __int64 v26; // x11
  char *v27; // x1
  size_t v28; // x2
  unsigned __int64 *v29; // x0
  __int128 v30; // q0
  __int64 result; // x0
  __int64 v32; // x8
  __int128 v33; // q0
  char v34; // w9
  unsigned __int64 v35; // [xsp+8h] [xbp-38h] BYREF
  __int128 v36; // [xsp+20h] [xbp-20h] BYREF
  unsigned __int64 v37; // [xsp+30h] [xbp-10h]

  v4 = (char *)(a1 + 1);
  v6 = *((_QWORD *)a1 + 1);
  v5 = (char *)*((_QWORD *)a1 + 2);
  v7 = *a1;
  v8 = v7 & 1;
  v9 = v7 >> 1;
  if ( v8 )
    v10 = *((_QWORD *)a1 + 1);
  else
    v10 = v9;
  if ( v8 )
    v11 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  else
    v11 = a1 + 1;
  if ( v10 )
  {
    v12 = v11;
    if ( v10 >= 8 )
    {
      v12 = &v11[v10 & 0xFFFFFFFFFFFFFFF8LL];
      v13 = v11 + 3;
      v14 = v10 & 0xFFFFFFFFFFFFFFF8LL;
      while ( 1 )
      {
        v15 = vceq_s8(*(int8x8_t *)(v13 - 3), (int8x8_t)0x2C2C2C2C2C2C2C2CLL).n64_u64[0];
        if ( (v15 & 1) != 0 )
        {
          *(v13 - 3) = 95;
          if ( (v15 & 0x100) == 0 )
          {
LABEL_13:
            if ( (v15 & 0x10000) == 0 )
              goto LABEL_14;
            goto LABEL_22;
          }
        }
        else if ( (v15 & 0x100) == 0 )
        {
          goto LABEL_13;
        }
        *(v13 - 2) = 95;
        if ( (v15 & 0x10000) == 0 )
        {
LABEL_14:
          if ( (v15 & 0x1000000) == 0 )
            goto LABEL_15;
          goto LABEL_23;
        }
LABEL_22:
        *(v13 - 1) = 95;
        if ( (v15 & 0x1000000) == 0 )
        {
LABEL_15:
          if ( (v15 & 0x100000000LL) == 0 )
            goto LABEL_16;
          goto LABEL_24;
        }
LABEL_23:
        *v13 = 95;
        if ( (v15 & 0x100000000LL) == 0 )
        {
LABEL_16:
          if ( (v15 & 0x10000000000LL) == 0 )
            goto LABEL_17;
          goto LABEL_25;
        }
LABEL_24:
        v13[1] = 95;
        if ( (v15 & 0x10000000000LL) == 0 )
        {
LABEL_17:
          if ( (v15 & 0x1000000000000LL) == 0 )
            goto LABEL_18;
          goto LABEL_26;
        }
LABEL_25:
        v13[2] = 95;
        if ( (v15 & 0x1000000000000LL) == 0 )
        {
LABEL_18:
          if ( (v15 & 0x100000000000000LL) != 0 )
            goto LABEL_27;
          goto LABEL_10;
        }
LABEL_26:
        v13[3] = 95;
        if ( (v15 & 0x100000000000000LL) != 0 )
LABEL_27:
          v13[4] = 95;
LABEL_10:
        v14 -= 8LL;
        v13 += 8;
        if ( !v14 )
        {
          if ( v10 == (v10 & 0xFFFFFFFFFFFFFFF8LL) )
            goto LABEL_29;
          goto LABEL_43;
        }
      }
    }
    do
    {
LABEL_43:
      if ( *v12 == 44 )
        *v12 = 95;
      ++v12;
    }
    while ( v12 != &v11[v10] );
LABEL_29:
    v16 = *a1;
    v6 = *((_QWORD *)a1 + 1);
    v5 = (char *)*((_QWORD *)a1 + 2);
    v8 = v16 & 1;
    v9 = v16 >> 1;
  }
  if ( v8 )
    v17 = v6;
  else
    v17 = v9;
  if ( v8 )
    v18 = v5;
  else
    v18 = (char *)(a1 + 1);
  if ( v17 )
  {
    v19 = v18;
    while ( 1 )
    {
      v20 = (unsigned __int8)*v19++;
      if ( v20 == 92 )
        break;
      ++v18;
      if ( !--v17 )
        goto LABEL_46;
    }
    *(_QWORD *)&v36 = "\\";
    *((_QWORD *)&v36 + 1) = "";
    sub_2D35AC0(a1, (__int64 *)&v36, "\\\\", (__int64)"", v18, v18 + 1, "\\\\");
    v21 = *a1;
    v6 = *((_QWORD *)a1 + 1);
    v5 = (char *)*((_QWORD *)a1 + 2);
    v8 = v21 & 1;
    v9 = v21 >> 1;
  }
LABEL_46:
  if ( v8 )
    v22 = v6;
  else
    v22 = v9;
  if ( v8 )
    v23 = v5;
  else
    v23 = v4;
  if ( v22 )
  {
    v24 = v23;
    while ( 1 )
    {
      v25 = (unsigned __int8)*v24++;
      if ( v25 == 34 )
        break;
      ++v23;
      if ( !--v22 )
        goto LABEL_58;
    }
    *(_QWORD *)&v36 = "\"";
    *((_QWORD *)&v36 + 1) = "";
    sub_2D35AC0(a1, (__int64 *)&v36, "\\\"", (__int64)"", v23, v23 + 1, "\\\"");
    v26 = *a1;
    v6 = *((_QWORD *)a1 + 1);
    v5 = (char *)*((_QWORD *)a1 + 2);
    v8 = v26 & 1;
    v9 = v26 >> 1;
  }
LABEL_58:
  if ( v8 )
    v27 = v5;
  else
    v27 = v4;
  if ( v8 )
    v28 = v6;
  else
    v28 = v9;
  BYTE2(v35) = 0;
  LOWORD(v35) = 8706;
  v29 = sub_6588400(&v35, v27, v28);
  v30 = *(_OWORD *)v29;
  v37 = v29[2];
  v36 = v30;
  v29[1] = 0LL;
  v29[2] = 0LL;
  *v29 = 0LL;
  result = (__int64)sub_67D352C(&v36, "\"");
  v32 = *(_QWORD *)(result + 16);
  v33 = *(_OWORD *)result;
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = 0LL;
  *(_QWORD *)(result + 16) = 0LL;
  v34 = v36;
  *(_QWORD *)(a2 + 16) = v32;
  *(_OWORD *)a2 = v33;
  if ( (v34 & 1) != 0 )
    result = sub_6575460();
  if ( (v35 & 1) != 0 )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_6424E14 (0x6424E14)
================================================================================

char *sub_6424E14()
{
  __int64 v0; // x19
  unsigned __int64 v1; // x9
  unsigned __int64 v2; // x8
  size_t v3; // x2
  char *v4; // x0
  __int64 v5; // x10
  int v6; // w12
  bool v7; // zf
  unsigned int v8; // w12
  char v9; // w13
  int v10; // w12
  unsigned __int64 v11; // x11
  unsigned __int8 *v12; // x1
  __int64 v13; // x9

  v0 = qword_6F7AE98;
  v1 = *(unsigned __int8 *)qword_6F7AE98;
  v2 = v1 >> 1;
  if ( (v1 & 1) != 0 )
    v3 = *(_QWORD *)(qword_6F7AE98 + 8);
  else
    v3 = v1 >> 1;
  if ( (v1 & 1) != 0 )
    v4 = *(char **)(qword_6F7AE98 + 16);
  else
    v4 = (char *)(qword_6F7AE98 + 1);
  if ( !v3 )
    return &byte_6F7AE78;
  v5 = 0LL;
  do
  {
    v6 = v4[v5];
    v7 = v6 == 32;
    v8 = v6 - 14;
    v9 = !v7;
    v10 = (unsigned __int8)v9 & (v8 < 0xFFFFFFFB);
    if ( (v10 & 1) != 0 )
      break;
    v7 = v3 - 1 == v5++;
  }
  while ( !v7 );
  if ( !v10 )
    return &byte_6F7AE78;
  v11 = qword_6F7AE80;
  if ( (byte_6F7AE78 & 1) == 0 )
    v11 = (unsigned __int64)(unsigned __int8)byte_6F7AE78 >> 1;
  if ( v3 != v11 )
    return (char *)v0;
  if ( (byte_6F7AE78 & 1) != 0 )
    v12 = (unsigned __int8 *)qword_6F7AE88;
  else
    v12 = (unsigned __int8 *)&unk_6F7AE79;
  if ( (v1 & 1) != 0 )
  {
    if ( memcmp(v4, v12, v3) )
      return (char *)v0;
    return &byte_6F7AE78;
  }
  v13 = 0LL;
  while ( *(unsigned __int8 *)(qword_6F7AE98 + v13 + 1) == v12[v13] )
  {
    if ( v2 == ++v13 )
      return &byte_6F7AE78;
  }
  return (char *)v0;
}


================================================================================
Function: sub_6425260 (0x6425260)
================================================================================

__int64 sub_6425260()
{
  return qword_6F7AEA8;
}


================================================================================
Function: sub_6429948 (0x6429948)
================================================================================

unsigned __int64 *__usercall sub_6429948@<X0>(__int64 a1@<X0>, unsigned __int64 *a2@<X8>)
{
  unsigned __int8 *v4; // x0
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x8
  __int64 v7; // x0
  _BYTE *v8; // x8
  __int64 v9; // x0
  __int128 *v11; // x0

  v4 = (unsigned __int8 *)sub_6425260();
  v5 = *v4;
  if ( (v5 & 1) != 0 )
    v6 = *((_QWORD *)v4 + 1);
  else
    v6 = v5 >> 1;
  if ( v6
    && ((v7 = sub_6425260(), (*(_BYTE *)v7 & 1) == 0) ? (v8 = (_BYTE *)(v7 + 1)) : (v8 = *(_BYTE **)(v7 + 16)),
        a1 && *v8 == 46) )
  {
    v9 = sub_6425260();
    return sub_67D4090(a2, a1, v9);
  }
  else
  {
    v11 = (__int128 *)sub_6425260();
    return sub_67D2788(a2, v11);
  }
}


================================================================================
Function: sub_6429A24 (0x6429A24)
================================================================================

__int64 sub_6429A24()
{
  return sub_6429948("ephemeralcounters.api");
}


================================================================================
Function: sub_642AE70 (0x642AE70)
================================================================================

_QWORD *__fastcall sub_642AE70(_QWORD *result)
{
  *result = 0LL;
  result[1] = 0LL;
  return result;
}


================================================================================
Function: sub_645BBD4 (0x645BBD4)
================================================================================

__int64 __fastcall sub_645BBD4(__int64 result)
{
  int v1; // w8

  *(_BYTE *)(result + 4) = 0;
  v1 = (unsigned __int8)byte_6F7C2B8;
  *(_DWORD *)result = -1;
  *(_QWORD *)(result + 8) = -1LL;
  if ( v1 )
    result = sub_645BC20();
  if ( byte_71C5168 )
    return sub_645BDF4(result);
  return result;
}


================================================================================
Function: sub_645BC20 (0x645BC20)
================================================================================

__int64 __fastcall sub_645BC20(__int64 result)
{
  bool v1; // zf
  unsigned int *v2; // x20
  unsigned __int8 v3; // w8
  __int64 v4; // x4
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  _QWORD *v8; // x19
  long double v9; // q0
  long double v10; // q1
  long double v11; // q2
  long double v12; // q3
  __int64 v13; // x0
  __int64 v14; // x2
  __int64 v15[3]; // [xsp+0h] [xbp-20h] BYREF

  if ( byte_71CF7B0 )
    v1 = byte_71C5168 == 0;
  else
    v1 = 1;
  if ( v1 )
    return result;
  v2 = (unsigned int *)result;
  v3 = atomic_load(byte_6D1B678);
  if ( (v3 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6D1B678) )
  {
    qword_6D1B638 = (__int64)off_67F87E8;
    sub_67D19DC(&stru_6D1B640);
    qword_6D1B668 = 0LL;
    unk_6D1B670 = 0LL;
    qword_6D1B638 = (__int64)off_6897788;
    qword_6C382D8 = (__int64)&qword_6D1B638;
    sub_67EB838(byte_6D1B678);
  }
  v8 = (_QWORD *)sub_32F11B4((__int64)&qword_6D1B638);
  if ( byte_71CF7B0 && byte_71CF760 )
  {
    if ( (unsigned __int8)qword_6F7C340 < 6u || BYTE1(qword_6F7C340) < 3u )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( (_BYTE)qword_6F7C340 )
LABEL_12:
    sub_654E814(
      qword_6F7C340,
      qword_6F7C348,
      "[DFLog::ConnectionStatusMonitor] Labeling connection status %d",
      *v2,
      v4,
      v5,
      v6,
      v7,
      v9,
      v10,
      v11,
      v12,
      v15[0]);
LABEL_13:
  v13 = v8[6];
  v14 = *v2;
  strcpy((char *)v15, " connectionStatus");
  result = sub_64207EC(v13, v15, v14);
  if ( (v15[0] & 1) != 0 )
    result = sub_6575460();
  if ( v8 )
    return (*(__int64 (__fastcall **)(_QWORD *))(*v8 + 16LL))(v8);
  return result;
}


================================================================================
Function: sub_645BDF4 (0x645BDF4)
================================================================================

void sub_645BDF4()
{
  unsigned __int64 v0; // x8
  unsigned __int8 v1; // w8
  _QWORD *v2; // x19
  __int64 v3; // x0
  char v4; // [xsp+0h] [xbp-20h] BYREF
  _QWORD v5[2]; // [xsp+1h] [xbp-1Fh] BYREF

  if ( byte_71C5168 )
  {
    v0 = qword_6F7C300;
    if ( (word_6F7C2F8 & 1) == 0 )
      v0 = (unsigned __int64)(unsigned __int8)word_6F7C2F8 >> 1;
    if ( v0 )
    {
      v1 = atomic_load(byte_6D1B678);
      if ( (v1 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6D1B678) )
      {
        qword_6D1B638 = (__int64)off_67F87E8;
        sub_67D19DC(&stru_6D1B640);
        qword_6D1B668 = 0LL;
        unk_6D1B670 = 0LL;
        qword_6D1B638 = (__int64)off_6897788;
        qword_6C382D8 = (__int64)&qword_6D1B638;
        sub_67EB838(byte_6D1B678);
      }
      v2 = (_QWORD *)sub_32F11B4((__int64)&qword_6D1B638);
      v3 = v2[6];
      v4 = 30;
      strcpy((char *)v5, "Playtest_Owners");
      sub_64206EC(v3, &v4, &word_6F7C2F8);
      if ( (v4 & 1) != 0 )
        sub_6575460();
      if ( v2 )
        (*(void (__fastcall **)(_QWORD *))(*v2 + 16LL))(v2);
    }
  }
}


================================================================================
Function: sub_645C2F0 (0x645C2F0)
================================================================================

void *sub_645C2F0()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_6F7C4A8);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_6F7C4A8) )
  {
    sub_645BBD4(&unk_6F7C498);
    __cxa_atexit((void (*)(void *))sub_645BF74, &unk_6F7C498, &off_67F7780);
    sub_67EB838(byte_6F7C4A8);
  }
  return &unk_6F7C498;
}


================================================================================
Function: sub_645C530 (0x645C530)
================================================================================

bool __fastcall sub_645C530(__int64 a1)
{
  bool v1; // zf

  if ( byte_71CF7B0 )
    v1 = byte_6F7C2D8 == 0;
  else
    v1 = 1;
  return v1 || *(_BYTE *)(a1 + 4) == 0;
}


================================================================================
Function: sub_6493454 (0x6493454)
================================================================================

unsigned __int64 __fastcall sub_6493454(char *a1, const char *a2, int a3)
{
  __int64 v6; // x0
  pthread_mutex_t *v7; // x19
  unsigned __int64 v8; // x22
  unsigned __int16 v9; // w20
  int *v10; // x22
  unsigned __int16 v11; // w25
  unsigned int v12; // w28
  int v13; // w8
  unsigned int v14; // w0
  unsigned int v15; // w9
  __int64 v16; // x27
  int v17; // w10
  unsigned int v18; // w8
  unsigned int v19; // w0
  size_t v20; // x25
  char v21; // w9
  unsigned __int8 *v22; // x10
  char v23; // w8
  int v24; // t1
  char v25; // w9
  unsigned __int8 *v26; // x10
  int v27; // t1
  int *v28; // x8

  v6 = sub_6493728();
  v7 = (pthread_mutex_t *)sub_649368C(v6);
  sub_67D1AC8(v7);
  v8 = sub_6493EC4(a1, a2);
  if ( !v8 )
  {
    if ( dword_6F7D778[0] == 1024 )
    {
      v8 = 0LL;
      goto LABEL_23;
    }
    v9 = sub_6493F88(a1);
    v10 = &dword_6F7D778[23 * v9];
    v11 = dword_6F7D778[0];
    v12 = v10[481];
    v13 = v10[480] + 1;
    ++dword_6F7D778[0];
    v10[480] = v13;
    v14 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
    v15 = dword_6F7D808;
    v16 = v11;
    if ( v12 <= v14 )
      v17 = v14;
    else
      v17 = v12;
    v18 = v10[480];
    v10[481] = v17;
    if ( v15 > v18 )
      v18 = v15;
    v8 = (0x10000LL << v9) & 0xFFFFFFFFFFFF0000LL | v11;
    dword_6F7D808 = v18;
    *(_QWORD *)&dword_6F7D778[24 * v11 + 1566] = v8;
    v19 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
    if ( v19 >= 0x3F )
      v20 = 63LL;
    else
      v20 = v19;
    memcpy(&dword_6F7D778[24 * v16 + 1570], a2, v20);
    if ( a3 != -1 )
    {
LABEL_22:
      v28 = &dword_6F7D778[24 * v16];
      *((_BYTE *)v28 + v20 + 6280) = 0;
      v28[1586] = v20;
      v28[1587] = a3 & 0xFFFFFF;
      v28[1569] = v9;
      v28[1568] = v16;
      *((_BYTE *)&dword_6F7D778[26142] + v16) = v9;
      goto LABEL_23;
    }
    v21 = *a1;
    if ( *a1 )
    {
      v22 = (unsigned __int8 *)(a1 + 1);
      v23 = 5;
      do
      {
        v23 = (33 * v23) ^ v21;
        v24 = *v22++;
        v21 = v24;
      }
      while ( v24 );
      v25 = *a2;
      if ( !*a2 )
        goto LABEL_21;
    }
    else
    {
      v23 = 5;
      v25 = *a2;
      if ( !*a2 )
      {
LABEL_21:
        a3 = dword_16B67C8[v23 & 0x1F];
        goto LABEL_22;
      }
    }
    v26 = (unsigned __int8 *)(a2 + 1);
    do
    {
      v23 = (33 * v23) ^ v25;
      v27 = *v26++;
      v25 = v27;
    }
    while ( v27 );
    goto LABEL_21;
  }
LABEL_23:
  sub_67D1AF4(v7);
  return v8;
}


================================================================================
Function: sub_6493668 (0x6493668)
================================================================================

__int64 __fastcall sub_6493668(__int64 a1)
{
  __int64 v1; // x8

  v1 = *(int *)(a1 + 1336);
  if ( (unsigned int)v1 > 3 )
    return 0x40000LL;
  else
    return (unsigned int)dword_AF76A0[v1];
}


================================================================================
Function: sub_649368C (0x649368C)
================================================================================

__int64 sub_649368C()
{
  unsigned __int8 v0; // w8
  pthread_mutex_t *v2; // x20

  v0 = atomic_load(byte_70E4AE0);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_70E4AE0) )
  {
    v2 = (pthread_mutex_t *)sub_6575418();
    sub_67D19DC(v2);
    qword_70E4AD8 = (__int64)v2;
    sub_67EB838(byte_70E4AE0);
  }
  return qword_70E4AD8;
}


================================================================================
Function: sub_6493718 (0x6493718)
================================================================================

// attributes: thunk
__int64 sub_6493718()
{
  return sub_649368C();
}


================================================================================
Function: sub_649371C (0x649371C)
================================================================================

int *sub_649371C()
{
  return dword_6F7D778;
}


================================================================================
Function: sub_6493728 (0x6493728)
================================================================================

__int64 __fastcall sub_6493728(__int64 a1)
{
  pthread_mutex_t *v1; // x20
  __int64 v2; // x9
  char *v3; // x8
  __int64 v4; // x23
  __int64 v5; // x27
  int *v6; // x8
  int *v7; // x9
  __int64 v8; // x9
  __int128 *v9; // x8
  int64x2_t v10; // q0
  int64x2_t v11; // q1
  __int64 *v12; // x23
  int v13; // w22
  __int64 v14; // t1
  __int64 v15; // x20
  __int64 v16; // x0
  pthread_mutex_t *v18; // [xsp+0h] [xbp-20h]
  __int64 v19; // [xsp+8h] [xbp-18h] BYREF
  __int64 v20; // [xsp+10h] [xbp-10h]

  v1 = (pthread_mutex_t *)sub_649368C(a1);
  sub_67D1AC8(v1);
  if ( (byte_70E4AE8 & 1) == 0 )
  {
    v18 = v1;
    byte_70E4AE8 = 1;
    memset(dword_6F7D778, 0, 0x167320uLL);
    atomic_store(0x167320u, &dword_7007720);
    *((_BYTE *)dword_6F7D778 + (unsigned int)&qword_1758[1] + 4) = 0;
    byte_6F7DEB0 = 0;
    byte_6F7E7AC = 0;
    byte_6F7E808 = 0;
    byte_6F7E864 = 0;
    byte_6F7E8C0 = 0;
    byte_6F7E91C = 0;
    byte_6F7E978 = 0;
    byte_6F7E9D4 = 0;
    byte_6F7EA30 = 0;
    byte_6F7EA8C = 0;
    byte_6F7EAE8 = 0;
    byte_6F7EB44 = 0;
    byte_6F7EBA0 = 0;
    byte_6F7EBFC = 0;
    byte_6F7EC58 = 0;
    byte_6F7ECB4 = 0;
    byte_6F7ED10 = 0;
    byte_6F7ED6C = 0;
    byte_6F7EDC8 = 0;
    byte_6F7EE24 = 0;
    byte_6F7EE80 = 0;
    *((_BYTE *)dword_6F7D778 + (unsigned int)qword_1818 + 4) = 0;
    v2 = 1024LL;
    byte_6F7DF0C = 0;
    *((_BYTE *)dword_6F7D778 + (unsigned int)&qword_17B8[1]) = 0;
    byte_6F7DF68 = 0;
    byte_6F7DFC4 = 0;
    byte_6F7E020 = 0;
    byte_6F7E07C = 0;
    byte_6F7E0D8 = 0;
    qword_6F7DA30 = 0x746C7561666564LL;
    v3 = &byte_6F7F060;
    byte_6F7E134 = 0;
    byte_6F7E190 = 0;
    byte_6F7E1EC = 0;
    byte_6F7E248 = 0;
    byte_6F7E2A4 = 0;
    byte_6F7E300 = 0;
    byte_6F7E35C = 0;
    byte_6F7E3B8 = 0;
    byte_6F7E414 = 0;
    byte_6F7E470 = 0;
    byte_6F7E4CC = 0;
    byte_6F7E528 = 0;
    byte_6F7E584 = 0;
    byte_6F7E5E0 = 0;
    byte_6F7E63C = 0;
    byte_6F7E698 = 0;
    byte_6F7E6F4 = 0;
    byte_6F7E750 = 0;
    qword_6F7DA70 = 0LL;
    byte_6F7DA78 = 0;
    qword_6F7DAB8 = 0LL;
    byte_6F7DAC0 = 0;
    qword_6F7DB00 = 0LL;
    byte_6F7DB08 = 0;
    qword_6F7DB48 = 0LL;
    byte_6F7DB50 = 0;
    qword_6F7DB90 = 0LL;
    byte_6F7DB98 = 0;
    qword_6F7DBD8 = 0LL;
    byte_6F7DBE0 = 0;
    qword_6F7DC20 = 0LL;
    byte_6F7DC28 = 0;
    qword_6F7DC68 = 0LL;
    byte_6F7DC70 = 0;
    qword_6F7DCB0 = 0LL;
    byte_6F7DCB8 = 0;
    qword_6F7DCF8 = 0LL;
    byte_6F7DD00 = 0;
    qword_6F7DD40 = 0LL;
    byte_6F7DD48 = 0;
    qword_6F7DD88 = 0LL;
    byte_6F7DD90 = 0;
    qword_6F7DDD0 = 0LL;
    byte_6F7DDD8 = 0;
    qword_6F7DE18 = 0LL;
    byte_6F7DE20 = 0;
    qword_6F7DE60 = 0LL;
    byte_6F7DE68 = 0;
    qword_6F7DEA8 = 0LL;
    dword_6F7D780 = 1;
    do
    {
      v2 -= 2LL;
      *(v3 - 96) = 0;
      *v3 = 0;
      v3 += 192;
    }
    while ( v2 );
    dword_6F7D77C = 0;
    clock_gettime(1, (struct timespec *)&v19);
    dword_6F7D7A4 = 22;
    qword_6F7D7A8 = 0LL;
    dword_6F7D7B0 = 0;
    qword_6F7D798 = v20 + 1000000000 * v19;
    *(int *)((char *)dword_6F7D778 + (unsigned int)&stru_88970.r_info) = -1;
    dword_70064F8 = -1;
    dword_6F7D788 = 60;
    *(int *)((char *)dword_6F7D778 + (unsigned int)&stru_89180.r_info) = -1;
    qword_6F7D7D8 = 0LL;
    *(_QWORD *)&dword_6F7D7E0 = 0x100000000LL;
    qword_6F7D7C0 = 0LL;
    qword_6F7D7C8 = 0LL;
    dword_6F7D778[0] = 0;
    dword_7006D08 = -1;
    dword_7007110 = -1;
    dword_6F7D800 = 1;
    qword_6F7DA28 = 0x3CF5C8D9420551ECLL;
    clock_gettime(1, (struct timespec *)&v19);
    v4 = 0LL;
    v5 = v20 + 1000000000 * v19;
    do
    {
      v6 = &dword_6F7D778[v4];
      v7 = &dword_6F7D778[v4 + 141296];
      *((_QWORD *)v7 + 2) = 0LL;
      *(_OWORD *)v7 = 0u;
      *((_QWORD *)v6 + 70652) = 0LL;
      *((_QWORD *)v6 + 70651) = v5;
      *((_WORD *)v6 + 282896) = 0;
      v6[141306] = -1;
      v6[141437] = 0;
      v6[141436] = 0;
      v6[141435] = 0;
      sub_654AED4(&dword_6F7D778[v4 + 141438]);
      v4 += 154LL;
    }
    while ( v4 != 78848 );
    v8 = 512LL;
    v9 = &xmmword_70E1810;
    v10 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    v11 = vdupq_n_s64(0x8000000000000000LL);
    dword_7061808 = 0;
    do
    {
      v8 -= 4LL;
      v9[256] = (__int128)v10;
      v9[257] = (__int128)v10;
      *v9 = (__int128)v11;
      v9[1] = (__int128)v11;
      v9 += 2;
    }
    while ( v8 );
    v12 = &qword_7007320;
    dword_70E3810 = -1;
    if ( qword_7007320 )
    {
      v13 = 0;
      v12 = &qword_7007320;
      do
      {
        v14 = v12[1];
        ++v12;
        ++v13;
      }
      while ( v14 );
    }
    else
    {
      v13 = 0;
    }
    v15 = sub_6575418();
    sub_67F03E0(0x540u, (atomic_uint *)&dword_7007720);
    *v12 = v15;
    memset((void *)v15, 0, 0x540uLL);
    *(_DWORD *)(v15 + 56) = v13;
    *(_WORD *)(v15 + 1272) = 20551;
    *(_BYTE *)(v15 + 1274) = 85;
    v16 = syscall(178LL);
    dword_6F7D814 = 0;
    *(_BYTE *)(v15 + 1340) = 1;
    *(_DWORD *)(v15 + 1336) = 2;
    qword_70E4A98 = v15;
    unk_70E3880 = 0;
    dword_70E3884 = 0;
    *(_QWORD *)(v15 + 48) = 1LL;
    byte_70E3888 = 0;
    byte_70587D8 = 0;
    sub_64A5448(v16);
    v1 = v18;
  }
  return sub_67D1AF4(v1);
}


================================================================================
Function: sub_6493C1C (0x6493C1C)
================================================================================

__int64 sub_6493C1C()
{
  return *sub_67EF968(qword_6C2FDE8);
}


================================================================================
Function: sub_6493C3C (0x6493C3C)
================================================================================

_QWORD *__fastcall sub_6493C3C(__int64 a1)
{
  _QWORD *result; // x0

  result = sub_67EF968(qword_6C2FDE8);
  *result = a1;
  return result;
}


================================================================================
Function: sub_6493C6C (0x6493C6C)
================================================================================

__int64 __fastcall sub_6493C6C(const char *a1, int a2)
{
  __int64 v4; // x0
  pthread_mutex_t *v5; // x19
  int v6; // w24
  const char *v7; // x21
  __int64 v8; // x22
  __int64 v9; // x20
  int v10; // w0
  __int64 v11; // x23

  v4 = sub_6493728();
  v5 = (pthread_mutex_t *)sub_649368C(v4);
  sub_67D1AC8(v5);
  if ( !sub_6493C1C() )
  {
    if ( a1 )
      v6 = a2;
    else
      v6 = 0;
    if ( a1 )
      v7 = a1;
    else
      v7 = "<Unknown>";
    v8 = 0LL;
    while ( *(_QWORD *)&dword_6F7D778[2 * v8 + 141034] )
    {
      if ( ++v8 == 128 )
      {
        v9 = 0LL;
        goto LABEL_16;
      }
    }
    v9 = sub_6575418();
    sub_67F03E0(0x540u, (atomic_uint *)&dword_7007720);
    *(_QWORD *)&dword_6F7D778[2 * v8 + 141034] = v9;
    memset((void *)v9, 0, 0x540uLL);
    *(_DWORD *)(v9 + 56) = v8;
    v10 = __strlen_chk(v7, 0xFFFFFFFFFFFFFFFFLL);
    if ( v10 >= 63 )
      v11 = 63LL;
    else
      v11 = v10;
    __memcpy_chk(v9 + 1272, v7, v11, 72LL);
    *(_BYTE *)(v9 + 1272 + v11) = 0;
    *(_DWORD *)(v9 + 52) = syscall(178LL);
    *(_DWORD *)(v9 + 1336) = v6;
    *(_BYTE *)(v9 + 1340) = 1;
LABEL_16:
    sub_6493C3C(v9);
  }
  return sub_67D1AF4(v5);
}


================================================================================
Function: sub_6493EC4 (0x6493EC4)
================================================================================

__int64 __fastcall sub_6493EC4(const char *a1, const char *a2)
{
  pthread_mutex_t *v4; // x19
  __int64 v5; // x23
  const char *v6; // x22
  char *v7; // x24
  __int64 v8; // x20

  sub_6493728((__int64)a1);
  v4 = (pthread_mutex_t *)sub_649368C();
  sub_67D1AC8(v4);
  v5 = (unsigned int)dword_6F7D778[0];
  if ( dword_6F7D778[0] )
  {
    v6 = (const char *)&unk_6F7F000;
    v7 = &byte_6F96FF0;
    while ( strcasecmp(a2, v6) || strcasecmp(a1, (const char *)&dword_6F7D778[23 * (unsigned __int8)*v7 + 462]) )
    {
      v6 += 96;
      ++v7;
      if ( !--v5 )
        goto LABEL_7;
    }
    v8 = *((_QWORD *)v6 - 2);
  }
  else
  {
LABEL_7:
    v8 = 0LL;
  }
  sub_67D1AF4(v4);
  return v8;
}


================================================================================
Function: sub_6493F88 (0x6493F88)
================================================================================

__int64 __fastcall sub_6493F88(char *s1, int a2)
{
  __int64 v4; // x19
  __int64 v5; // x23
  const char *v6; // x22
  bool v7; // zf
  size_t v8; // x0
  __int64 v9; // x25
  int *v10; // x8
  size_t v11; // x22
  int *v12; // x23
  __int64 v13; // x11
  int *v14; // x9
  __int64 v15; // x10
  __int64 v16; // x12
  int v17; // w13

  v4 = (unsigned int)dword_6F7D77C;
  if ( dword_6F7D77C )
  {
    v5 = 0LL;
    v6 = &byte_6F7DEB0;
    while ( strcasecmp(s1, v6) )
    {
      ++v5;
      v6 += 92;
      if ( v4 == v5 )
        goto LABEL_5;
    }
    LODWORD(v4) = v5;
  }
  else
  {
LABEL_5:
    if ( byte_71CF7B0 )
      v7 = byte_6F7D738 == 0;
    else
      v7 = 1;
    if ( v7 )
    {
      dword_6F7D77C = v4 + 1;
      v8 = strlen(s1);
      v9 = (unsigned __int16)v4;
    }
    else
    {
      if ( (unsigned int)(v4 - 48) < 0xFFFFFFCF )
      {
        LODWORD(v4) = 47;
        return (unsigned int)v4;
      }
      v9 = (unsigned __int16)v4;
      if ( (unsigned __int16)v4 == 47 )
        s1 = "OverflowGroup";
      dword_6F7D77C = v4 + 1;
      v8 = strlen(s1);
    }
    v10 = &dword_6F7D778[23 * v9];
    if ( v8 >= 0x3F )
      v11 = 63LL;
    else
      v11 = v8;
    v12 = v10 + 462;
    memcpy(v10 + 462, s1, v11);
    v13 = qword_6F7DA70;
    v14 = &dword_6F7D778[23 * v9];
    v15 = qword_6F7D7F0;
    v16 = qword_6F7D7F8;
    *((_BYTE *)v12 + v11) = 0;
    v14[478] = v11;
    v17 = dword_6F7D7B4;
    v14[479] = v9;
    v14[484] = a2;
    *((_OWORD *)v14 + 120) = xmmword_AF7BC0;
    qword_6F7DA70 = v13 | (1LL << v9);
    qword_6F7D7F0 = v15 | (1LL << v9);
    qword_6F7D7F8 = v16 | ((unsigned __int64)(a2 == 1) << v9);
    if ( dword_6F7D800 | v17 && dword_6F7D7E0 )
      qword_6F7D7A8 |= 1LL << v9;
  }
  return (unsigned int)v4;
}


================================================================================
Function: sub_6494170 (0x6494170)
================================================================================

__int64 __fastcall sub_6494170(char *a1)
{
  __int64 v2; // x0
  pthread_mutex_t *v3; // x19
  __int64 v4; // x20

  v2 = sub_6493728();
  v3 = (pthread_mutex_t *)sub_649368C(v2);
  sub_67D1AC8(v3);
  v4 = 0x10000LL << sub_6493F88(a1);
  sub_67D1AF4(v3);
  return v4;
}


================================================================================
Function: sub_6494654 (0x6494654)
================================================================================

__int64 __fastcall sub_6494654(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // x22
  __int16 v4; // w21
  __int64 v5; // x20
  __int64 v6; // x0
  unsigned int v7; // w0
  __int64 v8; // x24
  __int64 v9; // x27
  __int64 v10; // x8
  unsigned int v11; // w8
  __int64 v13; // x24
  __int64 v14; // x8
  unsigned int v15; // w8
  unsigned int v16; // w25
  __int64 v17; // x9
  size_t v18; // x22
  void *v19; // x0
  unsigned int *v20; // x10
  unsigned int v21; // w28
  __int64 v22; // x9
  __int64 v23; // x26
  size_t v24; // x22
  void *v25; // x0
  int v26; // w22
  __int64 v27; // x21
  __int64 v28; // x8
  unsigned int v29; // w8
  __int64 v30; // x9
  size_t v31; // x20
  void *v32; // x0
  unsigned __int64 v33; // x8
  __int64 v34; // [xsp+8h] [xbp-18h] BYREF
  __int64 v35; // [xsp+10h] [xbp-10h]

  v2 = a1 >> 16;
  if ( (qword_6F7D7A8 & (a1 >> 16)) == 0 )
    return -1LL;
  v4 = a1;
  v5 = sub_6493C1C(a1);
  if ( !v5 )
  {
    v6 = sub_6493C6C(0LL, 2LL);
    v5 = sub_6493C1C(v6);
    if ( !v5 )
      return -1LL;
  }
  if ( a2 == -1 )
  {
    clock_gettime(1, (struct timespec *)&v34);
    a2 = v35 + 1000000000 * v34;
  }
  if ( (qword_6F7D7F8 & v2) == 0 )
  {
    if ( dword_6F7D800 )
    {
      v13 = *(unsigned int *)(v5 + 8);
      v14 = *(int *)(v5 + 1336);
      if ( (unsigned int)v14 > 3 )
        v15 = 0x40000;
      else
        v15 = dword_AF76A0[v14];
      v16 = ((int)v13 + 1) % v15;
      if ( v16 != *(_DWORD *)(v5 + 12) )
      {
        v17 = *(_QWORD *)v5;
        if ( !*(_QWORD *)v5 )
        {
          v18 = 8 * v15;
          v19 = (void *)sub_6577314(v18);
          *(_QWORD *)v5 = v19;
          memset(v19, 0, v18);
          sub_67F03E0(v18, (atomic_uint *)&dword_7007720);
          v17 = *(_QWORD *)v5;
        }
        v20 = (unsigned int *)(v5 + 8);
        *(_QWORD *)(v17 + 8 * v13) = a2 & 0xFFFFFFFFFFFFLL | ((unsigned __int64)(v4 & 0x1FFF) << 48) | 0x2000000000000000LL;
        goto LABEL_40;
      }
      dword_6F7D7E8 = 100;
    }
    return a2;
  }
  if ( !*(_BYTE *)(v5 + 1340) )
    return -1LL;
  if ( !unk_70E3828 )
    return -1LL;
  v7 = unk_70E3828(*(_QWORD *)(v5 + 40));
  if ( v7 == -1 )
    return -1LL;
  if ( dword_6F7D800 )
  {
    v8 = qword_70E4A98;
    v9 = *(unsigned int *)(qword_70E4A98 + 8);
    v10 = *(int *)(qword_70E4A98 + 1336);
    if ( (unsigned int)v10 > 3 )
      v11 = 0x40000;
    else
      v11 = dword_AF76A0[v10];
    v21 = ((int)v9 + 1) % v11;
    if ( v21 == *(_DWORD *)(qword_70E4A98 + 12) )
    {
      dword_6F7D7E8 = 100;
LABEL_31:
      v26 = *(_DWORD *)(v5 + 56);
      v27 = *(unsigned int *)(v8 + 8);
      v28 = *(int *)(v8 + 1336);
      if ( (unsigned int)v28 > 3 )
        v29 = 0x40000;
      else
        v29 = dword_AF76A0[v28];
      v16 = ((int)v27 + 1) % v29;
      if ( v16 == *(_DWORD *)(v8 + 12) )
      {
        a2 = 0LL;
        dword_6F7D7E8 = 100;
        return a2;
      }
      v30 = *(_QWORD *)v8;
      if ( !*(_QWORD *)v8 )
      {
        v31 = 8 * v29;
        v32 = (void *)sub_6577314(v31);
        *(_QWORD *)v8 = v32;
        memset(v32, 0, v31);
        sub_67F03E0(v31, (atomic_uint *)&dword_7007720);
        v30 = *(_QWORD *)v8;
      }
      v20 = (unsigned int *)(v8 + 8);
      v33 = a2 & 0xFFFFFFFFFFFFLL | ((unsigned __int64)(v26 & 0x1FFF) << 48);
      a2 = 0LL;
      *(_QWORD *)(v30 + 8 * v27) = v33 | 0x8000000000000000LL;
LABEL_40:
      atomic_store(v16, v20);
      return a2;
    }
    v22 = *(_QWORD *)qword_70E4A98;
    v23 = v7;
    if ( !*(_QWORD *)qword_70E4A98 )
    {
      v24 = 8 * v11;
      v25 = (void *)sub_6577314(v24);
      *(_QWORD *)v8 = v25;
      memset(v25, 0, v24);
      sub_67F03E0(v24, (atomic_uint *)&dword_7007720);
      v22 = *(_QWORD *)v8;
    }
    *(_QWORD *)(v22 + 8 * v9) = v23 & 0xE000FFFFFFFFFFFFLL | ((unsigned __int64)(v4 & 0x1FFF) << 48) | 0x2000000000000000LL;
    atomic_store(v21, (unsigned int *)(v8 + 8));
    if ( dword_6F7D800 )
    {
      v8 = qword_70E4A98;
      goto LABEL_31;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_6494970 (0x6494970)
================================================================================

unsigned __int64 __fastcall sub_6494970(char *s)
{
  char *v2; // x20
  pthread_mutex_t *v3; // x21
  size_t v4; // x0
  size_t v5; // x21
  __int64 v6; // x2
  __int64 v7; // x8
  unsigned __int64 v8; // x24
  int v9; // w8
  unsigned __int64 v10; // x22
  char *v11; // x20
  unsigned __int16 v12; // w0
  __int64 v14; // [xsp+0h] [xbp-10h] BYREF

  v2 = (char *)atomic_load((unsigned __int64 *)&qword_70587F0);
  if ( !v2 )
  {
    v3 = (pthread_mutex_t *)sub_649368C();
    sub_67D1AC8(v3);
    v2 = (char *)atomic_load((unsigned __int64 *)&qword_70587F0);
    if ( !v2 )
    {
      v2 = (char *)sub_6577314(0x1000100uLL);
      memset(v2, 0, 0x1000100uLL);
      sub_67F03E0(0x1000100u, (atomic_uint *)&dword_7007720);
      atomic_store((unsigned __int64)v2, (unsigned __int64 *)&qword_70587F0);
    }
    sub_67D1AF4(v3);
  }
  v4 = strlen(s);
  if ( v4 >= 0xFF )
    v5 = 255LL;
  else
    v5 = v4;
  if ( v5 >= 9 )
    v6 = 8LL;
  else
    v6 = v5;
  v14 = 0LL;
  __memcpy_chk(&v14, s, v6, 8LL);
  if ( v5 > 8 )
    v7 = v14 + *(_QWORD *)&s[(unsigned __int8)v5 / 3u - 2] + *(_QWORD *)&s[v5 - 8];
  else
    v7 = v14;
  v8 = (0x9E3779B97F4A7C15LL * v7) >> 51;
  v9 = word_70E4AEA[v8];
  if ( (unsigned __int16)word_70ECB10 - v9 > 2048
    || (v10 = qword_70E8AF0[v9 & 0x7FF], strncmp(s, &v2[v10 & 0xFFFFFF], v5)) )
  {
    v10 = sub_67F0410(v5 + 1, (atomic_ullong *)qword_70587F8);
    v11 = &v2[v10 & 0xFFFFFF];
    memcpy(v11, s, v5);
    v11[v5] = 0;
    v12 = sub_67F02C0(1LL, &word_70ECB10);
    word_70E4AEA[v8] = v12;
    qword_70E8AF0[v12 & 0x7FF] = v10;
  }
  return v10;
}


================================================================================
Function: sub_6494B68 (0x6494B68)
================================================================================

__int64 __fastcall sub_6494B68(unsigned __int64 a1, char *a2)
{
  __int64 v4; // x0
  int v5; // w20
  __int64 v6; // x0
  __int64 v7; // x22
  __int64 v8; // x21
  _QWORD *v9; // x23
  __int64 v10; // x24
  __int64 v11; // x8
  unsigned int v12; // w8
  __int64 result; // x0
  __int64 v14; // x21
  __int64 v15; // x20
  _QWORD *v16; // x22
  __int64 v17; // x23
  __int64 v18; // x8
  unsigned int v19; // w8
  __int64 v20; // x8
  unsigned int v21; // w8
  __int64 v22; // x8
  unsigned int v23; // w8
  unsigned int v24; // w25
  __int64 v25; // x9
  size_t v26; // x22
  void *v27; // x0
  __int64 v28; // x8
  unsigned int *v29; // x10
  unsigned int v30; // w24
  __int64 v31; // x9
  size_t v32; // x21
  void *v33; // x0
  __int64 v34; // x8
  unsigned int *v35; // x10
  size_t v36; // x23
  void *v37; // x0
  size_t v38; // x22
  void *v39; // x0

  if ( !byte_6F7D6C8 )
  {
    result = sub_6493C1C(a1);
    if ( !result )
      return result;
    v14 = result;
    result = sub_6494970(a2);
    v15 = result;
    if ( (qword_6F7D7F8 & (a1 >> 16)) != 0 )
    {
      if ( !dword_6F7D800 )
        return result;
      v16 = (_QWORD *)qword_70E4A98;
      v17 = *(unsigned int *)(qword_70E4A98 + 8);
      v18 = *(int *)(qword_70E4A98 + 1336);
      if ( (unsigned int)v18 > 3 )
        v19 = 0x40000;
      else
        v19 = dword_AF76A0[v18];
      v30 = ((int)v17 + 1) % v19;
      if ( v30 != *(_DWORD *)(qword_70E4A98 + 12) )
      {
        v31 = *(_QWORD *)qword_70E4A98;
        if ( !*(_QWORD *)qword_70E4A98 )
        {
          v32 = 8 * v19;
          v33 = (void *)sub_6577314(v32);
          *v16 = v33;
          memset(v33, 0, v32);
          result = sub_67F03E0(v32, (atomic_uint *)&dword_7007720);
          v31 = *v16;
        }
        v34 = v15 & 0xFFFFFFFFFFFFLL;
        v35 = (unsigned int *)(v16 + 1);
LABEL_43:
        *(_QWORD *)(v31 + 8 * v17) = v34 & 0xE000FFFFFFFFFFFFLL | ((a1 & 0x1FFF) << 48) | 0x6000000000000000LL;
        atomic_store(v30, v35);
        return result;
      }
    }
    else
    {
      if ( !dword_6F7D800 )
        return result;
      v17 = *(unsigned int *)(v14 + 8);
      v22 = *(int *)(v14 + 1336);
      if ( (unsigned int)v22 > 3 )
        v23 = 0x40000;
      else
        v23 = dword_AF76A0[v22];
      v30 = ((int)v17 + 1) % v23;
      if ( v30 != *(_DWORD *)(v14 + 12) )
      {
        v31 = *(_QWORD *)v14;
        if ( !*(_QWORD *)v14 )
        {
          v38 = 8 * v23;
          v39 = (void *)sub_6577314(v38);
          *(_QWORD *)v14 = v39;
          memset(v39, 0, v38);
          result = sub_67F03E0(v38, (atomic_uint *)&dword_7007720);
          v31 = *(_QWORD *)v14;
        }
        v34 = v15 & 0xFFFFFFFFFFFFLL;
        v35 = (unsigned int *)(v14 + 8);
        goto LABEL_43;
      }
    }
    dword_6F7D7E8 = 100;
    return result;
  }
  v4 = sub_6574924(dword_71BEF88);
  v5 = v4;
  v6 = sub_6493C1C(v4);
  if ( v6 )
  {
    v7 = v6;
    v8 = sub_6494970(a2);
    if ( (qword_6F7D7F8 & (a1 >> 16)) != 0 )
    {
      if ( dword_6F7D800 )
      {
        v9 = (_QWORD *)qword_70E4A98;
        v10 = *(unsigned int *)(qword_70E4A98 + 8);
        v11 = *(int *)(qword_70E4A98 + 1336);
        if ( (unsigned int)v11 > 3 )
          v12 = 0x40000;
        else
          v12 = dword_AF76A0[v11];
        v24 = ((int)v10 + 1) % v12;
        if ( v24 != *(_DWORD *)(qword_70E4A98 + 12) )
        {
          v25 = *(_QWORD *)qword_70E4A98;
          if ( !*(_QWORD *)qword_70E4A98 )
          {
            v26 = 8 * v12;
            v27 = (void *)sub_6577314(v26);
            *v9 = v27;
            memset(v27, 0, v26);
            sub_67F03E0(v26, (atomic_uint *)&dword_7007720);
            v25 = *v9;
          }
          v28 = v8 & 0xFFFFFFFFFFFFLL;
          v29 = (unsigned int *)(v9 + 1);
LABEL_34:
          *(_QWORD *)(v25 + 8 * v10) = v28 & 0xE000FFFFFFFFFFFFLL | ((a1 & 0x1FFF) << 48) | 0x6000000000000000LL;
          atomic_store(v24, v29);
          return sub_6574924(v5);
        }
LABEL_30:
        dword_6F7D7E8 = 100;
      }
    }
    else if ( dword_6F7D800 )
    {
      v10 = *(unsigned int *)(v7 + 8);
      v20 = *(int *)(v7 + 1336);
      if ( (unsigned int)v20 > 3 )
        v21 = 0x40000;
      else
        v21 = dword_AF76A0[v20];
      v24 = ((int)v10 + 1) % v21;
      if ( v24 != *(_DWORD *)(v7 + 12) )
      {
        v25 = *(_QWORD *)v7;
        if ( !*(_QWORD *)v7 )
        {
          v36 = 8 * v21;
          v37 = (void *)sub_6577314(v36);
          *(_QWORD *)v7 = v37;
          memset(v37, 0, v36);
          sub_67F03E0(v36, (atomic_uint *)&dword_7007720);
          v25 = *(_QWORD *)v7;
        }
        v28 = v8 & 0xFFFFFFFFFFFFLL;
        v29 = (unsigned int *)(v7 + 8);
        goto LABEL_34;
      }
      goto LABEL_30;
    }
  }
  return sub_6574924(v5);
}


================================================================================
Function: sub_6494F1C (0x6494F1C)
================================================================================

__int64 __fastcall sub_6494F1C(int a1, __int64 a2)
{
  if ( a1 != 5 )
  {
    if ( (unsigned __int64)(qword_70587F8[0] - a2) <= 0x1000000 )
      return qword_70587F0 + (a2 & 0xFFFFFF);
    else
      return 0LL;
  }
  return a2;
}


================================================================================
Function: sub_6495060 (0x6495060)
================================================================================

unsigned __int64 __fastcall sub_6495060(unsigned __int64 result, char *format, _OWORD *a3)
{
  __int128 v3; // q1
  unsigned __int64 v4; // x19
  _OWORD v5[2]; // [xsp+0h] [xbp-130h] BYREF
  char s[256]; // [xsp+28h] [xbp-108h] BYREF

  if ( (qword_6F7D7A8 & (result >> 16)) != 0 )
  {
    v3 = a3[1];
    v4 = result;
    v5[0] = *a3;
    v5[1] = v3;
    vsnprintf(s, 0xFFuLL, format, v5);
    s[255] = 0;
    return sub_6494B68(v4, s);
  }
  return result;
}


================================================================================
Function: sub_64952A4 (0x64952A4)
================================================================================

__int64 __fastcall sub_64952A4(__int64 result, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v11; // w26
  int v12; // w19
  __int64 v13; // x0
  __int64 v14; // x25
  unsigned __int8 v15; // w8
  unsigned int v16; // w0
  _BYTE v17[48]; // [xsp+8h] [xbp-38h] BYREF

  v11 = result;
  if ( dword_6F7D800 || qword_6F7D7A8 )
  {
    v12 = sub_6574924(dword_71BEF88);
    v13 = sub_6493C1C();
    if ( v13 )
    {
      v14 = v13;
      v15 = atomic_load((unsigned __int8 *)sub_67EF968(qword_6C2FE08));
      if ( (v15 & 1) == 0 )
      {
        atomic_store(1u, (unsigned __int8 *)sub_67EF968(qword_6C2FE08));
        v16 = sub_64A3DF4(v17, v11, a2, a3, a4, a5, a6, 0LL);
        sub_64A3C74(v17, v16, v14);
        atomic_store(0, (unsigned __int8 *)sub_67EF968(qword_6C2FE08));
      }
    }
    return sub_6574924(v12);
  }
  return result;
}


================================================================================
Function: sub_64953E8 (0x64953E8)
================================================================================

__int64 __fastcall sub_64953E8(__int64 result, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // x20
  __int64 v5; // x21
  __int64 v6; // x0
  __int64 v7; // x25
  __int64 v8; // x24
  __int64 v9; // x8
  unsigned int v10; // w8
  __int64 v11; // x24
  __int64 v12; // x28
  __int64 v13; // x8
  unsigned int v14; // w8
  unsigned int v15; // w27
  __int64 v16; // x9
  size_t v17; // x22
  void *v18; // x0
  int v19; // w22
  __int64 v20; // x21
  __int64 v21; // x8
  unsigned int v22; // w8
  unsigned int v23; // w25
  __int64 v24; // x9
  size_t v25; // x22
  void *v26; // x0
  unsigned int *v27; // x10
  __int64 v28; // x9
  size_t v29; // x20
  void *v30; // x0
  __int64 v31; // [xsp+8h] [xbp-18h] BYREF
  __int64 v32; // [xsp+10h] [xbp-10h]

  if ( a2 != -1 )
  {
    v4 = result;
    result = ((__int64 (*)(void))sub_6493C1C)();
    v5 = result;
    if ( result || (v6 = sub_6493C6C(0LL, 2LL), result = sub_6493C1C(v6), (v5 = result) != 0) )
    {
      if ( a3 == -1 )
      {
        result = clock_gettime(1, (struct timespec *)&v31);
        a3 = v32 + 1000000000 * v31;
      }
      if ( (qword_6F7D7F8 & (v4 >> 16)) == 0 )
      {
        if ( !dword_6F7D800 )
          return result;
        v8 = *(unsigned int *)(v5 + 8);
        v9 = *(int *)(v5 + 1336);
        if ( (unsigned int)v9 > 3 )
          v10 = 0x40000;
        else
          v10 = dword_AF76A0[v9];
        v23 = ((int)v8 + 1) % v10;
        if ( v23 == *(_DWORD *)(v5 + 12) )
          goto LABEL_33;
        v24 = *(_QWORD *)v5;
        if ( !*(_QWORD *)v5 )
        {
          v25 = 8 * v10;
          v26 = (void *)sub_6577314(v25);
          *(_QWORD *)v5 = v26;
          memset(v26, 0, v25);
          result = sub_67F03E0(v25, (atomic_uint *)&dword_7007720);
          v24 = *(_QWORD *)v5;
        }
        v27 = (unsigned int *)(v5 + 8);
        *(_QWORD *)(v24 + 8 * v8) = a3 & 0xFFFFFFFFFFFFLL | ((v4 & 0x1FFF) << 48);
LABEL_37:
        atomic_store(v23, v27);
        return result;
      }
      if ( *(_BYTE *)(v5 + 1340) )
      {
        if ( unk_70E3828 )
        {
          result = unk_70E3828(*(_QWORD *)(v5 + 40));
          v7 = (unsigned int)result;
        }
        else
        {
          v7 = 0xFFFFFFFFLL;
        }
        if ( dword_6F7D800 )
        {
          v11 = qword_70E4A98;
          v12 = *(unsigned int *)(qword_70E4A98 + 8);
          v13 = *(int *)(qword_70E4A98 + 1336);
          if ( (unsigned int)v13 > 3 )
            v14 = 0x40000;
          else
            v14 = dword_AF76A0[v13];
          v15 = ((int)v12 + 1) % v14;
          if ( v15 == *(_DWORD *)(qword_70E4A98 + 12) )
          {
            dword_6F7D7E8 = 100;
LABEL_24:
            v19 = *(_DWORD *)(v5 + 56);
            v20 = *(unsigned int *)(v11 + 8);
            v21 = *(int *)(v11 + 1336);
            if ( (unsigned int)v21 > 3 )
              v22 = 0x40000;
            else
              v22 = dword_AF76A0[v21];
            v23 = ((int)v20 + 1) % v22;
            if ( v23 == *(_DWORD *)(v11 + 12) )
            {
LABEL_33:
              dword_6F7D7E8 = 100;
              return result;
            }
            v28 = *(_QWORD *)v11;
            if ( !*(_QWORD *)v11 )
            {
              v29 = 8 * v22;
              v30 = (void *)sub_6577314(v29);
              *(_QWORD *)v11 = v30;
              memset(v30, 0, v29);
              result = sub_67F03E0(v29, (atomic_uint *)&dword_7007720);
              v28 = *(_QWORD *)v11;
            }
            v27 = (unsigned int *)(v11 + 8);
            *(_QWORD *)(v28 + 8 * v20) = a3 & 0xFFFFFFFFFFFFLL | ((unsigned __int64)(v19 & 0x1FFF) << 48) | 0x8000000000000000LL;
            goto LABEL_37;
          }
          v16 = *(_QWORD *)qword_70E4A98;
          if ( !*(_QWORD *)qword_70E4A98 )
          {
            v17 = 8 * v14;
            v18 = (void *)sub_6577314(v17);
            *(_QWORD *)v11 = v18;
            memset(v18, 0, v17);
            result = sub_67F03E0(v17, (atomic_uint *)&dword_7007720);
            v16 = *(_QWORD *)v11;
          }
          *(_QWORD *)(v16 + 8 * v12) = v7 & 0xE000FFFFFFFFFFFFLL | ((v4 & 0x1FFF) << 48);
          atomic_store(v15, (unsigned int *)(v11 + 8));
          if ( dword_6F7D800 )
          {
            v11 = qword_70E4A98;
            goto LABEL_24;
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_64A3C74 (0x64A3C74)
================================================================================

__int64 __fastcall sub_64A3C74(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 result; // x0
  __int64 v7; // x22
  unsigned int v8; // w25
  int v9; // w8
  __int64 v10; // x9
  unsigned int *v11; // x10
  __int64 v12; // x23
  void *v13; // x0
  __int64 v14; // x8
  __int64 v15; // x10
  __int64 *v16; // x11
  unsigned int *v17; // x12
  __int64 v18; // x13
  __int64 v19; // x14
  __int64 v20; // x15
  __int64 v21; // x16
  __int64 v22; // x17
  __int64 *v23; // x11
  unsigned int *v24; // x12
  __int64 v25; // x9
  __int64 v26; // x13
  unsigned int v27; // t1
  __int64 v28; // t1
  _BYTE v29[4]; // [xsp+0h] [xbp-20h] BYREF
  int v30; // [xsp+4h] [xbp-1Ch] BYREF

  result = sub_649371C();
  if ( !*(_DWORD *)(result + 136) )
    return result;
  v7 = result;
  v8 = *((_DWORD *)a3 + 2);
  result = sub_6493668(a3);
  v9 = *((_DWORD *)a3 + 3);
  if ( !a2 )
  {
LABEL_6:
    if ( !*a3 )
    {
      v12 = 8LL * (unsigned int)result;
      v13 = (void *)sub_6577314(v12);
      *a3 = (__int64)v13;
      memset(v13, 0, v12);
      result = sub_67F03E0(v12, (atomic_uint *)(v7 + 565160));
    }
    if ( !a2 )
      goto LABEL_17;
    v14 = *a3;
    if ( a2 == 1 )
    {
      v15 = 0LL;
    }
    else
    {
      v15 = a2 & 0xFFFFFFFE;
      v16 = (__int64 *)(a1 + 8);
      v17 = (unsigned int *)&v30;
      v18 = v15;
      do
      {
        v19 = *(v16 - 1);
        v20 = *v16;
        v16 += 2;
        v18 -= 2LL;
        v21 = *(v17 - 1);
        v22 = *v17;
        v17 += 2;
        *(_QWORD *)(v14 + 8 * v21) = v19;
        *(_QWORD *)(v14 + 8 * v22) = v20;
      }
      while ( v18 );
      if ( v15 == a2 )
        goto LABEL_17;
    }
    v23 = (__int64 *)(a1 + 8 * v15);
    v24 = (unsigned int *)&v29[4 * v15];
    v25 = a2 - v15;
    do
    {
      v27 = *v24++;
      v26 = v27;
      --v25;
      v28 = *v23++;
      *(_QWORD *)(v14 + 8 * v26) = v28;
    }
    while ( v25 );
LABEL_17:
    atomic_store(v8, (unsigned int *)a3 + 2);
    return result;
  }
  v10 = a2;
  v11 = (unsigned int *)v29;
  while ( 1 )
  {
    *v11 = v8;
    v8 = (v8 + 1) % (unsigned int)result;
    if ( v8 == v9 )
      break;
    ++v11;
    if ( !--v10 )
      goto LABEL_6;
  }
  *(_DWORD *)(v7 + 112) = 100;
  return result;
}


================================================================================
Function: sub_64A3DF4 (0x64A3DF4)
================================================================================

__int64 __fastcall sub_64A3DF4(
        unsigned __int64 *a1,
        unsigned __int8 a2,
        __int64 a3,
        char *a4,
        unsigned __int64 a5,
        char *a6,
        _QWORD *a7,
        unsigned __int64 a8)
{
  unsigned int v8; // w21
  __int64 v9; // x8
  __int64 v10; // x10
  unsigned __int64 v11; // x8
  int v14; // w8
  __int64 v15; // x9
  __int64 v16; // x10
  int64x2_t *v17; // x11
  __int64 v18; // x12
  int64x2_t v19; // q0
  __int64 v20; // x11
  unsigned __int64 *v21; // x10
  bool v22; // cf
  _BYTE *v23; // x10
  int v24; // w11
  unsigned int v25; // w12
  char v26; // t1
  unsigned int v27; // w15
  bool v28; // zf
  __int64 v29; // x15
  __int64 v30; // x0
  unsigned __int64 v31; // x9
  unsigned __int64 v32; // x7

  v8 = 1;
  if ( a5 <= 0xA )
    v9 = 1LL;
  else
    v9 = 2LL;
  if ( a5 )
    v10 = v9;
  else
    v10 = 0LL;
  v11 = 0xC000000000000000LL;
  if ( (unsigned __int64)a6 | a8 )
    v11 = 0xD000000000000000LL;
  *a1 = v11 & 0xFC00000000000000LL | (v10 << 58) | ((unsigned __int64)a2 << 50) | a3 & 0x3FFFFFFFFFFFFLL;
  if ( a5 )
  {
    if ( (unsigned int)a5 >= 0x14 )
      v14 = 20;
    else
      v14 = a5;
    v15 = (unsigned int)(2 * v10);
    if ( !(_DWORD)v10 )
      goto LABEL_22;
    if ( (_DWORD)v10 == 1 )
    {
      v16 = 0LL;
    }
    else
    {
      v16 = (2 * (_BYTE)v10) & 4;
      v17 = (int64x2_t *)(a1 + 3);
      v18 = v16;
      v19 = vdupq_n_s64(0xDC00000000000000LL);
      do
      {
        v17[-1] = v19;
        *v17 = v19;
        v17 += 2;
        v18 -= 4LL;
      }
      while ( v18 );
      if ( v16 == v15 )
        goto LABEL_22;
    }
    v20 = v16 - v15;
    v21 = &a1[v16 + 1];
    do
    {
      v22 = __CFADD__(v20++, 1LL);
      *v21++ = 0xDC00000000000000LL;
    }
    while ( !v22 );
LABEL_22:
    if ( a4 && v14 )
    {
      v23 = a1 + 1;
      v24 = -1;
      v25 = 1;
      do
      {
        --v14;
        v26 = *a4++;
        v27 = v25 / 5;
        ++v25;
        *v23 = v26;
        v28 = v24 + 5 * v27 == 0;
        --v24;
        if ( v28 )
          v29 = 4LL;
        else
          v29 = 1LL;
        v23 += v29;
      }
      while ( v14 );
    }
    v8 = v15 | 1;
  }
  if ( a8 )
  {
LABEL_38:
    a1[v8++] = a8;
    return v8;
  }
  if ( a6 )
  {
    v30 = sub_64A3F6C((int)&qword_70ECC58, a6);
    v31 = 0xDE00000000000000LL;
    if ( !*a7 )
      v31 = 0xDC00000000000000LL;
    if ( *a7 == 0x1000000000000000LL )
      v32 = 0xDF00000000000000LL;
    else
      v32 = v31;
    a8 = v32 & 0xFFFF000000000000LL | v30 & 0xFFFFFFFFFFFFLL;
    goto LABEL_38;
  }
  return v8;
}


================================================================================
Function: sub_64A3F6C (0x64A3F6C)
================================================================================

unsigned __int64 __fastcall sub_64A3F6C(__int64 *a1, char *s, unsigned __int64 *a3)
{
  unsigned __int64 v3; // x8
  char *v5; // x21
  size_t v7; // x0
  unsigned __int64 v8; // x8
  char *v9; // x10
  __int64 v10; // t1
  pthread_mutex_t *v12; // x20
  __int64 v13; // x9
  __int64 v14; // x8
  unsigned int v15; // w12
  _QWORD *v16; // x24
  __int64 v17; // x13
  int v18; // w14
  unsigned int v19; // w12
  unsigned __int64 *v20; // x24
  __int64 v21; // t1
  int v22; // w9
  unsigned int v23; // w11
  _QWORD *v24; // x24
  __int64 v25; // x14
  _QWORD *v26; // x12
  int v27; // w15
  unsigned int v28; // w11
  bool v29; // zf
  unsigned __int64 v30; // x27
  __int64 v31; // x28
  _QWORD *v32; // x24
  int v33; // w9
  unsigned int v34; // w11
  _QWORD *v35; // x0
  __int64 v36; // x13
  _QWORD *v37; // x12
  int v38; // w14
  unsigned int v39; // w11
  bool v40; // zf
  _QWORD *v41; // x1
  __int64 v42; // x10
  __int64 v43; // x9
  _QWORD *v44; // x9
  __int64 v45; // t1
  int v46; // w8
  unsigned int v47; // w11
  __int64 v48; // x8
  __int64 v49; // x9
  __int64 v50; // x12
  unsigned __int64 v51; // d0
  int64x2_t v52; // q0
  __int64 v53; // x8
  __int64 v54; // x11
  __int64 v55; // x10
  unsigned __int64 v56; // x9
  int v57; // w13
  int v58; // w8
  _QWORD *v59; // x1
  unsigned __int64 v60; // x0
  __int64 v61; // x8
  __int64 v62; // x9
  __int64 v63; // x10
  __int64 v64; // x11
  unsigned __int64 v65; // x21
  unsigned __int64 v66; // x22
  __int64 v67; // x9
  __int64 v68; // x9
  __int64 v69; // x12
  unsigned __int64 v70; // x9
  unsigned __int64 *v71; // x8

  v3 = *a3;
  v5 = s;
  if ( *a3 == 0xF000000000000000LL )
  {
    if ( s )
    {
      v7 = strlen(s);
      v8 = 0LL;
      if ( v7 )
      {
        v9 = v5;
        do
        {
          v10 = *v9++;
          --v7;
          v8 ^= (v8 << 6) + (v8 >> 2) + v10 + 2654435769u;
        }
        while ( v7 );
        v8 &= 0xFFFFFFFFFFFFFFFuLL;
      }
    }
    else
    {
      v8 = 0LL;
    }
    *a3 = v8;
    goto LABEL_13;
  }
  if ( !v3 )
    return sub_6494970(s);
  if ( v3 != 0x1000000000000000LL )
  {
LABEL_13:
    v12 = (pthread_mutex_t *)sub_6493718();
    sub_67D1AC8(v12);
    v13 = *((unsigned int *)a1 + 4);
    v14 = *a1;
    if ( (_DWORD)v13 )
    {
      v15 = (37 * *a3) & (v13 - 1);
      v16 = (_QWORD *)(v14 + 16LL * v15);
      v17 = *v16;
      if ( *a3 == *v16 )
      {
LABEL_20:
        if ( v16 != (_QWORD *)(v14 + 16 * v13) )
        {
          v21 = v16[1];
          v20 = v16 + 1;
          if ( !sub_6494F1C(6LL, v21) )
            *v20 = sub_6494970(v5);
LABEL_80:
          v5 = (char *)*v20;
          sub_67D1AF4(v12);
          return (unsigned __int64)v5;
        }
        if ( a1[9] > (unsigned __int64)*((unsigned int *)a1 + 2) )
        {
LABEL_24:
          if ( (_DWORD)v13 )
          {
            v22 = v13 - 1;
            v23 = (37 * *a3) & v22;
            v24 = (_QWORD *)(v14 + 16LL * v23);
            v25 = *v24;
            if ( *a3 == *v24 )
            {
LABEL_74:
              v60 = sub_6494970(v5);
              v61 = a1[4];
              v62 = a1[5];
              v24[1] = v60;
              v20 = v24 + 1;
              v63 = a1[7];
              v64 = a1[8];
              v65 = v60;
              v66 = *a3;
              v67 = v62 - v61;
              v29 = v67 == 0;
              v68 = 32 * v67 - 1;
              if ( v29 )
                v69 = 0LL;
              else
                v69 = v68;
              v70 = v64 + v63;
              if ( v69 == v64 + v63 )
              {
                sub_64A585C(a1 + 3);
                v61 = a1[4];
                v70 = a1[7] + a1[8];
              }
              v71 = (unsigned __int64 *)(*(_QWORD *)(v61 + ((v70 >> 5) & 0x7FFFFFFFFFFFFF8LL))
                                       + 16LL * (unsigned __int8)v70);
              *v71 = v66;
              v71[1] = v65;
              ++a1[8];
              goto LABEL_80;
            }
            v26 = 0LL;
            v27 = 1;
            while ( v25 != -1 )
            {
              v28 = v23 + v27;
              if ( v26 )
                v29 = 0;
              else
                v29 = v25 == -2;
              v23 = v28 & v22;
              ++v27;
              if ( v29 )
                v26 = v24;
              v24 = (_QWORD *)(v14 + 16LL * v23);
              v25 = *v24;
              if ( *a3 == *v24 )
                goto LABEL_74;
            }
            if ( v26 )
              v59 = v26;
            else
              v59 = v24;
          }
          else
          {
            v59 = 0LL;
          }
          v24 = (_QWORD *)sub_64A5550(a1, v59, a3);
          goto LABEL_74;
        }
        v30 = a1[7];
        while ( 1 )
        {
          v31 = *(_QWORD *)(a1[4] + ((v30 >> 5) & 0x7FFFFFFFFFFFFF8LL));
          v32 = (_QWORD *)(v31 + 16LL * (unsigned __int8)v30);
          if ( (_DWORD)v13 )
          {
            v33 = v13 - 1;
            v34 = (37 * *v32) & v33;
            v35 = (_QWORD *)(v14 + 16LL * v34);
            v36 = *v35;
            if ( *v32 == *v35 )
              goto LABEL_53;
            v37 = 0LL;
            v38 = 1;
            while ( v36 != -1 )
            {
              v39 = v34 + v38;
              if ( v37 )
                v40 = 0;
              else
                v40 = v36 == -2;
              v34 = v39 & v33;
              ++v38;
              if ( v40 )
                v37 = v35;
              v35 = (_QWORD *)(v14 + 16LL * v34);
              v36 = *v35;
              if ( *v32 == *v35 )
                goto LABEL_53;
            }
            if ( v37 )
              v41 = v37;
            else
              v41 = v35;
          }
          else
          {
            v41 = 0LL;
          }
          v35 = (_QWORD *)sub_64A5550(a1, v41, v31 + 16LL * (unsigned __int8)v30);
LABEL_53:
          v42 = v35[1];
          v43 = v31 + 16LL * (unsigned __int8)v30;
          v45 = *(_QWORD *)(v43 + 8);
          v44 = (_QWORD *)(v43 + 8);
          if ( v45 == v42 )
          {
            v46 = *((_DWORD *)a1 + 4);
            if ( v46 )
            {
              v47 = v46 - 1;
              v48 = (37 * (unsigned int)*v32) & (v46 - 1);
              v49 = *a1;
              v50 = *(_QWORD *)(*a1 + 16 * v48);
              if ( *v32 == v50 )
              {
LABEL_56:
                v51 = vadd_s32((int32x2_t)a1[1], (int32x2_t)0x1FFFFFFFFLL).n64_u64[0];
                *(_QWORD *)(v49 + 16 * v48) = -2LL;
                a1[1] = v51;
              }
              else
              {
                v57 = 1;
                while ( v50 != -1 )
                {
                  v58 = v48 + v57++;
                  v48 = v58 & v47;
                  v50 = *(_QWORD *)(v49 + 16 * v48);
                  if ( *v32 == v50 )
                    goto LABEL_56;
                }
              }
            }
            v52 = vaddq_s64(*(int64x2_t *)(a1 + 7), (int64x2_t)xmmword_AF85E0);
            v30 = v52.n128_u64[0];
            *(int64x2_t *)(a1 + 7) = v52;
            if ( v52.n128_u64[0] < 0x200 )
              goto LABEL_38;
          }
          else
          {
            v53 = a1[4];
            v54 = a1[5];
            *v44 = v42;
            v55 = 32 * (v54 - v53) - 1;
            if ( v54 == v53 )
              v55 = 0LL;
            v56 = a1[8] + a1[7];
            if ( v55 == v56 )
            {
              sub_64A585C(a1 + 3);
              v53 = a1[4];
              v56 = a1[7] + a1[8];
            }
            *(_OWORD *)(*(_QWORD *)(v53 + ((v56 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * (unsigned __int8)v56) = *(_OWORD *)v32;
            v30 = a1[7] + 1;
            a1[7] = v30;
            if ( v30 <= 0x1FF )
              goto LABEL_38;
          }
          sub_6575460();
          v30 = a1[7] - 256;
          a1[4] += 8LL;
          a1[7] = v30;
LABEL_38:
          v14 = *a1;
          LODWORD(v13) = *((_DWORD *)a1 + 4);
          if ( a1[9] > (unsigned __int64)*((unsigned int *)a1 + 2) )
            goto LABEL_24;
        }
      }
      v18 = 1;
      while ( v17 != -1 )
      {
        v19 = v15 + v18++;
        v15 = v19 & (v13 - 1);
        v16 = (_QWORD *)(v14 + 16LL * v15);
        v17 = *v16;
        if ( *a3 == *v16 )
          goto LABEL_20;
      }
    }
    v16 = (_QWORD *)(v14 + 16 * v13);
    goto LABEL_20;
  }
  return (unsigned __int64)v5;
}


================================================================================
Function: sub_64A5448 (0x64A5448)
================================================================================

void *sub_64A5448()
{
  void *result; // x0

  result = memset(&unk_70ECCD8, 0, 0x1100uLL);
  *(_WORD *)((char *)&unk_70ECCD8 + (unsigned int)&algn_1018[5]) = 257;
  return result;
}


================================================================================
Function: sub_64A5550 (0x64A5550)
================================================================================

_QWORD *__fastcall sub_64A5550(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // w9
  __int64 v5; // x1
  _QWORD *result; // x0
  int v9; // w8
  int v10; // w11
  unsigned int v11; // w12
  __int64 v12; // x15
  _QWORD *v13; // x13
  int v14; // w16
  unsigned int v15; // w12
  bool v16; // zf

  v3 = *(_DWORD *)(a1 + 8);
  v5 = *(unsigned int *)(a1 + 16);
  if ( 4 * v3 + 4 >= (unsigned int)(3 * v5) )
  {
    v5 = (unsigned int)(2 * v5);
  }
  else if ( (int)v5 + ~v3 - *(_DWORD *)(a1 + 12) > (unsigned int)v5 >> 3 )
  {
    goto LABEL_3;
  }
  sub_64A5668(a1, v5);
  v9 = *(_DWORD *)(a1 + 16);
  if ( v9 )
  {
    v10 = v9 - 1;
    v11 = (37 * *a3) & (v9 - 1);
    a2 = (_QWORD *)(*(_QWORD *)a1 + 16LL * v11);
    v12 = *a2;
    if ( *a3 != *a2 )
    {
      v13 = 0LL;
      v14 = 1;
      while ( v12 != -1 )
      {
        v15 = v11 + v14;
        if ( v13 )
          v16 = 0;
        else
          v16 = v12 == -2;
        v11 = v15 & v10;
        ++v14;
        if ( v16 )
          v13 = a2;
        a2 = (_QWORD *)(*(_QWORD *)a1 + 16LL * v11);
        v12 = *a2;
        if ( *a3 == *a2 )
          goto LABEL_3;
      }
      if ( v13 )
        a2 = v13;
    }
  }
  else
  {
    a2 = 0LL;
  }
LABEL_3:
  v16 = *a2 == -1LL;
  ++*(_DWORD *)(a1 + 8);
  if ( !v16 )
    --*(_DWORD *)(a1 + 12);
  result = a2;
  *a2 = *a3;
  a2[1] = 0LL;
  return result;
}


================================================================================
Function: sub_64A5668 (0x64A5668)
================================================================================

__int64 __fastcall sub_64A5668(__int64 a1, int a2)
{
  __int64 v3; // x21
  unsigned __int64 v4; // x8
  __int64 *v5; // x20
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x8
  int v8; // w8
  int v9; // w8
  __int64 result; // x0
  __int64 v11; // x10
  __int64 v12; // x8
  __int64 v13; // x9
  _QWORD *v14; // x12
  __int64 v15; // x11
  __int64 v16; // x14
  _QWORD *v17; // x8
  __int64 v18; // x8
  __int64 v19; // x9
  __int64 v20; // x10
  _QWORD *v21; // x12
  __int64 v22; // x11
  __int64 v23; // x14
  _QWORD *v24; // x9
  int v25; // w8
  int v26; // w10
  __int64 *v27; // x13
  _QWORD *v28; // x8
  _QWORD *v29; // x15
  __int64 v30; // x14
  __int64 v31; // x14
  unsigned int v32; // w16
  __int64 v33; // x1
  _QWORD *v34; // x17
  int v35; // w2
  unsigned int v36; // w16
  bool v37; // zf

  v3 = *(unsigned int *)(a1 + 16);
  v4 = (unsigned int)(a2 - 1) | ((unsigned __int64)(unsigned int)(a2 - 1) >> 1);
  v5 = *(__int64 **)a1;
  v6 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
  v7 = v6 | (v6 >> 8) | ((v6 | (v6 >> 8)) >> 16);
  v8 = HIDWORD(v7) | v7;
  if ( (unsigned int)(v8 + 1) > 0x40 )
    v9 = v8 + 1;
  else
    v9 = 64;
  *(_DWORD *)(a1 + 16) = v9;
  result = sub_6575418();
  *(_QWORD *)a1 = result;
  if ( !v5 )
  {
    v18 = *(unsigned int *)(a1 + 16);
    *(_QWORD *)(a1 + 8) = 0LL;
    if ( !(_DWORD)v18 )
      return result;
    v19 = (v18 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if ( v19 )
    {
      v20 = v19 + 1;
      v21 = (_QWORD *)(result + 16);
      v22 = (v19 + 1) & 0x1FFFFFFFFFFFFFFELL;
      v23 = v22;
      v24 = (_QWORD *)(result + 16 * v22);
      do
      {
        v23 -= 2LL;
        *(v21 - 2) = -1LL;
        *v21 = -1LL;
        v21 += 4;
      }
      while ( v23 );
      if ( v20 == v22 )
        return result;
    }
    else
    {
      v24 = (_QWORD *)result;
    }
    v28 = (_QWORD *)(result + 16 * v18);
    do
    {
      *v24 = -1LL;
      v24 += 2;
    }
    while ( v24 != v28 );
    return result;
  }
  v11 = *(unsigned int *)(a1 + 16);
  *(_QWORD *)(a1 + 8) = 0LL;
  if ( (_DWORD)v11 )
  {
    v12 = (v11 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if ( v12 )
    {
      v13 = v12 + 1;
      v14 = (_QWORD *)(result + 16);
      v15 = (v12 + 1) & 0x1FFFFFFFFFFFFFFELL;
      v16 = v15;
      v17 = (_QWORD *)(result + 16 * v15);
      do
      {
        v16 -= 2LL;
        *(v14 - 2) = -1LL;
        *v14 = -1LL;
        v14 += 4;
      }
      while ( v16 );
      if ( v13 == v15 )
        goto LABEL_19;
    }
    else
    {
      v17 = (_QWORD *)result;
    }
    do
    {
      *v17 = -1LL;
      v17 += 2;
    }
    while ( v17 != (_QWORD *)(result + 16 * v11) );
  }
LABEL_19:
  if ( (_DWORD)v3 )
  {
    v25 = 0;
    v26 = v11 - 1;
    v27 = v5;
    do
    {
      v31 = *v27;
      if ( (unsigned __int64)*v27 <= 0xFFFFFFFFFFFFFFFDLL )
      {
        v32 = (37 * v31) & v26;
        v29 = (_QWORD *)(result + 16LL * v32);
        v33 = *v29;
        if ( v31 != *v29 )
        {
          v34 = 0LL;
          v35 = 1;
          while ( v33 != -1 )
          {
            v36 = v32 + v35;
            if ( v34 )
              v37 = 0;
            else
              v37 = v33 == -2;
            v32 = v36 & v26;
            ++v35;
            if ( v37 )
              v34 = v29;
            v29 = (_QWORD *)(result + 16LL * v32);
            v33 = *v29;
            if ( v31 == *v29 )
              goto LABEL_27;
          }
          if ( v34 )
            v29 = v34;
        }
LABEL_27:
        *v29 = v31;
        ++v25;
        v30 = v27[1];
        *(_DWORD *)(a1 + 8) = v25;
        v29[1] = v30;
      }
      v27 += 2;
    }
    while ( v27 != &v5[2 * v3] );
  }
  return sub_6575460();
}


================================================================================
Function: sub_64A585C (0x64A585C)
================================================================================

__int64 __fastcall sub_64A585C(__int64 *a1)
{
  unsigned __int64 v2; // x8
  bool v3; // cf
  unsigned __int64 v4; // x8
  __int64 *v5; // x9
  __int64 v6; // x8
  __int64 result; // x0
  __int64 v8; // x8
  __int64 v9; // x9
  __int64 v10; // x10
  unsigned __int64 v11; // x22
  unsigned __int64 v12; // x8
  __int64 v13; // x20
  __int64 v14; // x20
  __int64 v15; // x22
  __int128 v16; // q0
  __int64 v17; // x10
  __int64 v18; // x8
  __int64 v19; // x9
  __int64 *v20; // x8
  __int64 v21; // t1
  __int64 v22; // [xsp+8h] [xbp-38h] BYREF
  __int64 v23; // [xsp+10h] [xbp-30h] BYREF
  __int128 v24; // [xsp+18h] [xbp-28h]
  __int64 v25; // [xsp+28h] [xbp-18h]
  _QWORD *v26; // [xsp+30h] [xbp-10h]

  v2 = a1[4];
  v3 = v2 >= 0x100;
  v4 = v2 - 256;
  if ( v3 )
  {
    v5 = (__int64 *)a1[1];
    a1[4] = v4;
    v6 = *v5;
    a1[1] = (__int64)(v5 + 1);
    v23 = v6;
    return sub_64A5A78(a1, &v23);
  }
  v8 = a1[2];
  v9 = a1[3];
  v10 = v9 - *a1;
  v11 = (v8 - a1[1]) >> 3;
  if ( v11 < v10 >> 3 )
  {
    if ( v9 != v8 )
    {
      v23 = sub_6575418();
      return sub_64A5C30(a1, &v23);
    }
    v23 = sub_6575418();
    sub_64A5DE8(a1, &v23);
    v20 = (__int64 *)a1[1];
    v21 = *v20;
    a1[1] = (__int64)(v20 + 1);
    v23 = v21;
    return sub_64A5A78(a1, &v23);
  }
  v12 = v10 >> 2;
  if ( !v10 )
    v12 = 1LL;
  v26 = a1 + 3;
  if ( v12 >> 61 )
    sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v13 = 8 * v12;
  v23 = sub_6575418();
  *(_QWORD *)&v24 = v23 + 8 * v11;
  *((_QWORD *)&v24 + 1) = v24;
  v25 = v23 + v13;
  v22 = sub_6575418();
  sub_64A5FA8(&v23, &v22);
  v14 = a1[2];
  v15 = v14 + 8;
  while ( v14 != a1[1] )
  {
    v14 -= 8LL;
    v15 -= 8LL;
    sub_64A6160(&v23, v14);
  }
  result = *a1;
  v16 = v24;
  *a1 = v23;
  v17 = v25;
  v18 = a1[2];
  v19 = a1[3];
  *(_OWORD *)(a1 + 1) = v16;
  v23 = result;
  *(_QWORD *)&v24 = v14;
  a1[3] = v17;
  *((_QWORD *)&v24 + 1) = v18;
  v25 = v19;
  if ( v14 != v18 )
    *((_QWORD *)&v24 + 1) = v18 + 8 * ~((unsigned __int64)(v18 - v15) >> 3);
  if ( result )
    return sub_6575460();
  return result;
}


================================================================================
Function: sub_64A5A78 (0x64A5A78)
================================================================================

__int64 __fastcall sub_64A5A78(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_6575418();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_6575460();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_64A5C30 (0x64A5C30)
================================================================================

__int64 __fastcall sub_64A5C30(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_6575418();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_6575460();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_64A5DE8 (0x64A5DE8)
================================================================================

__int64 __fastcall sub_64A5DE8(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_6575418();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_6575460();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_64A5FA8 (0x64A5FA8)
================================================================================

__int64 __fastcall sub_64A5FA8(__int64 result, _QWORD *a2)
{
  char *v2; // x24
  _QWORD *v3; // x19
  char *v5; // x21
  char *v6; // x22
  __int64 v7; // x8
  __int64 v8; // x8
  signed __int64 v9; // x23
  __int64 v10; // x8
  __int64 v11; // x25
  char *v12; // x21
  unsigned __int64 v13; // x8
  __int64 v14; // x23
  unsigned __int64 v15; // x25
  char *v16; // x8
  bool v17; // zf
  signed __int64 v18; // x10
  unsigned __int64 v19; // x11
  char *v20; // x10
  __int64 v21; // x11
  __int128 *v22; // x14
  _OWORD *v23; // x15
  __int64 v24; // x13
  __int64 v25; // x16
  char *v26; // x13
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(char **)(result + 16);
  v3 = (_QWORD *)result;
  if ( v2 != *(char **)(result + 24) )
    goto LABEL_23;
  v5 = *(char **)result;
  v6 = *(char **)(result + 8);
  if ( (unsigned __int64)v6 > *(_QWORD *)result )
  {
    v7 = (__int64)&v6[-*(_QWORD *)result] >> 3;
    if ( v7 + 1 >= 0 )
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v2 - v6;
    v10 = v8 >> 1;
    v11 = -v10;
    v12 = &v6[-8 * v10];
    if ( v2 != v6 )
    {
      result = (__int64)memmove(&v6[-8 * v10], *(const void **)(result + 8), v2 - v6);
      v6 = (char *)v3[1];
    }
    v2 = &v12[v9];
    v3[1] = &v6[8 * v11];
    v3[2] = &v12[v9];
    goto LABEL_23;
  }
  v13 = (v2 - v5) >> 2;
  if ( v2 == v5 )
    v13 = 1LL;
  if ( v13 >> 61 )
    sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
  v14 = 8 * v13;
  v15 = v13 >> 2;
  result = sub_6575418();
  v16 = (char *)(result + 8 * v15);
  v18 = v2 - v6;
  v17 = v2 == v6;
  v2 = v16;
  if ( !v17 )
  {
    v2 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    v19 = v18 - 8;
    if ( (unsigned __int64)(v18 - 8) < 0x18 )
    {
      v20 = (char *)(result + 8 * v15);
      do
      {
LABEL_20:
        v29 = *(_QWORD *)v6;
        v6 += 8;
        *(_QWORD *)v20 = v29;
        v20 += 8;
      }
      while ( v20 != v2 );
      goto LABEL_21;
    }
    if ( result + 8 * v15 < (unsigned __int64)&v6[(v19 & 0xFFFFFFFFFFFFFFF8LL) + 8] )
    {
      v20 = (char *)(result + 8 * v15);
      if ( 8 * v15 + (v19 & 0xFFFFFFFFFFFFFFF8LL) + result + 8 > (unsigned __int64)v6 )
        goto LABEL_20;
    }
    v21 = (v19 >> 3) + 1;
    v22 = (__int128 *)(v6 + 16);
    v23 = (_OWORD *)(result + 8 * v15 + 16);
    v24 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
    v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    v20 = &v16[v24];
    v26 = &v6[v24];
    do
    {
      v27 = *(v22 - 1);
      v28 = *v22;
      v22 += 2;
      v25 -= 4LL;
      *(v23 - 1) = v27;
      *v23 = v28;
      v23 += 2;
    }
    while ( v25 );
    v6 = v26;
    if ( v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL) )
      goto LABEL_20;
  }
LABEL_21:
  *v3 = result;
  v3[1] = v16;
  v3[2] = v2;
  v3[3] = result + v14;
  if ( v5 )
  {
    result = sub_6575460();
    v2 = (char *)v3[2];
  }
LABEL_23:
  *(_QWORD *)v2 = *a2;
  v3[2] += 8LL;
  return result;
}


================================================================================
Function: sub_64A6160 (0x64A6160)
================================================================================

__int64 __fastcall sub_64A6160(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x21
  _QWORD *v3; // x19
  char *v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x25
  __int64 v8; // x8
  __int64 v9; // x8
  size_t v10; // x2
  __int64 v11; // x23
  bool v12; // zf
  __int64 v13; // x8
  unsigned __int64 v14; // x8
  __int64 v15; // x23
  unsigned __int64 v16; // x24
  unsigned __int64 v17; // x10
  char *v18; // x9
  unsigned __int64 v19; // x12
  char *v20; // x10
  __int64 *v21; // x11
  __int64 v22; // x12
  __int128 *v23; // x14
  _OWORD *v24; // x15
  __int64 v25; // x11
  __int64 v26; // x16
  __int128 v27; // q0
  __int128 v28; // q1
  __int64 v29; // t1

  v2 = *(_QWORD *)(result + 8);
  v3 = (_QWORD *)result;
  if ( v2 == *(_QWORD *)result )
  {
    v7 = *(_QWORD *)(result + 16);
    v6 = *(_QWORD *)(result + 24);
    if ( v7 >= v6 )
    {
      v13 = v6 - v2;
      v12 = v13 == 0;
      v14 = v13 >> 2;
      if ( v12 )
        v14 = 1LL;
      if ( v14 >> 61 )
        sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v15 = 8 * v14;
      v16 = (v14 + 3) >> 2;
      result = sub_6575418();
      v5 = (char *)(result + 8 * v16);
      v17 = v7 - v2;
      v18 = v5;
      if ( v7 != v2 )
      {
        v19 = v17 - 8;
        v18 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        v20 = (char *)(result + 8 * v16);
        v21 = (__int64 *)v2;
        if ( v19 < 0x18 )
          goto LABEL_28;
        if ( result + 8 * v16 < (v19 & 0xFFFFFFFFFFFFFFF8LL) + v2 + 8 )
        {
          v21 = (__int64 *)v2;
          v20 = (char *)(result + 8 * v16);
          if ( (v19 & 0xFFFFFFFFFFFFFFF8LL) + 8 * v16 + result + 8 > v2 )
            goto LABEL_28;
        }
        v22 = (v19 >> 3) + 1;
        v23 = (__int128 *)(v2 + 16);
        v24 = (_OWORD *)(result + 8 * v16 + 16);
        v25 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v26 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        v20 = &v5[v25];
        v21 = (__int64 *)(v2 + v25);
        do
        {
          v27 = *(v23 - 1);
          v28 = *v23;
          v23 += 2;
          v26 -= 4LL;
          *(v24 - 1) = v27;
          *v24 = v28;
          v24 += 2;
        }
        while ( v26 );
        if ( v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL) )
        {
LABEL_28:
          do
          {
            v29 = *v21++;
            *(_QWORD *)v20 = v29;
            v20 += 8;
          }
          while ( v20 != v18 );
        }
      }
      *v3 = result;
      v3[1] = v5;
      v3[2] = v18;
      v3[3] = result + v15;
      if ( v2 )
      {
        result = sub_6575460();
        v5 = (char *)v3[1];
      }
    }
    else
    {
      v8 = (__int64)(v6 - v7) >> 3;
      if ( v8 + 1 >= 0 )
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v7 - v2;
      v11 = v9 >> 1;
      v5 = (char *)(v7 + 8 * (v9 >> 1));
      if ( v7 != v2 )
      {
        v5 -= v10;
        result = (__int64)memmove(v5, *(const void **)(result + 8), v10);
        v7 = v3[2];
      }
      v3[1] = v5;
      v3[2] = v7 + 8 * v11;
    }
  }
  else
  {
    v5 = *(char **)(result + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  v3[1] -= 8LL;
  return result;
}


================================================================================
Function: sub_64AB8DC (0x64AB8DC)
================================================================================

_QWORD *sub_64AB8DC()
{
  return sub_67EF968(qword_6C2FE28);
}


================================================================================
Function: sub_64AB8F8 (0x64AB8F8)
================================================================================

_QWORD *__fastcall sub_64AB8F8(_QWORD *result)
{
  __int16 v1; // w19
  __int64 v2; // x20

  if ( result )
  {
    v1 = (__int16)result;
    sub_64AB8DC();
    v2 = *((unsigned __int8 *)sub_67EF968(qword_6C2FE28) + 32);
    result = sub_67EF968(qword_6C2FE28);
    if ( (unsigned int)v2 > 0xF )
    {
      ++*((_DWORD *)result + 9);
    }
    else
    {
      *((_WORD *)result + v2) = v1;
      *((_BYTE *)result + 32) = v2 + 1;
    }
  }
  return result;
}


================================================================================
Function: sub_64AB960 (0x64AB960)
================================================================================

_QWORD *__fastcall sub_64AB960(_QWORD *result)
{
  unsigned __int16 v1; // w19
  int v2; // w8
  int v3; // w19
  char v4; // w8
  unsigned __int8 v5; // w20

  if ( result )
  {
    v1 = (unsigned __int16)result;
    sub_64AB8DC();
    v2 = *((_DWORD *)sub_67EF968(qword_6C2FE28) + 9);
    if ( v2 )
    {
      v3 = v2 - 1;
      result = sub_67EF968(qword_6C2FE28);
      *((_DWORD *)result + 9) = v3;
    }
    else
    {
      v4 = *((_BYTE *)sub_67EF968(qword_6C2FE28) + 32);
      if ( !v4
        || (v5 = v4 - 1,
            result = sub_67EF968(qword_6C2FE28),
            *((_BYTE *)result + 32) = v5,
            *((unsigned __int16 *)result + v5) != v1) )
      {
        result = sub_67EF968(qword_6C2FE28);
        *((_BYTE *)result + 40) = 1;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_64BF11C (0x64BF11C)
================================================================================

__int64 __fastcall sub_64BF11C(const char *a1, __int64 a2, unsigned int a3)
{
  _BOOL8 v6; // x3

  v6 = strcmp(a1, "GPU") == 0;
  return sub_6493454(a1, a2, a3, v6);
}


================================================================================
Function: sub_64BFCB4 (0x64BFCB4)
================================================================================

__int64 __fastcall sub_64BFCB4(const char *a1)
{
  int v2; // w8

  v2 = strcmp(a1, "GPU");
  return sub_6494170(a1, v2 == 0);
}


================================================================================
Function: sub_64BFCFC (0x64BFCFC)
================================================================================

__int64 __fastcall sub_64BFCFC(__int64 a1, __int64 a2, __int64 a3)
{
  bool v6; // zf
  __int64 v7; // x19
  int v8; // w21
  __int64 v9; // x23
  unsigned __int64 v10; // x0
  __int64 v11; // x8
  unsigned int v12; // w11
  unsigned __int64 v13; // x9
  unsigned __int64 v14; // x10
  bool v15; // cf
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x10
  unsigned __int64 v18; // x10
  unsigned int v19; // w12
  unsigned int v20; // w11
  unsigned int v21; // w12
  unsigned int v22; // w13
  unsigned int v23; // w12
  unsigned __int64 v24; // x10
  unsigned int v25; // w11
  unsigned int v26; // w12

  if ( byte_71CF7B0 )
  {
    if ( byte_71BEE40 )
      v6 = 1;
    else
      v6 = qword_6F7D7A8 == 0;
    if ( !v6 )
      goto LABEL_9;
    return -1LL;
  }
  if ( !qword_6F7D7A8 )
    return -1LL;
LABEL_9:
  v8 = sub_6574924(dword_71BEF88);
  if ( !a3 )
    a3 = *(_QWORD *)sub_2550CD0();
  if ( byte_71BEF18 && a3 && *(_QWORD *)(a3 + 88) )
    ++*(_QWORD *)(a3 + 96);
  if ( byte_71CF7B0 )
  {
    if ( byte_71BEED8 )
    {
      if ( a3 )
      {
        v9 = sub_654B108();
        *(_DWORD *)(a3 + 72) = sub_654AE64();
        *(_DWORD *)(a3 + 76) = sub_654AE6C(v9);
        *(_QWORD *)(a3 + 56) = sub_654AE74(v9);
        v10 = sub_654AE7C(v9);
        v11 = *(_QWORD *)(a3 + 8);
        *(_QWORD *)(a3 + 64) = v10;
        *(_QWORD *)(a3 + 40) = 0LL;
        *(_QWORD *)(a3 + 48) = 0LL;
        *(_QWORD *)(a3 + 32) = 0LL;
        if ( v11 )
        {
          v12 = *(_DWORD *)(v11 + 72);
          if ( v12 )
          {
            v13 = *(_QWORD *)(a3 + 56);
            v14 = *(_QWORD *)(v11 + 56);
            v15 = v13 >= v14;
            v16 = v13 - v14;
            if ( v15 )
            {
              v17 = *(_QWORD *)(v11 + 64);
              v15 = v10 >= v17;
              v18 = v10 - v17;
              if ( v15 )
              {
                v19 = *(_DWORD *)(a3 + 72);
                v15 = v19 >= v12;
                v20 = v19 - v12;
                if ( v15 )
                {
                  v21 = *(_DWORD *)(a3 + 76);
                  v22 = *(_DWORD *)(v11 + 76);
                  v15 = v21 >= v22;
                  v23 = v21 - v22;
                  if ( v15 )
                  {
                    v24 = v18 + *(_QWORD *)(v11 + 40);
                    v25 = v20 + *(_DWORD *)(v11 + 48);
                    v26 = v23 + *(_DWORD *)(v11 + 52);
                    *(_QWORD *)(v11 + 32) += v16;
                    *(_QWORD *)(v11 + 40) = v24;
                    *(_DWORD *)(v11 + 48) = v25;
                    *(_DWORD *)(v11 + 52) = v26;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v7 = sub_6494654(a1, a2);
  sub_6574924(v8);
  return v7;
}


================================================================================
Function: sub_64BFEFC (0x64BFEFC)
================================================================================

__int64 sub_64BFEFC(__int64 result, char *a2, ...)
{
  gcc_va_list va1; // [xsp+B0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-28h] BYREF

  if ( !byte_71CF7B0 || !byte_71BEE40 )
  {
    va_start(va, a2);
    va_copy(va1, va);
    return sub_6495060(result, a2);
  }
  return result;
}


================================================================================
Function: sub_64BFFEC (0x64BFFEC)
================================================================================

__int64 __fastcall sub_64BFFEC(__int64 result, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  __int64 v6; // x22
  __int64 v9; // x21
  __int64 v10; // x8
  bool v11; // w9
  int v12; // w23
  __int64 v13; // x1
  __int64 v14; // x26
  unsigned int v15; // w23
  unsigned int v16; // w24
  unsigned __int64 v17; // x25
  unsigned __int64 v18; // x0
  unsigned int v19; // w10
  unsigned __int64 v20; // x8
  bool v21; // cf
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x9
  unsigned int v25; // w10
  unsigned int v26; // w11
  unsigned int v27; // w11
  unsigned __int64 v28; // x9
  unsigned int v29; // w10
  unsigned int v30; // w11
  __int64 v31; // x8
  unsigned __int64 v32; // x1
  unsigned __int64 v33; // x8
  unsigned __int64 v34; // [xsp+8h] [xbp-18h] BYREF
  __int64 v35; // [xsp+10h] [xbp-10h] BYREF

  v6 = a4;
  v9 = result;
  if ( byte_71CF7B0 )
  {
    if ( a2 == -1 || byte_71BEE40 )
      return result;
  }
  else if ( a2 == -1 )
  {
    return result;
  }
  if ( !a4 )
    v6 = *(_QWORD *)sub_2550CD0();
  if ( byte_71BEF18 )
  {
    if ( v6 )
    {
      v10 = *(_QWORD *)(v6 + 88);
      if ( v10 )
      {
        v11 = *(_QWORD *)(v6 + 96) == 1LL;
        v12 = a5 & 1;
        v13 = v12 ? 0LL : 0x2000000000000LL;
        v35 = 0LL;
        sub_64952A4(
          33LL,
          v13 & 0xFFFE000000000000LL | v10 & 0xFFFFFFFFFFFFLL | ((unsigned __int64)v11 << 48),
          0LL,
          0LL,
          0LL,
          &v35);
        if ( !v12 )
          *(_QWORD *)(v6 + 96) = 0LL;
      }
    }
  }
  if ( byte_71CF7B0 && byte_71BEED8 && *off_6C2FEA0 && v6 )
  {
    v14 = sub_654B108();
    v15 = sub_654AE64();
    v16 = sub_654AE6C(v14);
    v17 = sub_654AE74(v14);
    v18 = sub_654AE7C(v14);
    v19 = *(_DWORD *)(v6 + 72);
    if ( v19 )
    {
      v20 = *(_QWORD *)(v6 + 56);
      v21 = v17 >= v20;
      v22 = v17 - v20;
      if ( v21 )
      {
        v23 = *(_QWORD *)(v6 + 64);
        v21 = v18 >= v23;
        v24 = v18 - v23;
        if ( v21 )
        {
          v21 = v15 >= v19;
          v25 = v15 - v19;
          if ( v21 )
          {
            v26 = *(_DWORD *)(v6 + 76);
            v21 = v16 >= v26;
            v27 = v16 - v26;
            if ( v21 )
            {
              v28 = v24 + *(_QWORD *)(v6 + 40);
              v29 = v25 + *(_DWORD *)(v6 + 48);
              v30 = v27 + *(_DWORD *)(v6 + 52);
              *(_QWORD *)(v6 + 32) += v22;
              *(_QWORD *)(v6 + 40) = v28;
              *(_DWORD *)(v6 + 48) = v29;
              *(_DWORD *)(v6 + 52) = v30;
            }
          }
        }
      }
    }
    v31 = *(_QWORD *)(v6 + 8);
    if ( v31 )
    {
      *(_QWORD *)(v31 + 56) = v17;
      *(_QWORD *)(v31 + 64) = v18;
      *(_DWORD *)(v31 + 72) = v15;
      *(_DWORD *)(v31 + 76) = v16;
    }
    v32 = *(_DWORD *)(v6 + 52) & 0xFFFFFFLL | ((unsigned __int64)(*(_DWORD *)(v6 + 48) & 0xFFFFFF) << 24);
    v33 = v32 | *(unsigned int *)(v6 + 40) | ((unsigned __int64)(unsigned int)*(_QWORD *)(v6 + 32) << 32);
    v34 = *(unsigned int *)(v6 + 40) | ((unsigned __int64)(unsigned int)*(_QWORD *)(v6 + 32) << 32);
    if ( v33 )
    {
      v35 = 0LL;
      sub_64952A4(20LL, v32, &v34, 8LL, 0LL, &v35);
    }
  }
  return sub_64953E8(v9, a2, a3);
}


================================================================================
Function: sub_6517F8C (0x6517F8C)
================================================================================

__int64 __usercall sub_6517F8C@<X0>(__int64 a1@<X0>, __int64 a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  return sub_651A89C(a3, a1, a2);
}


================================================================================
Function: sub_65186CC (0x65186CC)
================================================================================

__int64 *__usercall sub_65186CC@<X0>(__int64 *__return_ptr a1@<X8>, __int64 *src@<X0>, size_t a3@<X1>)
{
  __int64 *v4; // x21
  size_t v5; // x8
  unsigned __int64 v6; // x9
  size_t v7; // x22
  bool v8; // cf
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x0
  size_t v11; // x11
  unsigned __int64 v12; // x10
  const void *v13; // x21
  size_t v14; // x20
  char *v15; // x22
  const void *v16; // x21
  size_t v17; // x20
  char *v18; // x22
  size_t v19; // x23
  __int64 v20; // x8
  __int64 v21; // x1
  size_t v22; // x23
  __int64 v23; // x8
  unsigned __int64 v24; // x0
  unsigned __int64 v25; // x11
  unsigned __int64 v26; // x10
  const void *v27; // x21
  size_t v28; // x20
  char *v29; // x22
  char *v30; // x23
  __int64 v31; // x8
  unsigned __int64 v32; // x0
  __int64 v33; // x1
  char *v34; // x21
  size_t v35; // x20
  unsigned __int64 v36; // x26
  size_t v37; // x22
  char *v38; // x23
  char *v39; // x22
  __int64 v40; // x8
  __int64 v41; // x8
  char v42; // w8
  __int64 v43; // x8
  __int128 v44; // [xsp+8h] [xbp-88h] BYREF
  char *v45; // [xsp+18h] [xbp-78h]
  __int128 s2; // [xsp+20h] [xbp-70h] BYREF
  char *v47; // [xsp+30h] [xbp-60h]
  unsigned __int64 v48; // [xsp+38h] [xbp-58h]
  size_t n[2]; // [xsp+40h] [xbp-50h] BYREF
  __int128 v50; // [xsp+50h] [xbp-40h] BYREF
  char *v51; // [xsp+68h] [xbp-28h]
  size_t v52; // [xsp+70h] [xbp-20h]
  __int128 v53; // [xsp+78h] [xbp-18h] BYREF

  *(_OWORD *)((char *)a1 + 106) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  if ( !a3 )
    return src;
  v4 = src;
  v5 = 0LL;
  while ( byte_1703D90[*((unsigned __int8 *)src + v5)] < 0 )
  {
    if ( a3 == ++v5 )
    {
      v52 = a3;
      v53 = (unsigned __int64)src + a3;
LABEL_12:
      *(_QWORD *)&v53 = src;
      *((_QWORD *)&v53 + 1) = a3;
      v51 = &byte_CBCB6C;
      v52 = 0LL;
      goto LABEL_13;
    }
  }
  v6 = a3 - v5;
  if ( a3 >= v5 )
    v7 = v5;
  else
    v7 = a3;
  v8 = v6 >= 3;
  v9 = v6 - 3;
  v51 = (char *)src;
  v52 = v7;
  if ( !v8 || *(unsigned __int16 *)((char *)src + v5) ^ 0x2F3A | *((unsigned __int8 *)src + v5 + 2) ^ 0x2F )
    goto LABEL_12;
  *(_QWORD *)&v53 = (char *)src + v5 + 3;
  *((_QWORD *)&v53 + 1) = v9;
  if ( src )
  {
    if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
      sub_67D2618();
    if ( v7 >= 0x17 )
    {
      v30 = (char *)sub_6575418();
      n[1] = v7;
      *(_QWORD *)&v50 = v30;
      n[0] = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v30 = (char *)n + 1;
      LOBYTE(n[0]) = 2 * v7;
      if ( !v7 )
      {
LABEL_104:
        v42 = *(_BYTE *)a1;
        v30[v7] = 0;
        if ( (v42 & 1) != 0 )
          sub_6575460();
        goto LABEL_106;
      }
    }
    memcpy(v30, v4, v7);
    goto LABEL_104;
  }
  n[0] = 0LL;
  n[1] = 0LL;
  *(_QWORD *)&v50 = 0LL;
LABEL_106:
  v43 = v50;
  *(_OWORD *)a1 = *(_OWORD *)n;
  a1[2] = v43;
LABEL_13:
  LOBYTE(s2) = 47;
  v10 = sub_657ECD8((int)&v53, &s2, 1uLL);
  if ( v10 == -1LL )
  {
    v50 = 0uLL;
    *(_OWORD *)n = v53;
  }
  else
  {
    if ( *((_QWORD *)&v53 + 1) >= v10 )
      v11 = v10;
    else
      v11 = *((_QWORD *)&v53 + 1);
    if ( *((_QWORD *)&v53 + 1) >= v10 + 1 )
      v12 = v10 + 1;
    else
      v12 = *((_QWORD *)&v53 + 1);
    n[0] = v53;
    n[1] = v11;
    *(_QWORD *)&v50 = v53 + v12;
    *((_QWORD *)&v50 + 1) = *((_QWORD *)&v53 + 1) - v12;
    if ( *((_QWORD *)&v53 + 1) != v12 )
    {
      v13 = (const void *)n[0];
      if ( !n[0] )
      {
        s2 = 0uLL;
        v47 = 0LL;
        goto LABEL_43;
      }
      v14 = n[1];
      if ( n[1] >= 0xFFFFFFFFFFFFFFF0LL )
        sub_67D2618();
      if ( n[1] >= 0x17 )
      {
        v22 = (n[1] + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v15 = (char *)sub_6575418();
        *((_QWORD *)&s2 + 1) = v14;
        v47 = v15;
        *(_QWORD *)&s2 = v22 | 1;
      }
      else
      {
        v15 = (char *)&s2 + 1;
        LOBYTE(s2) = 2 * LOBYTE(n[1]);
        if ( !n[1] )
          goto LABEL_42;
      }
      memcpy(v15, v13, v14);
LABEL_42:
      v15[v14] = 0;
LABEL_43:
      if ( (a1[3] & 1) != 0 )
        sub_6575460();
      v23 = (__int64)v47;
      *(_OWORD *)(a1 + 3) = s2;
      a1[5] = v23;
      LOBYTE(v44) = 35;
      v24 = sub_657ECD8((int)&v50, &v44, 1uLL);
      if ( v24 == -1LL )
      {
        v47 = 0LL;
        v48 = 0LL;
        s2 = v50;
      }
      else
      {
        if ( *((_QWORD *)&v50 + 1) >= v24 )
          v25 = v24;
        else
          v25 = *((_QWORD *)&v50 + 1);
        if ( *((_QWORD *)&v50 + 1) >= v24 + 1 )
          v26 = v24 + 1;
        else
          v26 = *((_QWORD *)&v50 + 1);
        v27 = (const void *)(v50 + v26);
        v28 = *((_QWORD *)&v50 + 1) - v26;
        *(_QWORD *)&s2 = v50;
        *((_QWORD *)&s2 + 1) = v25;
        v47 = (char *)(v50 + v26);
        v48 = *((_QWORD *)&v50 + 1) - v26;
        if ( *((_QWORD *)&v50 + 1) != v26 )
        {
          if ( (_QWORD)v50 )
          {
            if ( v28 >= 0xFFFFFFFFFFFFFFF0LL )
              sub_67D2618();
            if ( v28 >= 0x17 )
            {
              v29 = (char *)sub_6575418();
              *((_QWORD *)&v44 + 1) = v28;
              v45 = v29;
              *(_QWORD *)&v44 = (v28 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              v29 = (char *)&v44 + 1;
              LOBYTE(v44) = 2 * v28;
            }
            memcpy(v29, v27, v28);
            v29[v28] = 0;
          }
          else
          {
            v44 = 0uLL;
            v45 = 0LL;
          }
          if ( (a1[12] & 1) != 0 )
            sub_6575460();
          v31 = (__int64)v45;
          *((_OWORD *)a1 + 6) = v44;
          a1[14] = v31;
        }
      }
      LOBYTE(v44) = 63;
      v32 = sub_657ECD8((int)&s2, &v44, 1uLL);
      if ( v32 == -1LL )
      {
        v35 = *((_QWORD *)&s2 + 1);
        v34 = (char *)s2;
      }
      else
      {
        v34 = (char *)s2;
        if ( *((_QWORD *)&s2 + 1) >= v32 )
          v35 = v32;
        else
          v35 = *((_QWORD *)&s2 + 1);
        if ( *((_QWORD *)&s2 + 1) >= v32 + 1 )
          v36 = v32 + 1;
        else
          v36 = *((_QWORD *)&s2 + 1);
        v37 = *((_QWORD *)&s2 + 1) - v36;
        if ( *((_QWORD *)&s2 + 1) != v36 )
        {
          if ( (_QWORD)s2 )
          {
            if ( v37 >= 0xFFFFFFFFFFFFFFF0LL )
              sub_67D2618();
            if ( v37 >= 0x17 )
            {
              v38 = (char *)sub_6575418();
              *((_QWORD *)&v44 + 1) = v37;
              v45 = v38;
              *(_QWORD *)&v44 = (v37 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
            }
            else
            {
              v38 = (char *)&v44 + 1;
              LOBYTE(v44) = 2 * v37;
            }
            memcpy(v38, &v34[v36], v37);
            v38[v37] = 0;
          }
          else
          {
            v44 = 0uLL;
            v45 = 0LL;
          }
          if ( (a1[9] & 1) != 0 )
            sub_6575460();
          v40 = (__int64)v45;
          *(_OWORD *)(a1 + 9) = v44;
          a1[11] = v40;
          if ( !v34 )
            goto LABEL_96;
          goto LABEL_83;
        }
      }
      if ( !v34 )
      {
LABEL_96:
        v44 = 0uLL;
        v45 = 0LL;
        goto LABEL_97;
      }
LABEL_83:
      if ( v35 >= 0xFFFFFFFFFFFFFFF0LL )
        sub_67D2618();
      if ( v35 >= 0x17 )
      {
        v39 = (char *)sub_6575418();
        *((_QWORD *)&v44 + 1) = v35;
        v45 = v39;
        *(_QWORD *)&v44 = (v35 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      }
      else
      {
        v39 = (char *)&v44 + 1;
        LOBYTE(v44) = 2 * v35;
        if ( !v35 )
          goto LABEL_89;
      }
      memcpy(v39, v34, v35);
LABEL_89:
      v39[v35] = 0;
LABEL_97:
      if ( (a1[6] & 1) != 0 )
        sub_6575460();
      v41 = (__int64)v45;
      *((_OWORD *)a1 + 3) = v44;
      a1[8] = v41;
      return (__int64 *)sub_6518CF4(a1, v33);
    }
  }
  v16 = (const void *)n[0];
  if ( n[0] )
  {
    v17 = n[1];
    if ( n[1] >= 0xFFFFFFFFFFFFFFF0LL )
      sub_67D2618();
    if ( n[1] >= 0x17 )
    {
      v19 = (n[1] + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v18 = (char *)sub_6575418();
      *((_QWORD *)&s2 + 1) = v17;
      v47 = v18;
      *(_QWORD *)&s2 = v19 | 1;
    }
    else
    {
      v18 = (char *)&s2 + 1;
      LOBYTE(s2) = 2 * LOBYTE(n[1]);
      if ( !n[1] )
        goto LABEL_35;
    }
    memcpy(v18, v16, v17);
LABEL_35:
    v18[v17] = 0;
    goto LABEL_36;
  }
  s2 = 0uLL;
  v47 = 0LL;
LABEL_36:
  if ( (a1[3] & 1) != 0 )
    sub_6575460();
  v20 = (__int64)v47;
  *(_OWORD *)(a1 + 3) = s2;
  a1[5] = v20;
  sub_67D3284((_DWORD)a1 + 48, "/");
  return (__int64 *)sub_6518CF4(a1, v21);
}


================================================================================
Function: sub_6518CF4 (0x6518CF4)
================================================================================

__int64 __fastcall sub_6518CF4(__int64 result)
{
  unsigned __int8 *v1; // x19
  unsigned __int64 v2; // x8
  bool v3; // zf
  unsigned __int64 v4; // x8
  int8x16_t *v5; // x9
  char *v6; // x11
  unsigned __int64 v7; // x10
  int8x16_t *v8; // x11
  int32x4_t v9; // q0
  unsigned __int64 v10; // x12
  uint32x4_t v11; // q1
  int8x16_t v12; // q2
  int8x16_t v13; // q3
  int16x8_t v14; // q5
  int16x8_t v15; // q6
  int16x8_t v16; // q7
  int16x8_t v17; // q16
  int8x16_t v18; // q4
  int32x4_t v19; // q0
  uint32x4_t v20; // q1
  int8x8_t *v21; // x13
  unsigned __int64 v22; // x10
  int16x8_t v23; // q4
  char *v24; // x8
  int v25; // w9
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x8
  int8x16_t *v28; // x9
  char *v29; // x11
  __int64 v30; // x10
  int8x16_t *v31; // x11
  int32x4_t v32; // q0
  unsigned __int64 v33; // x12
  uint32x4_t v34; // q1
  int8x16_t v35; // q2
  int8x16_t v36; // q3
  int16x8_t v37; // q5
  int16x8_t v38; // q6
  int16x8_t v39; // q7
  int16x8_t v40; // q16
  int8x16_t v41; // q4
  int32x4_t v42; // q0
  uint32x4_t v43; // q1
  int8x8_t *v44; // x13
  __int64 v45; // x10
  int16x8_t v46; // q4
  char *v47; // x8
  int v48; // w9
  char v49; // w8
  unsigned __int64 v50; // x10
  unsigned __int8 *v51; // x20
  unsigned __int64 v52; // x8
  int v53; // w9
  unsigned __int64 v54; // x10
  unsigned __int64 v55; // x11
  unsigned __int8 *v56; // x11
  unsigned __int8 *v57; // x22
  _BYTE *v58; // x1
  unsigned __int64 v59; // x10
  unsigned __int8 *v60; // x23
  unsigned __int8 *v61; // x8
  unsigned __int8 *v62; // x8
  int v63; // t1
  unsigned __int8 *v64; // x26
  unsigned __int8 *v65; // x0
  unsigned __int8 *v66; // x1
  __int64 v67; // x8
  __int64 v68; // x10
  unsigned __int8 *v69; // x9
  unsigned __int8 *v70; // x11
  signed __int64 v71; // x27
  signed __int64 v72; // x19
  unsigned __int64 v73; // x8
  unsigned __int64 v74; // x8
  unsigned __int64 v75; // x8

  v1 = (unsigned __int8 *)result;
  v2 = *(unsigned __int8 *)result;
  v3 = (v2 & 1) == 0;
  v4 = v2 >> 1;
  if ( v3 )
  {
    v5 = (int8x16_t *)(result + 1);
  }
  else
  {
    v4 = *(_QWORD *)(result + 8);
    v5 = *(int8x16_t **)(result + 16);
  }
  if ( !v4 )
    goto LABEL_21;
  v6 = (char *)v5;
  if ( v4 >= 8 )
  {
    if ( v4 < 0x20 )
    {
      v7 = 0LL;
      goto LABEL_12;
    }
    v7 = v4 & 0xFFFFFFFFFFFFFFE0LL;
    v8 = v5 + 1;
    v9.n128_u64[0] = 0x4000000040LL;
    v9.n128_u64[1] = 0x4000000040LL;
    v10 = v4 & 0xFFFFFFFFFFFFFFE0LL;
    v11.n128_u64[0] = 0x1A0000001ALL;
    v11.n128_u64[1] = 0x1A0000001ALL;
    v12.n128_u64[0] = 0x2020202020202020LL;
    v12.n128_u64[1] = 0x2020202020202020LL;
    do
    {
      v13 = v8[-1];
      v10 -= 32LL;
      v14 = vmovl_s8((int8x8_t)v13.n128_u64[0]);
      v15 = vmovl_high_s8(v13);
      v16 = vmovl_high_s8(*v8);
      v17 = vmovl_s8((int8x8_t)v8->n128_u64[0]);
      v18 = vbslq_s8(
              vuzp1q_s8(
                vuzp1q_s16(
                  vcgtq_u32(v11, vaddw_s16(v9, (int16x4_t)v17.n128_u64[0])),
                  vcgtq_u32(v11, vaddw_high_s16(v9, v17))),
                vuzp1q_s16(
                  vcgtq_u32(v11, vaddw_s16(v9, (int16x4_t)v16.n128_u64[0])),
                  vcgtq_u32(v11, vaddw_high_s16(v9, v16)))),
              vorrq_s8(*v8, v12),
              *v8);
      v8[-1] = vbslq_s8(
                 vuzp1q_s8(
                   vuzp1q_s16(
                     vcgtq_u32(v11, vaddw_s16(v9, (int16x4_t)v14.n128_u64[0])),
                     vcgtq_u32(v11, vaddw_high_s16(v9, v14))),
                   vuzp1q_s16(
                     vcgtq_u32(v11, vaddw_s16(v9, (int16x4_t)v15.n128_u64[0])),
                     vcgtq_u32(v11, vaddw_high_s16(v9, v15)))),
                 vorrq_s8(v13, v12),
                 v13);
      *v8 = v18;
      v8 += 2;
    }
    while ( v10 );
    if ( v4 == v7 )
      goto LABEL_21;
    if ( (v4 & 0x18) != 0 )
    {
LABEL_12:
      v19.n128_u64[0] = 0x4000000040LL;
      v19.n128_u64[1] = 0x4000000040LL;
      v6 = (char *)v5 + (v4 & 0xFFFFFFFFFFFFFFF8LL);
      v20.n128_u64[0] = 0x1A0000001ALL;
      v20.n128_u64[1] = 0x1A0000001ALL;
      v21 = (int8x8_t *)((char *)v5 + v7);
      v22 = v7 - (v4 & 0xFFFFFFFFFFFFFFF8LL);
      do
      {
        v22 += 8LL;
        v23 = vmovl_s8((int8x8_t)v21->n64_u64[0]);
        v21->n64_u64[0] = vbsl_s8(
                            vmovn_s16(
                              vuzp1q_s16(
                                vcgtq_u32(v20, vaddw_s16(v19, (int16x4_t)v23.n128_u64[0])),
                                vcgtq_u32(v20, vaddw_high_s16(v19, v23)))),
                            vorr_s8((int8x8_t)v21->n64_u64[0], (int8x8_t)0x2020202020202020LL),
                            (int8x8_t)v21->n64_u64[0]).n64_u64[0];
        ++v21;
      }
      while ( v22 );
      if ( v4 == (v4 & 0xFFFFFFFFFFFFFFF8LL) )
        goto LABEL_21;
      goto LABEL_17;
    }
    v6 = (char *)v5 + v7;
  }
LABEL_17:
  v24 = (char *)v5 + v4;
  do
  {
    v25 = *v6;
    if ( (unsigned int)(v25 - 65) < 0x1A )
      LOBYTE(v25) = v25 | 0x20;
    *v6++ = v25;
  }
  while ( v6 != v24 );
LABEL_21:
  v26 = *(unsigned __int8 *)(result + 24);
  v3 = (v26 & 1) == 0;
  v27 = v26 >> 1;
  if ( v3 )
  {
    v28 = (int8x16_t *)(result + 25);
  }
  else
  {
    v27 = *(_QWORD *)(result + 32);
    v28 = *(int8x16_t **)(result + 40);
  }
  if ( !v27 )
    goto LABEL_41;
  v29 = (char *)v28;
  if ( v27 >= 8 )
  {
    if ( v27 < 0x20 )
    {
      v30 = 0LL;
LABEL_32:
      v42.n128_u64[0] = 0x4000000040LL;
      v42.n128_u64[1] = 0x4000000040LL;
      v29 = (char *)v28 + (v27 & 0xFFFFFFFFFFFFFFF8LL);
      v43.n128_u64[0] = 0x1A0000001ALL;
      v43.n128_u64[1] = 0x1A0000001ALL;
      v44 = (int8x8_t *)((char *)v28 + v30);
      v45 = v30 - (v27 & 0xFFFFFFFFFFFFFFF8LL);
      do
      {
        v45 += 8LL;
        v46 = vmovl_s8((int8x8_t)v44->n64_u64[0]);
        v44->n64_u64[0] = vbsl_s8(
                            vmovn_s16(
                              vuzp1q_s16(
                                vcgtq_u32(v43, vaddw_s16(v42, (int16x4_t)v46.n128_u64[0])),
                                vcgtq_u32(v43, vaddw_high_s16(v42, v46)))),
                            vorr_s8((int8x8_t)v44->n64_u64[0], (int8x8_t)0x2020202020202020LL),
                            (int8x8_t)v44->n64_u64[0]).n64_u64[0];
        ++v44;
      }
      while ( v45 );
      if ( v27 == (v27 & 0xFFFFFFFFFFFFFFF8LL) )
        goto LABEL_41;
      goto LABEL_37;
    }
    v30 = v27 & 0xFFFFFFFFFFFFFFE0LL;
    v31 = v28 + 1;
    v32.n128_u64[0] = 0x4000000040LL;
    v32.n128_u64[1] = 0x4000000040LL;
    v33 = v27 & 0xFFFFFFFFFFFFFFE0LL;
    v34.n128_u64[0] = 0x1A0000001ALL;
    v34.n128_u64[1] = 0x1A0000001ALL;
    v35.n128_u64[0] = 0x2020202020202020LL;
    v35.n128_u64[1] = 0x2020202020202020LL;
    do
    {
      v36 = v31[-1];
      v33 -= 32LL;
      v37 = vmovl_s8((int8x8_t)v36.n128_u64[0]);
      v38 = vmovl_high_s8(v36);
      v39 = vmovl_high_s8(*v31);
      v40 = vmovl_s8((int8x8_t)v31->n128_u64[0]);
      v41 = vbslq_s8(
              vuzp1q_s8(
                vuzp1q_s16(
                  vcgtq_u32(v34, vaddw_s16(v32, (int16x4_t)v40.n128_u64[0])),
                  vcgtq_u32(v34, vaddw_high_s16(v32, v40))),
                vuzp1q_s16(
                  vcgtq_u32(v34, vaddw_s16(v32, (int16x4_t)v39.n128_u64[0])),
                  vcgtq_u32(v34, vaddw_high_s16(v32, v39)))),
              vorrq_s8(*v31, v35),
              *v31);
      v31[-1] = vbslq_s8(
                  vuzp1q_s8(
                    vuzp1q_s16(
                      vcgtq_u32(v34, vaddw_s16(v32, (int16x4_t)v37.n128_u64[0])),
                      vcgtq_u32(v34, vaddw_high_s16(v32, v37))),
                    vuzp1q_s16(
                      vcgtq_u32(v34, vaddw_s16(v32, (int16x4_t)v38.n128_u64[0])),
                      vcgtq_u32(v34, vaddw_high_s16(v32, v38)))),
                  vorrq_s8(v36, v35),
                  v36);
      *v31 = v41;
      v31 += 2;
    }
    while ( v33 );
    if ( v27 == v30 )
      goto LABEL_41;
    if ( (v27 & 0x18) != 0 )
      goto LABEL_32;
    v29 = (char *)v28 + v30;
  }
LABEL_37:
  v47 = (char *)v28 + v27;
  do
  {
    v48 = *v29;
    if ( (unsigned int)(v48 - 65) < 0x1A )
      LOBYTE(v48) = v48 | 0x20;
    *v29++ = v48;
  }
  while ( v29 != v47 );
LABEL_41:
  if ( byte_71CF7B0 && byte_71CC0C0 )
  {
    result = sub_6519634(result);
    if ( (result & 1) != 0
      && (result = sub_6519634(v1 + 24), (result & 1) != 0)
      && (result = sub_6519634(v1 + 48), (result & 1) != 0)
      && (result = sub_6519634(v1 + 72), (result & 1) != 0) )
    {
      result = sub_6519634(v1 + 96);
      v49 = result ^ 1;
    }
    else
    {
      v49 = 1;
    }
    v1[120] = v49 & 1;
  }
  v51 = v1 + 48;
  v50 = v1[48];
  v52 = *((_QWORD *)v1 + 7);
  v53 = v50 & 1;
  v54 = v50 >> 1;
  if ( v53 )
    v55 = *((_QWORD *)v1 + 7);
  else
    v55 = v54;
  if ( v55 )
  {
    v56 = (unsigned __int8 *)*((_QWORD *)v1 + 8);
    v57 = v1 + 49;
    if ( v53 )
      v58 = (_BYTE *)*((_QWORD *)v1 + 8);
    else
      v58 = v1 + 49;
    if ( *v58 != 47 )
    {
      sub_67D360C(v1 + 48);
      v59 = v1[48];
      v52 = *((_QWORD *)v1 + 7);
      v56 = (unsigned __int8 *)*((_QWORD *)v1 + 8);
      v53 = v59 & 1;
      v54 = v59 >> 1;
    }
    if ( v53 )
      v57 = v56;
    else
      v52 = v54;
    v60 = &v57[v52];
    v61 = &v57[v52];
    v63 = *(v61 - 1);
    v62 = v61 - 1;
    if ( v63 == 47 )
      v64 = v62;
    else
      v64 = v60;
    if ( v64 != v57 )
    {
      v65 = 0LL;
      v66 = 0LL;
      v67 = 0LL;
      while ( 1 )
      {
        v68 = 0LL;
        v69 = v64;
        do
          v70 = &v64[v68--];
        while ( *(v70 - 1) != 47 );
        v64 += v68;
        if ( v68 == -1 )
          goto LABEL_69;
        if ( -v68 == 3 )
        {
          if ( v64[1] == 46 && v69[v68 + 2] == 46 )
          {
            ++v67;
            if ( byte_71CF7B0 && byte_71CC0E0 )
              v1[121] = 1;
            goto LABEL_69;
          }
        }
        else if ( -v68 == 2 && v64[1] == 46 )
        {
          goto LABEL_69;
        }
        if ( v67 )
        {
          --v67;
LABEL_69:
          v65 = v64;
          if ( !v66 )
            v66 = v69;
          goto LABEL_71;
        }
        if ( v65 )
        {
          v71 = v65 - v66;
          memmove(v65, v66, v60 - v66);
          v67 = 0LL;
          v66 = 0LL;
          v65 = 0LL;
          v60 += v71;
        }
        else
        {
          v67 = 0LL;
        }
LABEL_71:
        if ( v64 == v57 )
        {
          if ( v65 )
          {
            v72 = v65 - v66;
            memmove(v65, v66, v60 - v66);
            v60 += v72;
          }
          break;
        }
      }
    }
    if ( v60 > v57 )
      return (__int64)sub_67D36F0(v51, v60 - v57, 0);
    return sub_67D3284((int)v51, "/");
  }
  v73 = *v1;
  if ( (v73 & 1) != 0 )
    v74 = *((_QWORD *)v1 + 1);
  else
    v74 = v73 >> 1;
  if ( v74 )
  {
    v75 = v1[24];
    if ( (v75 & 1) != 0 ? *((_QWORD *)v1 + 4) : v75 >> 1 )
      return sub_67D3284((int)v51, "/");
  }
  return result;
}


================================================================================
Function: sub_651925C (0x651925C)
================================================================================

__int64 *__usercall sub_651925C@<X0>(
        __int64 *__return_ptr a1@<X8>,
        void *src@<X0>,
        size_t n@<X1>,
        void *a4@<X2>,
        void *a5@<X4>,
        size_t a6@<X3>,
        size_t a7@<X5>,
        const void *a8@<X6>,
        size_t a9@<X7>,
        void *a10,
        size_t na)
{
  char *v19; // x28
  size_t v20; // x21
  __int64 v21; // x8
  char *v22; // x26
  __int64 v23; // x8
  char *v24; // x24
  __int64 v25; // x8
  char *v26; // x22
  __int64 v27; // x8
  char *v28; // x22
  __int64 v29; // x8
  __int128 v32; // [xsp+10h] [xbp-20h] BYREF
  char *v33; // [xsp+20h] [xbp-10h]

  *(_OWORD *)((char *)a1 + 106) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  if ( !src )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_11;
  }
  if ( n >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( n >= 0x17 )
  {
    v20 = (n + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v19 = (char *)sub_6575418();
    *((_QWORD *)&v32 + 1) = n;
    v33 = v19;
    *(_QWORD *)&v32 = v20 | 1;
    goto LABEL_8;
  }
  v19 = (char *)&v32 + 1;
  LOBYTE(v32) = 2 * n;
  if ( n )
LABEL_8:
    memcpy(v19, src, n);
  v19[n] = 0;
  if ( (*(_BYTE *)a1 & 1) != 0 )
    sub_6575460();
LABEL_11:
  v21 = (__int64)v33;
  *(_OWORD *)a1 = v32;
  a1[2] = v21;
  if ( !a4 )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_20;
  }
  if ( a6 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( a6 >= 0x17 )
  {
    v22 = (char *)sub_6575418();
    *((_QWORD *)&v32 + 1) = a6;
    v33 = v22;
    *(_QWORD *)&v32 = (a6 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v22 = (char *)&v32 + 1;
    LOBYTE(v32) = 2 * a6;
    if ( !a6 )
      goto LABEL_19;
  }
  memcpy(v22, a4, a6);
LABEL_19:
  v22[a6] = 0;
LABEL_20:
  if ( (a1[3] & 1) != 0 )
    sub_6575460();
  v23 = (__int64)v33;
  *(_OWORD *)(a1 + 3) = v32;
  a1[5] = v23;
  if ( !a5 )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_31;
  }
  if ( a7 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( a7 >= 0x17 )
  {
    v24 = (char *)sub_6575418();
    *((_QWORD *)&v32 + 1) = a7;
    v33 = v24;
    *(_QWORD *)&v32 = (a7 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v24 = (char *)&v32 + 1;
    LOBYTE(v32) = 2 * a7;
    if ( !a7 )
      goto LABEL_30;
  }
  memcpy(v24, a5, a7);
LABEL_30:
  v24[a7] = 0;
LABEL_31:
  if ( (a1[6] & 1) != 0 )
    sub_6575460();
  v25 = (__int64)v33;
  *((_OWORD *)a1 + 3) = v32;
  a1[8] = v25;
  if ( !a8 )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_42;
  }
  if ( a9 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( a9 >= 0x17 )
  {
    v26 = (char *)sub_6575418();
    *((_QWORD *)&v32 + 1) = a9;
    v33 = v26;
    *(_QWORD *)&v32 = (a9 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v26 = (char *)&v32 + 1;
    LOBYTE(v32) = 2 * a9;
    if ( !a9 )
      goto LABEL_41;
  }
  memcpy(v26, a8, a9);
LABEL_41:
  v26[a9] = 0;
LABEL_42:
  if ( (a1[9] & 1) != 0 )
    sub_6575460();
  v27 = (__int64)v33;
  *(_OWORD *)(a1 + 9) = v32;
  a1[11] = v27;
  if ( !a10 )
  {
    v32 = 0uLL;
    v33 = 0LL;
    goto LABEL_53;
  }
  if ( na >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( na >= 0x17 )
  {
    v28 = (char *)sub_6575418();
    *((_QWORD *)&v32 + 1) = na;
    v33 = v28;
    *(_QWORD *)&v32 = (na + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
  }
  else
  {
    v28 = (char *)&v32 + 1;
    LOBYTE(v32) = 2 * na;
    if ( !na )
      goto LABEL_52;
  }
  memcpy(v28, a10, na);
LABEL_52:
  v28[na] = 0;
LABEL_53:
  if ( (a1[12] & 1) != 0 )
    sub_6575460();
  v29 = (__int64)v33;
  *((_OWORD *)a1 + 6) = v32;
  a1[14] = v29;
  return (__int64 *)sub_6518CF4(a1, n);
}


================================================================================
Function: sub_6519634 (0x6519634)
================================================================================

__int64 __fastcall sub_6519634(unsigned __int8 *a1)
{
  unsigned __int64 v1; // x15
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x14
  unsigned __int64 v4; // x1
  unsigned __int64 v5; // x13
  unsigned __int8 *v6; // x15
  int v7; // w13
  unsigned __int8 *v8; // x2
  int v9; // w3
  int v10; // w17
  int v11; // w3
  int v12; // w2
  bool v13; // zf
  int v14; // w17
  unsigned __int8 *v15; // x15
  int v16; // w16
  unsigned __int8 *v17; // x15
  unsigned __int8 *v18; // x15
  unsigned __int8 *v19; // x14
  unsigned __int8 *v20; // x15
  int v21; // w14

  v1 = *a1;
  v2 = *((_QWORD *)a1 + 1);
  if ( (v1 & 1) == 0 )
    v2 = v1 >> 1;
  if ( v2 )
  {
    v3 = 0LL;
    v4 = 0LL;
    while ( 1 )
    {
      if ( (v1 & 1) != 0 )
        v6 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      else
        v6 = a1 + 1;
      v7 = v6[v3];
      if ( v7 == 37 )
      {
        v5 = v3 + 3;
        if ( v3 + 3 > v2 )
          return 0LL;
        v8 = &v6[v3 + 1];
        v9 = *v8;
        v10 = v9 - 48;
        if ( (unsigned int)(v9 - 48) > 9 )
        {
          v10 = (v9 | 0x20) - 87;
          if ( (v9 | 0x20u) - 97 > 5 )
            v10 = -1;
        }
        v11 = v8[1];
        v12 = v11 - 48;
        if ( (unsigned int)(v11 - 48) > 9 )
        {
          if ( (v11 | 0x20u) - 97 > 5 )
            v12 = -1;
          else
            v12 = (v11 | 0x20) - 87;
        }
        v13 = v12 == -1 || v10 == -1;
        v14 = v12 + 16 * v10;
        if ( v13 )
          v14 = -1;
        if ( v14 < 0 )
          return 0LL;
        if ( (byte_1703D90[(unsigned __int8)v14] & 1) != 0 )
        {
          v6[v4++] = v14;
          if ( v5 >= v2 )
            goto LABEL_42;
        }
        else
        {
          v6[v4] = 37;
          if ( (*a1 & 1) != 0 )
            v15 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
          else
            v15 = a1 + 1;
          v16 = (char)v15[v3 + 1];
          v17 = &v15[v4];
          if ( (unsigned int)(v16 - 97) < 0x1A )
            LOBYTE(v16) = v16 ^ 0x20;
          v17[1] = v16;
          if ( (*a1 & 1) != 0 )
            v18 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
          else
            v18 = a1 + 1;
          v19 = &v18[v3];
          v20 = &v18[v4];
          v4 += 3LL;
          v21 = (char)v19[2];
          if ( (unsigned int)(v21 - 97) < 0x1A )
            LOBYTE(v21) = v21 ^ 0x20;
          v20[2] = v21;
          if ( v5 >= v2 )
            goto LABEL_42;
        }
      }
      else
      {
        v6[v4++] = v7;
        v5 = v3 + 1;
        if ( v3 + 1 >= v2 )
          goto LABEL_42;
      }
      LOBYTE(v1) = *a1;
      v3 = v5;
    }
  }
  v4 = 0LL;
LABEL_42:
  sub_67D36F0(a1, v4, 0);
  return 1LL;
}


================================================================================
Function: sub_65197D4 (0x65197D4)
================================================================================

unsigned __int64 *__usercall sub_65197D4@<X0>(unsigned __int8 *a1@<X0>, unsigned __int64 *a2@<X8>)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x12
  unsigned __int8 *v5; // x24
  unsigned __int64 v6; // x13
  unsigned __int8 *v7; // x23
  unsigned __int64 v8; // x11
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x10
  unsigned __int8 *v13; // x22
  unsigned __int64 v14; // x13
  unsigned __int8 *v15; // x21
  unsigned __int64 v16; // x10
  unsigned __int64 v17; // x8
  unsigned __int64 v19; // x9
  unsigned __int64 v20; // x8
  size_t v21; // x2
  void *v22; // x1
  unsigned __int64 v23; // x8
  bool v24; // zf
  size_t v25; // x8
  void *v26; // x1
  size_t v27; // x2
  unsigned __int64 *result; // x0
  unsigned __int64 v29; // x10
  size_t v30; // x8
  int v31; // w9
  size_t v32; // x10
  size_t v33; // x11
  void *v34; // x11
  _BYTE *v35; // x12
  unsigned __int64 v36; // x10
  void *v37; // x1
  size_t v38; // x2
  unsigned __int64 v39; // x8
  unsigned __int64 v40; // x8
  unsigned __int64 v41; // x8
  unsigned __int64 v42; // x8
  unsigned __int64 v43; // x8
  bool v44; // zf
  size_t v45; // x8
  void *v46; // x1
  size_t v47; // x2
  unsigned __int64 v48; // x8
  unsigned __int64 v49; // x8
  unsigned __int64 v50; // x8
  bool v51; // zf
  size_t v52; // x8
  void *v53; // x1
  size_t v54; // x2

  v3 = *a1;
  v5 = a1 + 24;
  v4 = a1[24];
  v7 = a1 + 48;
  v6 = a1[48];
  v8 = *((_QWORD *)a1 + 7);
  if ( (v3 & 1) != 0 )
    v9 = *((_QWORD *)a1 + 1);
  else
    v9 = v3 >> 1;
  v10 = v4 >> 1;
  if ( (v4 & 1) != 0 )
    v10 = *((_QWORD *)a1 + 4);
  v11 = v9 + v10;
  v13 = a1 + 72;
  v12 = a1[72];
  if ( (v6 & 1) == 0 )
    v8 = v6 >> 1;
  v15 = a1 + 96;
  v14 = a1[96];
  if ( (v12 & 1) != 0 )
    v16 = *((_QWORD *)a1 + 10);
  else
    v16 = v12 >> 1;
  v17 = v11 + v8;
  if ( (v14 & 1) != 0 )
    v19 = *((_QWORD *)a1 + 13);
  else
    v19 = v14 >> 1;
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  sub_658A084(a2, v17 + v16 + v19 + 6);
  v20 = *a1;
  if ( (v20 & 1) != 0 )
    v21 = *((_QWORD *)a1 + 1);
  else
    v21 = v20 >> 1;
  if ( v21 )
  {
    if ( (v20 & 1) != 0 )
      v22 = (void *)*((_QWORD *)a1 + 2);
    else
      v22 = a1 + 1;
    sub_6588400(a2, v22, v21);
    sub_67D352C(a2, "://");
  }
  v23 = a1[24];
  v24 = (v23 & 1) == 0;
  v25 = v23 >> 1;
  if ( v24 )
    v26 = v5 + 1;
  else
    v26 = (void *)*((_QWORD *)a1 + 5);
  if ( v24 )
    v27 = v25;
  else
    v27 = *((_QWORD *)a1 + 4);
  result = sub_6588400(a2, v26, v27);
  v29 = a1[48];
  v30 = *((_QWORD *)a1 + 7);
  v31 = v29 & 1;
  v32 = v29 >> 1;
  if ( v31 )
    v33 = *((_QWORD *)a1 + 7);
  else
    v33 = v32;
  if ( v33 )
  {
    v34 = (void *)*((_QWORD *)a1 + 8);
    if ( v31 )
      v35 = (_BYTE *)*((_QWORD *)a1 + 8);
    else
      v35 = v7 + 1;
    if ( *v35 != 47 )
    {
      sub_6589DEC(a2, 47LL);
      v36 = a1[48];
      v30 = *((_QWORD *)a1 + 7);
      v34 = (void *)*((_QWORD *)a1 + 8);
      v31 = v36 & 1;
      v32 = v36 >> 1;
    }
    if ( v31 )
      v37 = v34;
    else
      v37 = v7 + 1;
    if ( v31 )
      v38 = v30;
    else
      v38 = v32;
    result = sub_6588400(a2, v37, v38);
  }
  else
  {
    v39 = a1[24];
    if ( (v39 & 1) != 0 )
      v40 = *((_QWORD *)a1 + 4);
    else
      v40 = v39 >> 1;
    if ( v40 )
      result = (unsigned __int64 *)sub_6589DEC(a2, 47LL);
  }
  v41 = a1[72];
  if ( (v41 & 1) != 0 )
    v42 = *((_QWORD *)a1 + 10);
  else
    v42 = v41 >> 1;
  if ( v42 )
  {
    sub_6589DEC(a2, 63LL);
    v43 = a1[72];
    v44 = (v43 & 1) == 0;
    v45 = v43 >> 1;
    if ( v44 )
      v46 = v13 + 1;
    else
      v46 = (void *)*((_QWORD *)a1 + 11);
    if ( v44 )
      v47 = v45;
    else
      v47 = *((_QWORD *)a1 + 10);
    result = sub_6588400(a2, v46, v47);
  }
  v48 = a1[96];
  if ( (v48 & 1) != 0 )
    v49 = *((_QWORD *)a1 + 13);
  else
    v49 = v48 >> 1;
  if ( v49 )
  {
    sub_6589DEC(a2, 35LL);
    v50 = a1[96];
    v51 = (v50 & 1) == 0;
    v52 = v50 >> 1;
    if ( v51 )
      v53 = v15 + 1;
    else
      v53 = (void *)*((_QWORD *)a1 + 14);
    if ( v51 )
      v54 = v52;
    else
      v54 = *((_QWORD *)a1 + 13);
    return sub_6588400(a2, v53, v54);
  }
  return result;
}


================================================================================
Function: sub_6519A28 (0x6519A28)
================================================================================

bool __fastcall sub_6519A28(unsigned __int8 *a1)
{
  bool v2; // zf
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x9
  unsigned __int8 *v5; // x8
  unsigned __int8 *v6; // x8
  unsigned __int64 v7; // x9
  _BOOL8 result; // x0
  int v9; // t1
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x9
  unsigned __int8 *v12; // x8
  unsigned __int8 *v13; // x8
  unsigned __int64 v14; // x9
  int v15; // t1
  unsigned __int64 v16; // x10
  unsigned __int64 v17; // x8
  unsigned __int8 *v18; // x9
  int v19; // t1
  unsigned __int64 v20; // x10
  unsigned __int8 *v21; // x9
  int v22; // t1

  if ( byte_71CF7B0 )
    v2 = byte_71CC0C0 == 0;
  else
    v2 = 1;
  if ( v2 )
  {
    v3 = *a1;
    v4 = *((_QWORD *)a1 + 1);
    if ( (v3 & 1) == 0 )
      v4 = v3 >> 1;
    if ( v4 )
    {
      v5 = (v3 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a1 + 2) : a1 + 1;
      if ( ((char)*v5 & 0xFFFFFFDF) - 91 >= 0xFFFFFFE6 && byte_1703D90[*v5] < 0 )
      {
        v6 = v5 + 1;
        v7 = v4 - 1;
        result = 0LL;
        while ( v7 )
        {
          v9 = *v6++;
          --v7;
          if ( (byte_1703D90[v9] & 0x80000000) == 0 )
            return result;
        }
        if ( (sub_6519CF0(a1) & 1) != 0 )
        {
          v16 = a1[48];
          v17 = *((_QWORD *)a1 + 7);
          if ( (v16 & 1) == 0 )
            v17 = v16 >> 1;
          if ( v17 )
          {
            if ( (v16 & 1) != 0 )
              v18 = (unsigned __int8 *)*((_QWORD *)a1 + 8);
            else
              v18 = a1 + 49;
            while ( (byte_1703D90[*v18] & 0x37) != 0 )
            {
              if ( (byte_1703D90[*v18] & 2) != 0 )
              {
                if ( v17 < 3 )
                  return v17 == 0;
                v19 = v18[2];
                v18 += 2;
                if ( ((unsigned __int8)byte_1703D90[*(v18 - 1)] & (unsigned __int8)byte_1703D90[v19] & 8) == 0 )
                {
LABEL_46:
                  v17 = 1LL;
                  return v17 == 0;
                }
                v17 -= 2LL;
              }
              ++v18;
              if ( !--v17 )
                return v17 == 0;
            }
            return v17 == 0;
          }
        }
      }
    }
  }
  else if ( !a1[120] )
  {
    v10 = *a1;
    v11 = *((_QWORD *)a1 + 1);
    if ( (v10 & 1) == 0 )
      v11 = v10 >> 1;
    if ( v11 )
    {
      v12 = (v10 & 1) != 0 ? (unsigned __int8 *)*((_QWORD *)a1 + 2) : a1 + 1;
      if ( ((char)*v12 & 0xFFFFFFDF) - 91 >= 0xFFFFFFE6 && byte_1703D90[*v12] < 0 )
      {
        v13 = v12 + 1;
        v14 = v11 - 1;
        result = 0LL;
        while ( v14 )
        {
          v15 = *v13++;
          --v14;
          if ( (byte_1703D90[v15] & 0x80000000) == 0 )
            return result;
        }
        if ( (sub_6519CF0(a1) & 1) != 0 )
        {
          v20 = a1[48];
          v17 = *((_QWORD *)a1 + 7);
          if ( (v20 & 1) == 0 )
            v17 = v20 >> 1;
          if ( v17 )
          {
            if ( (v20 & 1) != 0 )
              v21 = (unsigned __int8 *)*((_QWORD *)a1 + 8);
            else
              v21 = a1 + 49;
            while ( (byte_1703D90[*v21] & 0x37) != 0 )
            {
              if ( (byte_1703D90[*v21] & 2) != 0 )
              {
                if ( v17 < 3 )
                  return v17 == 0;
                v22 = v21[2];
                v21 += 2;
                if ( ((unsigned __int8)byte_1703D90[*(v21 - 1)] & (unsigned __int8)byte_1703D90[v22] & 8) == 0 )
                  goto LABEL_46;
                v17 -= 2LL;
              }
              ++v21;
              if ( !--v17 )
                return v17 == 0;
            }
            return v17 == 0;
          }
        }
      }
    }
  }
  return 0LL;
}


================================================================================
Function: sub_6519CF0 (0x6519CF0)
================================================================================

bool __fastcall sub_6519CF0(__int64 a1)
{
  unsigned __int64 v1; // x9
  unsigned __int64 v2; // x10
  unsigned __int64 v3; // x11
  unsigned __int8 *v4; // x8
  unsigned __int64 v6; // x9
  bool v7; // w12
  __int64 v8; // x11
  unsigned __int64 v9; // x9
  _BYTE *i; // x8
  unsigned int v11; // w12
  char v13; // w11
  int v14; // t1
  unsigned int v15; // t1

  v1 = *(unsigned __int8 *)(a1 + 24);
  v2 = *(_QWORD *)(a1 + 32);
  if ( (v1 & 1) == 0 )
    v2 = v1 >> 1;
  if ( !v2 )
    return 0LL;
  v3 = v2 - 1;
  if ( (v1 & 1) != 0 )
    v4 = *(unsigned __int8 **)(a1 + 40);
  else
    v4 = (unsigned __int8 *)(a1 + 25);
  if ( v2 == 1 || v2 + 4 <= v3 )
    goto LABEL_30;
  if ( (unsigned int)v4[v3] - 48 > 9 )
  {
    v7 = 0;
    v6 = v2 - 1;
  }
  else
  {
    v6 = v2 - 2;
    v7 = v2 == 2;
    if ( v2 != 2 && v2 + 3 > v3 )
    {
      if ( (unsigned int)v4[v6] - 48 > 9 )
        goto LABEL_28;
      v6 = v2 - 3;
      v7 = v2 == 3;
      if ( v2 != 3 && v2 + 2 > v3 )
      {
        if ( (unsigned int)v4[v6] - 48 > 9 )
          goto LABEL_28;
        v6 = v2 - 4;
        v7 = v2 == 4;
        if ( v2 != 4 && v2 + 1 > v3 )
        {
          if ( (unsigned int)v4[v6] - 48 > 9 )
            goto LABEL_28;
          v6 = v2 - 5;
          v7 = v2 == 5;
          if ( v2 != 5 )
          {
            if ( (unsigned int)v4[v6] - 48 <= 9 )
            {
              v6 = v2 - 6;
              if ( v2 == 6 )
                goto LABEL_30;
            }
            goto LABEL_28;
          }
        }
      }
    }
  }
  if ( v7 )
  {
LABEL_30:
    v6 = v2;
    goto LABEL_31;
  }
LABEL_28:
  if ( v6 == v3 || v4[v6] != 58 )
    goto LABEL_30;
LABEL_31:
  v8 = *v4;
  if ( v8 != 91 || v4[v6 - 1] != 93 )
  {
    if ( v6 )
    {
      while ( 1 )
      {
        v13 = byte_1703D90[v8];
        if ( (v13 & 7) == 0 )
          break;
        if ( (v13 & 2) != 0 )
        {
          if ( v6 < 3 )
            return 0LL;
          v14 = v4[2];
          v4 += 2;
          if ( ((unsigned __int8)byte_1703D90[*(v4 - 1)] & (unsigned __int8)byte_1703D90[v14] & 8) == 0 )
            return 0LL;
          v6 -= 2LL;
        }
        if ( !--v6 )
          return 1LL;
        v15 = *++v4;
        v8 = v15;
      }
    }
    return 0LL;
  }
  v9 = v6 - 2;
  for ( i = v4 + 1; ; ++i )
  {
    if ( (unsigned __int8)(*i - 48) >= 0xAu )
    {
      v11 = (unsigned __int8)*i - 46;
      if ( v11 > 0x38 || ((1LL << v11) & 0x1F8000001F81001LL) == 0 )
        break;
    }
    --v9;
  }
  return v9 == 0;
}


================================================================================
Function: sub_6519F80 (0x6519F80)
================================================================================

bool __fastcall sub_6519F80(unsigned __int8 *a1)
{
  unsigned __int64 v1; // x10
  unsigned __int64 v3; // x8
  int v4; // w9
  unsigned __int64 v5; // x10
  unsigned __int64 v6; // x11
  unsigned __int64 v7; // x10

  v1 = *a1;
  v3 = *((_QWORD *)a1 + 1);
  v4 = v1 & 1;
  v5 = v1 >> 1;
  if ( v4 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v5;
  if ( v6 == 4 )
  {
    if ( !(unsigned int)sub_67D3100(a1, 0LL, 0xFFFFFFFFFFFFFFFFLL, "http", 4uLL) )
      return 1LL;
    v7 = *a1;
    v3 = *((_QWORD *)a1 + 1);
    v4 = v7 & 1;
    v5 = v7 >> 1;
  }
  if ( !v4 )
    v3 = v5;
  return v3 == 5 && (unsigned int)sub_67D3100(a1, 0LL, 0xFFFFFFFFFFFFFFFFLL, "https", 5uLL) == 0;
}


================================================================================
Function: sub_651A034 (0x651A034)
================================================================================

bool __fastcall sub_651A034(unsigned __int8 *a1)
{
  unsigned __int64 v1; // x10
  unsigned __int64 v3; // x8
  int v4; // w9
  unsigned __int64 v5; // x10
  unsigned __int64 v6; // x11
  unsigned __int64 v7; // x10

  v1 = *a1;
  v3 = *((_QWORD *)a1 + 1);
  v4 = v1 & 1;
  v5 = v1 >> 1;
  if ( v4 )
    v6 = *((_QWORD *)a1 + 1);
  else
    v6 = v5;
  if ( v6 == 2 )
  {
    if ( !(unsigned int)sub_67D3100(a1, 0LL, 0xFFFFFFFFFFFFFFFFLL, "ws", 2uLL) )
      return 1LL;
    v7 = *a1;
    v3 = *((_QWORD *)a1 + 1);
    v4 = v7 & 1;
    v5 = v7 >> 1;
  }
  if ( !v4 )
    v3 = v5;
  return v3 == 3 && (unsigned int)sub_67D3100(a1, 0LL, 0xFFFFFFFFFFFFFFFFLL, "wss", 3uLL) == 0;
}


================================================================================
Function: sub_651A108 (0x651A108)
================================================================================

bool __fastcall sub_651A108(__int64 a1, __int64 a2)
{
  __int64 v3; // x21
  __int64 v4; // x22
  unsigned __int8 *v5; // x1
  unsigned __int8 *v6; // x19
  __int64 v7; // x9
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x8
  unsigned __int8 *v11; // x8
  int v12; // w10
  unsigned __int8 *v13; // x9
  int v14; // w10
  unsigned __int8 *v15; // x9
  _BOOL8 result; // x0
  int v17; // t1
  __int64 v18; // [xsp+8h] [xbp-18h] BYREF
  __int64 v19; // [xsp+10h] [xbp-10h] BYREF

  v3 = a1 + 24;
  v19 = a2;
  sub_67C4788(&v18);
  v4 = sub_651A25C(v3, &v19, &v18);
  v6 = v5;
  sub_67C482C(&v18);
  v7 = *(_QWORD *)(a1 + 40);
  v8 = *(unsigned __int8 *)(a1 + 24);
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  if ( v9 )
    v7 = v3 + 1;
  if ( !v9 )
    v10 = *(_QWORD *)(a1 + 32);
  v11 = (unsigned __int8 *)(v7 + v10);
  if ( v11 == (unsigned __int8 *)v4 || v7 != v4 && *(_BYTE *)(v4 - 1) != 46 )
    return 0LL;
  if ( v11 == v6 )
    return 1LL;
  v12 = *v6;
  if ( v12 == 46 )
  {
    v13 = v6 + 1;
    if ( v6 + 1 != v11 )
    {
      v14 = *v13;
      if ( v14 != 46 )
        goto LABEL_15;
      v13 = v6 + 2;
      if ( v6 + 2 != v11 )
      {
        v14 = *v13;
LABEL_15:
        if ( v14 == 58 )
          goto LABEL_16;
        return 0LL;
      }
    }
    return 1LL;
  }
  v13 = v6;
  if ( v12 != 58 )
    return 0LL;
LABEL_16:
  v15 = v13 + 1;
  do
  {
    result = v15 == v11;
    if ( v15 == v11 )
      break;
    v17 = *v15++;
  }
  while ( (unsigned int)(v17 - 58) > 0xFFFFFFF5 );
  return result;
}


================================================================================
Function: sub_651A25C (0x651A25C)
================================================================================

unsigned __int8 *__fastcall sub_651A25C(unsigned __int8 *a1, const char **a2, __int64 *a3)
{
  const char *v5; // x21
  const char *v6; // x22
  __int64 v7; // x2
  unsigned __int64 v8; // x8
  bool v9; // zf
  unsigned __int64 v10; // x12
  const char *v11; // x8
  unsigned __int8 *v12; // x24
  unsigned __int64 v13; // x9
  unsigned __int8 *v14; // x9
  __int64 v15; // x27
  unsigned __int8 *v16; // x25
  unsigned __int8 *v17; // x20
  const char *v18; // x28
  __int64 v19; // x26
  unsigned int v20; // w22
  __int64 *v21; // x0
  char v22; // w0
  unsigned int v23; // w23
  __int64 v24; // x2
  __int64 *v25; // x0
  __int64 v26; // x9
  const char *v27; // x10
  unsigned __int8 *v29; // [xsp+8h] [xbp-38h]
  __int64 v30; // [xsp+10h] [xbp-30h] BYREF
  const char *v31; // [xsp+18h] [xbp-28h]
  const char *v32; // [xsp+20h] [xbp-20h]
  __int64 v33; // [xsp+28h] [xbp-18h] BYREF
  __int64 v34; // [xsp+30h] [xbp-10h] BYREF

  sub_67C4814(&v30, a3);
  v5 = *a2;
  v6 = &v5[__strlen_chk(*a2, 0xFFFFFFFFFFFFFFFFLL)];
  sub_67C4814(&v34, &v30);
  v31 = v5;
  v32 = v6;
  sub_67C4814(&v33, &v34);
  sub_67C482C(&v34);
  v8 = *a1;
  v9 = (v8 & 1) == 0;
  v10 = v8 >> 1;
  v11 = v32;
  if ( v9 )
    v12 = a1 + 1;
  else
    v12 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( v9 )
    v13 = v10;
  else
    v13 = *((_QWORD *)a1 + 1);
  v14 = &v12[v13];
  if ( v31 != v32 )
  {
    v15 = 0LL;
    v16 = v14;
    v29 = v14;
    while ( v16 != v12 )
    {
      v17 = v16--;
      v18 = v31;
      if ( v16 != v14 && v31 != v11 )
      {
        v19 = 0LL;
        while ( 1 )
        {
          v20 = v17[v19 - 1];
          v21 = sub_67C4BB8(&v33, (__int64)&qword_795CE58, v7);
          v22 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(*v21 + 24))(v21, v20);
          v23 = (unsigned __int8)v18[v19];
          LOBYTE(v20) = v22;
          v25 = sub_67C4BB8(&v33, (__int64)&qword_795CE58, v24);
          if ( (unsigned __int8)v20 != (*(unsigned __int8 (__fastcall **)(__int64 *, _QWORD))(*v25 + 24))(v25, v23) )
            break;
          v11 = v32;
          v26 = v19 + 1;
          if ( v15 != v19 )
          {
            v27 = &v18[v19++];
            if ( v27 + 1 != v32 )
              continue;
          }
          v18 += v26;
          goto LABEL_19;
        }
        v11 = v32;
        v18 += v19;
LABEL_19:
        v14 = v29;
      }
      ++v15;
      if ( v18 == v11 )
        goto LABEL_21;
    }
  }
  v16 = v14;
LABEL_21:
  sub_67C482C(&v33);
  sub_67C482C(&v30);
  return v16;
}


================================================================================
Function: sub_651A89C (0x651A89C)
================================================================================

_QWORD *__fastcall sub_651A89C(_QWORD *result, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 *v4; // x19
  _QWORD *v5; // x20
  unsigned __int64 v6; // x23
  unsigned __int64 v7; // x8
  unsigned __int8 *v8; // x11
  unsigned int v9; // w12
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x1
  char v13; // w9
  char s[4]; // [xsp+4h] [xbp-Ch] BYREF

  v4 = a2;
  v5 = result;
  v6 = (unsigned __int64)&a2[a3];
  v7 = a3;
  strcpy(s, "%00");
  if ( a3 > 4096 )
  {
    v8 = a2;
    v7 = a3;
    do
    {
      v9 = *v8;
      if ( v9 < 0x30 || v9 - 58 <= 0x26 && ((1LL << ((unsigned __int8)v9 - 58)) & 0x7E0000007FLL) != 0 || v9 >= 0x7B )
        v7 += 2LL;
      ++v8;
    }
    while ( (unsigned __int64)v8 < v6 );
  }
  v10 = *(unsigned __int8 *)result;
  if ( (v10 & 1) != 0 )
    v11 = result[1];
  else
    v11 = v10 >> 1;
  if ( v7 < ~v11 )
  {
    result = (_QWORD *)sub_658A084(result, v11 + v7);
    if ( a3 >= 1 )
    {
      do
      {
        v12 = *v4;
        if ( v12 < 0x30
          || (unsigned int)(v12 - 58) <= 0x26 && ((1LL << ((unsigned __int8)v12 - 58)) & 0x7E0000007FLL) != 0
          || (unsigned int)v12 >= 0x7B )
        {
          v13 = a0123456789abcd[v12 & 0xF];
          s[1] = a0123456789abcd[v12 >> 4];
          s[2] = v13;
          result = sub_67D352C(v5, s);
        }
        else
        {
          result = (_QWORD *)sub_6589DEC(v5, v12);
        }
        ++v4;
      }
      while ( (unsigned __int64)v4 < v6 );
    }
  }
  return result;
}


================================================================================
Function: sub_651ACA4 (0x651ACA4)
================================================================================

__int64 __fastcall sub_651ACA4(unsigned __int8 *a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x21
  unsigned __int64 *v9; // x0
  int v10; // w1
  unsigned __int8 *v11; // x23
  int v12; // w9
  int v13; // w8
  int v14; // w10
  int v15; // w9
  bool v16; // zf
  int v17; // w8
  int v18; // w1

  v3 = *(unsigned __int8 *)a3;
  if ( (v3 & 1) != 0 )
    v7 = a3[1];
  else
    v7 = v3 >> 1;
  sub_658A084(a3, v7 + a2);
  if ( a2 < 1 )
    return 1LL;
  v8 = (unsigned __int64)&a1[a2];
  while ( 1 )
  {
    while ( 1 )
    {
      v10 = *a1;
      if ( v10 == 43 )
      {
        v9 = a3;
        LOBYTE(v10) = 32;
        goto LABEL_7;
      }
      if ( v10 == 37 )
        break;
      v9 = a3;
LABEL_7:
      sub_6589DEC(v9, v10);
      if ( (unsigned __int64)++a1 >= v8 )
        return 1LL;
    }
    v11 = a1 + 3;
    if ( (unsigned __int64)(a1 + 3) > v8 )
      return 0LL;
    v12 = a1[1];
    v13 = v12 - 48;
    if ( (unsigned int)(v12 - 48) > 9 )
    {
      if ( (v12 | 0x20u) - 97 > 5 )
        v13 = -1;
      else
        v13 = (v12 | 0x20) - 87;
    }
    v14 = a1[2];
    v15 = v14 - 48;
    if ( (unsigned int)(v14 - 48) > 9 )
    {
      if ( (v14 | 0x20u) - 97 > 5 )
        v15 = -1;
      else
        v15 = (v14 | 0x20) - 87;
    }
    v16 = v15 == -1 || v13 == -1;
    v17 = v15 + 16 * v13;
    v18 = v16 ? -1 : v17;
    if ( v18 < 0 )
      return 0LL;
    sub_6589DEC(a3, v18);
    a1 += 3;
    if ( (unsigned __int64)v11 >= v8 )
      return 1LL;
  }
}


================================================================================
Function: sub_651ADD8 (0x651ADD8)
================================================================================

__int64 __usercall sub_651ADD8@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  return sub_651AE1C(a2, a1 + 72);
}


================================================================================
Function: sub_651AE1C (0x651AE1C)
================================================================================

_BYTE *__fastcall sub_651AE1C(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int64 v3; // x8
  bool v4; // zf
  __int64 v5; // x8
  _BYTE *result; // x0
  _BYTE *v7; // x22
  _BYTE *v8; // x23
  __int64 v9; // x24
  _BOOL4 v10; // w26
  _BYTE *v11; // x25
  _BYTE *v12; // x10
  __int64 v13; // x9
  _BYTE *v14; // x8
  __int64 v15; // x8
  _BYTE *v16; // x8
  _BYTE *v17; // x20
  unsigned __int64 v18; // x8
  __int128 v19; // q0
  __int64 v20; // x9
  __int128 v21; // [xsp+8h] [xbp-38h] BYREF
  __int64 v22; // [xsp+18h] [xbp-28h]
  __int128 v23; // [xsp+20h] [xbp-20h] BYREF
  __int64 v24; // [xsp+30h] [xbp-10h]

  v3 = *a2;
  v4 = (v3 & 1) == 0;
  v5 = v3 >> 1;
  if ( v4 )
    result = a2 + 1;
  else
    result = (_BYTE *)*((_QWORD *)a2 + 2);
  if ( !v4 )
    v5 = *((_QWORD *)a2 + 1);
  if ( v5 >= 1 )
  {
    v7 = &result[v5];
    v8 = &result[v5];
    v9 = (__int64)&result[v5 - 1];
    do
    {
      if ( result >= v8 )
      {
        v10 = 0;
      }
      else
      {
        if ( *result != 38 )
        {
          v12 = result + 1;
          v13 = v9 - (_QWORD)result;
          while ( 1 )
          {
            v14 = v12;
            if ( !v13 )
              break;
            --v13;
            ++v12;
            if ( *v14 == 38 )
            {
              v11 = v14;
              goto LABEL_22;
            }
          }
          v11 = v7;
LABEL_22:
          v10 = v14 < v8;
          if ( result < v11 )
          {
            v15 = 0LL;
            do
            {
              if ( result[v15] == 61 )
              {
                v16 = &result[v15];
                v17 = v16 + 1;
                if ( result == v16 )
                  goto LABEL_27;
                goto LABEL_29;
              }
              ++v15;
            }
            while ( v11 - result != v15 );
            v16 = v11;
            v17 = v11;
            if ( result == v11 )
            {
LABEL_27:
              v23 = 0uLL;
              v24 = 0LL;
              goto LABEL_30;
            }
LABEL_29:
            v23 = 0uLL;
            v24 = 0LL;
            sub_651ACA4(result, v16 - result, &v23);
LABEL_30:
            v21 = 0uLL;
            v22 = 0LL;
            if ( v17 != v11 )
              sub_651ACA4(v17, v11 - v17, &v21);
            v18 = *(_QWORD *)(a1 + 8);
            if ( v18 >= *(_QWORD *)(a1 + 16) )
            {
              sub_61EBEF8(a1, &v23, &v21);
              if ( (v21 & 1) != 0 )
                sub_6575460();
            }
            else
            {
              v19 = v23;
              *(_QWORD *)(v18 + 16) = v24;
              *(_OWORD *)v18 = v19;
              v24 = 0LL;
              v20 = v22;
              v23 = 0uLL;
              *(_OWORD *)(v18 + 24) = v21;
              *(_QWORD *)(v18 + 40) = v20;
              *(_QWORD *)(a1 + 8) = v18 + 48;
            }
            if ( (v23 & 1) != 0 )
              sub_6575460();
          }
          goto LABEL_8;
        }
        v10 = 1;
      }
      v11 = result;
LABEL_8:
      if ( v10 )
        result = v11 + 1;
      else
        result = v8;
    }
    while ( result < v8 );
  }
  return result;
}


================================================================================
Function: sub_651CCD8 (0x651CCD8)
================================================================================

_QWORD *__fastcall sub_651CCD8(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6)
{
  __int64 v11; // x19
  _QWORD *result; // x0
  _QWORD *v13; // x22
  _QWORD *i; // x23
  bool v15; // zf
  __int64 v16; // x21
  __int64 v17; // x0
  __int64 v18; // x8
  __int64 v19; // x21
  __int64 (__fastcall *v20)(); // [xsp+8h] [xbp-28h] BYREF
  __int64 v21; // [xsp+10h] [xbp-20h] BYREF
  int v22; // [xsp+1Ch] [xbp-14h] BYREF
  __int64 v23; // [xsp+20h] [xbp-10h] BYREF

  v23 = a2;
  v22 = a4;
  *(_QWORD *)(a1 + 8) = a5;
  v11 = a1 + 8;
  *(_QWORD *)a1 = off_6BACDE8;
  result = (_QWORD *)sub_6575418();
  result[2] = 0LL;
  result[3] = a5;
  *(_QWORD *)(a1 + 24) = 0LL;
  *result = off_6BACED8;
  result[1] = 0LL;
  *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = a6;
  *(_DWORD *)(a1 + 56) = a4;
  if ( a3 )
  {
    result = (_QWORD *)sub_651DD88(a1 + 24, a3);
    v13 = *(_QWORD **)(a1 + 24);
    for ( i = *(_QWORD **)(a1 + 32); v13 != i; result = (_QWORD *)sub_67D6798(&v21) )
    {
      if ( byte_71CF7B0 )
        v15 = byte_7286120 == 0;
      else
        v15 = 1;
      if ( v15 )
      {
        v17 = sub_6575418();
        *(_QWORD *)(v17 + 8) = 0LL;
        *(_QWORD *)(v17 + 16) = 0LL;
        *(_QWORD *)v17 = off_6BACF78;
        *(_OWORD *)(v17 + 40) = 0u;
        *(_OWORD *)(v17 + 56) = 0u;
        *(_OWORD *)(v17 + 72) = 0u;
        *(_OWORD *)(v17 + 88) = 0u;
        *(_OWORD *)(v17 + 100) = 0u;
        *(_OWORD *)(v17 + 24) = 0u;
        v18 = v17 + 24;
      }
      else
      {
        v16 = sub_678E980();
        v17 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v16 + 16LL))(v16, 128LL, 8LL);
        *(_QWORD *)v17 = off_6BACF28;
        *(_QWORD *)(v17 + 8) = 0LL;
        *(_QWORD *)(v17 + 16) = 0LL;
        *(_QWORD *)(v17 + 24) = v16;
        *(_OWORD *)(v17 + 48) = 0u;
        *(_OWORD *)(v17 + 64) = 0u;
        *(_OWORD *)(v17 + 80) = 0u;
        *(_OWORD *)(v17 + 96) = 0u;
        *(_OWORD *)(v17 + 108) = 0u;
        *(_OWORD *)(v17 + 32) = 0u;
        v18 = v17 + 32;
      }
      v19 = v13[2];
      v13[1] = v18;
      v13[2] = v17;
      if ( v19 && !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v19 + 8)) )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16LL))(v19);
        sub_67D18A4((unsigned __int64 *)v19);
      }
      v20 = sub_651CF2C;
      sub_651D198(&v21, &v20, &v23, v11, v13 + 1, &v22);
      if ( *v13 )
        sub_67EB9A0();
      *v13 = v21;
      v13 += 3;
      v21 = 0LL;
    }
  }
  return result;
}


================================================================================
Function: sub_651D198 (0x651D198)
================================================================================

__int64 __fastcall sub_651D198(pthread_t *a1, __int64 *a2, __int64 *a3, __int64 *a4, _QWORD *a5, int *a6)
{
  __int64 v12; // x22
  __int64 v13; // x0
  __int64 v14; // x24
  __int64 v15; // x28
  _QWORD *v16; // x19
  __int64 v17; // x26
  __int64 v18; // x25
  __int64 v19; // x23
  __int64 v20; // x27
  _QWORD *v21; // t2
  int v22; // w8
  __int64 result; // x0

  v12 = sub_6575418();
  sub_67D6ACC();
  v13 = sub_6575418();
  v15 = *a4;
  v14 = a4[1];
  v16 = (_QWORD *)v13;
  v17 = *a2;
  v18 = *a3;
  if ( v14 )
    sub_67F0410(1uLL, (atomic_ullong *)(v14 + 8));
  v21 = a5;
  v19 = *a5;
  v20 = v21[1];
  if ( v20 )
    sub_67F0410(1uLL, (atomic_ullong *)(v20 + 8));
  v22 = *a6;
  *v16 = v12;
  v16[1] = v17;
  v16[2] = v18;
  v16[3] = v15;
  v16[4] = v14;
  v16[5] = v19;
  v16[6] = v20;
  *((_DWORD *)v16 + 14) = v22;
  result = pthread_create(a1, 0LL, (void *(*)(void *))sub_651E138, v16);
  if ( (_DWORD)result )
    sub_67D662C(result, "thread constructor failed");
  return result;
}


================================================================================
Function: sub_651D404 (0x651D404)
================================================================================

__int64 __fastcall sub_651D404(_QWORD *a1, __int64 a2, unsigned int a3, unsigned int a4, __int64 a5)
{
  __int64 v10; // x24
  __int64 result; // x0

  v10 = sub_6575418();
  *(_OWORD *)v10 = 0u;
  *(_OWORD *)(v10 + 16) = 0u;
  *(_OWORD *)(v10 + 32) = 0u;
  *(_OWORD *)(v10 + 48) = 0u;
  *(_OWORD *)(v10 + 64) = 0u;
  *(_OWORD *)(v10 + 80) = 0u;
  *(_OWORD *)(v10 + 96) = 0u;
  *(_OWORD *)(v10 + 112) = 0u;
  *(_OWORD *)(v10 + 128) = 0u;
  *(_BYTE *)(v10 + 96) = 0;
  *(_BYTE *)(v10 + 97) = 0;
  *(_QWORD *)v10 = off_6BACE60;
  *(_QWORD *)(v10 + 104) = sub_6577314(0x180uLL);
  *(_QWORD *)(v10 + 112) = 8LL;
  *(_QWORD *)(v10 + 120) = 0LL;
  *(_QWORD *)(v10 + 128) = 0LL;
  *(_BYTE *)(v10 + 136) = 0;
  result = sub_651CCD8(a1, a2, a3, a4, v10, a5);
  *a1 = off_6BACE08;
  return result;
}


================================================================================
Function: sub_651D4BC (0x651D4BC)
================================================================================

__int64 __fastcall sub_651D4BC(__int64 a1, __int64 a2)
{
  char v4; // w19
  pthread_mutex_t *v5; // x21
  __int64 v6; // x8

  v4 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 8) + 16LL))(*(_QWORD *)(a1 + 8), a1);
  if ( (v4 & 1) != 0 )
  {
    sub_651D540(*(_QWORD *)(a1 + 8) + 104LL, a2);
    v5 = (pthread_mutex_t *)(*(_QWORD *)(a1 + 8) + 56LL);
    sub_67D1968(v5);
    v6 = *(_QWORD *)(a1 + 8);
    *(_BYTE *)(v6 + 97) = 1;
    sub_67A2D6C(v6 + 8);
    sub_67D19BC(v5);
  }
  return v4 & 1;
}


================================================================================
Function: sub_651D540 (0x651D540)
================================================================================

__int64 __fastcall sub_651D540(__int64 a1, __int64 a2)
{
  int v4; // w22
  int v5; // w23
  __int64 v6; // x0
  __int64 v7; // x9
  __int64 result; // x0
  __int64 v9; // x8
  _BYTE v10[32]; // [xsp+0h] [xbp-40h] BYREF
  _BYTE *v11; // [xsp+20h] [xbp-20h]
  __int64 v12; // [xsp+30h] [xbp-10h] BYREF

  if ( dword_6C30238 <= 1 )
    v4 = 1;
  else
    v4 = dword_6C30238;
LABEL_4:
  v5 = v4;
  while ( (sub_67F0140(1LL, a1 + 32) & 1) != 0 )
  {
    if ( !--v5 )
      goto LABEL_4;
  }
  v6 = *(_QWORD *)(a2 + 32);
  if ( !v6 )
    goto LABEL_11;
  if ( a2 != v6 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
LABEL_11:
    v11 = (_BYTE *)v6;
    goto LABEL_13;
  }
  v7 = *(_QWORD *)v6;
  v11 = v10;
  (*(void (__fastcall **)(__int64, _BYTE *))(v7 + 24))(v6, v10);
LABEL_13:
  sub_51DBA88(a1, v10, &v12);
  result = (__int64)v11;
  if ( v10 == v11 )
  {
    v9 = 4LL;
    goto LABEL_17;
  }
  if ( v11 )
  {
    v9 = 5LL;
LABEL_17:
    result = (*(__int64 (**)(void))(*(_QWORD *)v11 + 8 * v9))();
  }
  atomic_store(0, (unsigned __int8 *)(a1 + 32));
  return result;
}


================================================================================
Function: sub_651DD88 (0x651DD88)
================================================================================

char **__fastcall sub_651DD88(char **result, unsigned __int64 a2)
{
  char *v2; // x8
  char *v3; // x19
  char **v4; // x20
  char *v6; // x23
  unsigned __int64 v7; // x22
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x25
  __int64 v11; // x0
  size_t v12; // x21
  __int64 v13; // x9
  char *v14; // x21
  unsigned __int64 v15; // x24
  size_t v16; // x22
  char *v17; // x8
  __int64 v18; // x9
  char *v19; // x10
  char *v20; // x11
  char *v21; // x9
  char *v22; // x19
  char *v23; // x21
  __int64 v24; // x20

  v3 = result[1];
  v2 = result[2];
  v4 = result;
  if ( 0xAAAAAAAAAAAAAAABLL * ((v2 - v3) >> 3) >= a2 )
  {
    if ( a2 )
    {
      v12 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      result = (char **)memset(result[1], 0, v12);
      v3 += v12;
    }
    v4[1] = v3;
  }
  else
  {
    v6 = *result;
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *result) >> 3);
    v8 = v7 + a2;
    if ( v7 + a2 > 0xAAAAAAAAAAAAAAALL )
      sub_67D6BD4();
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v2 - v6) >> 3);
    if ( 2 * v9 >= v8 )
      v8 = 2 * v9;
    if ( v9 >= 0x555555555555555LL )
      v10 = 0xAAAAAAAAAAAAAAALL;
    else
      v10 = v8;
    if ( v10 )
    {
      if ( v10 > 0xAAAAAAAAAAAAAAALL )
        sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
      v11 = sub_6575418();
    }
    else
    {
      v11 = 0LL;
    }
    v13 = 24 * a2;
    v15 = v11 + 24 * v10;
    v14 = (char *)(v11 + 24 * v7);
    v16 = 24 * ((v13 - 24) / 0x18uLL) + 24;
    result = (char **)memset(v14, 0, v16);
    v17 = &v14[v16];
    if ( v3 == v6 )
    {
      *v4 = v14;
      v4[1] = v17;
      v4[2] = (char *)v15;
      if ( v3 )
        return (char **)sub_6575460();
    }
    else
    {
      v18 = 0LL;
      do
      {
        v19 = &v3[v18];
        v20 = &v14[v18];
        v18 -= 24LL;
        *(_OWORD *)(v20 - 24) = *(_OWORD *)(v19 - 24);
        *((_QWORD *)v20 - 1) = *((_QWORD *)v19 - 1);
        *((_QWORD *)v19 - 3) = 0LL;
        *((_QWORD *)v19 - 2) = 0LL;
        *((_QWORD *)v19 - 1) = 0LL;
      }
      while ( &v3[v18] != v6 );
      v21 = &v14[v18];
      v4[2] = (char *)v15;
      v22 = *v4;
      v23 = v4[1];
      *v4 = v21;
      for ( v4[1] = v17; v23 != v22; result = (char **)sub_67D6798(v23) )
      {
        v24 = *((_QWORD *)v23 - 1);
        v23 -= 24;
        if ( v24 )
        {
          if ( !sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(v24 + 8)) )
          {
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 16LL))(v24);
            sub_67D18A4((unsigned __int64 *)v24);
          }
        }
      }
      if ( v22 )
        return (char **)sub_6575460();
    }
  }
  return result;
}


================================================================================
Function: sub_6536F58 (0x6536F58)
================================================================================

__int64 __usercall sub_6536F58@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  __int64 result; // x0

  result = qword_71CD2D0;
  if ( qword_71CD2D0 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)qword_71CD2D0 + 48LL))(qword_71CD2D0, a1);
  *a2 = 0LL;
  a2[1] = 0LL;
  return result;
}


================================================================================
Function: sub_6537108 (0x6537108)
================================================================================

__int64 __usercall sub_6537108@<X0>(_QWORD *a1@<X8>)
{
  __int64 result; // x0

  result = qword_71CD330;
  if ( qword_71CD330 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_71CD330 + 48LL))(qword_71CD330);
  *a1 = 0LL;
  a1[1] = 0LL;
  return result;
}


================================================================================
Function: sub_65386A0 (0x65386A0)
================================================================================

__int64 __usercall sub_65386A0@<X0>(char a1@<W0>, int a2@<W1>, char *a3@<X2>, unsigned __int64 *a4@<X8>)
{
  __int64 result; // x0
  unsigned __int64 v9[2]; // [xsp+8h] [xbp-38h] BYREF
  __int128 v10; // [xsp+20h] [xbp-20h] BYREF

  sub_67D2788((unsigned __int64 *)&v10, &xmmword_71CD500);
  switch ( a2 )
  {
    case 0:
      sub_6762BB8((int)&v10, "appData");
      break;
    case 1:
      sub_6762BB8((int)&v10, "picture");
      break;
    case 2:
      sub_6762BB8((int)&v10, "video");
      break;
    case 3:
      sub_6762BB8((int)&v10, "exe");
      break;
    case 4:
      sub_67D2788(v9, &xmmword_71CD518);
      sub_67D3420((unsigned __int8 *)&v10, (unsigned __int8 *)v9);
      if ( (v9[0] & 1) != 0 )
        sub_6575460();
      break;
    default:
      break;
  }
  if ( a3 )
    sub_6762BB8((int)&v10, a3);
  LODWORD(v9[0]) = 0;
  v9[1] = (unsigned __int64)sub_6765A30();
  if ( (a1 & 1) == 0 || (sub_655E950(&v10, v9) & 1) != 0 || (result = sub_655E9EC(&v10, v9), (result & 1) != 0) )
  {
    result = (__int64)sub_67D2788(a4, &v10);
    if ( (v10 & 1) == 0 )
      return result;
  }
  else
  {
    *(_WORD *)a4 = 0;
    if ( (v10 & 1) == 0 )
      return result;
  }
  return sub_6575460();
}


================================================================================
Function: sub_6539844 (0x6539844)
================================================================================

void __usercall sub_6539844(__int64 a1@<X8>)
{
  *(_BYTE *)a1 = 6;
  *(_DWORD *)(a1 + 1) = 5067329;
}


================================================================================
Function: sub_65399B0 (0x65399B0)
================================================================================

__int64 sub_65399B0()
{
  return sysconf(96);
}


================================================================================
Function: sub_65399CC (0x65399CC)
================================================================================

__int64 sub_65399CC()
{
  return sysconf(96);
}


================================================================================
Function: sub_65399E4 (0x65399E4)
================================================================================

__int64 sub_65399E4()
{
  return sysconf(96);
}


================================================================================
Function: sub_6539A08 (0x6539A08)
================================================================================

__int64 sub_6539A08()
{
  return 1LL;
}


================================================================================
Function: sub_6539F0C (0x6539F0C)
================================================================================

__int64 sub_6539F0C()
{
  return dword_6C30048;
}


================================================================================
Function: sub_6539F88 (0x6539F88)
================================================================================

void __usercall sub_6539F88(_BYTE *a1@<X8>)
{
  *a1 = 14;
  strcpy(a1 + 1, "Android");
}


================================================================================
Function: sub_6539FB0 (0x6539FB0)
================================================================================

void __usercall sub_6539FB0(_BYTE *a1@<X8>)
{
  *a1 = 14;
  strcpy(a1 + 1, "Android");
}


================================================================================
Function: sub_6539FD8 (0x6539FD8)
================================================================================

__int64 sub_6539FD8()
{
  return 23LL;
}


================================================================================
Function: sub_6539FE0 (0x6539FE0)
================================================================================

unsigned __int64 *__usercall sub_6539FE0@<X0>(unsigned __int64 *a1@<X8>)
{
  return sub_67D2788(a1, &xmmword_71CD5A8);
}


================================================================================
Function: sub_653A254 (0x653A254)
================================================================================

unsigned __int64 *__usercall sub_653A254@<X0>(unsigned __int64 *a1@<X8>)
{
  return sub_67D2788(a1, &xmmword_71CD5C0);
}


================================================================================
Function: sub_653A2FC (0x653A2FC)
================================================================================

unsigned __int64 *__usercall sub_653A2FC@<X0>(unsigned __int64 *a1@<X8>)
{
  return sub_67D2788(a1, &xmmword_71CD5D8);
}


================================================================================
Function: sub_653A30C (0x653A30C)
================================================================================

void __usercall sub_653A30C(_BYTE *a1@<X8>)
{
  *a1 = 14;
  strcpy(a1 + 1, "Android");
}


================================================================================
Function: sub_653EEEC (0x653EEEC)
================================================================================

__int64 __fastcall sub_653EEEC(unsigned int a1)
{
  __int64 v2; // x0

  v2 = sub_6540468();
  if ( v2 )
    return sub_6540490(v2, a1);
  if ( qword_6C41EF0 )
  {
    if ( *(_QWORD *)(qword_6C41EF0 + 48) )
      JUMPOUT(0x653EF88LL);
  }
  return sub_653F72C(&unk_71CD9B0, a1);
}


================================================================================
Function: sub_653EF60 (0x653EF60)
================================================================================

__int64 __fastcall sub_653EF60(unsigned int a1)
{
  __int64 v1; // x1
  __int64 v2; // x0
  __int64 v4; // x19
  __int64 v5; // x22
  unsigned int v6; // w20
  __int64 v7; // x0

  v1 = a1;
  if ( !qword_6C41EF0 )
    return sub_653F72C(&unk_71CD9B0, v1);
  v2 = *(_QWORD *)(qword_6C41EF0 + 48);
  if ( !v2 )
    return sub_653F72C(&unk_71CD9B0, v1);
  v4 = v2 + 24;
  v5 = *(_QWORD *)(qword_6C41EF0 + 48);
  v6 = v1;
  sub_25A64D0(v2 + 24);
  v7 = *(_QWORD *)(v5 + 16);
  if ( v7 )
    sub_6540490(v7, v6);
  else
    sub_653F72C(&unk_71CD9B0, v6);
  return sub_25A80D4(v4);
}


================================================================================
Function: sub_653F72C (0x653F72C)
================================================================================

__int64 __usercall sub_653F72C@<X0>(__int64 *a1@<X0>, int a2@<W1>, unsigned __int64 *a3@<X8>)
{
  __int64 v3; // x19
  int v7; // w8
  unsigned int v8; // w10
  __int64 v9; // x8
  __int64 v10; // x9
  int v11; // w11
  int v12; // w12
  int v13; // w8

  v3 = (__int64)(a1 + 3);
  sub_25A64D0((__int64)(a1 + 3));
  v7 = *((_DWORD *)a1 + 4);
  if ( !v7 )
  {
LABEL_8:
    *a3 = 0LL;
    a3[1] = 0LL;
    a3[2] = 0LL;
    return sub_25A80D4(v3);
  }
  v8 = v7 - 1;
  v9 = (v7 - 1) & (unsigned int)(37 * a2);
  v10 = *a1;
  v11 = *(_DWORD *)(*a1 + 32 * v9);
  if ( v11 != a2 )
  {
    v12 = 1;
    while ( v11 != -1 )
    {
      v13 = v9 + v12++;
      v9 = v13 & v8;
      v11 = *(_DWORD *)(v10 + 32 * v9);
      if ( v11 == a2 )
        goto LABEL_3;
    }
    goto LABEL_8;
  }
LABEL_3:
  sub_67D2788(a3, (__int128 *)(v10 + 32 * v9 + 8));
  return sub_25A80D4(v3);
}


================================================================================
Function: sub_6540468 (0x6540468)
================================================================================

// attributes: thunk
__int64 sub_6540468(void)
{
  return sub_6540F5C();
}


================================================================================
Function: sub_6540490 (0x6540490)
================================================================================

__int64 __usercall sub_6540490@<X0>(__int64 a1@<X0>, int a2@<W1>, unsigned __int64 *a3@<X8>)
{
  return sub_653F72C((__int64 *)(a1 + 96), a2, a3);
}


================================================================================
Function: sub_6540F5C (0x6540F5C)
================================================================================

__int64 sub_6540F5C()
{
  return *(_QWORD *)sub_6583344((__int64)&qword_71CDBE0);
}


================================================================================
Function: sub_654A988 (0x654A988)
================================================================================

__int64 __fastcall sub_654A988(__int64 a1)
{
  return a1 + 80;
}


================================================================================
Function: sub_654A990 (0x654A990)
================================================================================

__int128 *sub_654A990()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_71CDFB0);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_71CDFB0) )
  {
    qword_71CDFA8 = 0LL;
    xmmword_71CDF88 = 0u;
    unk_71CDF98 = 0u;
    xmmword_71CDF68 = 0u;
    unk_71CDF78 = 0u;
    xmmword_71CDF48 = 0u;
    unk_71CDF58 = 0u;
    xmmword_71CDF28 = 0u;
    unk_71CDF38 = 0u;
    sub_67EB838(byte_71CDFB0);
  }
  return &xmmword_71CDF28;
}


================================================================================
Function: sub_654AA10 (0x654AA10)
================================================================================

__int64 __fastcall sub_654AA10(__int64 *a1)
{
  __int64 v1; // x19
  _DWORD v3[6]; // [xsp+0h] [xbp-20h] BYREF

  v1 = *a1;
  sub_6586BF8(v3, a1 + 1);
  return v1 + v3[0];
}


================================================================================
Function: sub_654AA6C (0x654AA6C)
================================================================================

__int64 (__fastcall ***__usercall sub_654AA6C@<X0>(
        char a1@<W0>,
        char a2@<W1>,
        __int64 a3@<X2>,
        char a4@<W3>,
        __int64 a5@<X8>))(_QWORD, __int64)
{
  __int64 (__fastcall ***result)(_QWORD, __int64); // x0

  *(_DWORD *)(a5 + 32) = 0;
  *(_QWORD *)(a5 + 16) = 0LL;
  *(_QWORD *)(a5 + 24) = 0LL;
  *(_BYTE *)(a5 + 40) = a1;
  *(_BYTE *)(a5 + 41) = a2;
  *(_BYTE *)(a5 + 42) = 0;
  *(_QWORD *)a5 = a3;
  *(_QWORD *)(a5 + 8) = 0LL;
  result = (__int64 (__fastcall ***)(_QWORD, __int64))sub_657489C();
  *(_DWORD *)(a5 + 8) = (_DWORD)result;
  *(_BYTE *)(a5 + 42) = a4;
  if ( byte_71CDFFC == 1 && byte_71CF7B0 && byte_71CDFD8 )
  {
    result = *(__int64 (__fastcall ****)(_QWORD, __int64))sub_6577D64(result);
    if ( result )
      return (__int64 (__fastcall ***)(_QWORD, __int64))(**result)(result, a5);
  }
  return result;
}


================================================================================
Function: sub_654AAF0 (0x654AAF0)
================================================================================

__int64 __fastcall sub_654AAF0(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 result; // x0

  if ( byte_71CDFFC != 1 )
    return sub_654ADA8(&unk_71CE000, a2, 0.0);
  v4 = sub_654B108();
  result = sub_654ADA8(v4, a2, 0.0);
  if ( byte_71CF7B0 && byte_71CDFD8 )
  {
    result = *(_QWORD *)sub_6577D64(result);
    if ( result )
      return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)result + 8LL))(result, a1, a2);
  }
  return result;
}


================================================================================
Function: sub_654AB80 (0x654AB80)
================================================================================

void *sub_654AB80()
{
  return &unk_71CE000;
}


================================================================================
Function: sub_654AB8C (0x654AB8C)
================================================================================

long double __usercall sub_654AB8C@<Q0>(char a1@<W0>, char a2@<W1>, char a3@<W2>, __int64 a4@<X8>)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_DWORD *)(a4 + 32) = 0;
  *(_BYTE *)(a4 + 40) = a1;
  *(_BYTE *)(a4 + 41) = a2;
  *(_BYTE *)(a4 + 42) = a3;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  return result;
}


================================================================================
Function: sub_654ABA8 (0x654ABA8)
================================================================================

__int64 __fastcall sub_654ABA8(__int64 a1, __int64 a2)
{
  __int64 v4; // x0
  __int64 result; // x0

  if ( byte_71CDFFC != 1 )
    return sub_654AE1C(&unk_71CE000, a2, 0.0);
  v4 = sub_654B108();
  result = sub_654AE1C(v4, a2, 0.0);
  if ( byte_71CF7B0 && byte_71CDFD8 )
  {
    result = *(_QWORD *)sub_6577D64(result);
    if ( result )
      return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)result + 24LL))(result, a1, a2);
  }
  return result;
}


================================================================================
Function: sub_654AC38 (0x654AC38)
================================================================================

bool sub_654AC38()
{
  __int64 v0; // x0

  if ( byte_71CDFFC != 1 )
    return 0LL;
  v0 = sub_654A990();
  return *(_BYTE *)(sub_654A988(v0) + 48) != 0;
}


================================================================================
Function: sub_654ADA8 (0x654ADA8)
================================================================================

__int64 __fastcall sub_654ADA8(__int64 result, __int64 a2, double a3)
{
  int v3; // w15
  unsigned int v4; // w11
  unsigned int v5; // w13
  __int64 v6; // x8
  __int64 v7; // x9
  __int64 v8; // x8
  __int64 v9; // x9
  unsigned __int64 v10; // x10
  double v11; // d0
  unsigned int v13; // w10
  unsigned __int64 v14; // x14
  unsigned int v15; // w8

  v3 = *(_DWORD *)(result + 24);
  v4 = *(_DWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 36);
  v6 = *(_QWORD *)(result + 8);
  v7 = *(_QWORD *)(result + 16);
  ++*(_DWORD *)result;
  v8 = v6 + a2;
  v9 = v8 - v7;
  v10 = (unsigned __int64)(v9 - 1) >> 4;
  *(_QWORD *)(result + 8) = v8;
  v11 = a3 * 1000.0 * 1000.0 * 1000.0;
  if ( v4 >= (int)v10 + 1 || v9 <= 0 )
    v13 = v4;
  else
    v13 = v10 + 1;
  v14 = llround(v11);
  if ( v5 >= (unsigned int)a2 )
    v15 = v5;
  else
    v15 = a2;
  *(_DWORD *)(result + 32) = v13;
  *(_DWORD *)(result + 36) = v15;
  *(_DWORD *)(result + 24) = v3 + (v14 >> 4);
  return result;
}


================================================================================
Function: sub_654AE1C (0x654AE1C)
================================================================================

double __fastcall sub_654AE1C(__int64 a1, __int64 a2, double a3)
{
  int v3; // w10
  __int64 v4; // x11
  double result; // d0

  v3 = *(_DWORD *)(a1 + 28);
  v4 = *(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 4);
  result = a3 * 1000.0 * 1000.0 * 1000.0;
  *(_DWORD *)(a1 + 28) = v3 + (llround(result) >> 4);
  *(_QWORD *)(a1 + 16) = v4 + a2;
  return result;
}


================================================================================
Function: sub_654AE64 (0x654AE64)
================================================================================

__int64 __fastcall sub_654AE64(unsigned int *a1)
{
  return *a1;
}


================================================================================
Function: sub_654AE6C (0x654AE6C)
================================================================================

__int64 __fastcall sub_654AE6C(__int64 a1)
{
  return *(unsigned int *)(a1 + 4);
}


================================================================================
Function: sub_654AE74 (0x654AE74)
================================================================================

__int64 __fastcall sub_654AE74(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}


================================================================================
Function: sub_654AE7C (0x654AE7C)
================================================================================

__int64 __fastcall sub_654AE7C(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}


================================================================================
Function: sub_654AED4 (0x654AED4)
================================================================================

long double __fastcall sub_654AED4(__int64 a1)
{
  long double result; // q0

  *(_OWORD *)&result = 0uLL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}


================================================================================
Function: sub_654B108 (0x654B108)
================================================================================

void *sub_654B108()
{
  _QWORD *v0; // x0
  _QWORD *v2; // x19

  if ( (*(_BYTE *)sub_67EF968(qword_6C30180) & 1) == 0 )
  {
    v2 = sub_67EF968(qword_6C30160);
    sub_654B198();
    sub_67EC670(sub_654B29C, v2, &off_67F7780);
    *(_BYTE *)sub_67EF968(qword_6C30180) = 1;
  }
  v0 = sub_67EF968(qword_6C30160);
  if ( *v0 )
    return (void *)*v0;
  else
    return &unk_71CF4A8;
}


================================================================================
Function: sub_654B198 (0x654B198)
================================================================================

__int64 __fastcall sub_654B198(_QWORD *a1)
{
  unsigned __int8 v2; // w8
  char *v3; // x21
  __int64 v4; // x8
  char *v5; // x13
  __int64 v6; // x11
  __int64 result; // x0
  __int64 v8; // x0
  __int128 v9; // q0
  __int64 v10; // x8

  v2 = atomic_load(byte_71CF4A0);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_71CF4A0) )
  {
    v8 = sub_654AB80();
    v9 = *(_OWORD *)(v8 + 16);
    v10 = *(_QWORD *)(v8 + 32);
    xmmword_71CE040 = *(_OWORD *)v8;
    *(_OWORD *)algn_71CE050 = v9;
    qword_71CE060 = v10;
    memset(&unk_71CE068, 0, 0x1438uLL);
    sub_67EB838(byte_71CF4A0);
  }
  v3 = (char *)&unk_71CE068;
  sub_67D1968(&stru_71CF478);
  v4 = 0LL;
  while ( 1 )
  {
    v5 = (char *)&xmmword_71CE040 + 8 * ((unsigned int)v4 >> 6);
    v6 = *((_QWORD *)v5 + 645);
    if ( ((1LL << v4) & v6) == 0 )
      break;
    ++v4;
    v3 += 40;
    if ( v4 == 128 )
    {
      v3 = 0LL;
      goto LABEL_7;
    }
  }
  *((_QWORD *)v5 + 645) = (1LL << v4) | v6;
LABEL_7:
  result = sub_67D19BC(&stru_71CF478);
  *a1 = v3;
  return result;
}


================================================================================
Function: sub_654BB38 (0x654BB38)
================================================================================

__int64 __fastcall sub_654BB38(__int64 result, unsigned __int8 *a2)
{
  __int64 *v3; // x20
  __int64 v4; // x9
  __int64 **v5; // x21
  __int64 *v6; // x0
  __int64 v7; // x2
  __int64 v8; // x20
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x21
  unsigned __int8 *v11; // x8
  char *v12; // x8
  unsigned __int8 *v13; // x9
  unsigned int v14; // t1
  char v15; // w11
  _BYTE v16[128]; // [xsp+8h] [xbp-88h] BYREF

  v3 = *(__int64 **)result;
  if ( !*(_BYTE *)(*(_QWORD *)result + 9LL) )
  {
    v4 = *v3;
    v5 = (__int64 **)result;
    v6 = *(__int64 **)result;
    *((_BYTE *)v3 + 9) = 1;
    result = (*(__int64 (__fastcall **)(__int64 *))(v4 + 32))(v6);
    v3 = *v5;
  }
  v7 = *((int *)v3 + 6);
  if ( (int)v7 <= 128 )
  {
    result = __memcpy_chk(v16, v3[2], v7, 128LL);
    v8 = *((unsigned int *)v3 + 6);
    if ( (unsigned int)v8 <= 0x7F )
    {
      v9 = *a2;
      if ( (v9 & 1) != 0 )
        v10 = *((_QWORD *)a2 + 1);
      else
        v10 = v9 >> 1;
      result = sub_67D36F0(a2, v10 + 2 * v8, 0LL);
      if ( (*a2 & 1) != 0 )
        v11 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
      else
        v11 = a2 + 1;
      if ( (_DWORD)v8 )
      {
        v12 = (char *)&v11[v10 + 1];
        v13 = v16;
        do
        {
          v14 = *v13++;
          --v8;
          v15 = a0123456789abcd_1[v14 & 0xF];
          *(v12 - 1) = a0123456789abcd_1[(unsigned __int64)v14 >> 4];
          *v12 = v15;
          v12 += 2;
        }
        while ( v8 );
      }
    }
  }
  return result;
}


================================================================================
Function: sub_654BD24 (0x654BD24)
================================================================================

__int64 sub_654BD24()
{
  unsigned __int64 v0; // x20
  __int64 v1; // x22
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x8
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x0
  __int64 result; // x0
  unsigned int v9; // w20
  unsigned int v10; // w0

  sub_654D8D4();
  v0 = atomic_load((unsigned __int64 *)&qword_71CF518);
  v1 = (unsigned int)dword_71CF528;
  v2 = (unsigned int)v0;
  if ( (unsigned int)v0 >= (unsigned __int64)(unsigned int)dword_71CF528 )
    goto LABEL_18;
  v3 = qword_71CF520;
  if ( !qword_71CF520 )
    goto LABEL_18;
  while ( 1 )
  {
    v4 = *(_QWORD *)(v3 + 136 * v2);
    if ( v3 <= v4 && v3 + 136 * v1 > v4 )
    {
      v6 = 0xF0F0F0F0F0F0F0F1LL * ((__int64)(v4 - v3) >> 3);
      if ( v6 >= 0xFFFFFFFF )
        v6 = 0xFFFFFFFFLL;
    }
    else
    {
      v6 = 0xFFFFFFFFLL;
    }
    v7 = sub_67F0010(v0, v6 | v0 & 0xFFFFFFFF00000000LL, (atomic_ullong *)&qword_71CF518);
    if ( v7 == v0 )
      break;
    v1 = (unsigned int)dword_71CF528;
    v2 = (unsigned int)v7;
    if ( (unsigned int)v7 < (unsigned __int64)(unsigned int)dword_71CF528 )
    {
      v3 = qword_71CF520;
      v0 = v7;
      if ( qword_71CF520 )
        continue;
    }
    goto LABEL_18;
  }
  LODWORD(v1) = dword_71CF528;
  if ( (unsigned int)v0 < (unsigned __int64)(unsigned int)dword_71CF528 && qword_71CF520 )
  {
    result = qword_71CF520 + 136LL * (unsigned int)v0;
    if ( !result )
      return sub_6575418();
  }
  else
  {
LABEL_18:
    v9 = dword_71CF510;
    if ( (unsigned int)v1 <= dword_71CF510 )
      return sub_6575418();
    while ( 1 )
    {
      v10 = sub_67EFE50(v9, v9 + 1, &dword_71CF510);
      if ( v10 == v9 )
        break;
      v9 = v10;
      if ( (unsigned int)v1 <= v10 )
        return sub_6575418();
    }
    if ( (unsigned int)v1 <= v9 )
      return sub_6575418();
    result = qword_71CF520 + 136LL * v9;
    if ( !result )
      return sub_6575418();
  }
  return result;
}


================================================================================
Function: sub_654CD24 (0x654CD24)
================================================================================

__int64 __usercall sub_654CD24@<X0>(__int64 a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  __int64 v6; // x19
  __int64 v8; // [xsp+0h] [xbp-10h] BYREF

  v6 = sub_654BD24(136LL);
  v8 = v6;
  *(_DWORD *)(v6 + 24) = 16;
  *(_QWORD *)v6 = &off_6BADDE8;
  *(_WORD *)(v6 + 8) = 1;
  *(_QWORD *)(v6 + 120) = 0LL;
  *(_QWORD *)(v6 + 16) = v6 + 120;
  *(_QWORD *)(v6 + 128) = 0LL;
  sub_66F0674(v6 + 28);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v6 + 24LL))(v6, a1, a2);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  sub_654BB38(&v8, a3);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
}


================================================================================
Function: sub_654D8D4 (0x654D8D4)
================================================================================

void sub_654D8D4()
{
  unsigned __int8 v0; // w8
  int v1; // w20

  v0 = atomic_load(byte_71CF530);
  if ( (v0 & 1) == 0 )
  {
    if ( (unsigned int)sub_67EB6E0((__int64)byte_71CF530) )
    {
      v1 = dword_6C301A0;
      dword_71CF510 = 0;
      qword_71CF518 = 0xFFFFFFFFLL;
      qword_71CF520 = sub_6575FA8(136LL * (unsigned int)dword_6C301A0, 8uLL);
      dword_71CF528 = v1;
      __cxa_atexit((void (*)(void *))sub_654D984, &dword_71CF510, &off_67F7780);
      sub_67EB838(byte_71CF530);
    }
  }
}


================================================================================
Function: sub_654E10C (0x654E10C)
================================================================================

__int64 __fastcall sub_654E10C(__int64 a1, int a2, int a3, int a4, double a5)
{
  __int64 v9; // x22
  const char *v10; // x4
  unsigned int v11; // w19
  _QWORD v13[3]; // [xsp+0h] [xbp-30h] BYREF

  v9 = (unsigned int)(a2 - 1);
  sub_6580FD4(v13, (__int64)((*(double *)&qword_726F7E0 + a5) * 1000.0));
  if ( (v13[0] & 1) != 0 )
    v10 = (const char *)v13[2];
  else
    v10 = (char *)v13 + 1;
  v11 = sub_654ED94(a1, -1LL, v9, "%s,%.6f,%04x,%d%s ", v10, a5, a3, a4, (const char *)off_6C301B0);
  if ( (v13[0] & 1) != 0 )
    sub_6575460();
  return v11;
}


================================================================================
Function: sub_654E21C (0x654E21C)
================================================================================

__int64 __fastcall sub_654E21C(
        __int64 a1,
        int a2,
        int a3,
        int a4,
        char a5,
        char *a6,
        __int64 a7,
        double a8,
        __int64 a9,
        unsigned __int64 a10,
        unsigned int *a11)
{
  __int64 v19; // x23
  const char *v20; // x4
  const char *v21; // x7
  int v22; // w26
  int v23; // w0
  __int64 v24; // x21
  __int64 v25; // x22
  __int64 result; // x0
  _QWORD v27[2]; // [xsp+8h] [xbp-158h] BYREF
  const char *v28; // [xsp+18h] [xbp-148h]
  __int64 v29; // [xsp+20h] [xbp-140h]
  __int64 v30; // [xsp+28h] [xbp-138h]
  __int64 v31; // [xsp+30h] [xbp-130h]
  __int64 v32; // [xsp+38h] [xbp-128h]

  v19 = (unsigned int)(a2 - 1);
  sub_6580FD4(v27, (__int64)((*(double *)&qword_726F7E0 + a8) * 1000.0));
  if ( (v27[0] & 1) != 0 )
    v20 = v28;
  else
    v20 = (char *)v27 + 1;
  if ( (unsigned __int8)(a5 + 1) > 7u )
    v21 = "invalid";
  else
    v21 = (char *)dword_1705070 + dword_1705070[(char)(a5 + 1)];
  v22 = sub_654ED94(a1, -1LL, v19, "%s,%.6f,%04x,%d,%s%s ", v20, a8, a3, a4, v21, (const char *)off_6C301B0);
  if ( (v27[0] & 1) != 0 )
    sub_6575460();
  v23 = sub_6579F14(v19, v22);
  v24 = a1 + v23;
  v25 = (unsigned int)(a2 - v23 - 2);
  v30 = 0LL;
  v31 = v25;
  v28 = 0LL;
  v29 = v25;
  v27[0] = off_6BADF88;
  v27[1] = v24;
  v32 = v24;
  result = sub_67900D8((__int64)v27, a6, a7, a10, a11, 0LL);
  *(_BYTE *)(v24 + v25) = 0;
  return result;
}


================================================================================
Function: sub_654E3D0 (0x654E3D0)
================================================================================

__int64 __fastcall sub_654E3D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_654E3E4(a1, a2, a3, a4, 0LL, 0LL, 0LL, 0LL);
}


================================================================================
Function: sub_654E3E4 (0x654E3E4)
================================================================================

__int64 __fastcall sub_654E3E4(
        __int64 result,
        __int64 a2,
        const char *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned __int64 v8; // x19
  double v16; // d8
  int v17; // w0
  unsigned __int8 v18; // w8
  int v19; // w19
  __int64 v20; // x22
  double *v21; // x8
  int v22; // w27
  float v23; // s0
  int v24; // w0
  int v25; // w0
  __int64 v26; // x2
  _BYTE *v27; // x0
  float v28; // s0
  float v29; // s1
  float v30; // s2
  float v31; // s3
  _BYTE s[1024]; // [xsp+10h] [xbp-420h] BYREF

  v8 = result;
  if ( (_BYTE)result )
  {
    if ( (unsigned __int8)result < 6u )
    {
LABEL_6:
      v16 = off_6C301A8();
      v17 = pthread_self();
      v18 = v8 - 1;
      v19 = v17 & 0x7FFFFFFF;
      v20 = v18;
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)((char *)&unk_726F9E8 + 4 * v18));
      v21 = (double *)((char *)&unk_71CF7C0 + 0x20000 * v20 + 64 * (unsigned __int64)(((_WORD)result - 1) & 0x7FF));
      *(_QWORD *)v21 = a3;
      v21[1] = v16;
      *((_QWORD *)v21 + 2) = a4;
      v21[3] = *(double *)&a5;
      v21[4] = *(double *)&a6;
      v21[5] = *(double *)&a7;
      v21[6] = *(double *)&a8;
      *((_DWORD *)v21 + 14) = v19;
      return result;
    }
    if ( !off_726F7D0 && !off_726F7D8 )
    {
      LOBYTE(v8) = 1;
      goto LABEL_6;
    }
    memset(s, 0, sizeof(s));
    v22 = pthread_self();
    v23 = off_6C301A8();
    v24 = sub_654E10C((__int64)s, 1024, v22, (unsigned __int8)v8, v23);
    v25 = sub_6579F14(1023, v24);
    v26 = (unsigned int)(1023 - v25);
    v27 = &s[v25];
    if ( a4 == 4294906029LL )
    {
      v28 = *(double *)&a5;
      v29 = *(double *)&a6;
      v30 = *(double *)&a7;
      v31 = *(double *)&a8;
      result = sub_654ED94((__int64)v27, -1LL, v26, a3, v28, v29, v30, v31);
    }
    else
    {
      result = sub_654ED94((__int64)v27, -1LL, v26, a3, a4, a5, a6, a7, a8);
    }
    if ( off_726F7D0 )
      result = off_726F7D0(v8, a2, s);
    if ( off_726F7D8 )
      return off_726F7D8(v8, a2, v8 >> 8, s);
  }
  return result;
}


================================================================================
Function: sub_654E614 (0x654E614)
================================================================================

__int64 __fastcall sub_654E614(unsigned __int64 a1, __int64 a2, const char *a3, __int128 *a4)
{
  unsigned __int64 v6; // x19
  __int128 v8; // q0
  __int128 v9; // q1
  __int64 result; // x0
  _OWORD *v11; // x8
  __int128 v12; // q1
  __int128 v13; // q2
  __int128 v14; // q3
  pthread_t v15; // x23
  float v16; // s0
  unsigned int v17; // w0
  int v18; // w0
  __int128 v19; // [xsp+0h] [xbp-470h]
  __int128 v20; // [xsp+10h] [xbp-460h]
  __int128 v21; // [xsp+20h] [xbp-450h]
  __int128 v22; // [xsp+30h] [xbp-440h]
  __int128 arg; // [xsp+40h] [xbp-430h] BYREF
  __int128 v24; // [xsp+50h] [xbp-420h]
  __int128 s; // [xsp+68h] [xbp-408h] BYREF
  __int128 v26; // [xsp+78h] [xbp-3F8h] BYREF
  _BYTE v27[28]; // [xsp+88h] [xbp-3E8h]

  v6 = a1;
  if ( (unsigned __int8)a1 < 6u )
    goto LABEL_5;
  if ( !off_726F7D0 && !off_726F7D8 )
  {
    LOBYTE(v6) = 1;
LABEL_5:
    v8 = *a4;
    v9 = a4[1];
    *(_QWORD *)&s = "%s";
    v19 = v8;
    v20 = v9;
    *((_QWORD *)&s + 1) = off_6C301A8();
    *(_DWORD *)&v27[24] = pthread_self();
    arg = v19;
    v24 = v20;
    vsnprintf((char *)&v26, 0x28uLL, a3, &arg);
    v27[23] = 0;
    *(_DWORD *)&v27[24] |= 0x80000000;
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)((char *)&unk_726F9E8 + 4 * (unsigned __int8)(v6 - 1)));
    v11 = (_OWORD *)((char *)&unk_71CF7C0
                   + 0x20000 * (unsigned __int64)(unsigned __int8)(v6 - 1)
                   + 64 * (unsigned __int64)(((_WORD)result - 1) & 0x7FF));
    v12 = *(_OWORD *)v27;
    v13 = s;
    v14 = v26;
    *(_OWORD *)((char *)v11 + 44) = *(_OWORD *)&v27[12];
    *v11 = v13;
    v11[1] = v14;
    v11[2] = v12;
    return result;
  }
  memset(&s, 0, 0x400uLL);
  v15 = pthread_self();
  v16 = off_6C301A8();
  v21 = *a4;
  v22 = a4[1];
  v17 = sub_654E10C(&s, 1024LL, v15, (unsigned __int8)v6, v16);
  v18 = sub_6579F14(1023LL, v17);
  arg = v21;
  v24 = v22;
  result = vsnprintf((char *)&s + v18, (unsigned int)(1023 - v18), a3, &arg);
  if ( off_726F7D0 )
    result = off_726F7D0(v6, a2, &s);
  if ( off_726F7D8 )
    return off_726F7D8(v6, a2, v6 >> 8, &s);
  return result;
}


================================================================================
Function: sub_654E814 (0x654E814)
================================================================================

__int64 __fastcall sub_654E814(
        __int64 result,
        __int64 a2,
        const char *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        long double a9,
        long double a10,
        long double a11,
        long double a12,
        __int64 a13)
{
  _QWORD v13[6]; // [xsp+80h] [xbp-80h] BYREF
  _OWORD v14[2]; // [xsp+B0h] [xbp-50h] BYREF
  __int128 v15; // [xsp+D8h] [xbp-28h]
  __int128 v16; // [xsp+E8h] [xbp-18h]

  v13[3] = a6;
  v13[4] = a7;
  v13[1] = a4;
  v13[2] = a5;
  v13[5] = a8;
  if ( (_BYTE)result )
  {
    *(_QWORD *)&v16 = v13;
    *((_QWORD *)&v16 + 1) = 0xFFFFFF80FFFFFFD8LL;
    *(_QWORD *)&v15 = &a13;
    *((_QWORD *)&v15 + 1) = v14;
    v14[0] = v15;
    v14[1] = v16;
    return sub_654E614(
             result,
             a2,
             a3,
             v14,
             a5,
             a6,
             a7,
             a8,
             *(_QWORD *)&a9,
             *((_QWORD *)&a9 + 1),
             *(_QWORD *)&a10,
             *((_QWORD *)&a10 + 1),
             *(_QWORD *)&a11,
             *((_QWORD *)&a11 + 1),
             *(_QWORD *)&a12,
             *((_QWORD *)&a12 + 1));
  }
  return result;
}


================================================================================
Function: sub_654E8B4 (0x654E8B4)
================================================================================

__int64 __fastcall sub_654E8B4(
        __int64 result,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8)
{
  __int64 v9; // x19
  _OWORD *v13; // x8
  __int128 v14; // q1
  __int128 v15; // q3
  pthread_t v19; // x27
  __int64 v20; // x7
  float v21; // s0
  double v22; // d0
  unsigned int v23; // w0
  int v24; // w0
  __int64 v25; // x26
  char *v26; // x27
  _QWORD s[2]; // [xsp+18h] [xbp-548h] BYREF
  __int128 v28; // [xsp+28h] [xbp-538h]
  __int128 v29; // [xsp+38h] [xbp-528h]
  __int128 *v30; // [xsp+48h] [xbp-518h]
  __int128 v31; // [xsp+418h] [xbp-148h] BYREF
  __int128 v32; // [xsp+428h] [xbp-138h] BYREF
  _BYTE v33[28]; // [xsp+438h] [xbp-128h]

  v9 = result;
  if ( (unsigned __int8)result < 6u )
    goto LABEL_2;
  if ( BYTE1(result) >= (unsigned int)(unsigned __int8)a3 )
  {
    if ( !off_726F7D0 && !off_726F7D8 )
    {
      LOBYTE(v9) = 1;
LABEL_2:
      *(_QWORD *)&v31 = "%s";
      *((_QWORD *)&v31 + 1) = off_6C301A8();
      *(_DWORD *)&v33[24] = pthread_self();
      s[0] = off_6BADF88;
      s[1] = &v32;
      v29 = xmmword_AF89D0;
      v28 = xmmword_AF89D0;
      v30 = &v32;
      sub_67900D8(s, a4, a5, a6, a7, 0LL);
      v33[23] = 0;
      *(_DWORD *)&v33[24] |= 0x80000000;
      result = sub_67F03E0(0xFFFFFFFFLL, (char *)&unk_726F9E8 + 4 * (unsigned __int8)(v9 - 1));
      v13 = (_OWORD *)((char *)&unk_71CF7C0
                     + 0x20000 * (unsigned __int64)(unsigned __int8)(v9 - 1)
                     + 64 * (unsigned __int64)(((_WORD)result - 1) & 0x7FF));
      v14 = *(_OWORD *)v33;
      *(_OWORD *)((char *)v13 + 44) = *(_OWORD *)&v33[12];
      v15 = v32;
      *v13 = v31;
      v13[1] = v15;
      v13[2] = v14;
      return result;
    }
    memset(s, 0, 0x400uLL);
    v19 = pthread_self();
    v21 = off_6C301A8();
    v22 = v21;
    if ( (a8 & 1) != 0 )
    {
      result = sub_654E21C(s, 1024LL, v19, (unsigned __int8)v9, a3, a4, a5, v20, v22, a6, a7);
    }
    else
    {
      v23 = sub_654E10C(s, 1024LL, v19, (unsigned __int8)v9, v22);
      v24 = sub_6579F14(1023LL, v23);
      v25 = (unsigned int)(1022 - v24);
      v26 = (char *)s + v24;
      *(_QWORD *)v33 = 0LL;
      *(_QWORD *)&v33[8] = v25;
      *(_QWORD *)&v32 = 0LL;
      *((_QWORD *)&v32 + 1) = v25;
      *((_QWORD *)&v31 + 1) = v26;
      *(_QWORD *)&v31 = off_6BADF88;
      *(_QWORD *)&v33[16] = v26;
      result = sub_67900D8(&v31, a4, a5, a6, a7, 0LL);
      v26[v25] = 0;
    }
    if ( off_726F7D0 )
      result = off_726F7D0(v9, a2, s);
    if ( off_726F7D8 )
      return off_726F7D8(v9, a2, a3, s);
  }
  return result;
}


================================================================================
Function: sub_654EB9C (0x654EB9C)
================================================================================

__int64 __fastcall sub_654EB9C(__int64 result, __int64 a2, const char *a3, const char *a4)
{
  unsigned __int64 v4; // x19
  int v8; // w21
  const char *v9; // x1
  _OWORD *v10; // x8
  __int128 v11; // q1
  __int128 v12; // q2
  __int128 v13; // q3
  int v14; // w23
  float v15; // s0
  int v16; // w0
  int v17; // w0
  __int128 s; // [xsp+8h] [xbp-408h] BYREF
  __int128 v19; // [xsp+18h] [xbp-3F8h] BYREF
  _BYTE v20[28]; // [xsp+28h] [xbp-3E8h]

  v4 = result;
  if ( !(_BYTE)result )
    return result;
  if ( (unsigned __int8)result < 6u )
    goto LABEL_6;
  if ( !off_726F7D0 && !off_726F7D8 )
  {
    LOBYTE(v4) = 1;
LABEL_6:
    *(_QWORD *)&s = a3;
    *((_QWORD *)&s + 1) = off_6C301A8();
    v8 = pthread_self();
    if ( a4 )
      v9 = a4;
    else
      v9 = "NULL";
    *(_DWORD *)&v20[24] = v8;
    strncpy((char *)&v19, v9, 0x28uLL);
    v20[23] = 0;
    *(_DWORD *)&v20[24] = v8 | 0x80000000;
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)((char *)&unk_726F9E8 + 4 * (unsigned __int8)(v4 - 1)));
    v10 = (_OWORD *)((char *)&unk_71CF7C0
                   + 0x20000 * (unsigned __int64)(unsigned __int8)(v4 - 1)
                   + 64 * (unsigned __int64)(((_WORD)result - 1) & 0x7FF));
    v11 = *(_OWORD *)v20;
    v12 = s;
    v13 = v19;
    *(_OWORD *)((char *)v10 + 44) = *(_OWORD *)&v20[12];
    *v10 = v12;
    v10[1] = v13;
    v10[2] = v11;
    return result;
  }
  memset(&s, 0, 0x400uLL);
  v14 = pthread_self();
  v15 = off_6C301A8();
  v16 = sub_654E10C((__int64)&s, 1024, v14, (unsigned __int8)v4, v15);
  v17 = sub_6579F14(1023, v16);
  result = sub_654ED94((__int64)&s + v17, -1LL, (unsigned int)(1023 - v17), a3, a4);
  if ( off_726F7D0 )
    result = off_726F7D0(v4, a2, &s);
  if ( off_726F7D8 )
    return off_726F7D8(v4, a2, v4 >> 8, &s);
  return result;
}


================================================================================
Function: sub_654ED80 (0x654ED80)
================================================================================

__int64 __fastcall sub_654ED80(__int64 a1, __int64 a2, const char *a3, __int64 a4)
{
  __int64 v4; // x3

  if ( (*(_BYTE *)a4 & 1) != 0 )
    v4 = *(_QWORD *)(a4 + 16);
  else
    v4 = a4 + 1;
  return sub_654EB9C(a1, a2, a3, v4);
}


================================================================================
Function: sub_654ED94 (0x654ED94)
================================================================================

__int64 sub_654ED94(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  gcc_va_list va1; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, a4);
  va_copy(va1, va);
  return __vsnprintf_chk(a1, a3, 0LL, a2, a4, va1);
}


================================================================================
Function: sub_654EFA4 (0x654EFA4)
================================================================================

__int64 __fastcall sub_654EFA4(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_65568E4(qword_726FA00, a1, a2, a3);
}


================================================================================
Function: sub_654F358 (0x654F358)
================================================================================

__int64 sub_654F358()
{
  return sub_6559560(qword_726FA00);
}


================================================================================
Function: sub_65568E4 (0x65568E4)
================================================================================

__int64 __fastcall sub_65568E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  pthread_mutex_t *v4; // x19
  __int64 *i; // x26
  int v10; // w8
  __int128 *v11; // x1
  __int64 v12; // x23
  _QWORD *v13; // x8

  v4 = (pthread_mutex_t *)(a1 + 40);
  sub_67D1968((pthread_mutex_t *)(a1 + 40));
  for ( i = *(__int64 **)(a1 + 296); i; i = (__int64 *)*i )
  {
    v10 = *((_DWORD *)i + 10);
    v11 = (__int128 *)(i + 2);
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        v12 = *(_QWORD *)(a3 + 8);
        if ( v12 == *(_QWORD *)(a3 + 16) )
        {
          sub_2507BE0(a3, v11);
          continue;
        }
        sub_67D2788(*(unsigned __int64 **)(a3 + 8), v11);
        v13 = (_QWORD *)(a3 + 8);
      }
      else
      {
        if ( v10 != 2 )
          continue;
        v12 = *(_QWORD *)(a2 + 8);
        if ( v12 == *(_QWORD *)(a2 + 16) )
        {
          sub_2507BE0(a2, v11);
          continue;
        }
        sub_67D2788(*(unsigned __int64 **)(a2 + 8), v11);
        v13 = (_QWORD *)(a2 + 8);
      }
    }
    else
    {
      v12 = *(_QWORD *)(a4 + 8);
      if ( v12 == *(_QWORD *)(a4 + 16) )
      {
        sub_2507BE0(a4, v11);
        continue;
      }
      sub_67D2788(*(unsigned __int64 **)(a4 + 8), v11);
      v13 = (_QWORD *)(a4 + 8);
    }
    *v13 = v12 + 24;
  }
  return sub_67D19BC(v4);
}


================================================================================
Function: sub_6559560 (0x6559560)
================================================================================

__int64 __fastcall sub_6559560(__int64 a1)
{
  pthread_mutex_t *v1; // x20
  __int64 v3; // x19

  v1 = (pthread_mutex_t *)(a1 + 40);
  sub_67D1968((pthread_mutex_t *)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 568);
  sub_67D19BC(v1);
  return v3;
}


================================================================================
Function: sub_655E930 (0x655E930)
================================================================================

bool __fastcall sub_655E930(__int64 a1)
{
  return (sub_67617C4(a1, 0LL) & 0xFFFFFFFELL) != 0;
}


================================================================================
Function: sub_655E950 (0x655E950)
================================================================================

bool __fastcall sub_655E950(__int64 a1, __int64 a2)
{
  return (sub_67617C4(a1, a2) & 0xFFFFFFFELL) != 0;
}


================================================================================
Function: sub_655E9EC (0x655E9EC)
================================================================================

__int64 sub_655E9EC()
{
  return sub_6760348() & 1;
}


================================================================================
Function: sub_65631A0 (0x65631A0)
================================================================================

__int64 __fastcall sub_65631A0(__int64 a1, unsigned int a2)
{
  __int64 v4; // x0
  __int64 result; // x0

  v4 = sub_6575418();
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(v4 + 32) = 0LL;
  *(_QWORD *)(v4 + 40) = 256LL;
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  result = sub_65631F0(a2, v4);
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}


================================================================================
Function: sub_65631F0 (0x65631F0)
================================================================================

__int64 __fastcall sub_65631F0(int a1, __int64 a2)
{
  __int64 result; // x0
  __int64 (__fastcall **v4)(); // x8
  _QWORD *v5; // x19

  if ( a1 == 1 )
  {
    result = sub_6575418();
    *(_QWORD *)(result + 16) = a2;
    *(_DWORD *)(result + 8) = 4;
    *(_DWORD *)(result + 72) = 324;
    *(_OWORD *)(result + 24) = 0u;
    *(_QWORD *)(result + 56) = 0LL;
    *(_QWORD *)(result + 64) = 512LL;
    *(_OWORD *)(result + 40) = 0u;
    *(_WORD *)(result + 76) = 0x2000;
    v4 = off_6BAE8E0;
    *(_QWORD *)(result + 80) = 4LL;
  }
  else
  {
    if ( a1 )
    {
      v5 = (_QWORD *)sub_67EAFB8(16LL);
      sub_67D2554(v5, "Unsupported Writer::Type.");
      sub_67EB030((__int64)v5, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_67EE34C);
    }
    result = sub_6575418();
    *(_QWORD *)(result + 16) = a2;
    *(_BYTE *)(result + 76) = 0;
    *(_DWORD *)(result + 8) = 4;
    *(_DWORD *)(result + 72) = 324;
    *(_OWORD *)(result + 24) = 0u;
    *(_QWORD *)(result + 56) = 0LL;
    *(_QWORD *)(result + 64) = 512LL;
    *(_OWORD *)(result + 40) = 0u;
    v4 = off_6BAE7E0;
  }
  *(_QWORD *)result = v4;
  return result;
}


================================================================================
Function: sub_6563344 (0x6563344)
================================================================================

__int64 __fastcall sub_6563344(__int64 *a1)
{
  __int64 result; // x0
  __int64 v3; // x19

  result = a1[1];
  if ( result )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)result + 8LL))(result);
  v3 = *a1;
  if ( v3 )
  {
    sub_6574E40(*(_QWORD *)(v3 + 16));
    if ( *(_QWORD *)(v3 + 8) )
      sub_6575460();
    return sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_65633A4 (0x65633A4)
================================================================================

__int64 __fastcall sub_65633A4(__int64 a1)
{
  int v1; // w8
  __int64 *v3; // x0
  __int64 v4; // x9

  v1 = *(_DWORD *)(a1 + 16);
  v3 = *(__int64 **)(a1 + 8);
  v4 = *v3;
  *(_DWORD *)(a1 + 16) = v1 + 1;
  (*(void (__fastcall **)(__int64 *))(v4 + 16))(v3);
  return a1;
}


================================================================================
Function: sub_65633E0 (0x65633E0)
================================================================================

__int64 __fastcall sub_65633E0(__int64 a1)
{
  int v1; // w8
  _QWORD *v4; // x19

  v1 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v1 - 1;
  if ( v1 <= 0 )
  {
    v4 = (_QWORD *)sub_67EAFB8(16LL);
    sub_67D2554(v4, "RBX::json::Writer depth underflow");
    sub_67EB030((__int64)v4, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_67EE34C);
  }
  (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 32LL))(*(_QWORD *)(a1 + 8), 0LL);
  return a1;
}


================================================================================
Function: sub_656346C (0x656346C)
================================================================================

__int64 __fastcall sub_656346C(__int64 a1)
{
  int v1; // w8
  __int64 *v3; // x0
  __int64 v4; // x9

  v1 = *(_DWORD *)(a1 + 16);
  v3 = *(__int64 **)(a1 + 8);
  v4 = *v3;
  *(_DWORD *)(a1 + 16) = v1 + 1;
  (*(void (__fastcall **)(__int64 *))(v4 + 40))(v3);
  return a1;
}


================================================================================
Function: sub_65634A8 (0x65634A8)
================================================================================

__int64 __fastcall sub_65634A8(__int64 a1)
{
  int v1; // w8
  _QWORD *v4; // x19

  v1 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v1 - 1;
  if ( v1 <= 0 )
  {
    v4 = (_QWORD *)sub_67EAFB8(16LL);
    sub_67D2554(v4, "RBX::json::Writer depth underflow");
    sub_67EB030((__int64)v4, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_67EE34C);
  }
  (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 48LL))(*(_QWORD *)(a1 + 8), 0LL);
  return a1;
}


================================================================================
Function: sub_656398C (0x656398C)
================================================================================

__int64 __fastcall sub_656398C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  (*(void (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(**(_QWORD **)(a1 + 8) + 72LL))(
    *(_QWORD *)(a1 + 8),
    a2,
    a3,
    0LL);
  (*(void (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(**(_QWORD **)(a1 + 8) + 72LL))(
    *(_QWORD *)(a1 + 8),
    a4,
    a5,
    0LL);
  return a1;
}


================================================================================
Function: sub_65639EC (0x65639EC)
================================================================================

__int64 __fastcall sub_65639EC(__int64 a1, double a2)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 64LL))(*(_QWORD *)(a1 + 8));
  (*(void (__fastcall **)(_QWORD, double))(**(_QWORD **)(a1 + 8) + 120LL))(*(_QWORD *)(a1 + 8), a2);
  return a1;
}


================================================================================
Function: sub_6563B74 (0x6563B74)
================================================================================

__int64 __fastcall sub_6563B74(__int64 a1, __int64 a2, unsigned int a3)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 80LL))(*(_QWORD *)(a1 + 8));
  (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 88LL))(*(_QWORD *)(a1 + 8), a3);
  return a1;
}


================================================================================
Function: sub_6563F48 (0x6563F48)
================================================================================

__int64 __fastcall sub_6563F48(_DWORD *a1)
{
  __int64 v1; // x19
  _BYTE *v2; // x8
  __int64 result; // x0
  _QWORD *v4; // x19

  if ( a1[4] )
  {
    v4 = (_QWORD *)sub_67EAFB8(16LL);
    sub_67D2554(v4, "RBX::json::Writer stack is not balanced!");
    sub_67EB030((__int64)v4, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_67EE34C);
  }
  v1 = *(_QWORD *)a1;
  v2 = *(_BYTE **)(*(_QWORD *)a1 + 24LL);
  if ( (unsigned __int64)(v2 + 1) > *(_QWORD *)(*(_QWORD *)a1 + 32LL) )
  {
    sub_65648B8(*(_QWORD *)a1, 1LL);
    v2 = *(_BYTE **)(v1 + 24);
  }
  *(_QWORD *)(v1 + 24) = v2 + 1;
  *v2 = 0;
  result = *(_QWORD *)(v1 + 16);
  --*(_QWORD *)(v1 + 24);
  return result;
}


================================================================================
Function: sub_6563FEC (0x6563FEC)
================================================================================

__int64 __fastcall sub_6563FEC(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 24LL) - *(_QWORD *)(*(_QWORD *)a1 + 16LL);
}


================================================================================
Function: sub_65648B8 (0x65648B8)
================================================================================

__int64 __fastcall sub_65648B8(__int64 *a1, __int64 a2)
{
  __int64 v3; // x20
  unsigned __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x0
  __int64 v8; // x22
  unsigned __int64 v9; // x21
  __int64 result; // x0
  _QWORD *v11; // x19

  v3 = a1[2];
  if ( v3 )
  {
    v5 = a1[4] - v3 + ((unsigned __int64)(a1[4] - v3 + 1) >> 1);
    v6 = a1[2];
  }
  else
  {
    if ( !*a1 )
    {
      v7 = sub_6575418();
      *a1 = v7;
      a1[1] = v7;
    }
    v5 = a1[5];
    v6 = 0LL;
  }
  v8 = a1[3] - v6;
  if ( v5 >= v8 + a2 )
    v9 = v5;
  else
    v9 = v8 + a2;
  result = sub_6576B14(v3, v9);
  if ( !result )
  {
    v11 = (_QWORD *)sub_67EAFB8(8LL);
    sub_67EE258(v11);
    sub_67EB030((__int64)v11, (__int64)&`typeinfo for'std::bad_alloc, (__int64)sub_67EE220);
  }
  a1[2] = result;
  a1[3] = result + v8;
  a1[4] = result + v9;
  return result;
}


================================================================================
Function: sub_657489C (0x657489C)
================================================================================

__int64 sub_657489C()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_7280238);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280238) )
  {
    qword_7280218 = 0LL;
    unk_7280220 = 0LL;
    dword_7280230 = 0;
    qword_7280228 = 0LL;
    sub_65831F0();
    sub_67EB838(byte_7280238);
  }
  return *(unsigned int *)(sub_6583344((__int64)&qword_7280218) + 8);
}


================================================================================
Function: sub_6574924 (0x6574924)
================================================================================

__int64 __fastcall sub_6574924(int a1)
{
  unsigned __int8 v2; // w8
  __int64 v3; // x8
  __int64 result; // x0

  v2 = atomic_load(byte_7280238);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280238) )
  {
    qword_7280218 = 0LL;
    unk_7280220 = 0LL;
    dword_7280230 = 0;
    qword_7280228 = 0LL;
    sub_65831F0();
    sub_67EB838(byte_7280238);
  }
  v3 = sub_6583344((__int64)&qword_7280218);
  result = *(unsigned int *)(v3 + 8);
  *(_DWORD *)(v3 + 8) = a1;
  return result;
}


================================================================================
Function: sub_6574E40 (0x6574E40)
================================================================================

__int64 __fastcall sub_6574E40(__int64 result)
{
  __int64 v1; // x19
  unsigned __int64 v2; // x20
  __int64 v3; // x1
  unsigned __int8 v4; // w8
  __int64 v5; // [xsp+8h] [xbp-38h] BYREF
  __int64 v6; // [xsp+10h] [xbp-30h]
  __int64 v7; // [xsp+18h] [xbp-28h]

  if ( result )
  {
    v1 = result;
    v2 = sub_677D9B8();
    sub_654AB8C(&v5, 0LL, 0LL, 0LL);
    v6 = sub_6586C70(v1, v2);
    v7 = v3;
    sub_67F0410(-(__int64)v2, (char *)&unk_7270200 + 64 * (unsigned __int64)(unsigned int)v6 + 16);
    v4 = atomic_load((unsigned __int8 *)&byte_7280240);
    if ( (v4 & 1) != 0 && qword_7280250 > v2 )
      sub_67F0410(-(__int64)v2, &qword_7280250);
    sub_677CBEC(v1);
    return sub_654ABA8(&v5, v2);
  }
  return result;
}


================================================================================
Function: sub_6575418 (0x6575418)
================================================================================

__int64 sub_6575418()
{
  __int64 result; // x0
  __int64 v1; // x19

  result = sub_6575DF4();
  if ( !result )
  {
    v1 = sub_67EAFB8(8LL);
    sub_67EE258();
    sub_67EB030(v1, &`typeinfo for'std::bad_alloc, sub_67EE220);
  }
  return result;
}


================================================================================
Function: sub_6575460 (0x6575460)
================================================================================

__int64 sub_6575460()
{
  return sub_6574E40();
}


================================================================================
Function: sub_6575DF4 (0x6575DF4)
================================================================================

__int64 __fastcall sub_6575DF4(unsigned __int64 a1)
{
  __int64 v1; // x19
  __int64 v2; // x0
  __int64 v3; // x0
  __int64 v4; // x20
  char *v5; // x21
  __int64 v6; // x22
  __int64 v7; // x0
  char *v8; // x21
  unsigned __int64 v9; // x23
  unsigned __int64 v10; // t1
  unsigned __int64 v11; // x22
  unsigned __int64 v12; // x0
  unsigned __int8 v13; // w8
  __int64 v15; // [xsp+0h] [xbp-50h] BYREF
  unsigned int v16[10]; // [xsp+8h] [xbp-48h] BYREF
  _BYTE v17[24]; // [xsp+30h] [xbp-20h] BYREF

  if ( a1 > 0xFFFFFFFFFFFFFFF6LL )
    return 0LL;
  sub_654AA6C(&v15, 0LL, 0LL, a1, 0LL);
  v2 = sub_654AA10(&v15);
  v3 = sub_677CA08(v2);
  v1 = v3;
  if ( v3 )
  {
    v4 = sub_677D9B8(v3);
    sub_654AAF0(&v15, v4);
    sub_6586BF8(v17, v16);
    sub_6586C3C(v1, v4, v17);
    v5 = (char *)&unk_7270200 + 64 * (unsigned __int64)v16[0];
    v6 = sub_67F0410(v4, v5 + 16);
    v7 = sub_67F0410(1LL, v5 + 32);
    if ( (sub_654AC38(v7) & 1) != 0 )
    {
      v10 = *((_QWORD *)v5 + 6);
      v8 = v5 + 48;
      v9 = v10;
      v11 = v6 + v4;
      if ( v10 < v11 )
      {
        do
        {
          v12 = sub_67EFF50(v9, v11, v8);
          if ( v12 == v9 )
            break;
          v9 = v12;
        }
        while ( v12 < v11 );
      }
    }
    v13 = atomic_load((unsigned __int8 *)&byte_7280240);
    if ( (v13 & 1) != 0 )
    {
      sub_67F0410(v4, &qword_7280250);
      if ( qword_7280250 >= (unsigned __int64)qword_7280248 && (unsigned int)sub_67EFD50(1LL, 0LL, &byte_7280240) == 1 )
      {
        if ( !qword_72701C0 )
          sub_24EA5A8();
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_72701C0 + 48LL))(qword_72701C0);
        atomic_store(0LL, (unsigned __int64 *)&qword_7280250);
        byte_7280240 = 1;
      }
    }
  }
  return v1;
}


================================================================================
Function: sub_6575FA8 (0x6575FA8)
================================================================================

__int64 __fastcall sub_6575FA8(unsigned __int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 v4; // x0
  __int64 v5; // x0
  __int64 v6; // x20
  char *v7; // x21
  unsigned __int64 v8; // x22
  atomic_ullong *v9; // x21
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // t1
  unsigned __int64 v12; // x22
  unsigned __int64 v13; // x0
  unsigned __int8 v14; // w8
  __int64 v16; // [xsp+0h] [xbp-50h] BYREF
  _DWORD v17[10]; // [xsp+8h] [xbp-48h] BYREF
  _DWORD v18[6]; // [xsp+30h] [xbp-20h] BYREF

  if ( a1 > 0xFFFFFFFFFFFFFFF6LL )
    return 0LL;
  sub_654AA6C(0, 2, a1, 0, (__int64)&v16);
  v4 = sub_654AA10(&v16);
  v5 = sub_677D480(v4, a2);
  v2 = v5;
  if ( v5 )
  {
    v6 = sub_677D9B8(v5);
    sub_654AAF0((__int64)&v16, v6);
    sub_6586BF8(v18, v17);
    sub_6586C3C(v2, v6, v18);
    v7 = (char *)&unk_7270200 + 64 * (unsigned __int64)v17[0];
    v8 = sub_67F0410(v6, (atomic_ullong *)(v7 + 16));
    sub_67F0410(1uLL, (atomic_ullong *)(v7 + 32));
    if ( sub_654AC38() )
    {
      v11 = *((_QWORD *)v7 + 6);
      v9 = (atomic_ullong *)(v7 + 48);
      v10 = v11;
      v12 = v8 + v6;
      if ( v11 < v12 )
      {
        do
        {
          v13 = sub_67EFF50(v10, v12, v9);
          if ( v13 == v10 )
            break;
          v10 = v13;
        }
        while ( v13 < v12 );
      }
    }
    v14 = atomic_load((unsigned __int8 *)&byte_7280240);
    if ( (v14 & 1) != 0 )
    {
      sub_67F0410(v6, (atomic_ullong *)&qword_7280250);
      if ( qword_7280250 >= (unsigned __int64)qword_7280248 && sub_67EFD50(1, 0, (atomic_uchar *)&byte_7280240) == 1 )
      {
        if ( !qword_72701C0 )
          sub_24EA5A8();
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_72701C0 + 48LL))(qword_72701C0);
        atomic_store(0LL, (unsigned __int64 *)&qword_7280250);
        byte_7280240 = 1;
      }
    }
  }
  return v2;
}


================================================================================
Function: sub_6576B14 (0x6576B14)
================================================================================

__int64 __fastcall sub_6576B14(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x19
  unsigned __int64 v4; // x20
  __int64 v5; // x1
  unsigned __int8 v6; // w8
  __int64 v7; // x0
  __int64 v8; // x0
  __int64 v9; // x20
  char *v10; // x21
  unsigned __int64 v11; // x22
  atomic_ullong *v12; // x21
  unsigned __int64 v13; // x23
  unsigned __int64 v14; // t1
  unsigned __int64 v15; // x22
  unsigned __int64 v16; // x0
  unsigned __int8 v17; // w8
  __int64 v19; // [xsp+C0h] [xbp-68h] BYREF
  __int64 v20; // [xsp+C8h] [xbp-60h] BYREF
  int v21; // [xsp+F0h] [xbp-38h] BYREF
  __int64 v22; // [xsp+F8h] [xbp-30h]
  __int64 v23; // [xsp+100h] [xbp-28h]

  if ( a2 > 0xFFFFFFFFFFFFFFF6LL )
    return 0LL;
  sub_654AA6C(0, 1, a2, 0, (__int64)&v19);
  if ( a1 )
  {
    sub_654AB8C(0, 1, 0, (__int64)&v21);
    v4 = sub_677D9B8(a1);
    v22 = sub_6586C70(a1, v4);
    v23 = v5;
    sub_67F0410(-(__int64)v4, (atomic_ullong *)((char *)&unk_7270200 + 64 * (unsigned __int64)(unsigned int)v22 + 16));
    v6 = atomic_load((unsigned __int8 *)&byte_7280240);
    if ( (v6 & 1) != 0 && qword_7280250 > v4 )
      sub_67F0410(-(__int64)v4, (atomic_ullong *)&qword_7280250);
    sub_654ABA8((__int64)&v21, v4);
  }
  v7 = sub_654AA10(&v19);
  v8 = sub_677CB8C(a1, v7);
  v2 = v8;
  if ( v8 )
  {
    v9 = sub_677D9B8(v8);
    sub_654AAF0((__int64)&v19, v9);
    sub_6586BF8(&v21, &v20);
    sub_6586C3C(v2, v9, &v21);
    v10 = (char *)&unk_7270200 + 64 * (unsigned __int64)(unsigned int)v20;
    v11 = sub_67F0410(v9, (atomic_ullong *)(v10 + 16));
    sub_67F0410(1uLL, (atomic_ullong *)(v10 + 32));
    if ( sub_654AC38() )
    {
      v14 = *((_QWORD *)v10 + 6);
      v12 = (atomic_ullong *)(v10 + 48);
      v13 = v14;
      v15 = v11 + v9;
      if ( v14 < v15 )
      {
        do
        {
          v16 = sub_67EFF50(v13, v15, v12);
          if ( v16 == v13 )
            break;
          v13 = v16;
        }
        while ( v16 < v15 );
      }
    }
    v17 = atomic_load((unsigned __int8 *)&byte_7280240);
    if ( (v17 & 1) != 0 )
    {
      sub_67F0410(v9, (atomic_ullong *)&qword_7280250);
      if ( qword_7280250 >= (unsigned __int64)qword_7280248 && sub_67EFD50(1, 0, (atomic_uchar *)&byte_7280240) == 1 )
      {
        if ( !qword_72701C0 )
          sub_24EA5A8();
        (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_72701C0 + 48LL))(qword_72701C0);
        atomic_store(0LL, (unsigned __int64 *)&qword_7280250);
        byte_7280240 = 1;
      }
    }
  }
  return v2;
}


================================================================================
Function: sub_6577314 (0x6577314)
================================================================================

__int64 __fastcall sub_6577314(unsigned __int64 a1)
{
  __int64 result; // x0
  _QWORD *v2; // x19

  result = sub_6575DF4(a1);
  if ( !result )
  {
    v2 = (_QWORD *)sub_67EAFB8(8LL);
    sub_67EE258(v2);
    sub_67EB030((__int64)v2, (__int64)&`typeinfo for'std::bad_alloc, (__int64)sub_67EE220);
  }
  return result;
}


================================================================================
Function: sub_657738C (0x657738C)
================================================================================

__int64 __fastcall sub_657738C(__int64 a1)
{
  return sub_6574E40(a1);
}


================================================================================
Function: sub_6577D64 (0x6577D64)
================================================================================

void *sub_6577D64()
{
  return &unk_7280258;
}


================================================================================
Function: sub_6577DB4 (0x6577DB4)
================================================================================

__int64 __fastcall sub_6577DB4(pthread_mutex_t *a1)
{
  unsigned __int64 v3; // x20
  __int64 result; // x0
  __int64 v5; // x0

  if ( !byte_71CF7B0 )
    return sub_67D1968(a1);
  if ( !byte_7280278 || dword_7280264 == 0 )
    return sub_67D1968(a1);
  v3 = dword_7280264;
  if ( sub_67F0410(1uLL, (atomic_ullong *)&unk_7280348) % v3 )
    return sub_67D1968(a1);
  result = sub_67D1994(a1);
  if ( (result & 1) == 0 )
  {
    sub_6580674(result);
    v5 = sub_67D1968(a1);
    sub_6580674(v5);
    JUMPOUT(0x65780ACLL);
  }
  return result;
}


================================================================================
Function: sub_6577E74 (0x6577E74)
================================================================================

__int64 __fastcall sub_6577E74(__int64 a1)
{
  unsigned __int64 v3; // x20
  __int64 result; // x0
  double v5; // d8
  __int64 v6; // x0
  double v7; // d0
  int v8; // w8
  int v9; // w9
  int v10; // w10
  int v11; // w11
  int v12; // w8
  int v13; // w9
  int v14; // w8
  int v15; // w10
  int v16; // w8
  int v17; // w11
  int v18; // w8
  int v19; // w9
  int v20; // w8
  int v21; // w10
  int v22; // w8
  int v23; // w11
  __int64 vars10; // [xsp+30h] [xbp+10h]
  __int64 vars18; // [xsp+38h] [xbp+18h]

  if ( !byte_71CF7B0 )
    return sub_67D1AC8(a1);
  if ( !byte_7280278 || dword_7280264 == 0 )
    return sub_67D1AC8(a1);
  v3 = dword_7280264;
  if ( sub_67F0410(1uLL, (atomic_ullong *)&unk_7280348) % v3 )
    return sub_67D1AC8(a1);
  result = sub_67D1B14(a1);
  if ( (result & 1) == 0 )
  {
    v5 = ((double (*)(void))sub_6580674)();
    v6 = sub_67D1AC8(a1);
    v7 = sub_6580674(v6) - v5;
    vars10 = vars18;
    result = sub_67F0470(1LL, qword_72802B0, v7);
    if ( result == -1 )
    {
      do
      {
        atomic_store(0LL, qword_72802B0);
        atomic_store(0LL, &qword_72802B0[1]);
        atomic_store(0LL, &qword_72802B0[2]);
        atomic_store(0LL, &qword_72802B0[3]);
        atomic_store(0LL, &qword_72802B0[4]);
        atomic_store(0LL, &qword_72802B0[5]);
        atomic_store(0LL, &qword_72802B0[6]);
        atomic_store(0LL, &qword_72802B0[7]);
        atomic_store(0LL, &qword_72802B0[8]);
        atomic_store(0LL, &qword_72802B0[9]);
        v8 = atomic_load(qword_72802B0);
        v9 = atomic_load(&qword_72802B0[1]);
        v10 = atomic_load(&qword_72802B0[2]);
        v11 = atomic_load(&qword_72802B0[3]);
        v12 = v9 + v8;
        v13 = atomic_load(&qword_72802B0[4]);
        v14 = v12 + v10;
        v15 = atomic_load(&qword_72802B0[5]);
        v16 = v14 + v11;
        v17 = atomic_load(&qword_72802B0[6]);
        v18 = v16 + v13;
        v19 = atomic_load(&qword_72802B0[7]);
        v20 = v18 + v15;
        v21 = atomic_load(&qword_72802B0[8]);
        v22 = v20 + v17;
        v23 = atomic_load(&qword_72802B0[9]);
      }
      while ( v22 + v19 + v21 + v23 );
    }
  }
  return result;
}


================================================================================
Function: sub_65786C4 (0x65786C4)
================================================================================

__int64 __fastcall sub_65786C4(unsigned int a1)
{
  int v1; // w8

  if ( a1 >= 8 )
    v1 = 8;
  else
    v1 = a1;
  return sub_6578E50(off_6BAEA60[v1]);
}


================================================================================
Function: sub_6578E50 (0x6578E50)
================================================================================

__int64 __fastcall sub_6578E50(_BYTE *a1, char *a2)
{
  __int64 result; // x0
  __int64 v5; // x3
  __int64 v6; // x4
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  long double v10; // q0
  long double v11; // q1
  long double v12; // q2
  long double v13; // q3
  char *v14; // x1
  unsigned __int64 v15; // x2
  char *v16; // x1
  unsigned __int64 v17; // x2
  __int64 v18; // [xsp+0h] [xbp-50h] BYREF
  unsigned __int64 v19; // [xsp+8h] [xbp-48h]
  char *v20; // [xsp+10h] [xbp-40h]
  _BYTE *v21; // [xsp+20h] [xbp-30h] BYREF
  unsigned __int64 v22; // [xsp+28h] [xbp-28h]
  char *v23; // [xsp+30h] [xbp-20h]
  __int64 v24; // [xsp+38h] [xbp-18h]

  if ( off_7280408 )
  {
    result = off_7280408(a1, a2);
    if ( (result & 1) == 0 )
      return result;
  }
  result = sub_65790A4();
  if ( !(_DWORD)result )
    return result;
  if ( a1 && a2 )
  {
    if ( *a1 )
    {
      if ( *a2 )
      {
        sub_654E814(
          774LL,
          (__int64)"Unknown",
          "[LOGCHANNELS + 1] RBXCRASH: %s (%s)",
          (__int64)a1,
          (__int64)a2,
          v7,
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v18);
        v21 = a1;
        v22 = 0LL;
        v23 = a2;
        v24 = 0LL;
        sub_678FFAC(&v18, "RBXCRASH: {} ({})\n", 18LL, 204LL, &v21);
        if ( (v18 & 1) != 0 )
          v14 = v20;
        else
          v14 = (char *)&v18 + 1;
        if ( (v18 & 1) != 0 )
          v15 = v19;
        else
          v15 = (unsigned __int64)(unsigned __int8)v18 >> 1;
        sub_2511460(&qword_795C7B0, v14, v15);
        if ( (v18 & 1) != 0 )
          goto LABEL_31;
        goto LABEL_32;
      }
      goto LABEL_18;
    }
  }
  else if ( a1 && *a1 )
  {
LABEL_18:
    sub_654E814(
      774LL,
      (__int64)"Unknown",
      "[LOGCHANNELS + 1] RBXCRASH: %s",
      (__int64)a1,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v18);
    v18 = (__int64)a1;
    v19 = 0LL;
    sub_678FFAC(&v21, "RBXCRASH: {}\n", 13LL, 12LL, &v18);
    if ( ((unsigned __int8)v21 & 1) != 0 )
      v16 = v23;
    else
      v16 = (char *)&v21 + 1;
    if ( ((unsigned __int8)v21 & 1) != 0 )
      v17 = v22;
    else
      v17 = (unsigned __int64)(unsigned __int8)v21 >> 1;
    goto LABEL_30;
  }
  sub_654E814(774LL, (__int64)"Unknown", "[LOGCHANNELS + 1] RBXCRASH", v5, v6, v7, v8, v9, v10, v11, v12, v13, v18);
  sub_678FFAC(&v21, "RBXCRASH\n", 9LL, 0LL, &v18);
  if ( ((unsigned __int8)v21 & 1) != 0 )
    v16 = v23;
  else
    v16 = (char *)&v21 + 1;
  if ( ((unsigned __int8)v21 & 1) != 0 )
    v17 = v22;
  else
    v17 = (unsigned __int64)(unsigned __int8)v21 >> 1;
LABEL_30:
  sub_2511460(&qword_795C7B0, v16, v17);
  if ( ((unsigned __int8)v21 & 1) != 0 )
LABEL_31:
    sub_6575460();
LABEL_32:
  if ( byte_71CF7B0 )
  {
    if ( byte_7280398 )
      abort();
  }
  return raise(5);
}


================================================================================
Function: sub_65790A4 (0x65790A4)
================================================================================

__int64 sub_65790A4()
{
  return (unsigned __int8)byte_6C30224;
}


================================================================================
Function: sub_65790B0 (0x65790B0)
================================================================================

__int64 sub_65790B0()
{
  return getpid();
}


================================================================================
Function: sub_6579128 (0x6579128)
================================================================================

pthread_t sub_6579128()
{
  return pthread_self();
}


================================================================================
Function: sub_6579B30 (0x6579B30)
================================================================================

unsigned __int8 *__fastcall sub_6579B30(unsigned __int8 *result, char *format, __int128 *a3)
{
  unsigned __int8 *v5; // x20
  int v6; // w0
  unsigned __int64 v7; // x9
  unsigned int v8; // w10
  __int64 v9; // x24
  unsigned __int64 v10; // x25
  __int128 v11; // q1
  unsigned __int8 *v12; // x8
  __int128 v13; // [xsp+10h] [xbp-40h]
  __int128 arg; // [xsp+20h] [xbp-30h] BYREF
  __int128 v15; // [xsp+30h] [xbp-20h]

  if ( format )
  {
    v5 = result;
    v13 = a3[1];
    arg = *a3;
    v15 = v13;
    v6 = vsnprintf(0LL, 0LL, format, &arg);
    v7 = *v5;
    v8 = v6 & ~(v6 >> 31);
    if ( v8 >= 0xF4240 )
      v9 = 1000000LL;
    else
      v9 = v8;
    if ( (v7 & 1) != 0 )
      v10 = *((_QWORD *)v5 + 1);
    else
      v10 = v7 >> 1;
    sub_67D36F0(v5, v10 + v9, 0);
    v11 = a3[1];
    if ( (*v5 & 1) != 0 )
      v12 = (unsigned __int8 *)*((_QWORD *)v5 + 2);
    else
      v12 = v5 + 1;
    arg = *a3;
    v15 = v11;
    vsnprintf((char *)&v12[v10], (unsigned int)(v9 + 1), format, &arg);
    return sub_67D36F0(v5, v10 + v9, 0);
  }
  return result;
}


================================================================================
Function: sub_6579C34 (0x6579C34)
================================================================================

void __noreturn sub_6579C34(char *format, ...)
{
  _QWORD *v1; // x20
  gcc_va_list va1; // [xsp+C0h] [xbp-60h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-38h] BYREF
  _QWORD v4[3]; // [xsp+108h] [xbp-18h] BYREF

  va_start(va, format);
  memset(v4, 0, sizeof(v4));
  va_copy(va1, va);
  sub_6579B30((unsigned __int8 *)v4, format, (__int128 *)va1);
  v1 = (_QWORD *)sub_67EAFB8(16LL);
  sub_67D24BC(v1, (char *)v4);
  sub_67EB030((__int64)v1, (__int64)&`typeinfo for'std::runtime_error, (__int64)sub_67EE34C);
}


================================================================================
Function: sub_6579D18 (0x6579D18)
================================================================================

__int64 __usercall sub_6579D18@<X0>(char *format@<X0>, _QWORD *a2@<X8>, ...)
{
  gcc_va_list va1; // [xsp+C0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-28h] BYREF

  va_start(va, a2);
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  va_copy(va1, va);
  return sub_6579B30((int)a2, format);
}


================================================================================
Function: sub_6579F14 (0x6579F14)
================================================================================

__int64 __fastcall sub_6579F14(int a1, int a2)
{
  int v2; // w8

  v2 = a1 - 1;
  if ( a1 - 1 >= a2 )
    v2 = a2;
  return v2 & (unsigned int)~(v2 >> 31);
}


================================================================================
Function: sub_6579F94 (0x6579F94)
================================================================================

unsigned __int64 sub_6579F94()
{
  __int64 v0; // x21
  __int64 v1; // x21
  __int64 v2; // x0
  __int64 v3; // x21
  int v4; // w0
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x10
  unsigned __int64 v8; // [xsp+0h] [xbp-10h] BYREF

  v8 = qword_7280448;
  if ( !qword_7280448 )
  {
    v0 = 7 * sub_67A2CE8();
    v1 = v0 ^ (97 * sub_67A2C10());
    v2 = sub_65790B0();
    v3 = (997LL * (int)v2) ^ v1 ^ (1997 * sub_6579128(v2));
    v8 = (unsigned __int64)&v8 ^ ((_QWORD)&qword_7280448 << 32) ^ (19997 * sub_65803EC()) ^ v3;
  }
  v4 = sub_67F03E0(1u, (atomic_uint *)&unk_7280450);
  v5 = v8 ^ (unsigned int)(2 * v4);
  v6 = 0x5851F42D4C957F2DLL * v5 + 105;
  qword_7280448 = 0x5851F42D4C957F2DLL * v6 + 105;
  return (unsigned int)__ROR4__((v5 >> 27) ^ (v8 >> 45), v8 >> 59) | ((unsigned __int64)(unsigned int)__ROR4__((v6 >> 45) ^ (v6 >> 27), v6 >> 59) << 32);
}


================================================================================
Function: sub_657A0FC (0x657A0FC)
================================================================================

__int64 sub_657A0FC()
{
  unsigned __int8 v0; // w8
  unsigned __int8 v1; // w8
  unsigned int v2; // w19

  v0 = atomic_load(byte_7280490);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280490) )
  {
    __cxa_atexit((void (*)(void *))sub_67D1C6C, &stru_7280468, &off_67F7780);
    sub_67EB838(byte_7280490);
  }
  sub_67D1968(&stru_7280468);
  v1 = atomic_load(byte_7280460);
  if ( (v1 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280460) )
  {
    qword_7280458 = sub_6579F94();
    sub_67EB838(byte_7280460);
  }
  v2 = __ROR4__(
         ((unsigned __int64)qword_7280458 >> 45) ^ ((unsigned __int64)qword_7280458 >> 27),
         (unsigned __int64)qword_7280458 >> 59);
  qword_7280458 = 0x5851F42D4C957F2DLL * qword_7280458 + 105;
  sub_67D19BC(&stru_7280468);
  return v2;
}


================================================================================
Function: sub_657C5C4 (0x657C5C4)
================================================================================

unsigned int **__fastcall sub_657C5C4(unsigned int **result)
{
  unsigned int *v1; // x20
  unsigned int v2; // w21
  unsigned int ***v3; // x19
  unsigned int **v4; // [xsp+0h] [xbp-10h]

  v1 = *result;
  if ( *result )
  {
    v2 = atomic_load(v1);
    if ( v2 )
    {
      v3 = (unsigned int ***)result;
      while ( 1 )
      {
        result = (unsigned int **)sub_67EFF10(v2, v2 + 1, v1);
        if ( (_DWORD)result == v2 )
          break;
        v2 = (unsigned int)result;
        if ( !(_DWORD)result )
          return result;
      }
      result = *v3;
      v4 = *v3;
      if ( *v3 )
      {
        sub_657C6CC();
        result = (unsigned int **)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)v4);
        if ( (_DWORD)result == 1 )
        {
          sub_657CF78(v4);
          result = (unsigned int **)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)((char *)v4 + 4));
          if ( (_DWORD)result == 1 )
            return (unsigned int **)sub_657E090(v4);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_657C6CC (0x657C6CC)
================================================================================

__int64 __fastcall sub_657C6CC(__int64 a1)
{
  unsigned __int8 v2; // w8
  pthread_mutex_t *v3; // x20
  unsigned int *v4; // x21
  unsigned int v5; // w22
  unsigned int v6; // w0
  __int64 v8; // x0

  v2 = atomic_load(byte_72805C8);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_72805C8) )
  {
    v8 = sub_6575418();
    *(_QWORD *)(v8 + 32) = 0LL;
    qword_72805C0 = v8;
    *(_OWORD *)v8 = 0u;
    *(_OWORD *)(v8 + 16) = 0u;
    sub_67EB838(byte_72805C8);
  }
  v3 = (pthread_mutex_t *)qword_72805C0;
  sub_67D1968((pthread_mutex_t *)qword_72805C0);
  v4 = *(unsigned int **)(a1 + 32);
  if ( v4 )
  {
    v5 = atomic_load(v4);
    if ( v5 )
    {
      while ( 1 )
      {
        v6 = sub_67EFF10(v5, v5 + 1, v4);
        if ( v6 == v5 )
          break;
        v5 = v6;
        if ( !v6 )
        {
          v4 = 0LL;
          goto LABEL_8;
        }
      }
      v4 = *(unsigned int **)(a1 + 32);
    }
    else
    {
      v4 = 0LL;
    }
  }
LABEL_8:
  if ( !v4 )
    return sub_67D19BC(v3);
  sub_657CE74(v4, a1);
  sub_67D19BC(v3);
  return sub_657E5C0(v4);
}


================================================================================
Function: sub_657CC24 (0x657CC24)
================================================================================

bool __fastcall sub_657CC24(unsigned int **a1, unsigned int **a2)
{
  unsigned int *v2; // x21
  unsigned int v4; // w22
  unsigned int v6; // w0
  unsigned int *v7; // x19
  unsigned int *v8; // x21
  unsigned int v9; // w22
  unsigned int v10; // w0
  unsigned int *v11; // x20

  v2 = *a1;
  if ( *a1 && (v4 = atomic_load(v2)) != 0 )
  {
    while ( 1 )
    {
      v6 = sub_67EFF10(v4, v4 + 1, v2);
      if ( v6 == v4 )
        break;
      v4 = v6;
      if ( !v6 )
        goto LABEL_5;
    }
    v7 = *a1;
    v8 = *a2;
    if ( !*a2 )
      goto LABEL_11;
  }
  else
  {
LABEL_5:
    v7 = 0LL;
    v8 = *a2;
    if ( !*a2 )
    {
LABEL_11:
      v11 = 0LL;
      goto LABEL_12;
    }
  }
  v9 = atomic_load(v8);
  if ( !v9 )
    goto LABEL_11;
  while ( 1 )
  {
    v10 = sub_67EFF10(v9, v9 + 1, v8);
    if ( v10 == v9 )
      break;
    v9 = v10;
    if ( !v10 )
      goto LABEL_11;
  }
  v11 = *a2;
  if ( v11 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)v11) == 1 )
    {
      sub_657CF78(v11);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v11 + 1)) == 1 )
        sub_657E090(v11);
    }
  }
LABEL_12:
  if ( v7 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)v7) == 1 )
    {
      sub_657CF78(v7);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 1)) == 1 )
        sub_657E090(v7);
    }
  }
  return v7 != v11;
}


================================================================================
Function: sub_657CD4C (0x657CD4C)
================================================================================

__int64 *__fastcall sub_657CD4C(__int64 *a1, __int64 *a2)
{
  __int64 v3; // x20
  __int64 v4; // x21

  v3 = *a1;
  v4 = *a2;
  if ( *a1 && (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v3 + 4)) == 1 )
    sub_657E090(v3);
  *a1 = v4;
  if ( v4 )
    sub_67F03E0(1u, (atomic_uint *)(v4 + 4));
  return a1;
}


================================================================================
Function: sub_657CE74 (0x657CE74)
================================================================================

__int64 __fastcall sub_657CE74(__int64 result, _QWORD *a2)
{
  __int64 v3; // x21
  __int64 v4; // x20
  unsigned int v5; // w21
  int v6; // w22
  __int64 v7; // x8
  __int64 *v8; // x9
  __int64 v9; // x20

  v3 = a2[4];
  v4 = result;
  a2[4] = 0LL;
  if ( v3 )
  {
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v3 + 4));
    if ( (_DWORD)result == 1 )
      result = sub_657DB34(v3);
  }
  v5 = *(_DWORD *)(v4 + 20);
  v6 = *(_DWORD *)(v4 + 16);
  if ( (v6 & v5) != 0 )
  {
    while ( 1 )
    {
      result = sub_67EFE50(v5, v5 | 0x80000000, v4 + 20);
      if ( (_DWORD)result == v5 )
        break;
      v5 = result;
      if ( (v6 & (unsigned int)result) == 0 )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v7 = a2[2];
    if ( v7 )
      *(_QWORD *)(v7 + 24) = a2[3] & 0xFFFFFFFFFFFFFFF8LL | *(_QWORD *)(v7 + 24) & 7LL;
    v8 = (__int64 *)((a2[3] & 0xFFFFFFFFFFFFFFF8LL) + 16);
    if ( (a2[3] & 0xFFFFFFFFFFFFFFF8LL) == 0 )
      v8 = (__int64 *)(v4 + 8);
    v9 = *v8;
    *v8 = v7;
    a2[2] = 0LL;
    if ( v9 )
    {
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)v9);
      if ( (_DWORD)result == 1 )
      {
        sub_657CF78(v9);
        result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v9 + 4));
        if ( (_DWORD)result == 1 )
          return sub_657E090((__int64 *)v9);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_657CF78 (0x657CF78)
================================================================================

__int64 __fastcall sub_657CF78(__int64 result)
{
  __int64 v1; // x19
  __int64 v2; // x20
  __int64 v3; // x19

  v1 = result;
  if ( (*(_BYTE *)(result + 24) & 4) != 0 )
    result = (*(__int64 (__fastcall **)(__int64))(result + 40))(result);
  v2 = *(_QWORD *)(v1 + 32);
  if ( v2 )
  {
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v2 + 4));
    if ( (_DWORD)result == 1 )
      result = sub_657DB34(v2);
  }
  v3 = *(_QWORD *)(v1 + 16);
  if ( v3 )
  {
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)v3);
    if ( (_DWORD)result == 1 )
    {
      sub_657CF78(v3);
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v3 + 4));
      if ( (_DWORD)result == 1 )
        return sub_657E090((__int64 *)v3);
    }
  }
  return result;
}


================================================================================
Function: sub_657D0F0 (0x657D0F0)
================================================================================

__int64 __fastcall sub_657D0F0(__int64 a1)
{
  unsigned __int8 v2; // w8
  pthread_mutex_t *v3; // x19
  unsigned int v4; // w21
  int v5; // w23
  unsigned int v6; // w0
  __int64 v7; // x21
  __int64 i; // x21
  __int64 result; // x0
  __int64 v10; // x8
  __int64 v11; // x20
  __int64 v12; // x0
  __int64 v13; // [xsp+0h] [xbp-10h]

  v2 = atomic_load(byte_72805C8);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_72805C8) )
  {
    v12 = sub_6575418();
    *(_QWORD *)(v12 + 32) = 0LL;
    qword_72805C0 = v12;
    *(_OWORD *)v12 = 0u;
    *(_OWORD *)(v12 + 16) = 0u;
    sub_67EB838(byte_72805C8);
  }
  v3 = (pthread_mutex_t *)qword_72805C0;
  sub_67D1968((pthread_mutex_t *)qword_72805C0);
  v4 = *(_DWORD *)(a1 + 20);
  v5 = *(_DWORD *)(a1 + 16);
  if ( (v5 & v4) != 0 )
  {
    while ( 1 )
    {
      v6 = sub_67EFE50(v4, v4 | 0x80000000, (atomic_uint *)(a1 + 20));
      if ( v6 == v4 )
        break;
      v4 = v6;
      if ( (v5 & v6) == 0 )
        goto LABEL_5;
    }
    for ( i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(i + 16) )
    {
      v11 = *(_QWORD *)(i + 32);
      *(_QWORD *)(i + 32) = 0LL;
      if ( v11 && (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v11 + 4)) == 1 )
        sub_657DB34((__int64 *)v11);
    }
    v7 = 0LL;
  }
  else
  {
LABEL_5:
    v7 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 8) = 0LL;
  }
  result = sub_67D19BC(v3);
  if ( v7 )
  {
    do
    {
      v10 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v7 + 16) = 0LL;
      v13 = v10;
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)v7);
      if ( (_DWORD)result == 1 )
      {
        sub_657CF78(v7);
        result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 4));
        if ( (_DWORD)result == 1 )
          result = sub_657E090((__int64 *)v7);
      }
      v7 = v13;
    }
    while ( v13 );
  }
  return result;
}


================================================================================
Function: sub_657D3C0 (0x657D3C0)
================================================================================

__int64 __fastcall sub_657D3C0(__int64 a1, __int64 a2)
{
  unsigned __int8 v4; // w8
  pthread_mutex_t *v5; // x20
  __int64 v6; // x23
  __int64 v7; // x22
  __int64 v8; // x8
  __int64 v9; // x21
  __int64 v11; // x0

  *(_QWORD *)(a2 + 24) &= 7uLL;
  v4 = atomic_load(byte_72805C8);
  if ( (v4 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_72805C8) )
  {
    v11 = sub_6575418();
    *(_QWORD *)(v11 + 32) = 0LL;
    qword_72805C0 = v11;
    *(_OWORD *)v11 = 0u;
    *(_OWORD *)(v11 + 16) = 0u;
    sub_67EB838(byte_72805C8);
  }
  v5 = (pthread_mutex_t *)qword_72805C0;
  sub_67D1968((pthread_mutex_t *)qword_72805C0);
  v6 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0LL;
  sub_67F03E0(1u, (atomic_uint *)a2);
  v7 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2;
  if ( v7 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)v7) == 1 )
    {
      sub_657CF78(v7);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 4)) == 1 )
        sub_657E090((__int64 *)v7);
    }
  }
  if ( v6 )
  {
    v8 = *(_QWORD *)(v6 + 24);
    v9 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = v6;
    *(_QWORD *)(v6 + 24) = v8 & 7 | a2;
    if ( v9 )
    {
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)v9) == 1 )
      {
        sub_657CF78(v9);
        if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v9 + 4)) == 1 )
          sub_657E090((__int64 *)v9);
      }
    }
  }
  return sub_67D19BC(v5);
}


================================================================================
Function: sub_657D974 (0x657D974)
================================================================================

__int64 sub_657D974()
{
  unsigned __int8 v0; // w8
  __int64 v1; // x20
  unsigned __int64 v2; // x22
  unsigned __int64 v3; // x21
  __int64 v4; // x8
  unsigned __int64 v5; // x8
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x0
  unsigned int v10; // w21
  unsigned int v11; // w0
  _QWORD *v12; // x20

  v0 = atomic_load(byte_72805F8);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_72805F8) )
  {
    v12 = (_QWORD *)sub_6575418();
    memset(v12, 0, 0x15F910uLL);
    qword_72805F0 = (__int64)v12;
    v12[1] = 0xFFFFFFFFLL;
    sub_67EB838(byte_72805F8);
  }
  v1 = qword_72805F0;
  v2 = qword_72805F0 + 16;
  v3 = atomic_load((unsigned __int64 *)(qword_72805F0 + 8));
  if ( (unsigned int)v3 >> 5 <= 0x752uLL )
  {
    v4 = (unsigned int)v3;
    while ( 1 )
    {
      v5 = *(_QWORD *)(v2 + 24 * v4);
      if ( v2 <= v5 && v1 + 1440016 > v5 )
      {
        v7 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v5 - v2) >> 3);
        if ( v7 >= 0xFFFFFFFF )
          v7 = 0xFFFFFFFFLL;
      }
      else
      {
        v7 = 0xFFFFFFFFLL;
      }
      v8 = sub_67F0010(v3, v7 | v3 & 0xFFFFFFFF00000000LL, (atomic_ullong *)(v1 + 8));
      if ( v8 == v3 )
        break;
      v4 = (unsigned int)v8;
      v3 = v8;
      if ( (unsigned int)v8 >> 5 >= 0x753uLL )
        goto LABEL_16;
    }
    if ( (unsigned int)v3 >> 5 < 0x753uLL )
      return v2 + 24LL * (unsigned int)v3;
  }
LABEL_16:
  v10 = *(_DWORD *)v1;
  if ( *(_DWORD *)v1 >> 5 > 0x752u )
    return sub_6575418();
  while ( 1 )
  {
    v11 = sub_67EFE50(v10, v10 + 1, (atomic_uint *)v1);
    if ( v11 == v10 )
      break;
    v10 = v11;
    if ( v11 >> 5 >= 0x753 )
      return sub_6575418();
  }
  return v2 + 24LL * v10;
}


================================================================================
Function: sub_657DB34 (0x657DB34)
================================================================================

unsigned __int64 __fastcall sub_657DB34(__int64 *a1)
{
  unsigned __int8 v2; // w8
  bool v4; // zf
  unsigned __int64 result; // x0
  unsigned __int8 v6; // w8
  __int64 v7; // x22
  unsigned __int64 v8; // x24
  __int64 v9; // x23
  unsigned __int64 v10; // x21
  __int64 v11; // x8
  unsigned __int64 v12; // x20
  __int64 v13; // x8
  _QWORD *v14; // x20
  _QWORD *v15; // x20

  v2 = atomic_load(byte_72805F8);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_72805F8) )
  {
    v14 = (_QWORD *)sub_6575418();
    memset(v14, 0, 0x15F910uLL);
    qword_72805F0 = (__int64)v14;
    v14[1] = 0xFFFFFFFFLL;
    sub_67EB838(byte_72805F8);
  }
  v4 = (unsigned __int64)a1 < qword_72805F0 + 16
    || qword_72805F0 + 1440016 <= (unsigned __int64)a1
    || (__int64 *)((char *)a1 - qword_72805F0 - 16) == (__int64 *)0x17FFFFFFE8LL;
  if ( v4 )
    return sub_6575460();
  v6 = atomic_load(byte_72805F8);
  if ( (v6 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_72805F8) )
  {
    v15 = (_QWORD *)sub_6575418();
    memset(v15, 0, 0x15F910uLL);
    qword_72805F0 = (__int64)v15;
    v15[1] = 0xFFFFFFFFLL;
    sub_67EB838(byte_72805F8);
  }
  v7 = qword_72805F0;
  v8 = 0xFFFFFFFFLL;
  v9 = qword_72805F0 + 16;
  if ( qword_72805F0 + 16 <= (unsigned __int64)a1 && qword_72805F0 + 1440016 > (unsigned __int64)a1 )
  {
    if ( 0xAAAAAAAAAAAAAAABLL * (((__int64)a1 - v9) >> 3) >= 0xFFFFFFFF )
      v8 = 0xFFFFFFFFLL;
    else
      v8 = 0xAAAAAAAAAAAAAAABLL * (((__int64)a1 - v9) >> 3);
  }
  v10 = *(_QWORD *)(qword_72805F0 + 8);
  v11 = v9 + 24LL * (unsigned int)v10;
  if ( (unsigned int)v10 >> 5 >= 0x753uLL )
    v11 = 0LL;
  *a1 = v11;
  result = sub_67EFFD0(v10, (v10 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v8, (atomic_ullong *)(v7 + 8));
  if ( result != v10 )
  {
    v12 = result;
    do
    {
      v13 = v9 + 24LL * (unsigned int)v12;
      if ( (unsigned int)v12 >> 5 >= 0x753uLL )
        v13 = 0LL;
      *a1 = v13;
      result = sub_67EFFD0(v12, (v12 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v8, (atomic_ullong *)(v7 + 8));
      v4 = result == v12;
      v12 = result;
    }
    while ( !v4 );
  }
  return result;
}


================================================================================
Function: sub_657DD4C (0x657DD4C)
================================================================================

__int64 __fastcall sub_657DD4C(__int64 a1)
{
  unsigned __int8 v1; // w8
  __int64 v2; // x20
  unsigned __int64 v3; // x22
  unsigned __int64 v4; // x21
  __int64 v5; // x8
  unsigned __int64 v6; // x24
  unsigned __int64 v7; // x8
  unsigned __int64 v9; // x8
  unsigned __int64 v10; // x0
  unsigned __int8 v11; // w8
  __int64 v12; // x20
  unsigned __int64 v13; // x21
  __int64 v14; // x8
  unsigned __int64 v15; // x24
  unsigned __int64 v16; // x8
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x0
  unsigned int v21; // w21
  unsigned int v22; // w0
  unsigned int v23; // w0
  unsigned int v24; // w8
  _QWORD *v25; // x20
  _QWORD *v26; // x20

  if ( a1 == 48 )
  {
    v11 = atomic_load(byte_7280618);
    if ( (v11 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280618) )
    {
      v26 = (_QWORD *)sub_6575418();
      memset(v26, 0, 0x15F910uLL);
      qword_7280610 = (__int64)v26;
      v26[1] = 0xFFFFFFFFLL;
      sub_67EB838(byte_7280618);
    }
    v12 = qword_7280610;
    v3 = qword_7280610 + 16;
    v13 = atomic_load((unsigned __int64 *)(qword_7280610 + 8));
    if ( (unsigned int)v13 >> 4 <= 0x752uLL )
    {
      v14 = (unsigned int)v13;
      v15 = qword_7280610 + 1440016;
      while ( 1 )
      {
        v16 = *(_QWORD *)(v3 + 48 * v14);
        if ( v3 <= v16 && v15 > v16 )
        {
          v18 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v16 - v3) >> 4);
          if ( v18 >= 0xFFFFFFFF )
            v18 = 0xFFFFFFFFLL;
        }
        else
        {
          v18 = 0xFFFFFFFFLL;
        }
        v19 = sub_67F0010(v13, v18 | v13 & 0xFFFFFFFF00000000LL, (atomic_ullong *)(v12 + 8));
        if ( v19 == v13 )
          break;
        v14 = (unsigned int)v19;
        v13 = v19;
        if ( (unsigned int)v19 >> 4 >= 0x753uLL )
          goto LABEL_37;
      }
      if ( (unsigned int)v13 >> 4 < 0x753uLL )
        return v3 + 48LL * (unsigned int)v13;
    }
LABEL_37:
    v21 = *(_DWORD *)v12;
    if ( *(_DWORD *)v12 >> 4 <= 0x752u )
    {
      while ( 1 )
      {
        v23 = sub_67EFE50(v21, v21 + 1, v12);
        if ( v23 == v21 )
          break;
        v21 = v23;
        if ( v23 >> 4 >= 0x753 )
          return sub_6575418();
      }
      v24 = 48;
      return v3 + v21 * (unsigned __int64)v24;
    }
    return sub_6575418();
  }
  if ( a1 != 56 )
    return sub_6575418();
  v1 = atomic_load(byte_7280608);
  if ( (v1 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280608) )
  {
    v25 = (_QWORD *)sub_6575418();
    memset(v25, 0, 0x334510uLL);
    qword_7280600 = (__int64)v25;
    v25[1] = 0xFFFFFFFFLL;
    sub_67EB838(byte_7280608);
  }
  v2 = qword_7280600;
  v3 = qword_7280600 + 16;
  v4 = atomic_load((unsigned __int64 *)(qword_7280600 + 8));
  if ( (unsigned int)v4 >> 5 <= 0x752uLL )
  {
    v5 = (unsigned int)v4;
    v6 = qword_7280600 + 3360016;
    while ( 1 )
    {
      v7 = *(_QWORD *)(v3 + 56 * v5);
      if ( v3 <= v7 && v6 > v7 )
      {
        v9 = 0x6DB6DB6DB6DB6DB7LL * ((__int64)(v7 - v3) >> 3);
        if ( v9 >= 0xFFFFFFFF )
          v9 = 0xFFFFFFFFLL;
      }
      else
      {
        v9 = 0xFFFFFFFFLL;
      }
      v10 = sub_67F0010(v4, v9 | v4 & 0xFFFFFFFF00000000LL, (atomic_ullong *)(v2 + 8));
      if ( v10 == v4 )
        break;
      v5 = (unsigned int)v10;
      v4 = v10;
      if ( (unsigned int)v10 >> 5 >= 0x753uLL )
        goto LABEL_31;
    }
    if ( (unsigned int)v4 >> 5 < 0x753uLL )
      return v3 + 56LL * (unsigned int)v4;
  }
LABEL_31:
  v21 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 >> 5 > 0x752u )
    return sub_6575418();
  while ( 1 )
  {
    v22 = sub_67EFE50(v21, v21 + 1, v2);
    if ( v22 == v21 )
      break;
    v21 = v22;
    if ( v22 >> 5 >= 0x753 )
      return sub_6575418();
  }
  v24 = 56;
  return v3 + v21 * (unsigned __int64)v24;
}


================================================================================
Function: sub_657E090 (0x657E090)
================================================================================

__int64 __fastcall sub_657E090(__int64 *a1)
{
  unsigned __int8 v2; // w8
  bool v4; // zf
  unsigned __int8 v5; // w8
  unsigned __int8 v6; // w8
  __int64 v7; // x22
  unsigned __int64 v8; // x24
  __int64 v9; // x23
  __int64 v10; // x21
  __int64 v11; // x8
  __int64 result; // x0
  __int64 v13; // x20
  __int64 v14; // x8
  unsigned __int8 v15; // w8
  __int64 v16; // x22
  __int64 v17; // x24
  __int64 v18; // x23
  __int64 v19; // x21
  __int64 v20; // x2
  __int64 v21; // x8
  __int64 v22; // x20
  __int64 v23; // x8
  _QWORD *v24; // x20
  _QWORD *v25; // x20
  _QWORD *v26; // x20
  _QWORD *v27; // x20

  v2 = atomic_load(byte_7280608);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280608) )
  {
    v24 = (_QWORD *)sub_6575418();
    memset(v24, 0, 0x334510uLL);
    qword_7280600 = (__int64)v24;
    v24[1] = 0xFFFFFFFFLL;
    sub_67EB838(byte_7280608);
  }
  v4 = (unsigned __int64)a1 < qword_7280600 + 16
    || qword_7280600 + 3360016 <= (unsigned __int64)a1
    || (__int64 *)((char *)a1 - qword_7280600 - 16) == (__int64 *)0x37FFFFFFC8LL;
  if ( v4 )
  {
    v5 = atomic_load(byte_7280618);
    if ( (v5 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280618) )
    {
      v25 = (_QWORD *)sub_6575418();
      memset(v25, 0, 0x15F910uLL);
      qword_7280610 = (__int64)v25;
      v25[1] = 0xFFFFFFFFLL;
      sub_67EB838(byte_7280618);
    }
    if ( (unsigned __int64)a1 < qword_7280610 + 16
      || qword_7280610 + 1440016 <= (unsigned __int64)a1
      || (__int64 *)((char *)a1 - qword_7280610 - 16) == (__int64 *)0x2FFFFFFFD0LL )
    {
      return sub_6575460();
    }
    else
    {
      v6 = atomic_load(byte_7280618);
      if ( (v6 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280618) )
      {
        v27 = (_QWORD *)sub_6575418();
        memset(v27, 0, 0x15F910uLL);
        qword_7280610 = (__int64)v27;
        v27[1] = 0xFFFFFFFFLL;
        sub_67EB838(byte_7280618);
      }
      v7 = qword_7280610;
      v8 = 0xFFFFFFFFLL;
      v9 = qword_7280610 + 16;
      if ( qword_7280610 + 16 <= (unsigned __int64)a1 && qword_7280610 + 1440016 > (unsigned __int64)a1 )
      {
        if ( 0xAAAAAAAAAAAAAAABLL * (((__int64)a1 - v9) >> 4) >= 0xFFFFFFFF )
          v8 = 0xFFFFFFFFLL;
        else
          v8 = 0xAAAAAAAAAAAAAAABLL * (((__int64)a1 - v9) >> 4);
      }
      v10 = *(_QWORD *)(qword_7280610 + 8);
      v11 = v9 + 48LL * (unsigned int)v10;
      if ( (unsigned int)v10 >> 4 >= 0x753uLL )
        v11 = 0LL;
      *a1 = v11;
      result = sub_67EFFD0(v10, (v10 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v8, v7 + 8);
      if ( result != v10 )
      {
        v13 = result;
        do
        {
          v14 = v9 + 48LL * (unsigned int)v13;
          if ( (unsigned int)v13 >> 4 >= 0x753uLL )
            v14 = 0LL;
          *a1 = v14;
          result = sub_67EFFD0(v13, (v13 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v8, v7 + 8);
          v4 = result == v13;
          v13 = result;
        }
        while ( !v4 );
      }
    }
  }
  else
  {
    v15 = atomic_load(byte_7280608);
    if ( (v15 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7280608) )
    {
      v26 = (_QWORD *)sub_6575418();
      memset(v26, 0, 0x334510uLL);
      qword_7280600 = (__int64)v26;
      v26[1] = 0xFFFFFFFFLL;
      sub_67EB838(byte_7280608);
    }
    v16 = qword_7280600;
    v17 = 0xFFFFFFFFLL;
    v18 = qword_7280600 + 16;
    if ( qword_7280600 + 16 <= (unsigned __int64)a1 && qword_7280600 + 3360016 > (unsigned __int64)a1 )
    {
      if ( (unsigned __int64)(0x6DB6DB6DB6DB6DB7LL * (((__int64)a1 - v18) >> 3)) >= 0xFFFFFFFF )
        v17 = 0xFFFFFFFFLL;
      else
        v17 = 0x6DB6DB6DB6DB6DB7LL * (((__int64)a1 - v18) >> 3);
    }
    v19 = *(_QWORD *)(qword_7280600 + 8);
    v20 = qword_7280600 + 8;
    v21 = v18 + 56LL * (unsigned int)v19;
    if ( (unsigned int)v19 >> 5 >= 0x753uLL )
      v21 = 0LL;
    *a1 = v21;
    result = sub_67EFFD0(v19, (v19 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v17, v20);
    if ( result != v19 )
    {
      v22 = result;
      do
      {
        v23 = v18 + 56LL * (unsigned int)v22;
        if ( (unsigned int)v22 >> 5 >= 0x753uLL )
          v23 = 0LL;
        *a1 = v23;
        result = sub_67EFFD0(v22, (v22 + 0x100000000LL) & 0xFFFFFFFF00000000LL | v17, v16 + 8);
        v4 = result == v22;
        v22 = result;
      }
      while ( !v4 );
    }
  }
  return result;
}


================================================================================
Function: sub_657E47C (0x657E47C)
================================================================================

__int64 *__fastcall sub_657E47C(__int64 *result)
{
  __int64 *v1; // x20
  int v2; // w19
  unsigned __int8 v3; // w8
  pthread_mutex_t *v4; // x21
  __int64 v5; // x22
  __int64 v6; // x0
  __int64 v7; // x0

  if ( *result )
  {
    __dmb(9u);
  }
  else
  {
    v1 = result;
    v2 = sub_6574924(dword_7280548);
    v3 = atomic_load(byte_72805C8);
    if ( (v3 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_72805C8) )
    {
      v7 = sub_6575418();
      *(_QWORD *)(v7 + 32) = 0LL;
      qword_72805C0 = v7;
      *(_OWORD *)v7 = 0u;
      *(_OWORD *)(v7 + 16) = 0u;
      sub_67EB838(byte_72805C8);
    }
    v4 = (pthread_mutex_t *)qword_72805C0;
    sub_67D1968((pthread_mutex_t *)qword_72805C0);
    if ( !*v1 )
    {
      v5 = sub_657D974(24LL);
      *(_QWORD *)v5 = 0LL;
      *(_QWORD *)(v5 + 8) = 0LL;
      *(_DWORD *)(v5 + 4) = 1;
      *(_QWORD *)(v5 + 16) = 0x7FFFFFFFLL;
      __dmb(0xBu);
      sub_67F03E0(1u, (atomic_uint *)v5);
      v6 = *v1;
      *v1 = v5;
      if ( v6 )
        sub_657E5C0(v6);
    }
    sub_67D19BC(v4);
    return (__int64 *)sub_6574924(v2);
  }
  return result;
}


================================================================================
Function: sub_657E5C0 (0x657E5C0)
================================================================================

__int64 __fastcall sub_657E5C0(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // x20

  result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)a1);
  if ( (_DWORD)result == 1 )
  {
    sub_657D0F0(a1);
    v3 = *(_QWORD *)(a1 + 8);
    if ( v3 )
    {
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, *(atomic_uint **)(a1 + 8)) == 1 )
      {
        sub_657CF78(v3);
        if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v3 + 4)) == 1 )
          sub_657E090((__int64 *)v3);
      }
    }
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(a1 + 4));
    if ( (_DWORD)result == 1 )
      return sub_657DB34(a1);
  }
  return result;
}


================================================================================
Function: sub_657ECD8 (0x657ECD8)
================================================================================

__int64 __fastcall sub_657ECD8(__int64 *a1, char *s2, size_t n, unsigned __int64 a4)
{
  unsigned __int64 v5; // x8
  size_t v6; // x2
  unsigned __int64 v7; // x22
  __int64 result; // x0
  __int64 v9; // x25
  size_t v11; // x21
  unsigned __int8 *v12; // x20
  void *v13; // x0
  size_t v14; // x26
  __int64 v15; // x8
  __int64 v16; // x10
  char v17; // w11
  int v18; // w22
  __int64 v19; // x27
  _OWORD v20[14]; // [xsp+0h] [xbp-110h]
  int8x16_t v21; // [xsp+E0h] [xbp-30h]
  int8x16_t v22; // [xsp+F0h] [xbp-20h]

  v5 = a1[1];
  v6 = v5 - a4;
  if ( v5 < a4 )
    return -1LL;
  v7 = a4;
  if ( !n )
    return v7;
  if ( v6 < n )
    return -1LL;
  v9 = *a1;
  v11 = n - 1;
  v12 = (unsigned __int8 *)(*a1 + a4);
  if ( n == 1 )
  {
    v13 = memchr((const void *)(*a1 + a4), *s2, v6);
    if ( v13 )
      return (__int64)v13 - v9;
    else
      return -1LL;
  }
  v14 = (size_t)&v12[v6 - n + 1];
  if ( n > 0xFF || v6 <= 0xF )
  {
    while ( memcmp((const void *)(v9 + v7), s2, n) )
    {
      ++v7;
      result = -1LL;
      if ( v9 + v7 >= v14 )
        return result;
    }
    return v7;
  }
  v15 = 0LL;
  v21 = vdupq_n_s8(n);
  v22 = v21;
  v20[12] = v21;
  v20[13] = v21;
  v20[10] = v21;
  v20[11] = v21;
  v20[8] = v21;
  v20[9] = v21;
  v20[6] = v21;
  v20[7] = v21;
  v20[4] = v21;
  v20[5] = v21;
  v20[2] = v21;
  v20[3] = v21;
  v20[0] = v21;
  v20[1] = v21;
  do
  {
    v16 = (unsigned __int8)s2[v15];
    v17 = v11 - v15;
    v15 = (unsigned int)(v15 + 1);
    *((_BYTE *)v20 + v16) = v17;
  }
  while ( v11 != v15 );
  v18 = (unsigned __int8)s2[v11];
  while ( 1 )
  {
    v19 = v12[v11];
    if ( (_DWORD)v19 == v18 && !memcmp(v12, s2, v11) )
      break;
    v12 += *((unsigned __int8 *)v20 + v19);
    if ( (unsigned __int64)v12 >= v14 )
      return -1LL;
  }
  return (__int64)&v12[-v9];
}


================================================================================
Function: sub_657F760 (0x657F760)
================================================================================

__int64 __fastcall sub_657F760(unsigned __int8 **a1, unsigned int a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x12
  unsigned __int8 *v5; // x9
  unsigned __int64 v6; // x10
  unsigned int v7; // w13
  int v8; // w14
  unsigned int v9; // w13
  unsigned __int64 v10; // x13
  unsigned __int8 *v12; // x9
  unsigned __int8 *v13; // x9
  int v14; // t1
  __int64 v15; // x10

  v3 = (unsigned __int64)a1[1];
  if ( a2 )
  {
    if ( v3 )
      goto LABEL_3;
    return (unsigned int)v3;
  }
  if ( v3 >= 2 )
  {
    v12 = *a1;
    if ( *(_WORD *)*a1 == 30768 || *(_WORD *)v12 == 22576 )
    {
      v13 = v12 + 2;
      a2 = 16;
    }
    else if ( *(_WORD *)v12 == 25136 || *(_WORD *)v12 == 16944 )
    {
      v13 = v12 + 2;
      a2 = 2;
    }
    else
    {
      if ( *(_WORD *)v12 != 28464 )
      {
        if ( *v12 != 48 || (v14 = v12[1], v13 = v12 + 1, (unsigned int)(v14 - 48) > 9) )
        {
          a2 = 10;
          goto LABEL_3;
        }
        a2 = 8;
        v15 = -1LL;
        goto LABEL_34;
      }
      v13 = v12 + 2;
      a2 = 8;
    }
    v15 = -2LL;
LABEL_34:
    v3 += v15;
    *a1 = v13;
    a1[1] = (unsigned __int8 *)v3;
    if ( !v3 )
      return (unsigned int)v3;
    goto LABEL_3;
  }
  a2 = 10;
  if ( !v3 )
    return (unsigned int)v3;
LABEL_3:
  v4 = 0LL;
  v5 = *a1;
  v6 = v3;
  *a3 = 0LL;
  do
  {
    if ( (char)*v5 < 48 )
      break;
    v7 = *v5;
    if ( v7 >= 0x3A )
    {
      if ( v7 < 0x61 )
      {
        if ( v7 - 65 > 0x19 )
          break;
        v8 = -55;
      }
      else
      {
        if ( v7 >= 0x7B )
          break;
        v8 = -87;
      }
    }
    else
    {
      v8 = -48;
    }
    v9 = v8 + v7;
    if ( v9 >= a2 )
      break;
    v10 = v4 * a2 + v9;
    *a3 = v10;
    if ( v10 / a2 < v4 )
      return 0LL;
    ++v5;
    --v6;
    v4 = v10;
  }
  while ( v6 );
  if ( v3 == v6 )
    return 0LL;
  *a1 = v5;
  a1[1] = (unsigned __int8 *)v6;
  return 1LL;
}


================================================================================
Function: sub_657FA34 (0x657FA34)
================================================================================

bool __fastcall sub_657FA34(_BYTE *a1, __int64 a2, unsigned int a3, __int64 *a4)
{
  __int64 v5; // x8
  __int128 v7; // [xsp+0h] [xbp-30h] BYREF
  __int128 v8; // [xsp+10h] [xbp-20h] BYREF
  __int64 v9; // [xsp+20h] [xbp-10h] BYREF

  *(_QWORD *)&v7 = a1;
  *((_QWORD *)&v7 + 1) = a2;
  if ( !a2 || *a1 != 45 )
  {
    if ( (sub_657F760(&v7, a3, &v9) & 1) == 0 )
      return 0LL;
    v5 = v9;
    if ( v9 < 0 )
      return 0LL;
LABEL_9:
    *a4 = v5;
    return *((_QWORD *)&v7 + 1) == 0LL;
  }
  *(_QWORD *)&v8 = a1 + 1;
  *((_QWORD *)&v8 + 1) = a2 - 1;
  if ( (sub_657F760(&v8, a3, &v9) & 1) != 0 )
  {
    v5 = -v9;
    if ( -v9 < 0 || v9 == 0 )
    {
      v7 = v8;
      goto LABEL_9;
    }
  }
  return 0LL;
}


================================================================================
Function: sub_65803EC (0x65803EC)
================================================================================

__int64 sub_65803EC()
{
  __int64 v1; // [xsp+8h] [xbp-18h] BYREF
  __int64 v2; // [xsp+10h] [xbp-10h]

  clock_gettime(1, (struct timespec *)&v1);
  if ( byte_71CF7B0 && byte_7281B88 )
    return v2 + 1000000000 * v1;
  else
    return (__int64)((double)v1 * 1000000000.0 + (double)v2);
}


================================================================================
Function: sub_6580494 (0x6580494)
================================================================================

__int64 sub_6580494()
{
  __int64 v0; // x0
  bool v1; // zf

  if ( byte_71CF7B0 )
  {
    v0 = qword_7281BD8;
    if ( byte_7281B88 )
      v1 = 1;
    else
      v1 = qword_7281BD8 == 0;
    if ( v1 )
      return sub_67A2C10() / 1000000;
  }
  else
  {
    v0 = qword_7281BD8;
    if ( !qword_7281BD8 )
      return sub_67A2C10() / 1000000;
  }
  if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 16LL))(v0) & 1) != 0 )
    return (__int64)(*(double (__fastcall **)(__int64))(*(_QWORD *)qword_7281BD8 + 8LL))(qword_7281BD8);
  return sub_67A2C10() / 1000000;
}


================================================================================
Function: sub_6580530 (0x6580530)
================================================================================

__int64 sub_6580530()
{
  __int64 v0; // x0
  bool v1; // zf

  if ( byte_71CF7B0 )
  {
    v0 = qword_7281BD8;
    if ( byte_7281B88 )
      v1 = 1;
    else
      v1 = qword_7281BD8 == 0;
    if ( v1 )
      return sub_67A2C10() / 1000;
  }
  else
  {
    v0 = qword_7281BD8;
    if ( !qword_7281BD8 )
      return sub_67A2C10() / 1000;
  }
  if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 16LL))(v0) & 1) != 0 )
    return (__int64)((*(double (__fastcall **)(__int64))(*(_QWORD *)qword_7281BD8 + 8LL))(qword_7281BD8) * 1000.0);
  return sub_67A2C10() / 1000;
}


================================================================================
Function: sub_6580674 (0x6580674)
================================================================================

__int64 sub_6580674()
{
  bool v0; // zf

  if ( byte_71CF7B0 )
    v0 = byte_7281B88 == 0;
  else
    v0 = 1;
  if ( v0
    && qword_7281BD8
    && ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_7281BD8 + 16LL))(qword_7281BD8) & 1) != 0 )
  {
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_7281BD8 + 8LL))(qword_7281BD8);
  }
  else
  {
    return sub_65806E0();
  }
}


================================================================================
Function: sub_65806E0 (0x65806E0)
================================================================================

double sub_65806E0()
{
  bool v0; // zf
  __int64 v1; // x0
  __int64 v2; // x20
  unsigned __int64 StatusReg; // x21
  __int64 *v4; // x20
  double v5; // d0
  __int64 v6; // x0
  unsigned __int8 v7; // w8
  double v9; // d8
  double v10; // [xsp+8h] [xbp-30h]
  __int64 v11; // [xsp+10h] [xbp-28h] BYREF
  __int64 v12; // [xsp+18h] [xbp-20h]

  if ( byte_71CF7B0 )
    v0 = byte_7281B88 == 0;
  else
    v0 = 1;
  if ( !v0 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    if ( *(double *)&qword_7285C08 != 0.0 )
    {
LABEL_10:
      __dmb(9u);
      v4 = &qword_7285C08;
      v5 = (double)(StatusReg - qword_7285C38);
      return *(double *)v4 * v5;
    }
    *(double *)&qword_7285C08 = 1.0 / (double)(unsigned __int64)sub_658149C(*(double *)&qword_7285C08);
    __dmb(0xBu);
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    qword_7285C38 = StatusReg;
    __dmb(9u);
    if ( byte_71CF7B0 && byte_71CF760 )
    {
      if ( (unsigned __int8)qword_7281B38 < 6u || (qword_7281B38 & 0xFC00) == 0 )
      {
LABEL_22:
        if ( byte_7285C19 == 1 )
        {
          v9 = (double)(sub_65803EC() - qword_7285C20);
          qword_7285C38 -= (unsigned __int64)(sub_6581D14() * v9 / *(double *)&qword_7285C08 + 0.5);
        }
        goto LABEL_10;
      }
    }
    else if ( !(_BYTE)qword_7281B38 )
    {
      goto LABEL_22;
    }
    v11 = (__int64)&unk_7285C40;
    v12 = 0LL;
    sub_654E8B4(qword_7281B38, qword_7281B40, 4u, (__int64)"[FLog::TimingInfo] {}", 21LL, 12LL, (__int64)&v11, 1);
    goto LABEL_22;
  }
  v1 = clock_gettime(1, (struct timespec *)&v11);
  if ( byte_71CF7B0 && byte_7281B88 )
    v2 = v12 + 1000000000 * v11;
  else
    v2 = (__int64)((double)v11 * 1000000000.0 + (double)v12);
  v6 = sub_6580EA8(v1);
  v5 = (double)(v2 - v6);
  v7 = atomic_load(byte_7285D08);
  if ( (v7 & 1) != 0 )
  {
    v4 = &qword_7285D00;
  }
  else
  {
    v10 = (double)(v2 - v6);
    v4 = &qword_7285D00;
    if ( (unsigned int)sub_67EB6E0((__int64)byte_7285D08) )
    {
      qword_7285D00 = 0x3E112E0BE826D695LL;
      sub_67EB838(byte_7285D08);
    }
    v5 = v10;
  }
  return *(double *)v4 * v5;
}


================================================================================
Function: sub_6580A00 (0x6580A00)
================================================================================

void sub_6580A00()
{
  int v0; // w8
  int v1; // w9
  bool v2; // zf

  v0 = (unsigned __int8)byte_7281B88;
  v1 = (unsigned __int8)byte_71CF7B0;
  if ( byte_71CF7B0 )
    v2 = byte_7281B88 == 0;
  else
    v2 = 1;
  if ( !v2 )
    goto LABEL_10;
  if ( qword_7281BD8 )
  {
    if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_7281BD8 + 16LL))(qword_7281BD8) & 1) != 0 )
      goto LABEL_14;
    v1 = (unsigned __int8)byte_71CF7B0;
    v0 = (unsigned __int8)byte_7281B88;
  }
  if ( v1 )
  {
LABEL_10:
    if ( v0 )
    {
LABEL_13:
      sub_65806E0();
      return;
    }
  }
  if ( !qword_7281BD8
    || ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)qword_7281BD8 + 16LL))(qword_7281BD8) & 1) == 0 )
  {
    goto LABEL_13;
  }
LABEL_14:
  (*(void (__fastcall **)(__int64))(*(_QWORD *)qword_7281BD8 + 8LL))(qword_7281BD8);
}


================================================================================
Function: sub_6580EA8 (0x6580EA8)
================================================================================

__int64 sub_6580EA8()
{
  bool v0; // zf
  __int64 result; // x0
  __int64 v2; // [xsp+8h] [xbp-18h] BYREF
  __int64 v3; // [xsp+10h] [xbp-10h]

  if ( byte_71CF7B0 )
    v0 = byte_7281B88 == 0;
  else
    v0 = 1;
  if ( v0 )
  {
    result = qword_7285C20;
    if ( !qword_7285C20 )
    {
      if ( (byte_7285C19 & 1) != 0 )
      {
        return 0LL;
      }
      else
      {
        clock_gettime(1, (struct timespec *)&v2);
        if ( byte_71CF7B0 && byte_7281B88 )
          result = v3 + 1000000000 * v2;
        else
          result = (__int64)((double)v2 * 1000000000.0 + (double)v3);
        qword_7285C20 = result;
        byte_7285C19 = 1;
      }
    }
  }
  else
  {
    if ( (byte_7285C19 & 1) == 0 )
    {
      qword_7285C20 = sub_65803EC();
      __dmb(0xBu);
      byte_7285C19 = 1;
    }
    __dmb(9u);
    return qword_7285C20;
  }
  return result;
}


================================================================================
Function: sub_6580FD4 (0x6580FD4)
================================================================================

char *__usercall sub_6580FD4@<X0>(__int64 a1@<X0>, __int64 a2@<X8>)
{
  char *result; // x0
  int v4; // [xsp+8h] [xbp-38h] BYREF
  unsigned __int64 v5; // [xsp+30h] [xbp-10h] BYREF

  v5 = (a1 & (unsigned __int64)~(a1 >> 63)) / 0x3E8;
  if ( sub_678FD08(&v5, &v4) )
    return (char *)sub_6579D18("%04d-%02d-%02dT%02d:%02d:%02d.%03dZ");
  result = (char *)sub_6575418();
  *(_QWORD *)(a2 + 16) = result;
  *(_OWORD *)a2 = xmmword_AF7260;
  strcpy(result, "0000-00-00T00:00:00.000Z");
  return result;
}


================================================================================
Function: sub_658149C (0x658149C)
================================================================================

unsigned __int64 sub_658149C()
{
  __int64 v0; // x28
  __int64 v1; // x19
  __int64 v2; // x22
  unsigned __int64 i; // x20
  unsigned __int64 v4; // x24
  __int64 v5; // x25
  __int64 v6; // x23
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x26
  unsigned __int64 v9; // x27
  __int64 v10; // x9
  __int64 v11; // x8
  unsigned __int64 v12; // x10
  unsigned __int64 v13; // x8
  __int64 v14; // x26
  __int64 v15; // x27
  unsigned __int64 j; // x25
  unsigned __int64 v17; // x19
  __int64 v18; // x10
  __int64 v19; // x9
  unsigned __int64 v20; // x8
  unsigned __int64 v21; // x24
  unsigned __int64 v22; // x19
  __int64 v23; // x0
  __int64 v24; // x1
  __int64 v25; // x9
  __int64 v26; // x8
  unsigned __int64 v27; // x10
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x9
  double v30; // d1
  double v31; // d0
  unsigned __int64 v32; // x5
  unsigned __int64 v33; // x6
  bool v34; // cc
  unsigned __int64 v35; // x22
  unsigned int v36; // w25
  unsigned int v37; // w23
  unsigned __int64 v38; // x20
  unsigned __int64 v39; // x8
  double *v40; // x10
  unsigned __int64 v41; // x20
  __int64 v42; // x9
  __int64 v43; // x21
  __int64 v44; // x8
  unsigned __int64 v45; // x9
  int64x2_t *v46; // x12
  double *v47; // x13
  int64x2_t v48; // q0
  __int64 v49; // x15
  int64x2_t v50; // t1
  double *v51; // x15
  double *v52; // x10
  unsigned int v53; // w12
  __int64 v54; // x13
  double *v55; // x14
  double *v56; // x12
  unsigned __int64 v57; // x14
  unsigned __int64 v58; // x12
  double v59; // d10
  __int64 v60; // x11
  __int64 v61; // x10
  double v62; // d1
  double v63; // d2
  double v64; // d5
  unsigned __int64 v65; // x12
  unsigned __int64 v66; // x9
  unsigned __int64 v67; // x8
  unsigned int v68; // w14
  __int64 *v69; // x15
  __int64 v70; // x15
  __int64 v71; // x16
  double v72; // d6
  unsigned __int64 v73; // x20
  double v74; // d5
  unsigned __int64 v75; // x11
  __int64 *v76; // x16
  __int64 v77; // x16
  __int64 v78; // x17
  __int64 v79; // x16
  double v80; // d6
  double v81; // d9
  double v82; // d8
  double v83; // d11
  int v84; // w9
  unsigned int v85; // w8
  int v86; // w10
  int32x4_t v87; // q0
  unsigned int v88; // w8
  int32x4_t v89; // q1
  int32x4_t v90; // q2
  int8x16_t v91; // q0
  unsigned int v92; // w9
  unsigned __int64 v93; // x9
  __int64 v94; // x8
  __int64 v95; // x21
  void *v96; // x0
  __int64 v97; // x1
  long double v98; // q0
  long double v99; // q1
  long double v100; // q2
  long double v101; // q3
  unsigned __int64 v102; // x8
  const char *v103; // x3
  unsigned __int64 v105; // [xsp+0h] [xbp-9FD0h]
  unsigned __int64 StatusReg; // [xsp+8h] [xbp-9FC8h]
  __int64 v107; // [xsp+10h] [xbp-9FC0h]
  __int64 v108; // [xsp+18h] [xbp-9FB8h] BYREF
  __int64 v109; // [xsp+20h] [xbp-9FB0h]
  __int64 v110; // [xsp+28h] [xbp-9FA8h] BYREF
  __int64 v111; // [xsp+30h] [xbp-9FA0h]
  __int64 v112; // [xsp+38h] [xbp-9F98h] BYREF
  __int64 v113; // [xsp+40h] [xbp-9F90h]
  _QWORD v114[3046]; // [xsp+48h] [xbp-9F88h] BYREF
  double v115; // [xsp+5F78h] [xbp-4058h] BYREF
  double v116; // [xsp+5F80h] [xbp-4050h]
  double v117; // [xsp+5F88h] [xbp-4048h]
  __int64 v118; // [xsp+5F90h] [xbp-4040h]
  unsigned int v119; // [xsp+5F98h] [xbp-4038h]
  _QWORD v120[1024]; // [xsp+5FA0h] [xbp-4030h]
  _QWORD v121[1024]; // [xsp+7FA0h] [xbp-2030h] BYREF
  float64x2x3_t v122; // 0:q4.16,16:q5.16,32:q6.16

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 0));
  if ( !byte_7281BB8 )
  {
    v35 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    clock_gettime(1, (struct timespec *)&v110);
    v36 = 0;
    do
    {
      v38 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
      v37 = 1;
      clock_gettime(1, (struct timespec *)&v108);
      v39 = v38 - v35;
      v40 = &v115 + v36;
      v41 = v109 + 1000000000 * (v108 - v110) - v111;
      *((_QWORD *)v40 + 5) = v39;
      *((_QWORD *)v40 + 1029) = v41;
      if ( v36 )
      {
        v42 = v36 - 1;
        if ( v39 == v120[(unsigned int)v42] || v41 == v121[v42] )
        {
          v37 = v36;
        }
        else
        {
          v37 = v36 + 1;
          if ( v36 >= 0x7F && (v41 - v121[0]) >> 5 >= 0xC35 && ((v39 - v120[0]) >> 4 > 0x270 || v41 - v121[0] > 0xF423F) )
            goto LABEL_53;
        }
      }
      v36 = v37;
    }
    while ( v37 < 0x400 );
    v37 = 1024;
    v41 = v121[1023];
LABEL_53:
    v43 = v37 - 8;
    v119 = v37;
    qword_7285C10 = v41;
    v44 = 0LL;
    if ( (unsigned int)v43 < 2 )
      goto LABEL_59;
    if ( (~(v37 - 9) & 0xFFFFFFF8) == 0 )
      goto LABEL_59;
    v45 = (unsigned __int64)(v43 - 1) >> 32;
    if ( v45 )
      goto LABEL_59;
    v44 = (unsigned int)v43 & 0xFFFFFFFE;
    v46 = (int64x2_t *)v121;
    v47 = (double *)&v112;
    do
    {
      v48 = v46[-512];
      v49 = ((_DWORD)v45 + 8) & 0xFFFFFFFE;
      v45 += 2LL;
      v50 = *v46++;
      v51 = &v115 + v49;
      v122.val[0] = vsubq_s64(*(int64x2_t *)(v51 + 5), v48);
      v122.val[1] = vsubq_s64(*(int64x2_t *)(v51 + 1029), v50);
      v122.val[2] = vdivq_f64(vcvtq_f64_u64(v122.val[0]), vcvtq_f64_u64(v122.val[1]));
      vst3q_f64(v47, v122);
      v47 += 6;
    }
    while ( v44 != v45 );
    if ( v44 != v43 )
    {
LABEL_59:
      v52 = (double *)&v114[3 * v44];
      do
      {
        v53 = v44 + 8;
        v54 = v44;
        v55 = &v115 + v44++;
        v56 = &v115 + v53;
        v57 = *((_QWORD *)v56 + 5) - *((_QWORD *)v55 + 5);
        v58 = *((_QWORD *)v56 + 1029) - v121[v54];
        *((_QWORD *)v52 - 2) = v57;
        *((_QWORD *)v52 - 1) = v58;
        *v52 = (double)v57 / (double)v58;
        v52 += 3;
      }
      while ( v43 != v44 );
    }
    sub_6581E2C(&v112, &v112 + 3 * v43);
    v59 = (*(double *)&v114[3 * ((v37 - 9) >> 1)] + *(double *)&v114[3 * ((unsigned int)v43 >> 1)]) * 0.5;
    v60 = ((unsigned int)v43 >> 1) - ((unsigned int)v43 >> 2);
    v61 = (unsigned int)v43 - (((unsigned int)v43 >> 2) + ((unsigned int)v43 >> 1));
    v115 = v59;
    if ( (_DWORD)v60 )
    {
      v62 = 0.0;
      v63 = 0.0;
      v64 = v59 * 0.0005;
      v65 = 0LL;
      v66 = 0LL;
      v67 = 0LL;
      v68 = ((unsigned int)v43 >> 1) - 1;
      do
      {
        v72 = v59 - *(double *)&v114[3 * v68];
        if ( v65 >= (unsigned int)v60 >> 1 && v72 > v64 )
          break;
        v63 = v63 + 1.0;
        v69 = &v112 + 3 * v68;
        ++v65;
        --v68;
        v62 = v62 + v72 * v72;
        v71 = *v69;
        v70 = v69[1];
        if ( v64 < v72 * 20.0 )
          v64 = v72 * 20.0;
        v66 += v71;
        v67 += v70;
      }
      while ( v60 != v65 );
      if ( !(_DWORD)v61 )
      {
LABEL_77:
        v81 = (double)v66 / (double)v67 * 1000000000.0;
        v116 = v81;
        v82 = sqrt(v62 / v63) * 1000000000.0;
        v117 = v82;
        if ( v59 * 0.0005 >= v82 + v82 )
          v83 = v59 * 0.0005;
        else
          v83 = v82 + v82;
        v84 = (int)(log(v83 * 20.0) * 0.434294482 + 0.00999999978);
        if ( v84 < 1 )
        {
          v85 = 1;
        }
        else
        {
          if ( (unsigned int)v84 >= 8 )
          {
            v86 = v84 & 7;
            v87.n128_u64[0] = 0x100000001LL;
            v87.n128_u64[1] = 0x100000001LL;
            v88 = v84 & 0xFFFFFFF8;
            v89.n128_u64[0] = 0xA0000000ALL;
            v89.n128_u64[1] = 0xA0000000ALL;
            v90.n128_u64[0] = 0x100000001LL;
            v90.n128_u64[1] = 0x100000001LL;
            do
            {
              v87 = vmulq_s32(v87, v89);
              v88 -= 8;
              v90 = vmulq_s32(v90, v89);
            }
            while ( v88 );
            v91 = vmulq_s32(v90, v87);
            v91.n128_u64[0] = vmul_s32((int32x2_t)v91.n128_u64[0], (int32x2_t)vextq_s8(v91, v91, 8uLL).n128_u64[0]).n64_u64[0];
            v85 = v91.n128_u32[0] * v91.n128_u32[1];
            if ( (v84 & 0x7FFFFFF8) == v84 )
              goto LABEL_89;
          }
          else
          {
            v85 = 1;
            v86 = v84;
          }
          v92 = v86 + 1;
          do
          {
            --v92;
            v85 *= 10;
          }
          while ( v92 > 1 );
        }
LABEL_89:
        v93 = (unsigned __int64)v81;
        v94 = (int)(((v85 >> 1) + (unsigned __int64)v81) / v85 * v85 - (unsigned __int64)v81);
        if ( fabs((double)(int)v94) >= v83 )
          v94 = 0LL;
        v95 = v94 + v93;
        v118 = v94 + v93;
        v96 = memcpy(&unk_7281BE0, &v115, 0x4028uLL);
        v102 = StatusReg - v95;
        if ( (__int64)(StatusReg - v95) < 0 )
          v102 = v95 - StatusReg;
        *(double *)&v101 = (double)v41 * 0.000001;
        *(double *)&v98 = v81;
        *(double *)&v100 = v82;
        if ( v82 * 5.0 <= (double)v102 )
          v103 = "Precise time not using hw freq %lu; using freq %lu from measured %.0lf median %.0lf std dev %lf; measur"
                 "ing took %lf ms\n";
        else
          v103 = "Precise time using hw freq %lu; got %lu from measured %.0lf median %.0lf std dev %lf; measuring took %lf ms\n";
        if ( v82 * 5.0 <= (double)v102 )
          v73 = v95;
        else
          v73 = StatusReg;
        *(double *)&v99 = v59 * 1000000000.0;
        sub_6581D78(v96, v97, 192LL, v103, v98, v99, v100, v101);
        return v73;
      }
    }
    else
    {
      v67 = 0LL;
      v63 = 0.0;
      v62 = 0.0;
      v66 = 0LL;
      if ( !(_DWORD)v61 )
        goto LABEL_77;
    }
    v74 = v59 * 0.0005;
    v75 = 0LL;
    do
    {
      v79 = ((v37 - 8) >> 1) + (unsigned int)v75;
      v80 = *(double *)&v114[3 * (unsigned int)v79] - v59;
      if ( v75 >= (unsigned int)v61 >> 1 && v80 > v74 )
        break;
      v76 = &v112 + 3 * v79;
      v63 = v63 + 1.0;
      ++v75;
      v78 = *v76;
      v77 = v76[1];
      v62 = v62 + v80 * v80;
      if ( v74 < v80 * 20.0 )
        v74 = v80 * 20.0;
      v66 += v78;
      v67 += v77;
    }
    while ( v61 != v75 );
    goto LABEL_77;
  }
  clock_gettime(1, (struct timespec *)&v110);
  v1 = v110;
  v2 = v111;
  for ( i = 10000LL; ; i *= 2LL )
  {
    do
    {
      clock_gettime(1, (struct timespec *)&v112);
      v4 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
      clock_gettime(1, (struct timespec *)&v115);
      v5 = v113 - v2 + 1000000000 * (v112 - v1);
      v6 = *(_QWORD *)&v116 - v2 + 1000000000 * (*(_QWORD *)&v115 - v1);
      v7 = v6 - v5;
    }
    while ( v6 == v5 );
    if ( v7 < i )
      break;
  }
  if ( v7 >= 0x3B9ACA00 )
    v8 = 1000000000LL;
  else
    v8 = v6 - v5;
  while ( 1 )
  {
    do
    {
      clock_gettime(1, (struct timespec *)&v112);
      v9 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
      clock_gettime(1, (struct timespec *)&v115);
      v10 = v113 - v2 + 1000000000 * (v112 - v1);
      v11 = *(_QWORD *)&v116 - v2 + 1000000000 * (*(_QWORD *)&v115 - v1);
      v12 = v11 - v10;
    }
    while ( v11 == v10 );
    if ( v12 < i )
      break;
    i *= 2LL;
  }
  if ( v12 < v8 )
    v6 = *(_QWORD *)&v116 - v2 + 1000000000 * (*(_QWORD *)&v115 - v1);
  else
    v10 = v5;
  if ( v12 >= v8 )
    v13 = v4;
  else
    v13 = v9;
  v107 = v10;
  v105 = v13;
  do
  {
    do
    {
      v15 = v110;
      v14 = v111;
      for ( j = 10000LL; ; j *= 2LL )
      {
        do
        {
          clock_gettime(1, (struct timespec *)&v112);
          v17 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
          clock_gettime(1, (struct timespec *)&v115);
          v18 = v113 - v14 + 1000000000 * (v112 - v15);
          v19 = *(_QWORD *)&v116 - v14 + 1000000000 * (*(_QWORD *)&v115 - v15);
          v20 = v19 - v18;
        }
        while ( v19 == v18 );
        if ( v20 < j )
          break;
      }
      v21 = 1000000000LL;
      if ( v20 < 0x3B9ACA00 )
      {
        v0 = v113 - v14 + 1000000000 * (v112 - v15);
        v2 = *(_QWORD *)&v116 - v14 + 1000000000 * (*(_QWORD *)&v115 - v15);
        i = v17;
        v21 = v19 - v18;
      }
      while ( 1 )
      {
        do
        {
          clock_gettime(1, (struct timespec *)&v112);
          v22 = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
          v23 = clock_gettime(1, (struct timespec *)&v115);
          v25 = v113 - v14 + 1000000000 * (v112 - v15);
          v26 = *(_QWORD *)&v116 - v14 + 1000000000 * (*(_QWORD *)&v115 - v15);
          v27 = v26 - v25;
        }
        while ( v26 == v25 );
        if ( v27 < j )
          break;
        j *= 2LL;
      }
      if ( v27 < v21 )
      {
        v0 = v113 - v14 + 1000000000 * (v112 - v15);
        v2 = *(_QWORD *)&v116 - v14 + 1000000000 * (*(_QWORD *)&v115 - v15);
      }
      v28 = v0 - v6;
      if ( v27 < v21 )
        i = v22;
      v29 = v2 - v107;
    }
    while ( v2 - v107 - v28 > v28 >> 4 );
    v30 = (double)(i - v105) * 1000000000.0;
    v31 = (double)v28;
    v32 = (unsigned __int64)(v30 / (double)v29);
    v33 = (unsigned __int64)(v30 / (double)v28);
    v34 = StatusReg < v32 || StatusReg > v33;
    qword_7285C10 = v0 - v6;
    if ( !v34 )
    {
      v73 = StatusReg;
      byte_7285C18 = 0;
      sub_6581D78(v23, v24, 192LL, "Precise time using hw freq %lu; measuring took %lf ms\n", StatusReg, v31 * 0.000001);
      return v73;
    }
  }
  while ( v28 <= 0x5F5E0FF && v2 - v107 - v28 > v28 >> 8 );
  byte_7285C18 = 1;
  v73 = (unsigned __int64)(v30 / (double)((v29 + v28) >> 1));
  sub_6581D78(
    v23,
    v24,
    192LL,
    "Precise time using measured freq %lu, between %lu and %lu, instead of %lu; measuring took %lf ms\n",
    v73,
    v32,
    v33,
    StatusReg,
    v31 * 0.000001);
  return v73;
}


================================================================================
Function: sub_6581D14 (0x6581D14)
================================================================================

double sub_6581D14()
{
  unsigned __int8 v0; // w9
  double *v1; // x8
  int v3; // w0

  v0 = atomic_load(byte_7285D08);
  v1 = (double *)&unk_7285000;
  if ( (v0 & 1) == 0 )
  {
    v3 = sub_67EB6E0((__int64)byte_7285D08);
    v1 = (double *)&unk_7285000;
    if ( v3 )
    {
      qword_7285D00 = 0x3E112E0BE826D695LL;
      sub_67EB838(byte_7285D08);
      v1 = (double *)&unk_7285000;
    }
  }
  return v1[416];
}


================================================================================
Function: sub_6581D78 (0x6581D78)
================================================================================

__int64 sub_6581D78(__int64 a1, __int64 a2, __int64 a3, const char *a4, ...)
{
  gcc_va_list va1; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, a4);
  va_copy(va1, va);
  return __vsnprintf_chk();
}


================================================================================
Function: sub_6581E2C (0x6581E2C)
================================================================================

__int64 __fastcall sub_6581E2C(__int64 result, double *a2)
{
  __int64 v3; // x19
  __int128 *v4; // x21
  unsigned __int64 v5; // x22
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x0
  unsigned __int64 v8; // x27
  unsigned __int64 v9; // x25
  unsigned __int64 v10; // x22
  unsigned __int64 v11; // x8
  unsigned __int64 v12; // x23
  __int128 *v13; // x24
  __int128 v14; // q0
  unsigned __int64 v15; // x8
  double *v16; // x8
  double v17; // t1
  __int128 v18; // q0
  unsigned __int64 v19; // x9
  double v20; // d1
  double *v21; // x9
  double v22; // t1
  __int128 v23; // q0
  double v24; // d1
  __int128 v25; // q0
  double v26; // d1
  __int64 v27; // x8
  double *v28; // x8
  double v29; // t1
  double v30; // d0
  bool v31; // nf
  double v32; // d1
  __int128 v33; // q0
  __int128 v34; // q0
  __int128 v35; // q0
  __int128 v36; // q0
  __int128 v37; // q0
  double v38; // d0
  double v39; // d1
  unsigned __int64 v40; // x8
  double *v41; // x9
  double v42; // d2
  __int128 v43; // q0
  unsigned __int64 v44; // x23
  double v45; // d0
  unsigned __int64 v46; // x9
  double v47; // d1
  double v48; // d1
  __int128 v49; // q0
  __int128 v50; // q0
  char v51; // w24
  __int64 v52; // x8
  __int128 v53; // q0
  double *i; // x9
  double v55; // d0
  double v56; // d1
  double v57; // d1
  __int128 v58; // q0
  __int128 v59; // q0
  double v60; // d0
  __int128 *v61; // x8
  double v62; // d1
  __int128 v63; // q0
  __int128 *v64; // x21
  __int128 *v65; // x22
  __int128 *v66; // x23
  __int128 v67; // q0
  __int64 v68; // x9
  __int64 v69; // x9
  double v70; // d1
  __int128 v71; // q2
  double v72; // d0
  __int128 v73; // q3
  __int64 v74; // x9
  double v75; // d1
  __int128 v76; // q2
  double v77; // d0
  __int128 v78; // q3
  __int64 v79; // x9
  double v80; // d2
  double *v81; // x8
  double v82; // d1
  __int128 *v83; // x9
  double v84; // d0
  __int64 v85; // x10
  __int128 v86; // q0
  __int64 v87; // x10
  __int64 v88; // x10
  __int64 v89; // x11
  __int128 v90; // q2
  __int128 v91; // q3
  double v92; // d0
  __int64 v93; // x11
  __int64 v94; // x9
  __int128 v95; // q0
  __int64 v96; // x10
  __int64 v97; // x11
  double v98; // d1
  __int64 v99; // x10
  __int128 v100; // q1
  __int64 v101; // x11
  double *v102; // x10
  __int64 v103; // x9
  __int64 v104; // x10
  double *v105; // x11
  double v106; // d0
  __int64 v107; // x10
  __int64 v108; // x11
  __int64 v109; // x12
  __int128 v110; // [xsp+80h] [xbp-20h]
  __int128 v111; // [xsp+80h] [xbp-20h]
  __int128 v112; // [xsp+80h] [xbp-20h]
  __int128 v113; // [xsp+80h] [xbp-20h]
  __int128 v114; // [xsp+80h] [xbp-20h]
  __int128 v115; // [xsp+80h] [xbp-20h]
  __int128 v116; // [xsp+80h] [xbp-20h]
  __int128 v117; // [xsp+80h] [xbp-20h]
  __int128 v118; // [xsp+80h] [xbp-20h]
  __int128 v119; // [xsp+80h] [xbp-20h]
  __int128 v120; // [xsp+80h] [xbp-20h]
  __int128 v121; // [xsp+80h] [xbp-20h]
  __int128 v122; // [xsp+80h] [xbp-20h]
  __int128 v123; // [xsp+80h] [xbp-20h]
  __int128 v124; // [xsp+80h] [xbp-20h]
  __int128 v125; // [xsp+80h] [xbp-20h]
  __int128 v126; // [xsp+80h] [xbp-20h]
  __int128 v127; // [xsp+80h] [xbp-20h]
  __int128 v128; // [xsp+80h] [xbp-20h]
  __int128 v129; // [xsp+80h] [xbp-20h]
  __int128 v130; // [xsp+80h] [xbp-20h]
  __int128 v131; // [xsp+80h] [xbp-20h]
  __int64 v132; // [xsp+90h] [xbp-10h]
  __int64 v133; // [xsp+90h] [xbp-10h]
  __int64 v134; // [xsp+90h] [xbp-10h]
  __int64 v135; // [xsp+90h] [xbp-10h]
  __int64 v136; // [xsp+90h] [xbp-10h]
  __int64 v137; // [xsp+90h] [xbp-10h]
  __int64 v138; // [xsp+90h] [xbp-10h]
  __int64 v139; // [xsp+90h] [xbp-10h]
  __int64 v140; // [xsp+90h] [xbp-10h]
  __int64 v141; // [xsp+90h] [xbp-10h]
  __int64 v142; // [xsp+90h] [xbp-10h]
  __int64 v143; // [xsp+90h] [xbp-10h]
  __int64 v144; // [xsp+90h] [xbp-10h]
  __int64 v145; // [xsp+90h] [xbp-10h]
  __int64 v146; // [xsp+90h] [xbp-10h]
  __int64 v147; // [xsp+90h] [xbp-10h]
  __int64 v148; // [xsp+90h] [xbp-10h]
  __int64 v149; // [xsp+90h] [xbp-10h]
  __int64 v150; // [xsp+90h] [xbp-10h]
  __int64 v151; // [xsp+90h] [xbp-10h]
  __int64 v152; // [xsp+90h] [xbp-10h]
  __int64 v153; // [xsp+90h] [xbp-10h]
  __int64 v154; // [xsp+90h] [xbp-10h]
  __int64 v155; // [xsp+90h] [xbp-10h]

  v3 = result;
LABEL_2:
  v4 = (__int128 *)(a2 - 3);
  v5 = v3;
LABEL_3:
  while ( 2 )
  {
    v6 = (unsigned __int64)a2 - v5;
    v3 = v5;
    switch ( 0xAAAAAAAAAAAAAAABLL * ((__int64)((__int64)a2 - v5) >> 3) )
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        if ( *(a2 - 1) < *(double *)(v5 + 16) )
        {
          v145 = *(_QWORD *)(v5 + 16);
          v123 = *(_OWORD *)v5;
          v59 = *(_OWORD *)(a2 - 3);
          *(double *)(v5 + 16) = *(a2 - 1);
          *(_OWORD *)v5 = v59;
          *((_QWORD *)a2 - 1) = v145;
          *(_OWORD *)(a2 - 3) = v123;
        }
        return result;
      case 3uLL:
        v60 = *(double *)(v5 + 40);
        v61 = (__int128 *)(v5 + 24);
        v62 = *(a2 - 1);
        if ( v60 >= *(double *)(v5 + 16) )
        {
          if ( v62 < v60 )
          {
            v86 = *v61;
            v150 = *(_QWORD *)(v5 + 40);
            v87 = *((_QWORD *)a2 - 1);
            *v61 = *v4;
            *(_QWORD *)(v5 + 40) = v87;
            *((_QWORD *)a2 - 1) = v150;
            *v4 = v86;
            if ( *(double *)(v5 + 40) < *(double *)(v5 + 16) )
            {
              v88 = *(_QWORD *)(v5 + 40);
              v151 = *(_QWORD *)(v5 + 16);
              v127 = *(_OWORD *)v5;
              *(_OWORD *)v5 = *v61;
              *(_QWORD *)(v5 + 16) = v88;
              *v61 = v127;
              *(_QWORD *)(v5 + 40) = v151;
            }
          }
        }
        else if ( v62 >= v60 )
        {
          v153 = *(_QWORD *)(v5 + 16);
          v94 = *(_QWORD *)(v5 + 40);
          v129 = *(_OWORD *)v5;
          *(_OWORD *)v5 = *v61;
          *(_QWORD *)(v5 + 16) = v94;
          *v61 = v129;
          *(_QWORD *)(v5 + 40) = v153;
          if ( *(a2 - 1) < *(double *)(v5 + 40) )
          {
            v95 = *v61;
            v154 = *(_QWORD *)(v5 + 40);
            v96 = *((_QWORD *)a2 - 1);
            *v61 = *v4;
            *(_QWORD *)(v5 + 40) = v96;
            *((_QWORD *)a2 - 1) = v154;
            *v4 = v95;
          }
        }
        else
        {
          v146 = *(_QWORD *)(v5 + 16);
          v124 = *(_OWORD *)v5;
          v63 = *v4;
          *(double *)(v5 + 16) = *(a2 - 1);
          *(_OWORD *)v5 = v63;
          *((_QWORD *)a2 - 1) = v146;
          *v4 = v124;
        }
        return result;
      case 4uLL:
        return sub_658289C(v5, v5 + 24, v5 + 48, a2 - 3);
      case 5uLL:
        v64 = (__int128 *)(v5 + 24);
        v65 = (__int128 *)(v5 + 48);
        v66 = (__int128 *)(v3 + 72);
        result = sub_658289C(v3, v3 + 24, v3 + 48, v3 + 72);
        if ( *(a2 - 1) < *(double *)(v3 + 88) )
        {
          v67 = *v66;
          v147 = *(_QWORD *)(v3 + 88);
          v68 = *((_QWORD *)a2 - 1);
          *v66 = *(_OWORD *)(a2 - 3);
          *(_QWORD *)(v3 + 88) = v68;
          *((_QWORD *)a2 - 1) = v147;
          *(_OWORD *)(a2 - 3) = v67;
          if ( *(double *)(v3 + 88) < *(double *)(v3 + 64) )
          {
            v69 = *(_QWORD *)(v3 + 64);
            v70 = *(double *)(v3 + 40);
            *(_QWORD *)(v3 + 64) = *(_QWORD *)(v3 + 88);
            v71 = *v66;
            v72 = *(double *)(v3 + 64);
            *(_QWORD *)(v3 + 88) = v69;
            v73 = *v65;
            *v65 = v71;
            *v66 = v73;
            if ( v72 < v70 )
            {
              v74 = *(_QWORD *)(v3 + 40);
              v75 = *(double *)(v3 + 16);
              *(_QWORD *)(v3 + 40) = *(_QWORD *)(v3 + 64);
              v76 = *v65;
              v77 = *(double *)(v3 + 40);
              *(_QWORD *)(v3 + 64) = v74;
              v78 = *v64;
              *v64 = v76;
              *v65 = v78;
              if ( v77 < v75 )
              {
                v79 = *(_QWORD *)(v3 + 40);
                v148 = *(_QWORD *)(v3 + 16);
                v125 = *(_OWORD *)v3;
                *(_OWORD *)v3 = *v64;
                *(_QWORD *)(v3 + 16) = v79;
                *v64 = v125;
                *(_QWORD *)(v3 + 40) = v148;
              }
            }
          }
        }
        return result;
      default:
        if ( (__int64)v6 > 743 )
        {
          if ( v6 >= 0x5DA9 )
          {
            v7 = v5;
            v8 = v6 / 0x30;
            v9 = v6 / 0x60;
            v10 = v5 + 24 * (v6 / 0x30);
            v11 = 24 * (v6 / 0x60);
            v12 = v3 + v11;
            v13 = (__int128 *)(v10 + v11);
            result = sub_658289C(v7, v3 + v11, v10, v10 + v11);
            if ( *(a2 - 1) < *((double *)v13 + 2) )
            {
              v132 = *((_QWORD *)v13 + 2);
              v110 = *v13;
              v14 = *v4;
              *((double *)v13 + 2) = *(a2 - 1);
              v15 = v3 + 24 * v8;
              *v13 = v14;
              *((_QWORD *)a2 - 1) = v132;
              *v4 = v110;
              v17 = *(double *)(v15 + 16);
              v16 = (double *)(v15 + 16);
              if ( *((double *)v13 + 2) >= v17 )
              {
                result = (unsigned int)(result + 1);
              }
              else
              {
                v133 = *(_QWORD *)(v10 + 16);
                v111 = *(_OWORD *)v10;
                v18 = *v13;
                *(_QWORD *)(v10 + 16) = *((_QWORD *)v13 + 2);
                v19 = v3 + 24 * v9;
                *(_OWORD *)v10 = v18;
                *((_QWORD *)v13 + 2) = v133;
                v20 = *v16;
                *v13 = v111;
                v22 = *(double *)(v19 + 16);
                v21 = (double *)(v19 + 16);
                if ( v20 >= v22 )
                {
                  result = (unsigned int)(result + 2);
                }
                else
                {
                  v134 = *(_QWORD *)(v12 + 16);
                  v112 = *(_OWORD *)v12;
                  v23 = *(_OWORD *)v10;
                  *(_QWORD *)(v12 + 16) = *(_QWORD *)(v10 + 16);
                  *(_OWORD *)v12 = v23;
                  *(_QWORD *)(v10 + 16) = v134;
                  v24 = *v21;
                  *(_OWORD *)v10 = v112;
                  if ( v24 >= *(double *)(v3 + 16) )
                  {
                    result = (unsigned int)(result + 3);
                  }
                  else
                  {
                    result = (unsigned int)(result + 4);
                    v135 = *(_QWORD *)(v3 + 16);
                    v113 = *(_OWORD *)v3;
                    v25 = *(_OWORD *)v12;
                    *(_QWORD *)(v3 + 16) = *(_QWORD *)(v12 + 16);
                    *(_OWORD *)v3 = v25;
                    *(_QWORD *)(v12 + 16) = v135;
                    *(_OWORD *)v12 = v113;
                  }
                }
              }
            }
LABEL_27:
            v38 = *(double *)(v3 + 16);
            v39 = *(double *)(v10 + 16);
            if ( v38 < v39 )
            {
              v40 = (unsigned __int64)(a2 - 3);
              goto LABEL_33;
            }
            v41 = a2 - 3;
            while ( 1 )
            {
              v40 = (unsigned __int64)(v41 - 3);
              if ( v41 - 3 == (double *)v3 )
                break;
              v42 = *(v41 - 1);
              v41 -= 3;
              if ( v42 < v39 )
              {
                LODWORD(result) = result + 1;
                v140 = *(_QWORD *)(v3 + 16);
                v118 = *(_OWORD *)v3;
                v43 = *(_OWORD *)v40;
                *(_QWORD *)(v3 + 16) = *(_QWORD *)(v40 + 16);
                *(_OWORD *)v3 = v43;
                *(_QWORD *)(v40 + 16) = v140;
                *(_OWORD *)v40 = v118;
LABEL_33:
                v44 = v3 + 24;
                if ( v3 + 24 < v40 )
                {
                  while ( 1 )
                  {
                    v45 = *(double *)(v10 + 16);
                    v46 = v44 - 24;
                    do
                    {
                      v47 = *(double *)(v46 + 40);
                      v46 += 24LL;
                    }
                    while ( v47 < v45 );
                    v44 = v46 + 24;
                    do
                    {
                      v48 = *(double *)(v40 - 8);
                      v40 -= 24LL;
                    }
                    while ( v48 >= v45 );
                    if ( v46 > v40 )
                      break;
                    LODWORD(result) = result + 1;
                    if ( v46 == v10 )
                      v10 = v40;
                    v141 = *(_QWORD *)(v46 + 16);
                    v119 = *(_OWORD *)v46;
                    v49 = *(_OWORD *)v40;
                    *(_QWORD *)(v46 + 16) = *(_QWORD *)(v40 + 16);
                    *(_OWORD *)v46 = v49;
                    *(_QWORD *)(v40 + 16) = v141;
                    *(_OWORD *)v40 = v119;
                  }
                  v44 = v46;
                }
                if ( v44 != v10 && *(double *)(v10 + 16) < *(double *)(v44 + 16) )
                {
                  LODWORD(result) = result + 1;
                  v142 = *(_QWORD *)(v44 + 16);
                  v120 = *(_OWORD *)v44;
                  v50 = *(_OWORD *)v10;
                  *(_QWORD *)(v44 + 16) = *(_QWORD *)(v10 + 16);
                  *(_OWORD *)v44 = v50;
                  *(_QWORD *)(v10 + 16) = v142;
                  *(_OWORD *)v10 = v120;
                }
                if ( (_DWORD)result )
                {
LABEL_49:
                  if ( (__int64)(0xAAAAAAAAAAAAAAABLL * ((__int64)(v44 - v3) >> 3)) < (__int64)(0xAAAAAAAAAAAAAAABLL
                                                                                              * ((__int64)((__int64)a2 - v44) >> 3)) )
                  {
                    result = sub_6581E2C(v3, v44);
                    v5 = v44 + 24;
                    goto LABEL_3;
                  }
                  result = sub_6581E2C(v44 + 24, a2);
                  a2 = (double *)v44;
                  goto LABEL_2;
                }
                v5 = v44 + 24;
                v51 = sub_6582A88(v3, v44);
                result = sub_6582A88(v44 + 24, a2);
                if ( (result & 1) == 0 )
                {
                  if ( (v51 & 1) != 0 )
                    goto LABEL_3;
                  goto LABEL_49;
                }
                a2 = (double *)v44;
                if ( (v51 & 1) == 0 )
                  goto LABEL_2;
                return result;
              }
            }
            v52 = v3 + 24;
            if ( v38 >= *(a2 - 1) )
            {
              if ( (__int128 *)v52 == v4 )
                return result;
              while ( v38 >= *(double *)(v52 + 16) )
              {
                v52 += 24LL;
                if ( (__int128 *)v52 == v4 )
                  return result;
              }
              v143 = *(_QWORD *)(v52 + 16);
              v121 = *(_OWORD *)v52;
              v53 = *v4;
              *(double *)(v52 + 16) = *(a2 - 1);
              *(_OWORD *)v52 = v53;
              v52 += 24LL;
              *((_QWORD *)a2 - 1) = v143;
              *v4 = v121;
            }
            if ( (__int128 *)v52 != v4 )
            {
              for ( i = a2 - 3; ; *(_OWORD *)i = v122 )
              {
                v55 = *(double *)(v3 + 16);
                v5 = v52 - 24;
                do
                {
                  v56 = *(double *)(v5 + 40);
                  v5 += 24LL;
                }
                while ( v55 >= v56 );
                v52 = v5 + 24;
                do
                {
                  v57 = *(i - 1);
                  i -= 3;
                }
                while ( v55 < v57 );
                if ( v5 >= (unsigned __int64)i )
                  break;
                v144 = *(_QWORD *)(v5 + 16);
                v122 = *(_OWORD *)v5;
                v58 = *(_OWORD *)i;
                *(double *)(v5 + 16) = i[2];
                *(_OWORD *)v5 = v58;
                *((_QWORD *)i + 2) = v144;
              }
              continue;
            }
            return result;
          }
          v26 = *(double *)(v5 + 16);
          v10 = v5 + 24LL * ((unsigned __int16)((_WORD)a2 - v5) / 0x30u);
          v27 = v3 + 24LL * ((unsigned __int16)v6 / 0x30u);
          v29 = *(double *)(v27 + 16);
          v28 = (double *)(v27 + 16);
          v30 = v29;
          v31 = v29 < v26;
          v32 = *(a2 - 1);
          if ( !v31 )
          {
            if ( v32 >= v30 )
            {
              result = 0LL;
              goto LABEL_27;
            }
            v137 = *(_QWORD *)(v10 + 16);
            v115 = *(_OWORD *)v10;
            v34 = *v4;
            *(double *)(v10 + 16) = *(a2 - 1);
            *(_OWORD *)v10 = v34;
            *((_QWORD *)a2 - 1) = v137;
            *v4 = v115;
            if ( *v28 < *(double *)(v3 + 16) )
            {
              result = 2LL;
              v138 = *(_QWORD *)(v3 + 16);
              v116 = *(_OWORD *)v3;
              v35 = *(_OWORD *)v10;
              *(_QWORD *)(v3 + 16) = *(_QWORD *)(v10 + 16);
              *(_OWORD *)v3 = v35;
              *(_QWORD *)(v10 + 16) = v138;
              *(_OWORD *)v10 = v116;
              goto LABEL_27;
            }
            goto LABEL_24;
          }
          if ( v32 >= v30 )
          {
            v139 = *(_QWORD *)(v3 + 16);
            v117 = *(_OWORD *)v3;
            v36 = *(_OWORD *)v10;
            *(_QWORD *)(v3 + 16) = *(_QWORD *)(v10 + 16);
            *(_OWORD *)v3 = v36;
            *(_QWORD *)(v10 + 16) = v139;
            *(_OWORD *)v10 = v117;
            if ( *(a2 - 1) >= *v28 )
            {
LABEL_24:
              result = 1LL;
              goto LABEL_27;
            }
            result = 2LL;
            v136 = *(_QWORD *)(v10 + 16);
            v114 = *(_OWORD *)v10;
            v37 = *v4;
            *(double *)(v10 + 16) = *(a2 - 1);
            *(_OWORD *)v10 = v37;
          }
          else
          {
            result = 1LL;
            v136 = *(_QWORD *)(v3 + 16);
            v114 = *(_OWORD *)v3;
            v33 = *v4;
            *(double *)(v3 + 16) = *(a2 - 1);
            *(_OWORD *)v3 = v33;
          }
          *((_QWORD *)a2 - 1) = v136;
          *v4 = v114;
          goto LABEL_27;
        }
        v80 = *(double *)(v5 + 40);
        v81 = (double *)(v5 + 48);
        v82 = *(double *)(v5 + 16);
        v83 = (__int128 *)(v5 + 24);
        v84 = *(double *)(v5 + 64);
        if ( v80 >= v82 )
        {
          if ( v84 < v80 )
          {
            v89 = *(_QWORD *)(v5 + 40);
            v90 = *(_OWORD *)v81;
            *(_QWORD *)(v5 + 40) = *(_QWORD *)(v5 + 64);
            v91 = *v83;
            v92 = *(double *)(v5 + 40);
            *(_QWORD *)(v5 + 64) = v89;
            *v83 = v90;
            *(_OWORD *)v81 = v91;
            if ( v92 < v82 )
            {
              v93 = *(_QWORD *)(v5 + 40);
              v152 = *(_QWORD *)(v5 + 16);
              v128 = *(_OWORD *)v5;
              *(_OWORD *)v5 = *v83;
              *(_QWORD *)(v5 + 16) = v93;
              *v83 = v128;
              *(_QWORD *)(v5 + 40) = v152;
            }
          }
        }
        else if ( v84 >= v80 )
        {
          v97 = *(_QWORD *)(v5 + 40);
          v155 = *(_QWORD *)(v5 + 16);
          v130 = *(_OWORD *)v5;
          *(_OWORD *)v5 = *v83;
          *(_QWORD *)(v5 + 16) = v97;
          *(_QWORD *)(v5 + 40) = v155;
          v98 = *(double *)(v5 + 40);
          *v83 = v130;
          if ( v84 < v98 )
          {
            v99 = *(_QWORD *)(v5 + 64);
            v100 = *v83;
            v101 = *(_QWORD *)(v5 + 40);
            *v83 = *(_OWORD *)v81;
            *(_QWORD *)(v5 + 40) = v99;
            *(_OWORD *)v81 = v100;
            *(_QWORD *)(v5 + 64) = v101;
          }
        }
        else
        {
          v85 = *(_QWORD *)(v5 + 64);
          v149 = *(_QWORD *)(v5 + 16);
          v126 = *(_OWORD *)v5;
          *(_OWORD *)v5 = *(_OWORD *)v81;
          *(_QWORD *)(v5 + 16) = v85;
          *(_OWORD *)v81 = v126;
          *(_QWORD *)(v5 + 64) = v149;
        }
        v102 = (double *)(v5 + 72);
        if ( (double *)(v5 + 72) != a2 )
        {
          v103 = 0LL;
          do
          {
            v105 = v81;
            v106 = v102[2];
            v81 = v102;
            if ( v106 < v105[2] )
            {
              v107 = v103;
              v131 = *(_OWORD *)v81;
              do
              {
                v108 = v5 + v107;
                v109 = *(_QWORD *)(v5 + v107 + 64);
                *(_OWORD *)(v108 + 72) = *(_OWORD *)(v5 + v107 + 48);
                *(_QWORD *)(v108 + 88) = v109;
                if ( v107 == -48 )
                {
                  v104 = v5;
                  goto LABEL_96;
                }
                v107 -= 24LL;
              }
              while ( v106 < *(double *)(v108 + 40) );
              v104 = v5 + v107 + 72;
LABEL_96:
              *(double *)(v104 + 16) = v106;
              *(_OWORD *)v104 = v131;
            }
            v102 = v81 + 3;
            v103 += 24LL;
          }
          while ( v81 + 3 != a2 );
        }
        return result;
    }
  }
}


================================================================================
Function: sub_658289C (0x658289C)
================================================================================

__int64 __fastcall sub_658289C(__int128 *a1, double *a2, double *a3, __int128 *a4)
{
  double v4; // d0
  double v5; // d1
  unsigned int v6; // w8
  __int64 v7; // x10
  __int128 v8; // q1
  __int64 v9; // x11
  __int64 v10; // x8
  __int128 v11; // q1
  __int64 v12; // x10
  __int64 v13; // x10
  __int128 v14; // q1
  __int64 v15; // x11
  __int64 v16; // x8
  __int128 v17; // q1
  __int64 v18; // x10
  __int64 v19; // x10
  __int64 v20; // x10
  __int128 v21; // q1
  __int64 v22; // x11
  __int64 v23; // x10
  __int128 v24; // q1
  __int64 v25; // x11
  __int64 v26; // x10
  __int128 v27; // q1
  __int64 v28; // x11

  v4 = a2[2];
  v5 = a3[2];
  if ( v4 >= *((double *)a1 + 2) )
  {
    if ( v5 >= v4 )
    {
      v6 = 0;
      goto LABEL_12;
    }
    v10 = *((_QWORD *)a3 + 2);
    v11 = *(_OWORD *)a2;
    v12 = *((_QWORD *)a2 + 2);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((_QWORD *)a2 + 2) = v10;
    *(_OWORD *)a3 = v11;
    *((_QWORD *)a3 + 2) = v12;
    if ( a2[2] < *((double *)a1 + 2) )
    {
      v6 = 2;
      v13 = *((_QWORD *)a2 + 2);
      v14 = *a1;
      v15 = *((_QWORD *)a1 + 2);
      *a1 = *(_OWORD *)a2;
      *((_QWORD *)a1 + 2) = v13;
      *(_OWORD *)a2 = v14;
      *((_QWORD *)a2 + 2) = v15;
      goto LABEL_12;
    }
  }
  else
  {
    if ( v5 < v4 )
    {
      v6 = 1;
      v7 = *((_QWORD *)a3 + 2);
      v8 = *a1;
      v9 = *((_QWORD *)a1 + 2);
      *a1 = *(_OWORD *)a3;
      *((_QWORD *)a1 + 2) = v7;
LABEL_9:
      *(_OWORD *)a3 = v8;
      *((_QWORD *)a3 + 2) = v9;
      goto LABEL_12;
    }
    v16 = *((_QWORD *)a2 + 2);
    v17 = *a1;
    v18 = *((_QWORD *)a1 + 2);
    *a1 = *(_OWORD *)a2;
    *((_QWORD *)a1 + 2) = v16;
    *(_OWORD *)a2 = v17;
    *((_QWORD *)a2 + 2) = v18;
    if ( a3[2] < a2[2] )
    {
      v6 = 2;
      v19 = *((_QWORD *)a3 + 2);
      v8 = *(_OWORD *)a2;
      v9 = *((_QWORD *)a2 + 2);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_QWORD *)a2 + 2) = v19;
      goto LABEL_9;
    }
  }
  v6 = 1;
LABEL_12:
  if ( *((double *)a4 + 2) < a3[2] )
  {
    v20 = *((_QWORD *)a4 + 2);
    v21 = *(_OWORD *)a3;
    v22 = *((_QWORD *)a3 + 2);
    *(_OWORD *)a3 = *a4;
    *((_QWORD *)a3 + 2) = v20;
    *a4 = v21;
    *((_QWORD *)a4 + 2) = v22;
    if ( a3[2] >= a2[2] )
    {
      ++v6;
    }
    else
    {
      v23 = *((_QWORD *)a3 + 2);
      v24 = *(_OWORD *)a2;
      v25 = *((_QWORD *)a2 + 2);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_QWORD *)a2 + 2) = v23;
      *(_OWORD *)a3 = v24;
      *((_QWORD *)a3 + 2) = v25;
      if ( a2[2] >= *((double *)a1 + 2) )
      {
        v6 += 2;
      }
      else
      {
        v6 += 3;
        v26 = *((_QWORD *)a2 + 2);
        v27 = *a1;
        v28 = *((_QWORD *)a1 + 2);
        *a1 = *(_OWORD *)a2;
        *((_QWORD *)a1 + 2) = v26;
        *(_OWORD *)a2 = v27;
        *((_QWORD *)a2 + 2) = v28;
      }
    }
  }
  return v6;
}


================================================================================
Function: sub_6582A88 (0x6582A88)
================================================================================

bool __fastcall sub_6582A88(__int64 a1, double *a2)
{
  unsigned __int64 v4; // x8
  _BOOL8 result; // x0
  __int64 v6; // x8
  __int128 v7; // q1
  __int64 v8; // x9
  double v9; // d2
  double *v10; // x8
  double v11; // d0
  __int128 *v12; // x9
  double v13; // d1
  __int64 v14; // x9
  __int128 v15; // q1
  __int64 v16; // x10
  double v17; // d0
  __int128 *v18; // x8
  double *v19; // x9
  double v20; // d1
  __int64 v21; // x8
  __int128 v22; // q1
  __int64 v23; // x10
  __int128 *v24; // x21
  __int128 *v25; // x22
  __int128 *v26; // x23
  __int64 v27; // x8
  __int128 v28; // q1
  __int64 v29; // x9
  __int64 v30; // x9
  double v31; // d1
  __int128 v32; // q2
  double v33; // d0
  __int128 v34; // q3
  __int64 v35; // x9
  double v36; // d1
  __int128 v37; // q2
  double v38; // d0
  __int128 v39; // q3
  __int64 v40; // x8
  __int128 v41; // q1
  __int64 v42; // x9
  __int64 v43; // x11
  __int128 v44; // q2
  __int128 v45; // q3
  double v46; // d1
  __int64 v47; // x10
  __int128 v48; // q1
  __int64 v49; // x11
  __int64 v50; // x10
  __int128 v51; // q1
  __int64 v52; // x11
  __int64 v53; // x9
  __int128 v54; // q1
  __int64 v55; // x10
  __int64 v56; // x11
  __int128 v57; // q2
  __int128 v58; // q3
  double v59; // d0
  __int64 v60; // x10
  __int128 v61; // q1
  __int64 v62; // x11
  double *v63; // x11
  __int64 v64; // x9
  int v65; // w10
  __int64 v66; // x11
  double *v67; // x12
  double v68; // d0
  __int64 v69; // x11
  __int64 v70; // x12
  __int64 v71; // x13
  __int64 v72; // x10
  __int128 v73; // q1
  __int64 v74; // x11
  __int64 v75; // x10
  __int128 v76; // q1
  __int64 v77; // x11
  __int128 v78; // [xsp+0h] [xbp-1F0h]

  v4 = 0xAAAAAAAAAAAAAAABLL * (((__int64)a2 - a1) >> 3);
  result = 1LL;
  switch ( v4 )
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if ( *(a2 - 1) >= *(double *)(a1 + 16) )
        return 1LL;
      result = 1LL;
      v6 = *((_QWORD *)a2 - 1);
      v7 = *(_OWORD *)a1;
      v8 = *(_QWORD *)(a1 + 16);
      *(_OWORD *)a1 = *(_OWORD *)(a2 - 3);
      *(_QWORD *)(a1 + 16) = v6;
      *(_OWORD *)(a2 - 3) = v7;
      *((_QWORD *)a2 - 1) = v8;
      return result;
    case 3uLL:
      v17 = *(double *)(a1 + 40);
      v18 = (__int128 *)(a1 + 24);
      v19 = a2 - 3;
      v20 = *(a2 - 1);
      if ( v17 >= *(double *)(a1 + 16) )
      {
        if ( v20 >= v17 )
          return 1LL;
        v50 = *((_QWORD *)a2 - 1);
        v51 = *v18;
        v52 = *(_QWORD *)(a1 + 40);
        *v18 = *(_OWORD *)v19;
        *(_QWORD *)(a1 + 40) = v50;
        *(_OWORD *)v19 = v51;
        *((_QWORD *)a2 - 1) = v52;
        if ( *(double *)(a1 + 40) >= *(double *)(a1 + 16) )
          return 1LL;
        result = 1LL;
        v53 = *(_QWORD *)(a1 + 40);
        v54 = *(_OWORD *)a1;
        v55 = *(_QWORD *)(a1 + 16);
        *(_OWORD *)a1 = *v18;
        *(_QWORD *)(a1 + 16) = v53;
        *v18 = v54;
        *(_QWORD *)(a1 + 40) = v55;
      }
      else if ( v20 >= v17 )
      {
        v72 = *(_QWORD *)(a1 + 40);
        v73 = *(_OWORD *)a1;
        v74 = *(_QWORD *)(a1 + 16);
        *(_OWORD *)a1 = *v18;
        *(_QWORD *)(a1 + 16) = v72;
        *v18 = v73;
        *(_QWORD *)(a1 + 40) = v74;
        if ( *(a2 - 1) >= *(double *)(a1 + 40) )
          return 1LL;
        result = 1LL;
        v75 = *((_QWORD *)a2 - 1);
        v76 = *v18;
        v77 = *(_QWORD *)(a1 + 40);
        *v18 = *(_OWORD *)v19;
        *(_QWORD *)(a1 + 40) = v75;
        *(_OWORD *)v19 = v76;
        *((_QWORD *)a2 - 1) = v77;
      }
      else
      {
        result = 1LL;
        v21 = *((_QWORD *)a2 - 1);
        v22 = *(_OWORD *)a1;
        v23 = *(_QWORD *)(a1 + 16);
        *(_OWORD *)a1 = *(_OWORD *)v19;
        *(_QWORD *)(a1 + 16) = v21;
        *(_OWORD *)v19 = v22;
        *((_QWORD *)a2 - 1) = v23;
      }
      return result;
    case 4uLL:
      sub_658289C(a1, a1 + 24, a1 + 48, a2 - 3);
      return 1LL;
    case 5uLL:
      v24 = (__int128 *)(a1 + 24);
      v25 = (__int128 *)(a1 + 48);
      v26 = (__int128 *)(a1 + 72);
      sub_658289C(a1, a1 + 24, a1 + 48, a1 + 72);
      if ( *(a2 - 1) >= *(double *)(a1 + 88) )
        return 1LL;
      v27 = *((_QWORD *)a2 - 1);
      v28 = *v26;
      v29 = *(_QWORD *)(a1 + 88);
      *v26 = *(_OWORD *)(a2 - 3);
      *(_QWORD *)(a1 + 88) = v27;
      *(_OWORD *)(a2 - 3) = v28;
      *((_QWORD *)a2 - 1) = v29;
      if ( *(double *)(a1 + 88) >= *(double *)(a1 + 64) )
        return 1LL;
      v30 = *(_QWORD *)(a1 + 64);
      v31 = *(double *)(a1 + 40);
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 88);
      v32 = *v26;
      v33 = *(double *)(a1 + 64);
      *(_QWORD *)(a1 + 88) = v30;
      v34 = *v25;
      *v25 = v32;
      *v26 = v34;
      if ( v33 >= v31 )
        return 1LL;
      v35 = *(_QWORD *)(a1 + 40);
      v36 = *(double *)(a1 + 16);
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 64);
      v37 = *v25;
      v38 = *(double *)(a1 + 40);
      *(_QWORD *)(a1 + 64) = v35;
      v39 = *v24;
      *v24 = v37;
      *v25 = v39;
      if ( v38 >= v36 )
        return 1LL;
      result = 1LL;
      v40 = *(_QWORD *)(a1 + 40);
      v41 = *(_OWORD *)a1;
      v42 = *(_QWORD *)(a1 + 16);
      *(_OWORD *)a1 = *v24;
      *(_QWORD *)(a1 + 16) = v40;
      *v24 = v41;
      *(_QWORD *)(a1 + 40) = v42;
      return result;
    default:
      v9 = *(double *)(a1 + 40);
      v10 = (double *)(a1 + 48);
      v11 = *(double *)(a1 + 16);
      v12 = (__int128 *)(a1 + 24);
      v13 = *(double *)(a1 + 64);
      if ( v9 >= v11 )
      {
        if ( v13 < v9 )
        {
          v43 = *(_QWORD *)(a1 + 40);
          v44 = *(_OWORD *)v10;
          *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 64);
          v45 = *v12;
          v46 = *(double *)(a1 + 40);
          *(_QWORD *)(a1 + 64) = v43;
          *v12 = v44;
          *(_OWORD *)v10 = v45;
          if ( v46 < v11 )
          {
            v47 = *(_QWORD *)(a1 + 40);
            v48 = *(_OWORD *)a1;
            v49 = *(_QWORD *)(a1 + 16);
            *(_OWORD *)a1 = *v12;
            *(_QWORD *)(a1 + 16) = v47;
            *v12 = v48;
            *(_QWORD *)(a1 + 40) = v49;
          }
        }
      }
      else if ( v13 >= v9 )
      {
        v56 = *(_QWORD *)(a1 + 40);
        v57 = *v12;
        *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 16);
        v58 = *(_OWORD *)a1;
        v59 = *(double *)(a1 + 40);
        *(_QWORD *)(a1 + 16) = v56;
        *(_OWORD *)a1 = v57;
        *v12 = v58;
        if ( v13 < v59 )
        {
          v60 = *(_QWORD *)(a1 + 64);
          v61 = *v12;
          v62 = *(_QWORD *)(a1 + 40);
          *v12 = *(_OWORD *)v10;
          *(_QWORD *)(a1 + 40) = v60;
          *(_OWORD *)v10 = v61;
          *(_QWORD *)(a1 + 64) = v62;
        }
      }
      else
      {
        v14 = *(_QWORD *)(a1 + 64);
        v15 = *(_OWORD *)a1;
        v16 = *(_QWORD *)(a1 + 16);
        *(_OWORD *)a1 = *(_OWORD *)v10;
        *(_QWORD *)(a1 + 16) = v14;
        *(_OWORD *)v10 = v15;
        *(_QWORD *)(a1 + 64) = v16;
      }
      v63 = (double *)(a1 + 72);
      if ( (double *)(a1 + 72) == a2 )
        return 1LL;
      v64 = 0LL;
      v65 = 0;
      break;
  }
  while ( 1 )
  {
    v67 = v10;
    v68 = v63[2];
    v10 = v63;
    if ( v68 < v67[2] )
    {
      v69 = v64;
      v78 = *(_OWORD *)v10;
      do
      {
        v70 = a1 + v69;
        v71 = *(_QWORD *)(a1 + v69 + 64);
        *(_OWORD *)(v70 + 72) = *(_OWORD *)(a1 + v69 + 48);
        *(_QWORD *)(v70 + 88) = v71;
        if ( v69 == -48 )
        {
          v66 = a1;
          goto LABEL_27;
        }
        v69 -= 24LL;
      }
      while ( v68 < *(double *)(v70 + 40) );
      v66 = a1 + v69 + 72;
LABEL_27:
      ++v65;
      *(double *)(v66 + 16) = v68;
      *(_OWORD *)v66 = v78;
      if ( v65 == 8 )
        return v10 + 3 == a2;
    }
    v63 = v10 + 3;
    v64 += 24LL;
    if ( v10 + 3 == a2 )
      return 1LL;
  }
}


================================================================================
Function: sub_6583040 (0x6583040)
================================================================================

_QWORD *sub_6583040()
{
  _QWORD *result; // x0
  _QWORD *v1; // x19
  _QWORD *v2; // x0

  result = sub_67EF968(qword_6C30368);
  if ( (*(_BYTE *)result & 1) == 0 )
  {
    if ( !*(_BYTE *)sub_67EF968(qword_6C30388) )
    {
      *(_BYTE *)sub_67EF968(qword_6C30388) = 1;
      v2 = sub_67EF968(qword_6C30328);
      *((_OWORD *)v2 + 63) = 0u;
      sub_67EC670(sub_658312C, v2, &off_67F7780);
    }
    v1 = sub_67EF968(qword_6C30348);
    *v1 = sub_67EF968(qword_6C30328);
    result = sub_67EF968(qword_6C30368);
    *(_BYTE *)result = 1;
  }
  return result;
}


================================================================================
Function: sub_65830FC (0x65830FC)
================================================================================

__int64 sub_65830FC()
{
  sub_6583040();
  return *sub_67EF968(qword_6C30348);
}


================================================================================
Function: sub_65831F0 (0x65831F0)
================================================================================

__int64 __fastcall sub_65831F0(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6)
{
  unsigned int i; // w24
  int v13; // w8
  unsigned int v14; // w25
  unsigned int v15; // w0
  __int64 result; // x0
  unsigned __int16 v17; // w8

  if ( *(_QWORD *)a1 )
    sub_65786C4(0LL, "Attempted to overwrite an already set TLS slot.");
  *(_QWORD *)(a1 + 8) = a5;
  *(_QWORD *)(a1 + 16) = a6;
  for ( i = atomic_load((unsigned __int16 *)&unk_7285D10); ; i = v15 )
  {
    if ( ((unsigned __int16)(a4 - 1) & (unsigned __int16)i) != 0 )
      v13 = (a4 + 0xFFFF + (unsigned __int16)i) & -a4;
    else
      v13 = i;
    v14 = v13 + a3;
    *(_WORD *)(a1 + 26) = v13;
    if ( (unsigned __int16)(v13 + a3) >= 0x3F1u )
      sub_65786C4(0LL, "Out of TLS bytes.");
    v15 = sub_67EFE10(i, v14, &unk_7285D10);
    if ( v15 == (unsigned __int16)i )
      break;
  }
  *(_QWORD *)a1 = a2;
  result = sub_67F0350(1LL, &unk_7285D12);
  if ( (unsigned int)result < 0x81 )
  {
    v17 = 127 - result;
    *(_WORD *)(a1 + 24) = 127 - result;
  }
  else
  {
    result = sub_65786C4(0LL, "Out of TLS slots.");
    v17 = *(_WORD *)(a1 + 24);
  }
  *((_QWORD *)&unk_7285D10 + v17 + 1) = a1;
  return result;
}


================================================================================
Function: sub_6583344 (0x6583344)
================================================================================

__int64 __fastcall sub_6583344(__int64 a1)
{
  __int64 v2; // x0
  __int64 v3; // x21
  __int64 v4; // x10
  __int64 v5; // x20

  v2 = sub_65830FC();
  v3 = v2 + 1008;
  v4 = *(unsigned __int16 *)(a1 + 26);
  v5 = v2 + v4;
  if ( ((*(_QWORD *)(v2 + 1008 + (((unsigned __int64)*(unsigned __int16 *)(a1 + 24) >> 3) & 0x1FF8)) >> *(_WORD *)(a1 + 24)) & 1) == 0 )
  {
    (*(void (__fastcall **)(__int64, _QWORD))(a1 + 8))(v2 + v4, *(_QWORD *)a1);
    *(_QWORD *)(v3 + (((unsigned __int64)*(unsigned __int16 *)(a1 + 24) >> 3) & 0x1FF8)) |= 1LL << *(_WORD *)(a1 + 24);
  }
  return v5;
}


================================================================================
Function: sub_6584E94 (0x6584E94)
================================================================================

unsigned __int64 *__usercall sub_6584E94@<X0>(__int128 *a1@<X0>, unsigned __int64 *a2@<X8>)
{
  return sub_67D2788(a2, a1);
}


================================================================================
Function: sub_6585904 (0x6585904)
================================================================================

__int64 __fastcall sub_6585904(__int64 a1, __int64 a2)
{
  pthread_mutex_t *v2; // x19
  __int64 v5; // [xsp+0h] [xbp-10h] BYREF

  v2 = (pthread_mutex_t *)(a1 + 8);
  v5 = a2;
  sub_6577DB4(a1 + 8);
  sub_6585C38(a1 + 48, &v5, &v5);
  return sub_67D19BC(v2);
}


================================================================================
Function: sub_65859DC (0x65859DC)
================================================================================

unsigned __int64 __fastcall sub_65859DC(unsigned __int64 result, unsigned __int64 a2)
{
  int8x8_t *v2; // x19
  int8x8_t v3; // x20
  int8x8_t v4; // x21
  uint8x8_t v5; // d0
  __int64 v6; // x8
  __int64 v7; // x8
  __int64 v8; // x8
  _QWORD *v9; // x8
  unsigned __int64 v10; // x10
  uint8x8_t v11; // d0
  _QWORD *i; // x12
  unsigned __int64 v13; // x13
  _QWORD *v14; // x15
  _QWORD *v15; // x14
  __int64 v16; // x13

  v2 = (int8x8_t *)result;
  if ( a2 == 1 )
  {
    v3.n64_u64[0] = 2LL;
  }
  else
  {
    v3.n64_u64[0] = a2;
    if ( (a2 & (a2 - 1)) != 0 )
    {
      result = sub_67A4870(a2);
      v3.n64_u64[0] = result;
    }
  }
  v4.n64_u64[0] = v2[1].n64_u64[0];
  if ( v3.n64_u64[0] > v4.n64_u64[0] )
    goto LABEL_18;
  if ( v3.n64_u64[0] < v4.n64_u64[0] )
  {
    result = vcvtps_u32_f32((float)v2[3].n64_u64[0] / v2[4].n64_f32[0]);
    if ( v4.n64_u64[0] < 3
      || (v5.n64_u64[0] = vcnt_s8(v4).n64_u64[0], v5.n64_u16[0] = vaddlv_u8(v5), v5.n64_u32[0] > 1uLL) )
    {
      result = sub_67A4870(result);
    }
    else
    {
      v6 = 1LL << -(char)__clz(result - 1);
      if ( result >= 2 )
        result = v6;
    }
    if ( v3.n64_u64[0] < result )
      v3.n64_u64[0] = result;
    if ( v3.n64_u64[0] < v4.n64_u64[0] )
    {
LABEL_18:
      if ( v3.n64_u64[0] )
      {
        if ( v3.n64_u64[0] >> 61 )
          sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        v7 = sub_6575418();
        result = v2->n64_u64[0];
        v2->n64_u64[0] = v7;
        if ( result )
          result = sub_6575460();
        v8 = 0LL;
        v2[1].n64_u64[0] = v3.n64_u64[0];
        do
          *(_QWORD *)(v2->n64_u64[0] + 8 * v8++) = 0LL;
        while ( v3.n64_u64[0] != v8 );
        v9 = (_QWORD *)v2[2].n64_u64[0];
        if ( v9 )
        {
          v10 = v9[1];
          v11.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
          v11.n64_u16[0] = vaddlv_u8(v11);
          if ( v11.n64_u32[0] > 1uLL )
          {
            if ( v10 >= v3.n64_u64[0] )
              v10 %= v3.n64_u64[0];
          }
          else
          {
            v10 &= v3.n64_u64[0] - 1;
          }
          *(_QWORD *)(v2->n64_u64[0] + 8 * v10) = v2 + 2;
          for ( i = (_QWORD *)*v9; *v9; i = (_QWORD *)*v9 )
          {
            v13 = i[1];
            if ( v11.n64_u32[0] > 1uLL )
            {
              if ( v13 >= v3.n64_u64[0] )
                v13 %= v3.n64_u64[0];
            }
            else
            {
              v13 &= v3.n64_u64[0] - 1;
            }
            if ( v13 == v10 )
            {
              v9 = i;
            }
            else
            {
              v14 = i;
              if ( *(_QWORD *)(v2->n64_u64[0] + 8 * v13) )
              {
                do
                {
                  v15 = v14;
                  v14 = (_QWORD *)*v14;
                }
                while ( v14 && i[2] == v14[2] );
                *v9 = v14;
                v16 = 8 * v13;
                *v15 = **(_QWORD **)(v2->n64_u64[0] + v16);
                **(_QWORD **)(v2->n64_u64[0] + v16) = i;
              }
              else
              {
                *(_QWORD *)(v2->n64_u64[0] + 8 * v13) = v9;
                v9 = i;
                v10 = v13;
              }
            }
          }
        }
      }
      else
      {
        result = v2->n64_u64[0];
        v2->n64_u64[0] = 0LL;
        if ( result )
          result = sub_6575460();
        v2[1].n64_u64[0] = 0LL;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6585C38 (0x6585C38)
================================================================================

_QWORD *__fastcall sub_6585C38(float *a1, _QWORD *a2, __int64 *a3)
{
  unsigned __int64 v3; // x24
  unsigned __int64 v5; // x22
  __int64 v6; // x11
  unsigned __int64 v8; // x10
  unsigned __int64 v9; // x23
  uint8x8_t v10; // d0
  _QWORD *v11; // x20
  unsigned __int64 v12; // x11
  _QWORD *v13; // x0
  __int64 v14; // x8
  __int64 v15; // x9
  float v16; // s1
  float v17; // s0
  _BOOL8 v18; // x9
  unsigned __int64 v19; // x10
  __int64 v20; // x1
  __int64 v21; // x8
  _QWORD *v22; // x9
  __int64 v23; // x10
  unsigned __int64 v24; // x8

  v5 = *((_QWORD *)a1 + 1);
  v6 = HIDWORD(*a2);
  v8 = 0x9DDFEA08EB382D69LL * ((8 * (unsigned int)*a2 + 8LL) ^ v6);
  v9 = 0x9DDFEA08EB382D69LL
     * ((0x9DDFEA08EB382D69LL * (v8 ^ v6 ^ (v8 >> 47))) ^ ((0x9DDFEA08EB382D69LL * (v8 ^ v6 ^ (v8 >> 47))) >> 47));
  if ( v5 )
  {
    v10.n64_u64[0] = vcnt_s8((int8x8_t)v5).n64_u64[0];
    v10.n64_u16[0] = vaddlv_u8(v10);
    if ( v10.n64_u32[0] > 1uLL )
    {
      v3 = 0x9DDFEA08EB382D69LL
         * ((0x9DDFEA08EB382D69LL * (v8 ^ v6 ^ (v8 >> 47))) ^ ((0x9DDFEA08EB382D69LL * (v8 ^ v6 ^ (v8 >> 47))) >> 47));
      if ( v9 >= v5 )
        v3 = v9 % v5;
    }
    else
    {
      v3 = v9 & (v5 - 1);
    }
    v11 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if ( v11 )
    {
      while ( 1 )
      {
        v11 = (_QWORD *)*v11;
        if ( !v11 )
          break;
        v12 = v11[1];
        if ( v12 != v9 )
        {
          if ( v10.n64_u32[0] <= 1uLL )
          {
            v12 &= v5 - 1;
          }
          else if ( v12 >= v5 )
          {
            v12 %= v5;
          }
          if ( v12 != v3 )
            break;
        }
        if ( v11[2] == *a2 )
          return v11;
      }
    }
  }
  v13 = (_QWORD *)sub_6575418();
  v14 = *((_QWORD *)a1 + 3);
  v11 = v13;
  v15 = *a3;
  *v13 = 0LL;
  v16 = a1[8];
  v13[1] = v9;
  v13[2] = v15;
  v17 = (float)(unsigned __int64)(v14 + 1);
  if ( !v5 || (float)(v16 * (float)v5) < v17 )
  {
    v18 = v5 < 3 || (v5 & (v5 - 1)) != 0;
    v19 = vcvtps_u32_f32(v17 / v16);
    if ( (v18 | (2 * v5)) >= v19 )
      v20 = v18 | (2 * v5);
    else
      v20 = v19;
    sub_65859DC(a1, v20);
    v5 = *((_QWORD *)a1 + 1);
    if ( (v5 & (v5 - 1)) != 0 )
    {
      if ( v9 >= v5 )
        v3 = v9 % v5;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v5 - 1) & v9;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if ( v22 )
  {
    *v11 = *v22;
    *v22 = v11;
  }
  else
  {
    v23 = *((_QWORD *)a1 + 2);
    *((_QWORD *)a1 + 2) = v11;
    *v11 = v23;
    *(_QWORD *)(v21 + 8 * v3) = a1 + 4;
    if ( *v11 )
    {
      v24 = *(_QWORD *)(*v11 + 8LL);
      if ( (v5 & (v5 - 1)) != 0 )
      {
        if ( v24 >= v5 )
          v24 %= v5;
      }
      else
      {
        v24 &= v5 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v11;
    }
  }
  ++*((_QWORD *)a1 + 3);
  return v11;
}


================================================================================
Function: sub_6586B90 (0x6586B90)
================================================================================

__int64 sub_6586B90()
{
  return 3LL;
}


================================================================================
Function: sub_6586B98 (0x6586B98)
================================================================================

const char *__fastcall sub_6586B98(int a1)
{
  if ( (unsigned int)(a1 - 1) > 3 )
    return "unknown";
  else
    return (char *)dword_1707228 + dword_1707228[a1 - 1];
}


================================================================================
Function: sub_6586BF8 (0x6586BF8)
================================================================================

__int64 __fastcall sub_6586BF8(_DWORD *a1, _DWORD *a2)
{
  __int64 result; // x0

  result = sub_6586D78(a1 + 2, (a2[3] << 10) & 0x7FFC00 | *a2 & 0x3FFLL | ((a2[2] & 0xFFFLL) << 23));
  *a1 = result;
  return result;
}


================================================================================
Function: sub_6586C3C (0x6586C3C)
================================================================================

__int64 __fastcall sub_6586C3C(__int64 result, __int64 a2, _DWORD *a3)
{
  char *v3; // x9
  unsigned __int64 v4; // x8
  _BYTE *v5; // x10
  char v6; // t1

  if ( (int)*a3 >= 1 )
  {
    v3 = (char *)(a3 + 2);
    v4 = result + a2 + ~*a3;
    v5 = (_BYTE *)(result + a2 - 1);
    do
    {
      v6 = *v3++;
      *v5-- = v6;
    }
    while ( (unsigned __int64)v5 > v4 );
  }
  return result;
}


================================================================================
Function: sub_6586C70 (0x6586C70)
================================================================================

__int64 __fastcall sub_6586C70(__int64 a1, __int64 a2)
{
  __int64 v2; // x21
  char *v3; // x19
  int v4; // w0
  __int64 v5; // x9
  unsigned __int64 v6; // x8
  __int64 v7; // x10
  char *v8; // x9
  __int64 v9; // x11
  char *v10; // x10
  _BYTE *v11; // x13
  unsigned __int64 v12; // x14
  char v13; // w15
  char v14; // w16
  char v15; // t1
  char v17; // [xsp+8h] [xbp-18h] BYREF
  _BYTE v18[7]; // [xsp+9h] [xbp-17h] BYREF

  v2 = a1 + a2;
  v3 = (char *)(a1 + a2 - 1);
  v4 = sub_6587038(v3);
  if ( v4 >= 1 )
  {
    v5 = v2 - 2;
    v6 = v2 + ~v4;
    if ( v6 < v2 - 2 )
      v5 = v2 + ~v4;
    v7 = ~v5;
    v8 = &v17;
    v9 = v2 + v7;
    if ( (unsigned __int64)(v2 + v7) < 2 )
    {
      v10 = v3;
      do
      {
LABEL_9:
        v15 = *v10--;
        *v8++ = v15;
      }
      while ( (unsigned __int64)v10 > v6 );
      return sub_6586F3C(&v17) & 0x3FF;
    }
    v11 = v18;
    v10 = &v3[-(v9 & 0xFFFFFFFFFFFFFFFELL)];
    v8 = &v18[(v9 & 0xFFFFFFFFFFFFFFFELL) - 1];
    v12 = v9 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v13 = *v3;
      v12 -= 2LL;
      v14 = *(v3 - 1);
      v3 -= 2;
      *(v11 - 1) = v13;
      *v11 = v14;
      v11 += 2;
    }
    while ( v12 );
    if ( v9 != (v9 & 0xFFFFFFFFFFFFFFFELL) )
      goto LABEL_9;
  }
  return sub_6586F3C(&v17) & 0x3FF;
}


================================================================================
Function: sub_6586D78 (0x6586D78)
================================================================================

__int64 __fastcall sub_6586D78(_BYTE *a1, unsigned __int64 a2)
{
  if ( a2 > 0xF0 )
  {
    if ( a2 > 0x8EF )
    {
      if ( a2 > 0x108EF )
      {
        if ( a2 >> 24 )
        {
          if ( HIDWORD(a2) )
          {
            if ( a2 >> 40 )
            {
              if ( HIWORD(a2) )
              {
                if ( HIBYTE(a2) )
                {
                  a1[2] = BYTE6(a2);
                  a1[3] = BYTE5(a2);
                  a1[5] = BYTE3(a2);
                  a1[1] = HIBYTE(a2);
                  *a1 = -1;
                  a1[4] = BYTE4(a2);
                  a1[6] = BYTE2(a2);
                  a1[7] = BYTE1(a2);
                  a1[8] = a2;
                  return 9LL;
                }
                else
                {
                  a1[2] = BYTE5(a2);
                  a1[3] = BYTE4(a2);
                  a1[4] = BYTE3(a2);
                  a1[1] = BYTE6(a2);
                  *a1 = -2;
                  a1[5] = BYTE2(a2);
                  a1[6] = BYTE1(a2);
                  a1[7] = a2;
                  return 8LL;
                }
              }
              else
              {
                a1[1] = BYTE5(a2);
                a1[2] = BYTE4(a2);
                a1[3] = BYTE3(a2);
                *a1 = -3;
                a1[4] = BYTE2(a2);
                a1[5] = BYTE1(a2);
                a1[6] = a2;
                return 7LL;
              }
            }
            else
            {
              a1[1] = BYTE4(a2);
              a1[2] = BYTE3(a2);
              *a1 = -4;
              a1[3] = BYTE2(a2);
              a1[4] = BYTE1(a2);
              a1[5] = a2;
              return 6LL;
            }
          }
          else
          {
            a1[1] = BYTE3(a2);
            a1[4] = a2;
            *a1 = -5;
            a1[2] = BYTE2(a2);
            a1[3] = BYTE1(a2);
            return 5LL;
          }
        }
        else
        {
          a1[3] = a2;
          *a1 = -6;
          a1[1] = BYTE2(a2);
          a1[2] = BYTE1(a2);
          return 4LL;
        }
      }
      else
      {
        *a1 = -7;
        a1[1] = (unsigned __int16)(a2 - 2288) >> 8;
        a1[2] = a2 + 16;
        return 3LL;
      }
    }
    else
    {
      a1[1] = a2 + 16;
      *a1 = ((unsigned __int16)(a2 - 240) >> 8) - 15;
      return 2LL;
    }
  }
  else
  {
    *a1 = a2;
    return 1LL;
  }
}


================================================================================
Function: sub_6586F3C (0x6586F3C)
================================================================================

unsigned __int64 __fastcall sub_6586F3C(unsigned __int8 *a1)
{
  unsigned __int64 result; // x0

  result = *a1;
  if ( (unsigned int)result >= 0xF1 )
  {
    if ( (unsigned int)result > 0xF8 )
    {
      switch ( (int)result )
      {
        case 249:
          result = bswap64((unsigned __int64)*(unsigned __int16 *)(a1 + 1) << 48) + 2288;
          break;
        case 250:
          result = bswap64((unsigned __int64)*((unsigned __int16 *)a1 + 1) << 48) & 0xFFFFFFFFFF00FFFFLL | ((unsigned __int64)a1[1] << 16);
          break;
        case 251:
          result = bswap64((unsigned __int64)*(unsigned int *)(a1 + 1) << 32);
          break;
        case 252:
          result = bswap64((unsigned __int64)*(unsigned int *)(a1 + 2) << 32) & 0xFFFFFF00FFFFFFFFLL | ((unsigned __int64)a1[1] << 32);
          break;
        case 253:
          result = bswap64((unsigned __int64)*(unsigned int *)(a1 + 3) << 32) & 0xFFFF0000FFFFFFFFLL | ((unsigned __int64)a1[2] << 32) & 0xFFFF00FFFFFFFFFFLL | ((unsigned __int64)a1[1] << 40);
          break;
        case 254:
          result = bswap64((unsigned __int64)*((unsigned int *)a1 + 1) << 32) & 0xFF000000FFFFFFFFLL | ((unsigned __int64)a1[3] << 32) & 0xFF0000FFFFFFFFFFLL | ((unsigned __int64)a1[2] << 40) & 0xFF00FFFFFFFFFFFFLL | ((unsigned __int64)a1[1] << 48);
          break;
        default:
          result = bswap64(*(_QWORD *)(a1 + 1));
          break;
      }
    }
    else
    {
      return (a1[1] | ((unsigned __int8)result << 8)) - 61456;
    }
  }
  return result;
}


================================================================================
Function: sub_6587038 (0x6587038)
================================================================================

__int64 __fastcall sub_6587038(unsigned __int8 *a1)
{
  unsigned int v1; // w8
  unsigned int v3; // w8

  v1 = *a1;
  if ( v1 < 0xF1 )
    return 1LL;
  if ( v1 < 0xF9 )
    return 2LL;
  v3 = (unsigned __int8)(v1 + 7);
  if ( v3 > 5 )
    return 9LL;
  else
    return v3 + 3;
}


================================================================================
Function: sub_6588000 (0x6588000)
================================================================================

unsigned __int8 *__fastcall sub_6588000(unsigned __int8 *a1, size_t n, int c)
{
  unsigned __int64 v4; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x27
  __int64 v9; // x9
  unsigned __int8 *v10; // x23
  const void *v11; // x23
  unsigned __int64 v12; // x24
  void *v13; // x25
  size_t v14; // x8
  unsigned __int64 v16; // x8

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( !n )
    return a1;
  v4 = *a1;
  if ( (v4 & 1) == 0 )
  {
    v7 = v4 >> 1;
    v8 = 22LL;
    LOBYTE(v9) = *a1;
    if ( 22 - (v4 >> 1) >= n )
      goto LABEL_4;
LABEL_7:
    if ( -17LL - v8 < v7 + n - v8 )
      abort();
    if ( (v4 & 1) != 0 )
    {
      v11 = (const void *)*((_QWORD *)a1 + 2);
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
      {
LABEL_10:
        v12 = -17LL;
        v13 = (void *)sub_6575418();
        if ( !v7 )
        {
LABEL_12:
          if ( v8 != 22 )
            sub_6575460();
          *((_QWORD *)a1 + 2) = v13;
          *(_QWORD *)a1 = v12 | 1;
          goto LABEL_15;
        }
LABEL_11:
        memcpy(v13, v11, v7);
        goto LABEL_12;
      }
    }
    else
    {
      v11 = a1 + 1;
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
        goto LABEL_10;
    }
    v16 = 2 * v8;
    if ( v7 + n >= 2 * v8 )
      v16 = v7 + n;
    if ( v16 >= 0x17 )
    {
      v12 = (v16 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v13 = (void *)sub_6575418();
      if ( !v7 )
        goto LABEL_12;
    }
    else
    {
      v12 = 23LL;
      v13 = (void *)sub_6575418();
      if ( !v7 )
        goto LABEL_12;
    }
    goto LABEL_11;
  }
  v9 = *(_QWORD *)a1;
  v7 = *((_QWORD *)a1 + 1);
  v8 = (*(_QWORD *)a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  if ( v8 - v7 < n )
    goto LABEL_7;
LABEL_4:
  if ( (v9 & 1) != 0 )
  {
LABEL_15:
    v10 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    goto LABEL_16;
  }
  v10 = a1 + 1;
LABEL_16:
  memset(&v10[v7], c, n);
  v14 = v7 + n;
  if ( (*a1 & 1) != 0 )
    *((_QWORD *)a1 + 1) = v14;
  else
    *a1 = 2 * v14;
  v10[v14] = 0;
  return a1;
}


================================================================================
Function: sub_6588260 (0x6588260)
================================================================================

unsigned __int64 *__fastcall sub_6588260(unsigned __int64 *a1, void *src, size_t n)
{
  unsigned __int64 v6; // x26
  _BYTE *v7; // x22
  unsigned __int64 v8; // x23
  unsigned __int64 v9; // x8
  void *v10; // x24

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v6 >= n )
    {
LABEL_3:
      if ( (*(_BYTE *)a1 & 1) != 0 )
      {
        v7 = (_BYTE *)a1[2];
        if ( !n )
          goto LABEL_13;
      }
      else
      {
        v7 = (char *)a1 + 1;
        if ( !n )
        {
LABEL_13:
          v7[n] = 0;
          if ( (*(_BYTE *)a1 & 1) != 0 )
            a1[1] = n;
          else
            *(_BYTE *)a1 = 2 * n;
          return a1;
        }
      }
      memmove(v7, src, n);
      goto LABEL_13;
    }
  }
  else
  {
    v6 = 22LL;
    if ( n <= 0x16 )
      goto LABEL_3;
  }
  if ( -18LL - v6 < n - v6 )
    abort();
  if ( (*(_BYTE *)a1 & 1) != 0 )
  {
    if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
      goto LABEL_10;
LABEL_17:
    v9 = 2 * v6;
    if ( 2 * v6 <= n )
      v9 = n;
    if ( v9 >= 0x17 )
      v8 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v8 = 23LL;
    goto LABEL_22;
  }
  if ( v6 <= 0x7FFFFFFFFFFFFFE6LL )
    goto LABEL_17;
LABEL_10:
  v8 = -17LL;
LABEL_22:
  v10 = (void *)sub_6575418();
  memcpy(v10, src, n);
  if ( v6 != 22 )
    sub_6575460();
  a1[1] = n;
  a1[2] = (unsigned __int64)v10;
  *a1 = v8 | 1;
  *((_BYTE *)v10 + n) = 0;
  return a1;
}


================================================================================
Function: sub_6588400 (0x6588400)
================================================================================

unsigned __int64 *__fastcall sub_6588400(unsigned __int64 *a1, void *src, size_t n)
{
  unsigned __int64 v6; // x8
  size_t v7; // x22
  unsigned __int64 v8; // x27
  char *v9; // x23
  unsigned __int64 v10; // x28
  const void *v11; // x23
  unsigned __int64 v12; // x24
  char *v13; // x25
  char *v14; // x8
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x8

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v6 = *(unsigned __int8 *)a1;
  if ( (v6 & 1) == 0 )
  {
    v7 = v6 >> 1;
    v8 = 22LL;
    if ( 22 - (v6 >> 1) >= n )
      goto LABEL_3;
LABEL_7:
    v10 = v7 + n;
    if ( -18LL - v8 < v7 + n - v8 )
      abort();
    if ( (v6 & 1) != 0 )
    {
      v11 = (const void *)a1[2];
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
      {
LABEL_10:
        v12 = -17LL;
        v13 = (char *)sub_6575418();
        if ( !v7 )
        {
LABEL_12:
          memcpy(&v13[v7], src, n);
          if ( v8 != 22 )
            sub_6575460();
          *a1 = v12 | 1;
          v14 = &v13[v10];
          a1[1] = v10;
          a1[2] = (unsigned __int64)v13;
          goto LABEL_26;
        }
LABEL_11:
        memcpy(v13, v11, v7);
        goto LABEL_12;
      }
    }
    else
    {
      v11 = (char *)a1 + 1;
      if ( v8 > 0x7FFFFFFFFFFFFFE6LL )
        goto LABEL_10;
    }
    v15 = 2 * v8;
    if ( v10 >= 2 * v8 )
      v15 = v7 + n;
    if ( v15 >= 0x17 )
    {
      v12 = (v15 + 16) & 0xFFFFFFFFFFFFFFF0LL;
      v13 = (char *)sub_6575418();
      if ( !v7 )
        goto LABEL_12;
    }
    else
    {
      v12 = 23LL;
      v13 = (char *)sub_6575418();
      if ( !v7 )
        goto LABEL_12;
    }
    goto LABEL_11;
  }
  v7 = a1[1];
  v8 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  if ( v8 - v7 < n )
    goto LABEL_7;
LABEL_3:
  if ( n )
  {
    if ( (v6 & 1) != 0 )
      v9 = (char *)a1[2];
    else
      v9 = (char *)a1 + 1;
    memcpy(&v9[v7], src, n);
    v16 = v7 + n;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v16;
    else
      *(_BYTE *)a1 = 2 * v16;
    v14 = &v9[v16];
LABEL_26:
    *v14 = 0;
  }
  return a1;
}


================================================================================
Function: sub_65885D4 (0x65885D4)
================================================================================

_QWORD *__fastcall sub_65885D4(_QWORD *a1)
{
  char *v2; // x8
  __int64 v3; // x0
  __int64 v4; // x8
  char *v5; // x8
  __int64 v6; // x0

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v2 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
  v3 = *((_QWORD *)v2 + 5);
  if ( v3 )
  {
    if ( !*((_DWORD *)v2 + 8) )
    {
      v4 = *((_QWORD *)v2 + 17);
      if ( v4 )
      {
        sub_65885D4(v4);
        v3 = *(_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 40);
      }
      v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 48LL))(v3);
      if ( (_DWORD)v3 == -1 )
        v3 = sub_67A8410();
    }
    v5 = (char *)a1 + *(_QWORD *)(*a1 - 24LL);
    if ( *((_QWORD *)v5 + 5) )
    {
      if ( !*((_DWORD *)v5 + 8) && (v5[9] & 0x20) != 0 && (sub_67A2EE8(v3) & 1) == 0 )
      {
        v6 = *(_QWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24LL) + 40);
        if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v6 + 48LL))(v6) == -1 )
          sub_67A8410();
      }
    }
  }
  return a1;
}


================================================================================
Function: sub_6589C04 (0x6589C04)
================================================================================

__int64 __fastcall sub_6589C04(_QWORD *a1)
{
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  *a1 = off_6BAF0D8;
  return sub_67C482C(a1 + 1);
}


================================================================================
Function: sub_6589DEC (0x6589DEC)
================================================================================

unsigned __int64 *__fastcall sub_6589DEC(unsigned __int64 *result, char a2)
{
  unsigned __int64 *v2; // x20
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x26
  size_t v6; // x21
  char *v7; // x23
  const void *v8; // x22
  unsigned __int64 v9; // x24
  unsigned __int64 v10; // x8
  char *v11; // x8

  v2 = result;
  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v4 = *(unsigned __int8 *)result;
  if ( (v4 & 1) != 0 )
  {
    v5 = result[1];
    v6 = (*result & 0xFFFFFFFFFFFFFFFELL) - 1;
    if ( v5 != v6 )
      goto LABEL_3;
LABEL_6:
    if ( v6 == -17LL )
      abort();
    if ( (v4 & 1) != 0 )
    {
      v8 = (const void *)result[2];
      if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
        goto LABEL_9;
    }
    else
    {
      v8 = (char *)result + 1;
      if ( v6 > 0x7FFFFFFFFFFFFFE6LL )
      {
LABEL_9:
        v9 = -17LL;
        goto LABEL_18;
      }
    }
    if ( v6 + 1 >= 2 * v6 )
      v10 = v6 + 1;
    else
      v10 = 2 * v6;
    if ( v10 >= 0x17 )
      v9 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v9 = 23LL;
LABEL_18:
    v7 = (char *)sub_6575418();
    result = (unsigned __int64 *)memcpy(v7, v8, v6);
    if ( v6 != 22 )
      result = (unsigned __int64 *)sub_6575460();
    v2[2] = (unsigned __int64)v7;
    *v2 = v9 | 1;
    goto LABEL_21;
  }
  v5 = v4 >> 1;
  v6 = 22LL;
  if ( v4 >> 1 == 22 )
    goto LABEL_6;
LABEL_3:
  if ( (v4 & 1) != 0 )
  {
    v7 = (char *)result[2];
LABEL_21:
    v2[1] = v5 + 1;
    goto LABEL_22;
  }
  *(_BYTE *)result = 2 * v5 + 2;
  v7 = (char *)result + 1;
LABEL_22:
  v11 = &v7[v5];
  *v11 = a2;
  v11[1] = 0;
  return result;
}


================================================================================
Function: sub_658A084 (0x658A084)
================================================================================

unsigned __int64 *__fastcall sub_658A084(unsigned __int64 *result, unsigned __int64 a2)
{
  unsigned __int64 v2; // x25
  unsigned __int64 *v3; // x19
  unsigned __int64 v4; // x23
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x24
  const void *v8; // x21
  int v9; // w26
  unsigned __int64 *v10; // x20
  int v11; // w27
  size_t v12; // x2
  unsigned __int64 v13; // x8

  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a2 >= 0xFFFFFFFFFFFFFFF0LL )
    abort();
  v2 = *(unsigned __int8 *)result;
  v3 = result;
  if ( (v2 & 1) == 0 )
  {
    v4 = v2 >> 1;
    v5 = 22LL;
    if ( v2 >> 1 <= a2 )
      v6 = a2;
    else
      v6 = v2 >> 1;
    if ( v6 >= 0x17 )
      goto LABEL_7;
LABEL_15:
    v7 = 22LL;
    if ( v5 == 22 )
      return result;
    goto LABEL_8;
  }
  v4 = result[1];
  v5 = (*result & 0xFFFFFFFFFFFFFFFELL) - 1;
  if ( v4 <= a2 )
    v6 = a2;
  else
    v6 = result[1];
  if ( v6 < 0x17 )
    goto LABEL_15;
LABEL_7:
  v7 = ((v6 + 16) & 0xFFFFFFFFFFFFFFF0LL) - 1;
  if ( v7 == v5 )
    return result;
LABEL_8:
  if ( v7 == 22 )
  {
    v8 = (const void *)result[2];
    v9 = 0;
    v10 = (unsigned __int64 *)((char *)result + 1);
    if ( (v2 & 1) == 0 )
    {
      v11 = 1;
      v12 = ((unsigned int)v2 >> 1) + 1LL;
LABEL_21:
      result = (unsigned __int64 *)memcpy(v10, v8, v12);
      goto LABEL_22;
    }
  }
  else
  {
    result = (unsigned __int64 *)sub_6575418();
    v10 = result;
    if ( (v2 & 1) == 0 )
    {
      v11 = 0;
      v8 = (char *)v3 + 1;
      v9 = 1;
      v12 = ((unsigned int)v2 >> 1) + 1LL;
      goto LABEL_21;
    }
    v8 = (const void *)v3[2];
    v9 = 1;
  }
  v13 = v3[1];
  v11 = 1;
  v12 = v13 + 1;
  if ( v13 != -1LL )
    goto LABEL_21;
LABEL_22:
  if ( v11 )
  {
    result = (unsigned __int64 *)sub_6575460();
    if ( v9 )
      goto LABEL_24;
  }
  else if ( v9 )
  {
LABEL_24:
    *v3 = (v7 + 1) | 1;
    v3[1] = v4;
    v3[2] = (unsigned __int64)v10;
    return result;
  }
  *(_BYTE *)v3 = 2 * v4;
  return result;
}


================================================================================
Function: sub_66BF1C8 (0x66BF1C8)
================================================================================

__int64 __fastcall sub_66BF1C8(int a1, __int16 a2, __int16 a3, __int64 a4, int a5)
{
  __int64 result; // x0
  int v11; // w8
  int v12; // w11
  __int64 v13; // x19
  int v14; // w9
  int v15; // w8
  int v16; // w8
  int v17; // w10
  __int64 v18; // x8
  __int64 v19; // x10
  __int64 v20; // x8

  result = sub_66BF2B8();
  if ( result )
  {
    v11 = *(_DWORD *)(result + 576);
    v12 = *(_DWORD *)(result + 580);
    v13 = result;
    v14 = v11 + 1;
    if ( v11 + 1 >= 0 )
      v15 = v11 + 1;
    else
      v15 = v11 + 16;
    v16 = v14 - (v15 & 0xFFFFFFF0);
    *(_DWORD *)(result + 576) = v16;
    if ( v16 == v12 )
    {
      v17 = v16 + 16;
      if ( v16 + 1 >= 0 )
        v17 = v16 + 1;
      *(_DWORD *)(result + 580) = v16 + 1 - (v17 & 0xFFFFFFF0);
    }
    *(_DWORD *)(result + 4LL * v16) = 0;
    v18 = *(int *)(result + 576);
    v19 = result + 8 * v18;
    *(_QWORD *)(v19 + 64) = (a1 << 24) | ((a2 & 0xFFF) << 12) | a3 & 0xFFFu;
    *(_QWORD *)(v19 + 384) = a4;
    *(_DWORD *)(result + 4 * v18 + 512) = a5;
    v20 = *(int *)(result + 576);
    if ( (*(_DWORD *)(result + 4 * v20 + 320) & 1) != 0 )
    {
      result = sub_66F0BC0(*(_QWORD *)(result + 192 + 8 * v20), "crypto/err/err.c", 457LL);
      v20 = *(int *)(v13 + 576);
      *(_QWORD *)(v13 + 192 + 8 * v20) = 0LL;
    }
    *(_DWORD *)(v13 + 4 * v20 + 320) = 0;
  }
  return result;
}


================================================================================
Function: sub_66BF2B8 (0x66BF2B8)
================================================================================

__int64 __fastcall sub_66BF2B8(__int64 a1)
{
  _DWORD *v1; // x0
  int v2; // w22
  _DWORD *v3; // x19
  __int64 v4; // x20
  __int64 v5; // x0

  v1 = (_DWORD *)__errno(a1);
  v2 = *v1;
  v3 = v1;
  if ( !(unsigned int)sub_66E2AF4(0x40000LL, 0LL) )
    return 0LL;
  v4 = 0LL;
  if ( (unsigned int)sub_6734E84(&unk_728871C, sub_66BFFD8) && dword_7288720 )
  {
    v5 = sub_6734EBC(&unk_7288710);
    if ( v5 != -1 )
    {
      v4 = v5;
      if ( v5 )
      {
LABEL_6:
        *v3 = v2;
        return v4;
      }
      if ( (unsigned int)sub_6734EC4(&unk_7288710, -1LL) )
      {
        v4 = sub_66F0A44(584LL, "crypto/err/err.c", 766LL);
        if ( !v4 )
        {
          sub_6734EC4(&unk_7288710, 0LL);
          return v4;
        }
        if ( (unsigned int)sub_66E297C(2LL) && (unsigned int)sub_6734EC4(&unk_7288710, v4) )
        {
          sub_66E2AF4(2LL, 0LL);
          goto LABEL_6;
        }
        sub_66BFCA4(v4);
        sub_6734EC4(&unk_7288710, 0LL);
      }
    }
    return 0LL;
  }
  return v4;
}


================================================================================
Function: sub_66BFCA4 (0x66BFCA4)
================================================================================

unsigned __int64 __fastcall sub_66BFCA4(unsigned __int64 result)
{
  unsigned __int64 v1; // x19
  char v2; // w8
  char v3; // w8
  char v4; // w8
  char v5; // w8
  char v6; // w8
  char v7; // w8
  char v8; // w8
  char v9; // w8
  char v10; // w8
  char v11; // w8
  char v12; // w8
  char v13; // w8
  char v14; // w8
  char v15; // w8
  char v16; // w8
  char v17; // w8
  char v18; // w8
  char v19; // w8
  char v20; // w8
  char v21; // w8
  char v22; // w8
  char v23; // w8
  char v24; // w8
  char v25; // w8
  char v26; // w8
  char v27; // w8
  char v28; // w8
  char v29; // w8
  char v30; // w8
  char v31; // w8

  if ( result )
  {
    v1 = result;
    if ( (*(_BYTE *)(result + 320) & 1) != 0 )
    {
      sub_66F0BC0(*(_QWORD *)(result + 192), (__int64)"crypto/err/err.c", 296LL);
      *(_QWORD *)(v1 + 192) = 0LL;
      v17 = *(_BYTE *)(v1 + 324);
      *(_DWORD *)(v1 + 320) = 0;
      if ( (v17 & 1) == 0 )
      {
LABEL_4:
        v3 = *(_BYTE *)(v1 + 328);
        *(_DWORD *)(v1 + 324) = 0;
        if ( (v3 & 1) == 0 )
          goto LABEL_5;
        goto LABEL_23;
      }
    }
    else
    {
      v2 = *(_BYTE *)(result + 324);
      *(_DWORD *)(result + 320) = 0;
      if ( (v2 & 1) == 0 )
        goto LABEL_4;
    }
    sub_66F0BC0(*(_QWORD *)(v1 + 200), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 200) = 0LL;
    v18 = *(_BYTE *)(v1 + 328);
    *(_DWORD *)(v1 + 324) = 0;
    if ( (v18 & 1) == 0 )
    {
LABEL_5:
      v4 = *(_BYTE *)(v1 + 332);
      *(_DWORD *)(v1 + 328) = 0;
      if ( (v4 & 1) == 0 )
        goto LABEL_6;
      goto LABEL_24;
    }
LABEL_23:
    sub_66F0BC0(*(_QWORD *)(v1 + 208), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 208) = 0LL;
    v19 = *(_BYTE *)(v1 + 332);
    *(_DWORD *)(v1 + 328) = 0;
    if ( (v19 & 1) == 0 )
    {
LABEL_6:
      v5 = *(_BYTE *)(v1 + 336);
      *(_DWORD *)(v1 + 332) = 0;
      if ( (v5 & 1) == 0 )
        goto LABEL_7;
      goto LABEL_25;
    }
LABEL_24:
    sub_66F0BC0(*(_QWORD *)(v1 + 216), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 216) = 0LL;
    v20 = *(_BYTE *)(v1 + 336);
    *(_DWORD *)(v1 + 332) = 0;
    if ( (v20 & 1) == 0 )
    {
LABEL_7:
      v6 = *(_BYTE *)(v1 + 340);
      *(_DWORD *)(v1 + 336) = 0;
      if ( (v6 & 1) == 0 )
        goto LABEL_8;
      goto LABEL_26;
    }
LABEL_25:
    sub_66F0BC0(*(_QWORD *)(v1 + 224), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 224) = 0LL;
    v21 = *(_BYTE *)(v1 + 340);
    *(_DWORD *)(v1 + 336) = 0;
    if ( (v21 & 1) == 0 )
    {
LABEL_8:
      v7 = *(_BYTE *)(v1 + 344);
      *(_DWORD *)(v1 + 340) = 0;
      if ( (v7 & 1) == 0 )
        goto LABEL_9;
      goto LABEL_27;
    }
LABEL_26:
    sub_66F0BC0(*(_QWORD *)(v1 + 232), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 232) = 0LL;
    v22 = *(_BYTE *)(v1 + 344);
    *(_DWORD *)(v1 + 340) = 0;
    if ( (v22 & 1) == 0 )
    {
LABEL_9:
      v8 = *(_BYTE *)(v1 + 348);
      *(_DWORD *)(v1 + 344) = 0;
      if ( (v8 & 1) == 0 )
        goto LABEL_10;
      goto LABEL_28;
    }
LABEL_27:
    sub_66F0BC0(*(_QWORD *)(v1 + 240), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 240) = 0LL;
    v23 = *(_BYTE *)(v1 + 348);
    *(_DWORD *)(v1 + 344) = 0;
    if ( (v23 & 1) == 0 )
    {
LABEL_10:
      v9 = *(_BYTE *)(v1 + 352);
      *(_DWORD *)(v1 + 348) = 0;
      if ( (v9 & 1) == 0 )
        goto LABEL_11;
      goto LABEL_29;
    }
LABEL_28:
    sub_66F0BC0(*(_QWORD *)(v1 + 248), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 248) = 0LL;
    v24 = *(_BYTE *)(v1 + 352);
    *(_DWORD *)(v1 + 348) = 0;
    if ( (v24 & 1) == 0 )
    {
LABEL_11:
      v10 = *(_BYTE *)(v1 + 356);
      *(_DWORD *)(v1 + 352) = 0;
      if ( (v10 & 1) == 0 )
        goto LABEL_12;
      goto LABEL_30;
    }
LABEL_29:
    sub_66F0BC0(*(_QWORD *)(v1 + 256), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 256) = 0LL;
    v25 = *(_BYTE *)(v1 + 356);
    *(_DWORD *)(v1 + 352) = 0;
    if ( (v25 & 1) == 0 )
    {
LABEL_12:
      v11 = *(_BYTE *)(v1 + 360);
      *(_DWORD *)(v1 + 356) = 0;
      if ( (v11 & 1) == 0 )
        goto LABEL_13;
      goto LABEL_31;
    }
LABEL_30:
    sub_66F0BC0(*(_QWORD *)(v1 + 264), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 264) = 0LL;
    v26 = *(_BYTE *)(v1 + 360);
    *(_DWORD *)(v1 + 356) = 0;
    if ( (v26 & 1) == 0 )
    {
LABEL_13:
      v12 = *(_BYTE *)(v1 + 364);
      *(_DWORD *)(v1 + 360) = 0;
      if ( (v12 & 1) == 0 )
        goto LABEL_14;
      goto LABEL_32;
    }
LABEL_31:
    sub_66F0BC0(*(_QWORD *)(v1 + 272), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 272) = 0LL;
    v27 = *(_BYTE *)(v1 + 364);
    *(_DWORD *)(v1 + 360) = 0;
    if ( (v27 & 1) == 0 )
    {
LABEL_14:
      v13 = *(_BYTE *)(v1 + 368);
      *(_DWORD *)(v1 + 364) = 0;
      if ( (v13 & 1) == 0 )
        goto LABEL_15;
      goto LABEL_33;
    }
LABEL_32:
    sub_66F0BC0(*(_QWORD *)(v1 + 280), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 280) = 0LL;
    v28 = *(_BYTE *)(v1 + 368);
    *(_DWORD *)(v1 + 364) = 0;
    if ( (v28 & 1) == 0 )
    {
LABEL_15:
      v14 = *(_BYTE *)(v1 + 372);
      *(_DWORD *)(v1 + 368) = 0;
      if ( (v14 & 1) == 0 )
        goto LABEL_16;
      goto LABEL_34;
    }
LABEL_33:
    sub_66F0BC0(*(_QWORD *)(v1 + 288), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 288) = 0LL;
    v29 = *(_BYTE *)(v1 + 372);
    *(_DWORD *)(v1 + 368) = 0;
    if ( (v29 & 1) == 0 )
    {
LABEL_16:
      v15 = *(_BYTE *)(v1 + 376);
      *(_DWORD *)(v1 + 372) = 0;
      if ( (v15 & 1) == 0 )
        goto LABEL_17;
      goto LABEL_35;
    }
LABEL_34:
    sub_66F0BC0(*(_QWORD *)(v1 + 296), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 296) = 0LL;
    v30 = *(_BYTE *)(v1 + 376);
    *(_DWORD *)(v1 + 372) = 0;
    if ( (v30 & 1) == 0 )
    {
LABEL_17:
      v16 = *(_BYTE *)(v1 + 380);
      *(_DWORD *)(v1 + 376) = 0;
      if ( (v16 & 1) == 0 )
      {
LABEL_19:
        *(_DWORD *)(v1 + 380) = 0;
        return sub_66F0BC0(v1, (__int64)"crypto/err/err.c", 298LL);
      }
LABEL_18:
      sub_66F0BC0(*(_QWORD *)(v1 + 312), (__int64)"crypto/err/err.c", 296LL);
      *(_QWORD *)(v1 + 312) = 0LL;
      goto LABEL_19;
    }
LABEL_35:
    sub_66F0BC0(*(_QWORD *)(v1 + 304), (__int64)"crypto/err/err.c", 296LL);
    *(_QWORD *)(v1 + 304) = 0LL;
    v31 = *(_BYTE *)(v1 + 380);
    *(_DWORD *)(v1 + 376) = 0;
    if ( (v31 & 1) == 0 )
      goto LABEL_19;
    goto LABEL_18;
  }
  return result;
}


================================================================================
Function: sub_66E297C (0x66E297C)
================================================================================

_DWORD *__fastcall sub_66E297C(char a1)
{
  _DWORD *result; // x0
  _BOOL4 v3; // w8
  _BOOL4 v4; // w8
  _BOOL4 v5; // w8
  _DWORD *v6; // x20

  if ( byte_728913C == 1 )
  {
    sub_66BF1C8(15, 116, 70, (__int64)"crypto/init.c", 615);
    return 0LL;
  }
  v3 = sub_6734E84(&dword_7289158, (void (*)(void))sub_66E2F48);
  result = 0LL;
  if ( v3 )
  {
    if ( dword_728915C )
    {
      v4 = sub_6734E84(&dword_7289160, (void (*)(void))sub_66E2FD0);
      result = 0LL;
      if ( v4 )
      {
        if ( dword_7289164 )
        {
          v5 = sub_6734E84(&dword_7289168, (void (*)(void))sub_66E2FFC);
          result = 0LL;
          if ( v5 )
          {
            if ( byte_7289148 )
            {
              v6 = (_DWORD *)sub_6734EBC(&qword_6C34570);
              if ( !v6 )
              {
                result = sub_66F0A44(0xCuLL, (__int64)"crypto/init.c", 66LL);
                if ( !result )
                  return result;
                v6 = result;
                if ( !sub_6734EC4((pthread_key_t *)&qword_6C34570, result) )
                {
                  sub_66F0BC0((unsigned __int64)v6, (__int64)"crypto/init.c", 68LL);
                  return 0LL;
                }
              }
              if ( (a1 & 1) != 0 )
              {
                *v6 = 1;
                if ( (a1 & 2) == 0 )
                {
LABEL_12:
                  result = &dword_0 + 1;
                  if ( (a1 & 4) == 0 )
                    return result;
LABEL_16:
                  v6[2] = 1;
                  return result;
                }
              }
              else if ( (a1 & 2) == 0 )
              {
                goto LABEL_12;
              }
              v6[1] = 1;
              result = &dword_0 + 1;
              if ( (a1 & 4) == 0 )
                return result;
              goto LABEL_16;
            }
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_66E2AF4 (0x66E2AF4)
================================================================================

__int64 __fastcall sub_66E2AF4(int a1, __int64 a2)
{
  __int64 result; // x0
  _BOOL4 v5; // w8
  void (*v6)(void); // x1
  _BOOL4 v7; // w8
  _BOOL4 v8; // w8
  _BOOL4 v9; // w8
  _BOOL4 v10; // w8
  _BOOL4 v11; // w8
  _BOOL4 v12; // w8
  _BOOL4 v13; // w8
  _BOOL4 v14; // w8
  _BOOL4 v15; // w8
  _BOOL4 v16; // w20
  int v17; // w22
  _BOOL4 v18; // w8
  _BOOL4 v19; // w8

  if ( byte_728913C == 1 )
  {
    if ( (a1 & 0x40000) == 0 )
      sub_66BF1C8(15, 116, 70, (__int64)"crypto/init.c", 615);
    return 0LL;
  }
  else
  {
    v5 = sub_6734E84(&dword_7289158, (void (*)(void))sub_66E2F48);
    result = 0LL;
    if ( v5 && dword_728915C )
    {
      if ( (a1 & 0x40000) != 0 )
        return 1LL;
      v6 = (void (*)(void))((a1 & 0x80000) != 0 ? sub_66E2FC0 : sub_66E2FD0);
      v7 = sub_6734E84(&dword_7289160, v6);
      result = 0LL;
      if ( v7 )
      {
        if ( dword_7289164 )
        {
          v8 = sub_6734E84(&dword_7289168, (void (*)(void))sub_66E2FFC);
          result = 0LL;
          if ( v8 )
          {
            if ( byte_7289148 )
            {
              if ( (a1 & 1) == 0
                || (v9 = sub_6734E84(&dword_728916C, (void (*)(void))sub_66E300C), result = 0LL, v9) && dword_7289170 )
              {
                if ( (a1 & 2) == 0
                  || (v10 = sub_6734E84(&dword_728916C, (void (*)(void))sub_66E301C), result = 0LL, v10)
                  && dword_7289170 )
                {
                  if ( (a1 & 0x10) == 0
                    || (v11 = sub_6734E84(dword_7289174, (void (*)(void))sub_66E3038), result = 0LL, v11)
                    && byte_728914C )
                  {
                    if ( (a1 & 4) == 0
                      || (v12 = sub_6734E84(dword_7289174, (void (*)(void))sub_66E3048), result = 0LL, v12)
                      && byte_728914C )
                    {
                      if ( (a1 & 0x20) == 0
                        || (v13 = sub_6734E84(&dword_7289174[1], (void (*)(void))sub_66E3068), result = 0LL, v13)
                        && byte_7289150 )
                      {
                        if ( (a1 & 8) == 0
                          || (v14 = sub_6734E84(&dword_7289174[1], (void (*)(void))sub_66E3078), result = 0LL, v14)
                          && byte_7289150 )
                        {
                          if ( (a1 & 0x20000) == 0 || (result = sub_6734F28(0LL), (_DWORD)result) )
                          {
                            if ( (a1 & 0x80) == 0
                              || (v15 = sub_6734E84(&dword_728917C, (void (*)(void))sub_66E3098), result = 0LL, v15)
                              && dword_7289180 )
                            {
                              if ( (a1 & 0x40) == 0
                                || (sub_6734E14(qword_7289198),
                                    qword_72891A0 = a2,
                                    v16 = sub_6734E84(&dword_728917C, (void (*)(void))sub_66E30B8),
                                    v17 = dword_7289180,
                                    qword_72891A0 = 0LL,
                                    sub_6734E30(qword_7289198),
                                    result = 0LL,
                                    v16)
                                && v17 >= 1 )
                              {
                                if ( (a1 & 0x100) == 0
                                  || (v18 = sub_6734E84(&dword_7289184, (void (*)(void))sub_66E30E4), result = 0LL, v18)
                                  && dword_7289188 )
                                {
                                  if ( (a1 & 0x10000) == 0 )
                                    return 1LL;
                                  v19 = sub_6734E84((pthread_once_t *)algn_728918C, (void (*)(void))sub_66E3124);
                                  result = 0LL;
                                  if ( v19 )
                                  {
                                    if ( byte_7289154 )
                                      return 1LL;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_66E313C (0x66E313C)
================================================================================

__int64 __fastcall sub_66E313C(__int64 a1)
{
  _QWORD *v2; // x0

  v2 = (_QWORD *)sub_66F0A04(16LL, "crypto/init.c", 807LL);
  if ( v2 )
  {
    *v2 = a1;
    v2[1] = qword_7289190;
    qword_7289190 = (__int64)v2;
    return 1LL;
  }
  else
  {
    sub_66BF1C8(15LL, 114LL, 65LL, "crypto/init.c", 808LL);
    return 0LL;
  }
}


================================================================================
Function: sub_66F0674 (0x66F0674)
================================================================================

__int64 __fastcall sub_66F0674(_OWORD *a1)
{
  __int64 result; // x0

  *(_OWORD *)((char *)a1 + 76) = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[2] = 0u;
  *a1 = xmmword_AFB090;
  result = 1LL;
  a1[1] = 0u;
  return result;
}


================================================================================
Function: sub_66F097C (0x66F097C)
================================================================================

__int64 __fastcall sub_66F097C(__int64 (__fastcall *a1)(), __int64 (__fastcall *a2)(), __int64 (__fastcall *a3)())
{
  if ( (byte_72891C0 & 1) != 0 )
    return 0LL;
  if ( a1 )
    off_6C34580[0] = a1;
  if ( a2 )
    off_6C34588[0] = a2;
  if ( a3 )
    off_6C34590 = a3;
  return 1LL;
}


================================================================================
Function: sub_66F0A04 (0x66F0A04)
================================================================================

unsigned __int64 __fastcall sub_66F0A04(unsigned __int64 result, __int64 a2, __int64 a3)
{
  if ( off_6C34580 && off_6C34580 != sub_66F0A04 )
    return off_6C34580(result, a2, a3);
  if ( result )
  {
    if ( (byte_72891C0 & 1) == 0 )
      byte_72891C0 = 1;
    return sub_677CA08(result);
  }
  return result;
}


================================================================================
Function: sub_66F0A44 (0x66F0A44)
================================================================================

void *__fastcall sub_66F0A44(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  void *v4; // x20

  if ( off_6C34580 && (char *)off_6C34580 != (char *)sub_66F0A04 )
  {
    v4 = (void *)off_6C34580(a1, a2, a3);
    if ( !v4 )
      return v4;
    goto LABEL_9;
  }
  if ( a1 )
  {
    if ( (byte_72891C0 & 1) == 0 )
      byte_72891C0 = 1;
    v4 = (void *)sub_677CA08(a1);
    if ( !v4 )
      return v4;
LABEL_9:
    memset(v4, 0, a1);
    return v4;
  }
  return 0LL;
}


================================================================================
Function: sub_66F0BC0 (0x66F0BC0)
================================================================================

unsigned __int64 __fastcall sub_66F0BC0(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  if ( !off_6C34590 || off_6C34590 == sub_66F0BC0 )
    return sub_677CBEC(a1);
  else
    return off_6C34590(a1, a2, a3);
}


================================================================================
Function: sub_6734E14 (0x6734E14)
================================================================================

bool __fastcall sub_6734E14(pthread_rwlock_t *a1)
{
  return pthread_rwlock_wrlock(a1) == 0;
}


================================================================================
Function: sub_6734E30 (0x6734E30)
================================================================================

bool __fastcall sub_6734E30(pthread_rwlock_t *a1)
{
  return pthread_rwlock_unlock(a1) == 0;
}


================================================================================
Function: sub_6734E84 (0x6734E84)
================================================================================

bool __fastcall sub_6734E84(pthread_once_t *a1, void (*a2)(void))
{
  return pthread_once(a1, a2) == 0;
}


================================================================================
Function: sub_6734EBC (0x6734EBC)
================================================================================

void *__fastcall sub_6734EBC(pthread_key_t *a1)
{
  return pthread_getspecific(*a1);
}


================================================================================
Function: sub_6734EC4 (0x6734EC4)
================================================================================

bool __fastcall sub_6734EC4(pthread_key_t *a1, const void *a2)
{
  return pthread_setspecific(*a1, a2) == 0;
}


================================================================================
Function: sub_6734F28 (0x6734F28)
================================================================================

bool sub_6734F28()
{
  return pthread_once(dword_7289490, (void (*)(void))sub_6734F54) == 0;
}


================================================================================
Function: sub_675F18C (0x675F18C)
================================================================================

__int64 sub_675F18C()
{
  __int64 v1; // [xsp+8h] [xbp-18h] BYREF
  __int64 v2; // [xsp+10h] [xbp-10h]

  clock_gettime(0, (struct timespec *)&v1);
  return v2 + 1000000000 * v1;
}


================================================================================
Function: sub_675F1F4 (0x675F1F4)
================================================================================

__int64 sub_675F1F4()
{
  __int64 v1; // [xsp+8h] [xbp-18h] BYREF
  __int64 v2; // [xsp+10h] [xbp-10h]

  clock_gettime(1, (struct timespec *)&v1);
  return v2 + 1000000000 * v1;
}


================================================================================
Function: sub_675FD74 (0x675FD74)
================================================================================

unsigned __int8 *__fastcall sub_675FD74(__int64 a1, char *a2, unsigned __int8 *a3, __int64 a4, __int64 a5)
{
  __int64 v9; // x0

  sub_67D24BC((_QWORD *)a1, a2);
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)a1 = off_6876838;
  v9 = sub_6575418();
  *(_QWORD *)(v9 + 64) = 0LL;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  sub_2D7C96C(a1 + 56);
  return sub_67D3420(*(unsigned __int8 **)(a1 + 56), a3);
}


================================================================================
Function: sub_6760348 (0x6760348)
================================================================================

__int64 __fastcall sub_6760348(__int64 a1, __int64 a2)
{
  char v4; // w20
  unsigned __int64 v5; // x8
  __int64 v7; // x20
  _BYTE v8[24]; // [xsp+8h] [xbp-48h] BYREF
  _QWORD v9[2]; // [xsp+20h] [xbp-30h] BYREF
  __int128 v10; // [xsp+38h] [xbp-18h] BYREF

  LODWORD(v10) = 0;
  *((_QWORD *)&v10 + 1) = sub_6765A30();
  if ( (unsigned int)sub_67617C4(a1, (__int64)&v10) == 3 )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = 0;
      v4 = 0;
      *(_QWORD *)(a2 + 8) = sub_6765A30();
    }
    else
    {
      v4 = 0;
    }
    return v4 & 1;
  }
  sub_6763F98(v9, a1);
  if ( (v9[0] & 1) != 0 )
    v5 = v9[1];
  else
    v5 = (unsigned __int64)LOBYTE(v9[0]) >> 1;
  if ( !v5 || (unsigned int)sub_67617C4((__int64)v9, (__int64)&v10) != 1 || (sub_6760348(v9, &v10), !(_DWORD)v10) )
  {
    v4 = sub_6760518(a1, a2);
    if ( (v9[0] & 1) == 0 )
      return v4 & 1;
LABEL_14:
    sub_6575460();
    return v4 & 1;
  }
  if ( !a2 )
  {
    v7 = sub_67EAFB8(72LL);
    sub_254CDB4((int)v8, "boost::filesystem::create_directories");
    sub_675FD74(v7, v8, v9, v10, *((_QWORD *)&v10 + 1));
    sub_67EB030(v7, (__int64)&`typeinfo for'boost::filesystem::filesystem_error, (__int64)sub_2D7C72C);
  }
  v4 = 0;
  *(_OWORD *)a2 = v10;
  if ( (v9[0] & 1) != 0 )
    goto LABEL_14;
  return v4 & 1;
}


================================================================================
Function: sub_6760518 (0x6760518)
================================================================================

bool __fastcall sub_6760518(__int64 a1, __int64 a2)
{
  const char *v4; // x0
  __int64 v5; // x0
  int v6; // w20
  __int64 v7; // x22
  __int64 *v8; // x0
  __int64 v10; // x19
  __int64 *v11; // x0
  unsigned __int64 v12[2]; // [xsp+20h] [xbp-30h] BYREF
  _QWORD v13[2]; // [xsp+38h] [xbp-18h] BYREF

  if ( (*(_BYTE *)a1 & 1) != 0 )
    v4 = *(const char **)(a1 + 16);
  else
    v4 = (const char *)(a1 + 1);
  v5 = mkdir(v4, 0x1FFu);
  v6 = v5;
  if ( (_DWORD)v5 )
  {
    v7 = *(unsigned int *)__errno(v5);
    LODWORD(v13[0]) = 0;
    v13[1] = sub_6765A30();
    if ( (_DWORD)v7 != 17 || (unsigned int)sub_67617C4(a1, (__int64)v13) != 3 )
    {
      if ( !a2 )
      {
        v10 = sub_67EAFB8(72LL);
        sub_254CDB4(v12, "boost::filesystem::create_directory");
        v11 = sub_6765A30();
        sub_675FD74(v10, (char *)v12, (unsigned __int8 *)a1, v7, (__int64)v11);
        sub_67EB030(v10, (__int64)&`typeinfo for'boost::filesystem::filesystem_error, (__int64)sub_2D7C72C);
      }
      v8 = sub_6765A30();
      *(_DWORD *)a2 = v7;
      goto LABEL_11;
    }
  }
  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    v8 = sub_6765A30();
LABEL_11:
    *(_QWORD *)(a2 + 8) = v8;
  }
  return v6 == 0;
}


================================================================================
Function: sub_67617C4 (0x67617C4)
================================================================================

unsigned __int64 __fastcall sub_67617C4(__int64 a1, __int64 a2)
{
  const char *v4; // x0
  __int64 v5; // x0
  _DWORD *v6; // x0
  _DWORD *v7; // x21
  int v8; // w23
  __int64 *v9; // x0
  unsigned __int16 v10; // w9
  __int64 v11; // x0
  int v12; // w0
  bool v13; // zf
  int v14; // w8
  __int64 v15; // x20
  __int64 v16; // x21
  __int64 *v17; // x0
  _BYTE v19[24]; // [xsp+0h] [xbp-A0h] BYREF
  _BYTE v20[16]; // [xsp+18h] [xbp-88h] BYREF
  int v21; // [xsp+28h] [xbp-78h]

  if ( (*(_BYTE *)a1 & 1) != 0 )
    v4 = *(const char **)(a1 + 16);
  else
    v4 = (const char *)(a1 + 1);
  v5 = stat(v4, (struct stat *)v20);
  if ( (_DWORD)v5 )
  {
    v6 = (_DWORD *)__errno(v5);
    v7 = v6;
    if ( a2 )
    {
      v8 = *v6;
      v9 = sub_6765A30();
      *(_DWORD *)a2 = v8;
      *(_QWORD *)(a2 + 8) = v9;
    }
    v10 = 0;
    v11 = 1LL;
    if ( *v7 != 2 && *v7 != 20 )
    {
      v12 = sub_2D7C0E4(a1, &byte_CBCB6C);
      v13 = v12 == 0;
      v14 = v12;
      v11 = v12 == 0;
      if ( v13 )
        v10 = 0;
      else
        v10 = -1;
      if ( v14 && !a2 )
      {
        v15 = sub_67EAFB8(72LL);
        sub_254CDB4((int)v19, "boost::filesystem::status");
        v16 = (unsigned int)*v7;
        v17 = sub_6765A30();
        sub_675FD74(v15, v19, a1, v16, v17);
        sub_67EB030(v15, (__int64)&`typeinfo for'boost::filesystem::filesystem_error, (__int64)sub_2D7C72C);
      }
    }
  }
  else
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = sub_6765A30();
    }
    v11 = 10LL;
    v10 = -1;
    switch ( ((v21 & 0xF000u) - 4096) >> 12 )
    {
      case 0u:
        v10 = v21 & 0xFFF;
        v11 = 7LL;
        break;
      case 1u:
        v10 = v21 & 0xFFF;
        v11 = 6LL;
        break;
      case 3u:
        v10 = v21 & 0xFFF;
        v11 = 3LL;
        break;
      case 5u:
        v10 = v21 & 0xFFF;
        v11 = 5LL;
        break;
      case 7u:
        v10 = v21 & 0xFFF;
        v11 = 2LL;
        break;
      case 0xBu:
        v10 = v21 & 0xFFF;
        v11 = 8LL;
        break;
      default:
        return v11 & 0xFFFF0000FFFFFFFFLL | ((unsigned __int64)v10 << 32);
    }
  }
  return v11 & 0xFFFF0000FFFFFFFFLL | ((unsigned __int64)v10 << 32);
}


================================================================================
Function: sub_6762998 (0x6762998)
================================================================================

unsigned __int64 *__fastcall sub_6762998(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v3; // x10
  size_t v4; // x8
  int v5; // w9
  size_t v6; // x10
  size_t v7; // x11
  void *v9; // x11
  _BYTE *v10; // x12
  unsigned __int64 v11; // x12
  unsigned __int64 v12; // x13
  unsigned __int64 *v13; // x12
  unsigned __int64 v14; // x10
  void *v15; // x1
  size_t v16; // x2
  unsigned int v17; // w8
  char *v18; // x9
  int v19; // w10
  char *v20; // x11
  unsigned __int64 v21; // x11
  unsigned __int64 v22; // x12
  unsigned __int8 *v23; // x11
  char *v24; // x1
  size_t v25; // x8
  size_t v26; // x2
  unsigned __int64 v28[2]; // [xsp+0h] [xbp-20h] BYREF
  char *v29; // [xsp+10h] [xbp-10h]

  v3 = *(unsigned __int8 *)a2;
  v4 = a2[1];
  v5 = v3 & 1;
  v6 = v3 >> 1;
  if ( v5 )
    v7 = a2[1];
  else
    v7 = v6;
  if ( v7 )
  {
    if ( a1 == a2 )
    {
      sub_67D2788(v28, (__int128 *)a2);
      v17 = LOBYTE(v28[0]);
      v18 = v29;
      v19 = v28[0] & 1;
      if ( v19 )
        v20 = v29;
      else
        v20 = (char *)v28 + 1;
      if ( *v20 != 47 )
      {
        v21 = *(unsigned __int8 *)a2;
        v22 = a2[1];
        if ( (v21 & 1) == 0 )
          v22 = v21 >> 1;
        if ( v22 )
        {
          v23 = (v21 & 1) != 0 ? (unsigned __int8 *)a2[2] : (unsigned __int8 *)a2 + 1;
          if ( v23[v22 - 1] != 47 )
          {
            sub_6589DEC(a2, 47);
            v17 = LOBYTE(v28[0]);
            v18 = v29;
            v19 = v28[0] & 1;
          }
        }
      }
      if ( v19 )
        v24 = v18;
      else
        v24 = (char *)v28 + 1;
      v25 = v17 >> 1;
      if ( v19 )
        v26 = v28[1];
      else
        v26 = v25;
      sub_6588400(a2, v24, v26);
      if ( (v28[0] & 1) != 0 )
        sub_6575460();
    }
    else
    {
      v9 = (void *)a2[2];
      if ( v5 )
        v10 = (_BYTE *)a2[2];
      else
        v10 = (char *)a2 + 1;
      if ( *v10 != 47 )
      {
        v11 = *(unsigned __int8 *)a1;
        v12 = a1[1];
        if ( (v11 & 1) == 0 )
          v12 = v11 >> 1;
        if ( v12 )
        {
          v13 = (v11 & 1) != 0 ? (unsigned __int64 *)a1[2] : (unsigned __int64 *)((char *)a1 + 1);
          if ( *((_BYTE *)v13 + v12 - 1) != 47 )
          {
            sub_6589DEC(a1, 47);
            v14 = *(unsigned __int8 *)a2;
            v4 = a2[1];
            v9 = (void *)a2[2];
            v5 = v14 & 1;
            v6 = v14 >> 1;
          }
        }
      }
      if ( v5 )
        v15 = v9;
      else
        v15 = (char *)a2 + 1;
      if ( v5 )
        v16 = v4;
      else
        v16 = v6;
      sub_6588400(a1, v15, v16);
    }
  }
  return a1;
}


================================================================================
Function: sub_6762BB8 (0x6762BB8)
================================================================================

unsigned __int64 *__fastcall sub_6762BB8(unsigned __int64 *a1, char *s)
{
  unsigned int v3; // w9
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x11
  size_t v7; // x0
  size_t v8; // x21
  char *v9; // x22
  unsigned __int64 v10; // x9
  unsigned __int64 v12; // x23
  unsigned int v13; // w8
  char *v14; // x9
  int v15; // w10
  char *v16; // x11
  unsigned __int64 v17; // x11
  unsigned __int64 v18; // x12
  unsigned __int64 *v19; // x11
  char *v20; // x1
  size_t v21; // x8
  size_t v22; // x2
  __int64 v23; // [xsp+0h] [xbp-20h] BYREF
  size_t v24; // [xsp+8h] [xbp-18h]
  char *v25; // [xsp+10h] [xbp-10h]

  if ( !*s )
    return a1;
  v3 = *(unsigned __int8 *)a1;
  v5 = a1[2];
  if ( (v3 & 1) == 0 )
    v5 = (unsigned __int64)a1 + 1;
  if ( v5 <= (unsigned __int64)s )
  {
    v6 = a1[1];
    if ( (v3 & 1) == 0 )
      v6 = v3 >> 1;
    if ( v5 + v6 > (unsigned __int64)s )
    {
      v7 = strlen(s);
      if ( v7 >= 0xFFFFFFFFFFFFFFF0LL )
        sub_67D2618();
      v8 = v7;
      if ( v7 >= 0x17 )
      {
        v12 = (v7 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v9 = (char *)sub_6575418();
        v24 = v8;
        v25 = v9;
        v23 = v12 | 1;
      }
      else
      {
        v9 = (char *)&v23 + 1;
        LOBYTE(v23) = 2 * v7;
        if ( !v7 )
          goto LABEL_23;
      }
      memcpy(v9, s, v8);
LABEL_23:
      v9[v8] = 0;
      v13 = (unsigned __int8)v23;
      v14 = v25;
      v15 = v23 & 1;
      if ( v15 )
        v16 = v25;
      else
        v16 = (char *)&v23 + 1;
      if ( *v16 != 47 )
      {
        v17 = *(unsigned __int8 *)a1;
        v18 = a1[1];
        if ( (v17 & 1) == 0 )
          v18 = v17 >> 1;
        if ( v18 )
        {
          v19 = (v17 & 1) != 0 ? (unsigned __int64 *)a1[2] : (unsigned __int64 *)((char *)a1 + 1);
          if ( *((_BYTE *)v19 + v18 - 1) != 47 )
          {
            sub_6589DEC(a1, 47);
            v13 = (unsigned __int8)v23;
            v14 = v25;
            v15 = v23 & 1;
          }
        }
      }
      if ( v15 )
        v20 = v14;
      else
        v20 = (char *)&v23 + 1;
      v21 = v13 >> 1;
      if ( v15 )
        v22 = v24;
      else
        v22 = v21;
      sub_6588400(a1, v20, v22);
      if ( (v23 & 1) != 0 )
        sub_6575460();
      return a1;
    }
  }
  if ( *s != 47 )
  {
    v10 = (v3 & 1) != 0 ? a1[1] : v3 >> 1;
    if ( v10 && *(_BYTE *)(v5 + v10 - 1) != 47 )
      sub_6589DEC(a1, 47);
  }
  sub_67D352C(a1, s);
  return a1;
}


================================================================================
Function: sub_6762DC8 (0x6762DC8)
================================================================================

__int64 __fastcall sub_6762DC8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x8
  unsigned int v10; // w19
  _QWORD v12[5]; // [xsp+8h] [xbp-A8h] BYREF
  _QWORD v13[2]; // [xsp+30h] [xbp-80h] BYREF
  _QWORD v14[5]; // [xsp+58h] [xbp-58h] BYREF
  _QWORD v15[2]; // [xsp+80h] [xbp-30h] BYREF

  sub_67630AC(v15);
  v4 = *a1;
  memset(v14, 0, 24);
  v5 = *((_QWORD *)a1 + 1);
  v14[3] = a1;
  if ( (v4 & 1) != 0 )
    v6 = v5;
  else
    v6 = v4 >> 1;
  v14[4] = v6;
  sub_67630AC(v13);
  v7 = *a2;
  memset(v12, 0, 24);
  v8 = *((_QWORD *)a2 + 1);
  v12[3] = a2;
  if ( (v7 & 1) != 0 )
    v9 = v8;
  else
    v9 = v7 >> 1;
  v12[4] = v9;
  v10 = sub_6762EDC(v15, v14, v13, v12);
  if ( (v13[0] & 1) != 0 )
    sub_6575460();
  if ( (v15[0] & 1) != 0 )
    sub_6575460();
  return v10;
}


================================================================================
Function: sub_6762EDC (0x6762EDC)
================================================================================

__int64 __fastcall sub_6762EDC(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4)
{
  __int64 v4; // x10
  __int64 v5; // x11
  __int64 v8; // x8
  __int64 v9; // x9
  __int64 result; // x0
  __int64 v13; // x12
  __int64 v14; // x13
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x9
  size_t v17; // x28
  size_t v18; // x26
  size_t v19; // x23
  const void *v20; // x24
  const void *v21; // x25
  int v22; // w0
  int v23; // w0
  char *v24; // [xsp+8h] [xbp-8h]

  v4 = *(_QWORD *)(a2 + 24);
  v5 = *(_QWORD *)(a2 + 32);
  v9 = a1[3];
  v8 = a1[4];
  if ( v9 == v4 && v8 == v5 )
  {
LABEL_3:
    v4 = v9;
    v5 = v8;
  }
  else
  {
    v13 = a3[3];
    v14 = *(_QWORD *)(a4 + 24);
    v24 = (char *)a3 + 1;
    while ( v13 != v14 || a3[4] != *(_QWORD *)(a4 + 32) )
    {
      v15 = *(unsigned __int8 *)a3;
      v16 = *(unsigned __int8 *)a1;
      if ( (v15 & 1) != 0 )
        v17 = a3[1];
      else
        v17 = v15 >> 1;
      if ( (v16 & 1) != 0 )
        v18 = a1[1];
      else
        v18 = v16 >> 1;
      if ( v17 >= v18 )
        v19 = v18;
      else
        v19 = v17;
      if ( v19 )
      {
        if ( (v15 & 1) != 0 )
          v20 = (const void *)a3[2];
        else
          v20 = v24;
        if ( (v16 & 1) != 0 )
          v21 = (const void *)a1[2];
        else
          v21 = (char *)a1 + 1;
        v22 = memcmp(v21, v20, v19);
        if ( v22 )
        {
          if ( v22 < 0 )
            return 0xFFFFFFFFLL;
        }
        else if ( v18 < v17 )
        {
          return 0xFFFFFFFFLL;
        }
        v23 = memcmp(v20, v21, v19);
        if ( v23 )
        {
          if ( v23 < 0 )
            return 1LL;
        }
        else if ( v17 < v18 )
        {
          return 1LL;
        }
      }
      else if ( v17 != v18 )
      {
        if ( v17 > v18 )
          return 0xFFFFFFFFLL;
        else
          return 1LL;
      }
      sub_6765208(a1);
      sub_6765208(a3);
      v4 = *(_QWORD *)(a2 + 24);
      v5 = *(_QWORD *)(a2 + 32);
      v9 = a1[3];
      v8 = a1[4];
      if ( v9 == v4 && v8 == v5 )
        goto LABEL_3;
      v13 = a3[3];
      v14 = *(_QWORD *)(a4 + 24);
    }
  }
  result = 1LL;
  if ( v9 == v4 && v8 == v5 )
  {
    result = 0xFFFFFFFFLL;
    if ( a3[3] == *(_QWORD *)(a4 + 24) && a3[4] == *(_QWORD *)(a4 + 32) )
      return 0LL;
  }
  return result;
}


================================================================================
Function: sub_67630AC (0x67630AC)
================================================================================

_QWORD *__usercall sub_67630AC@<X0>(unsigned __int8 *a1@<X0>, unsigned __int8 *a2@<X8>)
{
  unsigned __int64 v3; // x9
  unsigned __int64 v4; // x8
  unsigned __int8 *v5; // x9
  int v6; // w10
  unsigned __int64 v7; // x2
  size_t v8; // x3
  __int64 v9; // x10
  int v10; // w11
  _QWORD *result; // x0
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x8
  size_t v14[2]; // [xsp+0h] [xbp-20h] BYREF

  v3 = *a1;
  *(_QWORD *)a2 = 0LL;
  *((_QWORD *)a2 + 1) = 0LL;
  v4 = *((_QWORD *)a1 + 1);
  *((_QWORD *)a2 + 2) = 0LL;
  *((_QWORD *)a2 + 3) = a1;
  *((_QWORD *)a2 + 4) = 0LL;
  if ( (v3 & 1) == 0 )
    v4 = v3 >> 1;
  if ( v4 )
  {
    if ( (v3 & 1) != 0 )
      v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
    else
      v5 = a1 + 1;
    v6 = *v5;
    if ( v4 == 1 )
    {
      v7 = 0LL;
      if ( v6 != 47 )
      {
        v8 = 0LL;
        goto LABEL_23;
      }
      goto LABEL_9;
    }
    if ( v6 != 47 )
    {
      v8 = 0LL;
      goto LABEL_23;
    }
    if ( v5[1] == 47 )
    {
      if ( v4 != 2 && v5[2] == 47 )
      {
        v9 = 2LL;
        do
        {
          v7 = v9 - 1;
          *((_QWORD *)a2 + 4) = v9 - 1;
          if ( v4 == v9 )
            break;
          v10 = v5[v9++];
        }
        while ( v10 == 47 );
LABEL_9:
        v8 = 1LL;
        goto LABEL_27;
      }
      v8 = 2LL;
      if ( v4 > 2 )
      {
LABEL_23:
        while ( v5[v8] != 47 )
        {
          if ( v4 == ++v8 )
          {
            v7 = 0LL;
            v8 = v4;
            goto LABEL_27;
          }
        }
      }
      v7 = 0LL;
    }
    else
    {
      v7 = 0LL;
      v8 = 1LL;
    }
  }
  else
  {
    v7 = 0LL;
    v8 = 0LL;
  }
LABEL_27:
  sub_67D2CC8(v14, a1, v7, v8);
  result = sub_67D3420(a2, (unsigned __int8 *)v14);
  if ( (v14[0] & 1) != 0 )
    result = (_QWORD *)sub_6575460();
  v12 = *a2;
  if ( (v12 & 1) != 0 )
    v13 = *((_QWORD *)a2 + 1);
  else
    v13 = v12 >> 1;
  if ( v13 == 1 )
  {
    result = (_QWORD *)sub_67D3100(a2, 0LL, 0xFFFFFFFFFFFFFFFFLL, "/", 1uLL);
    if ( !(_DWORD)result )
      return sub_67D3284(a2, "/");
  }
  return result;
}


================================================================================
Function: sub_6763394 (0x6763394)
================================================================================

__int64 __fastcall sub_6763394(unsigned __int8 *a1)
{
  unsigned __int64 v1; // x9
  unsigned __int64 v2; // x8
  _BYTE *v3; // x10
  _BYTE *v4; // x20
  unsigned __int64 v5; // x19
  bool v6; // zf
  unsigned __int64 v7; // x9
  _BYTE *v8; // x10
  _BOOL4 v9; // w21
  __int64 v10; // x0
  unsigned __int64 v11; // x9
  __int64 v12; // x8
  int v13; // w10

  v1 = *a1;
  v2 = *((_QWORD *)a1 + 1);
  if ( (v1 & 1) == 0 )
    v2 = v1 >> 1;
  if ( v2 == 2 )
  {
    v3 = (_BYTE *)*((_QWORD *)a1 + 2);
    if ( (v1 & 1) != 0 )
      v4 = (_BYTE *)*((_QWORD *)a1 + 2);
    else
      v4 = a1 + 1;
    if ( *v4 == 47 && v4[1] == 47 )
    {
      v5 = 0LL;
LABEL_26:
      v9 = v4[v5] != 47;
      goto LABEL_29;
    }
  }
  else
  {
    if ( !v2 )
    {
      v3 = (_BYTE *)*((_QWORD *)a1 + 2);
      goto LABEL_17;
    }
    v3 = (_BYTE *)*((_QWORD *)a1 + 2);
  }
  v5 = v2 - 1;
  if ( (v1 & 1) != 0 )
    v4 = v3;
  else
    v4 = a1 + 1;
  if ( v4[v5] == 47 )
    goto LABEL_26;
LABEL_17:
  v6 = (v1 & 1) == 0;
  v7 = v2;
  if ( v6 )
    v4 = a1 + 1;
  else
    v4 = v3;
  do
  {
    if ( !v7 )
      goto LABEL_25;
    v8 = &v4[v7--];
  }
  while ( *(v8 - 1) != 47 );
  if ( v7 == -1LL || v7 == 1 && *v4 == 47 )
  {
LABEL_25:
    v5 = 0LL;
    if ( v2 )
      goto LABEL_26;
    goto LABEL_28;
  }
  v5 = v7 + 1;
  if ( v2 )
    goto LABEL_26;
LABEL_28:
  v9 = 1;
LABEL_29:
  v10 = sub_6763BCC();
  v11 = v5 - 1;
  v12 = v10 + 1;
  while ( v11 != -1LL )
  {
    if ( v10 == v11 )
      goto LABEL_35;
    v13 = (unsigned __int8)v4[v11--];
    if ( v13 != 47 )
    {
      v12 = v11 + 2;
      goto LABEL_35;
    }
  }
  v12 = 0LL;
LABEL_35:
  if ( v9 || v10 != 0 || v12 != 1 )
    return v12;
  else
    return -1LL;
}


================================================================================
Function: sub_6763BCC (0x6763BCC)
================================================================================

__int64 __fastcall sub_6763BCC(unsigned __int8 *a1, unsigned __int64 a2)
{
  _BYTE *v2; // x10
  int v3; // w9
  _BYTE *v4; // x8
  unsigned int v5; // w12
  _BYTE *v6; // x8
  _BYTE *v7; // x11
  unsigned __int64 v8; // x12
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x10
  unsigned __int64 v11; // x8
  _BYTE *v12; // x8
  _BYTE *v14; // x9
  _BYTE *v15; // x12
  int v16; // w13

  if ( a2 == 2 )
  {
    v2 = (_BYTE *)*((_QWORD *)a1 + 2);
    v3 = *a1 & 1;
    if ( (*a1 & 1) != 0 )
      v4 = (_BYTE *)*((_QWORD *)a1 + 2);
    else
      v4 = a1 + 1;
    if ( *v4 == 47 && v4[1] == 47 )
      return -1LL;
    goto LABEL_22;
  }
  if ( a2 < 4 )
  {
    if ( !a2 )
      return -1LL;
    v2 = (_BYTE *)*((_QWORD *)a1 + 2);
    v3 = *a1 & 1;
LABEL_22:
    if ( v3 )
      v12 = v2;
    else
      v12 = a1 + 1;
    if ( *v12 == 47 )
      return 0LL;
    return -1LL;
  }
  v5 = *a1;
  v2 = (_BYTE *)*((_QWORD *)a1 + 2);
  v3 = v5 & 1;
  if ( (v5 & 1) != 0 )
    v6 = (_BYTE *)*((_QWORD *)a1 + 2);
  else
    v6 = a1 + 1;
  if ( *v6 != 47 )
    goto LABEL_22;
  if ( v6[1] != 47 )
    goto LABEL_22;
  v7 = v6 + 2;
  if ( v6[2] == 47 )
    goto LABEL_22;
  v8 = v5 >> 1;
  if ( v3 )
    v9 = *((_QWORD *)a1 + 1);
  else
    v9 = v8;
  v10 = v9 - 3;
  if ( v9 >= 3 )
  {
    v14 = &v6[v9];
    while ( v10 )
    {
      v15 = v7 + 1;
      v16 = (unsigned __int8)v7[1];
      --v10;
      ++v7;
      if ( v16 == 47 )
        goto LABEL_33;
    }
    v15 = v14;
LABEL_33:
    v11 = v15 - v6;
    if ( v15 == v14 )
      v11 = -1LL;
  }
  else
  {
    v11 = -1LL;
  }
  if ( v11 >= a2 )
    return -1LL;
  else
    return v11;
}


================================================================================
Function: sub_6763CE4 (0x6763CE4)
================================================================================

_QWORD *__fastcall sub_6763CE4(_QWORD *result, _BYTE *src, _BYTE *a3)
{
  int v4; // w19
  size_t v5; // x21
  char *v6; // x22
  char *v7; // x1
  _QWORD v8[2]; // [xsp+10h] [xbp-20h] BYREF
  char *v9; // [xsp+20h] [xbp-10h]

  *result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  if ( src != a3 )
  {
    v4 = (int)result;
    v5 = a3 - src;
    if ( (unsigned __int64)(a3 - src) >= 0xFFFFFFFFFFFFFFF0LL )
      sub_67D2618();
    if ( v5 > 0x16 )
    {
      v6 = (char *)sub_6575418();
      v8[1] = v5;
      v9 = v6;
      v8[0] = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    }
    else
    {
      v6 = (char *)v8 + 1;
      LOBYTE(v8[0]) = 2 * v5;
    }
    memcpy(v6, src, v5);
    v6[v5] = 0;
    if ( (v8[0] & 1) != 0 )
      v7 = v9;
    else
      v7 = (char *)v8 + 1;
    result = (_QWORD *)sub_52F2BBC(v4, v7);
    if ( (v8[0] & 1) != 0 )
      return (_QWORD *)sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_6763F98 (0x6763F98)
================================================================================

__int64 __usercall sub_6763F98@<X0>(__int64 a1@<X0>, _QWORD *a2@<X8>)
{
  __int64 result; // x0
  void *v5; // x1

  result = sub_6763394();
  if ( result == -1 )
  {
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
  }
  else
  {
    if ( (*(_BYTE *)a1 & 1) != 0 )
      v5 = *(void **)(a1 + 16);
    else
      v5 = (void *)(a1 + 1);
    return sub_6763CE4((int)a2, v5);
  }
  return result;
}


================================================================================
Function: sub_6765208 (0x6765208)
================================================================================

unsigned __int8 *__fastcall sub_6765208(unsigned __int8 *result)
{
  unsigned __int8 *v1; // x19
  unsigned __int64 v2; // x10
  unsigned __int8 *v3; // x1
  __int64 v4; // x12
  unsigned __int64 v5; // x13
  unsigned __int64 v6; // x2
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x11
  _BYTE *v10; // x10
  bool v11; // w14
  unsigned __int8 *v12; // x11
  unsigned __int8 *v13; // x10
  int v14; // w15
  unsigned __int8 *v15; // x10
  unsigned __int8 *v16; // x14
  __int64 v17; // x12
  unsigned __int64 v18; // x12
  _BYTE *v19; // x13
  bool v20; // zf
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x9
  unsigned __int64 v23; // x15
  unsigned __int64 v24; // x14
  int v25; // w16
  __int64 v26; // x13
  __int64 v27; // x16
  _BYTE *v28; // x17
  _BYTE *v29; // x15
  _BYTE *v30; // x16
  unsigned __int8 v31; // w8
  size_t v32[2]; // [xsp+0h] [xbp-20h] BYREF

  v1 = result;
  v2 = *result;
  v3 = (unsigned __int8 *)*((_QWORD *)result + 3);
  v4 = *((_QWORD *)result + 4);
  if ( (v2 & 1) != 0 )
    v5 = *((_QWORD *)result + 1);
  else
    v5 = v2 >> 1;
  v6 = v5 + v4;
  *((_QWORD *)result + 4) = v5 + v4;
  v7 = *((_QWORD *)v3 + 1);
  LODWORD(v8) = *v3;
  v9 = (unsigned __int64)*v3 >> 1;
  if ( (v8 & 1) != 0 )
    v9 = *((_QWORD *)v3 + 1);
  if ( v6 == v9 )
  {
    if ( (v2 & 1) != 0 )
    {
      **((_BYTE **)result + 2) = 0;
      *((_QWORD *)result + 1) = 0LL;
    }
    else
    {
      *(_WORD *)result = 0;
    }
  }
  else
  {
    v11 = v5 >= 3
       && ((v2 & 1) == 0 ? (v10 = result + 1) : (v10 = (_BYTE *)*((_QWORD *)result + 2)), *v10 == 47 && v10[1] == 47)
       && v10[2] != 47;
    v12 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
    if ( (v8 & 1) != 0 )
      v13 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
    else
      v13 = v3 + 1;
    v14 = v13[v6];
    v15 = v3 + 1;
    if ( v14 == 47 )
    {
      if ( v11 )
        return (unsigned __int8 *)sub_67D2AC0(result, 47LL);
      if ( (v8 & 1) != 0 )
        v16 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
      else
        v16 = v3 + 1;
      if ( v16[v6] == 47 )
      {
        v17 = v5 + v4 + 1;
        while ( 1 )
        {
          *((_QWORD *)result + 4) = v17;
          v6 = v17;
          v7 = *((_QWORD *)v3 + 1);
          v12 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
          v8 = *v3;
          v18 = v8 >> 1;
          if ( (v8 & 1) != 0 )
            v19 = (_BYTE *)*((_QWORD *)v3 + 2);
          else
            v19 = v3 + 1;
          if ( (v8 & 1) != 0 )
            v18 = *((_QWORD *)v3 + 1);
          if ( v6 == v18 )
            break;
          v17 = v6 + 1;
          if ( v19[v6] != 47 )
            goto LABEL_36;
        }
        v23 = v6;
        while ( 1 )
        {
          v24 = v23 - 1;
          if ( v23 == 1 )
            break;
          v25 = (unsigned __int8)v19[v23-- - 2];
          if ( v25 != 47 )
          {
            if ( v24 < 3 || *v19 != 47 || v19[1] != 47 )
              goto LABEL_65;
            if ( v6 >= 3 )
            {
              v27 = 0LL;
              v28 = v19 + 2;
              v29 = &v19[v6];
              while ( v28[v27] != 47 )
              {
                if ( v6 - 2 == ++v27 )
                {
                  v30 = &v19[v6];
                  goto LABEL_62;
                }
              }
              v30 = &v28[v27];
LABEL_62:
              v26 = v30 - v19;
              if ( v29 == v30 )
                v26 = -1LL;
            }
            else
            {
              v26 = -1LL;
            }
            if ( v26 != v24 )
            {
LABEL_65:
              *((_QWORD *)result + 4) = v6 - 1;
              v31 = atomic_load(byte_72899D8);
              if ( (v31 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_72899D8) )
              {
                sub_54751B8((int)byte_72899C0, ".");
                __cxa_atexit((void (*)(void *))sub_273926C, byte_72899C0, &off_67F7780);
                sub_67EB838(byte_72899D8);
              }
              return sub_67D3420(v1, byte_72899C0);
            }
            break;
          }
        }
      }
    }
LABEL_36:
    v20 = (v8 & 1) == 0;
    v21 = (unsigned int)v8 >> 1;
    if ( !v20 )
    {
      v15 = v12;
      v21 = v7;
    }
    if ( v21 <= v6 )
      goto LABEL_45;
    v22 = v6;
    while ( v15[v22] != 47 )
    {
      if ( v21 == ++v22 )
        goto LABEL_45;
    }
    if ( v21 == v22 || v22 == -1LL )
LABEL_45:
      v22 = v21;
    sub_67D2CC8(v32, v3, v6, v22 - v6);
    result = sub_67D3420(v1, (unsigned __int8 *)v32);
    if ( (v32[0] & 1) != 0 )
      return (unsigned __int8 *)sub_6575460();
  }
  return result;
}


================================================================================
Function: sub_6765A30 (0x6765A30)
================================================================================

__int64 *sub_6765A30()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_7289A60);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_7289A60) )
  {
    qword_7289A58 = (__int64)off_6BDF3D0;
    sub_67EB838(byte_7289A60);
  }
  return &qword_7289A58;
}


================================================================================
Function: sub_6766264 (0x6766264)
================================================================================

__int64 (__fastcall ***sub_6766264())()
{
  return &off_6C35168;
}


================================================================================
Function: sub_67667A8 (0x67667A8)
================================================================================

void *sub_67667A8()
{
  unsigned __int64 v0; // x8
  __int64 (__fastcall **v2)(); // [xsp+8h] [xbp-18h] BYREF
  __int64 (__fastcall *v3)(); // [xsp+10h] [xbp-10h] BYREF

  v0 = atomic_load(&qword_7289AC8);
  if ( v0 != -1LL )
  {
    v2 = &v3;
    v3 = sub_6766834;
    sub_67D1B3C(&qword_7289AC8, (__int64)&v2, (void (__fastcall *)(__int64))sub_4F38F1C);
  }
  return pthread_getspecific(dword_7289AD0);
}


================================================================================
Function: sub_6766848 (0x6766848)
================================================================================

_QWORD *__fastcall sub_6766848(_QWORD *result)
{
  *result = 0LL;
  result[1] = 0LL;
  return result;
}


================================================================================
Function: sub_6766850 (0x6766850)
================================================================================

bool __fastcall sub_6766850(void **a1)
{
  char *v1; // x21
  _QWORD *v2; // x22
  __int64 v4; // x20
  int v5; // w20
  _QWORD *v6; // x8
  __int64 v7; // x19

  v2 = *a1;
  v1 = (char *)a1[1];
  if ( v1 )
    sub_67F0380(1LL, v1 + 8);
  v4 = v2[4];
  v2[3] = v2;
  v2[4] = v1;
  if ( v4 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v4 + 8)) == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 16LL))(v4);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v4 + 12)) == 1 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24LL))(v4);
    }
  }
  v5 = pthread_create((pthread_t *)*a1 + 5, 0LL, (void *(*)(void *))sub_6766964, *a1);
  if ( v5 )
  {
    v6 = *a1;
    v7 = *((_QWORD *)*a1 + 4);
    v6[3] = 0LL;
    v6[4] = 0LL;
    if ( v7 )
    {
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 8)) == 1 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
        if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v7 + 12)) == 1 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 24LL))(v7);
      }
    }
  }
  return v5 == 0;
}


================================================================================
Function: sub_6767254 (0x6767254)
================================================================================

__int64 __fastcall sub_6767254(__int64 result)
{
  __int64 v1; // x19
  __int64 v2; // x20
  pthread_mutex_t *v3; // x20
  pthread_mutex_t *mutex[3]; // [xsp+8h] [xbp-58h] BYREF
  _BYTE v5[56]; // [xsp+20h] [xbp-40h] BYREF

  v2 = *(_QWORD *)result;
  v1 = *(_QWORD *)(result + 8);
  *(_QWORD *)result = 0LL;
  *(_QWORD *)(result + 8) = 0LL;
  mutex[1] = (pthread_mutex_t *)v2;
  mutex[2] = (pthread_mutex_t *)v1;
  if ( v2 )
  {
    sub_25A7560((int)mutex, (pthread_mutex_t *)(v2 + 48));
    if ( !*(_BYTE *)(v2 + 305) )
    {
      pthread_detach(*(_QWORD *)(v2 + 40));
      *(_WORD *)(v2 + 305) = 257;
    }
    v3 = mutex[0];
    do
      result = pthread_mutex_unlock(v3);
    while ( (_DWORD)result == 4 );
    if ( (_DWORD)result )
    {
      sub_25A6430(v5, (unsigned int)result, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300(v5);
    }
  }
  if ( v1 )
  {
    result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v1 + 8));
    if ( (_DWORD)result == 1 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1);
      result = sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(v1 + 12));
      if ( (_DWORD)result == 1 )
        return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 24LL))(v1);
    }
  }
  return result;
}


================================================================================
Function: sub_67679F4 (0x67679F4)
================================================================================

pthread_mutex_t *__fastcall sub_67679F4(pthread_mutex_t **a1)
{
  pthread_mutex_t *v1; // x8
  pthread_mutex_t *align; // x19
  pthread_mutex_t *v3; // x20
  unsigned int v4; // w0
  pthread_mutex_t *v5; // x20
  pthread_mutex_t *mutex[2]; // [xsp+8h] [xbp-58h] BYREF
  pthread_mutex_t *v8; // [xsp+18h] [xbp-48h]
  _BYTE v9[56]; // [xsp+20h] [xbp-40h] BYREF

  align = *a1;
  v1 = a1[1];
  mutex[1] = *a1;
  v8 = v1;
  if ( v1 )
    sub_67F0380(1LL, &v1->__align + 1);
  if ( align )
  {
    sub_25A7560((int)mutex, (pthread_mutex_t *)((char *)align + 48));
    align = (pthread_mutex_t *)align[1].__align;
    v3 = mutex[0];
    do
      v4 = pthread_mutex_unlock(v3);
    while ( v4 == 4 );
    if ( v4 )
    {
      sub_25A6430(v9, v4, "boost: mutex unlock failed in pthread_mutex_unlock");
      sub_25A6300(v9);
    }
  }
  v5 = v8;
  if ( v8 )
  {
    if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)(&v8->__align + 1)) == 1 )
    {
      (*(void (__fastcall **)(pthread_mutex_t *))(v5->__align + 16))(v5);
      if ( (unsigned int)sub_67F03E0(0xFFFFFFFF, (atomic_uint *)((char *)&v5->__align + 12)) == 1 )
        (*(void (__fastcall **)(pthread_mutex_t *))(v5->__align + 24))(v5);
    }
  }
  return align;
}


================================================================================
Function: sub_6767B28 (0x6767B28)
================================================================================

void *sub_6767B28()
{
  unsigned __int64 v0; // x8
  void *result; // x0
  _BYTE *v2; // x19
  pthread_mutex_t *v3; // x19
  __int64 v4; // x0
  pthread_mutex_t *mutex; // [xsp+18h] [xbp-48h] BYREF
  _QWORD v6[6]; // [xsp+20h] [xbp-40h] BYREF

  v0 = atomic_load(&qword_7289AC8);
  if ( v0 != -1LL )
  {
    mutex = (pthread_mutex_t *)v6;
    v6[0] = sub_6766834;
    sub_67D1B3C(&qword_7289AC8, (__int64)&mutex, (void (__fastcall *)(__int64))sub_4F38F1C);
  }
  result = pthread_getspecific(dword_7289AD0);
  if ( result )
  {
    v2 = result;
    if ( *((_BYTE *)result + 408) )
    {
      sub_25A7560(&mutex, (pthread_mutex_t *)((char *)result + 48));
      if ( v2[409] )
      {
        v2[409] = 0;
        v4 = sub_67EAFB8(1LL);
        sub_67EB030(v4, (__int64)&`typeinfo for'boost::thread_interrupted, 0LL);
      }
      v3 = mutex;
      do
        result = (void *)pthread_mutex_unlock(v3);
      while ( (_DWORD)result == 4 );
      if ( (_DWORD)result )
      {
        sub_25A6430(v6, (unsigned int)result, "boost: mutex unlock failed in pthread_mutex_unlock");
        sub_25A6300((__int64)v6);
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6767D68 (0x6767D68)
================================================================================

_BYTE *__fastcall sub_6767D68(_BYTE *a1)
{
  unsigned __int64 v2; // x8
  _BYTE *result; // x0
  int v4; // w8
  unsigned __int64 v5; // x8
  __int64 (__fastcall **v6)(); // [xsp+8h] [xbp-18h] BYREF
  __int64 (__fastcall *v7)(); // [xsp+10h] [xbp-10h] BYREF

  v2 = atomic_load(&qword_7289AC8);
  if ( v2 != -1LL )
  {
    v6 = &v7;
    v7 = sub_6766834;
    sub_67D1B3C(&qword_7289AC8, (__int64)&v6, (void (__fastcall *)(__int64))sub_4F38F1C);
  }
  result = pthread_getspecific(dword_7289AD0);
  if ( result )
  {
    v4 = (unsigned __int8)result[408];
    *a1 = v4;
    if ( v4 )
    {
      v5 = atomic_load(&qword_7289AC8);
      if ( v5 != -1LL )
      {
        v6 = &v7;
        v7 = sub_6766834;
        sub_67D1B3C(&qword_7289AC8, (__int64)&v6, (void (__fastcall *)(__int64))sub_4F38F1C);
      }
      result = pthread_getspecific(dword_7289AD0);
      result[408] = 0;
    }
  }
  else
  {
    *a1 = 0;
  }
  return result;
}


================================================================================
Function: sub_6767E60 (0x6767E60)
================================================================================

_BYTE *__fastcall sub_6767E60(char *a1)
{
  unsigned __int64 v2; // x8
  _BYTE *result; // x0
  char v4; // w19
  unsigned __int64 v5; // x8
  __int64 (__fastcall **v6)(); // [xsp+8h] [xbp-18h] BYREF
  __int64 (__fastcall *v7)(); // [xsp+10h] [xbp-10h] BYREF

  v2 = atomic_load(&qword_7289AC8);
  if ( v2 != -1LL )
  {
    v6 = &v7;
    v7 = sub_6766834;
    sub_67D1B3C(&qword_7289AC8, (__int64)&v6, (void (__fastcall *)(__int64))sub_4F38F1C);
  }
  result = pthread_getspecific(dword_7289AD0);
  if ( result )
  {
    v4 = *a1;
    v5 = atomic_load(&qword_7289AC8);
    if ( v5 != -1LL )
    {
      v6 = &v7;
      v7 = sub_6766834;
      sub_67D1B3C(&qword_7289AC8, (__int64)&v6, (void (__fastcall *)(__int64))sub_4F38F1C);
    }
    result = pthread_getspecific(dword_7289AD0);
    result[408] = v4;
  }
  return result;
}


================================================================================
Function: sub_67685A0 (0x67685A0)
================================================================================

unsigned __int64 __fastcall sub_67685A0(int a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  __int64 v7; // x8
  unsigned int v9; // t1
  int v10; // w14
  unsigned __int8 *v11; // x15
  bool v12; // cf
  unsigned __int64 v13; // x9
  __int64 v14; // x8
  unsigned __int64 v15; // x9
  __int64 v16; // x8
  unsigned __int64 v17; // x9
  __int64 v18; // x8
  unsigned __int64 v19; // x9
  __int64 v20; // x8
  unsigned __int64 v21; // x9
  __int64 v22; // x8
  unsigned __int64 v23; // x9
  __int64 v24; // x8
  unsigned __int64 v25; // x9
  __int64 v26; // x8
  unsigned __int64 v27; // x9
  __int64 v28; // x8
  __int64 v29; // x0
  unsigned __int64 v30; // x9
  __int64 v31; // x8
  __int64 v32; // x9
  __int64 v33; // x8
  __int64 v34; // x9
  __int64 v35; // x8
  __int64 v36; // x9
  __int64 v37; // x8
  __int64 v38; // x9
  __int64 v39; // x16
  __int64 v40; // x8
  __int64 v41; // x9
  __int64 v42; // x8
  __int64 v43; // x9
  __int64 v44; // x8
  unsigned __int64 v45; // x9
  __int64 v46; // x8
  unsigned __int64 v47; // x9
  __int64 v48; // x8
  unsigned __int64 v49; // x9
  __int64 v50; // x8
  unsigned __int64 v51; // x9
  __int64 v52; // x8
  unsigned __int64 v53; // x9
  __int64 v54; // x8
  unsigned __int64 v55; // x9
  __int64 v56; // x8
  unsigned __int64 v57; // x9
  __int64 v58; // x8
  unsigned __int64 v59; // x9
  __int64 v60; // x8
  unsigned __int64 v61; // x9
  __int64 v62; // x8
  __int64 v63; // x9
  __int64 v64; // x8
  __int64 v65; // x9
  __int64 v66; // x8
  __int64 v67; // x9
  __int64 v68; // x8
  __int64 v69; // x9
  __int64 v70; // x8
  __int64 v71; // x9
  __int64 v72; // x11
  __int64 v73; // x8
  __int64 v74; // x9
  __int64 v75; // x8
  unsigned int v76; // t1

  a3 = (unsigned int)a3;
  v3 = HIWORD(a1);
  v4 = (unsigned __int16)a1;
  if ( (unsigned int)a3 != 1LL )
  {
    if ( !a2 )
      return 1LL;
    if ( (unsigned int)a3 < 0x10uLL )
    {
      if ( (_DWORD)a3 )
      {
        do
        {
          v9 = *a2++;
          --a3;
          v4 += v9;
          v3 += v4;
        }
        while ( a3 );
      }
      v3 %= 0xFFF1uLL;
      if ( v4 > 0xFFF0 )
        v4 -= 65521LL;
      return v4 | (v3 << 16);
    }
    if ( (unsigned __int64)(unsigned int)a3 >> 4 >= 0x15B )
    {
      do
      {
        a3 -= 5552LL;
        v10 = -347;
        v11 = a2;
        do
        {
          v12 = __CFADD__(v10++, 1);
          v13 = v4 + *v11;
          v14 = v13 + v3;
          v15 = v13 + v11[1];
          v16 = v14 + v15;
          v17 = v15 + v11[2];
          v18 = v16 + v17;
          v19 = v17 + v11[3];
          v20 = v18 + v19;
          v21 = v19 + v11[4];
          v22 = v20 + v21;
          v23 = v21 + v11[5];
          v24 = v22 + v23;
          v25 = v23 + v11[6];
          v26 = v24 + v25;
          v27 = v25 + v11[7];
          v28 = v26 + v27;
          v29 = v11[14];
          v30 = v27 + v11[8];
          v31 = v28 + v30;
          v32 = v30 + v11[9];
          v33 = v31 + v32;
          v34 = v32 + v11[10];
          v35 = v33 + v34;
          v36 = v34 + v11[11];
          v37 = v35 + v36;
          v38 = v36 + v11[12];
          v39 = v11[15];
          v40 = v37 + v38;
          v41 = v38 + v11[13];
          v11 += 16;
          v42 = v40 + v41;
          v43 = v41 + v29;
          v44 = v42 + v43;
          v4 = v43 + v39;
          v3 = v44 + v4;
        }
        while ( !v12 );
        a2 += 5552;
        v4 %= 0xFFF1uLL;
        v3 %= 0xFFF1uLL;
      }
      while ( a3 >> 4 > 0x15A );
      if ( !a3 )
        return v4 | (v3 << 16);
      if ( a3 < 0x10 )
        goto LABEL_29;
    }
    do
    {
      a3 -= 16LL;
      v45 = v4 + *a2;
      v46 = v45 + v3;
      v47 = v45 + a2[1];
      v48 = v46 + v47;
      v49 = v47 + a2[2];
      v50 = v48 + v49;
      v51 = v49 + a2[3];
      v52 = v50 + v51;
      v53 = v51 + a2[4];
      v54 = v52 + v53;
      v55 = v53 + a2[5];
      v56 = v54 + v55;
      v57 = v55 + a2[6];
      v58 = v56 + v57;
      v59 = v57 + a2[7];
      v60 = v58 + v59;
      v61 = v59 + a2[8];
      v62 = v60 + v61;
      v63 = v61 + a2[9];
      v64 = v62 + v63;
      v65 = v63 + a2[10];
      v66 = v64 + v65;
      v67 = v65 + a2[11];
      v68 = v66 + v67;
      v69 = v67 + a2[12];
      v70 = v68 + v69;
      v71 = v69 + a2[13];
      v72 = a2[15];
      v73 = v70 + v71;
      v74 = v71 + a2[14];
      a2 += 16;
      v75 = v73 + v74;
      v4 = v74 + v72;
      v3 = v75 + v4;
    }
    while ( a3 > 0xF );
    if ( a3 )
    {
LABEL_29:
      do
      {
        v76 = *a2++;
        --a3;
        v4 += v76;
        v3 += v4;
      }
      while ( a3 );
    }
    return (v4 % 0xFFF1) | ((v3 % 0xFFF1) << 16);
  }
  v5 = (unsigned __int16)a1 + (unsigned __int64)*a2;
  if ( v5 > 0xFFF0 )
    v5 -= 65521LL;
  v6 = v5 + HIWORD(a1);
  if ( v6 <= 0xFFF0 )
    v7 = v6 << 16;
  else
    v7 = (v6 << 16) - 4293984256u;
  return v7 | v5;
}


================================================================================
Function: sub_67689C0 (0x67689C0)
================================================================================

__int64 __fastcall sub_67689C0(int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3; // w11
  int *v4; // x9
  unsigned __int64 v5; // x10
  unsigned int v7; // w15
  unsigned int v8; // w14
  unsigned int v9; // w14
  unsigned int v10; // w14
  unsigned int v11; // w14
  unsigned int v12; // w14
  unsigned int v13; // w14
  unsigned int v14; // w14
  int *v15; // x12
  int v16; // t1
  int v17; // t1

  if ( !a2 )
    return 0LL;
  v3 = ~a1;
  if ( a3 && ((unsigned __int8)a2 & 3) != 0 )
  {
    v4 = (int *)(a2 + 1);
    v3 = dword_17325D4[(unsigned __int8)~(_BYTE)a1 ^ *a2] ^ ((unsigned int)~a1 >> 8);
    v5 = a3 - 1LL;
    if ( a3 != 1LL && ((unsigned __int8)v4 & 3) != 0 )
    {
      v4 = (int *)(a2 + 2);
      v3 = dword_17325D4[(unsigned __int8)v3 ^ a2[1]] ^ (v3 >> 8);
      v5 = a3 - 2LL;
      if ( a3 != 2LL && ((unsigned __int8)v4 & 3) != 0 )
      {
        v4 = (int *)(a2 + 3);
        v3 = dword_17325D4[(unsigned __int8)v3 ^ a2[2]] ^ (v3 >> 8);
        v5 = a3 - 3LL;
        if ( a3 != 3LL && ((unsigned __int8)v4 & 3) != 0 )
        {
          v4 = (int *)(a2 + 4);
          v3 = dword_17325D4[(unsigned __int8)v3 ^ a2[3]] ^ (v3 >> 8);
          v5 = a3 - 4LL;
        }
      }
    }
  }
  else
  {
    v4 = (int *)a2;
    v5 = a3;
  }
  if ( v5 >= 0x20 )
  {
    do
    {
      v5 -= 32LL;
      v7 = *v4 ^ v3;
      v8 = dword_17325D4[BYTE1(v7) + 512] ^ dword_17325D4[(unsigned __int8)v7 + 768] ^ dword_17325D4[BYTE2(v7) + 256] ^ dword_17325D4[HIBYTE(v7)] ^ v4[1];
      v9 = dword_17325D4[BYTE1(v8) + 512] ^ dword_17325D4[(unsigned __int8)(LOBYTE(dword_17325D4[BYTE1(v7) + 512]) ^ LOBYTE(dword_17325D4[(unsigned __int8)v7 + 768]) ^ LOBYTE(dword_17325D4[BYTE2(v7) + 256]) ^ LOBYTE(dword_17325D4[HIBYTE(v7)]) ^ *((_BYTE *)v4 + 4))
                                                        + 768] ^ dword_17325D4[BYTE2(v8) + 256] ^ dword_17325D4[HIBYTE(v8)] ^ v4[2];
      v10 = dword_17325D4[BYTE1(v9) + 512] ^ dword_17325D4[(unsigned __int8)v9 + 768] ^ dword_17325D4[BYTE2(v9) + 256] ^ dword_17325D4[HIBYTE(v9)] ^ v4[3];
      v11 = dword_17325D4[BYTE1(v10) + 512] ^ dword_17325D4[(unsigned __int8)v10 + 768] ^ dword_17325D4[BYTE2(v10) + 256] ^ dword_17325D4[HIBYTE(v10)] ^ v4[4];
      v12 = dword_17325D4[BYTE1(v11) + 512] ^ dword_17325D4[(unsigned __int8)v11 + 768] ^ dword_17325D4[BYTE2(v11) + 256] ^ dword_17325D4[HIBYTE(v11)] ^ v4[5];
      v13 = dword_17325D4[BYTE1(v12) + 512] ^ dword_17325D4[(unsigned __int8)v12 + 768] ^ dword_17325D4[BYTE2(v12) + 256] ^ dword_17325D4[HIBYTE(v12)] ^ v4[6];
      v14 = dword_17325D4[BYTE1(v13) + 512] ^ dword_17325D4[(unsigned __int8)v13 + 768] ^ dword_17325D4[BYTE2(v13) + 256] ^ dword_17325D4[HIBYTE(v13)] ^ v4[7];
      v15 = v4 + 8;
      v3 = dword_17325D4[BYTE1(v14) + 512] ^ dword_17325D4[(unsigned __int8)v14 + 768] ^ dword_17325D4[BYTE2(v14) + 256] ^ dword_17325D4[HIBYTE(v14)];
      v4 += 8;
    }
    while ( v5 > 0x1F );
    v4 = v15;
  }
  if ( v5 >= 4 )
  {
    do
    {
      v16 = *v4++;
      v5 -= 4LL;
      v3 = dword_17325D4[(unsigned __int8)((unsigned __int16)(v16 ^ v3) >> 8) + 512] ^ dword_17325D4[(unsigned __int8)(v16 ^ v3) + 768] ^ dword_17325D4[(unsigned __int8)((v16 ^ v3) >> 16) + 256] ^ dword_17325D4[(v16 ^ v3) >> 24];
    }
    while ( v5 > 3 );
  }
  for ( ; v5; v3 = dword_17325D4[(unsigned __int8)v3 ^ v17] ^ (v3 >> 8) )
  {
    v17 = *(unsigned __int8 *)v4;
    v4 = (int *)((char *)v4 + 1);
    --v5;
  }
  return ~v3;
}


================================================================================
Function: sub_6768C84 (0x6768C84)
================================================================================

__int64 __fastcall sub_6768C84(_QWORD *a1)
{
  void (__fastcall *v2)(_QWORD, _QWORD); // x9
  __int64 v3; // x1
  __int64 result; // x0
  int v5; // w20

  if ( !a1 )
    return 4294967294LL;
  if ( !a1[8] )
    return 4294967294LL;
  v2 = (void (__fastcall *)(_QWORD, _QWORD))a1[9];
  if ( !v2 )
    return 4294967294LL;
  v3 = a1[7];
  if ( !v3 || *(_QWORD **)v3 != a1 )
    return 4294967294LL;
  v5 = *(_DWORD *)(v3 + 8);
  if ( ((unsigned int)(v5 - 57) > 0x38 || ((1LL << ((unsigned __int8)v5 - 57)) & 0x100400400011001LL) == 0)
    && v5 != 666
    && v5 != 42 )
  {
    return 4294967294LL;
  }
  if ( *(_QWORD *)(v3 + 16) )
  {
    v2(a1[10], *(_QWORD *)(v3 + 16));
    v3 = a1[7];
  }
  if ( *(_QWORD *)(v3 + 120) )
  {
    ((void (__fastcall *)(_QWORD, _QWORD))a1[9])(a1[10], *(_QWORD *)(v3 + 120));
    v3 = a1[7];
  }
  if ( *(_QWORD *)(v3 + 112) )
  {
    ((void (__fastcall *)(_QWORD, _QWORD))a1[9])(a1[10], *(_QWORD *)(v3 + 112));
    v3 = a1[7];
  }
  if ( *(_QWORD *)(v3 + 96) )
  {
    ((void (__fastcall *)(_QWORD, _QWORD))a1[9])(a1[10], *(_QWORD *)(v3 + 96));
    v3 = a1[7];
  }
  ((void (__fastcall *)(_QWORD, __int64))a1[9])(a1[10], v3);
  if ( v5 == 113 )
    result = 4294967293LL;
  else
    result = 0LL;
  a1[7] = 0LL;
  return result;
}


================================================================================
Function: sub_6768E30 (0x6768E30)
================================================================================

unsigned __int64 __fastcall sub_6768E30(unsigned __int64 result)
{
  __int64 v1; // x22
  unsigned __int64 v2; // x19
  unsigned int v3; // w8
  int32x2_t v4; // d9
  int i; // w10
  unsigned int v6; // w9
  size_t v7; // x20
  int8x8_t v8; // d2
  int8x8_t v9; // d3
  __int64 v10; // x8
  __int64 v11; // x13
  unsigned __int64 v12; // d0
  __int64 v13; // x14
  uint32x2_t v14; // d1
  __int64 v15; // x11
  __int64 v16; // x9
  __int64 v17; // x10
  int v18; // w9
  __int64 v19; // x11
  __int64 v20; // x12
  unsigned __int16 *v21; // x13
  __int64 v22; // x14
  _WORD *v23; // x10
  unsigned int v24; // w11
  bool v25; // cf
  __int16 v26; // w11
  __int64 v27; // x13
  __int64 v28; // x9
  __int64 v29; // x10
  int v30; // w9
  __int64 v31; // x11
  __int64 v32; // x12
  __int64 v33; // x14
  unsigned __int16 *v34; // x13
  _WORD *v35; // x10
  unsigned int v36; // w11
  __int16 v37; // w11
  __int64 v38; // x24
  unsigned int v39; // w10
  __int64 v40; // x8
  const void *v41; // x1
  __int64 v42; // x9
  unsigned __int8 *v43; // x21
  int v44; // w8
  size_t v45; // x9
  int v46; // w9
  __int64 v47; // x11
  unsigned int v48; // w10
  int v49; // w14
  int v50; // w12
  unsigned int v51; // w13
  __int64 v52; // x14
  __int64 v53; // x17
  int v54; // w15
  __int64 v55; // x15
  unsigned __int64 v56; // x8
  unsigned __int64 v57; // x10
  unsigned __int64 v58; // x21
  size_t v59; // x20
  size_t v60; // x8
  unsigned __int64 v61; // x20

  v1 = *(unsigned int *)(result + 80);
  v2 = result;
  v3 = *(_DWORD *)(result + 180);
  v4.n64_u64[0] = vdup_n_s32(v1).n64_u64[0];
  for ( i = *(_DWORD *)(result + 80); ; i = *(_DWORD *)(v2 + 80) )
  {
    v6 = *(_DWORD *)(v2 + 172);
    LODWORD(v7) = *(_DWORD *)(v2 + 104) - (v3 + v6);
    if ( v6 < (int)v1 - 262 + i )
      goto LABEL_22;
    result = (unsigned __int64)memcpy(
                                 *(void **)(v2 + 96),
                                 (const void *)(*(_QWORD *)(v2 + 96) + v1),
                                 (unsigned int)(v1 - v7));
    v10 = *(unsigned int *)(v2 + 80);
    v11 = *(unsigned int *)(v2 + 132);
    v12 = vsub_s32(*(int32x2_t *)(v2 + 172), v4).n64_u64[0];
    v13 = *(_QWORD *)(v2 + 120);
    v14.n64_u64[0] = vdup_n_s32(v10).n64_u64[0];
    v15 = *(_QWORD *)(v2 + 152) - v1;
    v16 = (unsigned int)(v11 - 1);
    v17 = v13 + 2LL * (unsigned int)v11;
    *(_QWORD *)(v2 + 172) = v12;
    *(_QWORD *)(v2 + 152) = v15;
    if ( (unsigned int)v16 >= 3 )
    {
      v19 = v16 + 1;
      v20 = (v16 + 1) & 0x1FFFFFFFCLL;
      v18 = v11 - v20;
      v17 -= 2 * v20;
      v21 = (unsigned __int16 *)(v13 + 2 * v11 - 4);
      v22 = v20;
      do
      {
        v22 -= 4LL;
        v8.n64_u16[0] = v21[1];
        v9.n64_u16[0] = *(v21 - 1);
        v8.n64_u16[2] = *v21;
        v9.n64_u16[2] = *(v21 - 2);
        v8.n64_u64[0] = vrev64_s32(vqsub_u32(vand_s8(v8, (int8x8_t)0xFFFF0000FFFFLL), v14)).n64_u64[0];
        v9.n64_u64[0] = vrev64_s32(vqsub_u32(vand_s8(v9, (int8x8_t)0xFFFF0000FFFFLL), v14)).n64_u64[0];
        result = v9.n64_u32[1];
        *v21 = v8.n64_u16[0];
        *(v21 - 2) = v9.n64_u16[0];
        v21[1] = v8.n64_u16[2];
        *(v21 - 1) = v9.n64_u16[2];
        v21 -= 4;
      }
      while ( v22 );
      if ( v19 == v20 )
        goto LABEL_12;
    }
    else
    {
      v18 = v11;
    }
    v23 = (_WORD *)(v17 - 2);
    do
    {
      v24 = (unsigned __int16)*v23;
      v25 = v24 >= (unsigned int)v10;
      v26 = v24 - v10;
      if ( !v25 )
        v26 = 0;
      --v18;
      *v23-- = v26;
    }
    while ( v18 );
LABEL_12:
    v27 = *(_QWORD *)(v2 + 112) + 2 * v10;
    v28 = (unsigned int)(v10 - 1);
    if ( (unsigned int)v28 < 3 )
    {
      v29 = *(_QWORD *)(v2 + 112) + 2 * v10;
      v30 = v10;
LABEL_17:
      v35 = (_WORD *)(v29 - 2);
      do
      {
        v36 = (unsigned __int16)*v35;
        v25 = v36 >= (unsigned int)v10;
        v37 = v36 - v10;
        if ( !v25 )
          v37 = 0;
        --v30;
        *v35-- = v37;
      }
      while ( v30 );
      goto LABEL_21;
    }
    v31 = v28 + 1;
    v32 = (v28 + 1) & 0x1FFFFFFFCLL;
    v30 = v10 - v32;
    v33 = v32;
    v29 = v27 - 2 * v32;
    v34 = (unsigned __int16 *)(v27 - 4);
    do
    {
      v33 -= 4LL;
      v8.n64_u16[0] = v34[1];
      v9.n64_u16[0] = *(v34 - 1);
      v8.n64_u16[2] = *v34;
      v9.n64_u16[2] = *(v34 - 2);
      v8.n64_u64[0] = vrev64_s32(vqsub_u32(vand_s8(v8, (int8x8_t)0xFFFF0000FFFFLL), v14)).n64_u64[0];
      v9.n64_u64[0] = vrev64_s32(vqsub_u32(vand_s8(v9, (int8x8_t)0xFFFF0000FFFFLL), v14)).n64_u64[0];
      result = v9.n64_u32[1];
      *v34 = v8.n64_u16[0];
      *(v34 - 2) = v9.n64_u16[0];
      v34[1] = v8.n64_u16[2];
      *(v34 - 1) = v9.n64_u16[2];
      v34 -= 4;
    }
    while ( v33 );
    if ( v31 != v32 )
      goto LABEL_17;
LABEL_21:
    LODWORD(v7) = v1 + v7;
    v6 = v12;
LABEL_22:
    v38 = *(_QWORD *)v2;
    v39 = *(_DWORD *)(*(_QWORD *)v2 + 8LL);
    if ( !v39 )
      break;
    v40 = *(unsigned int *)(v2 + 180);
    if ( v39 <= (unsigned int)v7 )
      v7 = v39;
    else
      v7 = (unsigned int)v7;
    if ( (_DWORD)v7 )
    {
      v41 = *(const void **)v38;
      v42 = *(_QWORD *)(v2 + 96) + v6;
      *(_DWORD *)(v38 + 8) = v39 - v7;
      v43 = (unsigned __int8 *)(v42 + v40);
      result = (unsigned __int64)memcpy((void *)(v42 + v40), v41, v7);
      v44 = *(_DWORD *)(*(_QWORD *)(v38 + 56) + 48LL);
      if ( v44 == 2 )
      {
        result = sub_67689C0(*(_QWORD *)(v38 + 96), v43, v7);
LABEL_31:
        *(_QWORD *)(v38 + 96) = result;
      }
      else if ( v44 == 1 )
      {
        result = sub_67685A0(*(_QWORD *)(v38 + 96), v43, (unsigned int)v7);
        goto LABEL_31;
      }
      LODWORD(v40) = *(_DWORD *)(v2 + 180);
      v45 = *(_QWORD *)(v38 + 16) + v7;
      *(_QWORD *)v38 += v7;
      *(_QWORD *)(v38 + 16) = v45;
    }
    v46 = *(_DWORD *)(v2 + 5932);
    v3 = v40 + v7;
    *(_DWORD *)(v2 + 180) = v3;
    if ( v46 + v3 >= 3 )
    {
      v47 = *(_QWORD *)(v2 + 96);
      v48 = *(_DWORD *)(v2 + 172) - v46;
      v49 = *(unsigned __int8 *)(v47 + v48);
      *(_DWORD *)(v2 + 128) = v49;
      v51 = *(_DWORD *)(v2 + 140);
      v50 = *(_DWORD *)(v2 + 144);
      LODWORD(v52) = ((v49 << v50) ^ *(unsigned __int8 *)(v47 + v48 + 1)) & v51;
      *(_DWORD *)(v2 + 128) = v52;
      do
      {
        if ( !v46 )
          break;
        result = *(_QWORD *)(v2 + 112);
        v53 = *(_QWORD *)(v2 + 120);
        --v46;
        v54 = *(unsigned __int8 *)(v47 + v48 + 2);
        *(_DWORD *)(v2 + 5932) = v46;
        v52 = (((_DWORD)v52 << v50) ^ v54) & v51;
        v55 = *(_DWORD *)(v2 + 88) & v48;
        *(_DWORD *)(v2 + 128) = v52;
        *(_WORD *)(result + 2 * v55) = *(_WORD *)(v53 + 2 * v52);
        *(_WORD *)(v53 + 2 * v52) = v48++;
      }
      while ( v3 + v46 > 2 );
    }
    if ( v3 > 0x105 || !*(_DWORD *)(*(_QWORD *)v2 + 8LL) )
      break;
  }
  v56 = *(_QWORD *)(v2 + 5944);
  v57 = *(_QWORD *)(v2 + 104);
  if ( v57 > v56 )
  {
    v58 = *(unsigned int *)(v2 + 180) + (unsigned __int64)*(unsigned int *)(v2 + 172);
    if ( v56 < v58 )
    {
      if ( v57 - v58 >= 0x102 )
        v59 = 258LL;
      else
        v59 = v57 - v58;
      result = (unsigned __int64)memset((void *)(*(_QWORD *)(v2 + 96) + v58), 0, v59);
      v60 = v59 + v58;
      goto LABEL_51;
    }
    if ( v58 + 258 > v56 )
    {
      if ( v58 + 258 - v56 <= v57 - v56 )
        v61 = v58 + 258 - v56;
      else
        v61 = v57 - v56;
      result = (unsigned __int64)memset((void *)(*(_QWORD *)(v2 + 96) + v56), 0, (unsigned int)v61);
      v60 = *(_QWORD *)(v2 + 5944) + v61;
LABEL_51:
      *(_QWORD *)(v2 + 5944) = v60;
    }
  }
  return result;
}


================================================================================
Function: sub_676932C (0x676932C)
================================================================================

__int64 __fastcall sub_676932C(__int64 a1, unsigned int a2)
{
  __int64 v3; // x19
  int v4; // w9
  __int64 result; // x0
  int v7; // w8
  __int64 v8; // x11
  int v9; // w10
  size_t v10; // x8
  unsigned int v11; // w9
  size_t v12; // x22
  __int64 v13; // x11
  __int64 v14; // x12
  int v15; // w10
  size_t v16; // x13
  int v17; // w10
  int v18; // w10
  unsigned int v19; // w9
  __int64 v20; // x14
  __int64 v21; // x10
  char v22; // w8
  __int64 v23; // x9
  __int64 v24; // x8
  __int64 v25; // x9
  __int64 v26; // x11
  __int64 v27; // x8
  __int64 v28; // x11
  __int64 v29; // x8
  __int64 v30; // x9
  __int64 v31; // x11
  __int64 v32; // x8
  __int64 v33; // x11
  __int64 v34; // x0
  __int64 v35; // x8
  __int64 v36; // x10
  __int64 v37; // x8
  __int64 v38; // x11
  __int64 v39; // x8
  __int64 v40; // x11
  int *v41; // x8
  int v42; // w9
  int v43; // w10
  __int64 v44; // x11
  __int64 v45; // x12
  __int64 v46; // x8
  bool v47; // w9
  bool v48; // zf
  __int64 v49; // x10
  char v50; // w13
  char v51; // w9
  __int64 v52; // x8
  __int64 v53; // x8
  __int64 v54; // x11
  __int64 v55; // x9
  __int64 v56; // x9
  __int64 v57; // x11
  __int64 v58; // x8
  __int64 v59; // x9
  __int64 v60; // x11
  __int64 v61; // x8
  __int64 v62; // x9
  __int64 v63; // x11
  __int64 v64; // x8
  int v65; // w8
  char v66; // w8
  int v67; // w11
  int v68; // w12
  __int64 v69; // x8
  __int64 v70; // x10
  __int64 v71; // x8
  __int64 v72; // x10
  __int64 v73; // x8
  __int64 v74; // x10
  __int64 v75; // x8
  __int64 v76; // x10
  __int64 v77; // x8
  __int64 v78; // x10
  int v79; // w8
  char v80; // w8
  __int64 v82; // x9
  __int64 v83; // x11
  __int64 v84; // x8
  __int64 v85; // x11
  __int64 v86; // x8
  __int64 v87; // x9
  char v88; // w8
  __int64 v89; // x11
  __int64 v90; // x9
  __int64 v91; // x11
  int v92; // w8
  __int64 v94; // x9
  __int64 v95; // x11
  __int64 v96; // x8
  __int64 v97; // x12
  __int64 v98; // x9
  __int64 v99; // x8
  int v100; // w11
  __int64 v101; // x9
  unsigned __int64 v102; // x24
  size_t v103; // x10
  size_t v104; // x22
  int v105; // w25
  size_t v106; // x23
  unsigned __int64 v107; // x8
  int v108; // w9
  size_t v109; // x8
  __int64 v110; // x23
  unsigned int v111; // w8
  unsigned int v112; // w9
  size_t v113; // x24
  __int64 v114; // x11
  __int64 v115; // x12
  int v116; // w10
  size_t v117; // x9
  size_t v118; // x8
  int v119; // w9
  unsigned __int64 v120; // x9
  unsigned __int64 v121; // x8
  bool v122; // cc
  __int64 v123; // x22
  unsigned int v124; // w8
  unsigned int v125; // w9
  size_t v126; // x23
  __int64 v127; // x11
  __int64 v128; // x12
  int v129; // w10
  size_t v130; // x9
  __int64 v131; // x10
  __int64 v132; // x11
  __int64 v133; // x12
  unsigned __int64 v134; // x9
  unsigned __int64 v135; // x9
  unsigned __int64 v136; // x8
  bool v137; // cc
  __int64 v138; // x22
  unsigned int v139; // w8
  unsigned int v140; // w9
  size_t v141; // x23
  __int64 v142; // x11
  __int64 v143; // x12
  int v144; // w10
  size_t v145; // x9
  __int64 v146; // x10
  __int64 v147; // x11
  __int64 v148; // x12
  unsigned __int64 v149; // x9
  __int64 v150; // x8
  __int64 v151; // x10
  __int64 v152; // x11
  __int64 v153; // x8
  __int64 v154; // x11
  __int64 v155; // x9
  __int64 v156; // x8
  int v157; // w9
  int v158; // w0
  char *v159; // x0
  size_t v160; // x2
  int v161; // w9
  __int64 v162; // x8
  __int64 v163; // x9
  __int64 v164; // x11
  __int64 v165; // x8
  __int64 v166; // x11
  __int64 v167; // x9
  __int64 v168; // x8
  __int64 v169; // x11
  __int64 v170; // x9
  __int64 v171; // x8
  __int64 v172; // x11
  __int64 v173; // x9
  __int64 v174; // x8
  __int64 v175; // x10
  __int64 v176; // x11
  __int64 v177; // x8
  __int64 v178; // x11
  __int64 v179; // x9
  __int64 v180; // x8
  __int64 v181; // x11
  __int64 v182; // x9
  __int64 v183; // x8
  __int64 v184; // x11
  __int64 v185; // x10
  __int64 v186; // x9
  __int64 v187; // x9
  __int64 v188; // x12
  __int64 v189; // x9
  __int64 v190; // x11
  __int64 v191; // x8
  __int64 v192; // x11
  int v193; // w8

  if ( !a1 )
    return 4294967294LL;
  if ( !*(_QWORD *)(a1 + 64) )
    return 4294967294LL;
  if ( !*(_QWORD *)(a1 + 72) )
    return 4294967294LL;
  v3 = *(_QWORD *)(a1 + 56);
  if ( !v3 || *(_QWORD *)v3 != a1 )
    return 4294967294LL;
  v4 = *(_DWORD *)(v3 + 8);
  if ( ((unsigned int)(v4 - 57) > 0x38 || ((1LL << ((unsigned __int8)v4 - 57)) & 0x100400400011001LL) == 0)
    && v4 != 666
    && v4 != 42 )
  {
    return 4294967294LL;
  }
  if ( a2 > 5 )
    return 4294967294LL;
  if ( !*(_QWORD *)(a1 + 24) || (v7 = *(_DWORD *)(a1 + 8)) != 0 && !*(_QWORD *)a1 || a2 != 4 && v4 == 666 )
  {
    result = 4294967294LL;
    *(_QWORD *)(a1 + 48) = "stream error";
    return result;
  }
  if ( !*(_DWORD *)(a1 + 32) )
    goto LABEL_59;
  v8 = *(_QWORD *)(v3 + 40);
  v9 = *(_DWORD *)(v3 + 76);
  *(_DWORD *)(v3 + 76) = a2;
  if ( v8 )
  {
    sub_676F2B4(v3);
    v10 = *(_QWORD *)(v3 + 40);
    v11 = *(_DWORD *)(a1 + 32);
    if ( v11 >= (unsigned int)v10 )
      v12 = (unsigned int)v10;
    else
      v12 = v11;
    if ( (_DWORD)v12 )
    {
      memcpy(*(void **)(a1 + 24), *(const void **)(v3 + 32), v12);
      v13 = *(_QWORD *)(v3 + 32);
      v14 = *(_QWORD *)(v3 + 40);
      v15 = *(_DWORD *)(a1 + 32);
      v16 = *(_QWORD *)(a1 + 40) + v12;
      *(_QWORD *)(a1 + 24) += v12;
      v11 = v15 - v12;
      v10 = v14 - v12;
      *(_QWORD *)(a1 + 40) = v16;
      *(_DWORD *)(a1 + 32) = v15 - v12;
      *(_QWORD *)(v3 + 32) = v13 + v12;
      *(_QWORD *)(v3 + 40) = v14 - v12;
      if ( v14 == v12 )
        *(_QWORD *)(v3 + 32) = *(_QWORD *)(v3 + 16);
    }
    if ( !v11 )
      goto LABEL_159;
    v4 = *(_DWORD *)(v3 + 8);
  }
  else if ( v7 )
  {
    v10 = 0LL;
  }
  else
  {
    if ( v9 <= 4 )
      v67 = 0;
    else
      v67 = -9;
    v10 = 0LL;
    if ( a2 <= 4 )
      v68 = 0;
    else
      v68 = -9;
    if ( a2 != 4 && (int)(v68 + 2 * a2) <= v67 + 2 * v9 )
      goto LABEL_59;
  }
  if ( v4 == 42 )
  {
    if ( *(int *)(v3 + 200) <= 1 && (v17 = *(_DWORD *)(v3 + 196), v17 >= 2) )
    {
      if ( (unsigned int)v17 >= 6 )
      {
        if ( v17 == 6 )
          v18 = 128;
        else
          v18 = 192;
      }
      else
      {
        v18 = 64;
      }
    }
    else
    {
      v18 = 0;
    }
    v19 = v18 | ((*(_DWORD *)(v3 + 84) << 12) - 30720);
    v20 = *(_QWORD *)(v3 + 16);
    if ( *(_DWORD *)(v3 + 172) )
      v19 |= 0x20u;
    *(_QWORD *)(v3 + 40) = v10 + 1;
    *(_BYTE *)(v20 + v10) = BYTE1(v19);
    v21 = *(_QWORD *)(v3 + 40);
    v22 = (v19 % 0x1F) | v19;
    v23 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v21 + 1;
    *(_BYTE *)(v23 + v21) = v22 ^ 0x1F;
    if ( *(_DWORD *)(v3 + 172) )
    {
      v24 = *(_QWORD *)(v3 + 40);
      v25 = *(_QWORD *)(a1 + 96);
      v26 = *(_QWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 40) = v24 + 1;
      *(_BYTE *)(v26 + v24) = BYTE3(v25);
      v27 = *(_QWORD *)(v3 + 40);
      v28 = *(_QWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 40) = v27 + 1;
      *(_BYTE *)(v28 + v27) = BYTE2(v25);
      v29 = *(_QWORD *)(v3 + 40);
      v30 = *(_QWORD *)(a1 + 96);
      v31 = *(_QWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 40) = v29 + 1;
      *(_BYTE *)(v31 + v29) = BYTE1(v30);
      v32 = *(_QWORD *)(v3 + 40);
      v33 = *(_QWORD *)(v3 + 16);
      *(_QWORD *)(v3 + 40) = v32 + 1;
      *(_BYTE *)(v33 + v32) = v30;
    }
    *(_QWORD *)(a1 + 96) = sub_67685A0(0LL, 0LL, 0LL);
    *(_DWORD *)(v3 + 8) = 113;
    sub_676A0AC(a1);
    if ( *(_QWORD *)(v3 + 40) )
      goto LABEL_159;
    v4 = *(_DWORD *)(v3 + 8);
  }
  else if ( v4 == 666 )
  {
    if ( !*(_DWORD *)(a1 + 8) )
    {
LABEL_161:
      if ( !*(_DWORD *)(v3 + 180) && (!a2 || *(_DWORD *)(v3 + 8) == 666) )
        goto LABEL_185;
      goto LABEL_162;
    }
LABEL_59:
    result = 4294967291LL;
    *(_QWORD *)(a1 + 48) = "buffer error";
    return result;
  }
  if ( v4 != 57 )
  {
LABEL_83:
    switch ( v4 )
    {
      case 'E':
        goto LABEL_84;
      case 'I':
        goto LABEL_107;
      case '[':
        goto LABEL_131;
      case 'g':
        goto LABEL_154;
      default:
        goto LABEL_160;
    }
  }
  v34 = sub_67689C0(0LL, 0LL, 0LL);
  v35 = *(_QWORD *)(v3 + 40);
  v36 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(a1 + 96) = v34;
  *(_QWORD *)(v3 + 40) = v35 + 1;
  *(_BYTE *)(v36 + v35) = 31;
  v37 = *(_QWORD *)(v3 + 40);
  v38 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(v3 + 40) = v37 + 1;
  *(_BYTE *)(v38 + v37) = -117;
  v39 = *(_QWORD *)(v3 + 40);
  v40 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(v3 + 40) = v39 + 1;
  *(_BYTE *)(v40 + v39) = 8;
  v41 = *(int **)(v3 + 56);
  if ( !v41 )
  {
    v69 = *(_QWORD *)(v3 + 40);
    v70 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v69 + 1;
    *(_BYTE *)(v70 + v69) = 0;
    v71 = *(_QWORD *)(v3 + 40);
    v72 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v71 + 1;
    *(_BYTE *)(v72 + v71) = 0;
    v73 = *(_QWORD *)(v3 + 40);
    v74 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v73 + 1;
    *(_BYTE *)(v74 + v73) = 0;
    v75 = *(_QWORD *)(v3 + 40);
    v76 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v75 + 1;
    *(_BYTE *)(v76 + v75) = 0;
    v77 = *(_QWORD *)(v3 + 40);
    v78 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v77 + 1;
    *(_BYTE *)(v78 + v77) = 0;
    v79 = *(_DWORD *)(v3 + 196);
    if ( v79 == 9 )
    {
      v80 = 2;
    }
    else if ( v79 >= 2 && *(_DWORD *)(v3 + 200) <= 1 )
    {
      v80 = 0;
    }
    else
    {
      v80 = 4;
    }
    v94 = *(_QWORD *)(v3 + 40);
    v95 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v94 + 1;
    *(_BYTE *)(v95 + v94) = v80;
    v96 = *(_QWORD *)(v3 + 40);
    v97 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v96 + 1;
    *(_BYTE *)(v97 + v96) = 3;
    *(_DWORD *)(v3 + 8) = 113;
    sub_676A0AC(a1);
    if ( *(_QWORD *)(v3 + 40) )
      goto LABEL_159;
    v4 = *(_DWORD *)(v3 + 8);
    goto LABEL_83;
  }
  v42 = *v41;
  v43 = v41[17];
  v44 = *((_QWORD *)v41 + 3);
  v45 = *((_QWORD *)v41 + 5);
  v46 = *((_QWORD *)v41 + 7);
  v47 = v42 != 0;
  v48 = v43 == 0;
  v49 = *(_QWORD *)(v3 + 40);
  v50 = !v48;
  v51 = v47 & 0xE1 | (2 * (v50 & 1)) & 0xE3 | (4 * (v44 != 0)) & 0xE7 | (8 * (v45 != 0)) & 0xEF | (16 * (v46 != 0));
  v52 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(v3 + 40) = v49 + 1;
  *(_BYTE *)(v52 + v49) = v51;
  v53 = *(_QWORD *)(v3 + 40);
  v54 = *(_QWORD *)(v3 + 16);
  v55 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8LL);
  *(_QWORD *)(v3 + 40) = v53 + 1;
  *(_BYTE *)(v54 + v53) = v55;
  v56 = *(_QWORD *)(v3 + 40);
  v57 = *(_QWORD *)(v3 + 16);
  v58 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8LL) >> 8;
  *(_QWORD *)(v3 + 40) = v56 + 1;
  *(_BYTE *)(v57 + v56) = v58;
  v59 = *(_QWORD *)(v3 + 40);
  v60 = *(_QWORD *)(v3 + 16);
  v61 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8LL);
  *(_QWORD *)(v3 + 40) = v59 + 1;
  *(_BYTE *)(v60 + v59) = BYTE2(v61);
  v62 = *(_QWORD *)(v3 + 40);
  v63 = *(_QWORD *)(v3 + 16);
  v64 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 8LL) >> 24;
  *(_QWORD *)(v3 + 40) = v62 + 1;
  *(_BYTE *)(v63 + v62) = v64;
  v65 = *(_DWORD *)(v3 + 196);
  if ( v65 == 9 )
  {
    v66 = 2;
  }
  else if ( v65 >= 2 && *(_DWORD *)(v3 + 200) <= 1 )
  {
    v66 = 0;
  }
  else
  {
    v66 = 4;
  }
  v82 = *(_QWORD *)(v3 + 40);
  v83 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(v3 + 40) = v82 + 1;
  *(_BYTE *)(v83 + v82) = v66;
  v84 = *(_QWORD *)(v3 + 40);
  v85 = *(_QWORD *)(v3 + 16);
  LOBYTE(v82) = *(_DWORD *)(*(_QWORD *)(v3 + 56) + 20LL);
  *(_QWORD *)(v3 + 40) = v84 + 1;
  *(_BYTE *)(v85 + v84) = v82;
  v86 = *(_QWORD *)(v3 + 56);
  if ( *(_QWORD *)(v86 + 24) )
  {
    v87 = *(_QWORD *)(v3 + 40);
    v88 = *(_DWORD *)(v86 + 32);
    v89 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v87 + 1;
    *(_BYTE *)(v89 + v87) = v88;
    v90 = *(_QWORD *)(v3 + 40);
    v91 = *(_QWORD *)(v3 + 16);
    v92 = *(_DWORD *)(*(_QWORD *)(v3 + 56) + 32LL) >> 8;
    *(_QWORD *)(v3 + 40) = v90 + 1;
    *(_BYTE *)(v91 + v90) = v92;
    v86 = *(_QWORD *)(v3 + 56);
  }
  if ( *(_DWORD *)(v86 + 68) )
    *(_QWORD *)(a1 + 96) = sub_67689C0(*(_QWORD *)(a1 + 96), *(_QWORD *)(v3 + 16), *(unsigned int *)(v3 + 40));
  *(_QWORD *)(v3 + 64) = 0LL;
  *(_DWORD *)(v3 + 8) = 69;
LABEL_84:
  v98 = *(_QWORD *)(v3 + 56);
  v99 = *(_QWORD *)(v98 + 24);
  if ( v99 )
  {
    v100 = *(unsigned __int16 *)(v98 + 32);
    v101 = *(_QWORD *)(v3 + 64);
    v102 = *(_QWORD *)(v3 + 40);
    v103 = *(_QWORD *)(v3 + 24);
    v104 = (unsigned int)(v100 - v101);
    if ( v102 + v104 > v103 )
    {
      while ( 1 )
      {
        v105 = v103 - v102;
        v106 = (unsigned int)(v103 - v102);
        memcpy((void *)(*(_QWORD *)(v3 + 16) + v102), (const void *)(v99 + v101), v106);
        v107 = *(_QWORD *)(v3 + 24);
        v108 = *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL);
        *(_QWORD *)(v3 + 40) = v107;
        if ( v108 && v107 > v102 )
          *(_QWORD *)(a1 + 96) = sub_67689C0(
                                   *(_QWORD *)(a1 + 96),
                                   *(_QWORD *)(v3 + 16) + v102,
                                   (unsigned int)(v107 - v102));
        v109 = *(_QWORD *)(v3 + 64) + v106;
        v110 = *(_QWORD *)(a1 + 56);
        *(_QWORD *)(v3 + 64) = v109;
        sub_676F2B4(v110);
        v111 = *(_DWORD *)(v110 + 40);
        v112 = *(_DWORD *)(a1 + 32);
        if ( v112 >= v111 )
          v113 = v111;
        else
          v113 = v112;
        if ( (_DWORD)v113 )
        {
          memcpy(*(void **)(a1 + 24), *(const void **)(v110 + 32), v113);
          v114 = *(_QWORD *)(v110 + 32);
          v115 = *(_QWORD *)(v110 + 40);
          v116 = *(_DWORD *)(a1 + 32);
          v117 = *(_QWORD *)(a1 + 40) + v113;
          *(_QWORD *)(a1 + 24) += v113;
          *(_QWORD *)(a1 + 40) = v117;
          *(_DWORD *)(a1 + 32) = v116 - v113;
          *(_QWORD *)(v110 + 32) = v114 + v113;
          *(_QWORD *)(v110 + 40) = v115 - v113;
          if ( v115 == v113 )
            *(_QWORD *)(v110 + 32) = *(_QWORD *)(v110 + 16);
        }
        if ( *(_QWORD *)(v3 + 40) )
          goto LABEL_159;
        v103 = *(_QWORD *)(v3 + 24);
        v104 = (unsigned int)(v104 - v105);
        if ( v103 >= v104 )
        {
          v101 = *(_QWORD *)(v3 + 64);
          v102 = 0LL;
          v99 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 24LL);
          break;
        }
        v101 = *(_QWORD *)(v3 + 64);
        v102 = 0LL;
        v99 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 24LL);
      }
    }
    memcpy((void *)(*(_QWORD *)(v3 + 16) + v102), (const void *)(v99 + v101), v104);
    v118 = *(_QWORD *)(v3 + 40) + v104;
    v119 = *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL);
    *(_QWORD *)(v3 + 40) = v118;
    if ( v119 && v118 > v102 )
      *(_QWORD *)(a1 + 96) = sub_67689C0(*(_QWORD *)(a1 + 96), *(_QWORD *)(v3 + 16) + v102, (unsigned int)(v118 - v102));
    *(_QWORD *)(v3 + 64) = 0LL;
  }
  *(_DWORD *)(v3 + 8) = 73;
LABEL_107:
  if ( *(_QWORD *)(*(_QWORD *)(v3 + 56) + 40LL) )
  {
    v120 = *(_QWORD *)(v3 + 40);
    v121 = v120;
    while ( 1 )
    {
      if ( v120 == *(_QWORD *)(v3 + 24) )
      {
        if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
          v122 = v120 > v121;
        else
          v122 = 0;
        if ( v122 )
          *(_QWORD *)(a1 + 96) = sub_67689C0(
                                   *(_QWORD *)(a1 + 96),
                                   *(_QWORD *)(v3 + 16) + v121,
                                   (unsigned int)(v120 - v121));
        v123 = *(_QWORD *)(a1 + 56);
        sub_676F2B4(v123);
        v124 = *(_DWORD *)(v123 + 40);
        v125 = *(_DWORD *)(a1 + 32);
        if ( v125 >= v124 )
          v126 = v124;
        else
          v126 = v125;
        if ( (_DWORD)v126 )
        {
          memcpy(*(void **)(a1 + 24), *(const void **)(v123 + 32), v126);
          v127 = *(_QWORD *)(v123 + 32);
          v128 = *(_QWORD *)(v123 + 40);
          v129 = *(_DWORD *)(a1 + 32);
          v130 = *(_QWORD *)(a1 + 40) + v126;
          *(_QWORD *)(a1 + 24) += v126;
          *(_QWORD *)(a1 + 40) = v130;
          *(_DWORD *)(a1 + 32) = v129 - v126;
          *(_QWORD *)(v123 + 32) = v127 + v126;
          *(_QWORD *)(v123 + 40) = v128 - v126;
          if ( v128 == v126 )
            *(_QWORD *)(v123 + 32) = *(_QWORD *)(v123 + 16);
        }
        v121 = *(_QWORD *)(v3 + 40);
        if ( v121 )
          goto LABEL_159;
        v120 = 0LL;
      }
      v131 = *(_QWORD *)(v3 + 64);
      v132 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 40LL);
      *(_QWORD *)(v3 + 64) = v131 + 1;
      v133 = *(_QWORD *)(v3 + 16);
      LODWORD(v131) = *(unsigned __int8 *)(v132 + v131);
      *(_QWORD *)(v3 + 40) = v120 + 1;
      *(_BYTE *)(v133 + v120) = v131;
      if ( !(_DWORD)v131 )
        break;
      v120 = *(_QWORD *)(v3 + 40);
    }
    if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
    {
      v134 = *(_QWORD *)(v3 + 40);
      if ( v134 > v121 )
        *(_QWORD *)(a1 + 96) = sub_67689C0(
                                 *(_QWORD *)(a1 + 96),
                                 *(_QWORD *)(v3 + 16) + v121,
                                 (unsigned int)(v134 - v121));
    }
    *(_QWORD *)(v3 + 64) = 0LL;
  }
  *(_DWORD *)(v3 + 8) = 91;
LABEL_131:
  if ( *(_QWORD *)(*(_QWORD *)(v3 + 56) + 56LL) )
  {
    v135 = *(_QWORD *)(v3 + 40);
    v136 = v135;
    while ( 1 )
    {
      if ( v135 == *(_QWORD *)(v3 + 24) )
      {
        if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
          v137 = v135 > v136;
        else
          v137 = 0;
        if ( v137 )
          *(_QWORD *)(a1 + 96) = sub_67689C0(
                                   *(_QWORD *)(a1 + 96),
                                   *(_QWORD *)(v3 + 16) + v136,
                                   (unsigned int)(v135 - v136));
        v138 = *(_QWORD *)(a1 + 56);
        sub_676F2B4(v138);
        v139 = *(_DWORD *)(v138 + 40);
        v140 = *(_DWORD *)(a1 + 32);
        if ( v140 >= v139 )
          v141 = v139;
        else
          v141 = v140;
        if ( (_DWORD)v141 )
        {
          memcpy(*(void **)(a1 + 24), *(const void **)(v138 + 32), v141);
          v142 = *(_QWORD *)(v138 + 32);
          v143 = *(_QWORD *)(v138 + 40);
          v144 = *(_DWORD *)(a1 + 32);
          v145 = *(_QWORD *)(a1 + 40) + v141;
          *(_QWORD *)(a1 + 24) += v141;
          *(_QWORD *)(a1 + 40) = v145;
          *(_DWORD *)(a1 + 32) = v144 - v141;
          *(_QWORD *)(v138 + 32) = v142 + v141;
          *(_QWORD *)(v138 + 40) = v143 - v141;
          if ( v143 == v141 )
            *(_QWORD *)(v138 + 32) = *(_QWORD *)(v138 + 16);
        }
        v136 = *(_QWORD *)(v3 + 40);
        if ( v136 )
          goto LABEL_159;
        v135 = 0LL;
      }
      v146 = *(_QWORD *)(v3 + 64);
      v147 = *(_QWORD *)(*(_QWORD *)(v3 + 56) + 56LL);
      *(_QWORD *)(v3 + 64) = v146 + 1;
      v148 = *(_QWORD *)(v3 + 16);
      LODWORD(v146) = *(unsigned __int8 *)(v147 + v146);
      *(_QWORD *)(v3 + 40) = v135 + 1;
      *(_BYTE *)(v148 + v135) = v146;
      if ( !(_DWORD)v146 )
        break;
      v135 = *(_QWORD *)(v3 + 40);
    }
    if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
    {
      v149 = *(_QWORD *)(v3 + 40);
      if ( v149 > v136 )
        *(_QWORD *)(a1 + 96) = sub_67689C0(
                                 *(_QWORD *)(a1 + 96),
                                 *(_QWORD *)(v3 + 16) + v136,
                                 (unsigned int)(v149 - v136));
    }
  }
  *(_DWORD *)(v3 + 8) = 103;
LABEL_154:
  if ( *(_DWORD *)(*(_QWORD *)(v3 + 56) + 68LL) )
  {
    v150 = *(_QWORD *)(v3 + 40);
    if ( (unsigned __int64)(v150 + 2) > *(_QWORD *)(v3 + 24) )
    {
      sub_676A0AC(a1);
      v150 = *(_QWORD *)(v3 + 40);
      if ( v150 )
        goto LABEL_159;
    }
    v151 = *(_QWORD *)(a1 + 96);
    v152 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v150 + 1;
    *(_BYTE *)(v152 + v150) = v151;
    v153 = *(_QWORD *)(v3 + 40);
    v154 = *(_QWORD *)(v3 + 16);
    v155 = *(_QWORD *)(a1 + 96) >> 8;
    *(_QWORD *)(v3 + 40) = v153 + 1;
    *(_BYTE *)(v154 + v153) = v155;
    *(_QWORD *)(a1 + 96) = sub_67689C0(0LL, 0LL, 0LL);
  }
  *(_DWORD *)(v3 + 8) = 113;
  sub_676A0AC(a1);
  if ( *(_QWORD *)(v3 + 40) )
  {
LABEL_159:
    result = 0LL;
    *(_DWORD *)(v3 + 76) = -1;
    return result;
  }
LABEL_160:
  if ( !*(_DWORD *)(a1 + 8) )
    goto LABEL_161;
LABEL_162:
  v156 = *(int *)(v3 + 196);
  if ( (_DWORD)v156 )
  {
    v157 = *(_DWORD *)(v3 + 200);
    if ( v157 == 3 )
    {
      v158 = sub_676AAD0(v3, a2);
    }
    else if ( v157 == 2 )
    {
      v158 = sub_676A7D0(v3);
    }
    else
    {
      v158 = (*((__int64 (__fastcall **)(__int64, _QWORD))&unk_6BDF548 + 2 * v156 + 1))(v3, a2);
    }
  }
  else
  {
    v158 = sub_676A140(v3);
  }
  if ( (v158 & 0xFFFFFFFE) == 2 )
    *(_DWORD *)(v3 + 8) = 666;
  if ( (v158 & 0xFFFFFFFD) == 0 )
  {
    if ( *(_DWORD *)(a1 + 32) )
      return 0LL;
    goto LABEL_159;
  }
  if ( v158 == 1 )
  {
    if ( a2 != 5 )
    {
      if ( a2 == 1 )
      {
        sub_676F344(v3);
      }
      else
      {
        sub_676F138(v3, 0, 0LL);
        if ( a2 == 3 )
        {
          v159 = *(char **)(v3 + 120);
          v160 = 2LL * (unsigned int)(*(_DWORD *)(v3 + 132) - 1);
          *(_WORD *)&v159[v160] = 0;
          memset(v159, 0, v160);
          if ( !*(_DWORD *)(v3 + 180) )
          {
            *(_DWORD *)(v3 + 172) = 0;
            *(_QWORD *)(v3 + 152) = 0LL;
            *(_DWORD *)(v3 + 5932) = 0;
          }
        }
      }
    }
    sub_676A0AC(a1);
    if ( !*(_DWORD *)(a1 + 32) )
      goto LABEL_159;
  }
LABEL_185:
  if ( a2 != 4 )
    return 0LL;
  v161 = *(_DWORD *)(v3 + 48);
  if ( v161 < 1 )
    return 1LL;
  v162 = *(_QWORD *)(a1 + 96);
  if ( v161 == 2 )
  {
    v163 = *(_QWORD *)(v3 + 40);
    v164 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v163 + 1;
    *(_BYTE *)(v164 + v163) = v162;
    v165 = *(_QWORD *)(v3 + 40);
    v166 = *(_QWORD *)(v3 + 16);
    v167 = *(_QWORD *)(a1 + 96) >> 8;
    *(_QWORD *)(v3 + 40) = v165 + 1;
    *(_BYTE *)(v166 + v165) = v167;
    v168 = *(_QWORD *)(v3 + 40);
    v169 = *(_QWORD *)(v3 + 16);
    v170 = *(_QWORD *)(a1 + 96) >> 16;
    *(_QWORD *)(v3 + 40) = v168 + 1;
    *(_BYTE *)(v169 + v168) = v170;
    v171 = *(_QWORD *)(v3 + 40);
    v172 = *(_QWORD *)(v3 + 16);
    v173 = *(_QWORD *)(a1 + 96) >> 24;
    *(_QWORD *)(v3 + 40) = v171 + 1;
    *(_BYTE *)(v172 + v171) = v173;
    v174 = *(_QWORD *)(v3 + 40);
    v175 = *(_QWORD *)(a1 + 16);
    v176 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v174 + 1;
    *(_BYTE *)(v176 + v174) = v175;
    v177 = *(_QWORD *)(v3 + 40);
    v178 = *(_QWORD *)(v3 + 16);
    v179 = *(_QWORD *)(a1 + 16) >> 8;
    *(_QWORD *)(v3 + 40) = v177 + 1;
    *(_BYTE *)(v178 + v177) = v179;
    v180 = *(_QWORD *)(v3 + 40);
    v181 = *(_QWORD *)(v3 + 16);
    v182 = *(_QWORD *)(a1 + 16) >> 16;
    *(_QWORD *)(v3 + 40) = v180 + 1;
    *(_BYTE *)(v181 + v180) = v182;
    v183 = *(_QWORD *)(v3 + 40);
    v184 = *(_QWORD *)(v3 + 16);
    v185 = v183 + 1;
    v186 = *(_QWORD *)(a1 + 16) >> 24;
  }
  else
  {
    v187 = *(_QWORD *)(v3 + 40);
    v188 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v187 + 1;
    *(_BYTE *)(v188 + v187) = BYTE3(v162);
    v189 = *(_QWORD *)(v3 + 40);
    v190 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v189 + 1;
    *(_BYTE *)(v190 + v189) = BYTE2(v162);
    v191 = *(_QWORD *)(v3 + 40);
    v186 = *(_QWORD *)(a1 + 96);
    v192 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 40) = v191 + 1;
    *(_BYTE *)(v192 + v191) = BYTE1(v186);
    v183 = *(_QWORD *)(v3 + 40);
    v184 = *(_QWORD *)(v3 + 16);
    v185 = v183 + 1;
  }
  *(_QWORD *)(v3 + 40) = v185;
  *(_BYTE *)(v184 + v183) = v186;
  sub_676A0AC(a1);
  v193 = *(_DWORD *)(v3 + 48);
  if ( v193 >= 1 )
    *(_DWORD *)(v3 + 48) = -v193;
  return *(_QWORD *)(v3 + 40) == 0LL;
}


================================================================================
Function: sub_676A0AC (0x676A0AC)
================================================================================

void *__fastcall sub_676A0AC(__int64 a1)
{
  __int64 v1; // x19
  void *result; // x0
  unsigned int v4; // w8
  unsigned int v5; // w9
  size_t v6; // x21
  __int64 v7; // x11
  __int64 v8; // x12
  int v9; // w10
  size_t v10; // x9

  v1 = *(_QWORD *)(a1 + 56);
  result = (void *)sub_676F2B4(v1);
  v4 = *(_DWORD *)(v1 + 40);
  v5 = *(_DWORD *)(a1 + 32);
  if ( v5 >= v4 )
    v6 = v4;
  else
    v6 = v5;
  if ( (_DWORD)v6 )
  {
    result = memcpy(*(void **)(a1 + 24), *(const void **)(v1 + 32), v6);
    v7 = *(_QWORD *)(v1 + 32);
    v8 = *(_QWORD *)(v1 + 40);
    v9 = *(_DWORD *)(a1 + 32);
    v10 = *(_QWORD *)(a1 + 40) + v6;
    *(_QWORD *)(a1 + 24) += v6;
    *(_QWORD *)(a1 + 40) = v10;
    *(_DWORD *)(a1 + 32) = v9 - v6;
    *(_QWORD *)(v1 + 32) = v7 + v6;
    *(_QWORD *)(v1 + 40) = v8 - v6;
    if ( v8 == v6 )
      *(_QWORD *)(v1 + 32) = *(_QWORD *)(v1 + 16);
  }
  return result;
}


================================================================================
Function: sub_676A140 (0x676A140)
================================================================================

__int64 __fastcall sub_676A140(_QWORD *a1, int a2)
{
  __int64 v4; // x8
  unsigned int v5; // w26
  unsigned __int64 v6; // x0
  size_t v7; // x9
  __int64 v8; // x28
  unsigned __int8 *v9; // x23
  unsigned int v10; // w8
  __int64 v11; // x9
  unsigned int v12; // w10
  unsigned int v13; // w9
  bool v14; // cf
  unsigned int v15; // w10
  __int64 v16; // x12
  __int64 v17; // x28
  int v18; // w9
  unsigned int v19; // w11
  unsigned int v20; // w27
  _BOOL4 v22; // w21
  __int64 v23; // x24
  __int64 v24; // x22
  unsigned int v25; // w8
  unsigned int v26; // w9
  size_t v27; // x23
  __int64 v28; // x11
  __int64 v29; // x12
  int v30; // w10
  size_t v31; // x9
  size_t v32; // x22
  __int64 v33; // x8
  __int64 v34; // x11
  size_t v35; // x9
  int v36; // w10
  unsigned int v37; // w8
  size_t v38; // x22
  const void *v39; // x1
  void *v40; // x0
  int v41; // w8
  int v42; // w22
  int v43; // w9
  size_t v44; // x21
  size_t v45; // x2
  __int64 v46; // x8
  char *v47; // x0
  char *v48; // x1
  size_t v49; // x2
  unsigned int v50; // w8
  unsigned int v51; // w9
  unsigned int v52; // w8
  unsigned __int64 v53; // x10
  void *v54; // x0
  const void *v55; // x1
  int v56; // w11
  unsigned int v57; // w9
  __int64 v58; // x23
  unsigned int v59; // w9
  __int64 result; // x0
  size_t v61; // x21
  __int64 v62; // x11
  __int64 v63; // x10
  bool v64; // cc
  __int64 v65; // x11
  char *v66; // x0
  size_t v67; // x2
  unsigned int v68; // w8
  __int64 v69; // x8
  __int64 v70; // x10
  const void *v71; // x1
  unsigned __int8 *v72; // x22
  int v73; // w8
  unsigned __int64 v74; // x0
  unsigned int v75; // w8
  size_t v76; // x9
  unsigned int v77; // w10
  unsigned __int64 v78; // x9
  __int64 v79; // x8
  unsigned int v80; // w10
  unsigned int v81; // w11
  size_t v82; // x21
  _BOOL4 v83; // w20
  __int64 v84; // x22
  size_t v85; // x8
  __int64 v86; // x21
  unsigned int v87; // w8
  unsigned int v88; // w9
  size_t v89; // x19
  __int64 v90; // x11
  __int64 v91; // x12
  int v92; // w10
  size_t v93; // x9
  int v94; // [xsp+Ch] [xbp-4h]

  v4 = *a1;
  if ( a1[3] - 5LL <= (unsigned __int64)*((unsigned int *)a1 + 20) )
    v5 = *((_DWORD *)a1 + 6) - 5;
  else
    v5 = *((_DWORD *)a1 + 20);
  v94 = *(_DWORD *)(v4 + 8);
  do
  {
    v12 = *(_DWORD *)(v4 + 32);
    v13 = (*((_DWORD *)a1 + 1485) + 42) >> 3;
    v14 = v12 >= v13;
    v15 = v12 - v13;
    if ( !v14 )
    {
      v42 = 1;
      goto LABEL_46;
    }
    v16 = *(unsigned int *)(v4 + 8);
    v17 = (unsigned int)(*((_DWORD *)a1 + 43) - *((_DWORD *)a1 + 38));
    v18 = v17 + v16;
    if ( (unsigned __int64)(v17 + v16) >= 0xFFFF )
      v19 = 0xFFFF;
    else
      v19 = v17 + v16;
    if ( v19 <= v15 )
      v20 = v19;
    else
      v20 = v15;
    if ( v20 < v5 )
    {
      v42 = 1;
      if ( !a2 )
        goto LABEL_46;
      if ( a2 != 4 && v20 == 0 || v20 != v18 )
        goto LABEL_46;
    }
    v22 = a2 == 4 && v20 == v18;
    sub_676F138((int)a1, 0, 0LL);
    *(_WORD *)(a1[5] + a1[2] - 4LL) = v20;
    *(_WORD *)(a1[5] + a1[2] - 2LL) = ~(_WORD)v20;
    v23 = *a1;
    v24 = *(_QWORD *)(*a1 + 56LL);
    sub_676F2B4(v24);
    v25 = *(_DWORD *)(v24 + 40);
    v26 = *(_DWORD *)(v23 + 32);
    if ( v26 >= v25 )
      v27 = v25;
    else
      v27 = v26;
    if ( !(_DWORD)v27 )
      goto LABEL_30;
    memcpy(*(void **)(v23 + 24), *(const void **)(v24 + 32), v27);
    v28 = *(_QWORD *)(v24 + 32);
    v29 = *(_QWORD *)(v24 + 40);
    v30 = *(_DWORD *)(v23 + 32);
    v31 = *(_QWORD *)(v23 + 40) + v27;
    *(_QWORD *)(v23 + 24) += v27;
    *(_QWORD *)(v23 + 40) = v31;
    *(_DWORD *)(v23 + 32) = v30 - v27;
    *(_QWORD *)(v24 + 32) = v28 + v27;
    *(_QWORD *)(v24 + 40) = v29 - v27;
    if ( v29 == v27 )
    {
      *(_QWORD *)(v24 + 32) = *(_QWORD *)(v24 + 16);
      if ( !(_DWORD)v17 )
        goto LABEL_35;
    }
    else
    {
LABEL_30:
      if ( !(_DWORD)v17 )
        goto LABEL_35;
    }
    if ( (unsigned int)v17 <= v20 )
      v32 = (unsigned int)v17;
    else
      v32 = v20;
    memcpy(*(void **)(*a1 + 24LL), (const void *)(a1[12] + a1[19]), v32);
    v33 = *a1;
    v20 -= v32;
    v34 = *(_QWORD *)(*a1 + 40LL);
    v35 = *(_QWORD *)(*a1 + 24LL) + v32;
    v36 = *(_DWORD *)(*a1 + 32LL) - v32;
    a1[19] += v32;
    *(_QWORD *)(v33 + 24) = v35;
    *(_DWORD *)(v33 + 32) = v36;
    *(_QWORD *)(v33 + 40) = v34 + v32;
LABEL_35:
    if ( v20 )
    {
      v8 = *a1;
      v37 = *(_DWORD *)(*a1 + 8LL);
      v9 = *(unsigned __int8 **)(*a1 + 24LL);
      if ( v37 <= v20 )
        v38 = v37;
      else
        v38 = v20;
      if ( (_DWORD)v38 )
      {
        v39 = *(const void **)v8;
        v40 = *(void **)(*a1 + 24LL);
        *(_DWORD *)(v8 + 8) = v37 - v38;
        memcpy(v40, v39, v38);
        v41 = *(_DWORD *)(*(_QWORD *)(v8 + 56) + 48LL);
        if ( v41 == 2 )
        {
          v6 = sub_67689C0(*(_QWORD *)(v8 + 96), v9, v38);
          goto LABEL_6;
        }
        if ( v41 == 1 )
        {
          v6 = sub_67685A0(*(_QWORD *)(v8 + 96), v9, (unsigned int)v38);
LABEL_6:
          *(_QWORD *)(v8 + 96) = v6;
        }
        v7 = *(_QWORD *)(v8 + 16) + v38;
        *(_QWORD *)v8 += v38;
        *(_QWORD *)(v8 + 16) = v7;
        v8 = *a1;
        v9 = *(unsigned __int8 **)(*a1 + 24LL);
      }
      v10 = *(_DWORD *)(v8 + 32) - v20;
      v11 = *(_QWORD *)(v8 + 40) + v20;
      *(_QWORD *)(v8 + 24) = &v9[v20];
      *(_DWORD *)(v8 + 32) = v10;
      *(_QWORD *)(v8 + 40) = v11;
    }
    v4 = *a1;
  }
  while ( !v22 );
  v42 = 0;
LABEL_46:
  v43 = *(_DWORD *)(v4 + 8);
  v44 = (unsigned int)(v94 - v43);
  if ( v94 == v43 )
  {
    v53 = *((unsigned int *)a1 + 43);
    v52 = *((_DWORD *)a1 + 43);
  }
  else
  {
    v45 = *((unsigned int *)a1 + 20);
    if ( (unsigned int)v44 >= (unsigned int)v45 )
    {
      v54 = (void *)a1[12];
      v55 = (const void *)(*(_QWORD *)v4 - v45);
      *((_DWORD *)a1 + 1482) = 2;
      memcpy(v54, v55, v45);
      v51 = *((_DWORD *)a1 + 20);
      v52 = v51;
      *((_DWORD *)a1 + 43) = v51;
    }
    else
    {
      v46 = *((unsigned int *)a1 + 43);
      if ( a1[13] - v46 <= v44 )
      {
        v47 = (char *)a1[12];
        v48 = &v47[v45];
        v49 = (unsigned int)(v46 - v45);
        *((_DWORD *)a1 + 43) = v49;
        memcpy(v47, v48, v49);
        v50 = *((_DWORD *)a1 + 1482);
        if ( v50 <= 1 )
          *((_DWORD *)a1 + 1482) = v50 + 1;
      }
      memcpy((void *)(a1[12] + *((unsigned int *)a1 + 43)), (const void *)(*(_QWORD *)*a1 - v44), v44);
      v51 = *((_DWORD *)a1 + 20);
      v52 = *((_DWORD *)a1 + 43) + v44;
      *((_DWORD *)a1 + 43) = v52;
    }
    v56 = *((_DWORD *)a1 + 1483);
    v53 = v52;
    v57 = v51 - v56;
    a1[19] = v52;
    if ( (unsigned int)v44 <= v57 )
      v57 = v44;
    *((_DWORD *)a1 + 1483) = v57 + v56;
  }
  if ( a1[743] < v53 )
    a1[743] = v53;
  if ( !v42 )
    return 3LL;
  v58 = *a1;
  v59 = *(_DWORD *)(*a1 + 8LL);
  if ( (a2 & 0xFFFFFFFB) == 0 || v59 )
  {
    LODWORD(v61) = *((_DWORD *)a1 + 26) + ~(_DWORD)v53;
    if ( v59 > (unsigned int)v61 )
    {
      v62 = a1[19];
      v63 = *((unsigned int *)a1 + 20);
      v64 = v62 < v63;
      v65 = v62 - v63;
      if ( !v64 )
      {
        v66 = (char *)a1[12];
        v67 = v52 - (unsigned int)v63;
        a1[19] = v65;
        *((_DWORD *)a1 + 43) = v67;
        memcpy(v66, &v66[v63], v67);
        v68 = *((_DWORD *)a1 + 1482);
        if ( v68 <= 1 )
          *((_DWORD *)a1 + 1482) = v68 + 1;
        v58 = *a1;
        LODWORD(v61) = *((_DWORD *)a1 + 20) + v61;
        v59 = *(_DWORD *)(*a1 + 8LL);
      }
    }
  }
  else
  {
    if ( a1[19] == v53 )
      return 1LL;
    v59 = 0;
    LODWORD(v61) = *((_DWORD *)a1 + 26) + ~(_DWORD)v53;
  }
  if ( (unsigned int)v61 <= v59 )
    v61 = (unsigned int)v61;
  else
    v61 = v59;
  if ( (_DWORD)v61 )
  {
    v69 = a1[12];
    v70 = *((unsigned int *)a1 + 43);
    v71 = *(const void **)v58;
    *(_DWORD *)(v58 + 8) = v59 - v61;
    v72 = (unsigned __int8 *)(v69 + v70);
    memcpy((void *)(v69 + v70), v71, v61);
    v73 = *(_DWORD *)(*(_QWORD *)(v58 + 56) + 48LL);
    if ( v73 == 2 )
    {
      v74 = sub_67689C0(*(_QWORD *)(v58 + 96), v72, v61);
LABEL_80:
      *(_QWORD *)(v58 + 96) = v74;
    }
    else if ( v73 == 1 )
    {
      v74 = sub_67685A0(*(_QWORD *)(v58 + 96), v72, (unsigned int)v61);
      goto LABEL_80;
    }
    v76 = *(_QWORD *)(v58 + 16) + v61;
    v75 = *((_DWORD *)a1 + 43) + v61;
    *(_QWORD *)v58 += v61;
    *(_QWORD *)(v58 + 16) = v76;
    *((_DWORD *)a1 + 43) = v75;
  }
  else
  {
    v75 = *((_DWORD *)a1 + 43);
  }
  v77 = v75;
  if ( a1[743] < (unsigned __int64)v75 )
    a1[743] = v75;
  v78 = a1[3] - (unsigned int)((*((_DWORD *)a1 + 1485) + 42) >> 3);
  v79 = a1[19];
  if ( v78 >= 0xFFFF )
    LODWORD(v78) = 0xFFFF;
  v80 = v77 - v79;
  if ( *((_DWORD *)a1 + 20) >= (unsigned int)v78 )
    v81 = v78;
  else
    v81 = *((_DWORD *)a1 + 20);
  if ( v80 >= v81
    || (result = 0LL, a2)
    && (a2 == 4 || v80 != 0)
    && (result = 0LL, !*(_DWORD *)(*a1 + 8LL))
    && v80 <= (unsigned int)v78 )
  {
    if ( v80 <= (unsigned int)v78 )
      v82 = v80;
    else
      v82 = (unsigned int)v78;
    v83 = a2 == 4 && *(_DWORD *)(*a1 + 8LL) == 0 && v80 <= (unsigned int)v78;
    sub_676F138((int)a1, a1[12] + v79, v82);
    v84 = *a1;
    v85 = a1[19] + v82;
    v86 = *(_QWORD *)(*a1 + 56LL);
    a1[19] = v85;
    sub_676F2B4(v86);
    v87 = *(_DWORD *)(v86 + 40);
    v88 = *(_DWORD *)(v84 + 32);
    if ( v88 >= v87 )
      v89 = v87;
    else
      v89 = v88;
    if ( (_DWORD)v89 )
    {
      memcpy(*(void **)(v84 + 24), *(const void **)(v86 + 32), v89);
      v90 = *(_QWORD *)(v86 + 32);
      v91 = *(_QWORD *)(v86 + 40);
      v92 = *(_DWORD *)(v84 + 32);
      v93 = *(_QWORD *)(v84 + 40) + v89;
      *(_QWORD *)(v84 + 24) += v89;
      *(_QWORD *)(v84 + 40) = v93;
      *(_DWORD *)(v84 + 32) = v92 - v89;
      *(_QWORD *)(v86 + 32) = v90 + v89;
      *(_QWORD *)(v86 + 40) = v91 - v89;
      if ( v91 == v89 )
        *(_QWORD *)(v86 + 32) = *(_QWORD *)(v86 + 16);
    }
    if ( v83 )
      return 2LL;
    else
      return 0LL;
  }
  return result;
}


================================================================================
Function: sub_676A7D0 (0x676A7D0)
================================================================================

__int64 __fastcall sub_676A7D0(__int64 *a1, int a2)
{
  __int64 v4; // x9
  __int64 v5; // x10
  __int64 v6; // x8
  __int64 v7; // x12
  __int64 v8; // x9
  int v9; // w14
  __int64 v10; // x8
  int v11; // w11
  __int64 v12; // x9
  __int64 v13; // x1
  __int64 v14; // x23
  __int64 v15; // x21
  unsigned int v16; // w8
  unsigned int v17; // w9
  size_t v18; // x22
  __int64 v19; // x11
  __int64 v20; // x12
  int v21; // w10
  size_t v22; // x9
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 v25; // x8
  __int64 v26; // x1
  __int64 v27; // x22
  __int64 v28; // x20
  unsigned int v29; // w8
  unsigned int v30; // w9
  size_t v31; // x21
  __int64 v32; // x11
  __int64 v33; // x12
  int v34; // w10
  size_t v35; // x9
  __int64 v37; // x22
  __int64 v38; // x20
  unsigned int v39; // w8
  unsigned int v40; // w9
  size_t v41; // x21
  __int64 v42; // x11
  __int64 v43; // x12
  int v44; // w10
  size_t v45; // x9

  while ( 1 )
  {
    if ( !*((_DWORD *)a1 + 45) )
    {
      sub_6768E30(a1);
      if ( !*((_DWORD *)a1 + 45) )
        break;
    }
    v4 = *((unsigned int *)a1 + 43);
    *((_DWORD *)a1 + 40) = 0;
    v5 = *((unsigned int *)a1 + 1475);
    v6 = *(unsigned __int8 *)(a1[12] + v4);
    v7 = a1[736];
    *(_WORD *)(a1[738] + 2 * v5) = 0;
    v8 = (__int64)a1 + 4 * v6;
    *((_DWORD *)a1 + 1475) = v5 + 1;
    *(_BYTE *)(v7 + v5) = v6;
    v9 = *((_DWORD *)a1 + 1475);
    LOWORD(v5) = *(_WORD *)(v8 + 212) + 1;
    v10 = (unsigned int)(*((_DWORD *)a1 + 43) + 1);
    v11 = *((_DWORD *)a1 + 1474) - 1;
    --*((_DWORD *)a1 + 45);
    *(_WORD *)(v8 + 212) = v5;
    *((_DWORD *)a1 + 43) = v10;
    if ( v9 == v11 )
    {
      v12 = a1[19];
      if ( v12 < 0 )
        LODWORD(v13) = 0;
      else
        v13 = a1[12] + (unsigned int)v12;
      sub_676F498((int)a1, v13, v10 - v12);
      v14 = *a1;
      v15 = *(_QWORD *)(*a1 + 56);
      a1[19] = *((unsigned int *)a1 + 43);
      sub_676F2B4(v15);
      v16 = *(_DWORD *)(v15 + 40);
      v17 = *(_DWORD *)(v14 + 32);
      v18 = v17 >= v16 ? v16 : v17;
      if ( (_DWORD)v18 )
      {
        memcpy(*(void **)(v14 + 24), *(const void **)(v15 + 32), v18);
        v19 = *(_QWORD *)(v15 + 32);
        v20 = *(_QWORD *)(v15 + 40);
        v21 = *(_DWORD *)(v14 + 32);
        v22 = *(_QWORD *)(v14 + 40) + v18;
        *(_QWORD *)(v14 + 24) += v18;
        *(_QWORD *)(v14 + 40) = v22;
        *(_DWORD *)(v14 + 32) = v21 - v18;
        *(_QWORD *)(v15 + 32) = v19 + v18;
        *(_QWORD *)(v15 + 40) = v20 - v18;
        if ( v20 == v18 )
          *(_QWORD *)(v15 + 32) = *(_QWORD *)(v15 + 16);
      }
      if ( !*(_DWORD *)(*a1 + 32) )
        return 0LL;
    }
  }
  if ( !a2 )
    return 0LL;
  *((_DWORD *)a1 + 1483) = 0;
  if ( a2 != 4 )
  {
    if ( !*((_DWORD *)a1 + 1475) )
      return 1LL;
    v25 = a1[19];
    if ( v25 < 0 )
      LODWORD(v26) = 0;
    else
      v26 = a1[12] + (unsigned int)v25;
    sub_676F498((int)a1, v26, *((unsigned int *)a1 + 43) - v25);
    v37 = *a1;
    v38 = *(_QWORD *)(*a1 + 56);
    a1[19] = *((unsigned int *)a1 + 43);
    sub_676F2B4(v38);
    v39 = *(_DWORD *)(v38 + 40);
    v40 = *(_DWORD *)(v37 + 32);
    if ( v40 >= v39 )
      v41 = v39;
    else
      v41 = v40;
    if ( (_DWORD)v41 )
    {
      memcpy(*(void **)(v37 + 24), *(const void **)(v38 + 32), v41);
      v42 = *(_QWORD *)(v38 + 32);
      v43 = *(_QWORD *)(v38 + 40);
      v44 = *(_DWORD *)(v37 + 32);
      v45 = *(_QWORD *)(v37 + 40) + v41;
      *(_QWORD *)(v37 + 24) += v41;
      *(_QWORD *)(v37 + 40) = v45;
      *(_DWORD *)(v37 + 32) = v44 - v41;
      *(_QWORD *)(v38 + 32) = v42 + v41;
      *(_QWORD *)(v38 + 40) = v43 - v41;
      if ( v43 == v41 )
        *(_QWORD *)(v38 + 32) = *(_QWORD *)(v38 + 16);
    }
    return *(_DWORD *)(*a1 + 32) != 0;
  }
  v23 = a1[19];
  if ( v23 < 0 )
    LODWORD(v24) = 0;
  else
    v24 = a1[12] + (unsigned int)v23;
  sub_676F498((int)a1, v24, *((unsigned int *)a1 + 43) - v23);
  v27 = *a1;
  v28 = *(_QWORD *)(*a1 + 56);
  a1[19] = *((unsigned int *)a1 + 43);
  sub_676F2B4(v28);
  v29 = *(_DWORD *)(v28 + 40);
  v30 = *(_DWORD *)(v27 + 32);
  if ( v30 >= v29 )
    v31 = v29;
  else
    v31 = v30;
  if ( (_DWORD)v31 )
  {
    memcpy(*(void **)(v27 + 24), *(const void **)(v28 + 32), v31);
    v32 = *(_QWORD *)(v28 + 32);
    v33 = *(_QWORD *)(v28 + 40);
    v34 = *(_DWORD *)(v27 + 32);
    v35 = *(_QWORD *)(v27 + 40) + v31;
    *(_QWORD *)(v27 + 24) += v31;
    *(_QWORD *)(v27 + 40) = v35;
    *(_DWORD *)(v27 + 32) = v34 - v31;
    *(_QWORD *)(v28 + 32) = v32 + v31;
    *(_QWORD *)(v28 + 40) = v33 - v31;
    if ( v33 == v31 )
      *(_QWORD *)(v28 + 32) = *(_QWORD *)(v28 + 16);
  }
  if ( *(_DWORD *)(*a1 + 32) )
    return 3LL;
  else
    return 2LL;
}


================================================================================
Function: sub_676AAD0 (0x676AAD0)
================================================================================

__int64 __fastcall sub_676AAD0(__int64 *a1, int a2)
{
  unsigned int v4; // w8
  __int64 v5; // x9
  unsigned __int8 *v6; // x11
  int v7; // w12
  __int64 v8; // x13
  int v9; // w10
  unsigned __int8 *v10; // x14
  unsigned __int8 *v11; // x14
  unsigned __int8 *v12; // x14
  unsigned __int8 *v13; // x14
  int v14; // w15
  int v15; // w14
  unsigned __int64 v16; // x15
  int v17; // w11
  unsigned int v18; // w10
  __int64 v19; // x9
  __int64 v20; // x14
  __int64 v21; // x11
  __int16 v22; // w8
  __int64 v23; // x9
  int v24; // w12
  int v25; // w13
  int v26; // w10
  int v27; // w12
  unsigned int v28; // w8
  __int64 v29; // x10
  __int64 v30; // x8
  __int64 v31; // x12
  __int64 v32; // x9
  int v33; // w14
  int v34; // w11
  __int64 v35; // x9
  __int64 v36; // x1
  __int64 v37; // x26
  __int64 v38; // x21
  unsigned int v39; // w8
  unsigned int v40; // w9
  size_t v41; // x22
  __int64 v42; // x11
  __int64 v43; // x12
  int v44; // w10
  size_t v45; // x9
  __int64 v46; // x8
  __int64 v47; // x1
  __int64 v48; // x8
  __int64 v49; // x1
  __int64 v50; // x22
  __int64 v51; // x20
  unsigned int v52; // w8
  unsigned int v53; // w9
  size_t v54; // x21
  __int64 v55; // x11
  __int64 v56; // x12
  int v57; // w10
  size_t v58; // x9
  __int64 v60; // x22
  __int64 v61; // x20
  unsigned int v62; // w8
  unsigned int v63; // w9
  size_t v64; // x21
  __int64 v65; // x11
  __int64 v66; // x12
  int v67; // w10
  size_t v68; // x9

  while ( 1 )
  {
    while ( 1 )
    {
      v4 = *((_DWORD *)a1 + 45);
      if ( v4 < 0x103 )
        break;
      *((_DWORD *)a1 + 40) = 0;
LABEL_10:
      v5 = *((unsigned int *)a1 + 43);
      if ( !(_DWORD)v5 )
        goto LABEL_37;
      v6 = (unsigned __int8 *)(a1[12] + v5);
      v7 = *(v6 - 1);
      if ( v7 != *v6 || v7 != v6[1] || v7 != v6[2] )
        goto LABEL_37;
      v8 = 0LL;
      v9 = (_DWORD)v6 + 258;
      while ( 1 )
      {
        v10 = &v6[v8];
        if ( v7 != v6[v8 + 3] )
        {
          v17 = (_DWORD)v10 + 3;
          goto LABEL_32;
        }
        if ( v7 != v10[4] )
        {
          v17 = (_DWORD)v6 + v8 + 4;
          goto LABEL_32;
        }
        v11 = &v6[v8];
        if ( v7 != v6[v8 + 5] )
        {
          v17 = (_DWORD)v11 + 5;
          goto LABEL_32;
        }
        if ( v7 != v11[6] )
        {
          v17 = (_DWORD)v6 + v8 + 6;
          goto LABEL_32;
        }
        v12 = &v6[v8];
        if ( v7 != v6[v8 + 7] )
        {
          v17 = (_DWORD)v12 + 7;
          goto LABEL_32;
        }
        if ( v7 != v12[8] )
        {
          v17 = (_DWORD)v6 + v8 + 8;
          goto LABEL_32;
        }
        v13 = &v6[v8];
        if ( v7 != v6[v8 + 9] )
          break;
        v14 = v13[10];
        v15 = v8 + 8;
        if ( v7 == v14 )
        {
          v16 = v8 + 2;
          v8 += 8LL;
          if ( v16 < 0xFA )
            continue;
        }
        v17 = (_DWORD)v6 + v15 + 2;
        goto LABEL_32;
      }
      v17 = (_DWORD)v13 + 9;
LABEL_32:
      v18 = v17 - v9 + 258;
      if ( v18 > v4 )
        v18 = v4;
      *((_DWORD *)a1 + 40) = v18;
      if ( v18 < 3 )
        goto LABEL_37;
      v19 = *((unsigned int *)a1 + 1475);
      v20 = a1[736];
      *(_WORD *)(a1[738] + 2 * v19) = 1;
      v21 = byte_17351FE[(unsigned __int8)(v18 - 3)];
      *((_DWORD *)a1 + 1475) = v19 + 1;
      *(_BYTE *)(v20 + v19) = v18 - 3;
      v22 = *((_WORD *)a1 + 1252);
      v23 = (__int64)a1 + 4 * v21;
      LODWORD(v21) = *((_DWORD *)a1 + 40);
      v24 = *((_DWORD *)a1 + 45);
      *((_DWORD *)a1 + 40) = 0;
      v25 = *((_DWORD *)a1 + 43);
      LOWORD(v20) = *(_WORD *)(v23 + 1240);
      *((_WORD *)a1 + 1252) = v22 + 1;
      v26 = v24 - v21;
      v27 = *((_DWORD *)a1 + 1474);
      v28 = v25 + v21;
      LODWORD(v21) = *((_DWORD *)a1 + 1475);
      *((_DWORD *)a1 + 45) = v26;
      *((_DWORD *)a1 + 43) = v28;
      *(_WORD *)(v23 + 1240) = v20 + 1;
      if ( (_DWORD)v21 == v27 - 1 )
        goto LABEL_38;
    }
    sub_6768E30(a1);
    v4 = *((_DWORD *)a1 + 45);
    if ( !a2 && v4 < 0x103 )
      return 0LL;
    if ( !v4 )
      break;
    *((_DWORD *)a1 + 40) = 0;
    if ( v4 > 2 )
      goto LABEL_10;
    LODWORD(v5) = *((_DWORD *)a1 + 43);
LABEL_37:
    v29 = *((unsigned int *)a1 + 1475);
    v30 = *(unsigned __int8 *)(a1[12] + (unsigned int)v5);
    v31 = a1[736];
    *(_WORD *)(a1[738] + 2 * v29) = 0;
    v32 = (__int64)a1 + 4 * v30;
    *((_DWORD *)a1 + 1475) = v29 + 1;
    *(_BYTE *)(v31 + v29) = v30;
    v33 = *((_DWORD *)a1 + 1475);
    LOWORD(v29) = *(_WORD *)(v32 + 212) + 1;
    v28 = *((_DWORD *)a1 + 43) + 1;
    v34 = *((_DWORD *)a1 + 1474) - 1;
    --*((_DWORD *)a1 + 45);
    *(_WORD *)(v32 + 212) = v29;
    *((_DWORD *)a1 + 43) = v28;
    if ( v33 == v34 )
    {
LABEL_38:
      v35 = a1[19];
      if ( v35 < 0 )
        LODWORD(v36) = 0;
      else
        v36 = a1[12] + (unsigned int)v35;
      sub_676F498((int)a1, v36, v28 - v35);
      v37 = *a1;
      v38 = *(_QWORD *)(*a1 + 56);
      a1[19] = *((unsigned int *)a1 + 43);
      sub_676F2B4(v38);
      v39 = *(_DWORD *)(v38 + 40);
      v40 = *(_DWORD *)(v37 + 32);
      if ( v40 >= v39 )
        v41 = v39;
      else
        v41 = v40;
      if ( (_DWORD)v41 )
      {
        memcpy(*(void **)(v37 + 24), *(const void **)(v38 + 32), v41);
        v42 = *(_QWORD *)(v38 + 32);
        v43 = *(_QWORD *)(v38 + 40);
        v44 = *(_DWORD *)(v37 + 32);
        v45 = *(_QWORD *)(v37 + 40) + v41;
        *(_QWORD *)(v37 + 24) += v41;
        *(_QWORD *)(v37 + 40) = v45;
        *(_DWORD *)(v37 + 32) = v44 - v41;
        *(_QWORD *)(v38 + 32) = v42 + v41;
        *(_QWORD *)(v38 + 40) = v43 - v41;
        if ( v43 == v41 )
          *(_QWORD *)(v38 + 32) = *(_QWORD *)(v38 + 16);
      }
      if ( !*(_DWORD *)(*a1 + 32) )
        return 0LL;
    }
  }
  *((_DWORD *)a1 + 1483) = 0;
  if ( a2 != 4 )
  {
    if ( !*((_DWORD *)a1 + 1475) )
      return 1LL;
    v48 = a1[19];
    if ( v48 < 0 )
      LODWORD(v49) = 0;
    else
      v49 = a1[12] + (unsigned int)v48;
    sub_676F498((int)a1, v49, *((unsigned int *)a1 + 43) - v48);
    v60 = *a1;
    v61 = *(_QWORD *)(*a1 + 56);
    a1[19] = *((unsigned int *)a1 + 43);
    sub_676F2B4(v61);
    v62 = *(_DWORD *)(v61 + 40);
    v63 = *(_DWORD *)(v60 + 32);
    if ( v63 >= v62 )
      v64 = v62;
    else
      v64 = v63;
    if ( (_DWORD)v64 )
    {
      memcpy(*(void **)(v60 + 24), *(const void **)(v61 + 32), v64);
      v65 = *(_QWORD *)(v61 + 32);
      v66 = *(_QWORD *)(v61 + 40);
      v67 = *(_DWORD *)(v60 + 32);
      v68 = *(_QWORD *)(v60 + 40) + v64;
      *(_QWORD *)(v60 + 24) += v64;
      *(_QWORD *)(v60 + 40) = v68;
      *(_DWORD *)(v60 + 32) = v67 - v64;
      *(_QWORD *)(v61 + 32) = v65 + v64;
      *(_QWORD *)(v61 + 40) = v66 - v64;
      if ( v66 == v64 )
        *(_QWORD *)(v61 + 32) = *(_QWORD *)(v61 + 16);
    }
    return *(_DWORD *)(*a1 + 32) != 0;
  }
  v46 = a1[19];
  if ( v46 < 0 )
    LODWORD(v47) = 0;
  else
    v47 = a1[12] + (unsigned int)v46;
  sub_676F498((int)a1, v47, *((unsigned int *)a1 + 43) - v46);
  v50 = *a1;
  v51 = *(_QWORD *)(*a1 + 56);
  a1[19] = *((unsigned int *)a1 + 43);
  sub_676F2B4(v51);
  v52 = *(_DWORD *)(v51 + 40);
  v53 = *(_DWORD *)(v50 + 32);
  if ( v53 >= v52 )
    v54 = v52;
  else
    v54 = v53;
  if ( (_DWORD)v54 )
  {
    memcpy(*(void **)(v50 + 24), *(const void **)(v51 + 32), v54);
    v55 = *(_QWORD *)(v51 + 32);
    v56 = *(_QWORD *)(v51 + 40);
    v57 = *(_DWORD *)(v50 + 32);
    v58 = *(_QWORD *)(v50 + 40) + v54;
    *(_QWORD *)(v50 + 24) += v54;
    *(_QWORD *)(v50 + 40) = v58;
    *(_DWORD *)(v50 + 32) = v57 - v54;
    *(_QWORD *)(v51 + 32) = v55 + v54;
    *(_QWORD *)(v51 + 40) = v56 - v54;
    if ( v56 == v54 )
      *(_QWORD *)(v51 + 32) = *(_QWORD *)(v51 + 16);
  }
  if ( *(_DWORD *)(*a1 + 32) )
    return 3LL;
  else
    return 2LL;
}


================================================================================
Function: sub_676F038 (0x676F038)
================================================================================

long double __fastcall sub_676F038(__int64 a1)
{
  __int64 i; // x8
  __int64 v2; // x9
  long double result; // q0

  for ( i = 0LL; i != 1144; i += 8LL )
  {
    v2 = a1 + i;
    *(_WORD *)(v2 + 212) = 0;
    *(_WORD *)(v2 + 216) = 0;
  }
  *(_WORD *)(a1 + 2504) = 0;
  *(_OWORD *)&result = 0uLL;
  *(_WORD *)(a1 + 2508) = 0;
  *(_WORD *)(a1 + 2512) = 0;
  *(_WORD *)(a1 + 1236) = 1;
  *(_WORD *)(a1 + 2516) = 0;
  *(_WORD *)(a1 + 2520) = 0;
  *(_WORD *)(a1 + 2524) = 0;
  *(_WORD *)(a1 + 2528) = 0;
  *(_WORD *)(a1 + 2532) = 0;
  *(_WORD *)(a1 + 2536) = 0;
  *(_WORD *)(a1 + 2540) = 0;
  *(_WORD *)(a1 + 2544) = 0;
  *(_WORD *)(a1 + 2548) = 0;
  *(_WORD *)(a1 + 2552) = 0;
  *(_WORD *)(a1 + 2556) = 0;
  *(_WORD *)(a1 + 2560) = 0;
  *(_WORD *)(a1 + 2564) = 0;
  *(_WORD *)(a1 + 2568) = 0;
  *(_WORD *)(a1 + 2572) = 0;
  *(_WORD *)(a1 + 2576) = 0;
  *(_WORD *)(a1 + 2580) = 0;
  *(_WORD *)(a1 + 2584) = 0;
  *(_WORD *)(a1 + 2588) = 0;
  *(_WORD *)(a1 + 2592) = 0;
  *(_WORD *)(a1 + 2596) = 0;
  *(_WORD *)(a1 + 2600) = 0;
  *(_WORD *)(a1 + 2604) = 0;
  *(_WORD *)(a1 + 2608) = 0;
  *(_WORD *)(a1 + 2612) = 0;
  *(_WORD *)(a1 + 2616) = 0;
  *(_WORD *)(a1 + 2620) = 0;
  *(_WORD *)(a1 + 2748) = 0;
  *(_WORD *)(a1 + 2752) = 0;
  *(_WORD *)(a1 + 2756) = 0;
  *(_WORD *)(a1 + 2760) = 0;
  *(_WORD *)(a1 + 2764) = 0;
  *(_WORD *)(a1 + 2768) = 0;
  *(_WORD *)(a1 + 2772) = 0;
  *(_WORD *)(a1 + 2776) = 0;
  *(_WORD *)(a1 + 2780) = 0;
  *(_WORD *)(a1 + 2784) = 0;
  *(_WORD *)(a1 + 2788) = 0;
  *(_WORD *)(a1 + 2792) = 0;
  *(_WORD *)(a1 + 2796) = 0;
  *(_WORD *)(a1 + 2800) = 0;
  *(_WORD *)(a1 + 2804) = 0;
  *(_WORD *)(a1 + 2808) = 0;
  *(_WORD *)(a1 + 2812) = 0;
  *(_WORD *)(a1 + 2816) = 0;
  *(_WORD *)(a1 + 2820) = 0;
  *(_DWORD *)(a1 + 5900) = 0;
  *(_OWORD *)(a1 + 5912) = 0u;
  *(_DWORD *)(a1 + 5928) = 0;
  return result;
}


================================================================================
Function: sub_676F138 (0x676F138)
================================================================================

void *__fastcall sub_676F138(__int64 a1, const void *a2, size_t n, int a4)
{
  int v4; // w9
  __int64 v7; // x10
  __int64 v8; // x11
  __int16 v9; // w8
  __int64 v10; // x9
  __int64 v11; // x11
  int v12; // w9
  int v13; // w8
  int v14; // w10
  __int64 v15; // x9
  __int64 v16; // x11
  __int64 v17; // x8
  __int64 v18; // x11
  __int64 v19; // x9
  __int64 v20; // x11
  __int64 v21; // x8
  __int64 v22; // x10
  __int64 v23; // x8
  __int64 v24; // x11
  __int64 v25; // x8
  __int64 v26; // x11
  __int64 v27; // x8
  __int64 v28; // x11
  void *result; // x0

  v4 = *(_DWORD *)(a1 + 5940);
  if ( v4 < 14 )
  {
    v14 = a4 << v4;
    v12 = v4 + 3;
    LOWORD(v13) = *(_WORD *)(a1 + 5936) | v14;
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 40);
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(_WORD *)(a1 + 5936) | (a4 << v4);
    *(_WORD *)(a1 + 5936) = v9;
    *(_QWORD *)(a1 + 40) = v7 + 1;
    *(_BYTE *)(v8 + v7) = v9;
    v10 = *(_QWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16);
    LOBYTE(v9) = *(_BYTE *)(a1 + 5937);
    *(_QWORD *)(a1 + 40) = v10 + 1;
    *(_BYTE *)(v11 + v10) = v9;
    LODWORD(v10) = *(_DWORD *)(a1 + 5940);
    LOBYTE(v9) = 16 - v10;
    v12 = v10 - 13;
    v13 = (unsigned __int16)a4 >> v9;
  }
  *(_WORD *)(a1 + 5936) = v13;
  if ( v12 < 9 )
  {
    if ( v12 >= 1 )
    {
      v19 = *(_QWORD *)(a1 + 40);
      v20 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 40) = v19 + 1;
      *(_BYTE *)(v20 + v19) = v13;
    }
  }
  else
  {
    v15 = *(_QWORD *)(a1 + 40);
    v16 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 40) = v15 + 1;
    *(_BYTE *)(v16 + v15) = v13;
    v17 = *(_QWORD *)(a1 + 40);
    v18 = *(_QWORD *)(a1 + 16);
    LOBYTE(v15) = *(_BYTE *)(a1 + 5937);
    *(_QWORD *)(a1 + 40) = v17 + 1;
    *(_BYTE *)(v18 + v17) = v15;
  }
  v21 = *(_QWORD *)(a1 + 40);
  *(_WORD *)(a1 + 5936) = 0;
  v22 = *(_QWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 5940) = 0;
  *(_QWORD *)(a1 + 40) = v21 + 1;
  *(_BYTE *)(v22 + v21) = n;
  v23 = *(_QWORD *)(a1 + 40);
  v24 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 40) = v23 + 1;
  *(_BYTE *)(v24 + v23) = BYTE1(n);
  v25 = *(_QWORD *)(a1 + 40);
  v26 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 40) = v25 + 1;
  *(_BYTE *)(v26 + v25) = ~(_BYTE)n;
  v27 = *(_QWORD *)(a1 + 40);
  v28 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 40) = v27 + 1;
  *(_BYTE *)(v28 + v27) = (unsigned __int16)~(_WORD)n >> 8;
  result = memcpy((void *)(*(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 40)), a2, n);
  *(_QWORD *)(a1 + 40) += n;
  return result;
}


================================================================================
Function: sub_676F2B4 (0x676F2B4)
================================================================================

__int64 __fastcall sub_676F2B4(__int64 result)
{
  int v1; // w8
  __int64 v2; // x9
  __int64 v3; // x12
  int v4; // w8
  char v5; // w13
  __int64 v6; // x9
  char v7; // w10
  __int64 v8; // x12
  __int64 v9; // x8
  __int64 v10; // x11
  char v11; // w12

  v1 = *(_DWORD *)(result + 5940);
  if ( v1 == 16 )
  {
    v2 = *(_QWORD *)(result + 40);
    v3 = *(_QWORD *)(result + 16);
    v4 = 0;
    v5 = *(_BYTE *)(result + 5936);
    *(_QWORD *)(result + 40) = v2 + 1;
    *(_BYTE *)(v3 + v2) = v5;
    v6 = *(_QWORD *)(result + 40);
    v7 = *(_BYTE *)(result + 5937);
    v8 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v6 + 1;
    *(_BYTE *)(v8 + v6) = v7;
    *(_WORD *)(result + 5936) = 0;
  }
  else
  {
    if ( v1 < 8 )
      return result;
    v9 = *(_QWORD *)(result + 40);
    v10 = *(_QWORD *)(result + 16);
    v11 = *(_BYTE *)(result + 5936);
    *(_QWORD *)(result + 40) = v9 + 1;
    *(_BYTE *)(v10 + v9) = v11;
    v4 = *(_DWORD *)(result + 5940) - 8;
    *(_WORD *)(result + 5936) = *(unsigned __int8 *)(result + 5937);
  }
  *(_DWORD *)(result + 5940) = v4;
  return result;
}


================================================================================
Function: sub_676F344 (0x676F344)
================================================================================

__int64 __fastcall sub_676F344(__int64 result)
{
  int v1; // w10
  unsigned int v2; // w8
  __int64 v3; // x10
  __int64 v4; // x12
  __int64 v5; // x10
  __int64 v6; // x12
  char v7; // w8
  int v8; // w9
  __int64 v9; // x9
  __int64 v10; // x11
  __int64 v11; // x9
  __int64 v12; // x11
  char v13; // w8
  int v14; // w9
  __int64 v15; // x10
  int v16; // w9
  __int64 v17; // x12
  __int64 v18; // x10
  __int64 v19; // x12
  char v20; // w8
  __int64 v21; // x9
  __int64 v22; // x11

  v1 = *(_DWORD *)(result + 5940);
  LOWORD(v2) = *(_WORD *)(result + 5936) | (2 << v1);
  *(_WORD *)(result + 5936) = v2;
  if ( v1 < 14 )
  {
    v8 = v1 + 3;
  }
  else
  {
    v3 = *(_QWORD *)(result + 40);
    v4 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v3 + 1;
    *(_BYTE *)(v4 + v3) = v2;
    v5 = *(_QWORD *)(result + 40);
    v6 = *(_QWORD *)(result + 16);
    v7 = *(_BYTE *)(result + 5937);
    *(_QWORD *)(result + 40) = v5 + 1;
    *(_BYTE *)(v6 + v5) = v7;
    LODWORD(v5) = *(_DWORD *)(result + 5940);
    v2 = 2u >> (16 - v5);
    v8 = v5 - 13;
    *(_WORD *)(result + 5936) = v2;
  }
  *(_DWORD *)(result + 5940) = v8;
  if ( v8 < 10 )
  {
    v14 = v8 + 7;
  }
  else
  {
    v9 = *(_QWORD *)(result + 40);
    v10 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v9 + 1;
    *(_BYTE *)(v10 + v9) = v2;
    v11 = *(_QWORD *)(result + 40);
    v12 = *(_QWORD *)(result + 16);
    v13 = *(_BYTE *)(result + 5937);
    *(_QWORD *)(result + 40) = v11 + 1;
    *(_BYTE *)(v12 + v11) = v13;
    v2 = *(_DWORD *)(result + 5940);
    *(_WORD *)(result + 5936) = 0;
    v14 = v2 - 9;
    LOBYTE(v2) = 0;
  }
  *(_DWORD *)(result + 5940) = v14;
  if ( v14 == 16 )
  {
    v15 = *(_QWORD *)(result + 40);
    v16 = 0;
    v17 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v15 + 1;
    *(_BYTE *)(v17 + v15) = v2;
    v18 = *(_QWORD *)(result + 40);
    v19 = *(_QWORD *)(result + 16);
    v20 = *(_BYTE *)(result + 5937);
    *(_QWORD *)(result + 40) = v18 + 1;
    *(_BYTE *)(v19 + v18) = v20;
    *(_WORD *)(result + 5936) = 0;
  }
  else
  {
    if ( v14 < 8 )
      return result;
    v21 = *(_QWORD *)(result + 40);
    v22 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v21 + 1;
    *(_BYTE *)(v22 + v21) = v2;
    v16 = *(_DWORD *)(result + 5940) - 8;
    *(_WORD *)(result + 5936) = *(unsigned __int8 *)(result + 5937);
  }
  *(_DWORD *)(result + 5940) = v16;
  return result;
}


================================================================================
Function: sub_676F498 (0x676F498)
================================================================================

__int64 __fastcall sub_676F498(__int64 a1, const void *a2, size_t n, int a4)
{
  __int64 v8; // x9
  unsigned __int64 v9; // x11
  int v10; // w9
  unsigned __int64 v11; // x10
  int v12; // w8
  unsigned __int64 v13; // x11
  int v14; // w11
  unsigned int v15; // w10
  __int64 v16; // x9
  int v17; // w0
  int v18; // w15
  int v19; // w16
  unsigned __int16 *v20; // x12
  int v21; // w1
  unsigned int v22; // w14
  int v23; // w17
  int v24; // w11
  unsigned int v25; // w10
  __int64 v26; // x9
  int v27; // w17
  int v28; // w14
  int v29; // w15
  unsigned __int16 *v30; // x11
  int v31; // w0
  unsigned int v32; // w13
  int v33; // w16
  __int64 v34; // x10
  __int64 v35; // x11
  __int64 v36; // x9
  unsigned __int64 v37; // x11
  int v38; // w9
  int v39; // w10
  __int64 v40; // x12
  __int64 v41; // x13
  __int16 v42; // w9
  __int64 v43; // x11
  __int64 v44; // x13
  int v45; // w9
  int v46; // w9
  int v47; // w10
  int v48; // w8
  __int64 v49; // x11
  __int64 v50; // x12
  __int16 v51; // w9
  __int64 v52; // x10
  __int64 v53; // x12
  int v54; // w9
  int v55; // w10
  int v56; // w8
  int v57; // w10
  int v58; // w2
  int v59; // w21
  int v60; // w11
  __int64 v61; // x12
  __int16 v62; // w9
  __int64 v63; // x13
  __int64 v64; // x10
  __int64 v65; // x13
  int v66; // w9
  int v67; // w9
  int v68; // w10
  void *v69; // x1
  void *v70; // x2
  __int64 v71; // x0
  int v72; // w11
  int v73; // w11
  __int64 v74; // x12
  __int16 v75; // w9
  __int64 v76; // x11
  __int64 v77; // x10
  __int64 v78; // x12
  int v79; // w9
  int v80; // w10
  int v81; // w11
  __int64 v82; // x9
  int v83; // w8
  __int64 v84; // x12
  __int16 v85; // w10
  __int64 v86; // x13
  __int64 v87; // x11
  __int64 v88; // x13
  int v89; // w10
  int v90; // w10
  int v91; // w8
  char *v92; // x13
  unsigned int v93; // w14
  __int64 v94; // x10
  __int64 v95; // x16
  __int64 v96; // x8
  char v97; // w15
  __int64 v98; // x16
  __int64 result; // x0
  int v100; // w8
  __int64 v101; // x8
  __int64 v102; // x11
  char v103; // w12
  __int64 v104; // x8
  char v105; // w9
  __int64 v106; // x11

  if ( *(int *)(a1 + 196) < 1 )
  {
    v11 = n + 5;
    v12 = 0;
    v13 = n + 5;
    if ( !a2 )
      goto LABEL_118;
  }
  else
  {
    if ( *(_DWORD *)(*(_QWORD *)a1 + 88LL) == 2 )
    {
      v8 = 0LL;
      v9 = 4093624447LL;
      do
      {
        if ( (v9 & 1) != 0 && *(_WORD *)(a1 + 212 + v8) )
        {
          v10 = 0;
          goto LABEL_14;
        }
        v9 >>= 1;
        v8 += 4LL;
      }
      while ( v8 != 128 );
      if ( !*(_WORD *)(a1 + 248) && !*(_WORD *)(a1 + 252) && !*(_WORD *)(a1 + 264) )
      {
        v34 = 0LL;
        v35 = a1 + 340;
        while ( 1 )
        {
          v10 = *(unsigned __int16 *)(v35 + v34);
          if ( *(_WORD *)(v35 + v34) )
            break;
          v34 += 4LL;
          if ( v34 == 896 )
            goto LABEL_14;
        }
      }
      v10 = 1;
LABEL_14:
      *(_DWORD *)(*(_QWORD *)a1 + 88LL) = v10;
    }
    sub_676FD14(a1, a1 + 2904);
    sub_676FD14(a1, a1 + 2928);
    v14 = *(_DWORD *)(a1 + 2912);
    v15 = *(unsigned __int16 *)(a1 + 214);
    v16 = (unsigned int)(v14 + 1);
    *(_WORD *)(a1 + 4LL * (int)v16 + 214) = -1;
    if ( (v14 & 0x80000000) == 0 )
    {
      v17 = 0;
      if ( v15 )
        v18 = 4;
      else
        v18 = 3;
      if ( v15 )
        v19 = 7;
      else
        v19 = 138;
      v20 = (unsigned __int16 *)(a1 + 218);
      v21 = -1;
      do
      {
        v22 = v15;
        v15 = *v20;
        v23 = v17 + 1;
        if ( v17 + 1 < v19 && v22 == v15 )
        {
          v22 = v21;
        }
        else
        {
          if ( v23 >= v18 )
          {
            if ( v22 )
            {
              if ( v22 != v21 )
                ++*(_WORD *)(a1 + 4LL * v22 + 2748);
              ++*(_WORD *)(a1 + 2812);
              v23 = 0;
              if ( v15 )
              {
LABEL_29:
                if ( v22 == v15 )
                  v19 = 6;
                else
                  v19 = 7;
                if ( v22 == v15 )
                  v18 = 3;
                else
                  v18 = 4;
                goto LABEL_24;
              }
            }
            else if ( v17 > 9 )
            {
              ++*(_WORD *)(a1 + 2820);
              v23 = 0;
              if ( v15 )
                goto LABEL_29;
            }
            else
            {
              ++*(_WORD *)(a1 + 2816);
              v23 = 0;
              if ( v15 )
                goto LABEL_29;
            }
          }
          else
          {
            *(_WORD *)(a1 + 4LL * v22 + 2748) += v23;
            v23 = 0;
            if ( v15 )
              goto LABEL_29;
          }
          v18 = 3;
          v19 = 138;
        }
LABEL_24:
        --v16;
        v20 += 2;
        v17 = v23;
        v21 = v22;
      }
      while ( v16 );
    }
    v24 = *(_DWORD *)(a1 + 2936);
    v25 = *(unsigned __int16 *)(a1 + 2506);
    v26 = (unsigned int)(v24 + 1);
    *(_WORD *)(a1 + 4LL * (int)v26 + 2506) = -1;
    if ( (v24 & 0x80000000) == 0 )
    {
      v27 = 0;
      if ( v25 )
        v28 = 4;
      else
        v28 = 3;
      if ( v25 )
        v29 = 7;
      else
        v29 = 138;
      v30 = (unsigned __int16 *)(a1 + 2510);
      v31 = -1;
      do
      {
        v32 = v25;
        v25 = *v30;
        v33 = v27 + 1;
        if ( v27 + 1 < v29 && v32 == v25 )
        {
          v32 = v31;
        }
        else
        {
          if ( v33 >= v28 )
          {
            if ( v32 )
            {
              if ( v32 != v31 )
                ++*(_WORD *)(a1 + 4LL * v32 + 2748);
              ++*(_WORD *)(a1 + 2812);
              v33 = 0;
              if ( v25 )
              {
LABEL_59:
                if ( v32 == v25 )
                  v29 = 6;
                else
                  v29 = 7;
                if ( v32 == v25 )
                  v28 = 3;
                else
                  v28 = 4;
                goto LABEL_54;
              }
            }
            else if ( v27 > 9 )
            {
              ++*(_WORD *)(a1 + 2820);
              v33 = 0;
              if ( v25 )
                goto LABEL_59;
            }
            else
            {
              ++*(_WORD *)(a1 + 2816);
              v33 = 0;
              if ( v25 )
                goto LABEL_59;
            }
          }
          else
          {
            *(_WORD *)(a1 + 4LL * v32 + 2748) += v33;
            v33 = 0;
            if ( v25 )
              goto LABEL_59;
          }
          v28 = 3;
          v29 = 138;
        }
LABEL_54:
        --v26;
        v30 += 2;
        v27 = v33;
        v31 = v32;
      }
      while ( v26 );
    }
    sub_676FD14(a1, a1 + 2952);
    if ( *(_WORD *)(a1 + 2810) )
    {
      v12 = 18;
    }
    else if ( *(_WORD *)(a1 + 2754) )
    {
      v12 = 17;
    }
    else if ( *(_WORD *)(a1 + 2806) )
    {
      v12 = 16;
    }
    else if ( *(_WORD *)(a1 + 2758) )
    {
      v12 = 15;
    }
    else if ( *(_WORD *)(a1 + 2802) )
    {
      v12 = 14;
    }
    else if ( *(_WORD *)(a1 + 2762) )
    {
      v12 = 13;
    }
    else if ( *(_WORD *)(a1 + 2798) )
    {
      v12 = 12;
    }
    else if ( *(_WORD *)(a1 + 2766) )
    {
      v12 = 11;
    }
    else if ( *(_WORD *)(a1 + 2794) )
    {
      v12 = 10;
    }
    else if ( *(_WORD *)(a1 + 2770) )
    {
      v12 = 9;
    }
    else if ( *(_WORD *)(a1 + 2790) )
    {
      v12 = 8;
    }
    else if ( *(_WORD *)(a1 + 2774) )
    {
      v12 = 7;
    }
    else if ( *(_WORD *)(a1 + 2786) )
    {
      v12 = 6;
    }
    else if ( *(_WORD *)(a1 + 2778) )
    {
      v12 = 5;
    }
    else if ( *(_WORD *)(a1 + 2782) )
    {
      v12 = 4;
    }
    else if ( *(_WORD *)(a1 + 2750) )
    {
      v12 = 3;
    }
    else
    {
      v12 = 2;
    }
    v36 = *(_QWORD *)(a1 + 5912) + (unsigned int)(3 * v12 + 17);
    v37 = *(_QWORD *)(a1 + 5920) + 10LL;
    v11 = v37 >> 3;
    *(_QWORD *)(a1 + 5912) = v36;
    if ( v37 >> 3 <= (unsigned __int64)(v36 + 10) >> 3 )
      v13 = v37 >> 3;
    else
      v13 = (unsigned __int64)(v36 + 10) >> 3;
    if ( !a2 )
      goto LABEL_118;
  }
  if ( n + 4 <= v13 )
  {
    sub_676F138(a1, a2, n, a4);
    goto LABEL_143;
  }
LABEL_118:
  v38 = *(_DWORD *)(a1 + 5940);
  if ( *(_DWORD *)(a1 + 200) == 4 || v11 == v13 )
  {
    v48 = a4 + 2;
    if ( v38 < 14 )
    {
      v55 = *(unsigned __int16 *)(a1 + 5936) | (v48 << v38);
      v56 = v38 + 3;
    }
    else
    {
      v49 = *(_QWORD *)(a1 + 40);
      v50 = *(_QWORD *)(a1 + 16);
      v51 = *(_WORD *)(a1 + 5936) | (v48 << v38);
      *(_WORD *)(a1 + 5936) = v51;
      *(_QWORD *)(a1 + 40) = v49 + 1;
      *(_BYTE *)(v50 + v49) = v51;
      v52 = *(_QWORD *)(a1 + 40);
      v53 = *(_QWORD *)(a1 + 16);
      LOBYTE(v51) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v52 + 1;
      *(_BYTE *)(v53 + v52) = v51;
      v54 = *(_DWORD *)(a1 + 5940);
      v55 = (unsigned __int16)(a4 + 2) >> (16 - v54);
      v56 = v54 - 13;
    }
    *(_WORD *)(a1 + 5936) = v55;
    v69 = &unk_17352FE;
    *(_DWORD *)(a1 + 5940) = v56;
    v70 = &unk_173577E;
    v71 = a1;
  }
  else
  {
    v39 = a4 + 4;
    if ( v38 < 14 )
    {
      v57 = v39 << v38;
      v46 = v38 + 3;
      v47 = *(unsigned __int16 *)(a1 + 5936) | v57;
    }
    else
    {
      v40 = *(_QWORD *)(a1 + 40);
      v41 = *(_QWORD *)(a1 + 16);
      v42 = *(_WORD *)(a1 + 5936) | (v39 << v38);
      *(_WORD *)(a1 + 5936) = v42;
      *(_QWORD *)(a1 + 40) = v40 + 1;
      *(_BYTE *)(v41 + v40) = v42;
      v43 = *(_QWORD *)(a1 + 40);
      v44 = *(_QWORD *)(a1 + 16);
      LOBYTE(v42) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v43 + 1;
      *(_BYTE *)(v44 + v43) = v42;
      v45 = *(_DWORD *)(a1 + 5940);
      LOBYTE(v43) = 16 - v45;
      v46 = v45 - 13;
      v47 = (unsigned __int16)(a4 + 4) >> v43;
    }
    v58 = *(_DWORD *)(a1 + 2912);
    v59 = *(_DWORD *)(a1 + 2936);
    *(_DWORD *)(a1 + 5940) = v46;
    v60 = v58 + 65280;
    if ( v46 < 12 )
    {
      v72 = v60 << v46;
      v67 = v46 + 5;
      v68 = v47 | v72;
    }
    else
    {
      v61 = *(_QWORD *)(a1 + 40);
      v62 = v47 | (v60 << v46);
      v63 = *(_QWORD *)(a1 + 16);
      *(_WORD *)(a1 + 5936) = v62;
      *(_QWORD *)(a1 + 40) = v61 + 1;
      *(_BYTE *)(v63 + v61) = v62;
      v64 = *(_QWORD *)(a1 + 40);
      v65 = *(_QWORD *)(a1 + 16);
      LOBYTE(v62) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v64 + 1;
      *(_BYTE *)(v65 + v64) = v62;
      v66 = *(_DWORD *)(a1 + 5940);
      LOBYTE(v64) = 16 - v66;
      v67 = v66 - 11;
      v68 = (unsigned __int16)(v58 - 256) >> v64;
    }
    v73 = v59 + 0x10000;
    *(_DWORD *)(a1 + 5940) = v67;
    if ( v67 < 12 )
    {
      v80 = v68 | (v73 << v67);
      v81 = v67 + 5;
    }
    else
    {
      v74 = *(_QWORD *)(a1 + 40);
      v75 = v68 | (v73 << v67);
      v76 = *(_QWORD *)(a1 + 16);
      *(_WORD *)(a1 + 5936) = v75;
      *(_QWORD *)(a1 + 40) = v74 + 1;
      *(_BYTE *)(v76 + v74) = v75;
      v77 = *(_QWORD *)(a1 + 40);
      v78 = *(_QWORD *)(a1 + 16);
      LOBYTE(v75) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v77 + 1;
      *(_BYTE *)(v78 + v77) = v75;
      v79 = *(_DWORD *)(a1 + 5940);
      v80 = (unsigned __int16)v59 >> (16 - v79);
      v81 = v79 - 11;
    }
    v82 = (unsigned int)(v12 + 1);
    v83 = v12 + 65533;
    *(_DWORD *)(a1 + 5940) = v81;
    if ( v81 < 13 )
    {
      v91 = v80 | (v83 << v81);
      v90 = v81 + 4;
    }
    else
    {
      v84 = *(_QWORD *)(a1 + 40);
      v85 = v80 | (v83 << v81);
      v86 = *(_QWORD *)(a1 + 16);
      *(_WORD *)(a1 + 5936) = v85;
      *(_QWORD *)(a1 + 40) = v84 + 1;
      *(_BYTE *)(v86 + v84) = v85;
      v87 = *(_QWORD *)(a1 + 40);
      v88 = *(_QWORD *)(a1 + 16);
      LOBYTE(v85) = *(_BYTE *)(a1 + 5937);
      *(_QWORD *)(a1 + 40) = v87 + 1;
      *(_BYTE *)(v88 + v87) = v85;
      v89 = *(_DWORD *)(a1 + 5940);
      LOBYTE(v87) = 16 - v89;
      v90 = v89 - 12;
      v91 = (unsigned __int16)v83 >> v87;
    }
    v92 = &byte_1735930;
    *(_DWORD *)(a1 + 5940) = v90;
    do
    {
      v93 = *(unsigned __int16 *)(a1 + 4LL * (unsigned __int8)*v92 + 2750);
      v91 |= v93 << v90;
      *(_WORD *)(a1 + 5936) = v91;
      if ( v90 < 14 )
      {
        v90 += 3;
      }
      else
      {
        v94 = *(_QWORD *)(a1 + 40);
        v95 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 40) = v94 + 1;
        *(_BYTE *)(v95 + v94) = v91;
        v96 = *(_QWORD *)(a1 + 40);
        v97 = *(_BYTE *)(a1 + 5937);
        v98 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 40) = v96 + 1;
        *(_BYTE *)(v98 + v96) = v97;
        LODWORD(v94) = *(_DWORD *)(a1 + 5940);
        LOBYTE(v96) = 16 - v94;
        v90 = v94 - 13;
        v91 = v93 >> v96;
        *(_WORD *)(a1 + 5936) = v91;
      }
      --v82;
      ++v92;
      *(_DWORD *)(a1 + 5940) = v90;
    }
    while ( v82 );
    sub_6770964(a1, a1 + 212);
    sub_6770964(a1, a1 + 2504);
    v71 = a1;
    v69 = (void *)(a1 + 212);
    v70 = (void *)(a1 + 2504);
  }
  sub_67704A8(v71, v69, v70);
LABEL_143:
  result = sub_676F038(a1);
  if ( !a4 )
    return result;
  v100 = *(_DWORD *)(a1 + 5940);
  if ( v100 >= 9 )
  {
    v101 = *(_QWORD *)(a1 + 40);
    v102 = *(_QWORD *)(a1 + 16);
    v103 = *(_BYTE *)(a1 + 5936);
    *(_QWORD *)(a1 + 40) = v101 + 1;
    *(_BYTE *)(v102 + v101) = v103;
    v104 = *(_QWORD *)(a1 + 40);
    v105 = *(_BYTE *)(a1 + 5937);
LABEL_148:
    v106 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 40) = v104 + 1;
    *(_BYTE *)(v106 + v104) = v105;
    goto LABEL_149;
  }
  if ( v100 >= 1 )
  {
    v104 = *(_QWORD *)(a1 + 40);
    v105 = *(_BYTE *)(a1 + 5936);
    goto LABEL_148;
  }
LABEL_149:
  *(_WORD *)(a1 + 5936) = 0;
  *(_DWORD *)(a1 + 5940) = 0;
  return result;
}


================================================================================
Function: sub_676FD14 (0x676FD14)
================================================================================

__int64 __fastcall sub_676FD14(__int64 a1, __int64 *a2)
{
  __int64 *v4; // x9
  int *v5; // x8
  __int64 v6; // x19
  __int64 v7; // x27
  __int64 v8; // x9
  __int64 v9; // x10
  _WORD *v10; // x11
  int v11; // w24
  __int64 v12; // x13
  int v13; // w10
  __int64 *v14; // x25
  __int64 *v15; // x26
  unsigned int v16; // w22
  __int64 result; // x0
  bool v18; // cf
  int v19; // w12
  __int64 v20; // x9
  __int64 v21; // x10
  int v22; // w17
  __int64 v23; // x11
  int v24; // w10
  __int64 v25; // x12
  int v26; // w14
  int v27; // w15
  __int64 v28; // x17
  __int64 v29; // x16
  __int64 v30; // x1
  unsigned int v31; // w2
  unsigned int v32; // w3
  int v33; // w16
  int v34; // w15
  unsigned int v35; // w17
  unsigned int v36; // w3
  __int64 v37; // x14
  _WORD *v38; // x15
  __int64 v39; // x12
  __int64 v40; // x11
  _WORD *v41; // x16
  __int64 v42; // x10
  _WORD *v43; // x10
  __int64 v44; // x13
  unsigned int v45; // w12
  unsigned __int8 *v46; // x11
  int v47; // w15
  int v48; // w12
  int v49; // w13
  __int64 v50; // x15
  __int64 v51; // x14
  __int64 v52; // x17
  unsigned int v53; // w1
  int v54; // w14
  unsigned int v55; // w16
  int v56; // w13
  unsigned int v57; // w15
  unsigned int v58; // w1
  int v59; // w9
  __int64 v60; // x8
  __int64 *v61; // x10
  __int64 v62; // x15
  __int64 v63; // x8
  int v64; // w9
  __int64 v65; // x12
  __int64 v66; // x13
  int v67; // w14
  __int64 v68; // x10
  __int64 v69; // x15
  __int64 v70; // x16
  int v71; // w11
  int v72; // w15
  int *v73; // x16
  __int64 v74; // x17
  __int64 v75; // x1
  int v76; // w0
  bool v77; // cc
  int v78; // w1
  __int64 v79; // x2
  unsigned __int16 *v80; // x12
  _WORD *v81; // x15
  __int64 v82; // x16
  __int16 v83; // w17
  int v84; // t1
  bool v85; // vf
  unsigned __int16 v86; // w15
  int v87; // w12
  int v88; // w13
  int *v89; // x15
  __int64 v90; // x14
  __int64 v91; // t1
  __int64 v92; // x15
  _WORD *v93; // x15
  __int64 v94; // x16
  unsigned int v95; // t1
  __int16 v96; // w11
  __int16 v97; // w12
  __int16 v98; // w9
  __int16 v99; // w13
  __int16 v100; // w14
  __int16 v101; // w10
  __int16 v102; // w11
  __int16 v103; // w12
  __int16 v104; // w8
  __int16 v105; // w13
  __int16 v106; // w9
  __int16 v107; // w14
  __int16 v108; // w10
  __int16 v109; // w13
  __int16 v110; // w11
  __int16 v111; // w14
  __int16 v112; // w12
  __int16 v113; // w13
  __int16 v114; // w8
  __int16 v115; // w14
  __int16 v116; // w9
  __int16 v117; // w13
  __int16 v118; // w10
  __int16 v119; // w14
  __int64 v120; // x8
  __int64 v121; // x11
  __int64 v122; // x13
  __int64 v123; // x14
  int v124; // w12
  unsigned int v125; // w13
  unsigned int v126; // w11
  int v127; // w14
  int v128; // w14
  __int64 v129; // x10
  int v130; // w13
  _BYTE v131[2]; // [xsp+8h] [xbp-28h]
  __int16 v132; // [xsp+Ah] [xbp-26h]
  __int16 v133; // [xsp+Ch] [xbp-24h]
  __int16 v134; // [xsp+Eh] [xbp-22h]
  __int16 v135; // [xsp+10h] [xbp-20h]
  __int16 v136; // [xsp+12h] [xbp-1Eh]
  __int16 v137; // [xsp+14h] [xbp-1Ch]
  __int16 v138; // [xsp+16h] [xbp-1Ah]
  __int16 v139; // [xsp+18h] [xbp-18h]
  __int16 v140; // [xsp+1Ah] [xbp-16h]
  __int16 v141; // [xsp+1Ch] [xbp-14h]
  __int16 v142; // [xsp+1Eh] [xbp-12h]
  __int16 v143; // [xsp+20h] [xbp-10h]
  __int16 v144; // [xsp+22h] [xbp-Eh]
  __int16 v145; // [xsp+24h] [xbp-Ch]
  __int16 v146; // [xsp+26h] [xbp-Ah]

  v4 = (__int64 *)a2[2];
  v5 = (int *)(a1 + 5300);
  v6 = *a2;
  v7 = *((unsigned int *)v4 + 5);
  v8 = *v4;
  *(_QWORD *)(a1 + 5300) = 0x23D00000000LL;
  if ( (int)v7 <= 0 )
  {
    v13 = 0;
    v14 = (__int64 *)(a1 + 5912);
    v15 = (__int64 *)(a1 + 5920);
    v11 = -1;
    goto LABEL_92;
  }
  v9 = 0LL;
  v10 = (_WORD *)(v6 + 2);
  v11 = -1;
  do
  {
    if ( *(v10 - 1) )
    {
      v11 = v9;
      v12 = *(int *)(a1 + 5300) + 1LL;
      *(_DWORD *)(a1 + 5300) = v12;
      *(_DWORD *)(a1 + 4 * v12 + 3008) = v9;
      *(_BYTE *)(a1 + 5308 + v9) = 0;
    }
    else
    {
      *v10 = 0;
    }
    ++v9;
    v10 += 2;
  }
  while ( v7 != v9 );
  v13 = *(_DWORD *)(a1 + 5300);
  v14 = (__int64 *)(a1 + 5912);
  v15 = (__int64 *)(a1 + 5920);
  if ( v13 <= 1 )
  {
    do
    {
LABEL_92:
      v129 = v13 + 1LL;
      if ( v11 < 2 )
        v130 = v11 + 1;
      else
        v130 = 0;
      if ( v11 < 2 )
        ++v11;
      *(_DWORD *)(a1 + 5300) = v129;
      *(_DWORD *)(a1 + 4 * v129 + 3008) = v130;
      *(_WORD *)(v6 + 4LL * v130) = 1;
      *(_BYTE *)(a1 + v130 + 5308) = 0;
      --*(_QWORD *)(a1 + 5912);
      if ( v8 )
        *v15 -= *(unsigned __int16 *)(v8 + 4LL * v130 + 2);
      v13 = *v5;
    }
    while ( *v5 < 2 );
  }
  v16 = (unsigned int)v13 >> 1;
  *((_DWORD *)a2 + 2) = v11;
  do
  {
    result = sub_6770858(a1, v6, v16);
    v18 = v16-- != 0;
  }
  while ( v16 != 0 && v18 );
  v19 = *(_DWORD *)(a1 + 5300);
  v20 = (int)v7;
  do
  {
    v22 = v19 - 1;
    *(_DWORD *)(a1 + 5300) = v19 - 1;
    v23 = *(int *)(a1 + 4LL * v19 + 3008);
    v24 = *(_DWORD *)(a1 + 3012);
    *(_DWORD *)(a1 + 3012) = v23;
    if ( v19 <= 2 )
    {
      v25 = 1LL;
      goto LABEL_31;
    }
    v26 = 1;
    v27 = 2;
    while ( 1 )
    {
      if ( v27 >= v22 )
      {
        v33 = v27;
        v28 = v27;
      }
      else
      {
        v28 = v27;
        v29 = *(int *)(a1 + 3008 + 4 * (v27 | 1LL));
        v30 = *(int *)(a1 + 3008 + 4LL * v27);
        v31 = *(unsigned __int16 *)(v6 + 4 * v29);
        v32 = *(unsigned __int16 *)(v6 + 4 * v30);
        if ( v31 >= v32 )
        {
          if ( v31 != v32 )
          {
            v33 = v27;
            goto LABEL_21;
          }
          v36 = *(unsigned __int8 *)(a1 + 5308 + v29);
          v33 = v27;
          if ( v36 > *(unsigned __int8 *)(a1 + 5308 + v30) )
            goto LABEL_21;
        }
        v28 = v27 | 1LL;
        v33 = v27 | 1;
      }
LABEL_21:
      result = *(unsigned __int16 *)(v6 + 4 * v23);
      v34 = *(_DWORD *)(a1 + 4 * v28 + 3008);
      v35 = *(unsigned __int16 *)(v6 + 4LL * v34);
      if ( (unsigned int)result < v35 )
        break;
      if ( (_DWORD)result == v35 )
      {
        result = *(unsigned __int8 *)(a1 + v23 + 5308);
        if ( (unsigned int)result <= *(unsigned __int8 *)(a1 + v34 + 5308) )
          break;
      }
      *(_DWORD *)(a1 + 4LL * v26 + 3008) = v34;
      v27 = 2 * v33;
      v22 = *(_DWORD *)(a1 + 5300);
      v26 = v33;
      if ( 2 * v33 > v22 )
        goto LABEL_30;
    }
    v33 = v26;
LABEL_30:
    v25 = v33;
LABEL_31:
    v37 = v24;
    *(_DWORD *)(a1 + 3008 + 4 * v25) = v23;
    v38 = (_WORD *)(v6 + 4LL * v24);
    v39 = *(int *)(a1 + 3012);
    v40 = *(int *)(a1 + 5304) - 1LL;
    v41 = (_WORD *)(v6 + 4 * v39);
    *(_DWORD *)(a1 + 5304) = v40;
    *(_DWORD *)(a1 + 3008 + 4 * v40) = v24;
    v42 = *(int *)(a1 + 5304) - 1LL;
    *(_DWORD *)(a1 + 5304) = v42;
    *(_DWORD *)(a1 + 3008 + 4 * v42) = v39;
    v43 = (_WORD *)(v6 + 4 * v20);
    v44 = a1 + 5308;
    *v43 = *v41 + *v38;
    v45 = *(unsigned __int8 *)(a1 + 5308 + v39);
    if ( *(unsigned __int8 *)(a1 + 5308 + v37) >= v45 )
      LOBYTE(v45) = *(_BYTE *)(a1 + 5308 + v37);
    v46 = (unsigned __int8 *)(v44 + v20);
    *(_BYTE *)(v44 + v20) = v45 + 1;
    v41[1] = v20;
    v38[1] = v20;
    v47 = *(_DWORD *)(a1 + 5300);
    *(_DWORD *)(a1 + 3012) = v20;
    if ( v47 < 2 )
    {
      v21 = 1LL;
      goto LABEL_12;
    }
    v48 = 1;
    v49 = 2;
    while ( 2 )
    {
      if ( v49 >= v47 )
      {
        v54 = v49;
        v50 = v49;
      }
      else
      {
        v50 = v49;
        v51 = *(int *)(a1 + 3008 + 4 * (v49 | 1LL));
        v52 = *(int *)(a1 + 3008 + 4LL * v49);
        result = *(unsigned __int16 *)(v6 + 4 * v51);
        v53 = *(unsigned __int16 *)(v6 + 4 * v52);
        if ( (unsigned int)result < v53 )
          goto LABEL_38;
        if ( (_DWORD)result == v53 )
        {
          result = a1 + 5308;
          v58 = *(unsigned __int8 *)(a1 + 5308 + v51);
          v54 = v49;
          if ( v58 <= *(unsigned __int8 *)(a1 + 5308 + v52) )
          {
LABEL_38:
            v50 = v49 | 1LL;
            v54 = v49 | 1;
          }
        }
        else
        {
          v54 = v49;
        }
      }
      v55 = (unsigned __int16)*v43;
      v56 = *(_DWORD *)(a1 + 4 * v50 + 3008);
      v57 = *(unsigned __int16 *)(v6 + 4LL * v56);
      if ( v55 >= v57 && (v55 != v57 || *v46 > (unsigned int)*(unsigned __int8 *)(a1 + v56 + 5308)) )
      {
        *(_DWORD *)(a1 + 4LL * v48 + 3008) = v56;
        v49 = 2 * v54;
        v47 = *(_DWORD *)(a1 + 5300);
        v48 = v54;
        if ( 2 * v54 > v47 )
          goto LABEL_49;
        continue;
      }
      break;
    }
    v54 = v48;
LABEL_49:
    v21 = v54;
LABEL_12:
    *(_DWORD *)(a1 + 4 * v21 + 3008) = v20++;
    v19 = *(_DWORD *)(a1 + 5300);
  }
  while ( v19 > 1 );
  v59 = *(_DWORD *)(a1 + 3012);
  v60 = *(int *)(a1 + 5304) - 1LL;
  *(_DWORD *)(a1 + 5304) = v60;
  *(_DWORD *)(a1 + 3008 + 4 * v60) = v59;
  v61 = (__int64 *)a2[2];
  v62 = *(int *)(a1 + 5304);
  v63 = *a2;
  v64 = *((_DWORD *)a2 + 2);
  v65 = *v61;
  v66 = v61[1];
  v67 = *((_DWORD *)v61 + 4);
  v68 = *((int *)v61 + 6);
  *(_OWORD *)(a1 + 2992) = 0u;
  *(_OWORD *)(a1 + 2976) = 0u;
  *(_WORD *)(v63 + 4LL * *(int *)(a1 + 3008 + 4 * v62) + 2) = 0;
  v69 = *(int *)(a1 + 5304);
  if ( (int)v69 <= 571 )
  {
    v70 = a1 + 4 * v69;
    v71 = 0;
    v72 = v69 - 572;
    v73 = (int *)(v70 + 3012);
    do
    {
      v74 = *v73;
      v75 = v63 + 4 * v74;
      v76 = *(unsigned __int16 *)(v63 + 4LL * *(unsigned __int16 *)(v75 + 2) + 2);
      v77 = (int)v68 <= v76;
      if ( (int)v68 > v76 )
        result = (unsigned int)(v76 + 1);
      else
        result = (unsigned int)v68;
      if ( v77 )
        ++v71;
      *(_WORD *)(v75 + 2) = result;
      if ( (int)v74 <= v64 )
      {
        ++*(_WORD *)(a1 + 2LL * (int)result + 2976);
        v78 = (int)v74 >= v67 ? *(_DWORD *)(v66 + 4LL * ((int)v74 - v67)) : 0;
        v79 = *(unsigned __int16 *)(v63 + 4 * v74);
        result = *v14 + v79 * (unsigned int)(v78 + result);
        *v14 = result;
        if ( v65 )
        {
          result = *v15;
          *v15 += (v78 + (unsigned int)*(unsigned __int16 *)(v65 + 4 * v74 + 2)) * v79;
        }
      }
      v18 = __CFADD__(v72++, 1);
      ++v73;
    }
    while ( !v18 );
    if ( v71 )
    {
      v80 = (unsigned __int16 *)(a1 + 2 * v68 + 2976);
      do
      {
        v81 = (_WORD *)(a1 + 2 * v68 + 2976);
        v82 = (v68 << 32) + 0x100000000LL;
        do
        {
          v84 = (unsigned __int16)*--v81;
          v83 = v84;
          v82 -= 0x100000000LL;
        }
        while ( !v84 );
        v85 = __OFSUB__(v71, 2);
        v71 -= 2;
        *v81 = v83 - 1;
        *(_WORD *)(a1 + (v82 >> 31) + 2976) += 2;
        v86 = *v80 - 1;
        *v80 = v86;
      }
      while ( !((v71 < 0) ^ v85 | (v71 == 0)) );
      if ( (_DWORD)v68 )
      {
        v87 = 573;
        if ( v86 )
          goto LABEL_74;
        while ( (_DWORD)--v68 )
        {
          v86 = *(_WORD *)(a1 + 2 * v68 + 2976);
          if ( v86 )
          {
LABEL_74:
            v88 = v86;
            do
            {
              v89 = (int *)(a1 + 3004 + 4LL * v87);
              do
              {
                v91 = *v89--;
                v90 = v91;
                --v87;
              }
              while ( (int)v91 > v64 );
              v92 = v63 + 4 * v90;
              v95 = *(unsigned __int16 *)(v92 + 2);
              v93 = (_WORD *)(v92 + 2);
              v94 = v95;
              if ( (_DWORD)v68 != v95 )
              {
                *v14 += (v68 - v94) * *(unsigned __int16 *)(v63 + 4 * v90);
                *v93 = v68;
              }
              --v88;
            }
            while ( v88 );
          }
        }
      }
    }
  }
  v96 = *(_WORD *)(a1 + 2982);
  v97 = *(_WORD *)(a1 + 2984);
  v98 = 2 * (2 * *(_WORD *)(a1 + 2976) + *(_WORD *)(a1 + 2978));
  v99 = *(_WORD *)(a1 + 2986);
  v100 = *(_WORD *)(a1 + 2988);
  v101 = 2 * (v98 + *(_WORD *)(a1 + 2980));
  v132 = 2 * *(_WORD *)(a1 + 2976);
  v133 = v98;
  v102 = 2 * (v101 + v96);
  v134 = v101;
  v103 = 2 * (v102 + v97);
  v104 = v103 + v99;
  v105 = *(_WORD *)(a1 + 2990);
  v104 *= 2;
  v135 = v102;
  v106 = v104 + v100;
  v107 = *(_WORD *)(a1 + 2992);
  v106 *= 2;
  v136 = v103;
  v108 = v106 + v105;
  v109 = *(_WORD *)(a1 + 2994);
  v108 *= 2;
  v137 = v104;
  v110 = v108 + v107;
  v111 = *(_WORD *)(a1 + 2996);
  v110 *= 2;
  v138 = v106;
  v112 = v110 + v109;
  v113 = *(_WORD *)(a1 + 2998);
  v112 *= 2;
  v139 = v108;
  v114 = v112 + v111;
  v115 = *(_WORD *)(a1 + 3000);
  v114 *= 2;
  v140 = v110;
  v116 = v114 + v113;
  v117 = *(_WORD *)(a1 + 3002);
  v116 *= 2;
  v141 = v112;
  v118 = v115 + v116;
  v119 = *(_WORD *)(a1 + 3004);
  v142 = v114;
  v143 = v116;
  v144 = 2 * v118;
  v145 = 2 * (v117 + 2 * v118);
  v146 = 2 * (v145 + v119);
  if ( (v11 & 0x80000000) == 0 )
  {
    v120 = 0LL;
    do
    {
      v121 = v6 + 4 * v120;
      v122 = *(unsigned __int16 *)(v121 + 2);
      if ( *(_WORD *)(v121 + 2) )
      {
        v123 = 2 * v122;
        v124 = 0;
        v125 = v122 + 1;
        v126 = *(unsigned __int16 *)&v131[v123];
        *(_WORD *)&v131[v123] = v126 + 1;
        do
        {
          v127 = v126 & 1;
          v126 >>= 1;
          v128 = v124 | v127;
          --v125;
          v124 = 2 * v128;
        }
        while ( v125 > 1 );
        *(_WORD *)(v6 + 4 * v120) = v128;
      }
      ++v120;
    }
    while ( v120 != v11 + 1 );
  }
  return result;
}


================================================================================
Function: sub_67704A8 (0x67704A8)
================================================================================

__int64 __fastcall sub_67704A8(__int64 result, __int64 a2, __int64 a3)
{
  __int64 v3; // x8
  __int64 v4; // x5
  __int64 v5; // x19
  __int64 v6; // x5
  char v7; // w7
  __int64 v8; // x19
  int v9; // w3
  int v10; // w4
  int v11; // w3
  __int64 v12; // x6
  __int64 v13; // x7
  int v14; // w20
  __int64 v15; // x4
  unsigned int v16; // w19
  int v17; // w5
  int v18; // w4
  __int64 v19; // x20
  __int64 v20; // x22
  __int64 v21; // x4
  __int64 v22; // x22
  int v23; // w5
  unsigned __int16 *v24; // x3
  int v25; // w5
  unsigned int v26; // w4
  int v27; // w3
  int v28; // w6
  int v29; // w19
  int v30; // w6
  __int64 v31; // x7
  __int16 v32; // w4
  __int64 v33; // x20
  __int64 v34; // x4
  char v35; // w5
  __int64 v36; // x20
  int v37; // w5
  int v38; // w6
  unsigned int v39; // w6
  unsigned int v40; // w3
  __int64 v41; // x7
  unsigned __int16 *v42; // x3
  unsigned int v43; // w19
  int v44; // w3
  __int64 v45; // x5
  __int64 v46; // x21
  __int64 v47; // x4
  __int64 v48; // x21
  int v49; // w5
  unsigned int v50; // w6
  __int64 v51; // x7
  __int16 v52; // w3
  __int64 v53; // x19
  __int64 v54; // x3
  char v55; // w4
  __int64 v56; // x19
  char v57; // w4
  unsigned int v58; // w6
  unsigned int v59; // w9
  int v60; // w8
  int v61; // w11
  __int64 v62; // x12
  __int64 v63; // x14
  __int64 v64; // x12
  __int64 v65; // x14
  char v66; // w11
  int v67; // w11
  int v68; // w8

  if ( *(_DWORD *)(result + 5900) )
  {
    v3 = 0LL;
    while ( 1 )
    {
      v11 = *(unsigned __int16 *)(*(_QWORD *)(result + 5904) + 2 * v3);
      v12 = *(unsigned __int8 *)(*(_QWORD *)(result + 5888) + v3);
      if ( *(_WORD *)(*(_QWORD *)(result + 5904) + 2 * v3) )
      {
        v13 = byte_17351FE[v12];
        v14 = *(_DWORD *)(result + 5940);
        v15 = a2 + 4 * v13;
        v16 = *(unsigned __int16 *)(v15 + 1028);
        v17 = *(unsigned __int16 *)(v15 + 1030);
        v18 = *(unsigned __int16 *)(result + 5936) | (v16 << v14);
        *(_WORD *)(result + 5936) |= (_WORD)v16 << v14;
        if ( v14 <= 16 - v17 )
        {
          v23 = v14 + v17;
        }
        else
        {
          v19 = *(_QWORD *)(result + 40);
          v20 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v19 + 1;
          *(_BYTE *)(v20 + v19) = v18;
          v21 = *(_QWORD *)(result + 40);
          v22 = *(_QWORD *)(result + 16);
          LOBYTE(v19) = *(_BYTE *)(result + 5937);
          *(_QWORD *)(result + 40) = v21 + 1;
          *(_BYTE *)(v22 + v21) = v19;
          LODWORD(v19) = *(_DWORD *)(result + 5940);
          v23 = v17 + v19 - 16;
          v18 = v16 >> (16 - v19);
          *(_WORD *)(result + 5936) = v18;
        }
        *(_DWORD *)(result + 5940) = v23;
        if ( (unsigned __int64)(v13 - 28) >= 0xFFFFFFFFFFFFFFECLL )
        {
          v29 = dword_17357F8[v13];
          v30 = v12 - dword_1735944[v13];
          if ( v23 <= 16 - v29 )
          {
            v38 = v30 << v23;
            v23 += v29;
            v18 |= v38;
          }
          else
          {
            v31 = *(_QWORD *)(result + 40);
            v32 = v18 | (v30 << v23);
            v33 = *(_QWORD *)(result + 16);
            *(_WORD *)(result + 5936) = v32;
            *(_QWORD *)(result + 40) = v31 + 1;
            *(_BYTE *)(v33 + v31) = v32;
            v34 = *(_QWORD *)(result + 40);
            v35 = *(_BYTE *)(result + 5937);
            v36 = *(_QWORD *)(result + 16);
            *(_QWORD *)(result + 40) = v34 + 1;
            *(_BYTE *)(v36 + v34) = v35;
            v37 = *(_DWORD *)(result + 5940);
            LOBYTE(v34) = 16 - v37;
            v23 = v29 + v37 - 16;
            v18 = (unsigned __int16)v30 >> v34;
          }
          *(_WORD *)(result + 5936) = v18;
          *(_DWORD *)(result + 5940) = v23;
        }
        v39 = v11 - 1;
        v40 = ((unsigned int)(v11 - 1) >> 7) + 256;
        if ( v39 < 0x100 )
          v40 = v39;
        v41 = (unsigned __int8)byte_1734FFE[v40];
        v42 = (unsigned __int16 *)(a3 + 4 * v41);
        v43 = *v42;
        v44 = v42[1];
        v10 = v18 | (v43 << v23);
        *(_WORD *)(result + 5936) = v10;
        if ( v23 <= 16 - v44 )
        {
          v9 = v23 + v44;
        }
        else
        {
          v45 = *(_QWORD *)(result + 40);
          v46 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v45 + 1;
          *(_BYTE *)(v46 + v45) = v10;
          v47 = *(_QWORD *)(result + 40);
          v48 = *(_QWORD *)(result + 16);
          LOBYTE(v45) = *(_BYTE *)(result + 5937);
          *(_QWORD *)(result + 40) = v47 + 1;
          *(_BYTE *)(v48 + v47) = v45;
          LODWORD(v45) = *(_DWORD *)(result + 5940);
          v9 = v44 + v45 - 16;
          v10 = v43 >> (16 - v45);
          *(_WORD *)(result + 5936) = v10;
        }
        *(_DWORD *)(result + 5940) = v9;
        if ( (unsigned int)v41 < 4 )
          goto LABEL_6;
        v49 = dword_173586C[v41];
        v50 = v39 - dword_17359B8[v41];
        if ( v9 <= 16 - v49 )
        {
          v58 = v50 << v9;
          v9 += v49;
          LOWORD(v10) = v10 | v58;
        }
        else
        {
          v51 = *(_QWORD *)(result + 40);
          v52 = v10 | (v50 << v9);
          v53 = *(_QWORD *)(result + 16);
          *(_WORD *)(result + 5936) = v52;
          *(_QWORD *)(result + 40) = v51 + 1;
          *(_BYTE *)(v53 + v51) = v52;
          v54 = *(_QWORD *)(result + 40);
          v55 = *(_BYTE *)(result + 5937);
          v56 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v54 + 1;
          *(_BYTE *)(v56 + v54) = v55;
          LODWORD(v54) = *(_DWORD *)(result + 5940);
          v57 = 16 - v54;
          v9 = v49 + v54 - 16;
          v10 = (unsigned __int16)v50 >> v57;
        }
      }
      else
      {
        v24 = (unsigned __int16 *)(a2 + 4 * v12);
        v25 = *(_DWORD *)(result + 5940);
        v26 = *v24;
        v27 = v24[1];
        v28 = *(unsigned __int16 *)(result + 5936) | (v26 << v25);
        *(_WORD *)(result + 5936) |= (_WORD)v26 << v25;
        if ( v25 <= 16 - v27 )
        {
          v9 = v25 + v27;
          goto LABEL_5;
        }
        v4 = *(_QWORD *)(result + 40);
        v5 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v4 + 1;
        *(_BYTE *)(v5 + v4) = v28;
        v6 = *(_QWORD *)(result + 40);
        v7 = *(_BYTE *)(result + 5937);
        v8 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v6 + 1;
        *(_BYTE *)(v8 + v6) = v7;
        LODWORD(v6) = *(_DWORD *)(result + 5940);
        v9 = v27 + v6 - 16;
        v10 = v26 >> (16 - v6);
      }
      *(_WORD *)(result + 5936) = v10;
LABEL_5:
      *(_DWORD *)(result + 5940) = v9;
LABEL_6:
      if ( ++v3 >= (unsigned __int64)*(unsigned int *)(result + 5900) )
        goto LABEL_28;
    }
  }
  v9 = *(_DWORD *)(result + 5940);
LABEL_28:
  v59 = *(unsigned __int16 *)(a2 + 1024);
  v60 = *(unsigned __int16 *)(a2 + 1026);
  v61 = *(unsigned __int16 *)(result + 5936) | (v59 << v9);
  *(_WORD *)(result + 5936) |= (_WORD)v59 << v9;
  if ( v9 <= 16 - v60 )
  {
    v68 = v9 + v60;
  }
  else
  {
    v62 = *(_QWORD *)(result + 40);
    v63 = *(_QWORD *)(result + 16);
    *(_QWORD *)(result + 40) = v62 + 1;
    *(_BYTE *)(v63 + v62) = v61;
    v64 = *(_QWORD *)(result + 40);
    v65 = *(_QWORD *)(result + 16);
    v66 = *(_BYTE *)(result + 5937);
    *(_QWORD *)(result + 40) = v64 + 1;
    *(_BYTE *)(v65 + v64) = v66;
    v67 = *(_DWORD *)(result + 5940);
    v68 = v60 + v67 - 16;
    *(_WORD *)(result + 5936) = v59 >> (16 - v67);
  }
  *(_DWORD *)(result + 5940) = v68;
  return result;
}


================================================================================
Function: sub_6770858 (0x6770858)
================================================================================

__int64 __fastcall sub_6770858(__int64 result, __int64 a2, int a3)
{
  int v3; // w15
  int v4; // w13
  __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x12
  __int64 v8; // x15
  __int64 v9; // x15
  __int64 v10; // x14
  __int64 v11; // x17
  unsigned int v12; // w3
  unsigned int v13; // w4
  unsigned int v14; // w3
  int v15; // w14
  unsigned int v16; // w16
  int v17; // w13
  unsigned int v18; // w15

  v3 = *(_DWORD *)(result + 5300);
  v4 = 2 * a3;
  v5 = *(int *)(result + 4LL * a3 + 3008);
  if ( 2 * a3 > v3 )
  {
    v6 = a3;
    goto LABEL_17;
  }
  v7 = result + 5308;
  while ( 1 )
  {
    if ( v4 >= v3 )
    {
      v15 = v4;
      v9 = v4;
      goto LABEL_12;
    }
    v9 = v4;
    v10 = *(int *)(result + 3008 + 4 * (v4 | 1LL));
    v11 = *(int *)(result + 3008 + 4LL * v4);
    v12 = *(unsigned __int16 *)(a2 + 4 * v10);
    v13 = *(unsigned __int16 *)(a2 + 4 * v11);
    if ( v12 < v13 )
    {
LABEL_10:
      v9 = v4 | 1LL;
      v15 = v4 | 1;
      goto LABEL_12;
    }
    if ( v12 == v13 )
    {
      v14 = *(unsigned __int8 *)(v7 + v10);
      v15 = v4;
      if ( v14 <= *(unsigned __int8 *)(v7 + v11) )
        goto LABEL_10;
    }
    else
    {
      v15 = v4;
    }
LABEL_12:
    v16 = *(unsigned __int16 *)(a2 + 4 * v5);
    v17 = *(_DWORD *)(result + 4 * v9 + 3008);
    v18 = *(unsigned __int16 *)(a2 + 4LL * v17);
    if ( v16 < v18
      || v16 == v18
      && *(unsigned __int8 *)(result + v5 + 5308) <= (unsigned int)*(unsigned __int8 *)(result + v17 + 5308) )
    {
      break;
    }
    v8 = result + 4LL * a3;
    a3 = v15;
    *(_DWORD *)(v8 + 3008) = v17;
    v4 = 2 * v15;
    v3 = *(_DWORD *)(result + 5300);
    if ( 2 * v15 > v3 )
      goto LABEL_16;
  }
  v15 = a3;
LABEL_16:
  v6 = v15;
LABEL_17:
  *(_DWORD *)(result + 4 * v6 + 3008) = v5;
  return result;
}


================================================================================
Function: sub_6770964 (0x6770964)
================================================================================

__int64 __fastcall sub_6770964(__int64 result, __int64 a2, int a3)
{
  unsigned int v3; // w9
  __int64 v4; // x8
  int v5; // w4
  int v6; // w7
  int v7; // w6
  int v8; // w19
  unsigned int v9; // w3
  int v10; // w5
  __int64 v11; // x6
  int v12; // w7
  unsigned __int16 *v13; // x4
  unsigned __int16 *v14; // x6
  unsigned int v15; // w20
  int v16; // w19
  int v17; // w21
  __int64 v18; // x7
  __int64 v19; // x23
  __int64 v20; // x7
  char v21; // w22
  __int64 v22; // x23
  char v23; // w21
  int v24; // w6
  int v25; // w19
  unsigned int v26; // w7
  int v27; // w6
  int v28; // w5
  __int64 v29; // x19
  __int64 v30; // x21
  __int64 v31; // x5
  __int64 v32; // x21
  int v33; // w6
  __int64 v34; // x5
  int v35; // w7
  unsigned int v36; // w6
  int v37; // w5
  int v38; // w19
  __int64 v39; // x7
  __int64 v40; // x21
  __int64 v41; // x7
  __int64 v42; // x21
  char v43; // w19
  unsigned int v44; // w19
  int v45; // w19
  unsigned int v46; // w7
  int v47; // w6
  __int64 v48; // x19
  __int64 v49; // x21
  __int64 v50; // x5
  __int64 v51; // x21
  int v52; // w6
  unsigned int v53; // w19
  int v54; // w7
  int v55; // w5
  __int64 v56; // x6
  __int64 v57; // x21
  __int64 v58; // x5
  __int64 v59; // x21
  int v60; // w7
  int v61; // w6
  int v62; // w4
  __int64 v63; // x7
  __int16 v64; // w5
  __int64 v65; // x19
  __int64 v66; // x5
  char v67; // w6
  __int64 v68; // x19
  int v69; // w6
  int v70; // w4
  int v71; // w4
  int v72; // w7
  __int64 v73; // x6
  __int16 v74; // w5
  __int64 v75; // x19
  __int64 v76; // x5
  __int64 v77; // x19
  int v78; // w4
  int v79; // w7
  __int64 v80; // x6
  __int16 v81; // w5
  __int64 v82; // x19
  __int64 v83; // x5
  __int64 v84; // x19

  if ( (a3 & 0x80000000) == 0 )
  {
    v3 = *(unsigned __int16 *)(a2 + 2);
    v4 = 0LL;
    v5 = 0;
    if ( *(_WORD *)(a2 + 2) )
      v6 = 7;
    else
      v6 = 138;
    if ( *(_WORD *)(a2 + 2) )
      v7 = 4;
    else
      v7 = 3;
    v8 = -1;
    while ( 1 )
    {
      ++v4;
      v9 = v3;
      v3 = *(unsigned __int16 *)(a2 + 4 * v4 + 2);
      v10 = v5 + 1;
      if ( v5 + 1 >= v6 || v9 != v3 )
        break;
      v9 = v8;
LABEL_10:
      v8 = v9;
      v5 = v10;
      if ( v4 == a3 + 1 )
        return result;
    }
    if ( v10 < v7 )
    {
      v11 = result + 4LL * v9;
      v12 = *(_DWORD *)(result + 5940);
      v13 = (unsigned __int16 *)(v11 + 2750);
      v14 = (unsigned __int16 *)(v11 + 2748);
      do
      {
        v15 = *v14;
        v16 = *v13;
        v17 = *(unsigned __int16 *)(result + 5936) | (v15 << v12);
        *(_WORD *)(result + 5936) |= (_WORD)v15 << v12;
        if ( v12 <= 16 - v16 )
        {
          v12 += v16;
        }
        else
        {
          v18 = *(_QWORD *)(result + 40);
          v19 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v18 + 1;
          *(_BYTE *)(v19 + v18) = v17;
          v20 = *(_QWORD *)(result + 40);
          v21 = *(_BYTE *)(result + 5937);
          v22 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v20 + 1;
          *(_BYTE *)(v22 + v20) = v21;
          LODWORD(v20) = *(_DWORD *)(result + 5940);
          v23 = 16 - v20;
          v12 = v16 + v20 - 16;
          *(_WORD *)(result + 5936) = v15 >> v23;
        }
        --v10;
        *(_DWORD *)(result + 5940) = v12;
      }
      while ( v10 );
      goto LABEL_47;
    }
    if ( v9 )
    {
      if ( v9 == v8 )
      {
        v24 = *(_DWORD *)(result + 5940);
        ++v5;
      }
      else
      {
        v34 = result + 4LL * v9;
        v35 = *(_DWORD *)(result + 5940);
        v36 = *(unsigned __int16 *)(v34 + 2748);
        v37 = *(unsigned __int16 *)(v34 + 2750);
        v38 = *(unsigned __int16 *)(result + 5936) | (v36 << v35);
        *(_WORD *)(result + 5936) |= (_WORD)v36 << v35;
        if ( v35 <= 16 - v37 )
        {
          v24 = v35 + v37;
        }
        else
        {
          v39 = *(_QWORD *)(result + 40);
          v40 = *(_QWORD *)(result + 16);
          *(_QWORD *)(result + 40) = v39 + 1;
          *(_BYTE *)(v40 + v39) = v38;
          v41 = *(_QWORD *)(result + 40);
          v42 = *(_QWORD *)(result + 16);
          v43 = *(_BYTE *)(result + 5937);
          *(_QWORD *)(result + 40) = v41 + 1;
          *(_BYTE *)(v42 + v41) = v43;
          LODWORD(v41) = *(_DWORD *)(result + 5940);
          v44 = v36 >> (16 - v41);
          v24 = v37 + v41 - 16;
          *(_WORD *)(result + 5936) = v44;
        }
        *(_DWORD *)(result + 5940) = v24;
      }
      v53 = *(unsigned __int16 *)(result + 2812);
      v54 = *(unsigned __int16 *)(result + 2814);
      v55 = *(unsigned __int16 *)(result + 5936) | (v53 << v24);
      if ( v24 <= 16 - v54 )
      {
        v61 = v24 + v54;
      }
      else
      {
        v56 = *(_QWORD *)(result + 40);
        *(_WORD *)(result + 5936) = v55;
        v57 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v56 + 1;
        *(_BYTE *)(v57 + v56) = v55;
        v58 = *(_QWORD *)(result + 40);
        v59 = *(_QWORD *)(result + 16);
        LOBYTE(v56) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v58 + 1;
        *(_BYTE *)(v59 + v58) = v56;
        LODWORD(v58) = *(_DWORD *)(result + 5940);
        v60 = v54 + v58;
        v55 = v53 >> (16 - v58);
        v61 = v60 - 16;
      }
      v62 = v5 + 65533;
      *(_DWORD *)(result + 5940) = v61;
      if ( v61 >= 15 )
      {
        v63 = *(_QWORD *)(result + 40);
        v64 = v55 | (v62 << v61);
        v65 = *(_QWORD *)(result + 16);
        *(_WORD *)(result + 5936) = v64;
        *(_QWORD *)(result + 40) = v63 + 1;
        *(_BYTE *)(v65 + v63) = v64;
        v66 = *(_QWORD *)(result + 40);
        v67 = *(_BYTE *)(result + 5937);
        v68 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v66 + 1;
        *(_BYTE *)(v68 + v66) = v67;
        LODWORD(v66) = *(_DWORD *)(result + 5940);
        v69 = (unsigned __int16)v62 >> (16 - v66);
        v70 = v66 - 14;
        *(_WORD *)(result + 5936) = v69;
LABEL_46:
        *(_DWORD *)(result + 5940) = v70;
LABEL_47:
        v10 = 0;
        if ( v3 )
        {
          if ( v9 == v3 )
            v7 = 3;
          else
            v7 = 4;
          if ( v9 == v3 )
            v6 = 6;
          else
            v6 = 7;
        }
        else
        {
          v6 = 138;
          v7 = 3;
        }
        goto LABEL_10;
      }
      v28 = v55 | (v62 << v61);
      v70 = v61 + 2;
    }
    else if ( v5 > 9 )
    {
      v45 = *(_DWORD *)(result + 5940);
      v46 = *(unsigned __int16 *)(result + 2820);
      v47 = *(unsigned __int16 *)(result + 2822);
      v28 = *(unsigned __int16 *)(result + 5936) | (v46 << v45);
      if ( v45 <= 16 - v47 )
      {
        v52 = v45 + v47;
      }
      else
      {
        v48 = *(_QWORD *)(result + 40);
        *(_WORD *)(result + 5936) = v28;
        v49 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v48 + 1;
        *(_BYTE *)(v49 + v48) = v28;
        v50 = *(_QWORD *)(result + 40);
        v51 = *(_QWORD *)(result + 16);
        LOBYTE(v48) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v50 + 1;
        *(_BYTE *)(v51 + v50) = v48;
        LODWORD(v50) = *(_DWORD *)(result + 5940);
        v52 = v47 + v50 - 16;
        v28 = v46 >> (16 - v50);
      }
      v78 = v5 + 65526;
      v79 = v78 << v52;
      *(_DWORD *)(result + 5940) = v52;
      if ( v52 >= 10 )
      {
        v80 = *(_QWORD *)(result + 40);
        v81 = v28 | v79;
        v82 = *(_QWORD *)(result + 16);
        *(_WORD *)(result + 5936) = v81;
        *(_QWORD *)(result + 40) = v80 + 1;
        *(_BYTE *)(v82 + v80) = v81;
        v83 = *(_QWORD *)(result + 40);
        v84 = *(_QWORD *)(result + 16);
        LOBYTE(v80) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v83 + 1;
        *(_BYTE *)(v84 + v83) = v80;
        LODWORD(v83) = *(_DWORD *)(result + 5940);
        LODWORD(v80) = (unsigned __int16)v78 >> (16 - v83);
        v70 = v83 - 9;
        *(_WORD *)(result + 5936) = v80;
        goto LABEL_46;
      }
      LOWORD(v28) = v28 | v79;
      v70 = v52 + 7;
    }
    else
    {
      v25 = *(_DWORD *)(result + 5940);
      v26 = *(unsigned __int16 *)(result + 2816);
      v27 = *(unsigned __int16 *)(result + 2818);
      v28 = *(unsigned __int16 *)(result + 5936) | (v26 << v25);
      if ( v25 <= 16 - v27 )
      {
        v33 = v25 + v27;
      }
      else
      {
        v29 = *(_QWORD *)(result + 40);
        *(_WORD *)(result + 5936) = v28;
        v30 = *(_QWORD *)(result + 16);
        *(_QWORD *)(result + 40) = v29 + 1;
        *(_BYTE *)(v30 + v29) = v28;
        v31 = *(_QWORD *)(result + 40);
        v32 = *(_QWORD *)(result + 16);
        LOBYTE(v29) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v31 + 1;
        *(_BYTE *)(v32 + v31) = v29;
        LODWORD(v31) = *(_DWORD *)(result + 5940);
        v33 = v27 + v31 - 16;
        v28 = v26 >> (16 - v31);
      }
      v71 = v5 + 65534;
      v72 = v71 << v33;
      *(_DWORD *)(result + 5940) = v33;
      if ( v33 >= 14 )
      {
        v73 = *(_QWORD *)(result + 40);
        v74 = v28 | v72;
        v75 = *(_QWORD *)(result + 16);
        *(_WORD *)(result + 5936) = v74;
        *(_QWORD *)(result + 40) = v73 + 1;
        *(_BYTE *)(v75 + v73) = v74;
        v76 = *(_QWORD *)(result + 40);
        v77 = *(_QWORD *)(result + 16);
        LOBYTE(v73) = *(_BYTE *)(result + 5937);
        *(_QWORD *)(result + 40) = v76 + 1;
        *(_BYTE *)(v77 + v76) = v73;
        LODWORD(v76) = *(_DWORD *)(result + 5940);
        LODWORD(v73) = (unsigned __int16)v71 >> (16 - v76);
        v70 = v76 - 13;
        *(_WORD *)(result + 5936) = v73;
        goto LABEL_46;
      }
      LOWORD(v28) = v28 | v72;
      v70 = v33 + 3;
    }
    *(_WORD *)(result + 5936) = v28;
    goto LABEL_46;
  }
  return result;
}


================================================================================
Function: sub_67731EC (0x67731EC)
================================================================================

__int64 __fastcall sub_67731EC(__int64 a1, _OWORD *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x9
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x24
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x10
  unsigned __int64 v11; // x8
  char *v12; // x9
  _BYTE *v13; // x10
  char v14; // t1
  unsigned __int64 v15; // x9
  unsigned __int64 v16; // x8
  char *v17; // x9
  char v18; // t1
  unsigned __int64 v19; // x20
  unsigned __int64 v20; // x21
  unsigned __int64 v21; // x8
  __int64 v22; // x10
  unsigned __int64 v23; // x9
  char *v24; // x8
  _BYTE *v25; // x10
  char v26; // t1
  unsigned __int64 v28; // x12
  __int64 *v29; // x10
  __int64 v30; // x11
  unsigned __int64 v31; // x12
  _QWORD *v32; // x11
  __int64 v33; // t1
  __int128 v34; // q1
  __int64 v35; // x10
  unsigned __int64 v36; // x12
  __int64 *v37; // x10
  __int64 v38; // x11
  unsigned __int64 v39; // x12
  _QWORD *v40; // x11
  __int64 v41; // t1
  __int128 *v42; // x9
  _OWORD *v43; // x10
  unsigned __int64 v44; // x11
  __int128 v45; // q0
  __int128 v46; // q1
  unsigned __int64 v47; // x11
  __int64 *v48; // x9
  _QWORD *v49; // x10
  unsigned __int64 v50; // x11
  __int64 v51; // t1
  _BYTE v52[256]; // [xsp+8h] [xbp-128h] BYREF
  _BYTE v53[32]; // [xsp+108h] [xbp-28h] BYREF

  if ( !a3 )
    return 0LL;
  v3 = *(_QWORD *)(a1 + 32);
  v7 = (v3 >> 3) & 0x3F;
  v8 = 64 - v7;
  *(_QWORD *)(a1 + 32) = v3 + 8 * a3;
  if ( 64 - v7 <= a3 )
  {
    if ( v7 > 0x38 || a1 + v7 + 40 < (unsigned __int64)a2 + v8 && a1 + 104 > (unsigned __int64)a2 )
    {
      v15 = 0LL;
      goto LABEL_14;
    }
    if ( v7 <= 0x30 )
    {
      v15 = v8 & 0x70;
      *(_OWORD *)(a1 + v7 + 40) = *a2;
      if ( v15 != 16 )
      {
        *(_OWORD *)(v7 + a1 + 56) = a2[1];
        if ( v15 != 32 )
        {
          *(_OWORD *)(v7 + a1 + 72) = a2[2];
          if ( v15 != 48 )
            *(_OWORD *)(v7 + a1 + 88) = a2[3];
        }
      }
      if ( v8 == v15 )
        goto LABEL_16;
      if ( (v8 & 8) == 0 )
      {
LABEL_14:
        v16 = v15 + v7;
        v17 = (char *)a2 + v15;
        do
        {
          v18 = *v17++;
          *(_BYTE *)(a1 + 40 + v16++) = v18;
        }
        while ( v16 != 64 );
        goto LABEL_16;
      }
    }
    else
    {
      v15 = 0LL;
    }
    v28 = v15;
    v15 = v8 & 0x78;
    v29 = (__int64 *)((char *)a2 + v28);
    v30 = a1 + v28 + v7;
    v31 = v28 - v15;
    v32 = (_QWORD *)(v30 + 40);
    do
    {
      v33 = *v29++;
      v31 += 8LL;
      *v32++ = v33;
    }
    while ( v31 );
    if ( v8 != v15 )
      goto LABEL_14;
LABEL_16:
    sub_677354C(a1, a1 + 40, v52, v53);
    v19 = (unsigned __int64)a2 + v8;
    v20 = a3 - v8;
    if ( v20 >= 0x40 )
    {
      do
      {
        sub_677354C(a1, v19, v52, v53);
        v19 += 64LL;
        v20 -= 64LL;
      }
      while ( v20 > 0x3F );
    }
    if ( !v20 )
      goto LABEL_25;
    if ( v20 < 8 || a1 + 40 < v19 + v20 && v19 < a1 + 40 + v20 )
    {
      v21 = 0LL;
LABEL_23:
      v22 = a1 + v21;
      v23 = v20 - v21;
      v24 = (char *)(v19 + v21);
      v25 = (_BYTE *)(v22 + 40);
      do
      {
        v26 = *v24++;
        --v23;
        *v25++ = v26;
      }
      while ( v23 );
LABEL_25:
      sub_677C544(v52, 288LL);
      return 0LL;
    }
    if ( v20 >= 0x20 )
    {
      v21 = v20 & 0x20;
      v42 = (__int128 *)(v19 + 16);
      v43 = (_OWORD *)(a1 + 56);
      v44 = v20 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v45 = *(v42 - 1);
        v46 = *v42;
        v42 += 2;
        v44 -= 32LL;
        *(v43 - 1) = v45;
        *v43 = v46;
        v43 += 2;
      }
      while ( v44 );
      if ( v20 == v21 )
        goto LABEL_25;
      if ( (v20 & 0x18) == 0 )
        goto LABEL_23;
    }
    else
    {
      v21 = 0LL;
    }
    v47 = v21;
    v21 = v20 & 0xFFFFFFFFFFFFFFF8LL;
    v48 = (__int64 *)(v19 + v47);
    v49 = (_QWORD *)(a1 + v47 + 40);
    v50 = v47 - (v20 & 0xFFFFFFFFFFFFFFF8LL);
    do
    {
      v51 = *v48++;
      v50 += 8LL;
      *v49++ = v51;
    }
    while ( v50 );
    if ( v20 == v21 )
      goto LABEL_25;
    goto LABEL_23;
  }
  if ( a3 < 8 || a1 + 40 + v7 < (unsigned __int64)a2 + a3 && a1 + 40 + v7 + a3 > (unsigned __int64)a2 )
  {
    v9 = 0LL;
    goto LABEL_7;
  }
  if ( a3 >= 0x20 )
  {
    v34 = a2[1];
    v35 = a1 + v7;
    v9 = a3 & 0xFFFFFFFFFFFFFFE0LL;
    *(_OWORD *)(v35 + 40) = *a2;
    *(_OWORD *)(v35 + 56) = v34;
    if ( (a3 & 0xFFFFFFFFFFFFFFE0LL) == a3 )
      return 0LL;
    if ( (a3 & 0x18) == 0 )
      goto LABEL_7;
  }
  else
  {
    v9 = 0LL;
  }
  v36 = v9;
  v9 = a3 & 0xFFFFFFFFFFFFFFF8LL;
  v37 = (__int64 *)((char *)a2 + v36);
  v38 = a1 + v36 + v7;
  v39 = v36 - (a3 & 0xFFFFFFFFFFFFFFF8LL);
  v40 = (_QWORD *)(v38 + 40);
  do
  {
    v41 = *v37++;
    v39 += 8LL;
    *v40++ = v41;
  }
  while ( v39 );
  if ( v9 != a3 )
  {
LABEL_7:
    v10 = v9 + v7;
    v11 = a3 - v9;
    v12 = (char *)a2 + v9;
    v13 = (_BYTE *)(a1 + v10 + 40);
    do
    {
      v14 = *v12++;
      --v11;
      *v13++ = v14;
    }
    while ( v11 );
  }
  return 0LL;
}


================================================================================
Function: sub_677354C (0x677354C)
================================================================================

__int64 __fastcall sub_677354C(
        __int64 result,
        const char *a2,
        int8x16_t *a3,
        _DWORD *a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        int8x16_t a11)
{
  __int64 i; // x8
  uint16x8_t v12; // q4
  uint16x8_t v13; // q5
  uint16x8_t v14; // q6
  uint16x8_t v15; // q7
  uint16x8_t v18; // q17
  int8x16_t v19; // q19
  int8x16_t v20; // q22
  int8x16_t v21; // q6
  __int128 v28; // q0
  __int64 v29; // x8
  int v30; // w4
  int v31; // w12
  int v32; // w13
  int8x16_t *v33; // x10
  unsigned __int64 v34; // t2
  int v35; // w19
  int v36; // w16
  int v37; // w14
  int v38; // w17
  unsigned __int64 v39; // t2
  int v40; // w16
  int v41; // w5
  int v42; // w15
  int v43; // w1
  unsigned int v44; // w15
  int v45; // w16
  unsigned __int64 v46; // t2
  int v47; // w13
  int v48; // w13
  int v49; // w16
  int v50; // w6
  unsigned __int64 v51; // t2
  int v52; // w13
  int v53; // w5
  int v54; // w7
  int v55; // w5
  int v56; // w4
  unsigned int v57; // w14
  int v58; // w5
  int v59; // w5
  unsigned __int64 v60; // t2
  int v61; // w12
  int v62; // w17
  int v63; // w12
  int v64; // w5
  int v65; // w7
  int v66; // w1
  unsigned int v67; // w6
  unsigned int v68; // w15
  int v69; // w1
  int v70; // w1
  unsigned __int64 v71; // t2
  int v72; // w16
  int v73; // w1
  unsigned int v74; // w13
  int v75; // w16
  int v76; // w19
  int v77; // w16
  unsigned __int64 v78; // t2
  int v79; // w16
  int v80; // w7
  unsigned int v81; // w14
  int v82; // w16
  int v83; // w16
  unsigned __int64 v84; // t2
  int v85; // w16
  int v86; // w5
  int v87; // w16
  int v88; // w12
  unsigned __int32 v89; // w4
  int v90; // w6
  int v91; // w12
  unsigned int v92; // w17
  unsigned int v93; // w12
  int v94; // w15
  int v95; // w15
  unsigned __int64 v96; // t2
  int v97; // w15
  int v98; // w4
  int v99; // w13
  int v100; // w15
  int v101; // w6
  int v102; // w7
  int v103; // w15
  unsigned int v104; // w1
  unsigned int v105; // w14
  int v106; // w15
  int v107; // w15
  unsigned __int64 v108; // t2
  int v109; // w15
  int v110; // w16
  unsigned int v111; // w15
  int v112; // w7
  int v113; // w20
  int v114; // w5
  int v115; // w5
  unsigned __int64 v116; // t2
  int v117; // w17
  int v118; // w12
  unsigned int v119; // w17
  int v120; // w5
  int v121; // w5
  unsigned __int64 v122; // t2
  int v123; // w4
  int v124; // w13
  unsigned int v125; // w4
  int v126; // w7
  int v127; // w11
  int v128; // w5
  int v129; // w5
  unsigned __int64 v130; // t2
  int v131; // w1
  int v132; // w14
  int v133; // w1
  int v134; // w5
  int v135; // w11
  unsigned int v136; // w14
  int v137; // w11
  int8x8_t v138; // d0
  int8x8_t v139; // d2
  unsigned __int32 v140; // w11
  int32x2_t v141; // d7
  int v142; // w14
  unsigned __int64 v143; // t2
  int8x8_t v144; // d16
  int8x8_t v145; // d4
  int v146; // w14
  int8x8_t v147; // d1
  int8x8_t v148; // d5
  int8x8_t v149; // d18
  int8x8_t v150; // d2
  int8x8_t v151; // d19
  int8x8_t v152; // d3
  int8x8_t v153; // d7
  int8x8_t v154; // d6
  int32x2_t v155; // d7
  int32x2_t v156; // d4
  unsigned __int64 v157; // d5
  int v158; // w9
  int v159; // w8
  int v160; // w9
  int v161; // w10
  int v162; // w8
  int v163; // w9
  int v164; // w10
  int v165; // w8
  int v166; // w9
  int v167; // w10
  int8x16x4_t v168; // 0:q0.16,16:q1.16,32:q2.16,48:q3.16

  if ( a2 + 64 <= (const char *)a3 || &a3[4] <= (int8x16_t *)a2 )
  {
    v168 = vld4q_s8(a2);
    v12 = vmovl_high_u8(v168.val[3]);
    v13 = vmovl_u8((uint8x8_t)v168.val[3].n128_u64[0]);
    v14 = vmovl_u8((uint8x8_t)v168.val[2].n128_u64[0]);
    v15 = vmovl_high_u8(v168.val[2]);
    _Q21 = vmovl_u8((uint8x8_t)v168.val[1].n128_u64[0]);
    _Q16 = vmovl_high_u8(v168.val[1]);
    v18 = vmovl_high_u8(v168.val[0]);
    v168.val[0] = vmovl_u8((uint8x8_t)v168.val[0].n128_u64[0]);
    v168.val[2] = vshll_n_u16((uint16x4_t)v14.n128_u64[0], 8uLL);
    v19 = vmovl_high_u16(v13);
    v20 = vshll_high_n_u16(v14, 8uLL);
    v168.val[3] = vorrq_s8(vshll_n_u16((uint16x4_t)v15.n128_u64[0], 8uLL), vmovl_u16((uint16x4_t)v12.n128_u64[0]));
    v21 = vorrq_s8(vshll_high_n_u16(v15, 8uLL), vmovl_high_u16(v12));
    __asm { SHLL2           V7.4S, V16.8H, #0x10 }
    v168.val[1] = vorrq_s8(v168.val[2], vmovl_u16((uint16x4_t)v13.n128_u64[0]));
    __asm { SHLL2           V5.4S, V21.8H, #0x10 }
    v168.val[2] = vorrq_s8(v21, _Q7);
    a11 = vshlq_n_s32(vmovl_u16((uint16x4_t)v18.n128_u64[0]), 0x18uLL);
    a3[2] = vorrq_s8(vorrq_s8(v168.val[3], vshll_n_s16((int16x4_t)_Q16.n128_u64[0], 0x10uLL)), a11);
    a3[3] = vorrq_s8(v168.val[2], vshlq_n_s32(vmovl_high_u16(v18), 0x18uLL));
    *a3 = vorrq_s8(
            vorrq_s8(v168.val[1], vshll_n_s16((int16x4_t)_Q21.n128_u64[0], 0x10uLL)),
            vshlq_n_s32(vmovl_u16((uint16x4_t)v168.val[0].n128_u64[0]), 0x18uLL));
    a3[1] = vorrq_s8(vorrq_s8(vorrq_s8(v20, v19), _Q5), vshlq_n_s32(vmovl_high_u16(v168.val[0]), 0x18uLL));
  }
  else
  {
    for ( i = 0LL; i != 16; ++i )
      a3->n128_u32[i] = bswap32(*(_DWORD *)&a2[i * 4]);
  }
  v28 = *(_OWORD *)(result + 16);
  v29 = 0LL;
  *(_OWORD *)a4 = *(_OWORD *)result;
  *((_OWORD *)a4 + 1) = v28;
  while ( 1 )
  {
    v31 = a4[4];
    v30 = a4[5];
    v32 = a4[6];
    v33 = &a3[v29];
    HIDWORD(v34) = v31;
    LODWORD(v34) = v31;
    v35 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 4);
    v36 = (v34 >> 6) ^ __ROR4__(v31, 11);
    v38 = *a4;
    v37 = a4[1];
    v39 = __PAIR64__(*a4, __ROR4__(v31, 25));
    v40 = a3[v29].n128_u32[0] + (v36 ^ v39) + *(_DWORD *)((char *)&unk_1735A60 + v29 * 16) + (v30 & v31 | v32 & ~v31);
    LODWORD(v39) = *a4;
    v41 = a4[2];
    v42 = v40 + a4[7];
    v43 = v42 + a4[3];
    v44 = ((v39 >> 2) ^ __ROR4__(*a4, 13) ^ __ROR4__(*a4, 22)) + v42 + ((v41 | v37) & *a4 | v41 & v37);
    HIDWORD(v39) = v43;
    LODWORD(v39) = v43;
    a4[3] = v43;
    a4[7] = v44;
    v45 = (v39 >> 6) ^ __ROR4__(v43, 11);
    v46 = __PAIR64__(v44, __ROR4__(v43, 25));
    v47 = (v31 & v43 | v30 & ~v43) + v32 + (v45 ^ v46);
    LODWORD(v46) = v44;
    v48 = v47 + a3[v29].n128_u32[1] + v35;
    v49 = v48 + v41;
    v50 = (v46 >> 2) ^ __ROR4__(v44, 13);
    v51 = __PAIR64__(v48 + v41, __ROR4__(v44, 22));
    a4[2] = v48 + v41;
    v52 = (v44 & (v37 | v38) | v37 & v38) + v48 + (v50 ^ v51);
    LODWORD(v51) = v49;
    v53 = v51 >> 6;
    a4[6] = v52;
    HIDWORD(v51) = v52;
    LODWORD(v51) = v52;
    v54 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 12);
    v55 = a3[v29].n128_u32[2]
        + v30
        + *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 8)
        + (v43 & v49 | v31 & ~v49)
        + (v53 ^ __ROR4__(v49, 11) ^ __ROR4__(v49, 25));
    v56 = v55 + v37;
    v57 = ((v51 >> 2) ^ __ROR4__(v52, 13) ^ __ROR4__(v52, 22)) + (v52 & (v44 | v38) | v44 & v38) + v55;
    a4[1] = v56;
    HIDWORD(v51) = v56;
    LODWORD(v51) = v56;
    a4[5] = v57;
    v58 = (v51 >> 6) ^ __ROR4__(v56, 11);
    v60 = __PAIR64__(v57, __ROR4__(v56, 25));
    v59 = v58 ^ v60;
    LODWORD(v60) = v57;
    v61 = a3[v29].n128_u32[3] + v31 + v54 + (v49 & v56 | v43 & ~v56) + v59;
    v62 = v61 + v38;
    v63 = ((v60 >> 2) ^ __ROR4__(v57, 13) ^ __ROR4__(v57, 22)) + (v57 & (v52 | v44) | v52 & v44) + v61;
    *a4 = v62;
    HIDWORD(v60) = v62;
    LODWORD(v60) = v62;
    v64 = v60 >> 6;
    a4[4] = v63;
    HIDWORD(v60) = v63;
    LODWORD(v60) = v63;
    v65 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 20);
    v66 = a3[v29 + 1].n128_u32[0]
        + v43
        + *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 16)
        + (v56 & v62 | v49 & ~v62)
        + (v64 ^ __ROR4__(v62, 11) ^ __ROR4__(v62, 25));
    v67 = v66 + v44;
    v68 = ((v60 >> 2) ^ __ROR4__(v63, 13) ^ __ROR4__(v63, 22)) + (v63 & (v57 | v52) | v57 & v52) + v66;
    a4[7] = v67;
    HIDWORD(v60) = v67;
    LODWORD(v60) = v67;
    a4[3] = v68;
    v69 = (v60 >> 6) ^ __ROR4__(v67, 11);
    v71 = __PAIR64__(v68, __ROR4__(v67, 25));
    v70 = v69 ^ v71;
    LODWORD(v71) = v68;
    v72 = a3[v29 + 1].n128_u32[1] + v49 + v65 + (v62 & v67 | v56 & ~v67) + v70;
    v73 = v72 + v52;
    v74 = ((v71 >> 2) ^ __ROR4__(v68, 13) ^ __ROR4__(v68, 22)) + (v68 & (v63 | v57) | v63 & v57) + v72;
    a4[6] = v73;
    HIDWORD(v71) = v73;
    LODWORD(v71) = v73;
    a4[2] = v74;
    v75 = (v71 >> 6) ^ __ROR4__(v73, 11);
    v76 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 28);
    v78 = __PAIR64__(v74, __ROR4__(v73, 25));
    v77 = v75 ^ v78;
    LODWORD(v78) = v74;
    v79 = a3[v29 + 1].n128_u32[2]
        + v56
        + *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 24)
        + (v67 & v73 | v62 & ~v73)
        + v77;
    v80 = v79 + v57;
    v81 = ((v78 >> 2) ^ __ROR4__(v74, 13) ^ __ROR4__(v74, 22)) + (v74 & (v68 | v63) | v68 & v63) + v79;
    a4[5] = v80;
    HIDWORD(v78) = v80;
    LODWORD(v78) = v80;
    a4[1] = v81;
    v82 = (v78 >> 6) ^ __ROR4__(v80, 11);
    v84 = __PAIR64__(v81, __ROR4__(v80, 25));
    v83 = v82 ^ v84;
    LODWORD(v84) = v81;
    v85 = a3[v29 + 1].n128_u32[3] + v62 + v76 + (v73 & v80 | v67 & ~v80) + v83;
    v86 = v85 + v63;
    v87 = ((v84 >> 2) ^ __ROR4__(v81, 13) ^ __ROR4__(v81, 22)) + (v81 & (v74 | v68) | v74 & v68) + v85;
    a4[4] = v86;
    HIDWORD(v84) = v86;
    LODWORD(v84) = v86;
    v88 = v84 >> 6;
    *a4 = v87;
    HIDWORD(v84) = v87;
    LODWORD(v84) = v87;
    v89 = a3[v29 + 2].n128_u32[0] + v67;
    v90 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 36);
    v91 = v89
        + *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 32)
        + (v80 & v86 | v73 & ~v86)
        + (v88 ^ __ROR4__(v86, 11) ^ __ROR4__(v86, 25));
    v92 = v91 + v68;
    v93 = ((v84 >> 2) ^ __ROR4__(v87, 13) ^ __ROR4__(v87, 22)) + (v87 & (v81 | v74) | v81 & v74) + v91;
    a4[3] = v92;
    HIDWORD(v84) = v92;
    LODWORD(v84) = v92;
    a4[7] = v93;
    v94 = (v84 >> 6) ^ __ROR4__(v92, 11);
    v96 = __PAIR64__(v93, __ROR4__(v92, 25));
    v95 = v94 ^ v96;
    LODWORD(v96) = v93;
    v97 = a3[v29 + 2].n128_u32[1] + v73 + v90 + (v86 & v92 | v80 & ~v92) + v95;
    v98 = v97 + v74;
    v99 = ((v96 >> 2) ^ __ROR4__(v93, 13) ^ __ROR4__(v93, 22)) + (v93 & (v87 | v81) | v87 & v81) + v97;
    a4[2] = v98;
    HIDWORD(v96) = v98;
    LODWORD(v96) = v98;
    v100 = v96 >> 6;
    a4[6] = v99;
    HIDWORD(v96) = v99;
    LODWORD(v96) = v99;
    v101 = v80 + a3[v29 + 2].n128_u32[2];
    v102 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 44);
    v103 = v101
         + *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 40)
         + (v92 & v98 | v86 & ~v98)
         + (v100 ^ __ROR4__(v98, 11) ^ __ROR4__(v98, 25));
    v104 = v103 + v81;
    v105 = ((v96 >> 2) ^ __ROR4__(v99, 13) ^ __ROR4__(v99, 22)) + (v99 & (v93 | v87) | v93 & v87) + v103;
    a4[1] = v104;
    HIDWORD(v96) = v104;
    LODWORD(v96) = v104;
    a4[5] = v105;
    v106 = (v96 >> 6) ^ __ROR4__(v104, 11);
    v108 = __PAIR64__(v105, __ROR4__(v104, 25));
    v107 = v106 ^ v108;
    LODWORD(v108) = v105;
    v109 = v102 + a3[v29 + 2].n128_u32[3] + v86 + (v98 & v104 | v92 & ~v104) + v107;
    v110 = v109 + v87;
    v111 = ((v108 >> 2) ^ __ROR4__(v105, 13) ^ __ROR4__(v105, 22)) + (v105 & (v99 | v93) | v99 & v93) + v109;
    *a4 = v110;
    v112 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 48);
    v113 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 52);
    a4[4] = v111;
    HIDWORD(v108) = v110;
    LODWORD(v108) = v110;
    v114 = (v108 >> 6) ^ __ROR4__(v110, 11);
    v116 = __PAIR64__(v111, __ROR4__(v110, 25));
    v115 = v114 ^ v116;
    LODWORD(v116) = v111;
    v117 = v112 + a3[v29 + 3].n128_u32[0] + v92 + (v104 & v110 | v98 & ~v110) + v115;
    v118 = v117 + v93;
    v119 = ((v116 >> 2) ^ __ROR4__(v111, 13) ^ __ROR4__(v111, 22)) + (v111 & (v105 | v99) | v105 & v99) + v117;
    a4[7] = v118;
    HIDWORD(v116) = v118;
    LODWORD(v116) = v118;
    a4[3] = v119;
    v120 = (v116 >> 6) ^ __ROR4__(v118, 11);
    v122 = __PAIR64__(v119, __ROR4__(v118, 25));
    v121 = v120 ^ v122;
    LODWORD(v122) = v119;
    v123 = v113 + a3[v29 + 3].n128_u32[1] + v98 + (v110 & v118 | v104 & ~v118) + v121;
    v124 = v123 + v99;
    v125 = ((v122 >> 2) ^ __ROR4__(v119, 13) ^ __ROR4__(v119, 22)) + (v119 & (v111 | v105) | v111 & v105) + v123;
    a4[6] = v124;
    HIDWORD(v122) = v124;
    LODWORD(v122) = v124;
    v126 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 56);
    v127 = *(_DWORD *)((char *)&unk_1735A60 + v29 * 16 + 60);
    a4[2] = v125;
    v128 = (v122 >> 6) ^ __ROR4__(v124, 11);
    v130 = __PAIR64__(v125, __ROR4__(v124, 25));
    v129 = v128 ^ v130;
    LODWORD(v130) = v125;
    v131 = v126 + a3[v29 + 3].n128_u32[2] + v104 + (v118 & v124 | v110 & ~v124) + v129;
    v132 = v131 + v105;
    v133 = ((v130 >> 2) ^ __ROR4__(v125, 13) ^ __ROR4__(v125, 22)) + (v125 & (v119 | v111) | v119 & v111) + v131;
    a4[5] = v132;
    HIDWORD(v130) = v132;
    LODWORD(v130) = v132;
    v134 = v130 >> 6;
    a4[1] = v133;
    HIDWORD(v130) = v133;
    LODWORD(v130) = v133;
    v135 = v127
         + a3[v29 + 3].n128_u32[3]
         + v110
         + (v124 & v132 | v118 & ~v132)
         + (v134 ^ __ROR4__(v132, 11) ^ __ROR4__(v132, 25));
    v136 = v135 + v111;
    v137 = ((v130 >> 2) ^ __ROR4__(v133, 13) ^ __ROR4__(v133, 22)) + (v133 & (v125 | v119) | v125 & v119) + v135;
    a4[4] = v136;
    *a4 = v137;
    if ( v29 == 12 )
      break;
    v138.n64_u64[0] = *(unsigned __int64 *)&v33[3].n128_u8[4];
    v29 += 4LL;
    v139.n64_u64[0] = *(unsigned __int64 *)&v33->n128_u8[4];
    v140 = v33[3].n128_u32[3];
    v141.n64_u32[0] = v33->n128_u32[0];
    HIDWORD(v143) = v140;
    LODWORD(v143) = v140;
    v142 = v143 >> 17;
    v144.n64_u64[0] = *(unsigned __int64 *)((char *)&v33->n128_f64[1] + 4);
    HIDWORD(v143) = v138.n64_u32[1];
    LODWORD(v143) = v138.n64_u32[1];
    v145.n64_u64[0] = *(unsigned __int64 *)&v33[2].n128_u8[4];
    a11.n128_u32[0] = (v143 >> 17) ^ __ROR4__(v138.n64_u32[1], 19) ^ (v138.n64_u32[1] >> 10);
    HIDWORD(v143) = v140;
    LODWORD(v143) = v140;
    v141.n64_u32[1] = v142 ^ __ROR4__(v140, 19) ^ (v140 >> 10);
    v146 = (v143 >> 7) ^ __ROR4__(v140, 18) ^ (v140 >> 3);
    v147.n64_u64[0] = vadd_s32(
                        vadd_s32(vadd_s32(vzip1_s32((int32x2_t)a11.n128_u64[0], v139), v145), v141),
                        veor_s8(
                          veor_s8(
                            vorr_s8(vshl_n_s32(v139, 0x19uLL), vshr_n_u32(v139, 7uLL)),
                            vorr_s8(vshl_n_s32(v139, 0xEuLL), vshr_n_u32(v139, 0x12uLL))),
                          vshr_n_u32(v139, 3uLL))).n64_u64[0];
    v33[4].n128_u64[0] = v147.n64_u64[0];
    HIDWORD(v143) = v147.n64_u32[0];
    LODWORD(v143) = v147.n64_u32[0];
    v148.n64_u64[0] = *(unsigned __int64 *)((char *)&v33[2].n128_f64[1] + 4);
    v149.n64_u64[0] = *(unsigned __int64 *)&v33[1].n128_u8[4];
    v150.n64_u64[0] = vadd_s32(
                        vadd_s32(
                          vadd_s32(
                            veor_s8(
                              veor_s8(
                                vorr_s8(vshl_n_s32(v147, 0xFuLL), vshr_n_u32(v147, 0x11uLL)),
                                vorr_s8(vshl_n_s32(v147, 0xDuLL), vshr_n_u32(v147, 0x13uLL))),
                              vshr_n_u32(v147, 0xAuLL)),
                            v148),
                          vext_s8(v139, v144, 4uLL)),
                        veor_s8(
                          veor_s8(
                            vorr_s8(vshl_n_s32(v144, 0x19uLL), vshr_n_u32(v144, 7uLL)),
                            vorr_s8(vshl_n_s32(v144, 0xEuLL), vshr_n_u32(v144, 0x12uLL))),
                          vshr_n_u32(v144, 3uLL))).n64_u64[0];
    *(int8x8_t *)&v33[4].n128_i8[8] = v150;
    v151.n64_u64[0] = *(unsigned __int64 *)((char *)&v33[1].n128_f64[1] + 4);
    v152.n64_u64[0] = vadd_s32(
                        vadd_s32(
                          vadd_s32(
                            veor_s8(
                              veor_s8(
                                vorr_s8(vshl_n_s32(v150, 0xFuLL), vshr_n_u32(v150, 0x11uLL)),
                                vorr_s8(vshl_n_s32(v150, 0xDuLL), vshr_n_u32(v150, 0x13uLL))),
                              vshr_n_u32(v150, 0xAuLL)),
                            v138),
                          vext_s8(v144, v149, 4uLL)),
                        veor_s8(
                          veor_s8(
                            vorr_s8(vshl_n_s32(v149, 0x19uLL), vshr_n_u32(v149, 7uLL)),
                            vorr_s8(vshl_n_s32(v149, 0xEuLL), vshr_n_u32(v149, 0x12uLL))),
                          vshr_n_u32(v149, 3uLL))).n64_u64[0];
    v33[5].n128_u64[0] = v152.n64_u64[0];
    v153.n64_u64[0] = vorr_s8(vshl_n_s32(v152, 0xDuLL), vshr_n_u32(v152, 0x13uLL)).n64_u64[0];
    v154.n64_u64[0] = veor_s8(vorr_s8(vshl_n_s32(v152, 0xFuLL), vshr_n_u32(v152, 0x11uLL)), v153).n64_u64[0];
    v153.n64_u32[0] = v140;
    a11.n128_u64[0] = vadd_s32(
                        vadd_s32(
                          vadd_s32(veor_s8(v154, vshr_n_u32(v152, 0xAuLL)), vzip1_s32(v153, v147)),
                          vext_s8(v149, v151, 4uLL)),
                        veor_s8(
                          veor_s8(
                            vorr_s8(vshl_n_s32(v151, 0x19uLL), vshr_n_u32(v151, 7uLL)),
                            vorr_s8(vshl_n_s32(v151, 0xEuLL), vshr_n_u32(v151, 0x12uLL))),
                          vshr_n_u32(v151, 3uLL))).n64_u64[0];
    v33[5].n128_u64[1] = a11.n128_u64[0];
    v155.n64_u64[0] = vadd_s32(
                        vadd_s32(
                          vadd_s32(vext_s8(v151, v145, 4uLL), vext_s8(v147, v150, 4uLL)),
                          veor_s8(
                            veor_s8(
                              vorr_s8(
                                vshl_n_s32((int32x2_t)a11.n128_u64[0], 0xFuLL),
                                vshr_n_u32((uint32x2_t)a11.n128_u64[0], 0x11uLL)),
                              vorr_s8(
                                vshl_n_s32((int32x2_t)a11.n128_u64[0], 0xDuLL),
                                vshr_n_u32((uint32x2_t)a11.n128_u64[0], 0x13uLL))),
                            vshr_n_u32((uint32x2_t)a11.n128_u64[0], 0xAuLL))),
                        veor_s8(
                          veor_s8(
                            vorr_s8(vshl_n_s32(v145, 0x19uLL), vshr_n_u32(v145, 7uLL)),
                            vorr_s8(vshl_n_s32(v145, 0xEuLL), vshr_n_u32(v145, 0x12uLL))),
                          vshr_n_u32(v145, 3uLL))).n64_u64[0];
    v33[6].n128_u64[0] = v155.n64_u64[0];
    v156.n64_u64[0] = vadd_s32(
                        vadd_s32(
                          vadd_s32(vext_s8(v145, v148, 4uLL), vext_s8(v150, v152, 4uLL)),
                          veor_s8(
                            veor_s8(
                              vorr_s8(vshl_n_s32(v155, 0xFuLL), vshr_n_u32(v155, 0x11uLL)),
                              vorr_s8(vshl_n_s32(v155, 0xDuLL), vshr_n_u32(v155, 0x13uLL))),
                            vshr_n_u32(v155, 0xAuLL))),
                        veor_s8(
                          veor_s8(
                            vorr_s8(vshl_n_s32(v148, 0x19uLL), vshr_n_u32(v148, 7uLL)),
                            vorr_s8(vshl_n_s32(v148, 0xEuLL), vshr_n_u32(v148, 0x12uLL))),
                          vshr_n_u32(v148, 3uLL))).n64_u64[0];
    *(int32x2_t *)&v33[6].n128_i8[8] = v156;
    v157 = vadd_s32(
             vadd_s32(
               vadd_s32(vext_s8(v148, v138, 4uLL), vext_s8(v152, (int8x8_t)a11.n128_u64[0], 4uLL)),
               veor_s8(
                 veor_s8(
                   vorr_s8(vshl_n_s32(v156, 0xFuLL), vshr_n_u32(v156, 0x11uLL)),
                   vorr_s8(vshl_n_s32(v156, 0xDuLL), vshr_n_u32(v156, 0x13uLL))),
                 vshr_n_u32(v156, 0xAuLL))),
             veor_s8(
               veor_s8(
                 vorr_s8(vshl_n_s32(v138, 0x19uLL), vshr_n_u32(v138, 7uLL)),
                 vorr_s8(vshl_n_s32(v138, 0xEuLL), vshr_n_u32(v138, 0x12uLL))),
               vshr_n_u32(v138, 3uLL))).n64_u64[0];
    v33[7].n128_u64[0] = v157;
    v33[7].n128_u32[2] = vadd_s32(v138, *(int32x2_t *)&a11).n64_u32[1]
                       + ((__PAIR64__(v157, v157) >> 17) ^ __ROR4__(v157, 19) ^ ((unsigned int)v157 >> 10))
                       + v146;
    v33[7].n128_u32[3] = v155.n64_u32[0]
                       + ((v143 >> 7) ^ __ROR4__(v147.n64_u32[0], 18) ^ (v147.n64_u32[0] >> 3))
                       + v140
                       + ((__PAIR64__(HIDWORD(v157), HIDWORD(v157)) >> 17) ^ __ROR4__(HIDWORD(v157), 19) ^ (HIDWORD(v157) >> 10));
  }
  v158 = *(_DWORD *)(result + 4);
  *(_DWORD *)result += v137;
  v159 = v158 + a4[1];
  v160 = *(_DWORD *)(result + 8);
  v161 = *(_DWORD *)(result + 12);
  *(_DWORD *)(result + 4) = v159;
  *(_DWORD *)(result + 8) = v160 + a4[2];
  v162 = v161 + a4[3];
  v163 = *(_DWORD *)(result + 16);
  v164 = *(_DWORD *)(result + 20);
  *(_DWORD *)(result + 12) = v162;
  *(_DWORD *)(result + 16) = v163 + a4[4];
  v165 = v164 + a4[5];
  v166 = *(_DWORD *)(result + 24);
  v167 = *(_DWORD *)(result + 28);
  *(_DWORD *)(result + 20) = v165;
  *(_DWORD *)(result + 24) = v166 + a4[6];
  *(_DWORD *)(result + 28) = v167 + a4[7];
  return result;
}


================================================================================
Function: sub_6773FE8 (0x6773FE8)
================================================================================

__int64 __fastcall sub_6773FE8(__int64 a1, _DWORD *a2)
{
  unsigned __int64 v4; // x21
  __int64 v5; // x8
  _BYTE v7[256]; // [xsp+8h] [xbp-128h] BYREF
  _BYTE v8[32]; // [xsp+108h] [xbp-28h] BYREF

  v4 = *(_QWORD *)(a1 + 32);
  v5 = ((unsigned int)v4 >> 3) & 0x3F;
  if ( (unsigned int)v5 > 0x37 )
  {
    memcpy((void *)(a1 + 40 + (unsigned int)v5), &unk_1735B60, (unsigned int)(64 - v5));
    sub_677354C(a1, a1 + 40, v7, v8);
    v4 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 88) = 0LL;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
  }
  else
  {
    memcpy((void *)(a1 + v5 + 40), &unk_1735B60, (unsigned int)(56 - v5));
  }
  *(_QWORD *)(a1 + 96) = bswap64(v4);
  sub_677354C(a1, a1 + 40, v7, v8);
  *a2 = bswap32(*(_DWORD *)a1);
  a2[1] = bswap32(*(_DWORD *)(a1 + 4));
  a2[2] = bswap32(*(_DWORD *)(a1 + 8));
  a2[3] = bswap32(*(_DWORD *)(a1 + 12));
  a2[4] = bswap32(*(_DWORD *)(a1 + 16));
  a2[5] = bswap32(*(_DWORD *)(a1 + 20));
  a2[6] = bswap32(*(_DWORD *)(a1 + 24));
  a2[7] = bswap32(*(_DWORD *)(a1 + 28));
  sub_677C544(v7, 288LL);
  sub_677C544(a1, 104LL);
  return 0LL;
}


================================================================================
Function: sub_677415C (0x677415C)
================================================================================

__int64 __fastcall sub_677415C(__int64 a1)
{
  _OWORD v3[2]; // [xsp+0h] [xbp-70h] BYREF
  __int64 v4; // [xsp+20h] [xbp-50h]

  v4 = 0LL;
  v3[0] = xmmword_1735A40;
  v3[1] = unk_1735A50;
  sub_67731EC(v3);
  sub_6773FE8(v3, a1);
  return 0LL;
}


================================================================================
Function: sub_67763F8 (0x67763F8)
================================================================================

_DWORD *__fastcall sub_67763F8(_DWORD *result, unsigned int *a2)
{
  unsigned __int64 v2; // x11
  unsigned __int64 v3; // x13
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x15
  unsigned __int64 v6; // x16
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x12
  __int64 v9; // x3
  unsigned __int64 v10; // x4
  unsigned __int64 v11; // x1
  unsigned __int64 v12; // x13
  unsigned __int64 v13; // x15
  unsigned __int64 v14; // x16
  unsigned __int64 v15; // x4

  v2 = (*((unsigned __int8 *)a2 + 4) << 6) & 0x3FFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 5) << 14) & 0xFFFFFFFFC03FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 6) << 22);
  v3 = (32 * *((unsigned __int8 *)a2 + 7)) & 0x1FFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 8) << 13) & 0xFFFFFFFFE01FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 9) << 21);
  v4 = (8 * *((unsigned __int8 *)a2 + 10)) & 0x7FF | ((unsigned __int64)*((unsigned __int8 *)a2 + 11) << 11) & 0xFFFFFFFFF807FFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 12) << 19);
  v5 = (4 * *((unsigned __int8 *)a2 + 13)) & 0x3FF | ((unsigned __int64)*((unsigned __int8 *)a2 + 14) << 10) & 0xFFFFFFFFFC03FFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 15) << 18);
  v6 = (*((unsigned __int8 *)a2 + 20) << 7) & 0x7FFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 21) << 15) & 0xFFFFFFFF807FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 22) << 23);
  v7 = (32 * *((unsigned __int8 *)a2 + 23)) & 0x1FFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 24) << 13) & 0xFFFFFFFFE01FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 25) << 21);
  v8 = (4 * *((unsigned __int8 *)a2 + 29)) & 0x3FF | ((unsigned __int64)*((unsigned __int8 *)a2 + 30) << 10) | (*((unsigned __int8 *)a2 + 31) << 18) & 0x1FC0000;
  v9 = a2[4];
  v10 = (16 * *((unsigned __int8 *)a2 + 26)) & 0xFFF | ((unsigned __int64)*((unsigned __int8 *)a2 + 27) << 12) & 0xFFFFFFFFF00FFFFFLL | ((unsigned __int64)*((unsigned __int8 *)a2 + 28) << 20);
  v11 = *a2 + 19 * ((v8 + 0x1000000) >> 25);
  v12 = v3 + ((v2 + 0x1000000) >> 25);
  v13 = v5 + ((v4 + 0x1000000) >> 25);
  v14 = v6 + ((unsigned __int64)(v9 + 0x1000000) >> 25);
  v15 = v10 + ((v7 + 0x1000000) >> 25);
  *result = v11 - ((v11 + 0x2000000) & 0xFC000000);
  result[1] = v2 - ((v2 + 0x1000000) & 0x7E000000) + ((v11 + 0x2000000) >> 26);
  result[2] = v12 - ((v12 + 0x2000000) & 0xFC000000);
  result[3] = ((v12 + 0x2000000) >> 26) + v4 - ((v4 + 0x1000000) & 0xE000000);
  result[6] = v14 - ((v14 + 0x2000000) & 0xFC000000);
  result[7] = ((v14 + 0x2000000) >> 26) + v7 - ((v7 + 0x1000000) & 0x3E000000);
  result[4] = v13 - ((v13 + 0x2000000) & 0xFC000000);
  result[5] = v9 + ((v13 + 0x2000000) >> 26) - ((v9 + 0x1000000) & 0xFE000000);
  result[8] = v15 - ((v15 + 0x2000000) & 0xFC000000);
  result[9] = v8 + ((v15 + 0x2000000) >> 26) - ((v8 + 0x1000000) & 0x2000000);
  return result;
}


================================================================================
Function: sub_67765A4 (0x67765A4)
================================================================================

_BYTE *__fastcall sub_67765A4(_BYTE *result, _DWORD *a2)
{
  int v2; // w8
  int v3; // w15
  int v4; // w16
  int v5; // w17
  int v6; // w2
  int v7; // w12
  int v8; // w10
  int v9; // w11
  int v10; // w9
  unsigned int v11; // w13
  unsigned int v12; // w14
  unsigned int v13; // w1
  unsigned int v14; // w15
  unsigned int v15; // w3
  char v16; // w4
  unsigned int v17; // w13
  unsigned int v18; // w5
  int v19; // w6
  unsigned int v20; // w15
  unsigned int v21; // w16
  unsigned int v22; // w1
  int v23; // w7
  unsigned int v24; // w15
  unsigned int v25; // w17
  unsigned int v26; // w4
  unsigned int v27; // w15
  int v28; // w12
  unsigned int v29; // w11
  unsigned int v30; // w10
  unsigned int v31; // w9
  unsigned int v32; // w8

  v2 = a2[9];
  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  v6 = a2[4];
  v7 = a2[5];
  v9 = a2[6];
  v8 = a2[7];
  v10 = a2[8];
  v11 = *a2
      + 19
      * ((v2
        + ((v10
          + ((v8
            + ((v9
              + ((v7
                + ((v6
                  + ((v5 + ((v4 + ((v3 + ((int)(*a2 + ((unsigned int)(19 * v2 + 0x1000000) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25);
  v12 = v11 >> 8;
  v13 = HIWORD(v11);
  v14 = v3 + ((int)v11 >> 26);
  v15 = HIBYTE(v11);
  v16 = v14;
  *result = v11;
  v17 = v14 >> 6;
  v18 = v14 >> 14;
  v19 = (v14 >> 22) & 7;
  v20 = v4 + ((int)v14 >> 25);
  result[1] = v12;
  LOBYTE(v12) = v20;
  result[2] = v13;
  v21 = v20 >> 5;
  v22 = v20 >> 13;
  v23 = (v20 >> 21) & 0x1F;
  v24 = v5 + ((int)v20 >> 26);
  LOBYTE(v15) = v15 & 3 | (4 * v16);
  result[4] = v17;
  LOBYTE(v17) = v24;
  result[5] = v18;
  v25 = v24 >> 3;
  v26 = v24 >> 11;
  LOBYTE(v18) = (v24 >> 19) & 0x3F;
  v27 = v6 + ((int)v24 >> 25);
  result[7] = v21;
  v28 = v7 + ((int)v27 >> 26);
  result[8] = v22;
  v29 = v9 + (v28 >> 25);
  result[10] = v25;
  v30 = v8 + ((int)v29 >> 26);
  result[13] = v27 >> 2;
  result[14] = v27 >> 10;
  result[16] = v28;
  v31 = v10 + ((int)v30 >> 25);
  result[15] = v27 >> 18;
  result[17] = BYTE1(v28);
  v32 = v2 + ((int)v31 >> 26);
  result[18] = BYTE2(v28);
  result[20] = v29 >> 7;
  result[21] = v29 >> 15;
  result[26] = v31 >> 4;
  result[3] = v15;
  result[11] = v26;
  result[6] = v19 & 7 | (8 * v12);
  result[9] = v23 & 0x1F | (32 * v17);
  result[12] = v18 & 0x3F | ((_BYTE)v27 << 6);
  result[23] = v30 >> 5;
  result[24] = v30 >> 13;
  result[19] = HIBYTE(v28) & 1 | (2 * v29);
  result[27] = v31 >> 12;
  result[22] = (v29 >> 23) & 7 | (8 * v30);
  result[29] = v32 >> 2;
  result[30] = v32 >> 10;
  result[25] = (v30 >> 21) & 0xF | (16 * v31);
  result[28] = (v31 >> 20) & 0x3F | ((_BYTE)v32 << 6);
  result[31] = (v32 >> 18) & 0x7F;
  return result;
}


================================================================================
Function: sub_6776754 (0x6776754)
================================================================================

__int64 __fastcall sub_6776754(_DWORD *a1, int *a2)
{
  int v4; // w20
  int v5; // w20
  int v6; // w20
  int v8[10]; // [xsp+8h] [xbp-A8h] BYREF
  int v9[10]; // [xsp+30h] [xbp-80h] BYREF
  int v10[10]; // [xsp+58h] [xbp-58h] BYREF
  int v11[10]; // [xsp+80h] [xbp-30h] BYREF

  sub_6776B48(v11, a2);
  sub_6776B48(v10, v11);
  sub_6776B48(v10, v10);
  sub_6776D8C(v10, a2, v10);
  sub_6776D8C(v11, v11, v10);
  sub_6776B48(v9, v11);
  sub_6776D8C(v10, v10, v9);
  sub_6776B48(v9, v10);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776D8C(v10, v9, v10);
  sub_6776B48(v9, v10);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776D8C(v9, v9, v10);
  sub_6776B48(v8, v9);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776D8C(v9, v8, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776D8C(v10, v9, v10);
  sub_6776B48(v9, v10);
  v4 = 49;
  do
  {
    sub_6776B48(v9, v9);
    --v4;
  }
  while ( v4 );
  sub_6776D8C(v9, v9, v10);
  sub_6776B48(v8, v9);
  v5 = 99;
  do
  {
    sub_6776B48(v8, v8);
    --v5;
  }
  while ( v5 );
  sub_6776D8C(v9, v8, v9);
  sub_6776B48(v9, v9);
  v6 = 49;
  do
  {
    sub_6776B48(v9, v9);
    --v6;
  }
  while ( v6 );
  sub_6776D8C(v10, v9, v10);
  sub_6776B48(v10, v10);
  sub_6776B48(v10, v10);
  sub_6776B48(v10, v10);
  sub_6776B48(v10, v10);
  sub_6776B48(v10, v10);
  return sub_6776D8C(a1, v10, v11);
}


================================================================================
Function: sub_6776B48 (0x6776B48)
================================================================================

_DWORD *__fastcall sub_6776B48(_DWORD *result, int *a2)
{
  __int64 v2; // x3
  __int64 v3; // x11
  __int64 v4; // x5
  __int64 v5; // x9
  __int64 v6; // x2
  __int64 v7; // x14
  __int64 v8; // x13
  __int64 v9; // x20
  __int64 v10; // x11
  __int64 v11; // x12
  __int64 v12; // x16
  __int64 v13; // x22
  __int64 v14; // x4
  __int64 v15; // x1
  __int64 v16; // x15
  __int64 v17; // x6
  __int64 v18; // x24
  __int64 v19; // x26
  __int64 v20; // x27
  __int64 v21; // x19
  __int64 v22; // x7
  __int64 v23; // x23
  __int64 v24; // x25
  __int64 v25; // x21
  __int64 v26; // x20
  __int64 v27; // x5
  __int64 v28; // x22
  __int64 v29; // x9
  __int64 v30; // x24
  __int64 v31; // x7
  __int64 v32; // x21
  __int64 v33; // x25
  __int64 v34; // x20
  __int64 v35; // x9
  __int64 v36; // x2
  __int64 v37; // x14
  __int64 v38; // x9
  __int64 v39; // x13
  unsigned __int64 v40; // x8
  __int64 v41; // x15
  __int64 v42; // x10
  unsigned __int64 v43; // x11

  v3 = *a2;
  v2 = a2[1];
  v4 = a2[5];
  v5 = a2[6];
  v6 = a2[7];
  v7 = a2[8];
  v8 = 2 * v3;
  v9 = v3 * v3;
  v10 = a2[4];
  v11 = a2[9];
  v12 = a2[2];
  v13 = a2[3];
  v14 = 2 * v4;
  v15 = 2 * v13;
  v16 = 19 * v7;
  v17 = 2 * v2 * v2 + v12 * v8 + 19 * v5 * v5 + 38 * v6 * 2 * v4 + 19 * v7 * 2 * v10;
  v18 = 2 * v10 * v4;
  v19 = v9 + 38 * v4 * v4 + 19 * v5 * 2 * v10 + 38 * v6 * 2 * v13;
  v20 = v12 * v12 + 2 * v13 * 2 * v2 + v10 * v8 + 38 * v6 * v6;
  v21 = v8 * v2 + 19 * v5 * 2 * v4 + 38 * v6 * v10;
  v22 = 2 * v2 * v12 + v13 * v8 + 38 * v6 * v5;
  v23 = 2 * v6;
  v24 = v5 * 19 * v7;
  v25 = 2 * v12 * v13 + v10 * 2 * v2 + v4 * v8 + 19 * v7 * 2 * v6 + 38 * v11 * v5;
  v26 = v10 * 2 * v12 + 2 * v13 * v13 + 2 * v4 * 2 * v2 + v5 * v8;
  v27 = 2 * v13 * v10 + v4 * 2 * v12 + v5 * 2 * v2;
  v28 = v10 * v10 + v5 * 2 * v12;
  v29 = v18 + v5 * v15;
  v30 = v20 + 2 * v24 + 38 * v11 * v14;
  v31 = v22 + 19 * v7 * v14;
  v32 = v25 + ((v30 + 0x2000000) >> 26);
  v33 = v19 + 19 * v7 * 2 * v12 + 38 * v11 * 2 * v2;
  v34 = v26 + 19 * v7 * v7 + 38 * v11 * 2 * v6 + ((v32 + 0x1000000) >> 25);
  v35 = v29 + v6 * 2 * v12 + v7 * 2 * v2;
  v36 = v27 + v6 * v8 + 38 * v11 * v7 + ((v34 + 0x2000000) >> 26);
  v37 = v28 + v14 * v15 + v23 * 2 * v2 + v7 * v8 + 38 * v11 * v11 + ((v36 + 0x1000000) >> 25);
  v38 = v35 + v11 * v8 + ((v37 + 0x2000000) >> 26);
  v39 = v21 + v16 * v15 + 38 * v11 * v12 + ((v33 + 0x2000000) >> 26);
  v40 = v33 - ((v33 + 0x2000000) & 0xFFFFFFFFFC000000LL) + 19 * ((v38 + 0x1000000) >> 25);
  v41 = v17 + 38 * v11 * v15 + ((v39 + 0x1000000) >> 25);
  v42 = v31 + 38 * v11 * v10 + ((v41 + 0x2000000) >> 26);
  result[6] = v34 - ((v34 + 0x2000000) & 0xFC000000);
  result[7] = v36 - ((v36 + 0x1000000) & 0xFE000000);
  v43 = v30 - ((v30 + 0x2000000) & 0xFFFFFFFFFC000000LL) + ((v42 + 0x1000000) >> 25);
  result[2] = v41 - ((v41 + 0x2000000) & 0xFC000000);
  result[3] = v42 - ((v42 + 0x1000000) & 0xFE000000);
  *result = v40 - ((v40 + 0x2000000) & 0xFC000000);
  result[1] = v39 - ((v39 + 0x1000000) & 0xFE000000) + ((v40 + 0x2000000) >> 26);
  result[4] = v43 - ((v43 + 0x2000000) & 0xFC000000);
  result[5] = v32 - ((v32 + 0x1000000) & 0xFE000000) + ((v43 + 0x2000000) >> 26);
  result[8] = v37 - ((v37 + 0x2000000) & 0xFC000000);
  result[9] = v38 - ((v38 + 0x1000000) & 0xFE000000);
  return result;
}


================================================================================
Function: sub_6776D8C (0x6776D8C)
================================================================================

__int64 __fastcall sub_6776D8C(_DWORD *a1, int *a2, int *a3)
{
  __int64 v3; // x10
  __int64 v4; // x13
  __int64 v5; // x17
  __int64 v6; // x20
  __int64 v7; // x3
  __int64 v8; // x7
  __int64 v9; // x15
  __int64 v10; // x16
  __int64 v11; // x4
  __int64 v12; // x5
  __int64 result; // x0
  __int64 v14; // x19
  __int64 v15; // x21
  __int64 v16; // x22
  __int64 v17; // x24
  __int64 v18; // x29
  __int64 v19; // x30
  __int64 v20; // x23
  __int64 v21; // x28
  __int64 v22; // x27
  __int64 v23; // x12
  __int64 v24; // x8
  __int64 v25; // x20
  __int64 v26; // x11
  __int64 v27; // x8
  __int64 v28; // x9
  __int64 v29; // x27
  __int64 v30; // x10
  __int64 v31; // x2
  __int64 v32; // x17
  __int64 v33; // x20
  __int64 v34; // x11
  __int64 v35; // x14
  __int64 v36; // x9
  __int64 v37; // x10
  __int64 v38; // x14
  __int64 v39; // x17
  __int64 v40; // x15
  __int64 v41; // x16
  __int64 v42; // x11
  __int64 v43; // x9
  __int64 v44; // x13
  __int64 v45; // x10
  __int64 v46; // x1
  unsigned __int64 v47; // x16
  __int64 v48; // x8
  unsigned __int64 v49; // x14
  __int64 v50; // [xsp+8h] [xbp-A8h]
  __int64 v51; // [xsp+18h] [xbp-98h]
  __int64 v52; // [xsp+20h] [xbp-90h]
  __int64 v53; // [xsp+28h] [xbp-88h]
  __int64 v54; // [xsp+38h] [xbp-78h]
  __int64 v55; // [xsp+40h] [xbp-70h]

  v4 = a2[8];
  v3 = a2[9];
  v6 = *a3;
  v5 = a3[1];
  v7 = *a2;
  v8 = a2[1];
  v10 = a3[2];
  v9 = a3[3];
  v11 = a3[4];
  v12 = a3[5];
  result = a2[2];
  v14 = a2[7];
  v55 = 2 * v3;
  v50 = a2[3];
  v15 = a2[4];
  v16 = a2[5];
  v17 = a2[6];
  v18 = a3[6];
  v19 = a3[7];
  v20 = v6 * v15 + v5 * 2 * v50 + v10 * result + v9 * 2 * v8 + v11 * v7 + 19 * v12 * 2 * v3 + 19 * v18 * v4;
  v21 = v6 * v16 + v5 * v15 + v10 * v50 + v9 * result + v11 * v8 + v12 * v7 + 19 * v18 * v3;
  v53 = v6 * v7
      + 19 * v5 * 2 * v3
      + 19 * v10 * v4
      + 19 * v9 * 2 * v14
      + 19 * v11 * v17
      + 19 * v12 * 2 * v16
      + 19 * v18 * v15;
  v54 = v6 * v8 + v5 * v7 + 19 * v10 * v3 + 19 * v9 * v4 + 19 * v11 * v14 + 19 * v12 * v17 + 19 * v18 * v16;
  v22 = v6 * v17;
  v23 = v6 * v4;
  v51 = v6 * result + v5 * 2 * v8 + v10 * v7 + 19 * v9 * 2 * v3 + 19 * v11 * v4 + 19 * v12 * 2 * v14 + 19 * v18 * v17;
  v52 = v6 * v50 + v5 * result + v10 * v8 + v9 * v7 + 19 * v11 * v3 + 19 * v12 * v4 + 19 * v18 * v14;
  v24 = v6 * v14;
  v25 = v6 * v3;
  v26 = v24 + v5 * v17;
  v28 = a3[8];
  v27 = a3[9];
  v29 = v22 + v5 * 2 * v16;
  v30 = v23 + v5 * 2 * v14;
  v31 = 19 * v28;
  v32 = v25 + v5 * v4;
  v33 = v21 + 19 * v19 * v4 + 19 * v28 * v14;
  v34 = v26 + v10 * v16 + v9 * v15 + v11 * v50;
  v35 = v32 + v10 * v14 + v9 * v17 + v11 * v16 + v12 * v15 + v18 * v50 + v19 * result + v28 * v8;
  v36 = v30 + v10 * v17 + v9 * 2 * v16 + v11 * v15 + v12 * 2 * v50 + v18 * result + v19 * 2 * v8 + v28 * v7;
  v37 = v35 + v27 * v7;
  v27 *= 19LL;
  v38 = v20 + 19 * v19 * 2 * v14 + v31 * v17 + v27 * 2 * v16;
  v39 = v33 + v27 * v17 + ((v38 + 0x2000000) >> 26);
  v40 = v29
      + v10 * v15
      + v9 * 2 * v50
      + v11 * result
      + v12 * 2 * v8
      + v18 * v7
      + 19 * v19 * v55
      + v31 * v4
      + v27 * 2 * v14
      + ((v39 + 0x1000000) >> 25);
  v41 = v53 + 19 * v19 * 2 * v50 + v31 * result + v27 * 2 * v8;
  v42 = v34 + v12 * result + v18 * v8 + v19 * v7 + v31 * a2[9] + v27 * v4 + ((v40 + 0x2000000) >> 26);
  v43 = v36 + v27 * v55 + ((v42 + 0x1000000) >> 25);
  v44 = v54 + 19 * v19 * v15 + v31 * v50 + v27 * result + ((v41 + 0x2000000) >> 26);
  v45 = v37 + ((v43 + 0x2000000) >> 26);
  v46 = v51 + 19 * v19 * 2 * v16 + v31 * v15 + v27 * 2 * v50 + ((v44 + 0x1000000) >> 25);
  v47 = v41 - ((v41 + 0x2000000) & 0xFFFFFFFFFC000000LL) + 19 * ((v45 + 0x1000000) >> 25);
  v48 = v52 + 19 * v19 * v17 + v31 * v16 + v27 * v15 + ((v46 + 0x2000000) >> 26);
  v49 = v38 - ((v38 + 0x2000000) & 0xFFFFFFFFFC000000LL) + ((v48 + 0x1000000) >> 25);
  a1[2] = v46 - ((v46 + 0x2000000) & 0xFC000000);
  a1[3] = v48 - ((v48 + 0x1000000) & 0xFE000000);
  *a1 = v47 - ((v47 + 0x2000000) & 0xFC000000);
  a1[1] = v44 - ((v44 + 0x1000000) & 0xFE000000) + ((v47 + 0x2000000) >> 26);
  a1[6] = v40 - ((v40 + 0x2000000) & 0xFC000000);
  a1[7] = v42 - ((v42 + 0x1000000) & 0xFE000000);
  a1[4] = v49 - ((v49 + 0x2000000) & 0xFC000000);
  a1[5] = v39 - ((v39 + 0x1000000) & 0xFE000000) + ((v49 + 0x2000000) >> 26);
  a1[8] = v43 - ((v43 + 0x2000000) & 0xFC000000);
  a1[9] = v45 - ((v45 + 0x1000000) & 0xFE000000);
  return result;
}


================================================================================
Function: sub_6777124 (0x6777124)
================================================================================

__int64 __fastcall sub_6777124(int *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // x22
  __int64 v5; // x21
  int32x4_t v6; // q1
  unsigned __int64 v7; // d2
  int32x4_t v8; // q3
  int32x4_t v9; // q1
  int32x2_t v10; // d4
  int32x2_t v11; // d5
  int *v12; // x20
  int v13; // w10
  int v14; // w12
  int v15; // w13
  int v16; // w16
  int v17; // w14
  int v18; // w15
  int v19; // w0
  int v20; // w1
  int v21; // w11
  int v22; // w4
  int v23; // w17
  int v24; // w23
  int v25; // w8
  int v26; // w25
  int v27; // w27
  int v28; // w10
  int v29; // w6
  int v30; // w5
  int v31; // w7
  int v32; // w11
  int v33; // w3
  int v34; // w30
  int v35; // w10
  int v36; // w2
  int v37; // w24
  int v38; // w26
  int v39; // w12
  int v40; // w9
  int v41; // w14
  int v42; // w13
  int v43; // w2
  int v44; // w8
  int v45; // w15
  int v46; // w16
  int v47; // w6
  __int64 result; // x0
  int v49; // w5
  int v50; // w7
  int v51; // [xsp+8h] [xbp-8h]
  int v52; // [xsp+Ch] [xbp-4h]

  v4 = a2;
  v5 = a3;
  v6 = vaddq_s32(*(int32x4_t *)(a2 + 16), *(int32x4_t *)(a2 + 56));
  v7 = vadd_s32(*(int32x2_t *)(a2 + 32), *(int32x2_t *)(a2 + 72)).n64_u64[0];
  *(int32x4_t *)a1 = vaddq_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 40));
  *((int32x4_t *)a1 + 1) = v6;
  *((_QWORD *)a1 + 4) = v7;
  v8 = *(int32x4_t *)(a2 + 16);
  v9 = *(int32x4_t *)(a2 + 56);
  v10.n64_u64[0] = *(unsigned __int64 *)(a2 + 72);
  v11.n64_u64[0] = *(unsigned __int64 *)(a2 + 32);
  *(int32x4_t *)(a1 + 10) = vsubq_s32(*(int32x4_t *)(a2 + 40), *(int32x4_t *)a2);
  v12 = a1 + 10;
  *(int32x4_t *)(a1 + 14) = vsubq_s32(v9, v8);
  *((int32x2_t *)a1 + 9) = vsub_s32(v10, v11);
  sub_6776D8C(a1 + 20, a1, a3);
  sub_6776D8C(a1 + 10, a1 + 10, v5 + 40);
  sub_6776D8C(a1 + 30, v5 + 120, v4 + 120);
  sub_6776D8C(a1, v4 + 80, v5 + 80);
  v13 = a1[20];
  v14 = a1[21];
  v15 = a1[22];
  v16 = a1[23];
  v17 = a1[11];
  v18 = a1[12];
  v19 = a1[13];
  v20 = a1[14];
  v21 = *v12;
  v23 = a1[24];
  v22 = a1[25];
  LODWORD(v5) = a1[15];
  v24 = a1[16];
  v52 = *a1;
  v25 = a1[1];
  v26 = a1[2];
  v27 = a1[3];
  *a1 = v13 - *v12;
  a1[1] = v14 - v17;
  v28 = v21 + v13;
  a1[2] = v15 - v18;
  a1[3] = v16 - v19;
  v29 = a1[26];
  v30 = a1[27];
  LODWORD(v4) = a1[28];
  v31 = a1[17];
  v32 = a1[18];
  *v12 = v28;
  v34 = a1[4];
  v33 = a1[5];
  a1[4] = v23 - v20;
  a1[5] = v22 - v5;
  v35 = a1[6];
  LODWORD(v12) = a1[7];
  v36 = a1[19];
  v51 = v25;
  a1[6] = v29 - v24;
  a1[7] = v30 - v31;
  v38 = a1[29];
  v37 = a1[30];
  v39 = v17 + v14;
  v33 *= 2;
  v35 *= 2;
  LODWORD(v12) = 2 * (_DWORD)v12;
  v40 = 2 * a1[9];
  v41 = 2 * a1[8];
  a1[8] = v4 - v32;
  a1[9] = v38 - v36;
  a1[11] = v39;
  a1[12] = v18 + v15;
  a1[13] = v19 + v16;
  a1[14] = v20 + v23;
  v42 = v36 + v38;
  a1[15] = v5 + v22;
  a1[16] = v24 + v29;
  a1[17] = v31 + v30;
  a1[18] = v32 + v4;
  v44 = a1[33];
  v43 = a1[34];
  v45 = a1[31];
  v46 = a1[32];
  v47 = a1[35];
  LODWORD(v5) = a1[36];
  result = (unsigned int)(2 * v26);
  a1[19] = v42;
  a1[20] = v37 + 2 * v52;
  a1[23] = v44 + 2 * v27;
  a1[24] = v43 + 2 * v34;
  LODWORD(v4) = a1[39];
  a1[21] = v45 + 2 * v51;
  a1[22] = v46 + result;
  v49 = a1[37];
  v50 = a1[38];
  a1[25] = v47 + v33;
  a1[26] = v5 + v35;
  a1[29] = v4 + v40;
  a1[30] = 2 * v52 - v37;
  a1[39] = v40 - v4;
  a1[27] = v49 + (_DWORD)v12;
  a1[28] = v50 + v41;
  a1[33] = 2 * v27 - v44;
  a1[34] = 2 * v34 - v43;
  a1[35] = v33 - v47;
  a1[36] = v35 - v5;
  a1[31] = 2 * v51 - v45;
  a1[32] = result - v46;
  a1[37] = (_DWORD)v12 - v49;
  a1[38] = v41 - v50;
  return result;
}


================================================================================
Function: sub_677738C (0x677738C)
================================================================================

__int64 __fastcall sub_677738C(_DWORD *a1, int *a2)
{
  int v4; // w22
  int v5; // w22
  int v6; // w22
  int v8[10]; // [xsp+0h] [xbp-80h] BYREF
  int v9[10]; // [xsp+28h] [xbp-58h] BYREF
  int v10[10]; // [xsp+50h] [xbp-30h] BYREF

  sub_6776B48(v10, a2);
  sub_6776B48(v9, v10);
  sub_6776B48(v9, v9);
  sub_6776D8C(v9, a2, v9);
  sub_6776D8C(v10, v10, v9);
  sub_6776B48(v10, v10);
  sub_6776D8C(v10, v9, v10);
  sub_6776B48(v9, v10);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776D8C(v10, v9, v10);
  sub_6776B48(v9, v10);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776D8C(v9, v9, v10);
  sub_6776B48(v8, v9);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776B48(v8, v8);
  sub_6776D8C(v9, v8, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776B48(v9, v9);
  sub_6776D8C(v10, v9, v10);
  sub_6776B48(v9, v10);
  v4 = 49;
  do
  {
    sub_6776B48(v9, v9);
    --v4;
  }
  while ( v4 );
  sub_6776D8C(v9, v9, v10);
  sub_6776B48(v8, v9);
  v5 = 99;
  do
  {
    sub_6776B48(v8, v8);
    --v5;
  }
  while ( v5 );
  sub_6776D8C(v9, v8, v9);
  sub_6776B48(v9, v9);
  v6 = 49;
  do
  {
    sub_6776B48(v9, v9);
    --v6;
  }
  while ( v6 );
  sub_6776D8C(v10, v9, v10);
  sub_6776B48(v10, v10);
  sub_6776B48(v10, v10);
  return sub_6776D8C(a1, v10, a2);
}


================================================================================
Function: sub_677775C (0x677775C)
================================================================================

__int64 __fastcall sub_677775C(__int64 a1, __int64 a2)
{
  __int64 v2; // x20
  int32x4_t v5; // q0
  int32x4_t v6; // q1
  int32x2_t v7; // d4
  int32x2_t v8; // d8
  int32x4_t v9; // q0
  int32x2_t v10; // d9
  int32x4_t v11; // q1
  unsigned __int64 v12; // d2
  int32x4_t v14; // [xsp+0h] [xbp-170h]
  int32x4_t v15; // [xsp+10h] [xbp-160h]
  int32x4_t v16; // [xsp+20h] [xbp-150h]
  int32x4_t v17; // [xsp+20h] [xbp-150h]
  _OWORD v18[2]; // [xsp+30h] [xbp-140h] BYREF
  unsigned __int64 v19; // [xsp+50h] [xbp-120h]
  _OWORD v20[2]; // [xsp+60h] [xbp-110h] BYREF
  unsigned __int64 v21; // [xsp+80h] [xbp-F0h]
  int32x4_t v22; // [xsp+90h] [xbp-E0h] BYREF
  int32x4_t v23; // [xsp+A0h] [xbp-D0h]
  int32x2_t v24; // [xsp+B0h] [xbp-C0h]
  _BYTE v25[40]; // [xsp+B8h] [xbp-B8h] BYREF
  int32x4_t v26; // [xsp+E0h] [xbp-90h] BYREF
  int32x4_t v27; // [xsp+F0h] [xbp-80h]
  int32x2_t v28; // [xsp+100h] [xbp-70h]
  int32x4_t v29; // [xsp+110h] [xbp-60h] BYREF
  int32x4_t v30; // [xsp+120h] [xbp-50h]
  int32x2_t v31; // [xsp+130h] [xbp-40h]
  _BYTE v32[32]; // [xsp+138h] [xbp-38h] BYREF

  v2 = a1 + 40;
  sub_67763F8(a1 + 40);
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 80) = 1LL;
  *(_OWORD *)(a1 + 104) = 0u;
  sub_6776B48(&v29, v2);
  sub_6776D8C(&v26, &v29, &unk_1735BA0);
  v5 = *(int32x4_t *)(a1 + 80);
  v6 = *(int32x4_t *)(a1 + 96);
  v7.n64_u64[0] = *(unsigned __int64 *)(a1 + 112);
  v8.n64_u64[0] = vsub_s32(v31, v7).n64_u64[0];
  v15 = vsubq_s32(v30, v6);
  v16 = vsubq_s32(v29, v5);
  v29 = v16;
  v30 = v15;
  v31.n64_u64[0] = v8.n64_u64[0];
  v26 = vaddq_s32(v26, v5);
  v27 = vaddq_s32(v27, v6);
  v28.n64_u64[0] = vadd_s32(v28, v7).n64_u64[0];
  sub_6776B48(v25, &v26);
  sub_6776D8C(v25, v25, &v26);
  sub_6776B48(a1, v25);
  sub_6776D8C(a1, a1, &v26);
  sub_6776D8C(a1, a1, &v29);
  sub_677738C(a1, a1);
  sub_6776D8C(a1, a1, v25);
  sub_6776D8C(a1, a1, &v29);
  sub_6776B48(&v22, a1);
  sub_6776D8C(&v22, &v22, &v26);
  v14 = v22;
  v9 = v16;
  v17 = v23;
  v10.n64_u64[0] = v24.n64_u64[0];
  v20[0] = vsubq_s32(v22, v9);
  v20[1] = vsubq_s32(v23, v15);
  v21 = vsub_s32(v24, v8).n64_u64[0];
  sub_67765A4(v18, v20);
  if ( !(unsigned int)sub_677C5D0(v18, 32LL) )
  {
    v19 = vadd_s32(v31, v10).n64_u64[0];
    v18[0] = vaddq_s32(v29, v14);
    v18[1] = vaddq_s32(v30, v17);
    sub_67765A4(v32, v18);
    if ( !(unsigned int)sub_677C5D0(v32, 32LL) )
      return 0xFFFFFFFFLL;
    sub_6776D8C(a1, a1, &unk_1735BC8);
  }
  sub_67765A4(v32, a1);
  if ( (v32[0] & 1) == *(unsigned __int8 *)(a2 + 31) >> 7 )
  {
    v11 = vnegq_s32(*(int32x4_t *)(a1 + 16));
    v12 = vneg_s32(*(int32x2_t *)(a1 + 32)).n64_u64[0];
    *(int32x4_t *)a1 = vnegq_s32(*(int32x4_t *)a1);
    *(int32x4_t *)(a1 + 16) = v11;
    *(_QWORD *)(a1 + 32) = v12;
  }
  sub_6776D8C(a1 + 120, a1, v2);
  return 0LL;
}


================================================================================
Function: sub_67779CC (0x67779CC)
================================================================================

__int64 __fastcall sub_67779CC(__int64 a1, __int64 a2)
{
  int32x4_t v2; // q1
  unsigned __int64 v3; // d2
  int32x4_t v4; // q1
  unsigned __int64 v5; // d2
  __int128 v6; // q1
  __int64 v7; // d2

  v2 = vaddq_s32(*(int32x4_t *)(a2 + 16), *(int32x4_t *)(a2 + 56));
  v3 = vadd_s32(*(int32x2_t *)(a2 + 32), *(int32x2_t *)(a2 + 72)).n64_u64[0];
  *(int32x4_t *)a1 = vaddq_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 40));
  *(int32x4_t *)(a1 + 16) = v2;
  *(_QWORD *)(a1 + 32) = v3;
  v4 = vsubq_s32(*(int32x4_t *)(a2 + 56), *(int32x4_t *)(a2 + 16));
  v5 = vsub_s32(*(int32x2_t *)(a2 + 72), *(int32x2_t *)(a2 + 32)).n64_u64[0];
  *(int32x4_t *)(a1 + 40) = vsubq_s32(*(int32x4_t *)(a2 + 40), *(int32x4_t *)a2);
  *(int32x4_t *)(a1 + 56) = v4;
  *(_QWORD *)(a1 + 72) = v5;
  v6 = *(_OWORD *)(a2 + 96);
  v7 = *(_QWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 96) = v6;
  *(_QWORD *)(a1 + 112) = v7;
  return sub_6776D8C((_DWORD *)(a1 + 120), (int *)(a2 + 120), dword_1735BF0);
}


================================================================================
Function: sub_6777A4C (0x6777A4C)
================================================================================

__int64 __fastcall sub_6777A4C(__int64 a1, __int64 a2, int *a3)
{
  int *v4; // x21
  __int64 v5; // x22
  int32x4_t v6; // q1
  unsigned __int64 v7; // d2
  int32x4_t v8; // q3
  int32x4_t v9; // q1
  int32x2_t v10; // d4
  int32x2_t v11; // d5
  int *v12; // x20
  int v13; // w10
  int v14; // w12
  int v15; // w13
  int v16; // w16
  int v17; // w14
  int v18; // w15
  int v19; // w0
  int v20; // w1
  int v21; // w11
  int v22; // w4
  int v23; // w17
  int v24; // w23
  int v25; // w8
  int v26; // w25
  int v27; // w27
  int v28; // w10
  int v29; // w6
  int v30; // w5
  int v31; // w7
  int v32; // w11
  int v33; // w3
  int v34; // w30
  int v35; // w10
  int v36; // w2
  int v37; // w24
  int v38; // w26
  int v39; // w12
  int v40; // w9
  int v41; // w14
  int v42; // w13
  int v43; // w2
  int v44; // w8
  int v45; // w15
  int v46; // w16
  int v47; // w6
  __int64 result; // x0
  int v49; // w5
  int v50; // w7
  int v51; // [xsp+8h] [xbp-8h]
  int v52; // [xsp+Ch] [xbp-4h]

  v4 = a3;
  v5 = a2;
  v6 = vaddq_s32(*(int32x4_t *)(a2 + 16), *(int32x4_t *)(a2 + 56));
  v7 = vadd_s32(*(int32x2_t *)(a2 + 32), *(int32x2_t *)(a2 + 72)).n64_u64[0];
  *(int32x4_t *)a1 = vaddq_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 40));
  *(int32x4_t *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 32) = v7;
  v8 = *(int32x4_t *)(a2 + 16);
  v9 = *(int32x4_t *)(a2 + 56);
  v10.n64_u64[0] = *(unsigned __int64 *)(a2 + 72);
  v11.n64_u64[0] = *(unsigned __int64 *)(a2 + 32);
  *(int32x4_t *)(a1 + 40) = vsubq_s32(*(int32x4_t *)(a2 + 40), *(int32x4_t *)a2);
  v12 = (int *)(a1 + 40);
  *(int32x4_t *)(a1 + 56) = vsubq_s32(v9, v8);
  *(int32x2_t *)(a1 + 72) = vsub_s32(v10, v11);
  sub_6776D8C((_DWORD *)(a1 + 80), (int *)a1, a3 + 10);
  sub_6776D8C((_DWORD *)(a1 + 40), (int *)(a1 + 40), v4);
  sub_6776D8C((_DWORD *)(a1 + 120), v4 + 30, (int *)(v5 + 120));
  sub_6776D8C((_DWORD *)a1, (int *)(v5 + 80), v4 + 20);
  v13 = *(_DWORD *)(a1 + 80);
  v14 = *(_DWORD *)(a1 + 84);
  v15 = *(_DWORD *)(a1 + 88);
  v16 = *(_DWORD *)(a1 + 92);
  v17 = *(_DWORD *)(a1 + 44);
  v18 = *(_DWORD *)(a1 + 48);
  v19 = *(_DWORD *)(a1 + 52);
  v20 = *(_DWORD *)(a1 + 56);
  v21 = *v12;
  v23 = *(_DWORD *)(a1 + 96);
  v22 = *(_DWORD *)(a1 + 100);
  LODWORD(v4) = *(_DWORD *)(a1 + 60);
  v24 = *(_DWORD *)(a1 + 64);
  v52 = *(_DWORD *)a1;
  v25 = *(_DWORD *)(a1 + 4);
  v26 = *(_DWORD *)(a1 + 8);
  v27 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)a1 = v13 - *v12;
  *(_DWORD *)(a1 + 4) = v14 - v17;
  v28 = v21 + v13;
  *(_DWORD *)(a1 + 8) = v15 - v18;
  *(_DWORD *)(a1 + 12) = v16 - v19;
  v29 = *(_DWORD *)(a1 + 104);
  v30 = *(_DWORD *)(a1 + 108);
  LODWORD(v5) = *(_DWORD *)(a1 + 112);
  v31 = *(_DWORD *)(a1 + 68);
  v32 = *(_DWORD *)(a1 + 72);
  *v12 = v28;
  v34 = *(_DWORD *)(a1 + 16);
  v33 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 16) = v23 - v20;
  *(_DWORD *)(a1 + 20) = v22 - (_DWORD)v4;
  v35 = *(_DWORD *)(a1 + 24);
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  v36 = *(_DWORD *)(a1 + 76);
  v51 = v25;
  *(_DWORD *)(a1 + 24) = v29 - v24;
  *(_DWORD *)(a1 + 28) = v30 - v31;
  v38 = *(_DWORD *)(a1 + 116);
  v37 = *(_DWORD *)(a1 + 120);
  v39 = v17 + v14;
  v33 *= 2;
  v35 *= 2;
  LODWORD(v12) = 2 * (_DWORD)v12;
  v40 = 2 * *(_DWORD *)(a1 + 36);
  v41 = 2 * *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = v5 - v32;
  *(_DWORD *)(a1 + 36) = v38 - v36;
  *(_DWORD *)(a1 + 44) = v39;
  *(_DWORD *)(a1 + 48) = v18 + v15;
  *(_DWORD *)(a1 + 52) = v19 + v16;
  *(_DWORD *)(a1 + 56) = v20 + v23;
  v42 = v36 + v38;
  *(_DWORD *)(a1 + 60) = (_DWORD)v4 + v22;
  *(_DWORD *)(a1 + 64) = v24 + v29;
  *(_DWORD *)(a1 + 68) = v31 + v30;
  *(_DWORD *)(a1 + 72) = v32 + v5;
  v44 = *(_DWORD *)(a1 + 132);
  v43 = *(_DWORD *)(a1 + 136);
  v45 = *(_DWORD *)(a1 + 124);
  v46 = *(_DWORD *)(a1 + 128);
  v47 = *(_DWORD *)(a1 + 140);
  LODWORD(v4) = *(_DWORD *)(a1 + 144);
  result = (unsigned int)(2 * v26);
  *(_DWORD *)(a1 + 76) = v42;
  *(_DWORD *)(a1 + 80) = 2 * v52 - v37;
  *(_DWORD *)(a1 + 92) = 2 * v27 - v44;
  *(_DWORD *)(a1 + 96) = 2 * v34 - v43;
  LODWORD(v5) = *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 84) = 2 * v51 - v45;
  *(_DWORD *)(a1 + 88) = result - v46;
  v49 = *(_DWORD *)(a1 + 148);
  v50 = *(_DWORD *)(a1 + 152);
  *(_DWORD *)(a1 + 100) = v33 - v47;
  *(_DWORD *)(a1 + 104) = v35 - (_DWORD)v4;
  *(_DWORD *)(a1 + 116) = v40 - v5;
  *(_DWORD *)(a1 + 120) = v37 + 2 * v52;
  *(_DWORD *)(a1 + 156) = v5 + v40;
  *(_DWORD *)(a1 + 108) = (_DWORD)v12 - v49;
  *(_DWORD *)(a1 + 112) = v41 - v50;
  *(_DWORD *)(a1 + 132) = v44 + 2 * v27;
  *(_DWORD *)(a1 + 136) = v43 + 2 * v34;
  *(_DWORD *)(a1 + 140) = v47 + v33;
  *(_DWORD *)(a1 + 144) = (_DWORD)v4 + v35;
  *(_DWORD *)(a1 + 124) = v45 + 2 * v51;
  *(_DWORD *)(a1 + 128) = v46 + result;
  *(_DWORD *)(a1 + 148) = v49 + (_DWORD)v12;
  *(_DWORD *)(a1 + 152) = v50 + v41;
  return result;
}


================================================================================
Function: sub_6777CB8 (0x6777CB8)
================================================================================

__int64 __fastcall sub_6777CB8(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  _BYTE v5[40]; // [xsp+0h] [xbp-A0h] BYREF
  _BYTE v6[40]; // [xsp+28h] [xbp-78h] BYREF
  _BYTE v7[40]; // [xsp+50h] [xbp-50h] BYREF
  _BYTE v8[32]; // [xsp+78h] [xbp-28h] BYREF

  sub_6776754(v7, a2 + 80);
  sub_6776D8C(v6, a2, v7);
  sub_6776D8C(v5, a2 + 40, v7);
  sub_67765A4(a1, v5);
  result = sub_67765A4(v8, v6);
  *(_BYTE *)(a1 + 31) ^= v8[0] << 7;
  return result;
}


================================================================================
Function: sub_6777D60 (0x6777D60)
================================================================================

__int64 __fastcall sub_6777D60(__int64 a1, __int64 a2, __int128 *a3, __int64 a4)
{
  __int64 v6; // x8
  __int64 v7; // x10
  char v8; // w12
  char v9; // w11
  _BYTE *v10; // x13
  unsigned __int64 v11; // x8
  __int64 v12; // x12
  unsigned __int64 v13; // x13
  unsigned __int64 v14; // x14
  __int64 v15; // x15
  int v16; // w16
  int v17; // w17
  int v18; // w0
  int v19; // w16
  int v20; // w17
  unsigned __int64 v21; // x16
  __int64 v22; // x8
  __int64 v23; // x10
  char v24; // w12
  char v25; // w11
  _BYTE *v26; // x13
  unsigned __int64 v27; // x8
  __int64 v28; // x12
  unsigned __int64 v29; // x13
  unsigned __int64 v30; // x14
  __int64 v31; // x15
  int v32; // w16
  int v33; // w17
  int v34; // w0
  int v35; // w16
  int v36; // w17
  unsigned __int64 v37; // x16
  __int128 v38; // q1
  __int128 v39; // q2
  __int128 v40; // q3
  __int128 v41; // q0
  __int128 v42; // q1
  __int128 v43; // q2
  __int64 result; // x0
  __int64 v45; // x8
  __int64 v46; // x26
  __int64 v47; // x11
  __int64 v48; // x19
  unsigned __int64 v50; // x28
  int v51; // w28
  char *v52; // x28
  int v53; // w24
  int v54; // w24
  int v55; // w8
  __int64 v56; // [xsp+0h] [xbp-920h]
  __int64 v57; // [xsp+20h] [xbp-900h]
  __int64 v58; // [xsp+28h] [xbp-8F8h]
  _BYTE v59[40]; // [xsp+30h] [xbp-8F0h] BYREF
  __int64 v60; // [xsp+58h] [xbp-8C8h] BYREF
  __int64 v61; // [xsp+80h] [xbp-8A0h] BYREF
  __int64 v62; // [xsp+A8h] [xbp-878h] BYREF
  __int128 v63; // [xsp+D0h] [xbp-850h] BYREF
  __int128 v64; // [xsp+E0h] [xbp-840h]
  __int128 v65; // [xsp+F0h] [xbp-830h] BYREF
  __int128 v66; // [xsp+100h] [xbp-820h]
  __int128 v67; // [xsp+110h] [xbp-810h]
  __int128 v68; // [xsp+120h] [xbp-800h] BYREF
  __int128 v69; // [xsp+130h] [xbp-7F0h]
  __int64 v70; // [xsp+140h] [xbp-7E0h]
  _BYTE v71[40]; // [xsp+148h] [xbp-7D8h] BYREF
  int v72; // [xsp+170h] [xbp-7B0h] BYREF
  int v73; // [xsp+174h] [xbp-7ACh]
  int v74; // [xsp+178h] [xbp-7A8h]
  int v75; // [xsp+17Ch] [xbp-7A4h]
  int v76; // [xsp+180h] [xbp-7A0h]
  int v77; // [xsp+184h] [xbp-79Ch]
  int v78; // [xsp+188h] [xbp-798h]
  int v79; // [xsp+18Ch] [xbp-794h]
  int v80; // [xsp+190h] [xbp-790h]
  int v81; // [xsp+194h] [xbp-78Ch]
  int v82; // [xsp+198h] [xbp-788h] BYREF
  int v83; // [xsp+19Ch] [xbp-784h]
  int v84; // [xsp+1A0h] [xbp-780h]
  int v85; // [xsp+1A4h] [xbp-77Ch]
  int v86; // [xsp+1A8h] [xbp-778h]
  int v87; // [xsp+1ACh] [xbp-774h]
  int v88; // [xsp+1B0h] [xbp-770h]
  int v89; // [xsp+1B4h] [xbp-76Ch]
  int v90; // [xsp+1B8h] [xbp-768h]
  int v91; // [xsp+1BCh] [xbp-764h]
  int v92; // [xsp+1C0h] [xbp-760h] BYREF
  int v93; // [xsp+1C4h] [xbp-75Ch]
  int v94; // [xsp+1C8h] [xbp-758h]
  int v95; // [xsp+1CCh] [xbp-754h]
  int v96; // [xsp+1D0h] [xbp-750h]
  int v97; // [xsp+1D4h] [xbp-74Ch]
  int v98; // [xsp+1D8h] [xbp-748h]
  int v99; // [xsp+1DCh] [xbp-744h]
  int v100; // [xsp+1E0h] [xbp-740h]
  int v101; // [xsp+1E4h] [xbp-73Ch]
  int v102; // [xsp+1E8h] [xbp-738h] BYREF
  int v103; // [xsp+1ECh] [xbp-734h]
  int v104; // [xsp+1F0h] [xbp-730h]
  int v105; // [xsp+1F4h] [xbp-72Ch]
  int v106; // [xsp+1F8h] [xbp-728h]
  int v107; // [xsp+1FCh] [xbp-724h]
  int v108; // [xsp+200h] [xbp-720h]
  int v109; // [xsp+204h] [xbp-71Ch]
  int v110; // [xsp+208h] [xbp-718h]
  int v111; // [xsp+20Ch] [xbp-714h]
  _OWORD v112[10]; // [xsp+210h] [xbp-710h] BYREF
  _BYTE v113[160]; // [xsp+2B0h] [xbp-670h] BYREF
  _BYTE v114[160]; // [xsp+350h] [xbp-5D0h] BYREF
  _BYTE v115[160]; // [xsp+3F0h] [xbp-530h] BYREF
  _BYTE v116[160]; // [xsp+490h] [xbp-490h] BYREF
  _BYTE v117[160]; // [xsp+530h] [xbp-3F0h] BYREF
  _BYTE v118[160]; // [xsp+5D0h] [xbp-350h] BYREF
  _BYTE v119[672]; // [xsp+670h] [xbp-2B0h] BYREF

  v6 = 0LL;
  do
  {
    v7 = (unsigned int)v6 >> 3;
    v8 = v6 & 6;
    v9 = v6 & 6 | 1;
    v10 = &v119[v6 + 416];
    v6 += 2LL;
    LODWORD(v7) = *(unsigned __int8 *)(a2 + v7);
    *v10 = ((unsigned int)v7 >> v8) & 1;
    v10[1] = ((unsigned int)v7 >> v9) & 1;
  }
  while ( v6 != 256 );
  v11 = 0LL;
  v12 = 1LL;
  do
  {
    if ( v119[v11 + 416] && v11 <= 0xFE )
    {
      v13 = v11;
      v14 = 1LL;
      v15 = v12;
      do
      {
        v16 = (char)v119[v15 + 416];
        if ( v119[v15 + 416] )
        {
          v17 = (char)v119[v11 + 416];
          v18 = v16 << v14;
          v19 = (v16 << v14) + v17;
          if ( v19 > 15 )
          {
            v20 = v17 - v18;
            if ( v20 < -15 )
              break;
            v21 = v13;
            v119[v11 + 416] = v20;
            while ( v119[v21 + 417] )
            {
              v119[v21++ + 417] = 0;
              if ( v21 >= 0xFF )
                goto LABEL_17;
            }
            v119[v21 + 417] = 1;
          }
          else
          {
            v119[v11 + 416] = v19;
            v119[v15 + 416] = 0;
          }
        }
LABEL_17:
        if ( v14 > 5 )
          break;
        ++v14;
        ++v15;
        ++v13;
      }
      while ( v14 + v11 < 0x100 );
    }
    ++v11;
    ++v12;
  }
  while ( v11 != 256 );
  v22 = 0LL;
  do
  {
    v23 = (unsigned int)v22 >> 3;
    v24 = v22 & 6;
    v25 = v22 & 6 | 1;
    v26 = &v119[v22 + 160];
    v22 += 2LL;
    LODWORD(v23) = *(unsigned __int8 *)(a4 + v23);
    *v26 = ((unsigned int)v23 >> v24) & 1;
    v26[1] = ((unsigned int)v23 >> v25) & 1;
  }
  while ( v22 != 256 );
  v27 = 0LL;
  v28 = 1LL;
  do
  {
    if ( v119[v27 + 160] && v27 <= 0xFE )
    {
      v29 = v27;
      v30 = 1LL;
      v31 = v28;
      do
      {
        v32 = (char)v119[v31 + 160];
        if ( v119[v31 + 160] )
        {
          v33 = (char)v119[v27 + 160];
          v34 = v32 << v30;
          v35 = (v32 << v30) + v33;
          if ( v35 > 15 )
          {
            v36 = v33 - v34;
            if ( v36 < -15 )
              break;
            v37 = v29;
            v119[v27 + 160] = v36;
            while ( v119[v37 + 161] )
            {
              v119[v37++ + 161] = 0;
              if ( v37 >= 0xFF )
                goto LABEL_36;
            }
            v119[v37 + 161] = 1;
          }
          else
          {
            v119[v27 + 160] = v35;
            v119[v31 + 160] = 0;
          }
        }
LABEL_36:
        if ( v30 > 5 )
          break;
        ++v30;
        ++v31;
        ++v29;
      }
      while ( v30 + v27 < 0x100 );
    }
    ++v27;
    ++v28;
  }
  while ( v27 != 256 );
  sub_67779CC(v112, a3);
  v38 = a3[1];
  v39 = a3[2];
  v40 = a3[3];
  v63 = *a3;
  v64 = v38;
  v41 = a3[4];
  v42 = a3[5];
  v65 = v39;
  v66 = v40;
  v43 = a3[6];
  v67 = v41;
  v68 = v42;
  *(_QWORD *)&v40 = *((_QWORD *)a3 + 14);
  v69 = v43;
  v70 = v40;
  sub_67788BC(&v72, &v63);
  sub_6776D8C(v59, &v72, &v102);
  sub_6776D8C(&v60, &v82, &v92);
  sub_6776D8C(&v61, &v92, &v102);
  sub_6776D8C(&v62, &v72, &v82);
  sub_6777124(&v72, v59, v112);
  sub_6776D8C(&v63, &v72, &v102);
  sub_6776D8C((char *)&v65 + 8, &v82, &v92);
  sub_6776D8C(&v68, &v92, &v102);
  sub_6776D8C(v71, &v72, &v82);
  sub_67779CC(v113, &v63);
  sub_6777124(&v72, v59, v113);
  sub_6776D8C(&v63, &v72, &v102);
  sub_6776D8C((char *)&v65 + 8, &v82, &v92);
  sub_6776D8C(&v68, &v92, &v102);
  sub_6776D8C(v71, &v72, &v82);
  sub_67779CC(v114, &v63);
  sub_6777124(&v72, v59, v114);
  sub_6776D8C(&v63, &v72, &v102);
  sub_6776D8C((char *)&v65 + 8, &v82, &v92);
  sub_6776D8C(&v68, &v92, &v102);
  sub_6776D8C(v71, &v72, &v82);
  sub_67779CC(v115, &v63);
  sub_6777124(&v72, v59, v115);
  sub_6776D8C(&v63, &v72, &v102);
  sub_6776D8C((char *)&v65 + 8, &v82, &v92);
  sub_6776D8C(&v68, &v92, &v102);
  sub_6776D8C(v71, &v72, &v82);
  sub_67779CC(v116, &v63);
  sub_6777124(&v72, v59, v116);
  sub_6776D8C(&v63, &v72, &v102);
  sub_6776D8C((char *)&v65 + 8, &v82, &v92);
  sub_6776D8C(&v68, &v92, &v102);
  sub_6776D8C(v71, &v72, &v82);
  sub_67779CC(v117, &v63);
  sub_6777124(&v72, v59, v117);
  sub_6776D8C(&v63, &v72, &v102);
  sub_6776D8C((char *)&v65 + 8, &v82, &v92);
  sub_6776D8C(&v68, &v92, &v102);
  sub_6776D8C(v71, &v72, &v82);
  sub_67779CC(v118, &v63);
  sub_6777124(&v72, v59, v118);
  sub_6776D8C(&v63, &v72, &v102);
  sub_6776D8C((char *)&v65 + 8, &v82, &v92);
  sub_6776D8C(&v68, &v92, &v102);
  sub_6776D8C(v71, &v72, &v82);
  result = sub_67779CC(v119, &v63);
  v45 = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 80) = 1LL;
  v58 = a1 + 80;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 40) = 1LL;
  v46 = a1 + 40;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  while ( 1 )
  {
    v47 = (unsigned int)(v45 + 255);
    if ( v119[v47 + 416] || v119[v47 + 160] )
      break;
    if ( (_DWORD)--v45 == -256 )
      return result;
  }
  if ( (int)v45 + 255 >= 0 )
  {
    v48 = v45 + 255;
    v57 = a1;
    v56 = a1 + 40;
    do
    {
      sub_67788BC(&v72, a1);
      v50 = (unsigned __int8)v119[v48 + 416];
      if ( (char)v119[v48 + 416] < 1 )
      {
        if ( (v50 & 0x80) != 0 )
        {
          sub_6776D8C(&v63, &v72, &v102);
          sub_6776D8C((char *)&v65 + 8, &v82, &v92);
          sub_6776D8C(&v68, &v92, &v102);
          sub_6776D8C(v71, &v72, &v82);
          sub_6777A4C(&v72, &v63, &v112[10 * ((unsigned __int8)-(char)v50 >> 1)]);
        }
      }
      else
      {
        sub_6776D8C(&v63, &v72, &v102);
        sub_6776D8C((char *)&v65 + 8, &v82, &v92);
        sub_6776D8C(&v68, &v92, &v102);
        sub_6776D8C(v71, &v72, &v82);
        sub_6777124(&v72, &v63, &v112[10 * (v50 >> 1)]);
      }
      v51 = (char)v119[v48 + 160];
      if ( v51 >= 1 )
      {
        sub_6776D8C(&v63, &v72, &v102);
        sub_6776D8C((char *)&v65 + 8, &v82, &v92);
        sub_6776D8C(&v68, &v92, &v102);
        sub_6776D8C(v71, &v72, &v82);
        sub_6778AB4(&v72, &v63, (char *)&unk_1735C18 + 120 * ((unsigned __int8)v51 >> 1));
      }
      else if ( v51 < 0 )
      {
        sub_6776D8C(&v63, &v72, &v102);
        sub_6776D8C((char *)&v65 + 8, &v82, &v92);
        sub_6776D8C(&v68, &v92, &v102);
        sub_6776D8C(v71, &v72, &v82);
        v83 = HIDWORD(v65) - DWORD1(v63);
        v72 = v63 + DWORD2(v65);
        v75 = HIDWORD(v63) + DWORD1(v66);
        v85 = DWORD1(v66) - HIDWORD(v63);
        v86 = DWORD2(v66) - v64;
        v73 = DWORD1(v63) + HIDWORD(v65);
        v74 = DWORD2(v63) + v66;
        v76 = v64 + DWORD2(v66);
        v52 = (char *)&unk_1735C18 + 120 * ((unsigned __int8)-(char)v51 >> 1);
        v77 = DWORD1(v64) + HIDWORD(v66);
        v78 = DWORD2(v64) + v67;
        v82 = DWORD2(v65) - v63;
        v84 = v66 - DWORD2(v63);
        v79 = HIDWORD(v64) + DWORD1(v67);
        v80 = v65 + DWORD2(v67);
        v81 = DWORD1(v65) + HIDWORD(v67);
        v87 = HIDWORD(v66) - DWORD1(v64);
        v88 = v67 - DWORD2(v64);
        v89 = DWORD1(v67) - HIDWORD(v64);
        v90 = DWORD2(v67) - v65;
        v91 = HIDWORD(v67) - DWORD1(v65);
        sub_6776D8C(&v92, &v72, v52 + 40);
        sub_6776D8C(&v82, &v82, v52);
        sub_6776D8C(&v102, v52 + 80, v71);
        v72 = v92 - v82;
        v73 = v93 - v83;
        v53 = v96 - v86;
        v74 = v94 - v84;
        v75 = v95 - v85;
        v77 = v97 - v87;
        v83 += v93;
        v84 += v94;
        v85 += v95;
        v86 += v96;
        v79 = v99 - v89;
        v76 = v53;
        v54 = v101 - v91;
        v78 = v98 - v88;
        v80 = v100 - v90;
        v55 = v82 + v92;
        v89 += v99;
        v87 += v97;
        v90 += v100;
        v91 += v101;
        v81 = v54;
        v88 += v98;
        v92 = 2 * v68 - v102;
        v82 = v55;
        v94 = 2 * DWORD2(v68) - v104;
        v93 = 2 * DWORD1(v68) - v103;
        v95 = 2 * HIDWORD(v68) - v105;
        v96 = 2 * v69 - v106;
        v97 = 2 * DWORD1(v69) - v107;
        v102 += 2 * v68;
        v98 = 2 * DWORD2(v69) - v108;
        v99 = 2 * HIDWORD(v69) - v109;
        v104 += 2 * DWORD2(v68);
        v46 = v56;
        v100 = 2 * v70 - v110;
        a1 = v57;
        v106 += 2 * v69;
        v101 = 2 * HIDWORD(v70) - v111;
        v103 += 2 * DWORD1(v68);
        v105 += 2 * HIDWORD(v68);
        v107 += 2 * DWORD1(v69);
        v108 += 2 * DWORD2(v69);
        v109 += 2 * HIDWORD(v69);
        v110 += 2 * v70;
        v111 += 2 * HIDWORD(v70);
      }
      sub_6776D8C(a1, &v72, &v102);
      sub_6776D8C(v46, &v82, &v92);
      result = sub_6776D8C(v58, &v92, &v102);
    }
    while ( v48-- > 0 );
  }
  return result;
}


================================================================================
Function: sub_67788BC (0x67788BC)
================================================================================

__int64 __fastcall sub_67788BC(int *a1, __int64 a2)
{
  __int64 v2; // x20
  int32x4_t v4; // q1
  unsigned __int64 v5; // d2
  int v6; // w15
  int v7; // w16
  int v8; // w0
  int v9; // w17
  int v10; // w1
  int v11; // w2
  int v12; // w3
  int v13; // w5
  int v14; // w11
  int v15; // w12
  int v16; // w13
  int v17; // w14
  int v18; // w7
  int v19; // w22
  int v20; // w23
  int v21; // w9
  int v22; // w15
  int v23; // w16
  int v24; // w0
  int v25; // w17
  int v26; // w1
  int v27; // w2
  int v28; // w3
  int v29; // w5
  int v30; // w4
  int v31; // w17
  int v32; // w11
  int v33; // w5
  int v34; // w4
  int v35; // w22
  int v36; // w10
  int v37; // w13
  int v38; // w8
  int v39; // w3
  int v40; // w6
  int v41; // w7
  int v42; // w4
  int v43; // w17
  int v44; // w23
  int v45; // w24
  int v46; // w0
  int v47; // w3
  int v48; // w12
  int v49; // w14
  int v50; // w8
  int v51; // w13
  int v52; // w14
  int v53; // w3
  int v54; // w5
  __int64 result; // x0
  int v56; // w17
  int v57; // w9
  int v58; // w10
  int v59; // w9
  int v60; // w10
  int v61; // w11
  int v62; // w12
  int v63; // w9
  int v64; // w10
  int v65; // w11
  int v66; // w12
  int v67; // w9
  int v68; // w10
  _DWORD v69[10]; // [xsp+0h] [xbp-30h] BYREF

  v2 = a2;
  sub_6776B48(a1, a2);
  sub_6776B48(a1 + 20, v2 + 40);
  sub_677A0AC(a1 + 30, v2 + 80);
  v4 = vaddq_s32(*(int32x4_t *)(v2 + 56), *(int32x4_t *)(v2 + 16));
  v5 = vadd_s32(*(int32x2_t *)(v2 + 72), *(int32x2_t *)(v2 + 32)).n64_u64[0];
  *(int32x4_t *)(a1 + 10) = vaddq_s32(*(int32x4_t *)(v2 + 40), *(int32x4_t *)v2);
  *(int32x4_t *)(a1 + 14) = v4;
  *((_QWORD *)a1 + 9) = v5;
  sub_6776B48(v69, a1 + 10);
  v6 = a1[22];
  v7 = a1[23];
  v9 = a1[2];
  v8 = a1[3];
  v10 = a1[24];
  v11 = a1[25];
  v12 = a1[4];
  v13 = a1[5];
  v14 = a1[20];
  v15 = a1[21];
  v16 = *a1;
  v17 = a1[1];
  v18 = v9 + v6;
  v19 = v8 + v7;
  v20 = v12 + v10;
  v21 = v13 + v11;
  v22 = v6 - v9;
  v23 = v7 - v8;
  v25 = v69[0];
  v24 = v69[1];
  v26 = v10 - v12;
  v27 = v11 - v13;
  v28 = v69[2];
  v29 = v69[3];
  v30 = *a1 + v14;
  a1[13] = v19;
  a1[14] = v20;
  v31 = v25 - v30;
  v32 = v14 - v16;
  a1[10] = v30;
  v33 = v29 - v19;
  v34 = v69[4];
  v35 = v69[5];
  v36 = a1[26];
  v37 = a1[27];
  v38 = a1[6];
  LODWORD(v2) = a1[7];
  a1[11] = v17 + v15;
  a1[12] = v18;
  v39 = v28 - v18;
  v40 = a1[28];
  v41 = a1[29];
  v42 = v34 - v20;
  *a1 = v31;
  a1[1] = v24 - (v17 + v15);
  v44 = a1[8];
  v43 = a1[9];
  v45 = v38 + v36;
  a1[2] = v39;
  a1[3] = v33;
  v46 = v69[6];
  v47 = v69[7];
  v48 = v15 - v17;
  v49 = v2 + v37;
  a1[15] = v21;
  a1[16] = v38 + v36;
  v50 = v36 - v38;
  a1[21] = v48;
  a1[22] = v22;
  v51 = v37 - v2;
  a1[4] = v42;
  a1[5] = v35 - v21;
  a1[17] = v49;
  a1[18] = v44 + v40;
  v52 = v47 - v49;
  v54 = v69[8];
  v53 = v69[9];
  a1[25] = v27;
  a1[26] = v50;
  a1[6] = v46 - v45;
  a1[7] = v52;
  result = (unsigned int)(v43 + v41);
  v56 = v41 - v43;
  a1[19] = result;
  a1[20] = v32;
  a1[23] = v23;
  a1[24] = v26;
  a1[8] = v54 - (v44 + v40);
  a1[9] = v53 - result;
  v57 = a1[30];
  v58 = a1[31];
  a1[27] = v51;
  a1[28] = v40 - v44;
  a1[29] = v56;
  v59 = v57 - v32;
  v60 = v58 - v48;
  v61 = a1[32];
  v62 = a1[33];
  a1[30] = v59;
  a1[31] = v60;
  v63 = a1[34] - v26;
  v64 = a1[35] - v27;
  a1[32] = v61 - v22;
  a1[33] = v62 - v23;
  v65 = a1[36];
  v66 = a1[37];
  a1[34] = v63;
  a1[35] = v64;
  v67 = a1[38] - (v40 - v44);
  v68 = a1[39] - v56;
  a1[36] = v65 - v50;
  a1[37] = v66 - v51;
  a1[38] = v67;
  a1[39] = v68;
  return result;
}


================================================================================
Function: sub_6778AB4 (0x6778AB4)
================================================================================

__int64 __fastcall sub_6778AB4(__int64 a1, __int64 a2, int *a3)
{
  _DWORD *v4; // x21
  int *v5; // x22
  int32x4_t v6; // q1
  unsigned __int64 v7; // d2
  int32x4_t v8; // q3
  int32x4_t v9; // q1
  int32x2_t v10; // d4
  int32x2_t v11; // d5
  _DWORD *v12; // x20
  int v13; // w5
  int v14; // w6
  int v15; // w13
  int v16; // w14
  int v17; // w17
  int v18; // w8
  int v19; // w12
  int v20; // w15
  int v21; // w16
  int v22; // w0
  int v23; // w1
  int v24; // w2
  int v25; // w3
  int v26; // w7
  int v27; // w4
  int v28; // w5
  int v29; // w24
  int v30; // w26
  int v31; // w30
  int v32; // w4
  int v33; // w28
  int v34; // w23
  int v35; // w25
  int v36; // w9
  int v37; // w27
  int v38; // w11
  int v39; // w8
  int v40; // w10
  int v41; // w1
  int v42; // w2
  int v43; // w4
  int v44; // w8
  int v45; // w6
  int v46; // w23
  __int64 result; // x0
  int v48; // [xsp+0h] [xbp-10h]
  int v49; // [xsp+4h] [xbp-Ch]
  int v50; // [xsp+8h] [xbp-8h]
  int v51; // [xsp+Ch] [xbp-4h]

  v4 = (_DWORD *)a2;
  v5 = a3;
  v6 = vaddq_s32(*(int32x4_t *)(a2 + 16), *(int32x4_t *)(a2 + 56));
  v7 = vadd_s32(*(int32x2_t *)(a2 + 32), *(int32x2_t *)(a2 + 72)).n64_u64[0];
  *(int32x4_t *)a1 = vaddq_s32(*(int32x4_t *)a2, *(int32x4_t *)(a2 + 40));
  *(int32x4_t *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 32) = v7;
  v8 = *(int32x4_t *)(a2 + 16);
  v9 = *(int32x4_t *)(a2 + 56);
  v10.n64_u64[0] = *(unsigned __int64 *)(a2 + 72);
  v11.n64_u64[0] = *(unsigned __int64 *)(a2 + 32);
  *(int32x4_t *)(a1 + 40) = vsubq_s32(*(int32x4_t *)(a2 + 40), *(int32x4_t *)a2);
  v12 = (_DWORD *)(a1 + 40);
  *(int32x4_t *)(a1 + 56) = vsubq_s32(v9, v8);
  *(int32x2_t *)(a1 + 72) = vsub_s32(v10, v11);
  sub_6776D8C((_DWORD *)(a1 + 80), (int *)a1, a3);
  sub_6776D8C((_DWORD *)(a1 + 40), (int *)(a1 + 40), v5 + 10);
  sub_6776D8C((_DWORD *)(a1 + 120), v5 + 20, v4 + 30);
  v14 = *(_DWORD *)(a1 + 76);
  v13 = *(_DWORD *)(a1 + 80);
  v51 = v4[20];
  v15 = v4[25];
  v16 = v4[26];
  v49 = v4[22];
  v50 = v4[21];
  v17 = v4[29];
  v18 = v4[23];
  v19 = v4[24];
  v20 = v4[27];
  v21 = v4[28];
  v22 = *(_DWORD *)(a1 + 84);
  v23 = *(_DWORD *)(a1 + 88);
  v25 = *(_DWORD *)(a1 + 44);
  v24 = *(_DWORD *)(a1 + 48);
  v26 = *(_DWORD *)(a1 + 92);
  LODWORD(v5) = *(_DWORD *)(a1 + 96);
  LODWORD(v4) = v13 - *v12;
  v27 = *v12 + v13;
  v29 = *(_DWORD *)(a1 + 52);
  v28 = *(_DWORD *)(a1 + 56);
  v30 = *(_DWORD *)(a1 + 60);
  v31 = *(_DWORD *)(a1 + 64);
  *v12 = v27;
  v33 = *(_DWORD *)(a1 + 100);
  v32 = *(_DWORD *)(a1 + 104);
  *(_DWORD *)a1 = (_DWORD)v4;
  *(_DWORD *)(a1 + 4) = v22 - v25;
  v48 = v18;
  *(_DWORD *)(a1 + 8) = v23 - v24;
  *(_DWORD *)(a1 + 12) = v26 - v29;
  v34 = *(_DWORD *)(a1 + 108);
  v35 = *(_DWORD *)(a1 + 112);
  v37 = *(_DWORD *)(a1 + 68);
  v36 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 16) = (_DWORD)v5 - v28;
  *(_DWORD *)(a1 + 20) = v33 - v30;
  LODWORD(v12) = *(_DWORD *)(a1 + 116);
  v38 = *(_DWORD *)(a1 + 120);
  v19 *= 2;
  v15 *= 2;
  v16 *= 2;
  v20 *= 2;
  *(_DWORD *)(a1 + 24) = v32 - v31;
  *(_DWORD *)(a1 + 28) = v34 - v37;
  v21 *= 2;
  v17 *= 2;
  *(_DWORD *)(a1 + 32) = v35 - v36;
  *(_DWORD *)(a1 + 36) = (_DWORD)v12 - v14;
  v39 = v24 + v23;
  *(_DWORD *)(a1 + 52) = v29 + v26;
  *(_DWORD *)(a1 + 56) = v28 + (_DWORD)v5;
  v40 = v14 + (_DWORD)v12;
  *(_DWORD *)(a1 + 60) = v30 + v33;
  *(_DWORD *)(a1 + 64) = v31 + v32;
  v41 = *(_DWORD *)(a1 + 124);
  v42 = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 44) = v25 + v22;
  *(_DWORD *)(a1 + 48) = v39;
  *(_DWORD *)(a1 + 68) = v37 + v34;
  *(_DWORD *)(a1 + 72) = v36 + v35;
  v44 = *(_DWORD *)(a1 + 132);
  v43 = *(_DWORD *)(a1 + 136);
  LODWORD(v12) = *(_DWORD *)(a1 + 140);
  LODWORD(v5) = *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a1 + 84) = v41 + 2 * v50;
  *(_DWORD *)(a1 + 88) = v42 + 2 * v49;
  v45 = *(_DWORD *)(a1 + 148);
  LODWORD(v4) = *(_DWORD *)(a1 + 152);
  *(_DWORD *)(a1 + 76) = v40;
  *(_DWORD *)(a1 + 80) = v38 + 2 * v51;
  *(_DWORD *)(a1 + 92) = v44 + 2 * v48;
  *(_DWORD *)(a1 + 96) = v43 + v19;
  v46 = *(_DWORD *)(a1 + 156);
  result = (unsigned int)(2 * v49 - v42);
  *(_DWORD *)(a1 + 100) = (_DWORD)v12 + v15;
  *(_DWORD *)(a1 + 104) = (_DWORD)v5 + v16;
  *(_DWORD *)(a1 + 108) = v45 + v20;
  *(_DWORD *)(a1 + 112) = (_DWORD)v4 + v21;
  *(_DWORD *)(a1 + 116) = v46 + v17;
  *(_DWORD *)(a1 + 120) = 2 * v51 - v38;
  *(_DWORD *)(a1 + 124) = 2 * v50 - v41;
  *(_DWORD *)(a1 + 128) = result;
  *(_DWORD *)(a1 + 132) = 2 * v48 - v44;
  *(_DWORD *)(a1 + 136) = v19 - v43;
  *(_DWORD *)(a1 + 140) = v15 - (_DWORD)v12;
  *(_DWORD *)(a1 + 144) = v16 - (_DWORD)v5;
  *(_DWORD *)(a1 + 148) = v20 - v45;
  *(_DWORD *)(a1 + 152) = v21 - (_DWORD)v4;
  *(_DWORD *)(a1 + 156) = v17 - v46;
  return result;
}


================================================================================
Function: sub_677924C (0x677924C)
================================================================================

bool __fastcall sub_677924C(unsigned __int8 *a1)
{
  unsigned __int64 v1; // d0

  v1 = vand_s8(
         *(int8x8_t *)(a1 + 15),
         (int8x8_t)vextq_s8(*(int8x16_t *)(a1 + 15), *(int8x16_t *)(a1 + 15), 8uLL).n128_u64[0]).n64_u64[0];
  return ((((236 - *a1) & ((~a1[31] & 0x7F | v1 & BYTE1(v1) & BYTE2(v1) & BYTE3(v1) & BYTE4(v1) & BYTE5(v1) & BYTE6(v1) & HIBYTE(v1) & a1[14] & a1[13] & a1[12] & a1[11] & a1[10] & a1[9] & a1[8] & a1[7] & a1[6] & a1[5] & a1[4] & a1[3] & a1[2] & a1[1] ^ 0xFF)
                         - 1)) >> 8) & 1) == 0;
}


================================================================================
Function: sub_6779338 (0x6779338)
================================================================================

__int64 __fastcall sub_6779338(int8x16_t *a1)
{
  int8x8_t v1; // d2
  unsigned __int64 v2; // d5
  int8x16_t v3; // q4
  int8x8_t v4; // d0
  unsigned __int64 v5; // d2
  char v6; // w2
  char v7; // w3
  char v8; // w4
  char v9; // w5
  char v10; // w6
  unsigned __int64 v11; // d3
  char v12; // w9
  int8x16_t v13; // q2
  char v14; // w11
  char v15; // w12
  char v16; // w13
  char v17; // w14
  char v18; // w10
  int8x8_t v19; // d3
  unsigned __int8 v20; // w8
  unsigned __int8 v21; // w9
  unsigned __int8 v22; // w12
  int8x8_t v23; // d5
  int8x16_t v24; // q3
  unsigned __int8 v25; // w5
  unsigned __int8 v26; // w6
  char v27; // w3
  unsigned __int8 v28; // w4
  char v29; // w11
  unsigned __int8 v30; // w1
  char v31; // w10
  unsigned __int8 v32; // w12
  unsigned __int8 v33; // w13
  unsigned __int8 v34; // w16
  unsigned __int8 v35; // w17
  unsigned __int8 v36; // w6
  unsigned __int8 v37; // w19
  unsigned __int8 v38; // w20
  int8x16_t v39; // q3
  int8x16_t v40; // q1
  unsigned __int8 v41; // w2
  unsigned __int8 v42; // w15
  unsigned __int8 v43; // w3
  char v44; // w14
  unsigned __int8 v45; // w4
  char v46; // w14
  char v47; // w15
  char v48; // w9
  char v49; // w16
  char v50; // w9
  char v51; // w12
  unsigned __int8 v52; // w15
  unsigned __int8 v53; // w17
  char v54; // w8
  char v55; // w9
  unsigned __int8 v56; // w16
  char v57; // w10
  char v58; // w11
  char v59; // w1
  char v60; // w2
  char v61; // w15
  unsigned __int8 v62; // w17
  char v63; // w8
  char v64; // w9
  unsigned __int8 v65; // w2
  char v66; // w15
  unsigned __int8 v67; // w1
  char v68; // w8
  char v69; // w10
  char v70; // w11
  char v71; // w16
  char v72; // w9
  char v73; // w15
  unsigned __int8 v74; // w2
  unsigned __int8 v75; // w17
  char v76; // w15

  v1.n64_u64[0] = vextq_s8(*a1, *a1, 8uLL).n128_u64[0];
  v2 = vorr_s8((int8x8_t)a1->n128_u64[0], v1).n64_u64[0];
  v3 = veorq_s8(*a1, (int8x16_t)xmmword_AF6990);
  v4.n64_u64[0] = a1[1].n128_u64[0];
  v5 = vorr_s8(veor_s8((int8x8_t)a1->n128_u64[0], (int8x8_t)1LL), v1).n64_u64[0];
  v6 = BYTE3(v5);
  v7 = BYTE4(v5);
  v8 = BYTE5(v5);
  v9 = BYTE6(v5);
  v10 = HIBYTE(v5);
  v11 = vorr_s8((int8x8_t)v3.n128_u64[0], (int8x8_t)vextq_s8(v3, v3, 8uLL).n128_u64[0]).n64_u64[0];
  v12 = v5 | BYTE1(v5) | BYTE2(v5);
  v13 = veorq_s8(*a1, (int8x16_t)xmmword_AFCC90);
  v14 = BYTE4(v11);
  v15 = BYTE5(v11);
  v16 = BYTE6(v11);
  v17 = HIBYTE(v11);
  v18 = v11 | BYTE1(v11) | BYTE2(v11) | BYTE3(v11);
  v19.n64_u64[0] = (unsigned __int8)(v12 | v6 | v7 | v8 | v9 | v10);
  v13.n128_u64[0] = vorr_s8((int8x8_t)v13.n128_u64[0], (int8x8_t)vextq_s8(v13, v13, 8uLL).n128_u64[0]).n64_u64[0];
  v20 = vorr_s8(
          (int8x8_t)(unsigned __int8)(v2 | BYTE1(v2) | BYTE2(v2) | BYTE3(v2) | BYTE4(v2) | BYTE5(v2) | BYTE6(v2) | HIBYTE(v2)),
          v4).n64_u8[0];
  v21 = v18 | v14 | v15 | v16 | v17;
  v22 = vorr_s8(v19, v4).n64_u8[0];
  v23.n64_u64[0] = veor_s8(v4, (int8x8_t)0x3933C6D305ACDFD5LL).n64_u64[0];
  v24 = veorq_s8(*a1, (int8x16_t)xmmword_AFA910);
  v25 = v13.n128_u8[5];
  v3.n128_u8[0] = vorr_s8((int8x8_t)v21, v23).n64_u8[0];
  v26 = v13.n128_u8[6];
  v27 = v13.n128_u8[0] | v13.n128_u8[1] | v13.n128_u8[2] | v13.n128_u8[3] | v13.n128_u8[4];
  v28 = v13.n128_u8[7];
  v13.n128_u64[0] = vorr_s8((int8x8_t)v24.n128_u64[0], (int8x8_t)vextq_s8(v24, v24, 8uLL).n128_u64[0]).n64_u64[0];
  v24.n128_u64[0] = veor_s8(v4, (int8x8_t)0xC6CC392CFA53202ALL).n64_u64[0];
  v29 = v22 | v4.n64_u8[1] | v4.n64_u8[2] | v4.n64_u8[3] | v4.n64_u8[5];
  v30 = vorr_s8((int8x8_t)(unsigned __int8)(v27 | v25 | v26 | v28), (int8x8_t)v24.n128_u64[0]).n64_u8[0];
  v31 = v20 | v4.n64_u8[1] | v4.n64_u8[2] | v4.n64_u8[3] | v4.n64_u8[5] | v4.n64_u8[7];
  v32 = v24.n128_u8[7];
  v33 = v24.n128_u8[6];
  v34 = v24.n128_u8[5];
  v35 = v24.n128_u8[4];
  v36 = v24.n128_u8[3];
  v37 = v24.n128_u8[2];
  v38 = v24.n128_u8[1];
  v39 = veorq_s8(*a1, (int8x16_t)xmmword_AFE390);
  v40 = veorq_s8(*a1, (int8x16_t)xmmword_AFD580);
  v39.n128_u64[0] = vorr_s8((int8x8_t)v39.n128_u64[0], (int8x8_t)vextq_s8(v39, v39, 8uLL).n128_u64[0]).n64_u64[0];
  v40.n128_u64[0] = vorr_s8((int8x8_t)v40.n128_u64[0], (int8x8_t)vextq_s8(v40, v40, 8uLL).n128_u64[0]).n64_u64[0];
  v41 = v39.n128_u8[5];
  v42 = v39.n128_u8[4];
  v43 = v39.n128_u8[6];
  v44 = v39.n128_u8[0] | v39.n128_u8[1] | v39.n128_u8[2] | v39.n128_u8[3];
  v45 = v39.n128_u8[7];
  v39.n128_u64[0] = vmvn_s8(v4).n64_u64[0];
  v46 = v44 | v42 | v41;
  v47 = v40.n128_u8[0] | v40.n128_u8[1] | v40.n128_u8[2] | v40.n128_u8[3] | v40.n128_u8[4];
  v48 = v30 | v38 | v37 | v36 | v35 | v34;
  v49 = vorn_s8(
          (int8x8_t)(unsigned __int8)(v13.n128_u8[0] | v13.n128_u8[1] | v13.n128_u8[2] | v13.n128_u8[3] | v13.n128_u8[4] | v13.n128_u8[5] | v13.n128_u8[6] | v13.n128_u8[7]),
          v4).n64_u8[0] | v39.n128_u8[1];
  v40.n128_u8[0] = vorn_s8((int8x8_t)(unsigned __int8)(v46 | v43 | v45), v4).n64_u8[0];
  v4.n64_u8[0] = vorn_s8((int8x8_t)(unsigned __int8)(v47 | v40.n128_u8[5] | v40.n128_u8[6] | v40.n128_u8[7]), v4).n64_u8[0];
  v50 = v48 | v33 | v32;
  v51 = v49 | v39.n128_u8[2] | v39.n128_u8[3] | v39.n128_u8[4] | v39.n128_u8[5] | v39.n128_u8[6] | v39.n128_u8[7];
  v52 = a1[1].n128_u8[8];
  v53 = a1[1].n128_u8[9];
  v54 = v3.n128_u8[0] | v23.n64_u8[1] | v23.n64_u8[2] | v23.n64_u8[3] | v23.n64_u8[4] | v23.n64_u8[5] | v23.n64_u8[6] | v23.n64_u8[7] | v52 ^ 0xB1;
  v55 = v50 | v52 ^ 0x4E;
  v56 = a1[1].n128_u8[10];
  v57 = v31 | v52 | v53;
  v58 = v29 | v4.n64_u8[6] | v4.n64_u8[7] | v52 | v53;
  v59 = v53 ^ 0x38;
  v60 = v53 ^ 0xC7;
  v61 = v52 & v53;
  v62 = a1[1].n128_u8[11];
  v63 = v54 | v59 | v56 ^ 2;
  v64 = v55 | v60 | v56 ^ 0xFD;
  v65 = a1[1].n128_u8[12];
  v66 = v61 & v56;
  v67 = a1[1].n128_u8[13];
  v68 = v63 | v62 ^ 0x88;
  v69 = v57 | v56 | v62 | v65;
  v70 = v58 | v56 | v62 | v65;
  v71 = v65 ^ 0x6D;
  v72 = v64 | v62 ^ 0x77 | v65 ^ 0x92;
  v73 = v66 & v62 & v65;
  v74 = a1[1].n128_u8[14];
  v75 = a1[1].n128_u8[15];
  v76 = v73 & v67 & v74;
  return ((((unsigned __int8)(v4.n64_u8[0] | v39.n128_u8[1] | v39.n128_u8[2] | v39.n128_u8[3] | v39.n128_u8[4] | v39.n128_u8[5] | v39.n128_u8[6] | v39.n128_u8[7] | ~v76 | v75 & 0x7F ^ 0x7F)
          - 1) | ((unsigned __int8)(v40.n128_u8[0] | v39.n128_u8[1] | v39.n128_u8[2] | v39.n128_u8[3] | v39.n128_u8[4] | v39.n128_u8[5] | v39.n128_u8[6] | v39.n128_u8[7] | ~v76 | v75 & 0x7F ^ 0x7F)
                - 1) | ((unsigned __int8)(v51 | ~v76 | v75 & 0x7F ^ 0x7F) - 1) | ((unsigned __int8)(v72 | v67 ^ 0xAC | v74 ^ 3 | v75 & 0x7F ^ 0x7A)
                                                                                - 1) | ((unsigned __int8)(v68 | v71 | v67 ^ 0x53 | v74 ^ 0xFC | v75 & 0x7F ^ 5)
                                                                                      - 1) | ((unsigned __int8)(v70 | v67 | v74 | v75 & 0x7F)
                                                                                            - 1) | (((unsigned __int8)(v69 | v67 | v74) | v75 & 0x7Fu)
                                                                                                  - 1)) >> 8) & 1;
}


================================================================================
Function: sub_67798C8 (0x67798C8)
================================================================================

unsigned __int16 *__fastcall sub_67798C8(unsigned __int16 *result)
{
  int v1; // w9
  int v2; // w14
  unsigned __int8 v3; // w2
  unsigned __int64 v4; // x4
  unsigned __int64 v5; // x17
  int v6; // w15
  int v7; // w5
  int v8; // w23
  unsigned __int64 v9; // x21
  unsigned __int64 v10; // x24
  int v11; // w25
  unsigned __int8 v12; // w2
  unsigned __int64 v13; // x28
  unsigned __int8 v14; // w10
  unsigned __int64 v15; // x27
  unsigned __int64 v16; // x23
  unsigned __int64 v17; // x20
  unsigned __int64 v18; // x25
  unsigned __int64 v19; // x7
  unsigned __int64 v20; // x4
  unsigned __int64 v21; // x22
  __int64 v22; // x21
  unsigned __int64 v23; // x8
  unsigned __int64 v24; // x30
  unsigned __int64 v25; // x3
  unsigned __int64 v26; // x26
  unsigned __int64 v27; // x19
  unsigned __int64 v28; // x9
  unsigned __int64 v29; // x10
  unsigned __int64 v30; // x6
  unsigned __int64 v31; // x13
  unsigned __int64 v32; // x10
  unsigned __int64 v33; // x22
  unsigned __int64 v34; // x5
  unsigned __int64 v35; // x12
  unsigned __int64 v36; // x14
  __int64 v37; // x4
  unsigned __int64 v38; // x3
  unsigned __int64 v39; // x11
  unsigned __int64 v40; // x8
  unsigned __int64 v41; // x5
  unsigned __int64 v42; // x6
  unsigned __int64 v43; // x20
  __int64 v44; // x19
  __int64 v45; // x4
  unsigned __int64 v46; // x9
  __int64 v47; // x7
  __int64 v48; // x21
  unsigned __int64 v49; // x6
  unsigned __int64 v50; // x10
  __int64 v51; // x8
  __int64 v52; // x5
  unsigned __int64 v53; // x10
  unsigned __int64 v54; // x3
  signed __int64 v55; // x20
  signed __int64 v56; // x4
  signed __int64 v57; // x25
  __int64 v58; // x8
  unsigned __int64 v59; // x14
  signed __int64 v60; // x21
  __int64 v61; // x19
  __int64 v62; // x8
  __int64 v63; // x5
  signed __int64 v64; // x8
  __int64 v65; // x7
  __int64 v66; // x14
  unsigned __int64 v67; // x3
  unsigned __int64 v68; // x6
  unsigned __int64 v69; // x10
  __int64 v70; // x11
  __int64 v71; // x3
  __int64 v72; // x12
  unsigned __int64 v73; // x10
  unsigned __int64 v74; // x6
  __int64 v75; // x13
  __int64 v76; // x10
  signed __int64 v77; // x9
  __int64 v78; // x2
  __int64 v79; // x16
  __int64 v80; // x15
  __int64 v81; // x17
  __int64 v82; // x1
  __int64 v83; // x8
  __int64 v84; // x14
  __int64 v85; // x8
  __int64 v86; // x11
  __int64 v87; // x13
  __int64 v88; // x10
  unsigned __int64 v89; // x9
  unsigned __int64 v90; // [xsp+8h] [xbp-78h]
  unsigned __int64 v91; // [xsp+18h] [xbp-68h]

  v1 = *((unsigned __int8 *)result + 5);
  v2 = *((unsigned __int8 *)result + 13);
  v3 = *((_BYTE *)result + 18);
  v4 = ((unsigned __int64)(*((unsigned __int8 *)result + 15) | (unsigned __int16)(*((unsigned __int8 *)result + 16) << 8) | (*((unsigned __int8 *)result + 17) << 16) & 0xFFFFFF | (v3 << 24)) >> 6) & 0x1FFFFF;
  v5 = v3 & 0xF8 | (unsigned __int64)(unsigned __int16)(*((unsigned __int8 *)result + 19) << 8) | ((unsigned __int64)*((unsigned __int8 *)result + 20) << 16);
  v6 = *((unsigned __int8 *)result + 26);
  v91 = *((unsigned __int8 *)result + 2) | (unsigned __int16)(*((unsigned __int8 *)result + 3) << 8) | (*((unsigned __int8 *)result + 4) << 16) & 0xFFFFFF | ((unsigned __int8)v1 << 24);
  v7 = *((unsigned __int8 *)result + 34);
  v8 = *((unsigned __int8 *)result + 47);
  v9 = *((unsigned __int8 *)result + 44) | (unsigned __int16)(*((unsigned __int8 *)result + 45) << 8) | (*((unsigned __int8 *)result + 46) << 16) & 0xFFFFFF | ((unsigned __int8)v8 << 24);
  v10 = ((unsigned __int64)(v8 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 48) << 8) | (*((unsigned __int8 *)result + 49) << 16)) >> 2) & 0x1FFFFF;
  v11 = *((unsigned __int8 *)result + 55);
  v12 = *((_BYTE *)result + 60);
  v13 = ((unsigned __int64)(*((unsigned __int8 *)result + 49) | (unsigned __int16)(*((unsigned __int8 *)result + 50) << 8) | (*((unsigned __int8 *)result + 51) << 16) & 0xFFFFFF | (*((unsigned __int8 *)result + 52) << 24)) >> 7) & 0x1FFFFF;
  v90 = v1 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 6) << 8) | (*((unsigned __int8 *)result + 7) << 16);
  v14 = *((_BYTE *)result + 39);
  v15 = v12 & 0xF8 | (unsigned __int64)(unsigned __int16)(*((unsigned __int8 *)result + 61) << 8) | ((unsigned __int64)*((unsigned __int8 *)result + 62) << 16) & 0xFFFFFFFF00FFFFFFLL | ((unsigned __int64)*((unsigned __int8 *)result + 63) << 24);
  v16 = ((unsigned __int64)(*((unsigned __int8 *)result + 52) | (unsigned __int16)(*((unsigned __int8 *)result + 53) << 8) | (*((unsigned __int8 *)result + 54) << 16) & 0xFFFFFF | ((unsigned __int8)v11 << 24)) >> 4) & 0x1FFFFF;
  v17 = ((unsigned __int64)(v11 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 56) << 8) | (*((unsigned __int8 *)result + 57) << 16)) >> 1) & 0x1FFFFF;
  v18 = ((unsigned __int64)(*((unsigned __int8 *)result + 57) | (unsigned __int16)(*((unsigned __int8 *)result + 58) << 8) | (*((unsigned __int8 *)result + 59) << 16) & 0xFFFFFF | (v12 << 24)) >> 6) & 0x1FFFFF;
  v19 = ((*((unsigned __int8 *)result + 23) << 16) & 0x1F0000 | (unsigned __int64)*(unsigned __int16 *)((char *)result + 21))
      + 654183 * v10
      + 470296 * v13
      + 666643 * v16;
  v20 = v4 + 666643 * v10;
  v21 = (result[21] | (unsigned __int64)((*((unsigned __int8 *)result + 44) << 16) & 0x1F0000)) - 683901 * (v15 >> 3);
  v22 = ((v9 >> 5) & 0x1FFFFF) + ((__int64)(v21 + 0x100000) >> 21);
  v23 = (((unsigned __int64)(*((unsigned __int8 *)result + 23) | (unsigned __int16)(*((unsigned __int8 *)result + 24) << 8) | (*((unsigned __int8 *)result + 25) << 16) & 0xFFFFFF | ((unsigned __int8)v6 << 24)) >> 5) & 0x1FFFFF)
      - 997805 * v10
      + 654183 * v13
      + 470296 * v16
      + 666643 * v17
      + ((v19 + 0x100000) >> 21);
  v24 = 470296 * v10 + (v5 >> 3) + ((v20 + 0x100000) >> 21) + 666643 * v13;
  v25 = (((unsigned __int64)(*((unsigned __int8 *)result + 36) | (unsigned __int16)(*((unsigned __int8 *)result + 37) << 8) | (*((unsigned __int8 *)result + 38) << 16) & 0xFFFFFF | (v14 << 24)) >> 6) & 0x1FFFFF)
      - 683901 * v17
      + 136657 * v18
      - 997805 * (v15 >> 3);
  v26 = (((unsigned __int64)(*((unsigned __int8 *)result + 31) | (unsigned __int16)(*((unsigned __int8 *)result + 32) << 8) | (*((unsigned __int8 *)result + 33) << 16) & 0xFFFFFF | ((unsigned __int8)v7 << 24)) >> 4) & 0x1FFFFF)
      - 683901 * v13
      + 136657 * v16
      - 997805 * v17
      + 654183 * v18
      + 470296 * (v15 >> 3);
  v27 = (((unsigned __int64)(v6 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 27) << 8) | (*((unsigned __int8 *)result + 28) << 16)) >> 2) & 0x1FFFFF)
      + 136657 * v10
      - 997805 * v13
      + 654183 * v16
      + 470296 * v17
      + 666643 * v18;
  v28 = (((unsigned __int64)(*((unsigned __int8 *)result + 28) | (unsigned __int16)(*((unsigned __int8 *)result + 29) << 8) | (*((unsigned __int8 *)result + 30) << 16) & 0xFFFFFF | (*((unsigned __int8 *)result + 31) << 24)) >> 7) & 0x1FFFFF)
      - 683901 * v10
      + 136657 * v13
      - 997805 * v16
      + 654183 * v17
      + 470296 * v18
      + 666643 * (v15 >> 3)
      + ((__int64)(v27 + 0x100000) >> 21);
  v29 = -683901LL * v18
      + ((v14 & 0xF8 | (unsigned __int64)(unsigned __int16)(*((unsigned __int8 *)result + 40) << 8) | ((unsigned __int64)*((unsigned __int8 *)result + 41) << 16)) >> 3)
      + 136657 * (v15 >> 3)
      + ((__int64)(v25 + 0x100000) >> 21);
  v30 = v21 - ((v21 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((__int64)(v29 + 0x100000) >> 21);
  v31 = v27 + ((__int64)(v23 + 0x100000) >> 21) - ((v27 + 0x100000) & 0xFFFFFFFFFFE00000LL) - 683901 * v22;
  v32 = v29 - ((v29 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v33 = (((unsigned __int64)(*((unsigned __int8 *)result + 10) | (unsigned __int16)(*((unsigned __int8 *)result + 11) << 8) | (*((unsigned __int8 *)result + 12) << 16) & 0xFFFFFF | ((unsigned __int8)v2 << 24)) >> 4) & 0x1FFFFF)
      + 666643 * v30;
  v34 = (((unsigned __int64)(v7 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 35) << 8) | (*((unsigned __int8 *)result + 36) << 16)) >> 1) & 0x1FFFFF)
      - 683901 * v16
      + 136657 * v17
      - 997805 * v18
      + 654183 * (v15 >> 3)
      + ((__int64)(v26 + 0x100000) >> 21);
  v35 = v23 - ((v23 + 0x100000) & 0xFFFFFFFFFFE00000LL) + 136657 * v22 - 683901 * v30;
  v36 = (((unsigned __int64)(v2 & 0xFF0000FF | (unsigned __int16)(*((unsigned __int8 *)result + 14) << 8) | (*((unsigned __int8 *)result + 15) << 16)) >> 1) & 0x1FFFFF)
      + 666643 * v22
      + 470296 * v30
      + 654183 * v32;
  v37 = v20 - ((v20 + 0x100000) & 0x7FFFFE00000LL) + 470296 * v22 + 654183 * v30 - 997805 * v32;
  v38 = v25 - ((v25 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((__int64)(v34 + 0x100000) >> 21);
  v39 = v19
      + ((v24 + 0x100000) >> 21)
      - ((v19 + 0x100000) & 0x1FFFFFE00000LL)
      - 997805 * v22
      + 136657 * v30
      - 683901 * v32;
  v40 = v26 - ((v26 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((__int64)(v28 + 0x100000) >> 21);
  v41 = v34 - ((v34 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v42 = v24 - ((v24 + 0x100000) & 0xFFFFFFFFFFE00000LL) + 654183 * v22 - 997805 * v30 + 136657 * v32 - 683901 * v38;
  v43 = (*result | (unsigned __int64)((*((unsigned __int8 *)result + 2) << 16) & 0x1F0000)) + 666643 * v40;
  v44 = ((v91 >> 5) & 0x1FFFFF) + 470296 * v40 + 666643 * v41 + ((__int64)(v43 + 0x100000) >> 21);
  v45 = v37 + 136657 * v38 - 683901 * v41;
  v46 = v28 - ((v28 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((__int64)(v31 + 0x100000) >> 21);
  v47 = ((v90 >> 2) & 0x1FFFFF) + 654183 * v40 + 666643 * v38 + 470296 * v41;
  v48 = v33 + 470296 * v32 + 136657 * v40 + 654183 * v38 - 997805 * v41;
  v49 = v42 + ((v45 + 0x100000) >> 21);
  v50 = (((unsigned __int64)(*((unsigned __int8 *)result + 7) | (unsigned __int16)(*((unsigned __int8 *)result + 8) << 8) | (*((unsigned __int8 *)result + 9) << 16) & 0xFFFFFF | (*((unsigned __int8 *)result + 10) << 24)) >> 7) & 0x1FFFFF)
      + 666643 * v32
      - 997805 * v40
      + 470296 * v38
      + 654183 * v41;
  v51 = v36 - 683901 * v40 - 997805 * v38 + 136657 * v41;
  v52 = (__int64)(v46 + 0x100000) >> 21;
  v53 = v50 + ((v47 + 0x100000) >> 21);
  v54 = v45 - ((v45 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v55 = v43 - ((v43 + 0x100000) & 0xFFFFFFFFFFE00000LL) + 666643 * v52;
  v56 = v44 + 470296 * v52 - ((v44 + 0x100000) & 0xFFFFFFFFFFE00000LL) + (v55 >> 21);
  v57 = v47 + 654183 * v52 - ((v47 + 0x100000) & 0xFFFFFFFFFFE00000LL) + ((v44 + 0x100000) >> 21) + (v56 >> 21);
  v58 = v51 + ((v48 + 0x100000) >> 21);
  v59 = v48 + 136657 * v52 - ((v48 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v60 = v53 - 997805 * v52 - ((v53 + 0x100000) & 0xFFFFFFFFFFE00000LL) + (v57 >> 21);
  v61 = v58 + 0x100000;
  v62 = v58 - 683901 * v52;
  v63 = v59 + ((__int64)(v53 + 0x100000) >> 21) + (v60 >> 21);
  v64 = v62 - (v61 & 0xFFFFFFFFFFE00000LL) + (v63 >> 21);
  v65 = v49 + 0x100000;
  v66 = v54 + (v61 >> 21) + (v64 >> 21);
  v67 = v49 - ((v49 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v68 = v35 + ((__int64)(v39 + 0x100000) >> 21);
  v69 = v39 - ((v39 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v70 = v67 + (v66 >> 21);
  v71 = v68 + 0x100000;
  v72 = v69 + (v65 >> 21) + (v70 >> 21);
  v73 = v68 - ((v68 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v74 = v31 - ((v31 + 0x100000) & 0xFFFFFFFFFFE00000LL);
  v75 = v73 + (v72 >> 21);
  v76 = v74 + (v71 >> 21) + (v75 >> 21);
  v77 = v46 - ((v46 + 0x100000) & 0xFFFFFFFFFFE00000LL) + (v76 >> 21);
  v78 = (v55 & 0x1FFFFF) + 666643 * (v77 >> 21);
  v79 = (v56 & 0x1FFFFF) + 470296 * (v77 >> 21) + (v78 >> 21);
  *(_BYTE *)result = v55 + 19 * (v77 >> 21);
  v80 = (v57 & 0x1FFFFF) + 654183 * (v77 >> 21) + (v79 >> 21);
  *((_BYTE *)result + 3) = (unsigned __int64)v79 >> 3;
  v81 = (v60 & 0x1FFFFF) - 997805 * (v77 >> 21) + (v80 >> 21);
  *((_BYTE *)result + 4) = (unsigned __int64)v79 >> 11;
  v82 = (v63 & 0x1FFFFF) + 136657 * (v77 >> 21) + (v81 >> 21);
  v83 = (v64 & 0x1FFFFF) - 683901 * (v77 >> 21) + (v82 >> 21);
  *((_BYTE *)result + 6) = (unsigned __int64)v80 >> 6;
  *((_BYTE *)result + 5) = ((unsigned int)v79 >> 19) & 3 | (4 * (v57 + 103 * (v77 >> 21) + (v79 >> 21)));
  *((_BYTE *)result + 7) = ((unsigned int)v80 >> 14) & 0x7F | (((_BYTE)v60
                                                              - -83 * (unsigned __int8)(v77 >> 21)
                                                              + (unsigned __int8)(v80 >> 21)) << 7);
  v84 = (v66 & 0x1FFFFF) + (v83 >> 21);
  *((_BYTE *)result + 9) = (unsigned __int64)v81 >> 9;
  *((_BYTE *)result + 8) = (unsigned __int64)v81 >> 1;
  *((_BYTE *)result + 1) = (unsigned __int16)(v55 + 11283 * (v77 >> 21)) >> 8;
  LOBYTE(v79) = v83;
  *((_BYTE *)result + 11) = (unsigned __int64)v82 >> 4;
  *((_BYTE *)result + 2) = BYTE2(v78) & 0x1F | (32 * (v56 + 24 * (v77 >> 21) + (v78 >> 21)));
  *((_BYTE *)result + 10) = ((unsigned int)v81 >> 17) & 0xF | (16 * (v63 - 47 * (v77 >> 21) + (v81 >> 21)));
  *((_BYTE *)result + 14) = (unsigned __int64)v83 >> 7;
  *((_BYTE *)result + 15) = ((unsigned int)v83 >> 15) & 0x3F | ((_BYTE)v84 << 6);
  v85 = (v70 & 0x1FFFFF) + (v84 >> 21);
  v86 = (v72 & 0x1FFFFF) + (v85 >> 21);
  *((_BYTE *)result + 12) = (unsigned __int64)v82 >> 12;
  *((_BYTE *)result + 17) = (unsigned __int64)v84 >> 10;
  v87 = (v75 & 0x1FFFFF) + (v86 >> 21);
  *((_BYTE *)result + 18) = ((unsigned int)v84 >> 18) & 7 | (8 * v85);
  *((_BYTE *)result + 19) = (unsigned __int64)v85 >> 5;
  *((_BYTE *)result + 20) = (unsigned __int64)v85 >> 13;
  v88 = (v76 & 0x1FFFFF) + (v87 >> 21);
  *(unsigned __int16 *)((char *)result + 21) = v72 + (v85 >> 21);
  *((_BYTE *)result + 23) = BYTE2(v86) & 0x1F | (32 * v87);
  v89 = (v77 & 0x1FFFFF) + (v88 >> 21);
  *((_BYTE *)result + 25) = (unsigned __int64)v87 >> 11;
  *((_BYTE *)result + 27) = (unsigned __int64)v88 >> 6;
  *((_BYTE *)result + 13) = ((v82 & 0x100000) != 0) | (2 * v79);
  *((_BYTE *)result + 16) = (unsigned __int64)v84 >> 2;
  *((_BYTE *)result + 24) = (unsigned __int64)v87 >> 3;
  *((_BYTE *)result + 26) = ((unsigned int)v87 >> 19) & 3 | (4 * v88);
  *((_BYTE *)result + 28) = ((unsigned int)v88 >> 14) & 0x7F | ((_BYTE)v89 << 7);
  *((_BYTE *)result + 29) = v89 >> 1;
  *((_BYTE *)result + 30) = v89 >> 9;
  *((_BYTE *)result + 31) = v89 >> 17;
  return result;
}


================================================================================
Function: sub_677A058 (0x677A058)
================================================================================

bool __fastcall sub_677A058(__int64 a1)
{
  int v1; // w9
  int v2; // w8
  __int64 i; // x10
  unsigned int v4; // w13
  int v5; // w14

  LOBYTE(v1) = 0;
  v2 = 1;
  for ( i = 31LL; i != -1; --i )
  {
    v4 = *(unsigned __int8 *)(a1 + i);
    v5 = byte_D137E0[i];
    v1 = v2 & ((int)(v4 - v5) >> 8) | (unsigned __int8)v1;
    v2 &= ((v5 ^ v4) + 0xFFFF) >> 8;
  }
  return v1 != 0;
}


================================================================================
Function: sub_677A0AC (0x677A0AC)
================================================================================

_DWORD *__fastcall sub_677A0AC(_DWORD *result, int *a2)
{
  __int64 v2; // x11
  __int64 v3; // x13
  __int64 v4; // x9
  __int64 v5; // x21
  __int64 v6; // x5
  __int64 v7; // x22
  __int64 v8; // x2
  __int64 v9; // x3
  __int64 v10; // x19
  __int64 v11; // x11
  __int64 v12; // x1
  __int64 v13; // x16
  __int64 v14; // x10
  __int64 v15; // x15
  __int64 v16; // x12
  __int64 v17; // x4
  __int64 v18; // x20
  __int64 v19; // x7
  __int64 v20; // x19
  __int64 v21; // x24
  __int64 v22; // x27
  __int64 v23; // x28
  __int64 v24; // x21
  __int64 v25; // x23
  __int64 v26; // x8
  __int64 v27; // x26
  __int64 v28; // x6
  __int64 v29; // x5
  __int64 v30; // x8
  __int64 v31; // x3
  __int64 v32; // x2
  __int64 v33; // x8
  __int64 v34; // x13
  __int64 v35; // x9
  __int64 v36; // x12
  unsigned __int64 v37; // x14
  __int64 v38; // x13
  __int64 v39; // x9
  unsigned __int64 v40; // x11
  __int64 v41; // [xsp+8h] [xbp-68h]

  v2 = *a2;
  v3 = a2[1];
  v5 = a2[5];
  v4 = a2[6];
  v7 = a2[7];
  v6 = a2[8];
  v8 = a2[9];
  v9 = 2 * v2;
  v10 = v2 * v2;
  v11 = a2[4];
  v13 = a2[2];
  v12 = a2[3];
  v14 = 38 * v8;
  v15 = 2 * v5;
  v16 = 19 * v6;
  v17 = v9 * v3 + 19 * v4 * 2 * v5;
  v41 = 2 * v3 * v3 + v13 * v9 + 19 * v4 * v4;
  v18 = 2 * v3 * v13 + v12 * v9;
  v19 = 2 * (v10 + 38 * v5 * v5 + 19 * v4 * 2 * v11 + 38 * v7 * 2 * v12 + 19 * v6 * 2 * v13 + 38 * v8 * 2 * v3);
  v20 = 2 * v11 * v5;
  v21 = 2 * v13 * v12 + v11 * 2 * v3 + v5 * v9 + 19 * v6 * 2 * v7;
  v22 = v11 * 2 * v13 + 2 * v12 * v12 + 2 * v5 * 2 * v3 + v4 * v9 + 19 * v6 * v6 + 38 * v8 * 2 * v7;
  v23 = 2 * v12 * v11 + v5 * 2 * v13 + v4 * 2 * v3;
  v24 = 2 * (v13 * v13 + 2 * v12 * 2 * v3 + v11 * v9 + 38 * v7 * v7 + 2 * v4 * 19 * v6 + 38 * v8 * 2 * v5);
  v25 = ((v24 + 0x2000000) >> 26) + 2 * (v21 + 38 * v8 * v4);
  v26 = v20 + v4 * 2 * v12 + v7 * 2 * v13 + v6 * 2 * v3;
  v27 = v23 + v7 * v9 + 38 * v8 * v6;
  v28 = ((v25 + 0x1000000) >> 25) + 2 * v22;
  v29 = v11 * v11 + v4 * 2 * v13 + v15 * 2 * v12 + 2 * v7 * 2 * v3 + v6 * v9;
  v30 = v26 + v8 * v9;
  v31 = ((v28 + 0x2000000) >> 26) + 2 * v27;
  v32 = ((v31 + 0x1000000) >> 25) + 2 * (v29 + 38 * v8 * v8);
  v33 = ((v32 + 0x2000000) >> 26) + 2 * v30;
  v34 = v41 + 38 * v7 * v15 + v16 * 2 * v11 + v14 * 2 * v12;
  v35 = v18 + 38 * v7 * v4 + v16 * v15 + v14 * v11;
  v36 = ((v19 + 0x2000000) >> 26) + 2 * (v17 + 38 * v7 * v11 + v16 * 2 * v12 + v14 * v13);
  v37 = v19 - ((v19 + 0x2000000) & 0xFFFFFFFFFC000000LL) + 19 * ((v33 + 0x1000000) >> 25);
  v38 = ((v36 + 0x1000000) >> 25) + 2 * v34;
  v39 = ((v38 + 0x2000000) >> 26) + 2 * v35;
  v40 = v24 - ((v24 + 0x2000000) & 0xFFFFFFFFFC000000LL) + ((v39 + 0x1000000) >> 25);
  *result = v37 - ((v37 + 0x2000000) & 0xFC000000);
  result[1] = v36 - ((v36 + 0x1000000) & 0xFE000000) + ((v37 + 0x2000000) >> 26);
  result[2] = v38 - ((v38 + 0x2000000) & 0xFC000000);
  result[3] = v39 - ((v39 + 0x1000000) & 0xFE000000);
  result[4] = v40 - ((v40 + 0x2000000) & 0xFC000000);
  result[5] = v25 - ((v25 + 0x1000000) & 0xFE000000) + ((v40 + 0x2000000) >> 26);
  result[6] = v28 - ((v28 + 0x2000000) & 0xFC000000);
  result[7] = v31 - ((v31 + 0x1000000) & 0xFE000000);
  result[8] = v32 - ((v32 + 0x2000000) & 0xFC000000);
  result[9] = v33 - ((v33 + 0x1000000) & 0xFE000000);
  return result;
}


================================================================================
Function: sub_677A8BC (0x677A8BC)
================================================================================

// attributes: thunk
__int64 __fastcall sub_677A8BC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_677B908(a1, a2, a3, a4);
}


================================================================================
Function: sub_677A8C0 (0x677A8C0)
================================================================================

long double __fastcall sub_677A8C0(__int64 a1)
{
  long double result; // q0

  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  result = byte_173D818;
  *(_OWORD *)(a1 + 32) = xmmword_173D808;
  *(long double *)(a1 + 48) = byte_173D818;
  *(_OWORD *)a1 = xmmword_173D7E8;
  *(_OWORD *)(a1 + 16) = unk_173D7F8;
  return result;
}


================================================================================
Function: sub_677A8E8 (0x677A8E8)
================================================================================

__int64 __fastcall sub_677A8E8(__int64 a1, _OWORD *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  __int64 v4; // x9
  bool v8; // cf
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x24
  unsigned __int64 v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x8
  char *v15; // x9
  _BYTE *v16; // x10
  char v17; // t1
  __int64 v18; // x9
  __int64 v19; // x8
  char *v20; // x9
  char v21; // t1
  unsigned __int64 v22; // x20
  unsigned __int64 v23; // x21
  unsigned __int64 v24; // x8
  __int64 v25; // x10
  unsigned __int64 v26; // x9
  char *v27; // x8
  _BYTE *v28; // x10
  char v29; // t1
  __int128 v31; // q1
  __int64 v32; // x10
  __int128 v33; // q1
  _OWORD *v34; // x10
  __int128 v35; // q1
  unsigned __int64 v36; // x12
  __int64 *v37; // x10
  __int64 v38; // x11
  unsigned __int64 v39; // x12
  _QWORD *v40; // x11
  __int64 v41; // t1
  __int128 v42; // q1
  __int64 v43; // x10
  __int128 v44; // q1
  _OWORD *v45; // x10
  __int128 v46; // q1
  __int128 v47; // q1
  __int64 v48; // x10
  __int64 v49; // x12
  __int64 *v50; // x10
  __int64 v51; // x11
  __int64 v52; // x12
  _QWORD *v53; // x11
  __int64 v54; // t1
  __int128 *v55; // x9
  _OWORD *v56; // x10
  unsigned __int64 v57; // x11
  __int128 v58; // q0
  __int128 v59; // q1
  unsigned __int64 v60; // x11
  __int64 *v61; // x9
  _QWORD *v62; // x10
  unsigned __int64 v63; // x11
  __int64 v64; // t1
  _BYTE v65[640]; // [xsp+8h] [xbp-2C8h] BYREF
  _BYTE v66[64]; // [xsp+288h] [xbp-48h] BYREF

  if ( !a3 )
    return 0LL;
  v4 = *(_QWORD *)(a1 + 64);
  v3 = *(_QWORD *)(a1 + 72);
  v8 = __CFADD__(v3, 8 * a3);
  v9 = v3 + 8 * a3;
  v10 = (v3 >> 3) & 0x7F;
  if ( v8 )
    ++v4;
  v11 = 128 - v10;
  *(_QWORD *)(a1 + 64) = v4 + (a3 >> 61);
  *(_QWORD *)(a1 + 72) = v9;
  if ( 128 - v10 <= a3 )
  {
    if ( v10 > 0x78 || a1 + v10 + 80 < (unsigned __int64)a2 + v11 && a1 + 208 > (unsigned __int64)a2 )
    {
      v18 = 0LL;
      goto LABEL_16;
    }
    if ( v10 <= 0x60 )
    {
      v42 = a2[1];
      v43 = a1 + v10;
      v18 = (unsigned __int8)v11 & 0xE0;
      *(_OWORD *)(v43 + 80) = *a2;
      *(_OWORD *)(v43 + 96) = v42;
      if ( v18 != 32 )
      {
        v44 = a2[3];
        v45 = (_OWORD *)(v10 + a1);
        v45[7] = a2[2];
        v45[8] = v44;
        if ( v18 != 64 )
        {
          v46 = a2[5];
          v45[9] = a2[4];
          v45[10] = v46;
          if ( v18 != 96 )
          {
            v47 = a2[7];
            v48 = v10 + a1;
            *(_OWORD *)(v48 + 176) = a2[6];
            *(_OWORD *)(v48 + 192) = v47;
          }
        }
      }
      if ( v11 == v18 )
        goto LABEL_18;
      if ( (v11 & 0x18) == 0 )
      {
LABEL_16:
        v19 = v18 + v10;
        v20 = (char *)a2 + v18;
        do
        {
          v21 = *v20++;
          *(_BYTE *)(a1 + 80 + v19++) = v21;
        }
        while ( v19 != 128 );
        goto LABEL_18;
      }
    }
    else
    {
      v18 = 0LL;
    }
    v49 = v18;
    v18 = (unsigned __int8)v11 & 0xF8;
    v50 = (__int64 *)((char *)a2 + v49);
    v51 = a1 + v49 + v10;
    v52 = v49 - v18;
    v53 = (_QWORD *)(v51 + 80);
    do
    {
      v54 = *v50++;
      v52 += 8LL;
      *v53++ = v54;
    }
    while ( v52 );
    if ( v11 != v18 )
      goto LABEL_16;
LABEL_18:
    sub_677AC74(a1, a1 + 80, v65, v66);
    v22 = (unsigned __int64)a2 + v11;
    v23 = a3 - v11;
    if ( v23 >= 0x80 )
    {
      do
      {
        sub_677AC74(a1, v22, v65, v66);
        v22 += 128LL;
        v23 -= 128LL;
      }
      while ( v23 > 0x7F );
    }
    if ( !v23 )
      goto LABEL_27;
    if ( v23 < 8 || a1 + 80 < v22 + v23 && v22 < a1 + 80 + v23 )
    {
      v24 = 0LL;
LABEL_25:
      v25 = a1 + v24;
      v26 = v23 - v24;
      v27 = (char *)(v22 + v24);
      v28 = (_BYTE *)(v25 + 80);
      do
      {
        v29 = *v27++;
        --v26;
        *v28++ = v29;
      }
      while ( v26 );
LABEL_27:
      sub_677C544((__int64)v65, 704LL);
      return 0LL;
    }
    if ( v23 >= 0x20 )
    {
      v24 = v23 & 0x60;
      v55 = (__int128 *)(v22 + 16);
      v56 = (_OWORD *)(a1 + 96);
      v57 = v23 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v58 = *(v55 - 1);
        v59 = *v55;
        v55 += 2;
        v57 -= 32LL;
        *(v56 - 1) = v58;
        *v56 = v59;
        v56 += 2;
      }
      while ( v57 );
      if ( v23 == v24 )
        goto LABEL_27;
      if ( (v23 & 0x18) == 0 )
        goto LABEL_25;
    }
    else
    {
      v24 = 0LL;
    }
    v60 = v24;
    v24 = v23 & 0xFFFFFFFFFFFFFFF8LL;
    v61 = (__int64 *)(v22 + v60);
    v62 = (_QWORD *)(a1 + v60 + 80);
    v63 = v60 - (v23 & 0xFFFFFFFFFFFFFFF8LL);
    do
    {
      v64 = *v61++;
      v63 += 8LL;
      *v62++ = v64;
    }
    while ( v63 );
    if ( v23 == v24 )
      goto LABEL_27;
    goto LABEL_25;
  }
  if ( a3 < 8 || a1 + 80 + v10 < (unsigned __int64)a2 + a3 && a1 + 80 + v10 + a3 > (unsigned __int64)a2 )
  {
    v12 = 0LL;
    goto LABEL_9;
  }
  if ( a3 >= 0x20 )
  {
    v31 = a2[1];
    v32 = a1 + v10;
    v12 = a3 & 0xFFFFFFFFFFFFFFE0LL;
    *(_OWORD *)(v32 + 80) = *a2;
    *(_OWORD *)(v32 + 96) = v31;
    if ( (a3 & 0xFFFFFFFFFFFFFFE0LL) != 0x20 )
    {
      v33 = a2[3];
      v34 = (_OWORD *)(v10 + a1);
      v34[7] = a2[2];
      v34[8] = v33;
      if ( v12 != 64 )
      {
        v35 = a2[5];
        v34[9] = a2[4];
        v34[10] = v35;
      }
    }
    if ( v12 == a3 )
      return 0LL;
    if ( (a3 & 0x18) == 0 )
    {
LABEL_9:
      v13 = v12 + v10;
      v14 = a3 - v12;
      v15 = (char *)a2 + v12;
      v16 = (_BYTE *)(a1 + v13 + 80);
      do
      {
        v17 = *v15++;
        --v14;
        *v16++ = v17;
      }
      while ( v14 );
      return 0LL;
    }
  }
  else
  {
    v12 = 0LL;
  }
  v36 = v12;
  v12 = a3 & 0xFFFFFFFFFFFFFFF8LL;
  v37 = (__int64 *)((char *)a2 + v36);
  v38 = a1 + v36 + v10;
  v39 = v36 - (a3 & 0xFFFFFFFFFFFFFFF8LL);
  v40 = (_QWORD *)(v38 + 80);
  do
  {
    v41 = *v37++;
    v39 += 8LL;
    *v40++ = v41;
  }
  while ( v39 );
  if ( v12 != a3 )
    goto LABEL_9;
  return 0LL;
}


================================================================================
Function: sub_677AC74 (0x677AC74)
================================================================================

__int128 *__fastcall sub_677AC74(__int128 *result, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 i; // x8
  __int128 v5; // q0
  __int64 v6; // x8
  __int128 v7; // q2
  __int128 v8; // q3
  __int64 v9; // x4
  __int64 v10; // x12
  _QWORD *v11; // x10
  __int64 v12; // x13
  __int64 v13; // x19
  __int64 v14; // x14
  __int64 v15; // x17
  __int64 v16; // x5
  __int64 v17; // x15
  __int64 v18; // x1
  __int64 v19; // x15
  __int64 v20; // x13
  __int64 v21; // x16
  __int64 v22; // x13
  __int64 v23; // x7
  __int64 v24; // x5
  __int64 v25; // x4
  __int64 v26; // x14
  __int64 v27; // x12
  __int64 v28; // x17
  __int64 v29; // x12
  __int64 v30; // x7
  __int64 v31; // x1
  __int64 v32; // x6
  __int64 v33; // x15
  __int64 v34; // x16
  __int64 v35; // x1
  __int64 v36; // x13
  __int64 v37; // x19
  __int64 v38; // x16
  __int64 v39; // x7
  __int64 v40; // x14
  __int64 v41; // x16
  __int64 v42; // x5
  __int64 v43; // x16
  __int64 v44; // x4
  __int64 v45; // x6
  __int64 v46; // x12
  __int64 v47; // x17
  __int64 v48; // x12
  __int64 v49; // x15
  __int64 v50; // x4
  __int64 v51; // x13
  __int64 v52; // x6
  __int64 v53; // x7
  __int64 v54; // x15
  __int64 v55; // x1
  __int64 v56; // x14
  __int64 v57; // x15
  __int64 v58; // x16
  __int64 v59; // x15
  __int64 v60; // x7
  __int64 v61; // x20
  __int64 v62; // x17
  __int64 v63; // x12
  __int64 v64; // x17
  __int64 v65; // x4
  __int64 v66; // x13
  __int64 v67; // x4
  __int64 v68; // x7
  __int64 v69; // x11
  __int64 v70; // x1
  __int64 v71; // x14
  __int64 v72; // x1
  __int64 v73; // x11
  __int64 v74; // x14
  __int64 v75; // x11
  unsigned __int64 v76; // x11
  unsigned __int64 v77; // x12
  unsigned __int64 v78; // x13
  unsigned __int64 v79; // x6
  unsigned __int64 v80; // x7
  unsigned __int64 v81; // x17
  unsigned __int64 v82; // x16
  unsigned __int64 v83; // x1
  unsigned __int64 v84; // x14
  unsigned __int64 v85; // x15
  unsigned __int64 v86; // x13
  __int64 v87; // x4
  unsigned __int64 v88; // x20
  unsigned __int64 v89; // x4
  unsigned __int64 v90; // x7
  unsigned __int64 v91; // x21
  unsigned __int64 v92; // x4
  unsigned __int64 v93; // x23
  unsigned __int64 v94; // x24
  unsigned __int64 v95; // x17
  unsigned __int64 v96; // x5
  unsigned __int64 v97; // x5
  unsigned __int64 v98; // x19
  unsigned __int64 v99; // x25
  unsigned __int64 v100; // x11
  unsigned __int64 v101; // x12
  unsigned __int64 v102; // x7
  unsigned __int64 v103; // x6
  unsigned __int64 v104; // x13
  unsigned __int64 v105; // x17
  unsigned __int64 v106; // x1
  unsigned __int64 v107; // x11
  unsigned __int64 v108; // x5
  unsigned __int64 v109; // x12
  __int64 v110; // x9
  __int64 v111; // x8
  __int64 v112; // x9
  __int64 v113; // x10
  __int64 v114; // x8
  __int64 v115; // x9
  __int64 v116; // x10
  __int64 v117; // x8
  __int64 v118; // x9
  __int64 v119; // x10

  for ( i = 0LL; i != 128; i += 8LL )
    *(_QWORD *)(a3 + i) = bswap64(*(_QWORD *)(a2 + i));
  v5 = result[3];
  v6 = 0LL;
  v8 = *result;
  v7 = result[1];
  *((_OWORD *)a4 + 2) = result[2];
  *((_OWORD *)a4 + 3) = v5;
  *(_OWORD *)a4 = v8;
  *((_OWORD *)a4 + 1) = v7;
  while ( 1 )
  {
    v10 = a4[4];
    v9 = a4[5];
    v11 = (_QWORD *)(a3 + v6);
    v12 = a4[6];
    v13 = *(_QWORD *)((char *)&unk_173D828 + v6 + 8);
    v15 = *a4;
    v14 = a4[1];
    v16 = a4[2];
    v17 = *(_QWORD *)(a3 + v6)
        + (__ROR8__(v10, 14) ^ __ROR8__(v10, 18) ^ __ROR8__(v10, 41))
        + *(_QWORD *)((char *)&unk_173D828 + v6)
        + (v9 & v10 | v12 & ~v10)
        + a4[7];
    v18 = v17 + a4[3];
    v19 = (__ROR8__(*a4, 28) ^ __ROR8__(*a4, 34) ^ __ROR8__(*a4, 39)) + v17 + ((v16 | v14) & *a4 | v16 & v14);
    a4[3] = v18;
    a4[7] = v19;
    v20 = (v10 & v18 | v9 & ~v18)
        + v12
        + (__ROR8__(v18, 14) ^ __ROR8__(v18, 18) ^ __ROR8__(v18, 41))
        + *(_QWORD *)(a3 + v6 + 8)
        + v13;
    v21 = v20 + v16;
    a4[2] = v20 + v16;
    v22 = (v19 & (v14 | v15) | v14 & v15) + v20 + (__ROR8__(v19, 28) ^ __ROR8__(v19, 34) ^ __ROR8__(v19, 39));
    a4[6] = v22;
    v23 = *(_QWORD *)((char *)&unk_173D828 + v6 + 24);
    v24 = *(_QWORD *)(a3 + v6 + 16)
        + v9
        + *(_QWORD *)((char *)&unk_173D828 + v6 + 16)
        + (v18 & v21 | v10 & ~v21)
        + (__ROR8__(v21, 14) ^ __ROR8__(v21, 18) ^ __ROR8__(v21, 41));
    v25 = v24 + v14;
    v26 = (__ROR8__(v22, 28) ^ __ROR8__(v22, 34) ^ __ROR8__(v22, 39)) + (v22 & (v19 | v15) | v19 & v15) + v24;
    a4[1] = v25;
    a4[5] = v26;
    v27 = *(_QWORD *)(a3 + v6 + 24)
        + v10
        + v23
        + (v21 & v25 | v18 & ~v25)
        + (__ROR8__(v25, 14) ^ __ROR8__(v25, 18) ^ __ROR8__(v25, 41));
    v28 = v27 + v15;
    v29 = (__ROR8__(v26, 28) ^ __ROR8__(v26, 34) ^ __ROR8__(v26, 39)) + (v26 & (v22 | v19) | v22 & v19) + v27;
    *a4 = v28;
    a4[4] = v29;
    v30 = *(_QWORD *)((char *)&unk_173D828 + v6 + 40);
    v31 = *(_QWORD *)(a3 + v6 + 32)
        + v18
        + *(_QWORD *)((char *)&unk_173D828 + v6 + 32)
        + (v25 & v28 | v21 & ~v28)
        + (__ROR8__(v28, 14) ^ __ROR8__(v28, 18) ^ __ROR8__(v28, 41));
    v32 = v31 + v19;
    v33 = (__ROR8__(v29, 28) ^ __ROR8__(v29, 34) ^ __ROR8__(v29, 39)) + (v29 & (v26 | v22) | v26 & v22) + v31;
    a4[7] = v32;
    a4[3] = v33;
    v34 = *(_QWORD *)(a3 + v6 + 40)
        + v21
        + v30
        + (v28 & v32 | v25 & ~v32)
        + (__ROR8__(v32, 14) ^ __ROR8__(v32, 18) ^ __ROR8__(v32, 41));
    v35 = v34 + v22;
    v36 = (__ROR8__(v33, 28) ^ __ROR8__(v33, 34) ^ __ROR8__(v33, 39)) + (v33 & (v29 | v26) | v29 & v26) + v34;
    a4[6] = v35;
    a4[2] = v36;
    v37 = *(_QWORD *)((char *)&unk_173D828 + v6 + 56);
    v38 = *(_QWORD *)(a3 + v6 + 48)
        + v25
        + *(_QWORD *)((char *)&unk_173D828 + v6 + 48)
        + (v32 & v35 | v28 & ~v35)
        + (__ROR8__(v35, 14) ^ __ROR8__(v35, 18) ^ __ROR8__(v35, 41));
    v39 = v38 + v26;
    v40 = (__ROR8__(v36, 28) ^ __ROR8__(v36, 34) ^ __ROR8__(v36, 39)) + (v36 & (v33 | v29) | v33 & v29) + v38;
    a4[5] = v39;
    a4[1] = v40;
    v41 = *(_QWORD *)(a3 + v6 + 56)
        + v28
        + v37
        + (v35 & v39 | v32 & ~v39)
        + (__ROR8__(v39, 14) ^ __ROR8__(v39, 18) ^ __ROR8__(v39, 41));
    v42 = v41 + v29;
    v43 = (__ROR8__(v40, 28) ^ __ROR8__(v40, 34) ^ __ROR8__(v40, 39)) + (v40 & (v36 | v33) | v36 & v33) + v41;
    a4[4] = v42;
    *a4 = v43;
    v44 = *(_QWORD *)(a3 + v6 + 64) + v32;
    v45 = *(_QWORD *)((char *)&unk_173D828 + v6 + 72);
    v46 = v44
        + *(_QWORD *)((char *)&unk_173D828 + v6 + 64)
        + (v39 & v42 | v35 & ~v42)
        + (__ROR8__(v42, 14) ^ __ROR8__(v42, 18) ^ __ROR8__(v42, 41));
    v47 = v46 + v33;
    v48 = (__ROR8__(v43, 28) ^ __ROR8__(v43, 34) ^ __ROR8__(v43, 39)) + (v43 & (v40 | v36) | v40 & v36) + v46;
    a4[3] = v47;
    a4[7] = v48;
    v49 = *(_QWORD *)(a3 + v6 + 72)
        + v35
        + v45
        + (v42 & v47 | v39 & ~v47)
        + (__ROR8__(v47, 14) ^ __ROR8__(v47, 18) ^ __ROR8__(v47, 41));
    v50 = v49 + v36;
    v51 = (__ROR8__(v48, 28) ^ __ROR8__(v48, 34) ^ __ROR8__(v48, 39)) + (v48 & (v43 | v40) | v43 & v40) + v49;
    a4[2] = v50;
    a4[6] = v51;
    v52 = v39 + *(_QWORD *)(a3 + v6 + 80);
    v53 = *(_QWORD *)((char *)&unk_173D828 + v6 + 88);
    v54 = v52
        + *(_QWORD *)((char *)&unk_173D828 + v6 + 80)
        + (v47 & v50 | v42 & ~v50)
        + (__ROR8__(v50, 14) ^ __ROR8__(v50, 18) ^ __ROR8__(v50, 41));
    v55 = v54 + v40;
    v56 = (__ROR8__(v51, 28) ^ __ROR8__(v51, 34) ^ __ROR8__(v51, 39)) + (v51 & (v48 | v43) | v48 & v43) + v54;
    a4[1] = v55;
    a4[5] = v56;
    v57 = v53
        + *(_QWORD *)(a3 + v6 + 88)
        + v42
        + (v50 & v55 | v47 & ~v55)
        + (__ROR8__(v55, 14) ^ __ROR8__(v55, 18) ^ __ROR8__(v55, 41));
    v58 = v57 + v43;
    v59 = (__ROR8__(v56, 28) ^ __ROR8__(v56, 34) ^ __ROR8__(v56, 39)) + (v56 & (v51 | v48) | v51 & v48) + v57;
    *a4 = v58;
    v60 = *(_QWORD *)((char *)&unk_173D828 + v6 + 96);
    v61 = *(_QWORD *)((char *)&unk_173D828 + v6 + 104);
    a4[4] = v59;
    v62 = v60
        + *(_QWORD *)(a3 + v6 + 96)
        + v47
        + (v55 & v58 | v50 & ~v58)
        + (__ROR8__(v58, 14) ^ __ROR8__(v58, 18) ^ __ROR8__(v58, 41));
    v63 = v62 + v48;
    v64 = (__ROR8__(v59, 28) ^ __ROR8__(v59, 34) ^ __ROR8__(v59, 39)) + (v59 & (v56 | v51) | v56 & v51) + v62;
    a4[7] = v63;
    a4[3] = v64;
    v65 = v61
        + *(_QWORD *)(a3 + v6 + 104)
        + v50
        + (v58 & v63 | v55 & ~v63)
        + (__ROR8__(v63, 14) ^ __ROR8__(v63, 18) ^ __ROR8__(v63, 41));
    v66 = v65 + v51;
    v67 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v59 | v56) | v59 & v56) + v65;
    a4[6] = v66;
    v68 = *(_QWORD *)((char *)&unk_173D828 + v6 + 112);
    v69 = *(_QWORD *)((char *)&unk_173D828 + v6 + 120);
    a4[2] = v67;
    v70 = v68
        + *(_QWORD *)(a3 + v6 + 112)
        + v55
        + (v63 & v66 | v58 & ~v66)
        + (__ROR8__(v66, 14) ^ __ROR8__(v66, 18) ^ __ROR8__(v66, 41));
    v71 = v70 + v56;
    v72 = (__ROR8__(v67, 28) ^ __ROR8__(v67, 34) ^ __ROR8__(v67, 39)) + (v67 & (v64 | v59) | v64 & v59) + v70;
    a4[5] = v71;
    a4[1] = v72;
    v73 = v69
        + *(_QWORD *)(a3 + v6 + 120)
        + v58
        + (v66 & v71 | v63 & ~v71)
        + (__ROR8__(v71, 14) ^ __ROR8__(v71, 18) ^ __ROR8__(v71, 41));
    v74 = v73 + v59;
    v75 = (__ROR8__(v72, 28) ^ __ROR8__(v72, 34) ^ __ROR8__(v72, 39)) + (v72 & (v67 | v64) | v67 & v64) + v73;
    a4[4] = v74;
    *a4 = v75;
    if ( v6 == 512 )
      break;
    v76 = v11[14];
    v77 = v11[15];
    v6 += 128LL;
    v78 = v11[1];
    v79 = v11[8];
    v80 = v11[2];
    v81 = v11[3];
    v82 = (__ROR8__(v76, 19) ^ __ROR8__(v76, 61) ^ (v76 >> 6))
        + v11[9]
        + *v11
        + (__ROR8__(v78, 1) ^ __ROR8__(v78, 8) ^ (v78 >> 7));
    v83 = v11[9];
    v84 = v11[13];
    v85 = v76;
    v86 = v11[10]
        + v78
        + (__ROR8__(v77, 19) ^ __ROR8__(v77, 61) ^ (v77 >> 6))
        + (__ROR8__(v80, 1) ^ __ROR8__(v80, 8) ^ (v80 >> 7));
    v88 = v11[10];
    v87 = v11[11];
    v11[16] = v82;
    v11[17] = v86;
    v89 = (__ROR8__(v82, 19) ^ __ROR8__(v82, 61) ^ (v82 >> 6)) + v87 + v80;
    v90 = v11[4];
    v91 = v11[5];
    v92 = v89 + (__ROR8__(v81, 1) ^ __ROR8__(v81, 8) ^ (v81 >> 7));
    v93 = v11[11];
    v94 = v11[12];
    v95 = (__ROR8__(v86, 19) ^ __ROR8__(v86, 61) ^ (v86 >> 6))
        + v94
        + v81
        + (__ROR8__(v90, 1) ^ __ROR8__(v90, 8) ^ (v90 >> 7));
    v96 = (__ROR8__(v92, 19) ^ __ROR8__(v92, 61) ^ (v92 >> 6)) + v11[13] + v90;
    v11[18] = v92;
    v11[19] = v95;
    v97 = v96 + (__ROR8__(v91, 1) ^ __ROR8__(v91, 8) ^ (v91 >> 7));
    v99 = v11[6];
    v98 = v11[7];
    v100 = (__ROR8__(v95, 19) ^ __ROR8__(v95, 61) ^ (v95 >> 6))
         + v76
         + v91
         + (__ROR8__(v99, 1) ^ __ROR8__(v99, 8) ^ (v99 >> 7));
    v101 = (__ROR8__(v97, 19) ^ __ROR8__(v97, 61) ^ (v97 >> 6))
         + v77
         + v99
         + (__ROR8__(v98, 1) ^ __ROR8__(v98, 8) ^ (v98 >> 7));
    v102 = (__ROR8__(v100, 19) ^ __ROR8__(v100, 61) ^ (v100 >> 6))
         + v82
         + v98
         + (__ROR8__(v79, 1) ^ __ROR8__(v79, 8) ^ (v79 >> 7));
    v103 = v79
         + v86
         + (__ROR8__(v101, 19) ^ __ROR8__(v101, 61) ^ (v101 >> 6))
         + (__ROR8__(v83, 1) ^ __ROR8__(v83, 8) ^ (v83 >> 7));
    v11[20] = v97;
    v11[21] = v100;
    v11[22] = v101;
    v11[23] = v102;
    v104 = v83
         + v92
         + (__ROR8__(v102, 19) ^ __ROR8__(v102, 61) ^ (v102 >> 6))
         + (__ROR8__(v88, 1) ^ __ROR8__(v88, 8) ^ (v88 >> 7));
    v105 = v88
         + v95
         + (__ROR8__(v103, 19) ^ __ROR8__(v103, 61) ^ (v103 >> 6))
         + (__ROR8__(v93, 1) ^ __ROR8__(v93, 8) ^ (v93 >> 7));
    v11[24] = v103;
    v11[25] = v104;
    v106 = v93
         + v97
         + (__ROR8__(v104, 19) ^ __ROR8__(v104, 61) ^ (v104 >> 6))
         + (__ROR8__(v94, 1) ^ __ROR8__(v94, 8) ^ (v94 >> 7));
    v11[26] = v105;
    v11[27] = v106;
    v107 = v94
         + v100
         + (__ROR8__(v105, 19) ^ __ROR8__(v105, 61) ^ (v105 >> 6))
         + (__ROR8__(v84, 1) ^ __ROR8__(v84, 8) ^ (v84 >> 7));
    v108 = v11[15];
    v109 = v84
         + v101
         + (__ROR8__(v106, 19) ^ __ROR8__(v106, 61) ^ (v106 >> 6))
         + (__ROR8__(v85, 1) ^ __ROR8__(v85, 8) ^ (v85 >> 7));
    v11[28] = v107;
    v11[29] = v109;
    v11[30] = v85
            + v102
            + (__ROR8__(v107, 19) ^ __ROR8__(v107, 61) ^ (v107 >> 6))
            + (__ROR8__(v108, 1) ^ __ROR8__(v108, 8) ^ (v108 >> 7));
    v11[31] = v103
            + (__ROR8__(v82, 1) ^ __ROR8__(v82, 8) ^ (v82 >> 7))
            + v108
            + (__ROR8__(v109, 19) ^ __ROR8__(v109, 61) ^ (v109 >> 6));
  }
  v110 = *((_QWORD *)result + 1);
  *(_QWORD *)result += v75;
  v111 = v110 + a4[1];
  v112 = *((_QWORD *)result + 2);
  v113 = *((_QWORD *)result + 3);
  *((_QWORD *)result + 1) = v111;
  *((_QWORD *)result + 2) = v112 + a4[2];
  v114 = v113 + a4[3];
  v115 = *((_QWORD *)result + 4);
  v116 = *((_QWORD *)result + 5);
  *((_QWORD *)result + 3) = v114;
  *((_QWORD *)result + 4) = v115 + a4[4];
  v117 = v116 + a4[5];
  v118 = *((_QWORD *)result + 6);
  v119 = *((_QWORD *)result + 7);
  *((_QWORD *)result + 5) = v117;
  *((_QWORD *)result + 6) = v118 + a4[6];
  *((_QWORD *)result + 7) = v119 + a4[7];
  return result;
}


================================================================================
Function: sub_677B5DC (0x677B5DC)
================================================================================

__int64 __fastcall sub_677B5DC(__int64 a1, _QWORD *a2)
{
  __int64 v4; // x21
  __int64 v5; // x8
  __int64 v6; // x8
  _BYTE v8[640]; // [xsp+8h] [xbp-2C8h] BYREF
  _BYTE v9[64]; // [xsp+288h] [xbp-48h] BYREF

  v4 = *(_QWORD *)(a1 + 72);
  v5 = ((unsigned int)v4 >> 3) & 0x7F;
  if ( (unsigned int)v5 > 0x6F )
  {
    memcpy((void *)(a1 + 80 + (unsigned int)v5), &unk_173DAA8, (unsigned int)(128 - v5));
    sub_677AC74(a1, a1 + 80, v8, v9);
    v4 = *(_QWORD *)(a1 + 72);
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
  }
  else
  {
    memcpy((void *)(a1 + v5 + 80), &unk_173DAA8, (unsigned int)(112 - v5));
  }
  v6 = *(_QWORD *)(a1 + 64);
  *(_BYTE *)(a1 + 207) = v4;
  *(_BYTE *)(a1 + 195) = BYTE4(v6);
  *(_DWORD *)(a1 + 196) = bswap32(v6);
  *(_BYTE *)(a1 + 193) = BYTE6(v6);
  *(_BYTE *)(a1 + 194) = BYTE5(v6);
  *(_BYTE *)(a1 + 192) = HIBYTE(v6);
  *(_BYTE *)(a1 + 205) = BYTE2(v4);
  *(_BYTE *)(a1 + 206) = BYTE1(v4);
  *(_BYTE *)(a1 + 204) = BYTE3(v4);
  *(_BYTE *)(a1 + 202) = BYTE5(v4);
  *(_BYTE *)(a1 + 203) = BYTE4(v4);
  *(_BYTE *)(a1 + 201) = BYTE6(v4);
  *(_BYTE *)(a1 + 200) = HIBYTE(v4);
  sub_677AC74(a1, a1 + 80, v8, v9);
  *a2 = bswap64(*(_QWORD *)a1);
  a2[1] = bswap64(*(_QWORD *)(a1 + 8));
  a2[2] = bswap64(*(_QWORD *)(a1 + 16));
  a2[3] = bswap64(*(_QWORD *)(a1 + 24));
  a2[4] = bswap64(*(_QWORD *)(a1 + 32));
  a2[5] = bswap64(*(_QWORD *)(a1 + 40));
  a2[6] = bswap64(*(_QWORD *)(a1 + 48));
  a2[7] = bswap64(*(_QWORD *)(a1 + 56));
  sub_677C544((__int64)v8, 704LL);
  sub_677C544(a1, 208LL);
  return 0LL;
}


================================================================================
Function: sub_677B7B0 (0x677B7B0)
================================================================================

__int64 __fastcall sub_677B7B0(_BYTE *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  _BYTE *v5; // x20
  int v12; // w0
  int v13; // w20
  _BYTE v14[120]; // [xsp+0h] [xbp-250h] BYREF
  _BYTE v15[160]; // [xsp+78h] [xbp-1D8h] BYREF
  _BYTE v16[32]; // [xsp+118h] [xbp-138h] BYREF
  _BYTE v17[64]; // [xsp+138h] [xbp-118h] BYREF
  _BYTE v18[208]; // [xsp+178h] [xbp-D8h] BYREF

  v5 = a1 + 32;
  if ( !(unsigned int)sub_677A058(a1 + 32)
    || (unsigned int)sub_6779338(a1)
    || !(unsigned int)sub_677924C(a4)
    || (unsigned int)sub_6779338(a4)
    || (unsigned int)sub_677775C(v15, a4) )
  {
    return 0xFFFFFFFFLL;
  }
  sub_677B910(v18, a5);
  sub_677A8E8(v18, a1, 32LL);
  sub_677A8E8(v18, a4, 32LL);
  sub_677A8E8(v18, a2, a3);
  sub_677B5DC(v18, v17);
  sub_67798C8(v17);
  sub_6777D60(v14, v17, v15, v5);
  sub_6777CB8(v16, v14);
  v12 = sub_677C39C(v16, a1);
  if ( v16 == a1 )
    v13 = -1;
  else
    v13 = v12;
  return v13 | (unsigned int)sub_677C574(a1, v16, 32LL);
}


================================================================================
Function: sub_677B908 (0x677B908)
================================================================================

__int64 __fastcall sub_677B908(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_677B7B0(a1, a2, a3, a4, 0LL);
}


================================================================================
Function: sub_677B910 (0x677B910)
================================================================================

__int64 __fastcall sub_677B910(__int64 a1, int a2)
{
  __int64 result; // x0

  result = sub_677A8C0();
  if ( a2 )
    return sub_677A8E8(a1, xmmword_173DB28, 0x22uLL);
  return result;
}


================================================================================
Function: sub_677C39C (0x677C39C)
================================================================================

__int64 __fastcall sub_677C39C(__int64 a1, __int64 a2)
{
  __int64 v2; // x8
  char v3; // w9
  char v4; // w10
  int v6; // [xsp+8h] [xbp-18h]

  v2 = 0LL;
  v6 = 0;
  do
  {
    v3 = *(_BYTE *)(a1 + v2);
    v4 = *(_BYTE *)(a2 + v2++);
    v6 |= (unsigned __int8)(v4 ^ v3);
  }
  while ( v2 != 32 );
  return (((unsigned int)(v6 - 1) >> 8) & 1) - 1;
}


================================================================================
Function: sub_677C544 (0x677C544)
================================================================================

__int64 __fastcall sub_677C544(__int64 result, __int64 a2)
{
  __int64 v2; // x8
  bool v3; // zf

  if ( a2 )
  {
    v2 = 0LL;
    do
    {
      v3 = a2 == v2 + 1;
      *(_BYTE *)(result + v2++) = 0;
    }
    while ( !v3 );
  }
  return result;
}


================================================================================
Function: sub_677C574 (0x677C574)
================================================================================

__int64 __fastcall sub_677C574(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // x8
  char v4; // w9
  char v5; // w10
  unsigned __int8 v7; // [xsp+Ch] [xbp-14h]

  v7 = 0;
  if ( a3 )
  {
    for ( i = 0LL; i != a3; ++i )
    {
      v4 = *(_BYTE *)(a1 + i);
      v5 = *(_BYTE *)(a2 + i);
      v7 |= v5 ^ v4;
    }
  }
  return ((((unsigned int)v7 - 1) >> 8) & 1) - 1;
}


================================================================================
Function: sub_677C5D0 (0x677C5D0)
================================================================================

__int64 __fastcall sub_677C5D0(char *a1, __int64 a2)
{
  char v2; // t1
  unsigned __int8 i; // [xsp+Ch] [xbp-4h]

  for ( i = 0; a2; i |= v2 )
  {
    v2 = *a1++;
    --a2;
  }
  return (((unsigned int)i - 1) >> 8) & 1;
}


================================================================================
Function: sub_677CA08 (0x677CA08)
================================================================================

__int64 __fastcall sub_677CA08(unsigned __int64 a1)
{
  char *v2; // x0
  __int64 v3; // x9
  _QWORD *v4; // x8
  __int64 result; // x0
  int v6; // w10

  if ( dword_6C367E0 == -1 )
    v2 = (char *)sub_677FEB4();
  else
    v2 = (char *)pthread_getspecific(dword_6C367E0);
  if ( !v2 )
    v2 = (char *)&unk_6BDF6C0;
  if ( a1 > 0x400 )
    return sub_6784624();
  v3 = *(_QWORD *)&v2[((a1 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v4 = *(_QWORD **)(v3 + 16);
  if ( !v4 )
    return sub_6784624();
  result = *(_QWORD *)(v3 + 16);
  v6 = *(_DWORD *)(v3 + 24) + 1;
  *(_QWORD *)(v3 + 16) = *v4;
  *(_DWORD *)(v3 + 24) = v6;
  return result;
}


================================================================================
Function: sub_677CB8C (0x677CB8C)
================================================================================

__int64 __fastcall sub_677CB8C(__int64 a1, __int64 a2)
{
  void *v4; // x0

  if ( dword_6C367E0 == -1 )
    v4 = (void *)sub_677FEB4();
  else
    v4 = pthread_getspecific(dword_6C367E0);
  if ( !v4 )
    v4 = &unk_6BDF6C0;
  return sub_677D0B4(v4, a1, a2, 0LL);
}


================================================================================
Function: sub_677CBEC (0x677CBEC)
================================================================================

unsigned __int64 __fastcall sub_677CBEC(unsigned __int64 result)
{
  _QWORD *v1; // x3
  __int64 v2; // x9
  __int64 v3; // x1
  int v4; // w8
  __int64 v5; // x9

  if ( result )
  {
    v1 = (_QWORD *)result;
    result = (result - 1) & 0xFFFFFFFFFE000000LL;
    v2 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    v3 = result
       + 80 * (((unsigned __int64)v1 - result) >> 16)
       - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
       + 264;
    if ( *(_QWORD *)(result + 256) != v2
      || *(_BYTE *)(result
                  + 80 * (((unsigned __int64)v1 - result) >> 16)
                  - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
                  + 278) )
    {
      return sub_677CF08();
    }
    else
    {
      v4 = *(_DWORD *)(result
                     + 80 * (((unsigned __int64)v1 - result) >> 16)
                     - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
                     + 288);
      v5 = *(_QWORD *)(result
                     + 80 * (((unsigned __int64)v1 - result) >> 16)
                     - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
                     + 296);
      *(_QWORD *)(result
                + 80 * (((unsigned __int64)v1 - result) >> 16)
                - *(unsigned int *)(result + 80 * (((unsigned __int64)v1 - result) >> 16) + 268)
                + 296) = v1;
      --v4;
      *v1 = v5;
      *(_DWORD *)(v3 + 24) = v4;
      if ( !v4 )
        return sub_6784318(v3);
    }
  }
  return result;
}


================================================================================
Function: sub_677CC6C (0x677CC6C)
================================================================================

__int64 __fastcall sub_677CC6C(__int64 result)
{
  unsigned __int64 v1; // x8
  __int64 v2; // [xsp+0h] [xbp-10h] BYREF

  if ( result )
  {
    v1 = ((result - 1) & 0xFFFFFFFFFE000000LL)
       + 80 * ((result - ((result - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
       - *(unsigned int *)((char *)&qword_108[10 * ((result - ((result - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                         + ((result - 1) & 0xFFFFFFFFFE000000LL)
                         + 4);
    if ( (*((_BYTE *)&qword_110 + v1 + 6) & 2) != 0 )
    {
      return sub_677D3B8();
    }
    else
    {
      result = *(unsigned int *)((char *)&dword_124
                               + ((result - 1) & 0xFFFFFFFFFE000000LL)
                               + 80 * ((result - ((result - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
                               - *(unsigned int *)((char *)&qword_108[10
                                                                    * ((result - ((result - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                                                 + ((result - 1) & 0xFFFFFFFFFE000000LL)
                                                 + 4));
      if ( (result & 0x80000000) != 0 )
      {
        sub_6785898((v1 + 263) & 0xFFFFFFFFFE000000LL, v1 + 264, &v2);
        return v2;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_677CD24 (0x677CD24)
================================================================================

// attributes: thunk
__int64 __fastcall sub_677CD24(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_677D9BC(a1, a2, a3);
}


================================================================================
Function: sub_677CD28 (0x677CD28)
================================================================================

__int64 __fastcall sub_677CD28(void *a1, __int64 a2, __int64 a3, char a4)
{
  _QWORD *v4; // x19
  int v5; // w8

  v4 = *(_QWORD **)(a2 + 16);
  if ( !v4 )
    return sub_6784624(a1, a3, a4 & 1, 0LL);
  v5 = *(_DWORD *)(a2 + 24) + 1;
  *(_QWORD *)(a2 + 16) = *v4;
  *(_DWORD *)(a2 + 24) = v5;
  if ( (a4 & 1) != 0 )
  {
    if ( (*(_BYTE *)(a2 + 15) & 1) != 0 )
      *v4 = 0LL;
    else
      memset(v4, 0, *(unsigned int *)(a2 + 28));
  }
  return (__int64)v4;
}


================================================================================
Function: sub_677CDE4 (0x677CDE4)
================================================================================

__int64 __fastcall sub_677CDE4(char *a1, unsigned __int64 a2, char a3, __int64 a4)
{
  __int64 v4; // x8
  _QWORD *v5; // x19
  int v6; // w9
  char v8; // w2

  if ( a2 > 0x400 )
  {
    v8 = a3 & 1;
    return sub_6784624(a1, a2, v8, a4);
  }
  v4 = *(_QWORD *)&a1[((a2 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v5 = *(_QWORD **)(v4 + 16);
  if ( !v5 )
  {
    v8 = a3 & 1;
    a4 = 0LL;
    return sub_6784624(a1, a2, v8, a4);
  }
  v6 = *(_DWORD *)(v4 + 24) + 1;
  *(_QWORD *)(v4 + 16) = *v5;
  *(_DWORD *)(v4 + 24) = v6;
  if ( (a3 & 1) != 0 )
  {
    if ( (*(_BYTE *)(v4 + 15) & 1) != 0 )
      *v5 = 0LL;
    else
      memset(v5, 0, *(unsigned int *)(v4 + 28));
  }
  return (__int64)v5;
}


================================================================================
Function: sub_677CE78 (0x677CE78)
================================================================================

__int64 __fastcall sub_677CE78(char *a1, unsigned __int64 a2, char a3)
{
  __int64 v3; // x8
  _QWORD *v4; // x19
  int v5; // w9

  if ( a2 > 0x400 )
    return sub_6784624(a1, a2, a3 & 1, 0LL);
  v3 = *(_QWORD *)&a1[((a2 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v4 = *(_QWORD **)(v3 + 16);
  if ( !v4 )
    return sub_6784624(a1, a2, a3 & 1, 0LL);
  v5 = *(_DWORD *)(v3 + 24) + 1;
  *(_QWORD *)(v3 + 16) = *v4;
  *(_DWORD *)(v3 + 24) = v5;
  if ( (a3 & 1) != 0 )
  {
    if ( (*(_BYTE *)(v3 + 15) & 1) != 0 )
      *v4 = 0LL;
    else
      memset(v4, 0, *(unsigned int *)(v3 + 28));
  }
  return (__int64)v4;
}


================================================================================
Function: nullsub_285 (0x677CF04)
================================================================================

void nullsub_285()
{
  ;
}


================================================================================
Function: sub_677CF08 (0x677CF08)
================================================================================

__int64 __fastcall sub_677CF08(__int64 result, __int64 a2, char a3, _QWORD *a4)
{
  unsigned __int64 v7; // x8
  __int64 v8; // x22
  int v9; // w8
  unsigned __int64 v10; // [xsp+0h] [xbp-10h] BYREF

  if ( (*(_BYTE *)(a2 + 14) & 2) != 0 )
  {
    result = sub_6785898(result, a2, 0LL);
    v7 = *(unsigned int *)(a2 + 28);
    v8 = result;
    if ( (v7 & 0x80000000) != 0 )
    {
      result = sub_6785898((a2 - 1) & 0xFFFFFFFFFE000000LL, a2, &v10);
      v7 = v10;
    }
    a4 = (_QWORD *)(v8 + ((unsigned __int64)a4 - v8) / v7 * v7);
  }
  if ( (a3 & 1) == 0 )
    return sub_677D2D0(a2, a4);
  *a4 = *(_QWORD *)(a2 + 32);
  v9 = *(_DWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 32) = a4;
  *(_DWORD *)(a2 + 24) = --v9;
  if ( !v9 )
    return sub_6784318(a2);
  if ( (*(_BYTE *)(a2 + 14) & 1) != 0 )
    return sub_6783C70(a2);
  return result;
}


================================================================================
Function: sub_677D008 (0x677D008)
================================================================================

__int64 __fastcall sub_677D008(_QWORD *a1)
{
  __int64 v2; // x19
  char v3; // w20
  int v4; // w8
  __int64 v5; // x9

  v2 = (((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL)
     + 80 * (((unsigned __int64)a1 - (((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
     - *(unsigned int *)((char *)&qword_108[10
                                          * (((unsigned __int64)a1 - (((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                       + (((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL)
                       + 4)
     + 264;
  v3 = sub_6783548(v2, 0LL, 0LL);
  if ( (v3 & 1) != 0 )
  {
    sub_6783734(v2, 0LL);
    v4 = *(_DWORD *)(v2 + 24);
    v5 = *(_QWORD *)(v2 + 32);
    *(_QWORD *)(v2 + 32) = a1;
    --v4;
    *a1 = v5;
    *(_DWORD *)(v2 + 24) = v4;
    if ( v4 )
    {
      if ( (*(_BYTE *)(v2 + 14) & 1) != 0 )
        sub_6783C70(v2);
    }
    else
    {
      sub_6784318(v2);
    }
  }
  return v3 & 1;
}


================================================================================
Function: sub_677D0B4 (0x677D0B4)
================================================================================

_QWORD *__fastcall sub_677D0B4(char *a1, _QWORD *a2, unsigned __int64 a3, char a4)
{
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x23
  __int64 v11; // x8
  unsigned __int64 v12; // x8
  size_t v13; // x2
  __int64 v14; // x9
  __int64 v15; // x1
  int v16; // w8
  char v18; // w2
  _QWORD *v19; // x21
  unsigned __int64 v20; // [xsp+0h] [xbp-10h] BYREF

  if ( a2 )
  {
    v8 = (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
       + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
       - *(unsigned int *)((char *)&qword_108[10
                                            * (((unsigned __int64)a2
                                              - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                         + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                         + 4);
    if ( (*((_BYTE *)&qword_110 + v8 + 6) & 2) != 0 )
    {
      v9 = sub_677D3B8(((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL, (unsigned int *)(v8 + 264), (__int64)a2);
    }
    else
    {
      v9 = *(unsigned int *)((char *)&dword_124
                           + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                           + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
                           - *(unsigned int *)((char *)&qword_108[10
                                                                * (((unsigned __int64)a2
                                                                  - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                                             + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                                             + 4));
      if ( (v9 & 0x80000000) != 0 )
      {
        sub_6785898((v8 + 263) & 0xFFFFFFFFFE000000LL, (unsigned int *)(v8 + 264), &v20);
        v9 = v20;
      }
    }
    if ( a3 - 1 < v9 && v9 >> 1 <= a3 )
      return a2;
    if ( a3 > 0x400 )
      goto LABEL_31;
  }
  else
  {
    v9 = 0LL;
    if ( a3 > 0x400 )
      goto LABEL_31;
  }
  v11 = *(_QWORD *)&a1[((a3 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v19 = *(_QWORD **)(v11 + 16);
  if ( v19 )
  {
    ++*(_DWORD *)(v11 + 24);
    *(_QWORD *)(v11 + 16) = *v19;
    goto LABEL_15;
  }
LABEL_31:
  v19 = (_QWORD *)sub_6784624(a1, a3, 0, 0LL);
  if ( !v19 )
    return v19;
LABEL_15:
  if ( (a4 & 1) != 0 && v9 < a3 )
  {
    v12 = v9 - 8;
    if ( v9 <= 7 )
      v12 = 0LL;
    memset((char *)v19 + v12, 0, a3 - v12);
  }
  else if ( !a3 )
  {
    *(_BYTE *)v19 = 0;
  }
  if ( a2 )
  {
    if ( v9 >= a3 )
      v13 = a3;
    else
      v13 = v9;
    memcpy(v19, a2, v13);
    v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    v15 = (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
        + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
        - *(unsigned int *)((char *)&qword_108[10
                                             * (((unsigned __int64)a2
                                               - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                          + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                          + 4)
        + 264;
    if ( *(__int64 *)((char *)&qword_100 + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) == v14 )
    {
      if ( !*((_BYTE *)&qword_110
            + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
            + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
            - *(unsigned int *)((char *)&qword_108[10
                                                 * (((unsigned __int64)a2
                                                   - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                              + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                              + 4)
            + 6) )
      {
        *a2 = *(__int64 *)((char *)&qword_128
                         + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                         + 80 * (((unsigned __int64)a2 - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
                         - *(unsigned int *)((char *)&qword_108[10
                                                              * (((unsigned __int64)a2
                                                                - (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                                           + (((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL)
                                           + 4));
        v16 = *(_DWORD *)(v15 + 24);
        *(_QWORD *)(v15 + 32) = a2;
        *(_DWORD *)(v15 + 24) = --v16;
        if ( !v16 )
          sub_6784318(v15);
        return v19;
      }
      v18 = 1;
    }
    else
    {
      v18 = 0;
    }
    sub_677CF08(((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL, v15, v18, a2);
  }
  return v19;
}


================================================================================
Function: sub_677D2D0 (0x677D2D0)
================================================================================

__int64 __fastcall sub_677D2D0(__int64 a1, unsigned __int64 a2)
{
  __int64 i; // x21
  unsigned __int64 v5; // x8
  __int64 result; // x0
  unsigned __int64 v7; // x22
  __int64 v8; // x21
  __int64 v9; // x0
  bool v10; // zf
  __int64 v11; // x20

  if ( *(_DWORD *)((char *)&qword_F0 + ((a1 - 1) & 0xFFFFFFFFFE000000LL)) == 1 )
    sub_6786944();
  for ( i = *(_QWORD *)(a1 + 40); ; i = result )
  {
    v5 = i & 0xFFFFFFFFFFFFFFFCLL;
    if ( (i & 3) == 0 )
      break;
    *(_QWORD *)a2 = v5;
    result = sub_67EFFD0(i, i & 3 | a2, a1 + 40);
    if ( result == i )
      return result;
LABEL_6:
    ;
  }
  result = sub_67EFFD0(i, v5 | 1, a1 + 40);
  if ( result != i )
    goto LABEL_6;
  v7 = atomic_load((unsigned __int64 *)(a1 + 48));
  if ( v7 )
  {
    v8 = *(_QWORD *)(v7 + 2840);
    do
    {
      *(_QWORD *)a2 = v8;
      v9 = sub_67EFFD0(v8, a2, v7 + 2840);
      v10 = v9 == v8;
      v8 = v9;
    }
    while ( !v10 );
  }
  v11 = *(_QWORD *)(a1 + 40);
  do
  {
    result = sub_67EFFD0(v11, v11 & 0xFFFFFFFFFFFFFFFCLL | 2, a1 + 40);
    v10 = result == v11;
    v11 = result;
  }
  while ( !v10 );
  return result;
}


================================================================================
Function: sub_677D3B8 (0x677D3B8)
================================================================================

unsigned __int64 __fastcall sub_677D3B8(__int64 a1, unsigned int *a2, __int64 a3)
{
  __int64 v5; // x0
  unsigned __int64 v6; // x8
  __int64 v7; // x22
  unsigned __int64 v8; // x20
  unsigned __int64 v10; // [xsp+0h] [xbp-10h] BYREF

  v5 = sub_6785898(a1, a2, 0LL);
  v6 = a2[7];
  v7 = v5;
  if ( (v6 & 0x80000000) != 0 )
  {
    sub_6785898(((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL, a2, &v10);
    v6 = a2[7];
    v8 = (a3 - v7) % v10;
    if ( (v6 & 0x80000000) != 0 )
    {
      sub_6785898(((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL, a2, &v10);
      v6 = v10;
    }
  }
  else
  {
    v8 = (a3 - v5) % v6;
  }
  return v6 - v8;
}


================================================================================
Function: sub_677D480 (0x677D480)
================================================================================

__int64 __fastcall sub_677D480(unsigned __int64 a1, unsigned __int64 a2)
{
  __int64 v2; // x9
  _QWORD *v3; // x8
  int v4; // w10
  char *v7; // x0
  uint8x8_t v8; // d0
  uint8x8_t v9; // d0
  __int64 v10; // x1
  __int64 v11; // x8
  __int64 result; // x0

  if ( dword_6C367E0 == -1 )
    v7 = (char *)sub_677FEB4();
  else
    v7 = (char *)pthread_getspecific(dword_6C367E0);
  v8.n64_u64[0] = vcnt_s8((int8x8_t)a2).n64_u64[0];
  if ( !v7 )
    v7 = (char *)&unk_6BDF6C0;
  v8.n64_u16[0] = vaddlv_u8(v8);
  if ( v8.n64_u32[0] != 1LL )
    return 0LL;
  if ( a1 <= 0x400 )
  {
    v9.n64_u64[0] = vcnt_s8((int8x8_t)a1).n64_u64[0];
    v9.n64_u16[0] = vaddlv_u8(v9);
    if ( v9.n64_u32[0] <= 1uLL && a1 >= a2 )
    {
      v2 = *(_QWORD *)&v7[((a1 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
      v3 = *(_QWORD **)(v2 + 16);
      if ( !v3 )
        return sub_6784624(v7, a1, 0, 0LL);
      result = *(_QWORD *)(v2 + 16);
      v4 = *(_DWORD *)(v2 + 24) + 1;
      *(_QWORD *)(v2 + 16) = *v3;
      *(_DWORD *)(v2 + 24) = v4;
      return result;
    }
  }
  if ( (a1 & 0x8000000000000000LL) != 0 || !a2 )
    return 0LL;
  if ( a1 > 0x400 )
    return sub_677D868(v7, a1, a2, 0LL, 0LL);
  if ( a1 < a2 )
    return sub_677D868(v7, a1, a2, 0LL, 0LL);
  v10 = *(_QWORD *)&v7[((a1 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8];
  v11 = *(_QWORD *)(v10 + 16);
  if ( !v11 || ((a2 - 1) & v11) != 0 )
    return sub_677D868(v7, a1, a2, 0LL, 0LL);
  else
    return sub_677CD28(v7, v10, a1, 0);
}


================================================================================
Function: sub_677D868 (0x677D868)
================================================================================

__int64 __fastcall sub_677D868(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, char a5)
{
  unsigned __int64 v8; // x23
  __int64 v10; // x0
  __int64 v11; // x1
  char v12; // w24
  unsigned __int64 v13; // x8
  void *v14; // x21
  unsigned __int64 v15; // x9
  size_t v16; // x0
  __int64 v17; // x0

  v8 = a3 - 1;
  if ( a4 )
  {
    if ( a3 > 0x1000000 )
      return 0LL;
  }
  else
  {
    if ( a2 <= 0x80 && a3 <= a2 && (v8 & a2) == 0 )
      return sub_677CE78(a1, a2, a5 & 1);
    if ( a3 > 0x1000000 )
    {
      if ( a2 <= 0x401 )
        a2 = 1025LL;
      v17 = sub_677CDE4(a1, a2, 0LL, a3);
      if ( !v17 )
        return 0LL;
      v11 = v17;
      v12 = 0;
LABEL_11:
      if ( ((v11 + a4) & v8) != 0 )
        v13 = a3 - ((v11 + a4) & v8);
      else
        v13 = 0LL;
      v14 = (void *)(v13 + v11);
      if ( v13 )
      {
        v15 = ((v11 - 1) & 0xFFFFFFFFFE000000LL)
            + 80 * ((v11 - ((v11 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)
            - *(unsigned int *)((char *)&qword_108[10 * ((v11 - ((v11 - 1) & 0xFFFFFFFFFE000000LL)) >> 16)]
                              + ((v11 - 1) & 0xFFFFFFFFFE000000LL)
                              + 4);
        *(_BYTE *)(v15 + 278) = *((_BYTE *)&qword_110 + v15 + 6) | 2;
        nullsub_285(v15 + 264);
      }
      if ( !(v12 & 1 | ((a5 & 1) == 0)) )
      {
        v16 = sub_677CC6C((__int64)v14);
        memset(v14, 0, v16);
      }
      return (__int64)v14;
    }
  }
  v10 = sub_677CE78(a1, v8 + a2, a5 & 1);
  if ( v10 )
  {
    v11 = v10;
    v12 = 1;
    goto LABEL_11;
  }
  return 0LL;
}


================================================================================
Function: sub_677D9B8 (0x677D9B8)
================================================================================

// attributes: thunk
__int64 __fastcall sub_677D9B8(__int64 a1)
{
  return sub_677CC6C(a1);
}


================================================================================
Function: sub_677D9BC (0x677D9BC)
================================================================================

__int64 __fastcall sub_677D9BC(__int64 *a1, __int64 a2, __int64 a3)
{
  uint8x8_t v3; // d0
  __int64 result; // x0
  __int64 v9; // x0
  __int64 v10; // x8

  v3.n64_u64[0] = vcnt_s8((int8x8_t)a2).n64_u64[0];
  v3.n64_u16[0] = vaddlv_u8(v3);
  if ( v3.n64_u32[0] != 1LL || a1 == 0LL || (a2 & 7) != 0 )
    return 22LL;
  v9 = sub_677D480(a3);
  v10 = v9;
  if ( a3 && !v9 )
    return 12LL;
  result = 0LL;
  *a1 = v10;
  return result;
}


================================================================================
Function: sub_677DA34 (0x677DA34)
================================================================================

__int64 __fastcall sub_677DA34(__int64 result, int a2)
{
  __int64 v2; // x19
  __int64 v4; // x0
  int v5; // w23
  __int64 i; // x21
  __int64 v7; // x0
  __int64 v8; // x23
  __int64 j; // x24
  __int64 v10; // x8
  unsigned __int64 v11; // x26
  __int64 v12; // x21
  unsigned __int64 v13; // x22
  unsigned __int64 v14; // x0
  __int64 v15; // x0

  if ( !result )
    return result;
  v2 = result;
  if ( (_UNKNOWN *)result == &unk_6BDF6C0 )
    return result;
  v4 = sub_67845BC(result, a2 != 0);
  if ( a2 != 1 )
  {
    if ( a2 == 2 )
    {
      if ( *(_QWORD *)(v2 + 3024) )
      {
        for ( i = 0LL; i != 75; ++i )
        {
          v7 = *(_QWORD *)(v2 + 24 * i + 1040);
          if ( v7 )
          {
            do
            {
              v8 = *(_QWORD *)(v7 + 56);
              sub_67834F8();
              v7 = v8;
            }
            while ( v8 );
          }
        }
      }
      v5 = 1;
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  if ( (sub_677FFE4(v4) & 1) == 0 || *(_QWORD *)(*(_QWORD *)v2 + 16LL) != v2 || *(_BYTE *)(v2 + 3056) )
  {
LABEL_15:
    v5 = 0;
    goto LABEL_17;
  }
  sub_6785F34(v2, *(_QWORD *)v2 + 32LL);
  v5 = 0;
LABEL_17:
  sub_6783B08(v2);
  sub_67844A0(v2, a2 != 0);
  if ( *(_QWORD *)(v2 + 3024) )
  {
    for ( j = 0LL; j != 75; ++j )
    {
      v10 = v2 + 24 * j;
      v11 = *(_QWORD *)(v10 + 1040);
      if ( v11 )
      {
        v12 = v10 + 1040;
        do
        {
          v13 = v11;
          v14 = v11;
          v11 = *(_QWORD *)(v11 + 56);
          sub_6783734(v14, a2 != 0);
          if ( *(_DWORD *)(v13 + 24) )
          {
            if ( v5 )
              sub_6784080(v13, v12);
          }
          else
          {
            sub_67842B8(v13, v12, a2 != 0);
          }
        }
        while ( v11 );
      }
    }
  }
  result = sub_678630C(v2, a2 == 1, *(_QWORD *)v2 + 32LL);
  if ( a2 )
  {
    v15 = nullsub_286(*(_QWORD *)v2 + 32LL);
    result = sub_677FFE4(v15);
    if ( (result & 1) != 0 && *(_QWORD *)(*(_QWORD *)v2 + 16LL) == v2 )
    {
      sub_677FF28();
      return sub_677E854(1LL, 1LL, *(_QWORD *)v2 + 960LL);
    }
  }
  return result;
}


================================================================================
Function: sub_677DC2C (0x677DC2C)
================================================================================

__int64 __fastcall sub_677DC2C(__int64 a1, char a2)
{
  return sub_677DA34(a1, a2 & 1);
}


================================================================================
Function: sub_677DC88 (0x677DC88)
================================================================================

void *sub_677DC88()
{
  void *result; // x0

  sub_6780018();
  if ( dword_6C367E0 == -1 )
    result = sub_677FEB4();
  else
    result = pthread_getspecific(dword_6C367E0);
  if ( !result )
    return &unk_6BDF6C0;
  return result;
}


================================================================================
Function: sub_677DCCC (0x677DCCC)
================================================================================

__int64 __fastcall sub_677DCCC(__int64 a1)
{
  return sub_6785068(a1 + 2888);
}


================================================================================
Function: sub_677DCD4 (0x677DCD4)
================================================================================

__int64 __fastcall sub_677DCD4(__int64 a1, __int128 *a2)
{
  __int128 v2; // q0
  __int64 v3; // x8
  __int64 v4; // x1
  __int128 v6; // [xsp+0h] [xbp-20h] BYREF
  __int64 v7; // [xsp+10h] [xbp-10h]

  v2 = *a2;
  v3 = *((_QWORD *)a2 + 2);
  v4 = *(unsigned int *)(a1 + 2856);
  v6 = v2;
  v7 = v3;
  return sub_677E0B4(&v6, v4) & 1;
}


================================================================================
Function: sub_677E0B4 (0x677E0B4)
================================================================================

bool __fastcall sub_677E0B4(__int64 a1, int a2)
{
  if ( *(_DWORD *)(a1 + 20) == 6 )
    return *(_DWORD *)(a1 + 8) == a2 || (a2 | *(unsigned __int8 *)(a1 + 12)) == 0;
  else
    return a2 == 0;
}


================================================================================
Function: sub_677E0F0 (0x677E0F0)
================================================================================

const void *__fastcall sub_677E0F0(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        char a4,
        char a5,
        int a6,
        _QWORD *a7,
        __int64 a8)
{
  unsigned int v16; // w26
  const void *result; // x0
  _BOOL8 v18; // x0
  unsigned __int64 v19; // x27
  __int64 v20; // x0
  char v21; // w0
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x27
  char v26; // w0
  int v27; // w8
  unsigned __int64 v28; // x0
  int v29; // w8
  _DWORD *v30; // x8
  unsigned __int64 v31; // [xsp+8h] [xbp-18h]
  int v32; // [xsp+14h] [xbp-Ch] BYREF

  *a7 = 0LL;
  a7[1] = 0LL;
  a7[2] = 0LL;
  if ( qword_7292288 == 1 )
  {
    v16 = 0;
    if ( !(a1 >> 24) )
      goto LABEL_35;
  }
  else
  {
    v16 = sub_678323C();
    if ( !(a1 >> 24) )
      goto LABEL_35;
  }
  if ( a2 > 0x2000000 || a3 )
  {
LABEL_35:
    v18 = sub_67814F4(0x11u);
    if ( a6 || v18 )
      goto LABEL_39;
LABEL_37:
    if ( a3 )
      return sub_67829A8(a1, a2, a3, a4 & 1, a5 & 1, a7);
    else
      return sub_67824BC(a1, a2, a4 & 1, a5 & 1, (__int64)a7);
  }
  result = (const void *)sub_677E394(v16, a1, a4 & 1, a5 & 1, a6, (__int64)a7, a8);
  if ( result )
    return result;
  if ( a6 )
  {
    v18 = sub_67814F4(0x11u);
LABEL_39:
    v30 = (_DWORD *)__errno(v18);
    result = 0LL;
    *v30 = 12;
    return result;
  }
  v32 = 0;
  if ( sub_6780B10() )
    goto LABEL_20;
  v19 = atomic_load((unsigned __int64 *)&qword_7289EC0);
  if ( v19 > 0x6C )
    goto LABEL_20;
  v20 = sub_6781470(0x17u);
  if ( !v20 )
    goto LABEL_20;
  v31 = v20;
  v21 = sub_6781EFC();
  v22 = v31 >> 2;
  if ( (v21 & 1) != 0 )
    v22 = v31;
  v23 = v19 >> 3;
  v24 = v22 + 0x1FFFFFF;
  if ( v19 <= 7 )
    LOBYTE(v23) = 0;
  v25 = (v24 & 0xFFFFFFFFFE000000LL) << v23;
  if ( v25 < a1 )
    goto LABEL_20;
  v26 = sub_6780DEC(4u) == 2 ? sub_6781EF0() : sub_6780DEC(4u) == 1;
  if ( (unsigned int)sub_677EFCC(v25, v26 & 1, a5 & 1, 0, &v32) )
    goto LABEL_20;
  v27 = v32 - 1;
  if ( v32 < 1 )
    v27 = 112;
  if ( (v28 = atomic_load(&qword_7289B40[v27])) == 0
    || (a5 & 1) == 0 && *(_BYTE *)(v28 + 93)
    || *(_DWORD *)v28 && *(_BYTE *)(v28 + 92)
    || (v16 & 0x80000000) == 0 && (v29 = *(_DWORD *)(v28 + 88), (v29 & 0x80000000) == 0) && v29 != v16
    || (result = (const void *)sub_677F358((int *)v28, (a1 + 0x1FFFFFF) >> 25, a4 & 1, (__int64)a7)) == 0LL )
  {
LABEL_20:
    v18 = sub_67814F4(0x11u);
    if ( v18 )
      goto LABEL_39;
    goto LABEL_37;
  }
  return result;
}


================================================================================
Function: sub_677E394 (0x677E394)
================================================================================

__int64 __fastcall sub_677E394(unsigned int a1, __int64 a2, char a3, char a4, int a5, __int64 a6, __int64 a7)
{
  unsigned __int64 v7; // x26
  __int64 result; // x0
  unsigned __int64 v15; // x8
  __int64 v16; // x25
  __int64 v17; // x25

  v7 = qword_7289EC0;
  if ( !qword_7289EC0 )
    return 0LL;
  if ( a5 )
  {
    LODWORD(v15) = a5 - 1;
    if ( a5 >= 1 )
      v15 = (unsigned int)v15;
    else
      v15 = 112LL;
    if ( qword_7289EC0 <= v15 )
      return 0LL;
    result = sub_677E4C4((unsigned int)a5, 1LL, a1, a2, a3 & 1, a4 & 1, (unsigned int)a5, a6, a7);
    if ( !result )
      return 0LL;
  }
  else
  {
    v16 = 0LL;
    while ( 1 )
    {
      result = sub_677E4C4((unsigned int)++v16, 1LL, a1, a2, a3 & 1, a4 & 1, 0LL, a6, a7);
      if ( result )
        break;
      if ( v7 == v16 )
      {
        if ( (a1 & 0x80000000) != 0 )
          return 0LL;
        v17 = 0LL;
        if ( v7 <= 1 )
          v7 = 1LL;
        while ( 1 )
        {
          result = sub_677E4C4((unsigned int)++v17, 0LL, a1, a2, a3 & 1, a4 & 1, 0LL, a6, a7);
          if ( result )
            break;
          if ( v7 == v17 )
            return 0LL;
        }
        return result;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_677E4C4 (0x677E4C4)
================================================================================

unsigned __int64 __fastcall sub_677E4C4(int a1, char a2, int a3, __int64 a4, char a5, char a6, int a7, __int64 a8)
{
  int v8; // w8
  unsigned __int64 v9; // x0

  v8 = a1 - 1;
  if ( a1 < 1 )
    v8 = 112;
  v9 = atomic_load(&qword_7289B40[v8]);
  if ( v9
    && ((a6 & 1) != 0 || !*(_BYTE *)(v9 + 93))
    && (*(_DWORD *)v9 == a7 || (a7 | *(unsigned __int8 *)(v9 + 92)) == 0) )
  {
    if ( a7 )
      return sub_677F358((int *)v9, (unsigned __int64)(a4 + 0x1FFFFFF) >> 25, a5 & 1, a8);
    if ( a3 < 0 )
    {
      if ( (a2 & 1) != 0 )
        return sub_677F358((int *)v9, (unsigned __int64)(a4 + 0x1FFFFFF) >> 25, a5 & 1, a8);
    }
    else if ( (a2 & 1) != 0 )
    {
      if ( *(int *)(v9 + 88) < 0 || *(_DWORD *)(v9 + 88) == a3 )
        return sub_677F358((int *)v9, (unsigned __int64)(a4 + 0x1FFFFFF) >> 25, a5 & 1, a8);
    }
    else if ( *(int *)(v9 + 88) >= 0 && *(_DWORD *)(v9 + 88) != a3 )
    {
      return sub_677F358((int *)v9, (unsigned __int64)(a4 + 0x1FFFFFF) >> 25, a5 & 1, a8);
    }
  }
  return 0LL;
}


================================================================================
Function: sub_677E570 (0x677E570)
================================================================================

__int64 __fastcall sub_677E570(
        __int64 result,
        __int64 a2,
        unsigned __int64 a3,
        __int64 *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  int v10; // w8
  __int64 v13; // x19
  __int64 v15; // x8
  int v16; // w8
  unsigned __int64 v17; // x23
  bool v18; // vf
  int v19; // w8
  unsigned __int64 v20; // x24
  unsigned __int64 v21; // x1
  __int64 v22; // x4
  __int64 v23; // x5
  __int64 v24; // x6
  __int64 v25; // x7
  __int128 v26; // q0
  __int64 v27; // x8
  const char *v28; // x1
  __int128 v29; // [xsp+0h] [xbp-20h] BYREF
  __int64 v30; // [xsp+10h] [xbp-10h]

  if ( result && a2 )
  {
    v10 = *((_DWORD *)a4 + 5);
    v13 = result;
    if ( (unsigned int)(v10 - 3) > 2 )
    {
      if ( v10 == 6 )
      {
        v16 = *((_DWORD *)a4 + 2);
        v17 = *a4;
        v18 = __OFSUB__(v16, 1);
        v19 = v16 - 1;
        if ( v19 < 0 != v18 )
          v19 = 112;
        v20 = atomic_load(&qword_7289B40[v19]);
        if ( v20 )
        {
          v21 = *(_QWORD *)(v20 + 48);
          if ( v21 > v17 >> 6 )
          {
            if ( !*(_BYTE *)(v20 + 24) && *(_QWORD *)(v20 + 120) )
            {
              if ( a3 != a2 )
              {
                ((void (*)(void))sub_677FB88)();
                if ( a3 )
                  sub_67886E8(a5 + 96, a3);
              }
              sub_677E774(v20, v17, (unsigned __int64)(a2 + 0x1FFFFFF) >> 25, a5);
              v21 = *(_QWORD *)(v20 + 48);
            }
            if ( (sub_677FB88(v20 + 136, v21, (unsigned __int64)(a2 + 0x1FFFFFF) >> 25, v17) & 1) == 0 )
              return sub_6781A58(
                       11LL,
                       "trying to free an already freed arena block: %p, size %zu\n",
                       v13,
                       a2,
                       v22,
                       v23,
                       v24,
                       v25,
                       a9);
            return sub_677E854(0LL, 0LL, a5);
          }
          v26 = *(_OWORD *)a4;
          v27 = a4[2];
          v28 = "trying to free from non-existent arena block: %p, size %zu, memid: 0x%zx\n";
        }
        else
        {
          v26 = *(_OWORD *)a4;
          v27 = a4[2];
          v28 = "trying to free from non-existent arena: %p, size %zu, memid: 0x%zx\n";
        }
        *((_QWORD *)&v29 + 1) = *((_QWORD *)&v26 + 1);
        v30 = v27;
        return sub_6781A58(22LL, v28, result, a2, (__int64)&v29, a6, a7, a8, v26);
      }
    }
    else
    {
      if ( a3 != a2 )
      {
        if ( a3 )
          sub_67886E8(a5 + 96, a3);
      }
      v15 = a4[2];
      v29 = *(_OWORD *)a4;
      v30 = v15;
      sub_67822B8(v13, a2, &v29, a5);
    }
    return sub_677E854(0LL, 0LL, a5);
  }
  return result;
}


================================================================================
Function: sub_677E774 (0x677E774)
================================================================================

__int64 __fastcall sub_677E774(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v8; // x23
  __int64 result; // x0
  unsigned __int64 v10; // x23

  v8 = sub_6780DEC(15LL);
  result = sub_6780DEC(24LL);
  v10 = result * v8;
  if ( (v10 & 0x8000000000000000LL) == 0 )
  {
    if ( sub_6780B10() || !v10 )
    {
      return sub_677F4F8(a1, a2, a3, a4);
    }
    else
    {
      if ( *(_QWORD *)(a1 + 104) )
        sub_67F04A0(v10 / 0xA, (atomic_ullong *)(a1 + 104));
      else
        atomic_store(sub_6789348() + v10, (unsigned __int64 *)(a1 + 104));
      return sub_677FC94(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 48), a3, a2, 0LL);
    }
  }
  return result;
}


================================================================================
Function: sub_677E854 (0x677E854)
================================================================================

__int64 __fastcall sub_677E854(int a1, char a2, __int64 a3)
{
  __int64 result; // x0
  __int64 v6; // x20
  unsigned __int64 v7; // x19
  bool v8; // zf
  int v9; // w21
  __int64 v10; // x23
  __int64 v11; // x24
  __int64 v12; // x25
  unsigned __int64 v13; // x22
  unsigned __int64 v14; // x8
  char v15; // w26
  unsigned __int64 v16; // x28
  unsigned __int64 v17; // x23
  unsigned __int64 v18; // x20
  unsigned __int64 v19; // x19
  int v20; // w12
  unsigned __int64 v21; // x24
  unsigned __int64 v22; // x21
  unsigned __int64 v23; // x25
  unsigned __int64 v24; // x27
  unsigned __int64 v25; // x28
  unsigned __int64 v26; // x26
  char v27; // w10
  unsigned __int64 v28; // x0
  unsigned __int64 v29; // x25
  unsigned __int64 v30; // x22
  int v31; // w23
  int v32; // w12
  __int64 v33; // x23
  __int64 v34; // x24
  __int64 v35; // x0
  unsigned __int64 v36; // [xsp+0h] [xbp-50h]
  int v37; // [xsp+Ch] [xbp-44h]
  unsigned __int64 v38; // [xsp+10h] [xbp-40h]
  __int64 v39; // [xsp+18h] [xbp-38h]
  __int64 v40; // [xsp+20h] [xbp-30h]
  unsigned __int64 v41; // [xsp+28h] [xbp-28h]
  char v42; // [xsp+34h] [xbp-1Ch]
  __int64 v44; // [xsp+48h] [xbp-8h]

  result = sub_6780B10();
  if ( (result & 1) == 0 )
  {
    v6 = sub_6780DEC(15LL);
    result = sub_6780DEC(24LL);
    if ( result * v6 >= 1 )
    {
      v7 = atomic_load((unsigned __int64 *)&qword_7289EC0);
      if ( v7 )
      {
        result = sub_67F0010(0LL, 1uLL, (atomic_ullong *)&qword_7289EC8);
        if ( !result )
        {
          v8 = (a2 & 1) == 0;
          v9 = a1 ^ 1;
          if ( v8 )
            v10 = 1LL;
          else
            v10 = v7;
          result = sub_6789348();
          v11 = result;
          v12 = 0LL;
          while ( 1 )
          {
            v13 = atomic_load(&qword_7289B40[v12]);
            if ( v13 )
            {
              if ( !*(_BYTE *)(v13 + 24) )
              {
                if ( *(_QWORD *)(v13 + 128) )
                {
                  result = *(_QWORD *)(v13 + 104);
                  if ( result )
                  {
                    if ( ((unsigned __int8)v9 & (result > v11)) == 0 )
                    {
                      result = sub_67F0010(result, 0LL, (atomic_ullong *)(v13 + 104));
                      v14 = *(_QWORD *)(v13 + 48);
                      if ( v14 )
                      {
                        v36 = v10;
                        v15 = 0;
                        v16 = 0LL;
                        v17 = v13 + 136;
                        v39 = v12;
                        v40 = v11;
                        v37 = v9;
                        v38 = v7;
                        v42 = 1;
                        do
                        {
                          v18 = *(_QWORD *)(*(_QWORD *)(v13 + 128) + 8 * v16);
                          if ( v18 )
                          {
                            v19 = 0LL;
                            v41 = v16;
                            v44 = v16 << 6;
                            do
                            {
                              v21 = 0LL;
                              while ( ((v18 >> ((unsigned __int8)v19 + (unsigned __int8)v21)) & 1) != 0 )
                              {
                                ++v21;
                                if ( v19 + v21 == 64 )
                                {
                                  v21 = 64 - v19;
                                  break;
                                }
                              }
                              if ( v21 )
                              {
                                v22 = v21 + v19;
                                v23 = v19 + v44;
                                while ( 1 )
                                {
                                  result = sub_677F6A4(v17, *(_QWORD *)(v13 + 48), v21, v23);
                                  if ( (result & 1) != 0 )
                                    break;
                                  --v21;
                                  --v22;
                                  if ( !v21 )
                                    goto LABEL_24;
                                }
                                v24 = v19 + v21;
                                v18 = atomic_load((unsigned __int64 *)(*(_QWORD *)(v13 + 128) + 8 * v16));
                                if ( v19 + v21 <= v19 )
                                {
                                  LOBYTE(v20) = 0;
                                }
                                else
                                {
                                  v20 = 0;
                                  v25 = v19;
                                  do
                                  {
                                    v26 = 0LL;
                                    if ( v24 > v25 )
                                    {
                                      v27 = v25;
                                      while ( ((v18 >> v27) & 1) != 0 )
                                      {
                                        ++v26;
                                        ++v27;
                                        if ( v22 - v25 == v26 )
                                        {
                                          v26 = v24 - v25;
                                          break;
                                        }
                                      }
                                      if ( v26 )
                                      {
                                        v28 = v13;
                                        v29 = v13;
                                        v30 = v17;
                                        v31 = v20;
                                        sub_677F4F8(v28, v25 + v44, v26, a3);
                                        v32 = v31;
                                        v17 = v30;
                                        v13 = v29;
                                        v23 = v19 + v44;
                                        v20 = (v26 == v21) | v32;
                                      }
                                    }
                                    v25 += v26 + 1;
                                  }
                                  while ( v25 < v24 );
                                }
                                v42 &= v20;
                                result = sub_677F5E0(v17, *(_QWORD *)(v13 + 48), v21, v23);
                                v15 = 1;
                                v16 = v41;
                              }
LABEL_24:
                              v19 += v21 + 1;
                            }
                            while ( v19 < 0x40 );
                            v14 = *(_QWORD *)(v13 + 48);
                          }
                          ++v16;
                        }
                        while ( v16 < v14 );
                        if ( (v42 & 1) == 0 )
                        {
                          v33 = sub_6780DEC(15LL);
                          v34 = sub_6780DEC(24LL);
                          v35 = sub_6789348();
                          result = sub_67F0010(0LL, v35 + v34 * v33, (atomic_ullong *)(v13 + 104));
                        }
                        v7 = v38;
                        v9 = v37;
                        v10 = v36;
                        if ( (v15 & 1) != 0 )
                        {
                          v12 = v39;
                          v11 = v40;
                          if ( v36 < 2 )
                          {
LABEL_49:
                            atomic_store(0LL, &qword_7289EC8);
                            return result;
                          }
                          v10 = v36 - 1;
                        }
                        else
                        {
                          v12 = v39;
                          v11 = v40;
                        }
                      }
                    }
                  }
                }
              }
            }
            if ( ++v12 == v7 )
              goto LABEL_49;
          }
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_677EFCC (0x677EFCC)
================================================================================

__int64 __fastcall sub_677EFCC(__int64 a1, char a2, char a3, char a4, _DWORD *a5)
{
  unsigned __int64 v8; // x19
  __int64 v9; // x0
  int v10; // w24
  __int64 v11; // x23
  const char *v12; // x2
  __int128 v14; // [xsp+0h] [xbp-40h] BYREF
  __int64 v15; // [xsp+10h] [xbp-30h]
  __int128 v16; // [xsp+20h] [xbp-20h] BYREF
  __int64 v17; // [xsp+30h] [xbp-10h]

  if ( a5 )
    *a5 = 0;
  v8 = (a1 + 0x1FFFFFF) & 0xFFFFFFFFFE000000LL;
  v9 = sub_67824BC(v8, 0x2000000LL, a2 & 1, a3 & 1, &v16, &unk_7289F00);
  if ( !v9 )
    return 12LL;
  v10 = (unsigned __int8)v17;
  v11 = v9;
  v14 = v16;
  v15 = v17;
  if ( (((__int64 (__fastcall *)(__int64, unsigned __int64, _QWORD, __int64, _QWORD, __int128 *, _DWORD *))sub_677ED80)(
          v9,
          v8,
          (unsigned __int8)v17,
          0xFFFFFFFFLL,
          a4 & 1,
          &v14,
          a5) & 1) == 0 )
  {
    v14 = v16;
    v15 = v17;
    sub_67820FC(v11, v8, a2 & 1, &v14);
    sub_6780E3C("failed to reserve %zu k memory\n", v8 >> 10);
    return 12LL;
  }
  if ( v10 )
    v12 = " (in large os pages)";
  else
    v12 = &byte_CBCB6C;
  sub_6780E3C("reserved %zu KiB memory%s\n", v8 >> 10, v12);
  return 0LL;
}


================================================================================
Function: sub_677F124 (0x677F124)
================================================================================

__int64 __fastcall sub_677F124(__int64 a1, unsigned int a2, __int64 a3, char a4, _DWORD *a5)
{
  unsigned __int64 v9; // x23
  unsigned __int64 v10; // x0
  unsigned int v11; // w23
  __int64 v12; // x0
  __int64 v13; // x22
  __int64 v14; // x7
  __int128 v16; // [xsp+0h] [xbp-50h] BYREF
  __int64 v17; // [xsp+10h] [xbp-40h]
  __int128 v18; // [xsp+20h] [xbp-30h] BYREF
  __int64 v19; // [xsp+30h] [xbp-20h]
  size_t v20; // [xsp+38h] [xbp-18h] BYREF
  __int64 v21; // [xsp+40h] [xbp-10h] BYREF

  if ( a5 )
    *a5 = -1;
  if ( !a1 )
    return 0LL;
  if ( (a2 & 0x80000000) != 0 )
  {
    v11 = -1;
  }
  else
  {
    v9 = a2;
    v10 = qword_7292288;
    if ( !qword_7292288 )
      v10 = sub_67831DC();
    v11 = v9 % v10;
  }
  v20 = 0LL;
  v21 = 0LL;
  v12 = sub_6782EE8(a1, v11, a3, &v20, &v21, &v18);
  if ( v12 && v20 )
  {
    v13 = v12;
    sub_6780E3C((__int64)"numa node %i: reserved %zu GiB huge pages (of the %zu GiB requested)\n", v11, v20, a1);
    v16 = v18;
    v17 = v19;
    if ( (((__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD, _QWORD, __int128 *, _DWORD *, __int64))sub_677ED80)(
            v13,
            v21,
            1LL,
            v11,
            a4 & 1,
            &v16,
            a5,
            v14) & 1) != 0 )
      return 0LL;
    v16 = v18;
    v17 = v19;
    sub_67822B8(v13, v21, &v16);
  }
  else
  {
    sub_6781928((signed __int64)"failed to reserve %zu GiB huge pages\n", a1);
  }
  return 12LL;
}


================================================================================
Function: sub_677F288 (0x677F288)
================================================================================

__int64 __fastcall sub_677F288(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_677F124(a1, a2, a3, 0LL, 0LL);
}


================================================================================
Function: sub_677F294 (0x677F294)
================================================================================

__int64 __fastcall sub_677F294(__int64 result, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // x19
  unsigned __int64 v5; // x20
  unsigned __int64 v6; // x23
  unsigned __int64 v7; // x24
  unsigned __int64 v8; // x25
  __int64 v9; // x21
  unsigned __int64 v10; // x22
  unsigned __int64 v11; // x8
  bool v12; // cc

  if ( result )
  {
    v4 = result;
    if ( !a2 )
    {
      a2 = qword_7292288;
      if ( !qword_7292288 )
        a2 = sub_67831DC();
    }
    v5 = 0LL;
    if ( a2 )
      v6 = a2;
    else
      v6 = 1LL;
    v7 = v4 / v6;
    v8 = v4 % v6;
    if ( a3 )
      v9 = a3 / v6 + 50;
    else
      v9 = 0LL;
    do
    {
      if ( v5 >= v8 )
        v10 = v7;
      else
        v10 = v7 + 1;
      result = sub_677F124(v10, (unsigned int)v5, v9, 0LL, 0LL);
      if ( (_DWORD)result )
        break;
      v11 = v4 - v10;
      ++v5;
      if ( v4 < v10 )
        v11 = 0LL;
      if ( v5 >= v6 )
        break;
      v12 = v4 > v10;
      v4 = v11;
    }
    while ( v12 );
  }
  return result;
}


================================================================================
Function: sub_677F358 (0x677F358)
================================================================================

unsigned __int64 __fastcall sub_677F358(int *a1, unsigned __int64 a2, char a3, __int64 a4)
{
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x22
  unsigned __int64 v10; // x26
  int v11; // w8
  unsigned __int64 v12; // x3
  char v13; // w9
  __int64 v14; // x0
  __int64 v15; // x0
  __int64 v16; // x0
  unsigned __int64 v17; // x3
  bool v18; // w8
  _BYTE v20[4]; // [xsp+8h] [xbp-18h] BYREF
  _BYTE v21[4]; // [xsp+Ch] [xbp-14h] BYREF
  unsigned __int64 v22; // [xsp+10h] [xbp-10h] BYREF

  v8 = 0LL;
  if ( (sub_677F728(a1 + 34, *((_QWORD *)a1 + 6), 0LL, a2, &v22) & 1) == 0 )
    return v8;
  v9 = v22;
  *((_QWORD *)a1 + 12) = v22 >> 6;
  v10 = atomic_load((unsigned __int64 *)a1 + 4);
  v11 = *a1;
  v12 = v22;
  v13 = *((_BYTE *)a1 + 92);
  *(_DWORD *)(a4 + 13) = 0;
  *(_DWORD *)(a4 + 8) = v11;
  *(_QWORD *)a4 = v12;
  *(_BYTE *)(a4 + 12) = v13;
  *(_QWORD *)(a4 + 16) = 0x600000000LL;
  *(_BYTE *)(a4 + 16) = *((_BYTE *)a1 + 24);
  v14 = *((_QWORD *)a1 + 16);
  if ( v14 )
    sub_677FB88(v14, *((_QWORD *)a1 + 6), a2, v12);
  v8 = v10 + (v9 << 25);
  if ( *((_BYTE *)a1 + 26) )
  {
    v15 = *((_QWORD *)a1 + 14);
    if ( v15 )
      *(_BYTE *)(a4 + 18) = sub_677FC94(v15, *((_QWORD *)a1 + 6), a2, v22, 0LL) & 1;
  }
  v16 = *((_QWORD *)a1 + 15);
  if ( !v16 )
  {
    v18 = 1;
LABEL_15:
    *(_BYTE *)(a4 + 17) = v18;
    return v8;
  }
  if ( (a3 & 1) == 0 )
  {
    v18 = sub_677FDE0(v16, *((_QWORD *)a1 + 6), a2, v22);
    goto LABEL_15;
  }
  v17 = v22;
  *(_BYTE *)(a4 + 17) = 1;
  sub_677FC94(v16, *((_QWORD *)a1 + 6), a2, v17, v21);
  if ( v21[0] )
  {
    v20[0] = 0;
    if ( sub_6782B4C(v8, a2 << 25, v20) )
    {
      if ( v20[0] )
        *(_BYTE *)(a4 + 18) = 1;
    }
    else
    {
      *(_BYTE *)(a4 + 17) = 0;
    }
  }
  return v8;
}


================================================================================
Function: sub_677F4F8 (0x677F4F8)
================================================================================

__int64 __fastcall sub_677F4F8(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v8; // x8
  signed __int64 v9; // x23
  unsigned __int64 v10; // x24
  char v11; // w22
  __int64 result; // x0
  char v13; // w24

  v8 = atomic_load((unsigned __int64 *)(a1 + 32));
  v9 = a3 << 25;
  v10 = v8 + (a2 << 25);
  if ( (sub_677FDE0(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 48)) & 1) != 0 )
  {
    v11 = sub_6782EDC(v10, v9, a4);
    result = sub_677FB88(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 48), a3, a2);
    if ( (v11 & 1) == 0 )
      return result;
    return sub_677FB88(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 48), a3, a2);
  }
  v13 = sub_6782D6C(v10, v9, 0LL, a4);
  sub_6788604(a4 + 96, v9);
  result = sub_677FB88(*(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 48), a3, a2);
  if ( (v13 & 1) != 0 )
    return sub_677FB88(*(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 48), a3, a2);
  return result;
}


================================================================================
Function: sub_677F5E0 (0x677F5E0)
================================================================================

bool __fastcall sub_677F5E0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // x19

  v4 = -1LL;
  if ( a3 <= 0x3F )
  {
    if ( a3 )
      v4 = ~(-1LL << a3) << (a4 & 0x3F);
    else
      v4 = 0LL;
  }
  return (v4 & ~sub_67F0530(v4, a1 + ((a4 >> 3) & 0x1FFFFFFFFFFFFFF8LL))) == 0;
}


================================================================================
Function: sub_677F6A4 (0x677F6A4)
================================================================================

bool __fastcall sub_677F6A4(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v5; // x21
  __int64 v6; // x22
  unsigned __int64 v7; // x20
  unsigned __int64 v8; // x23
  unsigned __int64 v9; // x0
  bool v10; // zf

  v5 = a4 >> 6;
  v6 = -1LL;
  if ( a3 <= 0x3F )
  {
    if ( a3 )
      v6 = ~(-1LL << a3) << (a4 & 0x3F);
    else
      v6 = 0LL;
  }
  v7 = *(_QWORD *)(a1 + 8 * v5);
  do
  {
    v8 = v7 & v6;
    if ( (v7 & v6) != 0 )
      break;
    v9 = sub_67F0010(v7, v7 | v6, (atomic_ullong *)(a1 + 8 * v5));
    v10 = v9 == v7;
    v7 = v9;
  }
  while ( !v10 );
  return v8 == 0;
}


================================================================================
Function: sub_677F728 (0x677F728)
================================================================================

bool __fastcall sub_677F728(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, _QWORD *a5)
{
  unsigned __int64 v6; // x22
  unsigned __int64 v7; // x24
  __int64 v8; // x25
  bool v9; // w21
  __int64 v10; // x26
  unsigned __int64 v11; // x23
  unsigned __int64 v12; // x19
  __int64 v14; // x28
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x0
  bool v17; // zf
  unsigned __int64 v18; // x25
  __int64 v19; // x8
  __int64 v20; // x24
  unsigned __int64 v21; // x23
  unsigned __int64 *v23; // x23
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x9
  __int64 v26; // x14
  unsigned __int64 v27; // x15
  unsigned __int64 v28; // x16
  unsigned __int64 v29; // x25
  unsigned __int64 v30; // x10
  unsigned __int64 v31; // x11
  __int64 v32; // x13
  __int64 v33; // x27
  __int64 v34; // x9
  __int64 v35; // x22
  unsigned __int64 v36; // x24
  unsigned __int64 v37; // x0
  atomic_ullong *v38; // x8
  atomic_ullong *v39; // x24
  unsigned __int64 v40; // x0
  unsigned __int64 *v41; // x8
  unsigned __int64 v42; // x24
  unsigned __int64 v43; // x0
  unsigned __int64 v44; // x25
  unsigned __int64 v45; // x0
  __int64 v46; // x22
  unsigned __int64 v47; // x8
  unsigned __int64 v48; // x0
  unsigned __int64 v49; // x24
  __int64 v50; // x22
  unsigned __int64 v51; // x8
  unsigned __int64 v52; // x0
  __int64 v54; // [xsp+8h] [xbp-68h]
  _QWORD *v55; // [xsp+10h] [xbp-60h]
  __int64 v56; // [xsp+18h] [xbp-58h]
  __int64 v57; // [xsp+20h] [xbp-50h]
  unsigned __int64 v58; // [xsp+30h] [xbp-40h]
  unsigned __int64 v59; // [xsp+38h] [xbp-38h]
  __int64 v60; // [xsp+40h] [xbp-30h]
  unsigned __int64 v61; // [xsp+48h] [xbp-28h]
  unsigned __int64 v62; // [xsp+50h] [xbp-20h]
  __int64 v63; // [xsp+58h] [xbp-18h]
  unsigned __int64 v64; // [xsp+60h] [xbp-10h]

  v64 = a2;
  if ( a4 < 3 )
  {
    if ( a2 )
    {
      v6 = 0LL;
      v7 = 64 - a4;
      if ( a4 )
        v8 = ~(-1LL << a4);
      else
        v8 = 0LL;
      v9 = 1;
      v55 = a5;
      do
      {
        if ( a3 >= a2 )
          v10 = 0LL;
        else
          v10 = a3;
        v11 = *(_QWORD *)(a1 + 8 * v10);
        v12 = __clz(__rbit64(~v11));
        if ( v11 != -1LL && v12 <= v7 )
        {
          v14 = v8 << v12;
          do
          {
            if ( (v14 & v11) != 0 )
            {
              v15 = 64 - (v12 + __clz(v14 & v11));
              if ( a4 == 1 )
                v15 = 1LL;
              v12 += v15;
              v14 <<= v15;
            }
            else
            {
              v16 = sub_67F0010(v11, v14 | v11, (atomic_ullong *)(a1 + 8 * v10));
              v17 = v16 == v11;
              v11 = v16;
              if ( v17 )
                goto LABEL_94;
            }
          }
          while ( v12 <= v7 );
        }
        a2 = v64;
        ++v6;
        a3 = v10 + 1;
        v9 = v6 < v64;
      }
      while ( v6 != v64 );
      return v9;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  v18 = 64 - a4;
  v19 = ~(-1LL << a4);
  if ( a4 > 0x3F )
    v19 = -1LL;
  v20 = 0LL;
  v55 = a5;
  v54 = v19;
  v61 = a4 + 63;
  v62 = 64 - a4;
  v56 = a1 + 8;
  v57 = a1 - 8;
  while ( 1 )
  {
    v10 = a3 >= a2 ? 0LL : a3;
    if ( a4 <= 0x40 )
    {
      v21 = *(_QWORD *)(a1 + 8 * v10);
      v12 = __clz(__rbit64(~v21));
      if ( v21 != -1LL && v12 <= v18 )
        break;
    }
LABEL_38:
    v63 = v20;
    v23 = (unsigned __int64 *)(a1 + 8 * v10);
    v24 = *v23;
    v25 = __clz(*v23);
    if ( v25 )
    {
      v26 = 0LL;
      v27 = v64 - v10;
      v28 = v57 + 8 * v10;
LABEL_40:
      if ( v25 >= a4 )
      {
        v49 = *v23;
        if ( *v23 != -1LL )
        {
          v12 = __clz(__rbit64(~v49));
          if ( v12 <= v62 )
          {
            v50 = v54 << v12;
            do
            {
              if ( (v50 & v49) != 0 )
              {
                v51 = v12 + __clz(v50 & v49);
                v12 += 64 - v51;
                v50 <<= -(char)v51;
              }
              else
              {
                v52 = sub_67F0010(v49, v50 | v49, (atomic_ullong *)v23);
                if ( v52 == v49 )
                  goto LABEL_93;
                v49 = v52;
              }
            }
            while ( v12 <= v62 );
          }
        }
      }
      else
      {
        v29 = v28;
        v30 = v25;
        if ( v27 > (v61 - v25) >> 6 )
        {
          while ( 1 )
          {
            v31 = v30 + 64 <= a4 ? 64LL : a4 - v30;
            v32 = v31 ? ~(-1LL << v31) : 0LL;
            v33 = v31 <= 0x3F ? v32 : -1LL;
            if ( (v33 & *(_QWORD *)(v29 + 16)) != 0 )
              break;
            v30 += v31;
            v29 += 8LL;
            if ( v30 >= a4 )
            {
              v12 = 64 - v25;
              v58 = v28;
              v59 = v27;
              v60 = v26;
              v34 = ~(-1LL << v25) << -(char)v25;
              if ( v24 )
                v35 = v34;
              else
                v35 = -1LL;
              v36 = *v23;
              do
              {
                if ( (v36 & v35) != 0 )
                {
                  v41 = v23 - 1;
                  goto LABEL_66;
                }
                v37 = sub_67F0010(v36, v36 | v35, (atomic_ullong *)v23);
                v17 = v37 == v36;
                v36 = v37;
              }
              while ( !v17 );
              v38 = (atomic_ullong *)(v56 + 8 * v10);
              while ( 1 )
              {
                v39 = v38;
                if ( (unsigned __int64)v38 - 8 >= v29 )
                  break;
                v40 = sub_67F0010(0LL, 0xFFFFFFFFFFFFFFFFLL, v38);
                v38 = (atomic_ullong *)((char *)v39 + 8);
                if ( v40 )
                  goto LABEL_63;
              }
              v44 = *(_QWORD *)v38;
              while ( (v44 & v33) == 0 )
              {
                v45 = sub_67F0010(v44, v44 | v33, v39);
                v17 = v45 == v44;
                v44 = v45;
                if ( v17 )
                  goto LABEL_93;
              }
LABEL_63:
              v41 = (unsigned __int64 *)((char *)v39 - 8);
LABEL_66:
              while ( v41 > v23 )
                atomic_store(0LL, v41--);
              if ( v41 == v23 )
              {
                v42 = *v23;
                do
                {
                  v43 = sub_67F0010(v42, v42 & ~v35, (atomic_ullong *)v23);
                  v17 = v43 == v42;
                  v42 = v43;
                }
                while ( !v17 );
              }
              v28 = v58;
              v27 = v59;
              if ( v60 != 3 )
              {
                v24 = *v23;
                v26 = v60 + 1;
                v25 = __clz(*v23);
                if ( v25 )
                  goto LABEL_40;
              }
              break;
            }
          }
        }
      }
    }
    a2 = v64;
    a3 = v10 + 1;
    v18 = v62;
    v20 = v63 + 1;
    if ( v63 + 1 == v64 )
      return 0;
  }
  v46 = v54 << v12;
  while ( 1 )
  {
    while ( (v46 & v21) != 0 )
    {
      v47 = v12 + __clz(v46 & v21);
      v12 += 64 - v47;
      v46 <<= -(char)v47;
      if ( v12 > v18 )
        goto LABEL_38;
    }
    v48 = sub_67F0010(v21, v46 | v21, (atomic_ullong *)(a1 + 8 * v10));
    if ( v48 == v21 )
      break;
    v21 = v48;
    if ( v12 > v18 )
      goto LABEL_38;
  }
LABEL_93:
  v9 = 1;
LABEL_94:
  *v55 = v12 + (v10 << 6);
  return v9;
}


================================================================================
Function: sub_677FB88 (0x677FB88)
================================================================================

__int64 __fastcall sub_677FB88(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // x9
  unsigned __int64 v5; // x8
  __int64 v6; // x9
  __int64 v7; // x19
  unsigned int v8; // w19
  bool v10; // zf
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x19
  __int64 v14; // x20
  atomic_ullong *v15; // x21
  unsigned __int64 v16; // x22
  unsigned __int64 v17; // x0

  v4 = a4 & 0x3F;
  v5 = a4 >> 6;
  if ( v4 + a3 > 0x40 )
  {
    v10 = v4 == 0;
    v11 = a3 - (64 - v4);
    v12 = ~(-1LL << -(char)v4) << v4;
    if ( v10 )
      v13 = -1LL;
    else
      v13 = v12;
    if ( (v11 & 0x3F) != 0 )
      v14 = ~(-1LL << v11);
    else
      v14 = 0LL;
    v15 = (atomic_ullong *)(a1 + 8 * v5 + 8);
    v8 = (v13 & ~sub_67F0530(v13, a1 + 8 * v5)) == 0;
    if ( v11 >= 0x40 )
    {
      v16 = v11 >> 6;
      do
      {
        --v16;
        v17 = sub_67F0260(0LL, v15);
        v15 = (atomic_ullong *)((char *)v15 + 8);
        v8 = (v17 == -1LL) & (unsigned __int8)v8;
      }
      while ( v16 );
    }
    if ( v14 )
      return ((v14 & ~sub_67F0530(v14, v15)) == 0) & (unsigned __int8)v8;
  }
  else
  {
    v6 = ~(-1LL << a3) << v4;
    if ( !a3 )
      v6 = 0LL;
    if ( a3 <= 0x3F )
      v7 = v6;
    else
      v7 = -1LL;
    return (v7 & ~sub_67F0530(v7, a1 + 8 * v5)) == 0;
  }
  return v8;
}


================================================================================
Function: sub_677FC94 (0x677FC94)
================================================================================

__int64 __fastcall sub_677FC94(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, _BYTE *a5)
{
  __int64 v6; // x9
  unsigned __int64 v7; // x8
  __int64 v8; // x9
  __int64 v9; // x21
  __int64 v10; // x8
  unsigned int v11; // w20
  char v12; // w23
  bool v14; // zf
  __int64 v15; // x20
  unsigned __int64 v16; // x24
  __int64 v17; // x9
  __int64 v18; // x23
  __int64 v19; // x21
  __int64 v20; // x8
  atomic_ullong *v21; // x22
  unsigned __int64 v22; // x24
  unsigned __int64 v23; // x0
  __int64 v24; // x8

  v6 = a4 & 0x3F;
  v7 = a4 >> 6;
  if ( v6 + a3 > 0x40 )
  {
    v14 = v6 == 0;
    v15 = a1 + 8 * v7;
    v16 = a3 - (64 - v6);
    v17 = ~(-1LL << -(char)v6) << v6;
    if ( v14 )
      v18 = -1LL;
    else
      v18 = v17;
    if ( (v16 & 0x3F) != 0 )
      v19 = ~(-1LL << v16);
    else
      v19 = 0LL;
    v20 = sub_67F0620(v18, a1 + 8 * v7) & v18;
    v21 = (atomic_ullong *)(v15 + 8);
    v11 = v20 == 0;
    v12 = v20 != v18;
    if ( v16 >= 0x40 )
    {
      v22 = v16 >> 6;
      do
      {
        --v22;
        v23 = sub_67F0260(0xFFFFFFFFFFFFFFFFLL, v21);
        v21 = (atomic_ullong *)((char *)v21 + 8);
        v11 = (v23 == 0) & (unsigned __int8)v11;
        v12 |= v23 != -1LL;
      }
      while ( v22 );
    }
    if ( v19 )
    {
      v24 = sub_67F0620(v19, v21) & v19;
      v11 = (v24 == 0) & (unsigned __int8)v11;
      v12 |= v24 != v19;
    }
  }
  else
  {
    v8 = ~(-1LL << a3) << v6;
    if ( !a3 )
      v8 = 0LL;
    if ( a3 <= 0x3F )
      v9 = v8;
    else
      v9 = -1LL;
    v10 = sub_67F0620(v9, a1 + 8 * v7) & v9;
    v11 = v10 == 0;
    v12 = v10 != v9;
  }
  if ( a5 )
    *a5 = v12 & 1;
  return v11;
}


================================================================================
Function: sub_677FDE0 (0x677FDE0)
================================================================================

bool __fastcall sub_677FDE0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // x9
  unsigned __int64 v5; // x8
  __int64 v6; // x8
  __int64 v7; // x9
  _BOOL8 result; // x0
  _QWORD *v9; // x13
  unsigned __int64 v10; // x10
  __int64 v11; // x9
  __int64 v12; // x8
  __int64 *v13; // x9
  unsigned __int64 v14; // x10
  __int64 v15; // t1

  v4 = a4 & 0x3F;
  v5 = a4 >> 6;
  if ( v4 + a3 > 0x40 )
  {
    v9 = (_QWORD *)(a1 + 8 * v5);
    v10 = a3 - (64 - v4);
    if ( (a4 & 0x3F) != 0 )
      v11 = ~(-1LL << -(char)v4) << v4;
    else
      v11 = -1LL;
    if ( (v10 & 0x3F) != 0 )
      v12 = ~(-1LL << v10);
    else
      v12 = 0LL;
    result = (v11 & ~*v9) == 0;
    v13 = v9 + 1;
    if ( v10 >= 0x40 )
    {
      v14 = v10 >> 6;
      do
      {
        v15 = *v13++;
        --v14;
        result = (v15 == -1) & (unsigned __int8)result;
      }
      while ( v14 );
    }
    if ( v12 )
      return (v12 & ~*v13) == 0 && result;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 8 * v5);
    v7 = ~(-1LL << a3) << v4;
    if ( !a3 )
      v7 = 0LL;
    if ( a3 > 0x3F )
      v7 = -1LL;
    return (v7 & ~v6) == 0;
  }
  return result;
}


================================================================================
Function: sub_677FEA8 (0x677FEA8)
================================================================================

__int64 sub_677FEA8()
{
  return *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
}


================================================================================
Function: sub_677FEB4 (0x677FEB4)
================================================================================

_UNKNOWN **sub_677FEB4()
{
  if ( !qword_6C36378 )
  {
    qword_6C36368 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    qword_6C36378 = 1LL;
    sub_6785180(&unk_6C36390);
    qword_6C36378 = sub_677DCCC(&off_6C35848);
    qword_6C36380 = sub_677DCCC(&off_6C35848);
    qword_6C36388 = sub_677DCCC(&off_6C35848);
  }
  return &off_6C35848;
}


================================================================================
Function: sub_677FF28 (0x677FF28)
================================================================================

void sub_677FF28()
{
  __int64 i; // x21
  unsigned __int64 v1; // x0
  __int64 v2; // x8
  __int128 v3; // [xsp+0h] [xbp-20h] BYREF
  __int64 v4; // [xsp+10h] [xbp-10h]

  for ( i = 0LL; i != 16; ++i )
  {
    if ( qword_728A180[i] )
    {
      v1 = sub_67F0260(0LL, (atomic_ullong *)&qword_728A180[i]);
      if ( v1 )
      {
        v2 = *(_QWORD *)(v1 + 4680);
        v3 = *(_OWORD *)(v1 + 4664);
        v4 = v2;
        sub_67822B8(v1, 4688LL, &v3, &unk_7289F00);
      }
    }
  }
}


================================================================================
Function: sub_677FFE4 (0x677FFE4)
================================================================================

bool sub_677FFE4()
{
  __int64 v0; // x8

  v0 = qword_6C36368;
  return !qword_6C36368 || v0 == *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
}


================================================================================
Function: sub_678000C (0x678000C)
================================================================================

__int64 sub_678000C()
{
  return qword_6C36440;
}


================================================================================
Function: sub_6780018 (0x6780018)
================================================================================

_UNKNOWN **sub_6780018()
{
  _UNKNOWN **result; // x0
  __int64 v1; // x8
  _UNKNOWN **v2; // x0
  _QWORD *v3; // x19
  bool v4; // w8
  __int64 v5; // x3
  __int64 v6; // x4
  __int64 v7; // x5
  __int64 v8; // x6
  __int64 v9; // x7
  __int64 v10; // x10
  __int128 v11; // [xsp+0h] [xbp-20h] BYREF
  __int64 v12; // [xsp+10h] [xbp-10h]

  sub_67804B0();
  if ( dword_6C367E0 == -1 )
  {
    sub_677FEB4();
    result = &off_6C35848;
    if ( !&off_6C35848 )
      goto LABEL_4;
  }
  else
  {
    result = (_UNKNOWN **)pthread_getspecific(dword_6C367E0);
    if ( !result )
      goto LABEL_4;
  }
  if ( result != (_UNKNOWN **)&unk_6BDF6C0 )
    return result;
LABEL_4:
  v1 = qword_6C36368;
  if ( !qword_6C36368 || v1 == *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8) )
  {
    if ( !qword_6C36378 )
    {
      qword_6C36368 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
      qword_6C36378 = 1LL;
      sub_6785180((__int64)&unk_6C36390);
      qword_6C36378 = sub_677DCCC((__int64)&off_6C35848);
      qword_6C36380 = sub_677DCCC((__int64)&off_6C35848);
      qword_6C36388 = sub_677DCCC((__int64)&off_6C35848);
    }
    v2 = &off_6C35848;
    goto LABEL_46;
  }
  if ( qword_728A180 )
  {
    v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A180);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_728A188 )
  {
    v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A188);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_728A190 )
  {
    v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A190);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_728A198 )
  {
    v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A198);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_728A1A0 )
  {
    v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1A0);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_728A1A8 )
  {
    v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1A8);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_728A1B0 )
  {
    v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1B0);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_728A1B8 )
  {
    v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1B8);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_728A1C0 )
  {
    v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1C0);
    if ( v3 )
      goto LABEL_41;
  }
  if ( qword_728A1C8 && (v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1C8)) != 0LL
    || qword_728A1D0 && (v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1D0)) != 0LL
    || qword_728A1D8 && (v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1D8)) != 0LL
    || qword_728A1E0 && (v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1E0)) != 0LL
    || qword_728A1E8 && (v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1E8)) != 0LL
    || qword_728A1F0 && (v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1F0)) != 0LL
    || qword_728A1F8 && (v3 = (_QWORD *)sub_67F0260(0LL, &qword_728A1F8)) != 0LL )
  {
LABEL_41:
    v4 = 0;
    if ( !v3 )
      goto LABEL_44;
    goto LABEL_42;
  }
  v3 = (_QWORD *)sub_6782318(4688LL, &v11, &unk_7289F00);
  if ( !v3 )
  {
    v3 = (_QWORD *)sub_6782318(4688LL, &v11, &unk_7289F00);
    if ( !v3 )
    {
      sub_6781A58(12LL, "unable to allocate thread local heap metadata (%zu bytes)\n", 4688LL, v5, v6, v7, v8, v9, v11);
      goto LABEL_41;
    }
  }
  v10 = v12;
  v4 = BYTE2(v12) != 0;
  *(_OWORD *)(v3 + 583) = v11;
  v3[585] = v10;
LABEL_42:
  if ( !v4 )
    memset(v3, 0, 0x1250uLL);
LABEL_44:
  if ( v3 )
  {
    memcpy(v3 + 383, &unk_6BE02C0, 0x640uLL);
    memcpy(v3, &unk_6BDF6C0, 0xBF8uLL);
    v3[356] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    sub_6785180((__int64)(v3 + 361));
    v3[358] = sub_677DCCC((__int64)v3) | 1;
    v3[359] = sub_677DCCC((__int64)v3);
    v3[360] = sub_677DCCC((__int64)v3);
    v2 = (_UNKNOWN **)v3;
    *v3 = v3 + 383;
    v3[385] = v3;
    v3[386] = v3;
    v3[499] = v3 + 503;
    v3[500] = v3 + 501;
    v3[502] = v3 + 503;
LABEL_46:
    sub_678A208(v2);
  }
  sub_6788604(&unk_728A020, 1LL);
  return (_UNKNOWN **)sub_67F0410(1uLL, (atomic_ullong *)&qword_6C36440);
}


================================================================================
Function: sub_67804B0 (0x67804B0)
================================================================================

void sub_67804B0()
{
  const void *v0; // x0
  _UNKNOWN **v1; // x0
  __int64 v2; // x19
  __int64 v3; // x0
  __int64 v4; // x0

  if ( !qword_6C36378 )
  {
    qword_6C36368 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
    qword_6C36378 = 1LL;
    sub_6785180((__int64)&unk_6C36390);
    qword_6C36378 = sub_677DCCC((__int64)&off_6C35848);
    qword_6C36380 = sub_677DCCC((__int64)&off_6C35848);
    qword_6C36388 = sub_677DCCC((__int64)&off_6C35848);
  }
  if ( !qword_728A208 && !sub_67F0010(0LL, 1uLL, (atomic_ullong *)&qword_728A208) )
  {
    byte_7289ED0 = 1;
    v0 = (const void *)sub_6780E3C(
                         "process init: 0x%zx\n",
                         *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8));
    if ( (byte_728A210 & 1) == 0 )
    {
      byte_728A210 = 1;
      sub_678A1E4(v0);
      v0 = sub_678A208(&off_6C35848);
    }
    sub_6781FFC(v0);
    if ( !qword_6C36378 )
    {
      qword_6C36368 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 8);
      qword_6C36378 = 1LL;
      sub_6785180((__int64)&unk_6C36390);
      qword_6C36378 = sub_677DCCC((__int64)&off_6C35848);
      qword_6C36380 = sub_677DCCC((__int64)&off_6C35848);
      qword_6C36388 = sub_677DCCC((__int64)&off_6C35848);
    }
    sub_6780E3C("secure level: %d\n", 0);
    sub_6780E3C("mem tracking: %s\n", "none");
    v1 = sub_6780018();
    sub_67887D0(v1);
    if ( sub_67814F4(7u) )
    {
      v2 = sub_6781400(7LL, 0LL, 0x20000LL);
      v3 = sub_6780DEC(8LL);
      if ( v3 == -1 )
        sub_677F294(v2, 0LL, 500 * v2);
      else
        sub_677F288(v2, v3, 500 * v2);
    }
    if ( sub_67814F4(9u) )
    {
      v4 = sub_6780DEC(9LL);
      if ( v4 >= 1 )
        sub_677EFCC(v4 << 10, 1LL, 1LL, 0LL, 0LL);
    }
  }
}


================================================================================
Function: sub_6780B10 (0x6780B10)
================================================================================

bool sub_6780B10()
{
  return (byte_728A200 & 1) == 0;
}


================================================================================
Function: sub_6780DEC (0x6780DEC)
================================================================================

__int64 __fastcall sub_6780DEC(unsigned int a1)
{
  __int64 *v2; // x19

  if ( a1 > 0x19 )
    return 0LL;
  v2 = &qword_6C36448[4 * a1];
  if ( !*((_DWORD *)v2 + 2) )
    sub_6780F78((__int64)&qword_6C36448[4 * a1]);
  return *v2;
}


================================================================================
Function: sub_6780E3C (0x6780E3C)
================================================================================

__int64 sub_6780E3C(__int64 result, ...)
{
  const char *v1; // x19
  unsigned __int64 v2; // x19
  __int64 (__fastcall *v3)(); // x21
  gcc_va_list va1; // [xsp+C0h] [xbp-270h] BYREF
  gcc_va_list va; // [xsp+E0h] [xbp-250h] BYREF
  gcc_va_list arg; // [xsp+100h] [xbp-230h] BYREF
  char s[512]; // [xsp+128h] [xbp-208h] BYREF

  v1 = (const char *)result;
  if ( !dword_6C36490 )
    result = sub_6780F78((__int64)&qword_6C36488);
  if ( qword_6C36488 )
  {
    va_start(va, result);
    va_copy(va1, va);
    if ( v1 )
    {
      result = sub_6781DE8();
      if ( (result & 1) != 0 )
      {
        va_copy(arg, va1);
        vsnprintf(s, 0x1FFuLL, v1, arg);
        sub_6781E2C();
        result = sub_6781DE8();
        if ( (result & 1) != 0 )
        {
          v2 = atomic_load(&qword_728A220);
          if ( qword_728A218 )
          {
            v3 = (__int64 (__fastcall *)())qword_728A218;
            ((void (__fastcall *)(const char *, unsigned __int64))qword_728A218)("mimalloc: ", v2);
          }
          else
          {
            v3 = sub_6781D44;
            ((void (__fastcall *)(const char *, unsigned __int64))sub_6781D44)("mimalloc: ", v2);
          }
          ((void (__fastcall *)(char *, unsigned __int64))v3)(s, v2);
          return (__int64)sub_6781E2C();
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6780F78 (0x6780F78)
================================================================================

signed __int64 __fastcall sub_6780F78(__int64 a1)
{
  char *v2; // x21
  _BYTE *v3; // x8
  char *v4; // x9
  unsigned __int64 v5; // x12
  __int64 v6; // x13
  char *v7; // x11
  unsigned __int64 v8; // x10
  int v9; // w13
  int v10; // w12
  __int64 v11; // x11
  bool v12; // cc
  signed __int64 result; // x0
  _BYTE *v14; // x8
  char *v15; // x9
  unsigned __int64 v16; // x11
  __int64 v17; // x12
  unsigned __int64 v18; // x10
  int v19; // w12
  int v20; // w11
  __int64 v21; // x12
  bool v22; // cc
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x8
  unsigned __int64 v26; // x9
  __int64 v27; // x10
  int v28; // w8
  int8x16_t v29; // q0
  uint8x16_t v30; // q1
  int8x16_t v31; // q2
  int8x16_t v32; // q0
  uint8x16_t v33; // q1
  int8x16_t v34; // q2
  int8x8_t *v35; // x11
  int8x8_t *v36; // x12
  unsigned __int64 v37; // x13
  int8x8_t v38; // t1
  int v39; // w13
  int v40; // w8
  char *v41; // x9
  int v42; // w10
  const char *v43; // x1
  char *endptr; // [xsp+8h] [xbp-B8h] BYREF
  char needle[16]; // [xsp+10h] [xbp-B0h] BYREF
  int8x16_t v46; // [xsp+20h] [xbp-A0h]
  int8x16_t v47; // [xsp+30h] [xbp-90h]
  int8x16_t v48; // [xsp+40h] [xbp-80h]
  int8x16_t v49; // [xsp+60h] [xbp-60h] BYREF
  int8x16_t v50; // [xsp+70h] [xbp-50h]
  int8x16_t v51; // [xsp+80h] [xbp-40h]
  int8x16_t v52; // [xsp+90h] [xbp-30h]

  v2 = &needle[1];
  v3 = *(_BYTE **)(a1 + 16);
  strcpy(needle, "mimalloc_");
  if ( v3 )
  {
    v4 = needle;
    v5 = 64LL;
    v6 = 62LL;
    v7 = &needle[1];
    do
    {
      v8 = v6;
      v9 = (unsigned __int8)v4[2];
      ++v7;
      --v5;
      ++v4;
      if ( !v9 )
        break;
      v6 = v8 - 1;
    }
    while ( v5 > 1 );
    if ( v5 >= 2 )
    {
      LOBYTE(v10) = *v3;
      if ( *v3 )
      {
        v11 = 1LL;
        do
        {
          v4[v11] = v10;
          v10 = (unsigned __int8)v3[v11++];
          if ( v10 )
            v12 = v8 > 1;
          else
            v12 = 0;
          --v8;
        }
        while ( v12 );
        v7 = &v4[v11];
      }
    }
    *v7 = 0;
  }
  result = sub_678A114(needle, &v49, 65LL);
  if ( (result & 1) == 0 )
  {
    v14 = *(_BYTE **)(a1 + 24);
    if ( !v14 )
      goto LABEL_36;
    v15 = needle;
    v16 = 64LL;
    v17 = 62LL;
    strcpy(needle, "mimalloc_");
    do
    {
      v18 = v17;
      v19 = (unsigned __int8)v15[2];
      ++v2;
      --v16;
      ++v15;
      if ( !v19 )
        break;
      v17 = v18 - 1;
    }
    while ( v16 > 1 );
    if ( v16 >= 2 )
    {
      LOBYTE(v20) = *v14;
      if ( *v14 )
      {
        v21 = 1LL;
        do
        {
          v15[v21] = v20;
          v20 = (unsigned __int8)v14[v21++];
          if ( v20 )
            v22 = v18 > 1;
          else
            v22 = 0;
          --v18;
        }
        while ( v22 );
        v2 = &v15[v21];
      }
    }
    *v2 = 0;
    if ( (sub_678A114(needle, &v49, 65LL) & 1) == 0 )
    {
LABEL_36:
      result = sub_6780B10();
      if ( (result & 1) != 0 )
        return result;
      v28 = 1;
      goto LABEL_57;
    }
    result = sub_6781928(
               (signed __int64)"environment option \"mimalloc_%s\" is deprecated -- use \"mimalloc_%s\" instead.\n",
               *(const char **)(a1 + 24),
               *(const char **)(a1 + 16));
  }
  v23 = 0LL;
  do
  {
    v24 = v23 + 1;
    if ( !v49.n128_u8[v23] )
      break;
  }
  while ( v23++ < 0x40 );
  v26 = v24 - 1;
  if ( v24 != 1 )
  {
    if ( v26 < 8 )
    {
      v27 = 0LL;
      goto LABEL_49;
    }
    if ( v26 < 0x10 )
    {
      v27 = 0LL;
      goto LABEL_46;
    }
    v29.n128_u64[0] = 0x9F9F9F9F9F9F9F9FLL;
    v29.n128_u64[1] = 0x9F9F9F9F9F9F9F9FLL;
    v30.n128_u64[0] = 0x1A1A1A1A1A1A1A1ALL;
    v30.n128_u64[1] = 0x1A1A1A1A1A1A1A1ALL;
    v27 = v26 & 0x7FFFFFFFFFFFFFF0LL;
    v31.n128_u64[0] = 0xE0E0E0E0E0E0E0E0LL;
    v31.n128_u64[1] = 0xE0E0E0E0E0E0E0E0LL;
    *(int8x16_t *)needle = vbslq_s8(vcgtq_u8(v30, vaddq_s8(v49, v29)), vaddq_s8(v49, v31), v49);
    if ( (v26 & 0x7FFFFFFFFFFFFFF0LL) != 0x10 )
    {
      v46 = vbslq_s8(vcgtq_u8(v30, vaddq_s8(v50, v29)), vaddq_s8(v50, v31), v50);
      if ( v27 != 32 )
      {
        v32.n128_u64[0] = 0x9F9F9F9F9F9F9F9FLL;
        v32.n128_u64[1] = 0x9F9F9F9F9F9F9F9FLL;
        v33.n128_u64[0] = 0x1A1A1A1A1A1A1A1ALL;
        v33.n128_u64[1] = 0x1A1A1A1A1A1A1A1ALL;
        v34.n128_u64[0] = 0xE0E0E0E0E0E0E0E0LL;
        v34.n128_u64[1] = 0xE0E0E0E0E0E0E0E0LL;
        v47 = vbslq_s8(vcgtq_u8(v33, vaddq_s8(v51, v32)), vaddq_s8(v51, v34), v51);
        if ( v27 != 48 )
          v48 = vbslq_s8(vcgtq_u8(v33, vaddq_s8(v52, v32)), vaddq_s8(v52, v34), v52);
      }
    }
    if ( v26 != v27 )
    {
      if ( (v26 & 8) == 0 )
      {
        do
        {
LABEL_49:
          v39 = v49.n128_u8[v27];
          if ( (unsigned int)(v39 - 97) < 0x1A )
            LOBYTE(v39) = v39 - 32;
          needle[v27++] = v39;
        }
        while ( v26 != v27 );
        goto LABEL_52;
      }
LABEL_46:
      v35 = (int8x8_t *)((char *)&v49 + v27);
      v36 = (int8x8_t *)&needle[v27];
      v37 = v27 - (v26 & 0xFFFFFFFFFFFFFFF8LL);
      v27 = v26 & 0x7FFFFFFFFFFFFFF8LL;
      do
      {
        v38.n64_u64[0] = v35->n64_u64[0];
        ++v35;
        v37 += 8LL;
        v36->n64_u64[0] = vbsl_s8(
                            vcgt_u8((uint8x8_t)0x1A1A1A1A1A1A1A1ALL, vadd_s8(v38, (int8x8_t)0x9F9F9F9F9F9F9F9FLL)),
                            vadd_s8(v38, (int8x8_t)0xE0E0E0E0E0E0E0E0LL),
                            v38).n64_u64[0];
        ++v36;
      }
      while ( v37 );
      if ( v26 == v27 )
        goto LABEL_52;
      goto LABEL_49;
    }
  }
LABEL_52:
  needle[v24 - 1] = 0;
  if ( !needle[0] || (result = (signed __int64)strstr("1;TRUE;YES;ON", needle)) != 0 )
  {
    *(_QWORD *)a1 = 1LL;
    *(_DWORD *)(a1 + 8) = 2;
    return result;
  }
  result = (signed __int64)strstr("0;FALSE;NO;OFF", needle);
  if ( result )
  {
    v28 = 2;
    *(_QWORD *)a1 = 0LL;
LABEL_57:
    *(_DWORD *)(a1 + 8) = v28;
    return result;
  }
  endptr = needle;
  result = strtol(needle, &endptr, 10);
  v40 = *(_DWORD *)(a1 + 12);
  if ( v40 != 9 && v40 != 23 )
  {
    v41 = endptr;
    goto LABEL_75;
  }
  v41 = endptr;
  v42 = (unsigned __int8)*endptr;
  switch ( v42 )
  {
    case 'G':
      v41 = endptr + 1;
      result <<= 20;
      break;
    case 'M':
      v41 = endptr + 1;
      result <<= 10;
      break;
    case 'K':
      v41 = endptr + 1;
      break;
    default:
      result = (unsigned __int64)(result + 1023) >> 10;
      if ( v42 != 66 )
        goto LABEL_69;
LABEL_73:
      ++v41;
      goto LABEL_74;
  }
  v42 = (unsigned __int8)*v41;
  endptr = v41;
  if ( v42 == 66 )
    goto LABEL_73;
LABEL_69:
  if ( v42 == 73 && v41[1] == 66 )
  {
    v41 += 2;
LABEL_74:
    endptr = v41;
  }
LABEL_75:
  if ( !*v41 )
  {
    v28 = 2;
    *(_QWORD *)a1 = result;
    goto LABEL_57;
  }
  *(_DWORD *)(a1 + 8) = 1;
  if ( v40 != 2 || *(_QWORD *)a1 )
    return sub_6781928(
             (signed __int64)"environment option mimalloc_%s has an invalid value.\n",
             *(const char **)(a1 + 16));
  v43 = *(const char **)(a1 + 16);
  *(_QWORD *)a1 = 1LL;
  result = sub_6781928((signed __int64)"environment option mimalloc_%s has an invalid value.\n", v43);
  *(_QWORD *)a1 = 0LL;
  return result;
}


================================================================================
Function: sub_6781400 (0x6781400)
================================================================================

__int64 __fastcall sub_6781400(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v5; // x8
  __int64 *v6; // x21
  __int64 v7; // x9

  if ( a1 <= 0x19 )
  {
    v6 = &qword_6C36448[4 * a1];
    if ( !*((_DWORD *)v6 + 2) )
      sub_6780F78((__int64)&qword_6C36448[4 * a1]);
    v5 = *v6;
  }
  else
  {
    v5 = 0LL;
  }
  if ( v5 <= a3 )
    v7 = v5;
  else
    v7 = a3;
  if ( v5 >= a2 )
    return v7;
  else
    return a2;
}


================================================================================
Function: sub_6781470 (0x6781470)
================================================================================

__int64 __fastcall sub_6781470(unsigned int a1)
{
  __int64 *v2; // x19

  if ( a1 > 0x19 )
    return 0LL;
  v2 = &qword_6C36448[4 * a1];
  if ( !*((_DWORD *)v2 + 2) )
    sub_6780F78((__int64)&qword_6C36448[4 * a1]);
  if ( *v2 >= 0 )
    return *v2 << 10;
  else
    return 0LL;
}


================================================================================
Function: sub_67814F4 (0x67814F4)
================================================================================

bool __fastcall sub_67814F4(unsigned int a1)
{
  __int64 *v2; // x19

  if ( a1 > 0x19 )
    return 0LL;
  v2 = &qword_6C36448[4 * a1];
  if ( !*((_DWORD *)v2 + 2) )
    sub_6780F78((__int64)&qword_6C36448[4 * a1]);
  return *v2 != 0;
}


================================================================================
Function: sub_6781784 (0x6781784)
================================================================================

__int64 __fastcall sub_6781784(__int64 result, const char *a2, __int128 *a3)
{
  __int64 v4; // x20
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x8
  __int128 v8; // q1
  __int64 v9; // x0
  __int64 v10; // x0
  unsigned __int64 v11; // x19
  __int64 (__fastcall *v12)(); // x21
  __int64 v13; // x0
  __int64 v14; // x0
  __int64 v15; // x0
  unsigned __int64 v16; // x19
  __int64 (__fastcall *v17)(); // x20
  __int128 v18; // [xsp+0h] [xbp-290h]
  __int128 v19; // [xsp+10h] [xbp-280h]
  __int128 v20; // [xsp+20h] [xbp-270h] BYREF
  __int128 v21; // [xsp+30h] [xbp-260h]
  _OWORD arg[4]; // [xsp+40h] [xbp-250h] BYREF
  char s[512]; // [xsp+88h] [xbp-208h] BYREF

  v4 = result;
  if ( !result )
    goto LABEL_7;
  v6 = 0LL;
  do
  {
    v7 = v6;
    if ( !*(_BYTE *)(result + v6) )
      break;
    ++v6;
  }
  while ( v7 < 0x21 );
  if ( v7 <= 0x20 && (result = sub_677FFE4(result), (result & 1) == 0) )
  {
    sub_677FEA8();
    result = sub_6781E4C(arg);
    v18 = *a3;
    v19 = a3[1];
    if ( a2 )
    {
      result = sub_6781DE8(result);
      if ( (result & 1) != 0 )
      {
        v20 = v18;
        v21 = v19;
        v14 = vsnprintf(s, 0x1FFuLL, a2, &v20);
        v15 = sub_6781E2C(v14);
        result = sub_6781DE8(v15);
        if ( (result & 1) != 0 )
        {
          v16 = atomic_load(&qword_728A220);
          if ( qword_728A218 )
          {
            v17 = (__int64 (__fastcall *)())qword_728A218;
            ((void (__fastcall *)(_OWORD *, unsigned __int64))qword_728A218)(arg, v16);
          }
          else
          {
            v17 = sub_6781D44;
            ((void (__fastcall *)(_OWORD *, unsigned __int64))sub_6781D44)(arg, v16);
          }
          v13 = ((__int64 (__fastcall *)(char *, unsigned __int64))v17)(s, v16);
          return sub_6781E2C(v13);
        }
      }
    }
  }
  else
  {
LABEL_7:
    v8 = a3[1];
    v20 = *a3;
    v21 = v8;
    if ( a2 )
    {
      result = sub_6781DE8(result);
      if ( (result & 1) != 0 )
      {
        arg[0] = v20;
        arg[1] = v21;
        v9 = vsnprintf(s, 0x1FFuLL, a2, arg);
        v10 = sub_6781E2C(v9);
        result = sub_6781DE8(v10);
        if ( (result & 1) != 0 )
        {
          v11 = atomic_load(&qword_728A220);
          if ( qword_728A218 )
            v12 = (__int64 (__fastcall *)())qword_728A218;
          else
            v12 = sub_6781D44;
          if ( v4 )
            ((void (__fastcall *)(__int64, unsigned __int64))v12)(v4, v11);
          v13 = ((__int64 (__fastcall *)(char *, unsigned __int64))v12)(s, v11);
          return sub_6781E2C(v13);
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6781928 (0x6781928)
================================================================================

signed __int64 sub_6781928(signed __int64 result, ...)
{
  signed __int64 v1; // x19
  gcc_va_list va1; // [xsp+C0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-28h] BYREF

  v1 = result;
  if ( !dword_6C36490 )
    result = sub_6780F78(&qword_6C36488);
  if ( qword_6C36488 )
    goto LABEL_4;
  if ( !dword_6C36450 )
    result = sub_6780F78(&qword_6C36448);
  if ( qword_6C36448 )
  {
    if ( qword_6C36790 < 0 || (result = sub_67F04A0(1uLL, (atomic_ullong *)&unk_728A228), result <= qword_6C36790) )
    {
LABEL_4:
      va_start(va, result);
      va_copy(va1, va);
      return sub_6781784("mimalloc: warning: ", v1, va1);
    }
  }
  return result;
}


================================================================================
Function: sub_6781A58 (0x6781A58)
================================================================================

__int64 __fastcall sub_6781A58(
        __int64 result,
        const char *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  unsigned int v10; // w19
  __int64 (__fastcall *v11)(_QWORD, unsigned __int64); // x8
  unsigned __int64 v12; // x1
  _QWORD v13[6]; // [xsp+80h] [xbp-A0h] BYREF
  __int128 v14; // [xsp+B0h] [xbp-70h] BYREF
  __int128 v15; // [xsp+C0h] [xbp-60h]
  __int128 v16; // [xsp+D0h] [xbp-50h]
  __int128 v17; // [xsp+E0h] [xbp-40h]
  _OWORD v18[2]; // [xsp+F0h] [xbp-30h] BYREF

  v13[1] = a4;
  v13[2] = a5;
  v13[0] = a3;
  v13[3] = a6;
  v13[4] = a7;
  v13[5] = a8;
  v10 = result;
  *(_QWORD *)&v17 = v13;
  *((_QWORD *)&v17 + 1) = 0xFFFFFF80FFFFFFD0LL;
  *(_QWORD *)&v16 = &a9;
  *((_QWORD *)&v16 + 1) = &v14;
  v14 = v16;
  v15 = v17;
  if ( !dword_6C36490 )
    result = sub_6780F78(&qword_6C36488);
  if ( qword_6C36488 )
    goto LABEL_4;
  if ( !dword_6C36450 )
    result = sub_6780F78(&qword_6C36448);
  if ( qword_6C36448 )
  {
    if ( qword_6C36788 < 0 || (result = sub_67F04A0(1uLL, (atomic_ullong *)&unk_7292250), result <= qword_6C36788) )
    {
LABEL_4:
      v18[0] = v14;
      v18[1] = v15;
      result = sub_6781784("mimalloc: error: ", a2, v18);
    }
  }
  if ( off_728A230 )
  {
    v11 = (__int64 (__fastcall *)(_QWORD, unsigned __int64))off_728A230;
    v12 = atomic_load(&qword_728A238);
    return v11(v10, v12);
  }
  return result;
}


================================================================================
Function: sub_6781BBC (0x6781BBC)
================================================================================

__int64 __fastcall sub_6781BBC(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  unsigned __int8 v3; // w8
  unsigned __int8 *v4; // x9
  int v5; // w10
  unsigned __int8 v6; // w12
  int v7; // w11
  unsigned __int8 v8; // w12
  int v9; // t1

  if ( !a3 )
    return 0LL;
  v3 = *a1;
  if ( *a1 )
  {
    v4 = a1 + 1;
    do
    {
      v5 = *a2;
      if ( !*a2 || !a3 )
        break;
      v6 = v3 - 32;
      if ( (unsigned __int8)(v3 - 97) >= 0x1Au )
        v6 = v3;
      v7 = v6;
      if ( (unsigned int)(v5 - 97) >= 0x1A )
        v8 = *a2;
      else
        v8 = v5 - 32;
      if ( v7 != v8 )
        return (unsigned int)((char)v3 - (char)v5);
      v9 = *v4++;
      v3 = v9;
      ++a2;
      --a3;
    }
    while ( v9 );
    if ( !a3 )
      return 0LL;
  }
  LOBYTE(v5) = *a2;
  return (unsigned int)((char)v3 - (char)v5);
}


================================================================================
Function: sub_6781C34 (0x6781C34)
================================================================================

_BYTE *__fastcall sub_6781C34(_BYTE *result, _BYTE *a2, unsigned __int64 a3)
{
  char v3; // w8
  unsigned __int64 v4; // x9
  unsigned __int8 *v5; // x10
  int v6; // t1
  bool v7; // cf

  if ( result && a2 && a3 )
  {
    v3 = *a2;
    if ( *a2 && a3 >= 2 )
    {
      v4 = a3 - 1;
      v5 = a2 + 1;
      do
      {
        *result++ = v3;
        v6 = *v5++;
        v3 = v6;
        v7 = v4-- != 0;
      }
      while ( v6 && v4 != 0 && v7 );
    }
    *result = 0;
  }
  return result;
}


================================================================================
Function: sub_6781C74 (0x6781C74)
================================================================================

__int64 __fastcall sub_6781C74(__int64 result)
{
  __int64 v1; // x8

  if ( result )
  {
    v1 = 0LL;
    while ( *(unsigned __int8 *)(result + v1++) )
      ;
    return v1 - 1;
  }
  return result;
}


================================================================================
Function: sub_6781DE8 (0x6781DE8)
================================================================================

__int64 sub_6781DE8()
{
  int v0; // w19

  v0 = *(unsigned __int8 *)sub_67EF968(qword_6C36798);
  if ( (v0 & 1) == 0 )
    *(_BYTE *)sub_67EF968(qword_6C36798) = 1;
  return v0 ^ 1u;
}


================================================================================
Function: sub_6781E2C (0x6781E2C)
================================================================================

_QWORD *sub_6781E2C()
{
  _QWORD *result; // x0

  result = sub_67EF968(qword_6C36798);
  *(_BYTE *)result = 0;
  return result;
}


================================================================================
Function: sub_6781E4C (0x6781E4C)
================================================================================

__int64 sub_6781E4C(char *a1, __int64 a2, __int64 a3, __int64 a4, ...)
{
  gcc_va_list arg; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, a4);
  va_copy(arg, va);
  return vsnprintf(a1, 0x40uLL, "%sthread 0x%llx: ", arg);
}


================================================================================
Function: sub_6781EF0 (0x6781EF0)
================================================================================

__int64 sub_6781EF0()
{
  return (unsigned __int8)byte_6C367D0;
}


================================================================================
Function: sub_6781EFC (0x6781EFC)
================================================================================

__int64 sub_6781EFC()
{
  return (unsigned __int8)byte_6C367D2;
}


================================================================================
Function: sub_6781F08 (0x6781F08)
================================================================================

__int64 sub_6781F08()
{
  return qword_6C367B8;
}


================================================================================
Function: sub_6781F14 (0x6781F14)
================================================================================

bool __fastcall sub_6781F14(unsigned __int64 a1, unsigned __int64 a2)
{
  return qword_6C367C0 && sub_67814F4(6u) && !(a1 % qword_6C367C0) && a2 % qword_6C367C0 == 0;
}


================================================================================
Function: sub_6781F7C (0x6781F7C)
================================================================================

unsigned __int64 __fastcall sub_6781F7C(unsigned __int64 result)
{
  unsigned __int64 v1; // x8
  unsigned __int64 v2; // x9

  if ( result >> 19 )
  {
    if ( result >= 0x200000 )
    {
      if ( result >= 0x800000 )
      {
        v1 = 0x400000LL;
        if ( !(result >> 25) )
          v1 = 0x100000LL;
      }
      else
      {
        v1 = 0x40000LL;
      }
    }
    else
    {
      v1 = 0x10000LL;
    }
  }
  else
  {
    v1 = qword_6C367B8;
  }
  if ( ~v1 > result )
  {
    v2 = result + v1 - 1;
    if ( (v1 & (v1 - 1)) != 0 )
      return v2 / v1 * v1;
    else
      return v2 & -(__int64)v1;
  }
  return result;
}


================================================================================
Function: sub_6781FFC (0x6781FFC)
================================================================================

__int64 sub_6781FFC()
{
  return sub_6789974(&qword_6C367B8);
}


================================================================================
Function: sub_6782008 (0x6782008)
================================================================================

unsigned __int64 __fastcall sub_6782008(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // x20
  unsigned __int64 v5; // x21
  void *v6; // x0
  __int64 v7; // x0

  if ( a1 - 33554433 < 0xFFFFFFFFFE000001LL )
    return 0LL;
  v2 = (a2 + 0x1FFFFFF) & 0xFFFFFFFFFE000000LL;
  if ( v2 > 0x40000000 )
    return 0LL;
  v5 = sub_67F04A0(v2, (atomic_ullong *)&unk_7292280);
  if ( v5 - 0x1E0000000001LL <= 0xFFFFE1FFFFFFFFFFLL )
  {
    if ( dword_6C367E0 == -1 )
      v6 = sub_677FEB4();
    else
      v6 = pthread_getspecific(dword_6C367E0);
    if ( !v6 )
      v6 = &unk_6BDF6C0;
    v7 = sub_677DCCC((__int64)v6);
    sub_67F0010(v5 + v2, ((v7 << 8) & 0x3FFFE000000LL) + 0x20000000000LL, (atomic_ullong *)&unk_7292280);
    v5 = sub_67F04A0(v2, (atomic_ullong *)&unk_7292280);
  }
  if ( v5 % a1 )
    return 0LL;
  else
    return v5;
}


================================================================================
Function: sub_67820FC (0x67820FC)
================================================================================

unsigned __int64 __fastcall sub_67820FC(unsigned __int64 result, unsigned __int64 a2, char a3, char **a4)
{
  int v4; // w8
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x10
  unsigned __int64 v8; // x10
  char *v9; // x21
  unsigned __int64 v10; // x20
  int v11; // w0
  int v12; // w0

  v4 = *((_DWORD *)a4 + 5);
  if ( (unsigned int)(v4 - 3) <= 2 )
  {
    if ( a2 >> 19 )
    {
      if ( a2 >= 0x200000 )
      {
        if ( a2 >= 0x800000 )
        {
          v6 = 0x400000LL;
          if ( !(a2 >> 25) )
            v6 = 0x100000LL;
        }
        else
        {
          v6 = 0x40000LL;
        }
      }
      else
      {
        v6 = 0x10000LL;
      }
    }
    else
    {
      v6 = qword_6C367B8;
    }
    if ( ~v6 > a2 )
    {
      v7 = a2 + v6 - 1;
      if ( (v6 & (v6 - 1)) != 0 )
        a2 = v7 / v6 * v6;
      else
        a2 = v7 & -(__int64)v6;
    }
    v8 = result - (_QWORD)*a4;
    if ( *a4 )
    {
      v9 = *a4;
    }
    else
    {
      v8 = 0LL;
      v9 = (char *)result;
    }
    v10 = v8 + a2;
    if ( v4 == 4 )
    {
      if ( v9 && v10 >> 30 )
      {
        do
        {
          v11 = sub_6789A40(v9, 0x40000000LL);
          if ( v11 )
            sub_6781928(
              (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
              v11,
              v11,
              0x40000000uLL,
              v9);
          sub_67886E8((unsigned __int64)&unk_7289F60, 0x40000000uLL);
          result = sub_67886E8((unsigned __int64)&unk_7289F40, 0x40000000uLL);
          v10 -= 0x40000000LL;
          v9 += 0x40000000;
        }
        while ( v10 >> 30 );
      }
    }
    else if ( v9 && v10 )
    {
      v12 = sub_6789A40(v9, v8 + a2);
      if ( v12 )
        sub_6781928(
          (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
          v12,
          v12,
          v10,
          v9);
      if ( (a3 & 1) != 0 )
        sub_67886E8((unsigned __int64)&unk_7289F60, v10);
      return sub_67886E8((unsigned __int64)&unk_7289F40, v10);
    }
  }
  return result;
}


================================================================================
Function: sub_67822B8 (0x67822B8)
================================================================================

__int64 __fastcall sub_67822B8(__int64 a1, __int64 a2, __int128 *a3)
{
  __int64 v3; // x8
  __int128 v5; // [xsp+0h] [xbp-20h] BYREF
  __int64 v6; // [xsp+10h] [xbp-10h]

  v3 = *((_QWORD *)a3 + 2);
  v5 = *a3;
  v6 = v3;
  return sub_67820FC(a1, a2, 1LL, &v5);
}


================================================================================
Function: sub_6782318 (0x6782318)
================================================================================

unsigned __int64 __fastcall sub_6782318(unsigned __int64 result, __int64 a2)
{
  signed __int64 v3; // x20
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x9
  int v6; // w0
  char v7; // w8
  char v8; // w10
  _BYTE v9[4]; // [xsp+8h] [xbp-18h] BYREF
  _BYTE v10[4]; // [xsp+Ch] [xbp-14h] BYREF
  unsigned __int64 v11; // [xsp+10h] [xbp-10h] BYREF

  *(_QWORD *)a2 = 0LL;
  *(_QWORD *)(a2 + 8) = 0LL;
  *(_QWORD *)(a2 + 16) = 0LL;
  if ( result )
  {
    v3 = result;
    if ( result >> 19 )
    {
      if ( result >= 0x200000 )
      {
        if ( result >= 0x800000 )
        {
          v4 = 0x400000LL;
          if ( !(result >> 25) )
            v4 = 0x100000LL;
        }
        else
        {
          v4 = 0x40000LL;
        }
      }
      else
      {
        v4 = 0x10000LL;
      }
    }
    else
    {
      v4 = qword_6C367B8;
    }
    if ( ~v4 <= result )
    {
      v10[0] = 0;
    }
    else
    {
      v5 = result + v4 - 1;
      if ( (v4 & (v4 - 1)) != 0 )
      {
        v3 = v5 / v4 * v4;
        v10[0] = 0;
        if ( !v3 )
          return 0LL;
      }
      else
      {
        v3 = v5 & -(__int64)v4;
        v10[0] = 0;
        if ( !v3 )
          return 0LL;
      }
    }
    v9[0] = 0;
    v11 = 0LL;
    v6 = sub_6789A70(v3, 1LL, 1LL, 0LL, v10, v9, &v11);
    if ( v6 )
      sub_6781928(
        (signed __int64)"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, align: 0x%zx, commit: %d, allow large: %d)\n",
        v6,
        v6,
        v3,
        1uLL,
        1,
        0);
    if ( !v11 )
      return 0LL;
    sub_6788604((unsigned __int64)&unk_7289F40, v3);
    sub_6788604((unsigned __int64)&unk_7289F60, v3);
    result = v11;
    if ( v11 )
    {
      v7 = v10[0];
      v8 = v9[0];
      *(_QWORD *)a2 = 0LL;
      *(_QWORD *)(a2 + 8) = 0LL;
      *(_BYTE *)(a2 + 19) = 0;
      *(_BYTE *)(a2 + 16) = v7;
      *(_BYTE *)(a2 + 17) = 1;
      *(_BYTE *)(a2 + 18) = v8;
      *(_DWORD *)(a2 + 20) = 3;
    }
  }
  return result;
}


================================================================================
Function: sub_67824BC (0x67824BC)
================================================================================

const void *__fastcall sub_67824BC(unsigned __int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4, __int64 a5)
{
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  const void *v9; // x23
  unsigned __int64 v10; // x11
  uint8x8_t v11; // d0
  unsigned __int64 v12; // x12
  __int64 v13; // x11
  __int64 v14; // x12
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x21
  uint8x8_t v17; // d0
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x22
  __int64 v20; // x23
  int v21; // w24
  unsigned int v22; // w25
  int v23; // w0
  int v24; // w0
  int v25; // w0
  __int64 v26; // x3
  unsigned __int64 v27; // x27
  unsigned __int64 v28; // x8
  char v29; // w8
  char v30; // w10
  int v31; // w0
  const void *v32; // x25
  unsigned __int64 v33; // x24
  unsigned __int64 v34; // x9
  __int64 v35; // x9
  unsigned __int64 v37; // x22
  __int64 v38; // x23
  int v39; // w0
  const void *v40; // x23
  int v41; // w0
  _BYTE v42[4]; // [xsp+8h] [xbp-18h] BYREF
  _BYTE v43[4]; // [xsp+Ch] [xbp-14h] BYREF
  unsigned __int64 v44; // [xsp+10h] [xbp-10h] BYREF

  *(_QWORD *)a5 = 0LL;
  *(_QWORD *)(a5 + 8) = 0LL;
  *(_QWORD *)(a5 + 16) = 0LL;
  if ( !a1 )
    return 0LL;
  if ( a1 >> 19 )
  {
    if ( a1 >= 0x200000 )
    {
      if ( a1 >= 0x800000 )
      {
        v7 = 0x400000LL;
        if ( !(a1 >> 25) )
          v7 = 0x100000LL;
      }
      else
      {
        v7 = 0x40000LL;
      }
    }
    else
    {
      v7 = 0x10000LL;
    }
  }
  else
  {
    v7 = qword_6C367B8;
  }
  if ( ~v7 > a1 )
  {
    v8 = a1 + v7 - 1;
    if ( (v7 & (v7 - 1)) != 0 )
      a1 = v8 / v7 * v7;
    else
      a1 = v8 & -(__int64)v7;
  }
  v9 = 0LL;
  v43[0] = 0;
  v10 = qword_6C367B8 - 1 + a2;
  v11.n64_u64[0] = vcnt_s8((int8x8_t)qword_6C367B8).n64_u64[0];
  v12 = v10 / qword_6C367B8;
  v13 = v10 & -qword_6C367B8;
  v11.n64_u16[0] = vaddlv_u8(v11);
  v14 = v12 * qword_6C367B8;
  v15 = v11.n64_u32[0];
  if ( v11.n64_u32[0] <= 1uLL )
    v16 = v13;
  else
    v16 = v14;
  if ( qword_6C367B8 <= v16 )
  {
    v17.n64_u64[0] = vcnt_s8((int8x8_t)v16).n64_u64[0];
    v17.n64_u16[0] = vaddlv_u8(v17);
    if ( v17.n64_u32[0] <= 1uLL )
    {
      v18 = qword_6C367B8 - 1 + a1;
      if ( v15 > 1 )
      {
        v19 = v18 / qword_6C367B8 * qword_6C367B8;
        if ( !v19 )
          return 0LL;
      }
      else
      {
        v19 = v18 & -qword_6C367B8;
        if ( !v19 )
          return 0LL;
      }
      if ( v16 )
        v20 = v16;
      else
        v20 = 1LL;
      v21 = a3 & 1;
      v22 = a3 & a4 & 1;
      v42[0] = 0;
      v44 = 0LL;
      v23 = sub_6789A70(v19, v20, a3 & 1, v22, (__int64)v43, v42, (__int64 *)&v44);
      if ( v23 )
        sub_6781928(
          (signed __int64)"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, align: 0x%zx, commit: %d, a"
                          "llow large: %d)\n",
          v23,
          v23,
          v19,
          v20,
          v21,
          v22);
      if ( !v44 )
        return 0LL;
      sub_6788604((unsigned __int64)&unk_7289F40, v19);
      if ( (a3 & 1) != 0 )
        sub_6788604((unsigned __int64)&unk_7289F60, v19);
      v9 = (const void *)v44;
      if ( v44 )
      {
        if ( !(v44 % v16) )
        {
          v27 = v44;
LABEL_47:
          v29 = v43[0];
          v30 = v42[0];
          *(_BYTE *)(a5 + 19) = 0;
          *(_BYTE *)(a5 + 16) = v29;
          *(_BYTE *)(a5 + 17) = a3 & 1;
          *(_BYTE *)(a5 + 18) = v30;
          *(_DWORD *)(a5 + 20) = 3;
          *(_QWORD *)a5 = v27;
          *(_QWORD *)(a5 + 8) = v16;
          return v9;
        }
        sub_6781928(
          (signed __int64)"unable to allocate aligned OS memory directly, fall back to over-allocation (size: 0x%zx bytes"
                          ", address: %p, alignment: 0x%zx, commit: %d)\n",
          v19,
          (const void *)v44,
          v16,
          a3 & 1);
        v24 = sub_6789A40(v9, v19);
        if ( v24 )
          sub_6781928(
            (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
            v24,
            v24,
            v19,
            v9);
        if ( (a3 & 1) != 0 )
          sub_67886E8((unsigned __int64)&unk_7289F60, v19);
        sub_67886E8((unsigned __int64)&unk_7289F40, v19);
        if ( v19 >= ~v16 )
          return 0LL;
        v9 = (const void *)(v19 + v16);
        if ( !byte_6C367D1 )
        {
          if ( !v9 )
            return v9;
          v42[0] = 0;
          v44 = 0LL;
          v31 = sub_6789A70(v19 + v16, 1LL, a3 & 1, 0, (__int64)v43, v42, (__int64 *)&v44);
          if ( v31 )
            sub_6781928(
              (signed __int64)"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, align: 0x%zx, commit: %"
                              "d, allow large: %d)\n",
              v31,
              v31,
              v19 + v16,
              1uLL,
              a3 & 1,
              0);
          if ( !v44 )
            return 0LL;
          sub_6788604((unsigned __int64)&unk_7289F40, v19 + v16);
          if ( (a3 & 1) != 0 )
            sub_6788604((unsigned __int64)&unk_7289F60, v19 + v16);
          v32 = (const void *)v44;
          if ( !v44 )
            return 0LL;
          v27 = (v16 + v44 - 1) & -(__int64)v16;
          v33 = v27 - v44;
          v34 = v19 + qword_6C367B8 - 1;
          if ( (qword_6C367B8 & (qword_6C367B8 - 1)) != 0 )
            v35 = v34 / qword_6C367B8 * qword_6C367B8;
          else
            v35 = v34 & -qword_6C367B8;
          v37 = (unsigned __int64)v9 - v33 - v35;
          if ( v33 )
          {
            v38 = v35;
            v39 = sub_6789A40(v44, v27 - v44);
            if ( v39 )
              sub_6781928(
                (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
                v39,
                v39,
                v27 - (_QWORD)v32,
                v32);
            if ( (a3 & 1) != 0 )
              sub_67886E8((unsigned __int64)&unk_7289F60, v27 - (_QWORD)v32);
            sub_67886E8((unsigned __int64)&unk_7289F40, v27 - (_QWORD)v32);
            v35 = v38;
          }
          if ( v37 && v27 )
          {
            v40 = (const void *)(v27 + v35);
            v41 = sub_6789A40(v27 + v35, v37);
            if ( v41 )
              sub_6781928(
                (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
                v41,
                v41,
                v37,
                v40);
            if ( (a3 & 1) != 0 )
              sub_67886E8((unsigned __int64)&unk_7289F60, v37);
            sub_67886E8((unsigned __int64)&unk_7289F40, v37);
          }
          v9 = (const void *)(((unsigned __int64)v32 + v16 - 1) & -(__int64)v16);
          goto LABEL_74;
        }
        if ( v9 )
        {
          v42[0] = 0;
          v44 = 0LL;
          v25 = sub_6789A70(v19 + v16, 1LL, 0, 0, (__int64)v43, v42, (__int64 *)&v44);
          if ( v25 )
            sub_6781928(
              (signed __int64)"unable to allocate OS memory (error: %d (0x%x), size: 0x%zx bytes, align: 0x%zx, commit: %"
                              "d, allow large: %d)\n",
              v25,
              v25,
              v19 + v16,
              1uLL,
              0,
              0);
          if ( !v44 )
            return 0LL;
          sub_6788604((unsigned __int64)&unk_7289F40, v19 + v16);
          v27 = v44;
          if ( !v44 )
            return 0LL;
          v28 = v16 + v44 - 1;
          v9 = (const void *)(v28 & -(__int64)v16);
          if ( (a3 & 1) != 0 )
            sub_6782B4C(v28 & -(__int64)v16, v19, 0LL, v26);
LABEL_74:
          if ( !v9 )
            return v9;
          goto LABEL_47;
        }
      }
    }
  }
  return v9;
}


================================================================================
Function: sub_67829A8 (0x67829A8)
================================================================================

const void *__fastcall sub_67829A8(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        char a4,
        char a5,
        _QWORD *a6)
{
  unsigned __int64 v6; // x19
  unsigned __int64 v9; // x8
  __int64 v10; // x8
  unsigned __int64 v11; // x21
  char *v12; // x0
  char *v13; // x22
  __int64 v14; // x8
  unsigned __int64 v15; // x9
  bool v16; // zf
  unsigned __int64 v17; // x10
  __int64 v18; // x9
  __int64 v19; // x10
  __int64 v20; // x8
  const void *v21; // x20
  __int64 v22; // x21
  int v23; // w0
  char v24[4]; // [xsp+4h] [xbp-Ch] BYREF

  v6 = 0LL;
  *a6 = 0LL;
  a6[1] = 0LL;
  a6[2] = 0LL;
  if ( a3 > 0x2000000 )
    return (const void *)v6;
  if ( a3 )
  {
    v9 = a2 - 1 + a3;
    if ( (a2 & (a2 - 1)) != 0 )
      v10 = v9 / a2 * a2;
    else
      v10 = v9 & -(__int64)a2;
    v11 = v10 - a3;
    v12 = (char *)sub_67824BC(v10 - a3 + a1, a2, a4 & 1, a5 & 1, (__int64)a6);
    if ( !v12 )
      return 0LL;
    v13 = v12;
    v6 = (unsigned __int64)&v12[v11];
    if ( (a4 & 1) != 0 && v11 > qword_6C367B8 )
    {
      sub_67886E8((unsigned __int64)&unk_7289F60, v11);
      v14 = qword_6C367B8;
      v15 = (unsigned __int64)&v13[qword_6C367B8 - 1];
      v16 = (v14 & (v14 - 1)) == 0;
      v17 = v15 / qword_6C367B8;
      v18 = v15 & -qword_6C367B8;
      v19 = v17 * qword_6C367B8;
      if ( (v14 & (v14 - 1)) != 0 )
        v20 = v6 / qword_6C367B8 * qword_6C367B8;
      else
        v20 = -qword_6C367B8 & v6;
      if ( v16 )
        v21 = (const void *)v18;
      else
        v21 = (const void *)v19;
      v22 = v20 - (_QWORD)v21;
      if ( v20 - (__int64)v21 >= 1 )
      {
        v24[0] = 1;
        v23 = sub_6789CE4(v21, v22, v24);
        if ( v23 )
          sub_6781928(
            (signed __int64)"cannot decommit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\n",
            v23,
            v23,
            v21,
            v22);
      }
    }
    return (const void *)v6;
  }
  return sub_67824BC(a1, a2, a4 & 1, a5 & 1, (__int64)a6);
}


================================================================================
Function: sub_6782B4C (0x6782B4C)
================================================================================

bool __fastcall sub_6782B4C(unsigned __int64 a1, signed __int64 a2, _BYTE *a3)
{
  _BOOL4 v6; // w20
  __int64 v7; // x9
  __int64 v8; // x21
  __int64 v9; // x8
  unsigned __int64 v10; // x10
  __int64 v11; // x22
  int v12; // w0
  _BYTE v14[4]; // [xsp+4h] [xbp-Ch] BYREF

  if ( a3 )
    *a3 = 0;
  sub_6788604((unsigned __int64)&unk_7289F60, a2);
  v6 = 1;
  sub_6788598((unsigned __int64)&unk_728A100, 1uLL);
  if ( a1 && a2 )
  {
    if ( (qword_6C367B8 & (qword_6C367B8 - 1)) != 0 )
    {
      v10 = qword_6C367B8 + a1 + a2 - 1;
      v8 = a1 / qword_6C367B8 * qword_6C367B8;
      v9 = v10 / qword_6C367B8 * qword_6C367B8;
    }
    else
    {
      v7 = qword_6C367B8 + a1 + a2 - 1;
      v8 = -qword_6C367B8 & a1;
      v9 = v7 & -qword_6C367B8;
    }
    v11 = v9 - v8;
    if ( v9 - v8 < 1 )
    {
      return 1;
    }
    else
    {
      v14[0] = 0;
      v12 = sub_6789CBC(v8, v9 - v8, v14);
      v6 = v12 == 0;
      if ( v12 )
      {
        sub_6781928(
          (signed __int64)"cannot commit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\n",
          v12,
          v12,
          (const void *)v8,
          v11);
      }
      else if ( a3 && v14[0] )
      {
        *a3 = 1;
      }
    }
  }
  return v6;
}


================================================================================
Function: sub_6782C98 (0x6782C98)
================================================================================

__int64 __fastcall sub_6782C98(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // w22
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x10
  __int64 v6; // x9
  __int64 v7; // x10
  __int64 v8; // x8
  const void *v9; // x20
  __int64 v10; // x21
  int v12; // w0

  v3 = 1;
  if ( a1 && a2 )
  {
    v4 = a1 + qword_6C367B8 - 1;
    v5 = v4 / qword_6C367B8;
    v6 = v4 & -qword_6C367B8;
    v7 = v5 * qword_6C367B8;
    if ( (qword_6C367B8 & (qword_6C367B8 - 1)) != 0 )
      v8 = (a1 + a2) / (unsigned __int64)qword_6C367B8 * qword_6C367B8;
    else
      v8 = -qword_6C367B8 & (a1 + a2);
    if ( (qword_6C367B8 & (qword_6C367B8 - 1)) != 0 )
      v9 = (const void *)v7;
    else
      v9 = (const void *)v6;
    v10 = v8 - (_QWORD)v9;
    if ( v8 - (__int64)v9 < 1 )
    {
      return 1;
    }
    else
    {
      sub_6788604(a3 + 128, v8 - (_QWORD)v9);
      v3 = 1;
      sub_6788598(a3 + 528, 1LL);
      v12 = sub_6789D0C(v9, v10);
      if ( v12 )
      {
        sub_6781928(
          (signed __int64)"cannot reset OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\n",
          v12,
          v12,
          v9,
          v10);
        return 0;
      }
    }
  }
  return v3;
}


================================================================================
Function: sub_6782D6C (0x6782D6C)
================================================================================

bool __fastcall sub_6782D6C(__int64 a1, unsigned __int64 a2, char a3, __int64 a4)
{
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x10
  __int64 v11; // x19
  __int64 v12; // x8
  __int64 v13; // x20
  int v14; // w0
  char v15[4]; // [xsp+4h] [xbp-Ch] BYREF

  if ( sub_6780DEC(0xFu) < 0 )
    return 0LL;
  sub_6788598(a4 + 544, 1uLL);
  sub_6788604(a4 + 160, a2);
  if ( !sub_67814F4(5u) || sub_6780B10() )
  {
    if ( (a3 & 1) != 0 )
      sub_6782C98(a1, a2, a4);
    return 0LL;
  }
  v15[0] = 1;
  sub_67886E8((unsigned __int64)&unk_7289F60, a2);
  if ( a1 && a2 )
  {
    v9 = a1 + qword_6C367B8 - 1;
    v10 = a1 + a2;
    if ( (qword_6C367B8 & (qword_6C367B8 - 1)) != 0 )
    {
      v11 = v9 / qword_6C367B8 * qword_6C367B8;
      v12 = v10 / qword_6C367B8 * qword_6C367B8;
    }
    else
    {
      v11 = v9 & -qword_6C367B8;
      v12 = -qword_6C367B8 & v10;
    }
    v13 = v12 - v11;
    if ( v12 - v11 >= 1 )
    {
      v15[0] = 1;
      v14 = sub_6789CE4(v11, v13, v15);
      if ( v14 )
        sub_6781928(
          (signed __int64)"cannot decommit OS memory (error: %d (0x%x), address: %p, size: 0x%zx bytes)\n",
          v14,
          v14,
          (const void *)v11,
          v13);
    }
  }
  return v15[0] != 0;
}


================================================================================
Function: sub_6782EDC (0x6782EDC)
================================================================================

__int64 __fastcall sub_6782EDC(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_6782D6C(a1, a2, 1LL, a3);
}


================================================================================
Function: sub_6782EE8 (0x6782EE8)
================================================================================

unsigned __int64 __fastcall sub_6782EE8(__int64 a1, unsigned int a2, __int64 a3, _QWORD *a4, _QWORD *a5, __int64 a6)
{
  unsigned __int64 v8; // x26
  void *v9; // x0
  unsigned __int64 v10; // x22
  unsigned __int64 v11; // x0
  bool v12; // zf
  __int64 v13; // x0
  __int64 v14; // x28
  __int64 v15; // x26
  char v16; // w20
  char *v17; // x27
  int v18; // w0
  unsigned __int64 v19; // x0
  __int64 v20; // x8
  _QWORD *v21; // x19
  _QWORD *v22; // x24
  const void *v23; // x23
  int v24; // w0
  char *v30; // [xsp+28h] [xbp-18h] BYREF
  char v31[4]; // [xsp+34h] [xbp-Ch] BYREF

  *(_QWORD *)a6 = 0LL;
  *(_QWORD *)(a6 + 8) = 0LL;
  *(_QWORD *)(a6 + 16) = 0LL;
  if ( a5 )
    *a5 = 0LL;
  if ( a4 )
    *a4 = 0LL;
  v8 = qword_72922C0;
  do
  {
    v10 = v8;
    if ( !v8 )
    {
      if ( dword_6C367E0 == -1 )
        v9 = sub_677FEB4();
      else
        v9 = pthread_getspecific(dword_6C367E0);
      if ( !v9 )
        v9 = &unk_6BDF6C0;
      v10 = ((((unsigned __int64)sub_677DCCC((__int64)v9) >> 17) & 0xFFF) << 30) | 0x200000000000LL;
    }
    v11 = sub_67F0010(v8, v10 + (a1 << 30), (atomic_ullong *)&qword_72922C0);
    v12 = v11 == v8;
    v8 = v11;
  }
  while ( !v12 );
  v13 = sub_6788860();
  if ( a1 )
  {
    v14 = v13;
    v15 = 0LL;
    v16 = 1;
    v17 = (char *)v10;
    while ( 1 )
    {
      v31[0] = 0;
      v30 = 0LL;
      v18 = sub_6789DD4(v17, 0x40000000LL, a2, v31, &v30);
      v16 &= v31[0] != 0;
      if ( v18 )
        break;
      if ( v17 != v30 )
      {
        if ( v30 )
        {
          sub_6781928((signed __int64)"could not allocate contiguous huge OS page %zu at %p\n", v15, v17);
          v23 = v30;
          v21 = a5;
          if ( v30 )
          {
            v24 = sub_6789A40(v30, 0x40000000uLL);
            v22 = a4;
            if ( v24 )
              sub_6781928(
                (signed __int64)"unable to free OS memory (error: %d (0x%x), size: 0x%zx bytes, address: %p)\n",
                v24,
                v24,
                0x40000000uLL,
                v23);
            sub_67886E8((unsigned __int64)&unk_7289F60, 0x40000000uLL);
            sub_67886E8((unsigned __int64)&unk_7289F40, 0x40000000uLL);
            a1 = v15;
            goto LABEL_35;
          }
LABEL_28:
          v22 = a4;
          a1 = v15;
          goto LABEL_35;
        }
LABEL_27:
        v21 = a5;
        goto LABEL_28;
      }
      sub_6788604((unsigned __int64)&unk_7289F60, 0x40000000LL);
      sub_6788604((unsigned __int64)&unk_7289F40, 0x40000000LL);
      if ( a3 >= 1 )
      {
        v19 = sub_678934C(v14);
        v20 = (__int64)(v19 / (v15 + 2) * a1) <= 2 * a3 ? v19 : a3 + 1;
        if ( v20 > a3 )
        {
          sub_6781928((signed __int64)"huge OS page allocation timed out (after allocating %zu page(s))\n", ++v15);
          goto LABEL_27;
        }
      }
      ++v15;
      v17 += 0x40000000;
      if ( a1 == v15 )
        goto LABEL_34;
    }
    sub_6781928(
      (signed __int64)"unable to allocate huge OS page (error: %d (0x%x), address: %p, size: %zx bytes)\n",
      v18,
      v18,
      v17,
      0x40000000uLL);
    goto LABEL_27;
  }
  v16 = 1;
LABEL_34:
  v22 = a4;
  v21 = a5;
LABEL_35:
  if ( v22 )
    *v22 = a1;
  if ( v21 )
    *v21 = a1 << 30;
  if ( !a1 )
    return 0LL;
  *(_QWORD *)a6 = 0LL;
  *(_QWORD *)(a6 + 8) = 0LL;
  *(_BYTE *)(a6 + 18) = v16;
  *(_WORD *)(a6 + 16) = 257;
  *(_BYTE *)(a6 + 19) = 0;
  *(_DWORD *)(a6 + 20) = 4;
  return v10;
}


================================================================================
Function: sub_67831DC (0x67831DC)
================================================================================

signed __int64 sub_67831DC()
{
  signed __int64 v0; // x19
  __int64 v1; // x0

  v0 = atomic_load((unsigned __int64 *)&qword_7292288);
  if ( !v0 )
  {
    v0 = sub_6780DEC(0x10u);
    if ( v0 <= 0 )
    {
      v1 = sub_6789EC8();
      if ( v1 )
        v0 = v1;
      else
        v0 = 1LL;
    }
    atomic_store(v0, (unsigned __int64 *)&qword_7292288);
    sub_6780E3C((__int64)"using %zd numa regions\n", v0);
  }
  return v0;
}


================================================================================
Function: sub_678323C (0x678323C)
================================================================================

unsigned __int64 sub_678323C()
{
  unsigned __int64 v0; // x19
  unsigned __int64 result; // x0
  __int64 v2; // x0
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v5; // x3
  __int64 v6; // x0

  v0 = qword_7292288;
  if ( !qword_7292288 )
  {
    v0 = atomic_load((unsigned __int64 *)&qword_7292288);
    if ( !v0 )
    {
      v2 = sub_6780DEC(0x10u);
      v0 = v2;
      if ( v2 <= 0 )
      {
        v6 = sub_6789EC8(v2, v3, v4, v5);
        if ( v6 )
          v0 = v6;
        else
          v0 = 1LL;
      }
      atomic_store(v0, (unsigned __int64 *)&qword_7292288);
      sub_6780E3C((__int64)"using %zd numa regions\n", v0);
    }
  }
  if ( v0 < 2 )
    return 0LL;
  result = sub_6789EC0();
  if ( result >= v0 )
    result %= v0;
  return result;
}


================================================================================
Function: sub_67834F8 (0x67834F8)
================================================================================

__int64 __fastcall sub_67834F8(__int64 a1, unsigned int a2, char a3)
{
  __int64 result; // x0
  char v7; // w21

  result = sub_6783548(a1, a2, a3);
  if ( (result & 1) == 0 )
  {
    v7 = a3 & 1;
    do
    {
      __wfe();
      result = sub_6783548(a1, a2, v7);
    }
    while ( (result & 1) == 0 );
  }
  return result;
}


================================================================================
Function: sub_6783548 (0x6783548)
================================================================================

__int64 __fastcall sub_6783548(__int64 a1, unsigned int a2, char a3)
{
  __int64 v5; // x22
  unsigned __int8 v6; // w23
  unsigned __int64 v7; // x21
  int v8; // w8
  __int64 result; // x0
  unsigned __int64 v10; // x21
  int v11; // w8
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x21
  int v14; // w8
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x21
  int v17; // w8
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x21
  int v20; // w8
  unsigned __int64 v21; // x8

  v5 = a2;
  v6 = a3 ^ 1;
  while ( 1 )
  {
    v7 = atomic_load((unsigned __int64 *)(a1 + 40));
    v8 = v7 & 3;
    if ( v8 == 1 )
      break;
    if ( v8 == a2
      || (v6 & (v8 == 3)) != 0
      || sub_67EFFD0(v7, v7 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40)) == v7 )
    {
      return 1LL;
    }
  }
  __wfe();
  while ( 1 )
  {
    v10 = atomic_load((unsigned __int64 *)(a1 + 40));
    v11 = v10 & 3;
    if ( v11 == 1 )
      break;
    if ( v11 == a2 || (v6 & (v11 == 3)) != 0 )
      return 1LL;
    v12 = sub_67EFFD0(v10, v10 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40));
    result = 1LL;
    if ( v12 == v10 )
      return result;
  }
  __wfe();
  while ( 1 )
  {
    v13 = atomic_load((unsigned __int64 *)(a1 + 40));
    v14 = v13 & 3;
    if ( v14 == 1 )
      break;
    if ( v14 == a2 || (v6 & (v14 == 3)) != 0 )
      return 1LL;
    v15 = sub_67EFFD0(v13, v13 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40));
    result = 1LL;
    if ( v15 == v13 )
      return result;
  }
  __wfe();
  while ( 1 )
  {
    v16 = atomic_load((unsigned __int64 *)(a1 + 40));
    v17 = v16 & 3;
    if ( v17 == 1 )
      break;
    if ( v17 == a2 || (v6 & (v17 == 3)) != 0 )
      return 1LL;
    v18 = sub_67EFFD0(v16, v16 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40));
    result = 1LL;
    if ( v18 == v16 )
      return result;
  }
  __wfe();
  while ( 1 )
  {
    v19 = atomic_load((unsigned __int64 *)(a1 + 40));
    v20 = v19 & 3;
    if ( v20 == 1 )
      break;
    if ( v20 == a2 || (v6 & (v20 == 3)) != 0 )
      return 1LL;
    v21 = sub_67EFFD0(v19, v19 & 0xFFFFFFFFFFFFFFFCLL | v5, (atomic_ullong *)(a1 + 40));
    result = 1LL;
    if ( v21 == v19 )
      return result;
  }
  return 0LL;
}


================================================================================
Function: sub_6783734 (0x6783734)
================================================================================

unsigned __int64 __fastcall sub_6783734(unsigned __int64 result, char a2)
{
  unsigned __int64 v3; // x19
  unsigned __int64 v4; // x21
  __int64 v5; // x2
  __int64 v6; // x3
  __int64 v7; // x4
  __int64 v8; // x5
  __int64 v9; // x6
  __int64 v10; // x7
  _QWORD **v11; // x8
  _QWORD *v12; // x12
  unsigned int v13; // w10
  unsigned int v14; // w9
  _QWORD *v15; // x11
  unsigned int v16; // w13
  _QWORD *v18; // x8
  __int64 v19; // x9
  char v20; // w9
  int v21; // w9
  __int64 v22; // x12
  _QWORD *v23; // x11
  _QWORD *v24; // x10
  __int64 v25; // [xsp+0h] [xbp+0h]

  v3 = result;
  if ( (a2 & 1) != 0 || *(_QWORD *)(result + 40) >= 4uLL )
  {
    result = *(_QWORD *)(result + 40);
    do
    {
      v4 = result;
      result = sub_67F0010(result, result & 3, (atomic_ullong *)(v3 + 40));
    }
    while ( result != v4 );
    v11 = (_QWORD **)(v4 & 0xFFFFFFFFFFFFFFFCLL);
    if ( (v4 & 0xFFFFFFFFFFFFFFFCLL) != 0 )
    {
      v12 = *v11;
      v13 = 1;
      v14 = *(unsigned __int16 *)(v3 + 10);
      v15 = (_QWORD *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
      if ( *v11 && *(_WORD *)(v3 + 10) )
      {
        v16 = 1;
        do
        {
          v15 = v12;
          v12 = (_QWORD *)*v12;
          v13 = v16 + 1;
          if ( !v12 )
            break;
        }
        while ( v16++ < v14 );
      }
      if ( v13 <= v14 )
      {
        v21 = *(_DWORD *)(v3 + 24);
        v22 = *(_QWORD *)(v3 + 32);
        *(_QWORD *)(v3 + 32) = v11;
        *v15 = v22;
        *(_DWORD *)(v3 + 24) = v21 - v13;
        v18 = *(_QWORD **)(v3 + 32);
        if ( !v18 )
          return result;
        goto LABEL_15;
      }
      result = sub_6781A58(14LL, "corrupted thread-free list\n", v5, v6, v7, v8, v9, v10, v25);
    }
  }
  v18 = *(_QWORD **)(v3 + 32);
  if ( !v18 )
    return result;
LABEL_15:
  v19 = *(_QWORD *)(v3 + 16);
  if ( !v19 )
  {
LABEL_16:
    v20 = *(_BYTE *)(v3 + 15);
    *(_QWORD *)(v3 + 16) = v18;
    *(_QWORD *)(v3 + 32) = 0LL;
    *(_BYTE *)(v3 + 15) = v20 & 0xFE;
    return result;
  }
  if ( (a2 & 1) != 0 )
  {
    v23 = v18;
    do
    {
      v24 = v23;
      v23 = (_QWORD *)*v23;
    }
    while ( v23 );
    *v24 = v19;
    goto LABEL_16;
  }
  return result;
}


================================================================================
Function: sub_6783844 (0x6783844)
================================================================================

__int64 __fastcall sub_6783844(__int64 a1, unsigned int *a2)
{
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  char v7; // w9
  __int64 v9; // [xsp+0h] [xbp-10h] BYREF

  v4 = a2[7];
  if ( (v4 & 0x80000000) != 0 )
  {
    sub_6785898(((unsigned __int64)a2 - 1) & 0xFFFFFFFFFE000000LL, a2, &v9);
    v4 = v9;
  }
  v5 = v4 + 7;
  if ( (unsigned __int64)(v4 + 7) >= 0x10 )
  {
    v6 = v5 >> 3;
    if ( v5 > 0x47 )
    {
      if ( v5 <= 0x20007 )
      {
        v7 = __clz(--v6);
        LODWORD(v6) = ((v6 >> (61 - v7)) & 3 | (4 * (unsigned __int8)(63 - v7))) + 253;
      }
      else
      {
        LOBYTE(v6) = 73;
      }
    }
    else
    {
      LOBYTE(v6) = (v6 + 1) & 0xFE;
    }
  }
  else
  {
    LOBYTE(v6) = 1;
  }
  return sub_6783944(a1, (unsigned __int64 *)(a1 + 24LL * (unsigned __int8)v6 + 1040), (unsigned __int64)a2);
}


================================================================================
Function: sub_6783944 (0x6783944)
================================================================================

__int64 __fastcall sub_6783944(__int64 result, unsigned __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 *v3; // x11
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x12
  int v7; // w12
  unsigned __int8 v8; // w11
  unsigned __int64 v9; // x11
  unsigned __int64 v10; // x15
  unsigned __int64 v11; // x14
  int v12; // w15
  unsigned __int8 v13; // w16
  bool v14; // cc
  unsigned __int64 v15; // x10
  unsigned __int64 v16; // x9
  int64x2_t v17; // q0
  int64x2_t *v18; // x12
  unsigned __int64 v19; // x13
  __int64 v20; // x8
  unsigned __int64 *v21; // x9

  *(_BYTE *)(a3 + 14) = *(_BYTE *)(a3 + 14) & 0xFE | (a2[2] == 131088);
  v3 = (unsigned __int64 *)(*a2 + 64);
  if ( !*a2 )
    v3 = a2 + 1;
  v4 = a2[2];
  *(_QWORD *)(a3 + 56) = *a2;
  *(_QWORD *)(a3 + 64) = 0LL;
  *v3 = a3;
  *a2 = a3;
  if ( v4 <= 0x400 )
  {
    v5 = (v4 + 7) >> 3;
    if ( *(_QWORD *)(result + 8 * v5 + 8) != a3 )
    {
      if ( v4 >= 9 )
      {
        if ( v4 > 0x40 )
        {
          v8 = 63 - __clz(v5 - 1);
          v7 = (((v5 - 1) >> (v8 - 2)) & 3 | (4 * v8)) - 3;
        }
        else
        {
          LOBYTE(v7) = (v5 + 1) & 0xFE;
        }
        v9 = (unsigned __int64)(a2 - 3);
        do
        {
          v10 = *(_QWORD *)(v9 + 16) + 7LL;
          v11 = v10 >> 3;
          if ( v10 >= 0x10 )
          {
            if ( v10 > 0x47 )
            {
              if ( v10 <= 0x20007 )
              {
                v13 = 63 - __clz(v11 - 1);
                v12 = (((v11 - 1) >> (v13 - 2)) & 3 | (4 * v13)) - 3;
              }
              else
              {
                LOBYTE(v12) = 73;
              }
            }
            else
            {
              LOBYTE(v12) = (v11 + 1) & 0xFE;
            }
          }
          else
          {
            LOBYTE(v12) = 1;
          }
          if ( (unsigned __int8)v7 != (unsigned __int8)v12 )
            break;
          v14 = v9 > result + 1040;
          v9 -= 24LL;
        }
        while ( v14 );
        if ( v11 + 1 <= v5 )
          v6 = v11 + 1;
        else
          v6 = (v4 + 7) >> 3;
      }
      else
      {
        v6 = 0LL;
      }
      v15 = v5 - v6 + 1;
      if ( v15 < 4 )
      {
        v16 = v6;
LABEL_28:
        v20 = v5 - v16 + 1;
        v21 = (unsigned __int64 *)(result + 8 * v16 + 8);
        do
        {
          --v20;
          *v21++ = a3;
        }
        while ( v20 );
        goto LABEL_30;
      }
      v17 = vdupq_n_s64(a3);
      v16 = v6 + (v15 & 0xFFFFFFFFFFFFFFFCLL);
      v18 = (int64x2_t *)(result + 8 * v6 + 24);
      v19 = v15 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v18[-1] = v17;
        *v18 = v17;
        v19 -= 4LL;
        v18 += 2;
      }
      while ( v19 );
      if ( v15 != (v15 & 0xFFFFFFFFFFFFFFFCLL) )
        goto LABEL_28;
    }
  }
LABEL_30:
  ++*(_QWORD *)(result + 3024);
  return result;
}


================================================================================
Function: sub_6783B08 (0x6783B08)
================================================================================

unsigned __int64 __fastcall sub_6783B08(unsigned __int64 result)
{
  _QWORD *v1; // x20
  unsigned __int64 v2; // x19
  _BOOL4 v3; // w8
  bool v4; // zf
  char v5; // w21
  _QWORD *v6; // x22
  unsigned __int64 v7; // x21

  v1 = *(_QWORD **)(result + 2840);
  if ( v1 )
  {
    v2 = result;
    do
    {
      do
      {
        result = sub_67F0010((unsigned __int64)v1, 0LL, (atomic_ullong *)(v2 + 2840));
        v3 = result == (_QWORD)v1;
        if ( (_QWORD *)result != v1 )
          v1 = (_QWORD *)result;
        v4 = v3 || v1 == 0LL;
      }
      while ( !v4 );
      if ( !v1 )
        break;
      v5 = 1;
      do
      {
        while ( 1 )
        {
          v6 = (_QWORD *)*v1;
          result = sub_677D008(v1);
          if ( (result & 1) != 0 )
            break;
          v7 = *(_QWORD *)(v2 + 2840);
          do
          {
            *v1 = v7;
            result = sub_67EFFD0(v7, (unsigned __int64)v1, (atomic_ullong *)(v2 + 2840));
            v4 = result == v7;
            v7 = result;
          }
          while ( !v4 );
          v5 = 0;
          v1 = v6;
          if ( !v6 )
            goto LABEL_21;
        }
        v1 = v6;
      }
      while ( v6 );
      if ( (v5 & 1) != 0 )
        return result;
LABEL_21:
      __wfe();
      v1 = *(_QWORD **)(v2 + 2840);
    }
    while ( v1 );
  }
  return result;
}


================================================================================
Function: sub_6783C70 (0x6783C70)
================================================================================

__int64 __fastcall sub_6783C70(__int64 result)
{
  __int64 v1; // x9
  __int64 v2; // x10
  int v3; // w10
  unsigned __int64 v4; // x11
  unsigned __int64 v5; // x10
  unsigned __int8 v6; // w11

  if ( (*(_BYTE *)(result + 14) & 1) != 0 )
  {
    v1 = *(_QWORD *)(result + 48);
    v2 = *(unsigned int *)(result + 28);
    if ( (unsigned int)v2 >= 9 )
    {
      v4 = (unsigned __int64)(v2 + 7) >> 3;
      if ( (unsigned int)v2 > 0x40 )
      {
        if ( (unsigned int)v2 <= 0x20000 )
        {
          v5 = v4 - 1;
          v6 = 63 - __clz(v4 - 1);
          v3 = ((v5 >> (v6 - 2)) & 3 | (4 * v6)) + 253;
        }
        else
        {
          LOBYTE(v3) = 73;
        }
      }
      else
      {
        LOBYTE(v3) = (v4 + 1) & 0xFE;
      }
    }
    else
    {
      LOBYTE(v3) = 1;
    }
    *(_BYTE *)(result + 14) |= 1u;
    return sub_6783D0C(v1 + 24LL * (unsigned __int8)v3 + 1040, v1 + 2816);
  }
  return result;
}


================================================================================
Function: sub_6783D0C (0x6783D0C)
================================================================================

unsigned __int64 *__fastcall sub_6783D0C(unsigned __int64 *result, _QWORD *a2, unsigned __int64 a3)
{
  __int64 v3; // x9
  __int64 v4; // x8
  _QWORD *v5; // x10
  unsigned __int64 v6; // x12
  unsigned __int64 v7; // x11
  unsigned __int64 v8; // x15
  int v9; // w14
  unsigned __int8 v10; // w13
  unsigned __int64 v11; // x13
  unsigned __int64 v12; // x17
  unsigned __int64 v13; // x16
  int v14; // w17
  unsigned __int8 v15; // w1
  bool v16; // cc
  unsigned __int64 v17; // x13
  unsigned __int64 v18; // x12
  int64x2_t v19; // q0
  int64x2_t *v20; // x15
  unsigned __int64 v21; // x16
  __int64 v22; // x11
  _QWORD *v23; // x12
  unsigned __int64 v24; // x11
  unsigned __int64 v25; // x10
  unsigned __int64 v26; // x11
  unsigned __int64 v27; // x15
  int v28; // w14
  unsigned __int8 v29; // w13
  unsigned __int64 v30; // x13
  unsigned __int64 v31; // x17
  unsigned __int64 v32; // x16
  int v33; // w17
  unsigned __int64 v34; // x13
  unsigned __int64 v35; // x12
  int64x2_t v36; // q0
  int64x2_t *v37; // x15
  unsigned __int64 v38; // x16
  unsigned __int64 v39; // x11
  __int64 v40; // x12
  unsigned __int64 v41; // x9
  unsigned __int64 *v42; // x11

  v3 = *(_QWORD *)(a3 + 48);
  v4 = *(_QWORD *)(a3 + 64);
  if ( v4 )
    *(_QWORD *)(v4 + 56) = *(_QWORD *)(a3 + 56);
  v5 = *(_QWORD **)(a3 + 56);
  if ( v5 )
    v5[8] = v4;
  if ( a2[1] == a3 )
    a2[1] = *(_QWORD *)(a3 + 64);
  if ( *a2 == a3 )
  {
    v6 = a2[2];
    *a2 = v5;
    if ( v6 <= 0x400 )
    {
      v7 = (v6 + 7) >> 3;
      if ( !v5 )
        v5 = &unk_173DB80;
      if ( *(_QWORD **)(v3 + 8 * v7 + 8) != v5 )
      {
        if ( v6 >= 9 )
        {
          if ( v6 > 0x40 )
          {
            v10 = 63 - __clz(v7 - 1);
            v9 = (((v7 - 1) >> (v10 - 2)) & 3 | (4 * v10)) - 3;
          }
          else
          {
            LOBYTE(v9) = (v7 + 1) & 0xFE;
          }
          v11 = (unsigned __int64)(a2 - 3);
          do
          {
            v12 = *(_QWORD *)(v11 + 16) + 7LL;
            v13 = v12 >> 3;
            if ( v12 >= 0x10 )
            {
              if ( v12 > 0x47 )
              {
                if ( v12 <= 0x20007 )
                {
                  v15 = 63 - __clz(v13 - 1);
                  v14 = (((v13 - 1) >> (v15 - 2)) & 3 | (4 * v15)) - 3;
                }
                else
                {
                  LOBYTE(v14) = 73;
                }
              }
              else
              {
                LOBYTE(v14) = (v13 + 1) & 0xFE;
              }
            }
            else
            {
              LOBYTE(v14) = 1;
            }
            if ( (unsigned __int8)v9 != (unsigned __int8)v14 )
              break;
            v16 = v11 > v3 + 1040;
            v11 -= 24LL;
          }
          while ( v16 );
          if ( v13 + 1 <= v7 )
            v8 = v13 + 1;
          else
            v8 = (v6 + 7) >> 3;
        }
        else
        {
          v8 = 0LL;
        }
        v17 = v7 - v8 + 1;
        if ( v17 < 4 )
        {
          v18 = v8;
LABEL_35:
          v22 = v7 - v18 + 1;
          v23 = (_QWORD *)(v3 + 8 * v18 + 8);
          do
          {
            --v22;
            *v23++ = v5;
          }
          while ( v22 );
          goto LABEL_37;
        }
        v19 = vdupq_n_s64((unsigned __int64)v5);
        v18 = v8 + (v17 & 0xFFFFFFFFFFFFFFFCLL);
        v20 = (int64x2_t *)(v3 + 8 * v8 + 24);
        v21 = v17 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v20[-1] = v19;
          *v20 = v19;
          v21 -= 4LL;
          v20 += 2;
        }
        while ( v21 );
        if ( v17 != (v17 & 0xFFFFFFFFFFFFFFFCLL) )
          goto LABEL_35;
      }
    }
  }
LABEL_37:
  v24 = result[1];
  *(_QWORD *)(a3 + 56) = 0LL;
  *(_QWORD *)(a3 + 64) = v24;
  if ( v24 )
  {
    v25 = result[2];
    *(_QWORD *)(v24 + 56) = a3;
    result[1] = a3;
    goto LABEL_66;
  }
  v25 = result[2];
  *result = a3;
  result[1] = a3;
  if ( v25 <= 0x400 )
  {
    v26 = (v25 + 7) >> 3;
    if ( *(_QWORD *)(v3 + 8 * v26 + 8) != a3 )
    {
      if ( v25 >= 9 )
      {
        if ( v25 > 0x40 )
        {
          v29 = 63 - __clz(v26 - 1);
          v28 = (((v26 - 1) >> (v29 - 2)) & 3 | (4 * v29)) - 3;
        }
        else
        {
          LOBYTE(v28) = (v26 + 1) & 0xFE;
        }
        v30 = (unsigned __int64)(result - 3);
        do
        {
          v31 = *(_QWORD *)(v30 + 16) + 7LL;
          v32 = v31 >> 3;
          if ( v31 >= 0x10 )
          {
            if ( v31 > 0x47 )
            {
              if ( v31 <= 0x20007 )
              {
                result = (unsigned __int64 *)(unsigned __int8)(63 - __clz(v32 - 1));
                v33 = (((v32 - 1) >> ((unsigned __int8)result - 2)) & 3 | (4 * (unsigned __int8)result)) - 3;
              }
              else
              {
                LOBYTE(v33) = 73;
              }
            }
            else
            {
              LOBYTE(v33) = (v32 + 1) & 0xFE;
            }
          }
          else
          {
            LOBYTE(v33) = 1;
          }
          if ( (unsigned __int8)v28 != (unsigned __int8)v33 )
            break;
          v16 = v30 > v3 + 1040;
          v30 -= 24LL;
        }
        while ( v16 );
        if ( v32 + 1 <= v26 )
          v27 = v32 + 1;
        else
          v27 = (v25 + 7) >> 3;
      }
      else
      {
        v27 = 0LL;
      }
      v34 = v26 - v27 + 1;
      if ( v34 < 4 )
      {
        v35 = v27;
LABEL_64:
        v39 = v26 - v35;
        v40 = v3 + 8 * v35;
        v41 = v39 + 1;
        v42 = (unsigned __int64 *)(v40 + 8);
        do
        {
          --v41;
          *v42++ = a3;
        }
        while ( v41 );
        goto LABEL_66;
      }
      v36 = vdupq_n_s64(a3);
      v35 = v27 + (v34 & 0xFFFFFFFFFFFFFFFCLL);
      v37 = (int64x2_t *)(v3 + 8 * v27 + 24);
      v38 = v34 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v37[-1] = v36;
        *v37 = v36;
        v38 -= 4LL;
        v37 += 2;
      }
      while ( v38 );
      if ( v34 != (v34 & 0xFFFFFFFFFFFFFFFCLL) )
        goto LABEL_64;
    }
  }
LABEL_66:
  *(_BYTE *)(a3 + 14) = *(_BYTE *)(a3 + 14) & 0xFE | (v25 == 131088);
  return result;
}


================================================================================
Function: sub_6784080 (0x6784080)
================================================================================

__int64 __fastcall sub_6784080(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 *v3; // x21
  __int64 v4; // x20

  v3 = (unsigned __int64 *)(a1 + 48);
  v4 = **(_QWORD **)(a1 + 48) + 32LL;
  sub_67840CC(a2, a1);
  atomic_store(0LL, v3);
  return sub_6785ED0(a1, v4);
}


================================================================================
Function: sub_67840CC (0x67840CC)
================================================================================

unsigned __int64 __fastcall sub_67840CC(unsigned __int64 result, __int64 a2)
{
  __int64 v2; // x8
  __int64 v3; // x11
  _QWORD *v4; // x10
  unsigned __int64 v5; // x12
  unsigned __int64 v6; // x11
  unsigned __int64 v7; // x15
  int v8; // w14
  unsigned __int8 v9; // w13
  unsigned __int64 v10; // x13
  unsigned __int64 v11; // x0
  unsigned __int64 v12; // x17
  unsigned __int8 v13; // w2
  bool v14; // cc
  unsigned __int64 v15; // x13
  unsigned __int64 v16; // x12
  int64x2_t v17; // q0
  int64x2_t *v18; // x15
  unsigned __int64 v19; // x16
  __int64 v20; // x11
  _QWORD *v21; // x12
  char v22; // w8

  v2 = *(_QWORD *)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 64);
  if ( v3 )
    *(_QWORD *)(v3 + 56) = *(_QWORD *)(a2 + 56);
  v4 = *(_QWORD **)(a2 + 56);
  if ( v4 )
    v4[8] = v3;
  if ( *(_QWORD *)(result + 8) == a2 )
    *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 64);
  if ( *(_QWORD *)result == a2 )
  {
    v5 = *(_QWORD *)(result + 16);
    *(_QWORD *)result = v4;
    if ( v5 <= 0x400 )
    {
      v6 = (v5 + 7) >> 3;
      if ( !v4 )
        v4 = &unk_173DB80;
      if ( *(_QWORD **)(v2 + 8 * v6 + 8) != v4 )
      {
        if ( v5 >= 9 )
        {
          if ( v5 > 0x40 )
          {
            v9 = 63 - __clz(v6 - 1);
            v8 = (((v6 - 1) >> (v9 - 2)) & 3 | (4 * v9)) - 3;
          }
          else
          {
            LOBYTE(v8) = (v6 + 1) & 0xFE;
          }
          v10 = result - 24;
          do
          {
            v11 = *(_QWORD *)(v10 + 16) + 7LL;
            v12 = v11 >> 3;
            if ( v11 >= 0x10 )
            {
              if ( v11 > 0x47 )
              {
                if ( v11 <= 0x20007 )
                {
                  v13 = 63 - __clz(v12 - 1);
                  result = (((v12 - 1) >> (v13 - 2)) & 3 | (4 * (unsigned int)v13)) - 3;
                }
                else
                {
                  result = 73LL;
                }
              }
              else
              {
                result = ((_DWORD)v12 + 1) & 0xFFFFFFFE;
              }
            }
            else
            {
              result = 1LL;
            }
            if ( (unsigned __int8)v8 != (unsigned __int8)result )
              break;
            result = v10 - 24;
            v14 = v10 > v2 + 1040;
            v10 -= 24LL;
          }
          while ( v14 );
          if ( v12 + 1 <= v6 )
            v7 = v12 + 1;
          else
            v7 = (v5 + 7) >> 3;
        }
        else
        {
          v7 = 0LL;
        }
        v15 = v6 - v7 + 1;
        if ( v15 < 4 )
        {
          v16 = v7;
LABEL_35:
          v20 = v6 - v16 + 1;
          v21 = (_QWORD *)(v2 + 8 * v16 + 8);
          do
          {
            --v20;
            *v21++ = v4;
          }
          while ( v20 );
          goto LABEL_37;
        }
        v17 = vdupq_n_s64((unsigned __int64)v4);
        v16 = v7 + (v15 & 0xFFFFFFFFFFFFFFFCLL);
        v18 = (int64x2_t *)(v2 + 8 * v7 + 24);
        v19 = v15 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v18[-1] = v17;
          *v18 = v17;
          v19 -= 4LL;
          v18 += 2;
        }
        while ( v19 );
        if ( v15 != (v15 & 0xFFFFFFFFFFFFFFFCLL) )
          goto LABEL_35;
      }
    }
  }
LABEL_37:
  --*(_QWORD *)(v2 + 3024);
  v22 = *(_BYTE *)(a2 + 14);
  *(_QWORD *)(a2 + 56) = 0LL;
  *(_QWORD *)(a2 + 64) = 0LL;
  *(_BYTE *)(a2 + 14) = v22 & 0xFE;
  return result;
}


================================================================================
Function: sub_67842B8 (0x67842B8)
================================================================================

__int64 __fastcall sub_67842B8(__int64 a1, unsigned __int64 a2, char a3)
{
  unsigned __int64 *v4; // x22
  __int64 v6; // x21

  v4 = (unsigned __int64 *)(a1 + 48);
  *(_BYTE *)(a1 + 14) &= ~2u;
  v6 = **(_QWORD **)(a1 + 48) + 32LL;
  sub_67840CC(a2, a1);
  atomic_store(0LL, v4);
  return sub_6785900(a1, a3, v6);
}


================================================================================
Function: sub_6784318 (0x6784318)
================================================================================

_QWORD *__fastcall sub_6784318(__int64 a1)
{
  char v1; // w10
  __int64 v3; // x9
  char v4; // w8
  unsigned __int64 v5; // x10
  unsigned __int8 v6; // w11
  __int64 v7; // x11
  _QWORD *result; // x0
  __int64 v9; // x20
  char v10; // w9
  __int64 v11; // x8
  unsigned __int64 v12; // x9

  v1 = *(_BYTE *)(a1 + 14);
  v3 = *(unsigned int *)(a1 + 28);
  v4 = v1 & 0xFD;
  *(_BYTE *)(a1 + 14) = v1 & 0xFD;
  if ( (v1 & 1) != 0 )
  {
    v5 = 74LL;
  }
  else
  {
    if ( (unsigned int)v3 >= 9 )
    {
      v5 = (unsigned __int64)(v3 + 7) >> 3;
      if ( (unsigned int)v3 > 0x40 )
      {
        if ( (unsigned int)v3 <= 0x20000 )
        {
          v6 = 63 - __clz(--v5);
          LODWORD(v5) = ((v5 >> (v6 - 2)) & 3 | (4 * v6)) + 253;
        }
        else
        {
          LOBYTE(v5) = 73;
        }
      }
      else
      {
        LOBYTE(v5) = (v5 + 1) & 0xFE;
      }
    }
    else
    {
      LOBYTE(v5) = 1;
    }
    v5 = (unsigned __int8)v5;
  }
  v7 = *(_QWORD *)(a1 + 48);
  result = (_QWORD *)(v7 + 24 * v5 + 1040);
  if ( (unsigned int)v3 <= 0x20000
    && *(_QWORD *)(v7 + 24 * v5 + 1056) <= 0x20000uLL
    && *(_QWORD *)(v7 + 24 * v5 + 1048) == a1
    && *result == a1 )
  {
    if ( (unsigned int)v3 > 0x4000 )
      v10 = 10;
    else
      v10 = 34;
    *(_BYTE *)(a1 + 15) = v10 & 0xFE | *(_BYTE *)(a1 + 15) & 1;
    v11 = *(_QWORD *)(a1 + 48);
    v12 = 0xAAAAAAAAAAAAAAABLL * ((__int64)(v7 + 24 * v5 - v11) >> 3);
    if ( v12 < *(_QWORD *)(v11 + 3032) )
      *(_QWORD *)(v11 + 3032) = v12;
    if ( v12 > *(_QWORD *)(v11 + 3040) )
      *(_QWORD *)(v11 + 3040) = v12;
  }
  else
  {
    *(_BYTE *)(a1 + 14) = v4;
    v9 = **(_QWORD **)(a1 + 48) + 32LL;
    sub_67840CC(result, a1);
    atomic_store(0LL, (unsigned __int64 *)(a1 + 48));
    return (_QWORD *)sub_6785900(a1, 0LL, v9);
  }
  return result;
}


================================================================================
Function: sub_67844A0 (0x67844A0)
================================================================================

__int64 __fastcall sub_67844A0(__int64 result, char a2)
{
  unsigned __int64 v2; // x25
  __int64 v3; // x19
  unsigned __int64 v4; // x24
  unsigned __int64 v5; // x26
  unsigned __int64 v7; // x21
  __int64 v8; // x8
  unsigned int v9; // w10
  __int64 v10; // x22
  unsigned __int64 *v11; // x27
  __int64 v12; // x23

  v2 = *(_QWORD *)(result + 3032);
  v3 = result;
  if ( v2 <= *(_QWORD *)(result + 3040) )
  {
    v4 = 0LL;
    v5 = 74LL;
    v7 = result + 24 * v2 + 1040;
    do
    {
      v8 = *(_QWORD *)v7;
      if ( *(_QWORD *)v7 )
      {
        v9 = *(unsigned __int8 *)(v8 + 15);
        if ( v9 >= 2 )
        {
          if ( *(_DWORD *)(v8 + 24) )
          {
            *(_BYTE *)(v8 + 15) = v9 & 1;
          }
          else
          {
            *(_BYTE *)(v8 + 15) = v9 - 2;
            if ( (a2 & 1) != 0 || (unsigned __int8)(v9 - 2) <= 1u )
            {
              v10 = *(_QWORD *)v7;
              v11 = (unsigned __int64 *)(*(_QWORD *)v7 + 48LL);
              *(_BYTE *)(v10 + 14) = *(_BYTE *)(*(_QWORD *)v7 + 14LL) & 0xFD;
              v12 = **(_QWORD **)(v10 + 48) + 32LL;
              sub_67840CC(v7, v10);
              atomic_store(0LL, v11);
              result = sub_6785900(v10, a2 & 1, v12);
            }
            else
            {
              if ( v2 < v5 )
                v5 = v2;
              if ( v2 > v4 )
                v4 = v2;
            }
          }
        }
      }
      ++v2;
      v7 += 24LL;
    }
    while ( v2 <= *(_QWORD *)(v3 + 3040) );
  }
  else
  {
    v4 = 0LL;
    v5 = 74LL;
  }
  *(_QWORD *)(v3 + 3032) = v5;
  *(_QWORD *)(v3 + 3040) = v4;
  return result;
}


================================================================================
Function: sub_67845BC (0x67845BC)
================================================================================

_QWORD *__fastcall sub_67845BC(_QWORD *result, char a2)
{
  _QWORD *v2; // x9
  _QWORD *v3; // x19

  v2 = (_QWORD *)*result;
  ++*(_QWORD *)*result;
  if ( off_72922C8 )
  {
    if ( !*((_BYTE *)v2 + 8) )
    {
      v3 = result;
      *((_BYTE *)v2 + 8) = 1;
      result = (_QWORD *)off_72922C8(a2 & 1);
      *(_BYTE *)(*v3 + 8LL) = 0;
    }
  }
  return result;
}


================================================================================
Function: sub_6784624 (0x6784624)
================================================================================

__int64 __fastcall sub_6784624(void *a1, __int64 a2, char a3, __int64 a4)
{
  __int64 v7; // x21
  __int64 v8; // x8
  _QWORD *v9; // x23
  __int64 v10; // x0
  _BOOL4 v11; // w8
  bool v12; // zf
  __int64 v13; // x23
  _QWORD *v15; // x25
  __int64 v16; // x24
  __int64 v17; // x0
  void *v18; // x19
  size_t v19; // x0

  v7 = (__int64)a1;
  if ( a1 == &unk_6BDF6C0 )
  {
    v7 = sub_677DC88();
    if ( (_UNKNOWN *)v7 == &unk_6BDF6C0 )
      return 0LL;
  }
  v8 = *(_QWORD *)v7;
  ++**(_QWORD **)v7;
  if ( off_72922C8 && !*(_BYTE *)(v8 + 8) )
  {
    *(_BYTE *)(v8 + 8) = 1;
    off_72922C8(0LL);
    *(_BYTE *)(*(_QWORD *)v7 + 8LL) = 0;
  }
  v9 = *(_QWORD **)(v7 + 2840);
  if ( v9 )
  {
    do
    {
      v10 = sub_67F0010(v9, 0LL, v7 + 2840);
      v11 = v10 == (_QWORD)v9;
      if ( (_QWORD *)v10 != v9 )
        v9 = (_QWORD *)v10;
      v12 = v11 || v9 == 0LL;
    }
    while ( !v12 );
    if ( v9 )
    {
      do
      {
        v15 = (_QWORD *)*v9;
        if ( (sub_677D008(v9) & 1) == 0 )
        {
          v16 = *(_QWORD *)(v7 + 2840);
          do
          {
            *v9 = v16;
            v17 = sub_67EFFD0(v16, v9, v7 + 2840);
            v12 = v17 == v16;
            v16 = v17;
          }
          while ( !v12 );
        }
        v9 = v15;
      }
      while ( v15 );
    }
  }
  v13 = sub_6784808(v7, a2, a4);
  if ( v13 || (sub_677DC2C(v7, 1LL), (v13 = sub_6784808(v7, a2, a4)) != 0) )
  {
    if ( (a3 & 1) == 0 || *(_DWORD *)(v13 + 28) )
      return sub_677CD28(v7, v13, a2, a3 & 1);
    v18 = (void *)sub_677CD28(v7, v13, a2, 0LL);
    v19 = sub_6784C94(v13);
    memset(v18, 0, v19);
  }
  else
  {
    sub_6781A58(12LL, "unable to allocate memory (%zu bytes)\n", a2);
    return 0LL;
  }
  return (__int64)v18;
}


================================================================================
Function: sub_6784808 (0x6784808)
================================================================================

__int64 __fastcall sub_6784808(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  int v4; // w8
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  unsigned __int8 v7; // w9
  __int64 v8; // x22
  __int64 v9; // x23
  __int64 v10; // x19
  __int64 v11; // x0
  __int64 v12; // x21
  _QWORD **v13; // x8
  _QWORD *v14; // x12
  unsigned int v15; // w10
  unsigned int v16; // w9
  _QWORD *v17; // x11
  unsigned int v18; // w13
  bool v19; // cf
  int v20; // w9
  __int64 v21; // x8
  __int64 v22; // x9
  __int64 v23; // x9
  __int64 *v24; // x21
  char i; // w26
  __int64 v26; // x27
  char v27; // w8
  __int64 v28; // x0
  __int64 v29; // x23
  _QWORD **v30; // x8
  _QWORD *v31; // x12
  unsigned int v32; // w10
  unsigned int v33; // w9
  _QWORD *v34; // x11
  unsigned int v35; // w13
  int v36; // w9
  __int64 v37; // x0
  __int64 v38; // x23
  _QWORD **v39; // x8
  _QWORD *v40; // x12
  unsigned int v41; // w10
  unsigned int v42; // w9
  _QWORD *v43; // x11
  unsigned int v44; // w13
  char v45; // w9
  int v46; // w9
  unsigned __int64 v47; // x1
  unsigned __int64 v48; // x9
  __int16 v49; // w20
  unsigned __int64 v51; // [xsp+0h] [xbp-10h] BYREF

  if ( a2 <= 0x20000 && !a3 )
  {
    if ( a2 >= 9 )
    {
      v5 = (a2 + 7) >> 3;
      if ( a2 > 0x40 )
      {
        v6 = v5 - 1;
        v7 = 63 - __clz(v5 - 1);
        v4 = ((v6 >> (v7 - 2)) & 3 | (4 * v7)) + 253;
      }
      else
      {
        LOBYTE(v4) = (v5 + 1) & 0xFE;
      }
    }
    else
    {
      LOBYTE(v4) = 1;
    }
    v8 = (unsigned __int8)v4;
    v9 = a1 + 24LL * (unsigned __int8)v4;
    v10 = *(_QWORD *)(v9 + 1040);
    if ( v10 )
    {
      if ( *(_QWORD *)(v10 + 40) >= 4uLL )
      {
        v11 = *(_QWORD *)(v10 + 40);
        do
        {
          v12 = v11;
          v11 = sub_67F0010(v11, v11 & 3, v10 + 40);
        }
        while ( v11 != v12 );
        v13 = (_QWORD **)(v12 & 0xFFFFFFFFFFFFFFFCLL);
        if ( (v12 & 0xFFFFFFFFFFFFFFFCLL) != 0 )
        {
          v14 = *v13;
          v15 = 1;
          v16 = *(unsigned __int16 *)(v10 + 10);
          v17 = (_QWORD *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
          if ( *v13 && *(_WORD *)(v10 + 10) )
          {
            v18 = 1;
            do
            {
              v17 = v14;
              v14 = (_QWORD *)*v14;
              v15 = v18 + 1;
              if ( !v14 )
                break;
              v19 = v18++ >= v16;
            }
            while ( !v19 );
          }
          if ( v15 <= v16 )
          {
            *v17 = *(_QWORD *)(v10 + 32);
            v20 = *(_DWORD *)(v10 + 24);
            *(_QWORD *)(v10 + 32) = v13;
            *(_DWORD *)(v10 + 24) = v20 - v15;
          }
          else
          {
            sub_6781A58(14LL, "corrupted thread-free list\n");
          }
        }
      }
      v21 = *(_QWORD *)(v10 + 32);
      v22 = *(_QWORD *)(v10 + 16);
      if ( v21 )
      {
LABEL_23:
        if ( !v22 )
        {
          v23 = *(unsigned __int8 *)(v10 + 15);
          *(_QWORD *)(v10 + 16) = v21;
          *(_QWORD *)(v10 + 32) = 0LL;
          *(_BYTE *)(v10 + 15) = v23 & 0xFE;
        }
        goto LABEL_76;
      }
      if ( v22 )
      {
LABEL_76:
        *(_BYTE *)(v10 + 15) &= 1u;
        return v10;
      }
    }
    v24 = (__int64 *)(v9 + 1040);
    for ( i = 1; ; i = 0 )
    {
      v26 = *v24;
      if ( *v24 )
        break;
LABEL_28:
      sub_67844A0(a1, 0LL);
      v10 = sub_6784E24(a1, v24, *(_QWORD *)(a1 + 24 * v8 + 1056), 0LL);
      v27 = i & (v10 == 0);
      if ( (v27 & 1) == 0 )
        return v10;
    }
    while ( 1 )
    {
      v10 = v26;
      v26 = *(_QWORD *)(v26 + 56);
      if ( *(_QWORD *)(v10 + 40) >= 4uLL )
      {
        v28 = *(_QWORD *)(v10 + 40);
        do
        {
          v29 = v28;
          v28 = sub_67F0010(v28, v28 & 3, v10 + 40);
        }
        while ( v28 != v29 );
        v30 = (_QWORD **)(v29 & 0xFFFFFFFFFFFFFFFCLL);
        if ( (v29 & 0xFFFFFFFFFFFFFFFCLL) != 0 )
        {
          v31 = *v30;
          v32 = 1;
          v33 = *(unsigned __int16 *)(v10 + 10);
          v34 = (_QWORD *)(v29 & 0xFFFFFFFFFFFFFFFCLL);
          if ( *v30 && *(_WORD *)(v10 + 10) )
          {
            v35 = 1;
            do
            {
              v34 = v31;
              v31 = (_QWORD *)*v31;
              v32 = v35 + 1;
              if ( !v31 )
                break;
              v19 = v35++ >= v33;
            }
            while ( !v19 );
          }
          if ( v32 <= v33 )
          {
            *v34 = *(_QWORD *)(v10 + 32);
            v36 = *(_DWORD *)(v10 + 24);
            *(_QWORD *)(v10 + 32) = v30;
            *(_DWORD *)(v10 + 24) = v36 - v32;
          }
          else
          {
            sub_6781A58(14LL, "corrupted thread-free list\n");
          }
        }
      }
      v21 = *(_QWORD *)(v10 + 32);
      v22 = *(_QWORD *)(v10 + 16);
      if ( v21 )
        goto LABEL_23;
      if ( v22 )
        goto LABEL_76;
      if ( *(unsigned __int16 *)(v10 + 10) < (unsigned int)*(unsigned __int16 *)(v10 + 12) )
      {
        sub_6785898((v10 - 1) & 0xFFFFFFFFFE000000LL, (unsigned int *)v10, &v51);
        if ( *(int *)(v10 + 28) < 0 )
          v47 = v51;
        else
          v47 = *(unsigned int *)(v10 + 28);
        if ( v47 <= 0xFFF )
        {
          v48 = 0x1000u / (unsigned __int16)v47;
          if ( (unsigned int)v48 <= 4 )
            v48 = 4LL;
        }
        else
        {
          v48 = 4LL;
        }
        if ( *(unsigned __int16 *)(v10 + 12) - (unsigned __int64)*(unsigned __int16 *)(v10 + 10) <= v48 )
          v49 = *(_WORD *)(v10 + 12) - *(_WORD *)(v10 + 10);
        else
          v49 = v48;
        sub_6784FD4(v10);
        *(_WORD *)(v10 + 10) += v49;
        goto LABEL_76;
      }
      if ( (*(_BYTE *)(v10 + 14) & 1) != 0 )
        goto LABEL_30;
      sub_6783D0C(*(_QWORD *)(v10 + 48) + 2816LL, v24);
      if ( *(_QWORD *)(v10 + 40) < 4uLL )
        goto LABEL_60;
      v37 = *(_QWORD *)(v10 + 40);
      do
      {
        v38 = v37;
        v37 = sub_67F0010(v37, v37 & 3, v10 + 40);
      }
      while ( v37 != v38 );
      v39 = (_QWORD **)(v38 & 0xFFFFFFFFFFFFFFFCLL);
      if ( (v38 & 0xFFFFFFFFFFFFFFFCLL) == 0 )
        goto LABEL_60;
      v40 = *v39;
      v41 = 1;
      v42 = *(unsigned __int16 *)(v10 + 10);
      v43 = (_QWORD *)(v38 & 0xFFFFFFFFFFFFFFFCLL);
      if ( *v39 && *(_WORD *)(v10 + 10) )
      {
        v44 = 1;
        do
        {
          v43 = v40;
          v40 = (_QWORD *)*v40;
          v41 = v44 + 1;
          if ( !v40 )
            break;
          v19 = v44++ >= v42;
        }
        while ( !v19 );
      }
      if ( v41 > v42 )
        break;
      *v43 = *(_QWORD *)(v10 + 32);
      v46 = *(_DWORD *)(v10 + 24);
      *(_QWORD *)(v10 + 32) = v39;
      *(_DWORD *)(v10 + 24) = v46 - v41;
      if ( v39 )
      {
LABEL_61:
        if ( !*(_QWORD *)(v10 + 16) )
        {
          v45 = *(_BYTE *)(v10 + 15);
          *(_QWORD *)(v10 + 16) = v39;
          *(_QWORD *)(v10 + 32) = 0LL;
          *(_BYTE *)(v10 + 15) = v45 & 0xFE;
        }
      }
LABEL_30:
      if ( !v26 )
        goto LABEL_28;
    }
    sub_6781A58(14LL, "corrupted thread-free list\n");
LABEL_60:
    v39 = *(_QWORD ***)(v10 + 32);
    if ( v39 )
      goto LABEL_61;
    goto LABEL_30;
  }
  if ( (a2 & 0x8000000000000000LL) != 0 )
  {
    sub_6781A58(75LL, "allocation request is too large (%zu bytes)\n", a2);
    return 0LL;
  }
  return sub_6784CFC(a1, a2);
}


================================================================================
Function: sub_6784C94 (0x6784C94)
================================================================================

__int64 __fastcall sub_6784C94(unsigned int *a1)
{
  __int64 result; // x0
  __int64 v3; // [xsp+0h] [xbp-10h] BYREF

  result = a1[7];
  if ( (result & 0x80000000) != 0 )
  {
    sub_6785898(((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL, a1, &v3);
    return v3;
  }
  return result;
}


================================================================================
Function: sub_6784CFC (0x6784CFC)
================================================================================

unsigned int *__fastcall sub_6784CFC(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // x0
  unsigned __int64 v6; // x9
  unsigned __int64 v8; // x8
  unsigned __int8 v9; // w9
  unsigned int *v10; // x0
  unsigned int *v11; // x19
  __int64 v13; // [xsp+0h] [xbp-10h] BYREF

  v5 = sub_6781F7C(a2);
  v6 = 2147483655LL;
  if ( v5 <= 0x1000000 && a3 == 0 )
    v6 = v5 + 7;
  if ( v6 >= 0x10 )
  {
    v8 = v6 >> 3;
    if ( v6 > 0x47 )
    {
      if ( v6 <= 0x20007 )
      {
        v9 = 63 - __clz(--v8);
        LODWORD(v8) = ((v8 >> (v9 - 2)) & 3 | (4 * v9)) + 253;
      }
      else
      {
        LOBYTE(v8) = 73;
      }
    }
    else
    {
      LOBYTE(v8) = (v8 + 1) & 0xFE;
    }
  }
  else
  {
    LOBYTE(v8) = 1;
  }
  v10 = sub_6784E24(a1, a1 + 24LL * (unsigned __int8)v8 + 1040, v5);
  v11 = v10;
  if ( v10 && (v10[7] & 0x80000000) != 0 )
    sub_6785898(((unsigned __int64)v10 - 1) & 0xFFFFFFFFFE000000LL, v10, &v13);
  return v11;
}


================================================================================
Function: sub_6784E24 (0x6784E24)
================================================================================

unsigned int *__fastcall sub_6784E24(unsigned __int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned int *v6; // x0
  unsigned int *v7; // x21
  unsigned int v8; // w9
  unsigned __int64 v9; // x8
  __int64 v10; // x11
  unsigned __int64 v11; // x1
  unsigned __int64 v12; // x9
  __int16 v13; // w22
  unsigned __int64 v15; // [xsp+8h] [xbp-18h] BYREF
  unsigned __int64 v16; // [xsp+10h] [xbp-10h] BYREF

  v6 = (unsigned int *)sub_6786994();
  v7 = v6;
  if ( v6 )
  {
    if ( !a2 || *(_QWORD *)(a2 + 16) == 131080LL )
    {
      a3 = v6[7];
      if ( (a3 & 0x80000000) != 0 )
      {
        sub_6785898(((unsigned __int64)v6 - 1) & 0xFFFFFFFFFE000000LL, v6, &v16);
        a3 = v16;
      }
    }
    v8 = 0x80000000;
    if ( !(a3 >> 31) )
      v8 = a3;
    atomic_store(a1, (unsigned __int64 *)v7 + 6);
    v7[7] = v8;
    sub_6785898(((unsigned __int64)v7 - 1) & 0xFFFFFFFFFE000000LL, v7, &v15);
    v9 = v15 / a3;
    v10 = *((_QWORD *)v7 + 2);
    *((_BYTE *)v7 + 15) = *((_BYTE *)v7 + 15) & 0xFE | ((v7[2] & 2) != 0);
    *((_WORD *)v7 + 6) = v9;
    if ( !v10 && *((unsigned __int16 *)v7 + 5) < (unsigned int)(unsigned __int16)v9 )
    {
      sub_6785898(((unsigned __int64)v7 - 1) & 0xFFFFFFFFFE000000LL, v7, &v16);
      if ( (v7[7] & 0x80000000) != 0 )
        v11 = v16;
      else
        v11 = v7[7];
      if ( v11 <= 0xFFF )
      {
        v12 = 0x1000u / (unsigned __int16)v11;
        if ( (unsigned int)v12 <= 4 )
          v12 = 4LL;
      }
      else
      {
        v12 = 4LL;
      }
      if ( *((unsigned __int16 *)v7 + 6) - (unsigned __int64)*((unsigned __int16 *)v7 + 5) <= v12 )
        v13 = *((_WORD *)v7 + 6) - *((_WORD *)v7 + 5);
      else
        v13 = v12;
      sub_6784FD4(v7);
      *((_WORD *)v7 + 5) += v13;
    }
    if ( a2 )
      sub_6783944(a1, a2, v7);
  }
  return v7;
}


================================================================================
Function: sub_6784FD4 (0x6784FD4)
================================================================================

__int64 __fastcall sub_6784FD4(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // x0
  __int64 v7; // x11
  __int64 v8; // x12
  __int64 v9; // x8
  _QWORD *v10; // x9
  __int64 v11; // x10
  __int64 v12; // x11
  __int64 v13; // x10

  result = sub_6785898((a1 - 1) & 0xFFFFFFFFFE000000LL, (unsigned int *)a1, 0LL);
  v7 = *(unsigned __int16 *)(a1 + 10);
  v8 = (a3 + v7 - 1) * a2;
  v9 = result + v7 * a2;
  v10 = (_QWORD *)(result + v8);
  if ( v7 * a2 <= v8 )
  {
    v11 = 0LL;
    v12 = result + a2 + a2 * v7;
    do
    {
      *(_QWORD *)(v9 + v11) = v12 + v11;
      v11 += a2;
    }
    while ( v9 + v11 <= (unsigned __int64)v10 );
  }
  v13 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v9;
  *v10 = v13;
  return result;
}


================================================================================
Function: sub_6785068 (0x6785068)
================================================================================

unsigned __int64 __fastcall sub_6785068(__int64 a1)
{
  int v1; // w8
  __int64 v3; // x8
  unsigned int v4; // w20
  bool v5; // vf
  int v6; // w8
  __int64 v7; // x8
  unsigned int v8; // w0
  unsigned __int64 result; // x0

  v1 = *(_DWORD *)(a1 + 128);
  if ( v1 <= 0 )
  {
    sub_678549C(a1);
    v1 = 16;
    *(_DWORD *)(a1 + 128) = 16;
  }
  v3 = a1 + 4 * (16LL - v1);
  v4 = *(_DWORD *)(v3 + 64);
  *(_DWORD *)(v3 + 64) = 0;
  LODWORD(v3) = *(_DWORD *)(a1 + 128);
  v5 = __OFSUB__((_DWORD)v3, 1);
  v6 = v3 - 1;
  *(_DWORD *)(a1 + 128) = v6;
  if ( (v6 < 0) ^ v5 | (v6 == 0) )
  {
    sub_678549C(a1);
    v6 = 16;
    *(_DWORD *)(a1 + 128) = 16;
  }
  v7 = a1 + 4 * (16LL - v6);
  v8 = *(_DWORD *)(v7 + 64);
  *(_DWORD *)(v7 + 64) = 0;
  result = v8 | ((unsigned __int64)v4 << 32);
  --*(_DWORD *)(a1 + 128);
  return result;
}


================================================================================
Function: sub_6785180 (0x6785180)
================================================================================

long double __fastcall sub_6785180(__int64 a1)
{
  unsigned __int64 v2; // x8
  unsigned __int64 v3; // x14
  unsigned __int64 v4; // x16
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x15
  unsigned __int64 v7; // x0
  unsigned __int64 v8; // x13
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x2
  unsigned __int64 v11; // x3
  unsigned __int64 v12; // x17
  unsigned __int64 v13; // x11
  unsigned __int64 v14; // x4
  unsigned __int64 v15; // x5
  unsigned __int64 v16; // x1
  unsigned __int64 v17; // x12
  unsigned __int64 v18; // x6
  __int64 v19; // x0
  unsigned __int64 v20; // x9
  __int64 v21; // x10
  unsigned __int64 v22; // x9
  unsigned __int64 v23; // x13
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x8
  unsigned __int64 v26; // x9
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x10
  unsigned __int64 v29; // x10
  unsigned __int64 v30; // x11
  unsigned __int64 v31; // x11
  unsigned __int64 v32; // x12
  unsigned __int64 v33; // x12
  unsigned __int64 v34; // x14
  unsigned __int64 v35; // x14
  unsigned __int64 v36; // x1
  unsigned __int64 v37; // x14
  unsigned __int64 v38; // x14
  unsigned __int64 v39; // x6
  unsigned __int64 v40; // x17
  unsigned __int64 v41; // x5
  int v42; // w7
  long double result; // q0
  int v44; // w9
  int v45; // w8
  unsigned __int8 v46; // w13
  unsigned __int8 v47; // w14
  int v48; // w8
  int v49; // w9
  int v50; // w10
  int v51; // [xsp+8h] [xbp-28h] BYREF
  int v52; // [xsp+Ch] [xbp-24h]
  int v53; // [xsp+10h] [xbp-20h]
  int v54; // [xsp+14h] [xbp-1Ch]
  int v55; // [xsp+18h] [xbp-18h]
  int v56; // [xsp+1Ch] [xbp-14h]
  int v57; // [xsp+20h] [xbp-10h]
  int v58; // [xsp+24h] [xbp-Ch]

  if ( (sub_678A1CC(&v51, 32LL) & 1) != 0 )
  {
    LOBYTE(v2) = v51;
    *(_BYTE *)(a1 + 132) = 0;
    LOBYTE(v3) = BYTE1(v51);
    LOBYTE(v4) = BYTE2(v51);
    LOBYTE(v5) = v52;
    LOBYTE(v6) = BYTE1(v52);
    LOBYTE(v7) = BYTE2(v52);
    LOBYTE(v8) = HIBYTE(v52);
    LOBYTE(v9) = v53;
    LOBYTE(v10) = BYTE1(v53);
    LOBYTE(v11) = BYTE2(v53);
    LOBYTE(v12) = HIBYTE(v53);
    LOBYTE(v13) = v54;
    LOBYTE(v14) = BYTE1(v54);
    LOBYTE(v15) = BYTE2(v54);
    LOBYTE(v16) = HIBYTE(v54);
    LOBYTE(v17) = v55;
    LOBYTE(v18) = BYTE1(v55);
  }
  else
  {
    v19 = sub_6781928("unable to use secure randomness\n");
    v20 = sub_6789FE4(v19) ^ (unsigned __int64)sub_6785100;
    v21 = (((unsigned __int8)v20 ^ (unsigned __int8)((unsigned int)v20 >> 17)) & 0xF) + 1LL;
    do
    {
      if ( !v20 )
        v20 = 17LL;
      --v21;
      v22 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9LL * (v20 ^ (v20 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v20 ^ (v20 >> 30))) >> 27));
      v20 = v22 ^ (v22 >> 31);
    }
    while ( v21 );
    v23 = 17LL;
    if ( v20 )
      v24 = v20;
    else
      v24 = 17LL;
    v25 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v24 ^ (v24 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v24 ^ (v24 >> 30))) >> 27));
    v2 = v25 ^ (v25 >> 31);
    v4 = v2 >> 16;
    if ( v2 )
      v26 = v2;
    else
      v26 = 17LL;
    v27 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v26 ^ (v26 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v26 ^ (v26 >> 30))) >> 27));
    v5 = v27 ^ (v27 >> 31);
    v6 = v5 >> 8;
    if ( v5 )
      v28 = v5;
    else
      v28 = 17LL;
    v7 = v5 >> 16;
    v51 = v2;
    v52 = v5;
    v29 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v28 ^ (v28 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v28 ^ (v28 >> 30))) >> 27));
    v9 = v29 ^ (v29 >> 31);
    v10 = v9 >> 8;
    if ( v9 )
      v30 = v9;
    else
      v30 = 17LL;
    v11 = v9 >> 16;
    v31 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v30 ^ (v30 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v30 ^ (v30 >> 30))) >> 27));
    v13 = v31 ^ (v31 >> 31);
    v14 = v13 >> 8;
    if ( v13 )
      v32 = v13;
    else
      v32 = 17LL;
    v53 = v9;
    v54 = v13;
    v33 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v32 ^ (v32 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v32 ^ (v32 >> 30))) >> 27));
    v17 = v33 ^ (v33 >> 31);
    if ( v17 )
      v34 = v17;
    else
      v34 = 17LL;
    v35 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v34 ^ (v34 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v34 ^ (v34 >> 30))) >> 27));
    v36 = v35 ^ (v35 >> 31);
    if ( v36 )
      v37 = v35 ^ (v35 >> 31);
    else
      v37 = 17LL;
    v55 = v17;
    v56 = v36;
    v16 = v13 >> 24;
    v38 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9LL * (v37 ^ (v37 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v37 ^ (v37 >> 30))) >> 27));
    v39 = v38 ^ (v38 >> 31);
    if ( v39 )
      v23 = v38 ^ (v38 >> 31);
    *(_BYTE *)(a1 + 132) = 1;
    v3 = v2 >> 8;
    v40 = (0xBF58476D1CE4E5B9LL * (v23 ^ (v23 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v23 ^ (v23 >> 30))) >> 27);
    v8 = v5 >> 24;
    v41 = 0x94D049BB133111EBLL * v40;
    v12 = v9 >> 24;
    v42 = (v41 >> 31) ^ v41;
    v15 = v13 >> 16;
    v57 = v39;
    v58 = v42;
    v18 = v17 >> 8;
  }
  *(_QWORD *)(a1 + 128) = 0LL;
  *(_OWORD *)&result = 0uLL;
  v44 = (unsigned __int16)((unsigned __int8)v5 | ((unsigned __int8)v6 << 8)) | ((unsigned __int8)v7 << 16) & 0xFFFFFF | ((unsigned __int8)v8 << 24);
  v45 = (unsigned __int16)((unsigned __int8)v2 | ((unsigned __int8)v3 << 8)) | ((unsigned __int8)v4 << 16) & 0xFFFFFF | (HIBYTE(v51) << 24);
  v46 = BYTE2(v55);
  v47 = HIBYTE(v55);
  *(_OWORD *)a1 = xmmword_AFBA10;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 16) = v45;
  *(_DWORD *)(a1 + 20) = v44;
  v48 = v56;
  v49 = v57;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 24) = (unsigned __int8)v9 | (unsigned __int16)((unsigned __int8)v10 << 8) | ((unsigned __int8)v11 << 16) & 0xFFFFFF | ((unsigned __int8)v12 << 24);
  *(_DWORD *)(a1 + 28) = (unsigned __int8)v13 | (unsigned __int16)((unsigned __int8)v14 << 8) | ((unsigned __int8)v15 << 16) & 0xFFFFFF | ((unsigned __int8)v16 << 24);
  v50 = v58;
  *(_DWORD *)(a1 + 32) = (unsigned __int8)v17 | (unsigned __int16)((unsigned __int8)v18 << 8) | (v46 << 16) & 0xFFFFFF | (v47 << 24);
  *(_DWORD *)(a1 + 36) = v48;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 40) = v49;
  *(_DWORD *)(a1 + 44) = v50;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 56) = a1;
  return result;
}


================================================================================
Function: sub_678549C (0x678549C)
================================================================================

int *__fastcall sub_678549C(int *result)
{
  int v1; // w6
  int v2; // w7
  int v3; // w1
  int v4; // w3
  int v5; // w16
  int v6; // w17
  int v7; // w13
  int v8; // w14
  int v9; // w12
  int v10; // w15
  int v11; // w9
  int v12; // w10
  int v13; // w4
  int v14; // w5
  int v15; // w2
  int v16; // w11
  unsigned __int64 v17; // x8
  int v18; // w7
  int v19; // w6
  int v20; // w3
  int v21; // w1
  int v22; // w5
  unsigned __int64 v23; // t2
  int v24; // w4
  int v25; // w2
  int v26; // w11
  int v27; // w12
  int v28; // w15
  int v29; // w10
  int v30; // w9
  int v31; // w17
  int v32; // w16
  int v33; // w14
  int v34; // w13
  int v35; // w7
  int v36; // w6
  int v37; // w3
  int v38; // w1
  int v39; // w5
  int v40; // w4
  int v41; // w2
  int v42; // w11
  int v43; // w12
  int v44; // w15
  int v45; // w10
  int v46; // w9
  int v47; // w16
  int v48; // w14
  int v49; // w13
  int v50; // w17
  int v51; // w7
  int v52; // w6
  int v53; // w3
  int v54; // w1
  int v55; // w11
  int v56; // w5
  int v57; // w4
  int v58; // w2
  int v59; // w10
  int v60; // w9
  int v61; // w12
  int v62; // w15
  int v63; // w16
  int v64; // w14
  int v65; // w13
  int v66; // w17
  int v67; // w19
  int v68; // w8
  int v69; // w7
  int v70; // w20
  int v71; // w6
  int v72; // w8
  int v73; // w8
  int v74; // w17
  int v75; // w14
  int v76; // w1
  int v77; // w3
  int v78; // w13
  int v79; // w14
  int v80; // w13
  int v81; // w10
  int v82; // w12
  int v83; // w8
  int v84; // w15

  v2 = *result;
  v1 = result[1];
  v4 = result[2];
  v3 = result[3];
  v6 = result[4];
  v5 = result[5];
  v8 = result[6];
  v7 = result[7];
  v9 = result[8];
  v10 = result[9];
  v12 = result[10];
  v11 = result[11];
  v14 = result[12];
  v13 = result[13];
  v15 = result[14];
  v16 = result[15];
  v17 = -2LL;
  do
  {
    v18 = v2 + v6;
    v19 = v1 + v5;
    v20 = v4 + v8;
    v21 = v3 + v7;
    v17 += 2LL;
    HIDWORD(v23) = v14 ^ v18;
    LODWORD(v23) = v14 ^ v18;
    v22 = v23 >> 16;
    HIDWORD(v23) = v13 ^ v19;
    LODWORD(v23) = v13 ^ v19;
    v24 = v23 >> 16;
    HIDWORD(v23) = v15 ^ v20;
    LODWORD(v23) = v15 ^ v20;
    v25 = v23 >> 16;
    HIDWORD(v23) = v16 ^ v21;
    LODWORD(v23) = v16 ^ v21;
    v26 = v23 >> 16;
    v27 = v9 + v22;
    v28 = v10 + v24;
    v29 = v12 + v25;
    v30 = v11 + v26;
    HIDWORD(v23) = v27 ^ v6;
    LODWORD(v23) = v27 ^ v6;
    v31 = v23 >> 20;
    HIDWORD(v23) = v28 ^ v5;
    LODWORD(v23) = v28 ^ v5;
    v32 = v23 >> 20;
    HIDWORD(v23) = v29 ^ v8;
    LODWORD(v23) = v29 ^ v8;
    v33 = v23 >> 20;
    HIDWORD(v23) = v30 ^ v7;
    LODWORD(v23) = v30 ^ v7;
    v34 = v23 >> 20;
    v35 = v31 + v18;
    v36 = v32 + v19;
    v37 = v33 + v20;
    v38 = v34 + v21;
    HIDWORD(v23) = v35 ^ v22;
    LODWORD(v23) = v35 ^ v22;
    v39 = v23 >> 24;
    HIDWORD(v23) = v36 ^ v24;
    LODWORD(v23) = v36 ^ v24;
    v40 = v23 >> 24;
    HIDWORD(v23) = v37 ^ v25;
    LODWORD(v23) = v37 ^ v25;
    v41 = v23 >> 24;
    HIDWORD(v23) = v38 ^ v26;
    LODWORD(v23) = v38 ^ v26;
    v42 = v23 >> 24;
    v43 = v39 + v27;
    v44 = v40 + v28;
    v45 = v41 + v29;
    v46 = v42 + v30;
    HIDWORD(v23) = v44 ^ v32;
    LODWORD(v23) = v44 ^ v32;
    v47 = v23 >> 25;
    HIDWORD(v23) = v45 ^ v33;
    LODWORD(v23) = v45 ^ v33;
    v48 = v23 >> 25;
    HIDWORD(v23) = v46 ^ v34;
    LODWORD(v23) = v46 ^ v34;
    v49 = v23 >> 25;
    HIDWORD(v23) = v43 ^ v31;
    LODWORD(v23) = v43 ^ v31;
    v50 = v23 >> 25;
    v51 = v47 + v35;
    v52 = v48 + v36;
    v53 = v49 + v37;
    v54 = v38 + v50;
    HIDWORD(v23) = v42 ^ v51;
    LODWORD(v23) = v42 ^ v51;
    v55 = v23 >> 16;
    HIDWORD(v23) = v52 ^ v39;
    LODWORD(v23) = v52 ^ v39;
    v56 = v23 >> 16;
    HIDWORD(v23) = v53 ^ v40;
    LODWORD(v23) = v53 ^ v40;
    v57 = v23 >> 16;
    HIDWORD(v23) = v54 ^ v41;
    LODWORD(v23) = v54 ^ v41;
    v58 = v23 >> 16;
    v59 = v55 + v45;
    v60 = v46 + v56;
    v61 = v57 + v43;
    v62 = v58 + v44;
    HIDWORD(v23) = v59 ^ v47;
    LODWORD(v23) = v59 ^ v47;
    v63 = v23 >> 20;
    HIDWORD(v23) = v60 ^ v48;
    LODWORD(v23) = v60 ^ v48;
    v64 = v23 >> 20;
    HIDWORD(v23) = v61 ^ v49;
    LODWORD(v23) = v61 ^ v49;
    v65 = v23 >> 20;
    HIDWORD(v23) = v62 ^ v50;
    LODWORD(v23) = v62 ^ v50;
    v66 = v23 >> 20;
    v2 = v63 + v51;
    v1 = v64 + v52;
    v4 = v65 + v53;
    v3 = v66 + v54;
    HIDWORD(v23) = v2 ^ v55;
    LODWORD(v23) = v2 ^ v55;
    v16 = v23 >> 24;
    HIDWORD(v23) = v1 ^ v56;
    LODWORD(v23) = v1 ^ v56;
    v14 = v23 >> 24;
    HIDWORD(v23) = v4 ^ v57;
    LODWORD(v23) = v4 ^ v57;
    v13 = v23 >> 24;
    HIDWORD(v23) = v3 ^ v58;
    LODWORD(v23) = v3 ^ v58;
    v15 = v23 >> 24;
    v12 = v16 + v59;
    v11 = v14 + v60;
    v9 = v13 + v61;
    v10 = v15 + v62;
    HIDWORD(v23) = v12 ^ v63;
    LODWORD(v23) = v12 ^ v63;
    v5 = v23 >> 25;
    HIDWORD(v23) = v11 ^ v64;
    LODWORD(v23) = v11 ^ v64;
    v8 = v23 >> 25;
    HIDWORD(v23) = v9 ^ v65;
    LODWORD(v23) = v9 ^ v65;
    v7 = v23 >> 25;
    HIDWORD(v23) = v10 ^ v66;
    LODWORD(v23) = v10 ^ v66;
    v6 = v23 >> 25;
  }
  while ( v17 < 0x12 );
  v67 = result[1];
  v68 = *result + v2;
  v70 = result[2];
  v69 = result[3];
  result[16] = v68;
  result[17] = v67 + v1;
  v72 = result[4];
  v71 = result[5];
  result[18] = v70 + v4;
  result[19] = v69 + v3;
  v73 = v72 + v6;
  v74 = result[7];
  v75 = result[6] + v8;
  v77 = result[8];
  v76 = result[9];
  result[20] = v73;
  result[21] = v71 + v5;
  result[22] = v75;
  result[23] = v74 + v7;
  v78 = result[10];
  v79 = result[11];
  result[24] = v77 + v9;
  result[25] = v76 + v10;
  v80 = v78 + v12;
  v82 = result[12];
  v81 = result[13];
  v83 = result[14];
  v84 = result[15];
  result[26] = v80;
  result[27] = v79 + v11;
  result[28] = v82 + v14;
  result[29] = v81 + v13;
  result[30] = v83 + v15;
  result[31] = v84 + v16;
  result[32] = 16;
  result[12] = v82 + 1;
  if ( v82 == -1 )
  {
    result[13] = v81 + 1;
    if ( v81 == -1 )
      result[14] = v83 + 1;
  }
  return result;
}


================================================================================
Function: sub_6785700 (0x6785700)
================================================================================

__int64 __fastcall sub_6785700(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x9
  __int64 v3; // x8
  bool v4; // cc
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x9
  unsigned __int64 v7; // x9
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x9
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x9

  v2 = *a1;
  if ( *a1 == -1LL )
  {
    v3 = 64LL;
  }
  else if ( v2 )
  {
    v3 = 0LL;
    do
    {
      v4 = v2 > 1;
      v3 += v2 & 1;
      v2 >>= 1;
    }
    while ( v4 );
  }
  else
  {
    v3 = 0LL;
  }
  v5 = a1[1];
  if ( v5 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v5 )
  {
    do
    {
      v4 = v5 > 1;
      v3 += v5 & 1;
      v5 >>= 1;
    }
    while ( v4 );
  }
  v6 = a1[2];
  if ( v6 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v6 )
  {
    do
    {
      v4 = v6 > 1;
      v3 += v6 & 1;
      v6 >>= 1;
    }
    while ( v4 );
  }
  v7 = a1[3];
  if ( v7 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v7 )
  {
    do
    {
      v4 = v7 > 1;
      v3 += v7 & 1;
      v7 >>= 1;
    }
    while ( v4 );
  }
  v8 = a1[4];
  if ( v8 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v8 )
  {
    do
    {
      v4 = v8 > 1;
      v3 += v8 & 1;
      v8 >>= 1;
    }
    while ( v4 );
  }
  v9 = a1[5];
  if ( v9 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v9 )
  {
    do
    {
      v4 = v9 > 1;
      v3 += v9 & 1;
      v9 >>= 1;
    }
    while ( v4 );
  }
  v10 = a1[6];
  if ( v10 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v10 )
  {
    do
    {
      v4 = v10 > 1;
      v3 += v10 & 1;
      v10 >>= 1;
    }
    while ( v4 );
  }
  v11 = a1[7];
  if ( v11 == -1LL )
  {
    v3 += 64LL;
  }
  else if ( v11 )
  {
    do
    {
      v4 = v11 > 1;
      v3 += v11 & 1;
      v11 >>= 1;
    }
    while ( v4 );
  }
  return v3 * (a2 >> 9);
}


================================================================================
Function: sub_6785898 (0x6785898)
================================================================================

__int64 __fastcall sub_6785898(__int64 a1, unsigned int *a2, _QWORD *a3)
{
  __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x8

  v3 = a2[7];
  if ( (unsigned int)v3 < 8 )
  {
    v5 = 0LL;
    if ( !a3 )
      return a1 + v5 - 0x3333333333330000LL * (((unsigned __int64)a2 - a1 - 264) >> 4);
LABEL_11:
    *a3 = ((unsigned __int64)*a2 << 16) - v5;
    return a1 + v5 - 0x3333333333330000LL * (((unsigned __int64)a2 - a1 - 264) >> 4);
  }
  if ( (unsigned int)v3 >= 0x201 )
    v4 = 0LL;
  else
    v4 = a2[7];
  if ( (unsigned int)v3 <= 0x40 )
    v5 = 3 * v3;
  else
    v5 = v4;
  if ( a3 )
    goto LABEL_11;
  return a1 + v5 - 0x3333333333330000LL * (((unsigned __int64)a2 - a1 - 264) >> 4);
}


================================================================================
Function: nullsub_286 (0x67858FC)
================================================================================

void nullsub_286()
{
  ;
}


================================================================================
Function: sub_6785900 (0x6785900)
================================================================================

__int64 __fastcall sub_6785900(__int64 a1, char a2, __int64 a3)
{
  unsigned __int64 v5; // x20
  __int64 result; // x0
  __int64 v7; // x8

  v5 = (a1 - 1) & 0xFFFFFFFFFE000000LL;
  result = sub_6785980();
  v7 = *(_QWORD *)(v5 + 208);
  if ( !v7 )
    return sub_6785AA8(v5, a2 & 1, a3);
  if ( v7 == *(_QWORD *)(v5 + 192) )
    return sub_6785CD4(v5, a3);
  return result;
}


================================================================================
Function: sub_6785980 (0x6785980)
================================================================================

__int64 __fastcall sub_6785980(unsigned int *a1, __int64 a2)
{
  char *v4; // x22
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x21
  __int64 v7; // x9
  char v8; // w8
  __int64 result; // x0

  v4 = (char *)a1 + 10;
  v5 = a1[7];
  v6 = ((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL;
  if ( (v5 & 0x80000000) != 0 )
    v5 = (unsigned __int64)*a1 << 16;
  sub_67886E8(*(_QWORD *)(a2 + 896) + 192LL, v5 * *((unsigned __int16 *)a1 + 5));
  sub_67886E8(*(_QWORD *)(a2 + 896) + 32LL, 1LL);
  if ( *(_BYTE *)(v6 + 24) && (sub_67814F4(11LL) & 1) != 0 )
  {
    v7 = a1[7];
    if ( (unsigned int)v7 < 8 )
    {
      v7 = 0LL;
    }
    else if ( (unsigned int)v7 > 0x40 )
    {
      if ( (unsigned int)v7 >= 0x201 )
        v7 = 0LL;
    }
    else
    {
      v7 *= 3LL;
    }
    sub_6782C98(
      v6 + v7 - 0x3333333333330000LL * (((unsigned __int64)a1 - v6 - 264) >> 4),
      ((unsigned __int64)*a1 << 16) - v7,
      *(_QWORD *)(a2 + 896));
  }
  v8 = a1[2] & 0xFD;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *(_QWORD *)(v4 + 62) = 0LL;
  *(_OWORD *)v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *((_BYTE *)a1 + 8) = v8;
  a1[7] = 1;
  result = sub_6787150(a1, a2);
  --*(_QWORD *)(v6 + 208);
  return result;
}


================================================================================
Function: sub_6785AA8 (0x6785AA8)
================================================================================

__int64 __fastcall sub_6785AA8(__int128 *a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // x9
  unsigned int *v6; // x8
  unsigned __int64 v7; // x12
  unsigned __int64 v8; // x15
  unsigned __int64 v9; // x0
  __int64 v10; // x17
  unsigned int **v11; // x1
  __int64 v12; // x0
  _QWORD *v13; // x15
  _QWORD *v14; // x15
  unsigned int *v15; // t1
  __int64 v16; // x0
  __int64 v17; // x22
  __int64 v18; // x23
  unsigned __int64 v19; // x9
  unsigned __int64 v20; // x8
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // x8
  __int64 v23; // x2
  __int64 v26; // x9
  __int64 v27; // x1
  __int64 v28; // x4
  __int128 v30; // [xsp+0h] [xbp-20h] BYREF
  __int64 v31; // [xsp+10h] [xbp-10h]

  v5 = *((_QWORD *)a1 + 31);
  if ( v5 >= 1 )
  {
    v6 = (unsigned int *)a1 + 66;
    v7 = (unsigned __int64)&a1[5 * v5 + 16] + 8;
    while ( v6[7] || *((_DWORD *)a1 + 60) == 1 )
    {
LABEL_4:
      v6 += 20 * *v6;
      if ( (unsigned __int64)v6 >= v7 )
        goto LABEL_19;
    }
    v8 = *v6;
    if ( (unsigned int)v8 >= 2 )
    {
      v9 = __clz(v8 - 1);
      if ( 63 - v9 >= 3 )
        v8 = (((v8 - 1) >> (61 - (unsigned __int8)v9)) & 3 | (4 * (63 - v9))) - 4;
    }
    v10 = *((_QWORD *)v6 + 8);
    if ( v10 )
      *(_QWORD *)(v10 + 56) = *((_QWORD *)v6 + 7);
    v11 = (unsigned int **)&a3[3 * v8];
    v12 = *((_QWORD *)v6 + 7);
    if ( *v11 == v6 )
    {
      *v11 = (unsigned int *)v12;
      if ( !v12 )
        goto LABEL_15;
    }
    else if ( !v12 )
    {
LABEL_15:
      v13 = &a3[3 * v8];
      v15 = (unsigned int *)v13[1];
      v14 = v13 + 1;
      if ( v15 == v6 )
        *v14 = *((_QWORD *)v6 + 8);
      *((_QWORD *)v6 + 7) = 0LL;
      *((_QWORD *)v6 + 8) = 0LL;
      v6[7] = 1;
      goto LABEL_4;
    }
    *(_QWORD *)(v12 + 64) = v10;
    goto LABEL_15;
  }
LABEL_19:
  sub_67886E8(a3[112] + 192LL, *((_QWORD *)a1 + 29) << 16);
  atomic_store(0LL, (unsigned __int64 *)a1 + 32);
  sub_6788440(a1);
  v16 = a3[112];
  v17 = -65536LL * *((_QWORD *)a1 + 28);
  if ( v17 < 0 )
  {
    sub_67886E8(v16, 1LL);
    v18 = -1LL;
  }
  else
  {
    v18 = 1LL;
    sub_6788604(v16, 1LL);
  }
  v19 = a3[109];
  v20 = a3[108] + v18;
  a3[108] = v20;
  if ( v20 > v19 )
    a3[109] = v20;
  v21 = a3[111];
  v22 = a3[110] + v17;
  a3[110] = v22;
  if ( v22 > v21 )
    a3[111] = v22;
  v23 = sub_6785700(a1 + 7, *((_QWORD *)a1 + 28) << 16);
  while ( atomic_load(qword_7292300) )
    __wfe();
  v26 = *((_QWORD *)a1 + 2);
  v27 = *((_QWORD *)a1 + 28) << 16;
  v28 = a3[112];
  v30 = *a1;
  v31 = v26;
  return sub_677E570(a1, v27, v23, &v30, v28);
}


================================================================================
Function: sub_6785CD4 (0x6785CD4)
================================================================================

unsigned __int64 __fastcall sub_6785CD4(unsigned __int64 a1, _QWORD *a2)
{
  __int64 v2; // x8
  unsigned __int64 *v5; // x11
  unsigned int *v6; // x8
  unsigned __int64 v7; // x11
  __int64 v8; // x14
  unsigned __int64 v9; // x15
  unsigned __int64 v10; // x0
  __int64 v11; // x17
  unsigned int **v12; // x1
  __int64 v13; // x0
  _QWORD *v14; // x15
  _QWORD *v15; // x15
  unsigned int *v16; // t1
  char v17; // w0
  __int64 v18; // x0
  __int64 v19; // x21
  __int64 v20; // x22
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // x8
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x8
  unsigned __int64 v25; // x21
  unsigned __int64 v26; // x0
  bool v27; // zf

  v2 = *(_QWORD *)(a1 + 248);
  if ( v2 >= 1 )
  {
    v5 = (unsigned __int64 *)(a1 + 80 * v2);
    v6 = (unsigned int *)(a1 + 264);
    v7 = (unsigned __int64)(v5 + 33);
    while ( 1 )
    {
      v8 = *v6;
      if ( !v6[7] )
        break;
LABEL_4:
      v6 += 20 * v8;
      if ( (unsigned __int64)v6 >= v7 )
        goto LABEL_18;
    }
    v9 = *v6;
    if ( (unsigned int)v8 >= 2 )
    {
      v9 = *v6;
      v10 = __clz(v8 - 1);
      if ( 63 - v10 >= 3 )
        v9 = (((unsigned __int64)(v8 - 1) >> (61 - (unsigned __int8)v10)) & 3 | (4 * (63 - v10))) - 4;
    }
    v11 = *((_QWORD *)v6 + 8);
    if ( v11 )
      *(_QWORD *)(v11 + 56) = *((_QWORD *)v6 + 7);
    v12 = (unsigned int **)&a2[3 * v9];
    v13 = *((_QWORD *)v6 + 7);
    if ( *v12 == v6 )
    {
      *v12 = (unsigned int *)v13;
      if ( !v13 )
        goto LABEL_14;
    }
    else if ( !v13 )
    {
LABEL_14:
      v14 = &a2[3 * v9];
      v16 = (unsigned int *)v14[1];
      v15 = v14 + 1;
      if ( v16 == v6 )
        *v15 = *((_QWORD *)v6 + 8);
      *((_QWORD *)v6 + 7) = 0LL;
      *((_QWORD *)v6 + 8) = 0LL;
      v6[7] = 0;
      goto LABEL_4;
    }
    *(_QWORD *)(v13 + 64) = v11;
    goto LABEL_14;
  }
LABEL_18:
  v17 = sub_67814F4(12LL);
  sub_6786778(a1, v17 & 1, a2[112]);
  sub_6788604(a2[112] + 224LL, 1LL);
  v18 = a2[112];
  v19 = -65536LL * *(_QWORD *)(a1 + 224);
  if ( v19 < 0 )
  {
    sub_67886E8(v18, 1LL);
    v20 = -1LL;
  }
  else
  {
    v20 = 1LL;
    sub_6788604(v18, 1LL);
  }
  v21 = a2[109];
  v22 = a2[108] + v20;
  a2[108] = v22;
  if ( v22 > v21 )
    a2[109] = v22;
  v23 = a2[111];
  v24 = a2[110] + v19;
  a2[110] = v24;
  if ( v24 > v23 )
    a2[111] = v24;
  atomic_store(0LL, (unsigned __int64 *)(a1 + 256));
  atomic_store(0LL, (unsigned __int64 *)(a1 + 176));
  *(_QWORD *)(a1 + 200) = 1LL;
  v25 = qword_7292340;
  do
  {
    atomic_store(v25 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(a1 + 176));
    v26 = sub_67EFFD0(v25, ((_DWORD)v25 + 1) & 0x1FFFFFF | a1, (atomic_ullong *)&qword_7292340);
    v27 = v26 == v25;
    v25 = v26;
  }
  while ( !v27 );
  return sub_67F0410(1uLL, (atomic_ullong *)&unk_7292380);
}


================================================================================
Function: sub_6785ED0 (0x6785ED0)
================================================================================

unsigned __int64 __fastcall sub_6785ED0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // x9
  unsigned __int64 v3; // x20
  unsigned __int64 result; // x0

  v2 = a2[112];
  v3 = (a1 - 1) & 0xFFFFFFFFFE000000LL;
  *(_UNKNOWN ***)((char *)off_C0 + v3) = (_UNKNOWN **)(*(char **)((char *)off_C0 + v3) + 1);
  result = sub_6788604(v2 + 256, 1LL);
  if ( *(_QWORD *)(v3 + 208) == *(_QWORD *)(v3 + 192) )
    return sub_6785CD4(v3, a2);
  return result;
}


================================================================================
Function: sub_6785F34 (0x6785F34)
================================================================================

__int64 __fastcall sub_6785F34(__int64 result, __int64 a2)
{
  atomic_ullong *v2; // x19
  _QWORD *v3; // x20
  atomic_ullong *v4; // x23
  __int64 v5; // x28
  __int64 v6; // x26
  unsigned __int64 v7; // x27
  atomic_ullong *v8; // x25
  _QWORD *v9; // x23
  atomic_ullong *v10; // x20
  __int64 v11; // x8
  __int64 v12; // x19
  unsigned __int64 v13; // x28
  unsigned __int64 v14; // x0
  bool v15; // zf
  unsigned __int64 v16; // x27
  unsigned __int64 v17; // x26
  unsigned __int64 v18; // x0
  __int64 v19; // [xsp+0h] [xbp-10h]

  v2 = (atomic_ullong *)&qword_72923C0;
  v3 = &unk_7292000;
  v4 = (atomic_ullong *)&unk_7292380;
  v19 = result;
LABEL_2:
  if ( !((unsigned __int64)qword_7292340 >> 25) )
  {
    if ( !v3[120] )
      return result;
    result = sub_67F0260(0LL, v2);
    if ( !result )
      return result;
    v5 = qword_7292340;
    v6 = result;
    if ( (unsigned __int64)qword_7292340 >> 25
      || (v7 = qword_7292400,
          sub_67F0010(
            qword_7292340,
            ((_DWORD)qword_7292340 + 1) & 0x1FFFFFF | (unsigned __int64)result,
            (atomic_ullong *)&qword_7292340) != v5) )
    {
      v8 = v4;
      v9 = v3;
      v10 = v2;
      v11 = v6;
      do
      {
        v12 = v11;
        v11 = *(_QWORD *)(v11 + 176);
      }
      while ( v11 );
      v13 = qword_7292340;
      do
      {
        v7 = qword_7292400;
        atomic_store(v13 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(v12 + 176));
        v14 = sub_67EFFD0(v13, ((_DWORD)v13 + 1) & 0x1FFFFFF | (unsigned __int64)v6, (atomic_ullong *)&qword_7292340);
        v15 = v14 == v13;
        v13 = v14;
      }
      while ( !v15 );
      v2 = v10;
      v3 = v9;
      v4 = v8;
    }
    sub_67F0410(v7, v4);
    sub_67F0410(-(__int64)v7, (atomic_ullong *)&qword_7292400);
  }
  sub_67F0410(1uLL, (atomic_ullong *)qword_7292300);
  v16 = atomic_load((unsigned __int64 *)&qword_7292340);
  while ( 1 )
  {
    v17 = v16 & 0xFFFFFFFFFE000000LL;
    if ( (v16 & 0xFFFFFFFFFE000000LL) == 0 )
      return sub_67F0410(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_7292300);
    v18 = sub_67F0010(
            v16,
            *(_QWORD *)((char *)&dword_B0 + (v16 & 0xFFFFFFFFFE000000LL)) | ((_DWORD)v16 + 1) & 0x1FFFFFF,
            (atomic_ullong *)&qword_7292340);
    v15 = v18 == v16;
    v16 = v18;
    if ( v15 )
    {
      sub_67F0410(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_7292300);
      atomic_store(0LL, (unsigned __int64 *)(v17 + 176));
      sub_67F0410(0xFFFFFFFFFFFFFFFFLL, v4);
      result = sub_6786114(v17, v19, 0LL, 0LL, a2);
      goto LABEL_2;
    }
  }
}


================================================================================
Function: sub_6786114 (0x6786114)
================================================================================

__int64 __fastcall sub_6786114(__int64 a1, unsigned __int64 a2, __int64 a3, _BYTE *a4, _QWORD *a5)
{
  __int64 v9; // x20
  __int64 v10; // x8
  unsigned __int64 v11; // x0
  __int64 v12; // x24
  __int64 v13; // x25
  unsigned __int64 v14; // x9
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x8
  __int64 v18; // x8
  __int64 v19; // x9
  unsigned __int64 v20; // x27
  unsigned __int64 *v21; // x24
  __int64 v22; // x0
  _BOOL4 v23; // w8

  v9 = a1;
  if ( a4 )
    *a4 = 0;
  atomic_store(sub_677FEA8(), (unsigned __int64 *)(a1 + 256));
  v10 = *(_QWORD *)(v9 + 224);
  *(_QWORD *)(v9 + 200) = 0LL;
  v11 = a5[112];
  v12 = v10 << 16;
  if ( v10 << 16 < 0 )
  {
    sub_67886E8(v11, 1uLL);
    v13 = -1LL;
  }
  else
  {
    v13 = 1LL;
    sub_6788604(v11, 1LL);
  }
  v14 = a5[109];
  v15 = a5[108] + v13;
  a5[108] = v15;
  if ( v15 > v14 )
    a5[109] = v15;
  v16 = a5[111];
  v17 = a5[110] + v12;
  a5[110] = v17;
  if ( v17 > v16 )
    a5[111] = v17;
  sub_67886E8(a5[112] + 224LL, 1uLL);
  v18 = *(_QWORD *)(v9 + 248);
  v19 = *(unsigned int *)(v9 + 264);
  if ( v18 > v19 )
  {
    v20 = v9 + 264 + 80 * v18;
    v21 = (unsigned __int64 *)(v9 + 80 * v19 + 264);
    while ( *((_DWORD *)v21 + 7) )
    {
      sub_67886E8(a5[112] + 256LL, 1uLL);
      --*(_QWORD *)(v9 + 192);
      atomic_store(a2, v21 + 6);
      sub_67834F8((__int64)v21, 0, 1);
      sub_6783734((unsigned __int64)v21, 0);
      if ( !*((_DWORD *)v21 + 6) )
      {
        v22 = sub_6785980((unsigned int *)v21, (__int64)a5);
        goto LABEL_13;
      }
      sub_6783844(a2, v21);
      if ( *((_DWORD *)v21 + 7) == a3 )
      {
        if ( *((_DWORD *)v21 + 6) >= (unsigned int)*((unsigned __int16 *)v21 + 6) )
        {
          v23 = v21[5] > 3;
          if ( a4 )
          {
LABEL_23:
            if ( v23 )
              *a4 = 1;
          }
        }
        else
        {
          v23 = 1;
          if ( a4 )
            goto LABEL_23;
        }
      }
LABEL_14:
      v21 += 10 * *(unsigned int *)v21;
      if ( (unsigned __int64)v21 >= v20 )
        goto LABEL_25;
    }
    v22 = (__int64)sub_6787150((unsigned int *)v21, (__int64)a5);
LABEL_13:
    v21 = (unsigned __int64 *)v22;
    goto LABEL_14;
  }
LABEL_25:
  if ( !*(_QWORD *)(v9 + 208) )
  {
    sub_6785AA8((__int128 *)v9, 0LL, a5);
    return 0LL;
  }
  return v9;
}


================================================================================
Function: sub_678630C (0x678630C)
================================================================================

__int64 __fastcall sub_678630C(__int64 result, char a2, __int64 a3)
{
  _QWORD *v5; // x20
  __int64 v6; // x20
  __int64 v7; // x21
  unsigned __int64 v8; // x22
  __int64 v9; // x8
  __int64 v10; // x20
  unsigned __int64 v11; // x25
  unsigned __int64 v12; // x0
  bool v13; // zf
  int v14; // w25
  char v15; // w8
  atomic_ullong *v16; // x24
  __int64 v17; // x20
  __int64 v18; // x27
  unsigned __int64 v19; // x28
  atomic_ullong *v20; // x25
  __int64 v21; // x24
  __int64 v22; // x8
  __int64 v23; // x23
  unsigned __int64 v24; // x20
  unsigned __int64 v25; // x0
  unsigned __int64 v26; // x28
  unsigned __int64 v27; // x27
  unsigned __int64 v28; // x0
  unsigned __int64 v29; // x20
  unsigned __int64 v30; // x0
  __int64 v32; // [xsp+0h] [xbp-10h]
  char v33; // [xsp+8h] [xbp-8h]
  int v34; // [xsp+Ch] [xbp-4h]

  v5 = &unk_7292000;
  v32 = result;
  if ( (a2 & 1) != 0 )
  {
    if ( qword_72923C0 && (result = sub_67F0260(0LL, (atomic_ullong *)&qword_72923C0)) != 0 )
    {
      v6 = qword_7292340;
      v7 = result;
      if ( (unsigned __int64)qword_7292340 >> 25
        || (v8 = qword_7292400,
            sub_67F0010(
              qword_7292340,
              ((_DWORD)qword_7292340 + 1) & 0x1FFFFFF | (unsigned __int64)result,
              (atomic_ullong *)&qword_7292340) != v6) )
      {
        v9 = v7;
        do
        {
          v10 = v9;
          v9 = *(_QWORD *)(v9 + 176);
        }
        while ( v9 );
        v11 = qword_7292340;
        do
        {
          v8 = qword_7292400;
          atomic_store(v11 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(v10 + 176));
          v12 = sub_67EFFD0(v11, ((_DWORD)v11 + 1) & 0x1FFFFFF | (unsigned __int64)v7, (atomic_ullong *)&qword_7292340);
          v13 = v12 == v11;
          v11 = v12;
        }
        while ( !v13 );
      }
      sub_67F0410(v8, (atomic_ullong *)&unk_7292380);
      result = sub_67F0410(-(__int64)v8, (atomic_ullong *)&qword_7292400);
      v14 = 0x3FFF;
      v5 = (_QWORD *)&unk_7292000;
    }
    else
    {
      v14 = 0x3FFF;
    }
  }
  else
  {
    v14 = 1023;
  }
  v15 = a2 & 1;
  v16 = (atomic_ullong *)&qword_7292400;
  v33 = v15;
  do
  {
    if ( !((unsigned __int64)qword_7292340 >> 25) )
    {
      if ( !v5[120] )
        return result;
      result = sub_67F0260(0LL, (atomic_ullong *)&qword_72923C0);
      if ( !result )
        return result;
      v17 = qword_7292340;
      v18 = result;
      if ( (unsigned __int64)qword_7292340 >> 25
        || (v19 = qword_7292400,
            sub_67F0010(
              qword_7292340,
              ((_DWORD)qword_7292340 + 1) & 0x1FFFFFF | (unsigned __int64)result,
              (atomic_ullong *)&qword_7292340) != v17) )
      {
        v34 = v14;
        v20 = v16;
        v21 = a3;
        v22 = v18;
        do
        {
          v23 = v22;
          v22 = *(_QWORD *)(v22 + 176);
        }
        while ( v22 );
        v24 = qword_7292340;
        do
        {
          v19 = qword_7292400;
          atomic_store(v24 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(v23 + 176));
          v25 = sub_67EFFD0(v24, ((_DWORD)v24 + 1) & 0x1FFFFFF | (unsigned __int64)v18, (atomic_ullong *)&qword_7292340);
          v13 = v25 == v24;
          v24 = v25;
        }
        while ( !v13 );
        a3 = v21;
        v5 = &unk_7292000;
        v16 = v20;
        v14 = v34;
      }
      else
      {
        v5 = (_QWORD *)&unk_7292000;
      }
      sub_67F0410(v19, (atomic_ullong *)&unk_7292380);
      sub_67F0410(-(__int64)v19, v16);
    }
    sub_67F0410(1uLL, (atomic_ullong *)qword_7292300);
    v26 = atomic_load((unsigned __int64 *)&qword_7292340);
    do
    {
      v27 = v26 & 0xFFFFFFFFFE000000LL;
      if ( (v26 & 0xFFFFFFFFFE000000LL) == 0 )
        return sub_67F0410(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_7292300);
      v28 = sub_67F0010(
              v26,
              *(_QWORD *)((char *)&dword_B0 + (v26 & 0xFFFFFFFFFE000000LL)) | ((_DWORD)v26 + 1) & 0x1FFFFFF,
              (atomic_ullong *)&qword_7292340);
      v13 = v28 == v26;
      v26 = v28;
    }
    while ( !v13 );
    sub_67F0410(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_7292300);
    atomic_store(0LL, (unsigned __int64 *)(v27 + 176));
    sub_67F0410(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)&unk_7292380);
    sub_678665C(v27, 0LL, 0LL, a3);
    if ( *(_QWORD *)(v27 + 208) )
    {
      sub_6786778(v27, v33, *(_QWORD *)(a3 + 896));
      v29 = v5[120];
      do
      {
        atomic_store(v29, (unsigned __int64 *)(v27 + 176));
        v30 = sub_67EFFD0(v29, v27, (atomic_ullong *)&qword_72923C0);
        v13 = v30 == v29;
        v29 = v30;
      }
      while ( !v13 );
      result = sub_67F0410(1uLL, v16);
      v5 = (_QWORD *)&unk_7292000;
    }
    else
    {
      result = sub_6786114(v27, v32, 0LL, 0LL, a3);
    }
  }
  while ( v14-- > 0 );
  return result;
}


================================================================================
Function: sub_678665C (0x678665C)
================================================================================

__int64 __fastcall sub_678665C(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x8
  __int64 v5; // x9
  unsigned __int64 v8; // x26
  char v11; // w24
  unsigned int *v12; // x23
  unsigned __int64 v13; // x8
  bool v14; // w8
  unsigned int v15; // w8
  unsigned int *v16; // x0

  v4 = *(_QWORD *)(a1 + 248);
  v5 = *(unsigned int *)(a1 + 264);
  if ( v4 > v5 )
  {
    v8 = a1 + 264 + 80 * v4;
    v11 = 0;
    v12 = (unsigned int *)(a1 + 80 * v5 + 264);
    while ( v12[7] )
    {
      sub_6783734((unsigned __int64)v12, 0);
      v15 = v12[6];
      if ( !v15 )
      {
        sub_67886E8(*(_QWORD *)(a4 + 896) + 256LL, 1uLL);
        --*(_QWORD *)(a1 + 192);
        v16 = (unsigned int *)sub_6785980(v12, a4);
        v13 = *v16;
        v12 = v16;
        goto LABEL_4;
      }
      if ( v12[7] != a3 )
        goto LABEL_6;
      v14 = v15 < *((unsigned __int16 *)v12 + 6) || *((_QWORD *)v12 + 5) > 3uLL;
LABEL_5:
      v11 |= v14;
LABEL_6:
      v12 += 20 * *v12;
      if ( (unsigned __int64)v12 >= v8 )
        return v11 & 1;
    }
    v13 = *v12;
LABEL_4:
    v14 = v13 >= a2;
    goto LABEL_5;
  }
  v11 = 0;
  return v11 & 1;
}


================================================================================
Function: sub_6786778 (0x6786778)
================================================================================

__int64 __fastcall sub_6786778(__int64 result, char a2, __int64 a3)
{
  __int64 v4; // x20
  _OWORD *v6; // x23
  __int128 v7; // q1
  unsigned __int64 v8; // x24
  __int128 v9; // q2
  __int128 v10; // q3
  unsigned __int64 v11; // x10
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x9
  __int64 v14; // x11
  __int64 v15; // x12
  __int64 v16; // x13
  unsigned __int64 v17; // x11
  char v18; // w13
  __int64 v19; // x15
  unsigned __int64 v20; // x12
  __int64 v21; // x14
  __int64 v22; // x2
  char v23; // w15
  _OWORD v24[4]; // [xsp+0h] [xbp-50h]

  if ( *(_BYTE *)(result + 25) )
  {
    v4 = result;
    v6 = (_OWORD *)(result + 48);
    if ( *(_QWORD *)(result + 48)
      || *(_QWORD *)(result + 56)
      || *(_QWORD *)(result + 64)
      || *(_QWORD *)(result + 72)
      || *(_QWORD *)(result + 80)
      || *(_QWORD *)(result + 88)
      || *(_QWORD *)(result + 96)
      || *(_QWORD *)(result + 104) )
    {
      result = sub_6789348();
      if ( (a2 & 1) != 0 || result >= *(_QWORD *)(v4 + 40) )
      {
        v7 = v6[1];
        v8 = 0LL;
        v9 = v6[2];
        v10 = v6[3];
        v24[0] = *v6;
        v24[1] = v7;
        *(_OWORD *)(v4 + 40) = 0u;
        *(_OWORD *)(v4 + 56) = 0u;
        *(_OWORD *)(v4 + 72) = 0u;
        *(_OWORD *)(v4 + 88) = 0u;
        v24[2] = v9;
        v24[3] = v10;
        *(_QWORD *)(v4 + 104) = 0LL;
        while ( 1 )
        {
          v11 = v8 >> 6;
          v12 = v8 & 0x3F;
          v13 = v8 >> 6 << 6;
          if ( v8 >> 6 <= 7 )
            v14 = 7LL;
          else
            v14 = v8 >> 6;
          v15 = -64LL * (v8 >> 6);
          v16 = v14 + 1;
          while ( 1 )
          {
            v17 = *((_QWORD *)v24 + v11) >> v12;
            if ( v17 )
              break;
            v12 = 0LL;
            ++v11;
            v15 -= 64LL;
            v13 += 64LL;
            if ( v16 == v11 )
              return result;
          }
          if ( (v17 & 1) == 0 )
          {
            do
            {
              v18 = v17;
              v17 >>= 1;
              ++v12;
            }
            while ( (v18 & 2) == 0 );
            if ( v11 > 7 )
              return result;
          }
          v19 = 0LL;
          v20 = v12 - v15;
          do
          {
            v21 = -v19;
            v22 = v19 << 16;
            do
            {
              v23 = v17;
              v17 >>= 1;
              --v21;
              v22 += 0x10000LL;
            }
            while ( (v23 & 2) != 0 );
            if ( (((_BYTE)v12 + (_BYTE)v13 - (_BYTE)v21) & 0x3F) != 0 )
              goto LABEL_26;
            if ( ++v11 > 7 )
              break;
            v17 = *((_QWORD *)v24 + v11);
LABEL_26:
            v19 = -v21;
          }
          while ( (v17 & 1) != 0 );
          if ( v21 )
          {
            v8 = v12 + v13 - v21;
            result = sub_6787638(v4, v4 + (v20 << 16), v22, a3);
            if ( v8 < 0x200 )
              continue;
          }
          return result;
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6786944 (0x6786944)
================================================================================

unsigned __int64 __fastcall sub_6786944(unsigned __int64 result, __int64 a2, __int64 a3)
{
  if ( *(_BYTE *)(result + 24) )
  {
    result = sub_677CC6C(a3);
    if ( result >= 9 )
      return sub_6782C98(a3 + 8, result - 8, &unk_7289F00);
  }
  return result;
}


================================================================================
Function: sub_6786994 (0x6786994)
================================================================================

__int64 __fastcall sub_6786994(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x29
  __int64 v6; // x30
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x2
  unsigned int v10; // w9
  unsigned __int64 v11; // x0
  __int64 v12; // x1
  __int64 v13; // x2
  unsigned int v14; // w9
  unsigned __int64 v15; // x19
  __int64 v16; // x0
  __int64 v17; // x1
  __int64 v18; // x21
  __int64 v19; // x8
  unsigned __int64 v20; // x9
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x9
  __int64 v23; // x9
  _QWORD v24[4]; // [xsp+0h] [xbp-40h] BYREF

  v7 = a2;
  if ( a3 >= 0x1000001 )
  {
    v14 = *(_DWORD *)(a1 + 2856);
    v11 = a2;
    if ( a3 <= 0x2000000 )
      v12 = 0x2000000LL;
    else
      v12 = a3;
    v13 = v14;
  }
  else
  {
    if ( a2 <= 0x4000 )
      goto LABEL_3;
    if ( a2 <= 0x20000 )
    {
      a2 = 0x80000LL;
      v8 = v7;
      return sub_6786B38(a1, a2, v8);
    }
    if ( a2 < 0x1000001 )
    {
LABEL_3:
      v8 = a2;
      return sub_6786B38(a1, a2, v8);
    }
    v10 = *(_DWORD *)(a1 + 2856);
    v11 = a2;
    v12 = a3;
    v13 = v10;
  }
  v24[2] = v5;
  v24[3] = v6;
  v15 = v12;
  v24[0] = 0LL;
  v16 = sub_67879F8(v11, v12, v13, a4, a5, v24);
  v17 = 0LL;
  if ( v16 )
  {
    v18 = v24[0];
    if ( v24[0] )
    {
      v19 = *(unsigned int *)(v24[0] + 28LL);
      if ( (unsigned int)v19 < 8 )
      {
        v19 = 0LL;
      }
      else if ( (unsigned int)v19 > 0x40 )
      {
        if ( (unsigned int)v19 >= 0x201 )
          v19 = 0LL;
      }
      else
      {
        v19 *= 3LL;
      }
      v20 = ((unsigned __int64)*(unsigned int *)v24[0] << 16) - v19;
      if ( v20 >> 31 )
        LODWORD(v20) = 0x80000000;
      *(_DWORD *)(v24[0] + 28LL) = v20;
      if ( v15 && *(_BYTE *)(v16 + 24) )
      {
        v21 = v16 + v19 - 0x3333333333330000LL * ((unsigned __int64)(v18 - v16 - 264) >> 4);
        v22 = v15 - 1 + v21;
        if ( (v15 & (v15 - 1)) != 0 )
          v23 = v22 / v15 * v15;
        else
          v23 = v22 & -(__int64)v15;
        sub_6782C98(v21 + 8, v23 - (v21 + 8), (__int64)&unk_7289F00);
      }
      return v18;
    }
  }
  return v17;
}


================================================================================
Function: sub_6786B38 (0x6786B38)
================================================================================

__int64 __fastcall sub_6786B38(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // x8
  __int64 v6; // x10
  void *v7; // x22
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x8
  __int64 v11; // x19
  unsigned __int64 v12; // x12
  unsigned int v14; // w20
  unsigned __int64 v15; // x21
  signed __int64 v16; // x8
  unsigned __int64 v17; // x10
  unsigned __int64 v18; // x27
  unsigned int **v19; // x23
  unsigned int *v20; // x25
  unsigned __int64 v21; // x26
  __int128 v22; // q0
  __int64 v23; // x9
  unsigned int *v24; // x10
  unsigned __int64 v25; // x2
  unsigned __int64 v26; // x8
  unsigned __int64 v27; // x9
  __int64 *v28; // x10
  unsigned __int64 v29; // x11
  unsigned __int64 v30; // x12
  unsigned __int64 v31; // x11
  _DWORD *v32; // x12
  unsigned __int64 v33; // x11
  unsigned __int64 v34; // x9
  __int64 v35; // x12
  unsigned __int64 *v36; // x9
  unsigned __int64 *v37; // x10
  __int64 v38; // x0
  __int64 v39; // x20
  __int64 v40; // x0
  __int64 v41; // x23
  __int64 v42; // x27
  unsigned __int64 v43; // x0
  __int64 v44; // x28
  unsigned __int64 v45; // x20
  unsigned __int64 v46; // x27
  __int64 v47; // x19
  __int64 v48; // x23
  void *v49; // x24
  unsigned __int64 v50; // x8
  unsigned __int64 v51; // x22
  unsigned __int64 v52; // x28
  unsigned __int64 v53; // x0
  bool v54; // zf
  unsigned __int64 v55; // x28
  unsigned __int64 v56; // x20
  unsigned __int64 v57; // x0
  __int128 v58; // q0
  __int64 v59; // x8
  int v60; // w28
  int v61; // w0
  unsigned __int64 v62; // x28
  unsigned __int64 v63; // x0
  __int64 v65; // [xsp+10h] [xbp-50h]
  unsigned __int64 v67; // [xsp+20h] [xbp-40h]
  __int64 v68; // [xsp+28h] [xbp-38h]
  char v70[4]; // [xsp+3Ch] [xbp-24h] BYREF
  __int128 v71; // [xsp+40h] [xbp-20h] BYREF
  __int64 v72; // [xsp+50h] [xbp-10h]

  v5 = 0x10000LL;
  v6 = -65536LL;
  v7 = &_stack_chk_guard;
  if ( a2 > 0x80000 )
    v5 = 0x80000LL;
  v8 = a2 + v5;
  if ( a2 > 0x80000 )
    v6 = -524288LL;
  v9 = v6 & (v8 - 1);
  v11 = a4;
  v12 = v9 >> 16;
  v14 = *(_DWORD *)(a1 + 2856);
  v67 = v9 >> 16;
  if ( v9 >= 0x20000 )
  {
    v17 = __clz(v12 - 1);
    v16 = v9 >> 16;
    if ( 63 - v17 >= 3 )
      v16 = (((v12 - 1) >> (61 - (unsigned __int8)v17)) & 3 | (4 * (63 - v17))) - 4;
    v15 = v12;
    if ( v16 > 35 )
    {
LABEL_46:
      v70[0] = 0;
      v40 = sub_6781400(0x15u, 8LL, 1024LL);
      v41 = a1;
      if ( v40 < 1 )
      {
LABEL_79:
        if ( sub_67879F8(0LL, 0LL, *(unsigned int *)(v41 + 2856), v11, a5, 0LL) )
          return sub_6786B38(v41, a2, a3);
        return 0LL;
      }
      v42 = v40;
      v65 = v11;
      while ( 2 )
      {
        v68 = v42;
        if ( !((unsigned __int64)qword_7292340 >> 25) )
        {
          if ( !qword_72923C0 )
          {
LABEL_76:
            v43 = 0LL;
LABEL_77:
            if ( v70[0] )
              return 0LL;
            goto LABEL_78;
          }
          v43 = sub_67F0260(0LL, (atomic_ullong *)&qword_72923C0);
          if ( !v43 )
            goto LABEL_77;
          v44 = qword_7292340;
          v45 = v43;
          if ( (unsigned __int64)qword_7292340 >> 25
            || (v46 = qword_7292400,
                sub_67F0010(
                  qword_7292340,
                  ((_DWORD)qword_7292340 + 1) & 0x1FFFFFF | v43,
                  (atomic_ullong *)&qword_7292340) != v44) )
          {
            v47 = v41;
            v48 = a5;
            v49 = v7;
            v50 = v45;
            do
            {
              v51 = v50;
              v50 = *(_QWORD *)(v50 + 176);
            }
            while ( v50 );
            v52 = qword_7292340;
            do
            {
              v46 = qword_7292400;
              atomic_store(v52 & 0xFFFFFFFFFE000000LL, (unsigned __int64 *)(v51 + 176));
              v53 = sub_67EFFD0(v52, ((_DWORD)v52 + 1) & 0x1FFFFFF | v45, (atomic_ullong *)&qword_7292340);
              v54 = v53 == v52;
              v52 = v53;
            }
            while ( !v54 );
            v7 = v49;
            a5 = v48;
            v41 = v47;
            v11 = v65;
          }
          sub_67F0410(v46, (atomic_ullong *)&unk_7292380);
          sub_67F0410(-(__int64)v46, (atomic_ullong *)&qword_7292400);
        }
        v42 = v68 - 1;
        sub_67F0410(1uLL, (atomic_ullong *)qword_7292300);
        v55 = atomic_load((unsigned __int64 *)&qword_7292340);
        do
        {
          v56 = v55 & 0xFFFFFFFFFE000000LL;
          if ( (v55 & 0xFFFFFFFFFE000000LL) == 0 )
          {
            sub_67F0410(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_7292300);
            goto LABEL_76;
          }
          v57 = sub_67F0010(
                  v55,
                  *(_QWORD *)((char *)&dword_B0 + (v55 & 0xFFFFFFFFFE000000LL)) | ((_DWORD)v55 + 1) & 0x1FFFFFF,
                  (atomic_ullong *)&qword_7292340);
          v54 = v57 == v55;
          v55 = v57;
        }
        while ( !v54 );
        sub_67F0410(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)qword_7292300);
        atomic_store(0LL, (unsigned __int64 *)(v56 + 176));
        sub_67F0410(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)&unk_7292380);
        v58 = *(_OWORD *)v56;
        v59 = *(_QWORD *)(v56 + 200) + 1LL;
        v72 = *(_QWORD *)(v56 + 16);
        v71 = v58;
        *(_QWORD *)(v56 + 200) = v59;
        v60 = sub_677DCD4(v41, &v71);
        v61 = sub_678665C(v56, v67, a3, v11);
        if ( !*(_QWORD *)(v56 + 208) )
          goto LABEL_68;
        if ( (v61 & v60 & 1) != 0 )
        {
          v43 = sub_6786114(v56, v41, a3, v70, v11);
          if ( v70[0] )
            return 0LL;
LABEL_78:
          if ( v43 )
            return sub_6786B38(v41, a2, a3);
          goto LABEL_79;
        }
        if ( *(_QWORD *)(v56 + 200) < 4uLL || ((v60 ^ 1) & 1) != 0 )
        {
          sub_6786778(v56, 1, *(_QWORD *)(v11 + 896));
          v62 = qword_72923C0;
          do
          {
            atomic_store(v62, (unsigned __int64 *)(v56 + 176));
            v63 = sub_67EFFD0(v62, v56, (atomic_ullong *)&qword_72923C0);
            v54 = v63 == v62;
            v62 = v63;
          }
          while ( !v54 );
          sub_67F0410(1uLL, (atomic_ullong *)&qword_7292400);
        }
        else
        {
LABEL_68:
          sub_6786114(v56, v41, 0LL, 0LL, v11);
        }
        if ( v68 > 1 )
          continue;
        goto LABEL_76;
      }
    }
  }
  else
  {
    v15 = 1LL;
    v16 = v9 >> 16;
  }
  v18 = a4 + 840;
  v19 = (unsigned int **)(a4 + 24 * v16);
  while ( 1 )
  {
    v20 = *v19;
    if ( *v19 )
      break;
LABEL_11:
    v19 += 3;
    if ( (unsigned __int64)v19 > v18 )
      goto LABEL_46;
  }
  while ( 1 )
  {
    if ( v15 <= *v20 )
    {
      v21 = ((unsigned __int64)v20 - 1) & 0xFFFFFFFFFE000000LL;
      v22 = *(_OWORD *)v21;
      v72 = *(_QWORD *)((char *)&word_10 + v21);
      v71 = v22;
      if ( (sub_677E0B4(&v71, v14) & 1) != 0 )
        break;
    }
    v20 = (unsigned int *)*((_QWORD *)v20 + 7);
    if ( !v20 )
      goto LABEL_11;
  }
  v23 = *((_QWORD *)v20 + 8);
  if ( v23 )
    *(_QWORD *)(v23 + 56) = *((_QWORD *)v20 + 7);
  v24 = (unsigned int *)*((_QWORD *)v20 + 7);
  if ( *v19 == v20 )
    *v19 = v24;
  if ( v24 )
    *((_QWORD *)v24 + 8) = v23;
  if ( v19[1] == v20 )
    v19[1] = (unsigned int *)*((_QWORD *)v20 + 8);
  v25 = *v20;
  *((_QWORD *)v20 + 7) = 0LL;
  *((_QWORD *)v20 + 8) = 0LL;
  v20[7] = 1;
  if ( v15 < v25 )
  {
    v26 = v15 - 0x3333333333333333LL * ((__int64)((__int64)v20 - v21 - 264) >> 4);
    v27 = v25 - v15;
    if ( *(_DWORD *)((char *)&qword_F0 + (((unsigned __int64)v20 - 1) & 0xFFFFFFFFFE000000LL)) == 1 )
    {
      v28 = 0LL;
    }
    else
    {
      v28 = (__int64 *)atomic_load((unsigned __int64 *)(v21 + 256));
      if ( v28 )
      {
        if ( v27 >= 2 )
        {
          v30 = __clz(v27 - 1);
          v29 = v25 - v15;
          if ( 63 - v30 >= 3 )
            v29 = (((v27 - 1) >> (61 - (unsigned __int8)v30)) & 3 | (4 * (63 - v30))) - 4;
        }
        else
        {
          v29 = v25 - v15;
        }
        v28 = (__int64 *)(v11 + 24 * v29);
      }
    }
    if ( !v27 )
      v27 = 1LL;
    v31 = v21 + 80 * v26;
    *(_DWORD *)(v31 + 264) = v27;
    *(_DWORD *)(v31 + 268) = 0;
    if ( v27 >= 2 )
    {
      v32 = (_DWORD *)(v21 + 80 * (v26 + v27));
      v32[46] = 0;
      v32[47] = 80 * v27 - 80;
      v32[53] = 0;
    }
    if ( v28 )
    {
      v33 = v31 + 264;
      v34 = v21 + 80 * v26;
      *(_QWORD *)(v34 + 328) = 0LL;
      v35 = *v28;
      *(_QWORD *)(v34 + 320) = *v28;
      v36 = (unsigned __int64 *)(v35 + 64);
      *v28 = v33;
      v37 = (unsigned __int64 *)(v28 + 1);
      if ( !v35 )
        v36 = v37;
      *v36 = v33;
    }
    v25 = (unsigned int)v15;
    *(int *)((char *)&dword_124[20 * v26] + (((unsigned __int64)v20 - 1) & 0xFFFFFFFFFE000000LL)) = 0;
    *v20 = v15;
  }
  v38 = sub_6787F30(
          ((unsigned __int64)v20 - 1) & 0xFFFFFFFFFE000000LL,
          0xCCCCCCCCCCCCCCCDLL * ((__int64)((__int64)v20 - v21 - 264) >> 4),
          v25,
          v11);
  if ( !v38 )
  {
    sub_6787150(v20, v11);
    goto LABEL_46;
  }
  v39 = v38;
  sub_6786778((v38 - 1) & 0xFFFFFFFFFE000000LL, 0, *(_QWORD *)(v11 + 896));
  return v39;
}


================================================================================
Function: sub_6787150 (0x6787150)
================================================================================

unsigned int *__fastcall sub_6787150(unsigned int *a1, __int64 a2)
{
  unsigned int *v2; // x19
  unsigned __int64 v3; // x0
  unsigned __int64 v4; // x8
  __int64 v5; // x11
  unsigned int *v6; // x10
  unsigned int *v7; // x9
  _DWORD *v8; // x9
  unsigned int v9; // t1
  char *v10; // x9
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x10
  __int64 v13; // x10
  unsigned int **v14; // x12
  __int64 v15; // x11
  __int64 v16; // x9
  _QWORD *v17; // x9
  unsigned int *v18; // t1
  unsigned __int64 v20; // x12
  unsigned __int64 v21; // x14
  unsigned int *v22; // x13
  _QWORD *v23; // x13
  __int64 v24; // x14
  __int64 v25; // t1
  unsigned int **v26; // x15
  unsigned int *v27; // x11
  _QWORD *v28; // x11
  __int64 v29; // x16
  __int64 v30; // t1
  __int64 v31; // x12
  _QWORD *v32; // x12
  unsigned int *v33; // t1

  v2 = a1;
  v3 = ((unsigned __int64)a1 - 1) & 0xFFFFFFFFFE000000LL;
  v4 = atomic_load((unsigned __int64 *)(v3 | 0x100));
  if ( *(_DWORD *)(v3 + 240) == 1 )
  {
    v2[7] = 0;
  }
  else
  {
    v5 = *v2;
    v6 = &v2[20 * v5];
    if ( (unsigned __int64)v6 < v3 + 80LL * *(_QWORD *)(v3 + 248) + 264 )
    {
      v7 = &v2[20 * v5];
      v9 = v7[7];
      v8 = v7 + 7;
      if ( !v9 )
      {
        v20 = *v6;
        if ( v4 )
        {
          if ( (unsigned int)v20 >= 2 )
          {
            v21 = __clz(v20 - 1);
            if ( 63 - v21 >= 3 )
              v20 = (((v20 - 1) >> (61 - (unsigned __int8)v21)) & 3 | (4 * (63 - v21))) - 4;
          }
          v22 = &v2[20 * v5];
          v25 = *((_QWORD *)v22 + 8);
          v23 = v22 + 16;
          v24 = v25;
          if ( v25 )
            *(_QWORD *)(v24 + 56) = *(_QWORD *)&v2[20 * v5 + 14];
          v26 = (unsigned int **)(a2 + 24 * v20);
          v27 = &v2[20 * v5];
          v30 = *((_QWORD *)v27 + 7);
          v28 = v27 + 14;
          v29 = v30;
          if ( *v26 == v6 )
            *v26 = (unsigned int *)v29;
          if ( v29 )
            *(_QWORD *)(v29 + 64) = v24;
          v31 = a2 + 24 * v20;
          v33 = *(unsigned int **)(v31 + 8);
          v32 = (_QWORD *)(v31 + 8);
          if ( v33 == v6 )
            *v32 = *v23;
          *v28 = 0LL;
          v28[1] = 0LL;
          *v8 = 1;
        }
      }
    }
    if ( v3 + 264 < (unsigned __int64)v2 )
    {
      v10 = (char *)v2 - *(v2 - 19);
      if ( !*((_DWORD *)v10 - 13) )
      {
        v2 = (unsigned int *)(v10 - 80);
        v11 = *((unsigned int *)v10 - 20);
        if ( v4 )
        {
          if ( (unsigned int)v11 >= 2 )
          {
            v12 = __clz(v11 - 1);
            if ( 63 - v12 >= 3 )
              v11 = (((v11 - 1) >> (61 - (unsigned __int8)v12)) & 3 | (4 * (63 - v12))) - 4;
          }
          v13 = *((_QWORD *)v2 + 8);
          if ( v13 )
            *(_QWORD *)(v13 + 56) = *((_QWORD *)v2 + 7);
          v14 = (unsigned int **)(a2 + 24 * v11);
          v15 = *((_QWORD *)v2 + 7);
          if ( *v14 == v2 )
            *v14 = (unsigned int *)v15;
          if ( v15 )
            *(_QWORD *)(v15 + 64) = v13;
          v16 = a2 + 24 * v11;
          v18 = *(unsigned int **)(v16 + 8);
          v17 = (_QWORD *)(v16 + 8);
          if ( v18 == v2 )
            *v17 = *((_QWORD *)v2 + 8);
          *((_QWORD *)v2 + 7) = 0LL;
          *((_QWORD *)v2 + 8) = 0LL;
          v2[7] = 1;
        }
      }
    }
    sub_678736C();
  }
  return v2;
}


================================================================================
Function: sub_678736C (0x678736C)
================================================================================

__int64 __fastcall sub_678736C(__int64 result, __int64 a2, unsigned __int64 a3, char a4, __int64 a5)
{
  __int64 v5; // x19
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x10
  __int64 *v10; // x25
  unsigned __int64 v11; // x8
  __int64 v12; // x9
  _DWORD *v13; // x10
  __int64 v14; // x26
  __int64 v15; // x21
  unsigned __int64 v16; // x23
  unsigned __int64 v17; // x22
  bool v18; // w9
  int8x16_t v19; // q3
  int8x16_t v20; // q5
  int8x16_t v21; // q2
  int8x16_t v22; // q1
  __int64 v23; // x0
  __int64 v24; // x23
  __int64 v25; // x22
  __int64 v26; // x8
  __int64 v27; // x0
  __int64 v28; // x8
  __int64 v29; // x9
  __int64 *v30; // x8
  __int64 *v31; // x25
  __int64 v32; // [xsp+0h] [xbp-60h] BYREF
  char v33[8]; // [xsp+8h] [xbp-58h] BYREF
  int8x16_t v34; // [xsp+10h] [xbp-50h] BYREF
  int8x16_t v35; // [xsp+20h] [xbp-40h]
  int8x16_t v36; // [xsp+30h] [xbp-30h]
  int8x16_t v37; // [xsp+40h] [xbp-20h]

  v5 = result;
  if ( *(_DWORD *)(result + 240) == 1 || (v7 = atomic_load((unsigned __int64 *)(result + 256))) == 0 )
  {
    v10 = 0LL;
  }
  else
  {
    v8 = a3;
    if ( a3 >= 2 )
    {
      v9 = __clz(a3 - 1);
      v8 = a3;
      if ( 63 - v9 >= 3 )
        v8 = (((a3 - 1) >> (61 - (unsigned __int8)v9)) & 3 | (4 * (63 - v9))) - 4;
    }
    v10 = (__int64 *)(a5 + 24 * v8);
  }
  if ( a3 )
    v11 = a3;
  else
    v11 = 1LL;
  v12 = result + 80 * a2;
  *(_DWORD *)(v12 + 264) = v11;
  *(_DWORD *)(v12 + 268) = 0;
  if ( v11 >= 2 )
  {
    v13 = (_DWORD *)(result + 80 * (a2 + v11));
    v13[46] = 0;
    v13[47] = 80 * v11 - 80;
    v13[53] = 0;
  }
  v14 = v12 + 264;
  if ( (a4 & 1) == 0 || !*(_BYTE *)(result + 25) )
    goto LABEL_33;
  v15 = *(_QWORD *)(a5 + 896);
  v16 = v11 << 16;
  v17 = ((v12 + 263) & 0xFFFFFFFFFE000000LL)
      - 0x3333333333330000LL * ((v12 - ((v12 + 263) & 0xFFFFFFFFFE000000LL)) >> 4);
  if ( !sub_6780DEC(15LL) )
  {
    result = sub_6787638(v5, v17, v16, v15);
    if ( !v10 )
      goto LABEL_37;
    goto LABEL_34;
  }
  v32 = 0LL;
  result = sub_6787864(v5, 1LL, v17, v16, v33, &v32, &v34);
  v18 = 0;
  if ( !v34.n128_u64[0]
    && __PAIR128__(v34.n128_u64[1], 0LL) == v35.n128_u64[0]
    && __PAIR128__(v35.n128_u64[1], 0LL) == v36.n128_u64[0]
    && __PAIR128__(v36.n128_u64[1], 0LL) == v37.n128_u64[0] )
  {
    v18 = v37.n128_u64[1] == 0;
  }
  if ( v18 || !v32 )
  {
LABEL_33:
    if ( !v10 )
      goto LABEL_37;
    goto LABEL_34;
  }
  v19 = vandq_s8(*(int8x16_t *)(v5 + 160), v37);
  v20 = *(int8x16_t *)(v5 + 96);
  v21 = vorrq_s8(*(int8x16_t *)(v5 + 64), vandq_s8(*(int8x16_t *)(v5 + 128), v35));
  v22 = vorrq_s8(*(int8x16_t *)(v5 + 80), vandq_s8(*(int8x16_t *)(v5 + 144), v36));
  *(int8x16_t *)(v5 + 48) = vorrq_s8(*(int8x16_t *)(v5 + 48), vandq_s8(*(int8x16_t *)(v5 + 112), v34));
  *(int8x16_t *)(v5 + 64) = v21;
  *(int8x16_t *)(v5 + 80) = v22;
  *(int8x16_t *)(v5 + 96) = vorrq_s8(v20, v19);
  v23 = sub_6789348();
  v24 = *(_QWORD *)(v5 + 40);
  v25 = v23;
  if ( !v24 )
  {
    v27 = 15LL;
LABEL_31:
    result = sub_6780DEC(v27);
    v26 = result + v25;
    goto LABEL_32;
  }
  result = sub_6780DEC(25LL);
  if ( v24 > v25 )
  {
    v26 = *(_QWORD *)(v5 + 40) + result;
LABEL_32:
    *(_QWORD *)(v5 + 40) = v26;
    goto LABEL_33;
  }
  if ( result + v24 > v25 )
  {
    v27 = 25LL;
    goto LABEL_31;
  }
  result = sub_6786778(v5, 1, v15);
  if ( !v10 )
    goto LABEL_37;
LABEL_34:
  v28 = v5 + 80 * a2;
  *(_QWORD *)(v28 + 328) = 0LL;
  v29 = *v10;
  *(_QWORD *)(v28 + 320) = *v10;
  v30 = (__int64 *)(v29 + 64);
  *v10 = v14;
  v31 = v10 + 1;
  if ( !v29 )
    v30 = v31;
  *v30 = v14;
LABEL_37:
  *(_DWORD *)(v5 + 80 * a2 + 292) = 0;
  return result;
}


================================================================================
Function: sub_6787638 (0x6787638)
================================================================================

int8x16_t __fastcall sub_6787638(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int8x16_t result; // q0
  int8x16_t v7; // q5
  int8x16_t v8; // q6
  bool v9; // w14
  int8x16_t v10; // q7
  unsigned __int64 v11; // x23
  __int64 v12; // x21
  unsigned __int64 v13; // x24
  unsigned __int64 v14; // x8
  int8x16_t v15; // q1
  unsigned __int64 v16; // x9
  int8x16_t v17; // q2
  __int64 v18; // x0
  int8x16_t v19; // q0
  int8x16_t v20; // q4
  int8x16_t v21; // q2
  int8x16_t v22; // q3
  int8x16_t v23; // q0
  int8x16_t v24; // q4
  int8x16_t v25; // q2
  int8x16_t v26; // q3
  int8x16_t v27; // [xsp+0h] [xbp-D0h]
  int8x16_t v28; // [xsp+10h] [xbp-C0h]
  int8x16_t v29; // [xsp+20h] [xbp-B0h]
  __int64 v30; // [xsp+30h] [xbp-A0h] BYREF
  __int64 v31; // [xsp+38h] [xbp-98h] BYREF
  _OWORD v32[3]; // [xsp+40h] [xbp-90h] BYREF
  unsigned __int64 v33; // [xsp+70h] [xbp-60h]
  unsigned __int64 v34; // [xsp+78h] [xbp-58h]
  _BYTE v35[56]; // [xsp+80h] [xbp-50h] BYREF
  unsigned __int64 v36; // [xsp+B8h] [xbp-18h]

  if ( *(_BYTE *)(a1 + 25) )
  {
    v30 = 0LL;
    v31 = 0LL;
    sub_6787864(a1, 1LL, a2, a3, &v31, &v30, v35);
    v7 = *(int8x16_t *)v35;
    v8 = *(int8x16_t *)&v35[16];
    v9 = 0;
    v10 = *(int8x16_t *)&v35[32];
    v11 = *(_QWORD *)&v35[48];
    if ( *(_OWORD *)v35 == 0LL
      && *(_OWORD *)&v35[16] == 0LL
      && !*(_QWORD *)&v35[32]
      && __PAIR128__(*(unsigned __int64 *)&v35[40], 0LL) == *(unsigned __int64 *)&v35[48] )
    {
      v9 = v36 == 0;
    }
    if ( !v9 )
    {
      v12 = v30;
      if ( v30 )
      {
        if ( (*(_QWORD *)(a1 + 112) & *(_QWORD *)v35) != 0LL
          || (*(_OWORD *)&v35[8] & *(_OWORD *)(a1 + 120)) != 0LL
          || (*(_OWORD *)&v35[24] & *(_OWORD *)(a1 + 136)) != 0LL
          || (*(_OWORD *)&v35[40] & *(_OWORD *)(a1 + 152)) != 0LL
          || (v13 = v36, (v36 & *(_QWORD *)(a1 + 168)) != 0) )
        {
          v27 = *(int8x16_t *)&v35[32];
          v28 = *(int8x16_t *)&v35[16];
          v29 = *(int8x16_t *)v35;
          if ( (sub_6782EDC(v31, v30, a4) & 1) != 0 )
          {
            v13 = v36;
            v14 = v11 & *(_QWORD *)(a1 + 160);
            v15 = vandq_s8(v28, *(int8x16_t *)(a1 + 128));
            v16 = v36 & *(_QWORD *)(a1 + 168);
            v17 = vandq_s8(v27, *(int8x16_t *)(a1 + 144));
            v32[0] = vandq_s8(v29, *(int8x16_t *)(a1 + 112));
            v32[1] = v15;
            v33 = v14;
            v34 = v16;
            v32[2] = v17;
            v18 = sub_6785700((unsigned __int64 *)v32, 0x2000000uLL);
            sub_6788604((unsigned __int64)&unk_7289F60, v12 - v18);
            v19.n128_u64[0] = v11;
            v7 = v29;
            v10 = v27;
            v8 = v28;
            v19.n128_u64[1] = v13;
            v20 = *(int8x16_t *)(a1 + 160);
            v21 = vbicq_s8(*(int8x16_t *)(a1 + 128), v28);
            v22 = vbicq_s8(*(int8x16_t *)(a1 + 144), v27);
            *(int8x16_t *)(a1 + 112) = vbicq_s8(*(int8x16_t *)(a1 + 112), v29);
            *(int8x16_t *)(a1 + 128) = v21;
            *(int8x16_t *)(a1 + 144) = v22;
            *(int8x16_t *)(a1 + 160) = vbicq_s8(v20, v19);
          }
          else
          {
            v8 = v28;
            v7 = v29;
            v13 = v36;
            v10 = v27;
          }
        }
        v23.n128_u64[0] = v11;
        v23.n128_u64[1] = v13;
        v24 = *(int8x16_t *)(a1 + 96);
        v25 = vbicq_s8(*(int8x16_t *)(a1 + 64), v8);
        v26 = vbicq_s8(*(int8x16_t *)(a1 + 80), v10);
        *(int8x16_t *)(a1 + 48) = vbicq_s8(*(int8x16_t *)(a1 + 48), v7);
        *(int8x16_t *)(a1 + 64) = v25;
        result = vbicq_s8(v24, v23);
        *(int8x16_t *)(a1 + 80) = v26;
        *(int8x16_t *)(a1 + 96) = result;
      }
    }
  }
  return result;
}


================================================================================
Function: sub_6787864 (0x6787864)
================================================================================

signed __int64 __fastcall sub_6787864(
        signed __int64 result,
        char a2,
        char *a3,
        __int64 a4,
        _QWORD *a5,
        unsigned __int64 *a6,
        _OWORD *a7)
{
  unsigned __int64 v8; // x9
  __int64 v9; // x13
  char *v10; // x10
  __int64 v11; // x12
  unsigned __int64 v12; // x13
  unsigned __int64 v14; // x20
  unsigned __int64 v15; // x7
  unsigned __int64 v16; // x21
  __int128 v17; // q0
  unsigned __int64 v18; // x10
  unsigned __int64 v19; // x9
  __int64 v20; // x11
  unsigned __int64 v21; // x9
  __int64 *v22; // x10
  unsigned __int64 v23; // x12
  __int64 v24; // x13

  a7[2] = 0u;
  a7[3] = 0u;
  *a7 = 0u;
  a7[1] = 0u;
  if ( (unsigned __int64)(a4 - 33554433) >= 0xFFFFFFFFFE000000LL && *(_DWORD *)(result + 240) != 1 )
  {
    v8 = *(_QWORD *)(result + 224) << 16;
    if ( result + v8 > (unsigned __int64)a3 )
    {
      v9 = (__int64)&a3[-result + 0xFFFF];
      if ( (a2 & 1) == 0 )
        v9 = (__int64)&a3[-result];
      v10 = (char *)(*(_QWORD *)(result + 232) << 16);
      v11 = (__int64)&a3[a4 - result + 0xFFFF];
      v12 = v9 & 0xFFFFFFFFFFFF0000LL;
      if ( (a2 & 1) != 0 )
        v11 = (__int64)&a3[a4 - result];
      if ( v12 < (unsigned __int64)v10 && &a3[-result] >= v10 )
        v14 = *(_QWORD *)(result + 232) << 16;
      else
        v14 = v12;
      if ( (v11 & 0xFFFFFFFFFFFF0000LL) <= v8 )
        v8 = v11 & 0xFFFFFFFFFFFF0000LL;
      v15 = v8 >= v14 ? v8 - v14 : 0LL;
      *a5 = result + v14;
      *a6 = v15;
      if ( v8 > v14 )
      {
        v16 = v15 >> 16;
        if ( (v15 >> 16) + (v14 >> 16) >= 0x201 )
          result = sub_6781928(
                     (signed __int64)"commit mask overflow: idx=%zu count=%zu start=%zx end=%zx p=0x%p size=%zu fullsize=%zu\n",
                     v14 >> 16,
                     v15 >> 16,
                     v14,
                     v8,
                     a3,
                     a4,
                     v15);
        if ( !v16 )
        {
          v17 = 0uLL;
          goto LABEL_26;
        }
        if ( v16 == 512 )
        {
          *(_QWORD *)&v17 = -1LL;
          *((_QWORD *)&v17 + 1) = -1LL;
LABEL_26:
          a7[2] = v17;
          a7[3] = v17;
          *a7 = v17;
          a7[1] = v17;
          return result;
        }
        v18 = v14 >> 22;
        if ( 64 - ((v14 >> 16) & 0x3F) >= v16 )
          v19 = v16;
        else
          v19 = 64 - ((v14 >> 16) & 0x3F);
        v20 = ~(-1LL << v19) << SBYTE2(v14);
        a7[2] = 0u;
        a7[3] = 0u;
        if ( v19 > 0x3F )
          v20 = -1LL;
        v21 = v16 - v19;
        *a7 = 0uLL;
        a7[1] = 0uLL;
        *((_QWORD *)a7 + v18) = v20;
        if ( v21 )
        {
          v22 = (__int64 *)a7 + v18 + 1;
          do
          {
            if ( v21 >= 0x40 )
              v23 = 64LL;
            else
              v23 = v21;
            if ( v23 <= 0x3F )
              v24 = ~(-1LL << v23);
            else
              v24 = -1LL;
            v21 -= v23;
            *v22++ = v24;
          }
          while ( v21 );
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67879F8 (0x67879F8)
================================================================================

__int64 __fastcall sub_67879F8(__int64 a1, __int64 a2, unsigned int a3, _QWORD *a4, __int64 a5, _QWORD *a6)
{
  unsigned __int64 v10; // x0
  unsigned __int64 v11; // x8
  __int64 v12; // x8
  unsigned __int64 v13; // x20
  unsigned __int64 v14; // x24
  unsigned __int64 v15; // x28
  unsigned __int64 v16; // x21
  unsigned int v17; // w26
  bool v18; // w0
  bool v19; // w21
  unsigned __int64 v20; // x27
  __int64 v21; // x24
  unsigned __int64 v22; // x0
  unsigned __int64 v23; // x8
  __int64 v24; // x8
  unsigned __int64 v25; // x8
  unsigned __int64 v26; // x24
  __int64 v27; // x0
  __int64 v28; // x21
  unsigned __int64 v29; // x23
  __int128 v30; // q0
  __int128 v31; // q0
  unsigned __int64 v32; // x9
  __int64 v33; // x10
  unsigned __int64 v34; // x9
  __int64 *v35; // x10
  unsigned __int64 v36; // x12
  __int64 v37; // x13
  __int64 v38; // x5
  __int64 v39; // x6
  __int64 v40; // x7
  __int128 v41; // q0
  int v42; // w8
  bool v43; // w8
  __int128 v44; // q0
  __int128 v45; // q1
  __int128 v46; // q2
  __int128 v47; // q3
  unsigned __int64 v48; // x0
  __int64 v49; // x20
  unsigned __int64 v50; // x9
  unsigned __int64 v51; // x8
  unsigned __int64 v52; // x9
  unsigned __int64 v53; // x8
  _BOOL4 v54; // w20
  __int64 v55; // x22
  __int64 v56; // x8
  signed __int64 v57; // x1
  int v58; // w8
  __int64 v59; // x9
  unsigned __int64 v60; // x10
  unsigned __int64 v61; // x8
  unsigned __int64 v62; // x10
  __int64 v63; // x4
  unsigned __int64 *v64; // x9
  unsigned __int64 v65; // x11
  unsigned __int64 v66; // x10
  _DWORD *v67; // x11
  unsigned __int64 v68; // x10
  unsigned __int64 v69; // x8
  unsigned __int64 v70; // x11
  unsigned __int64 *v71; // x8
  unsigned __int64 *v72; // x9
  __int128 v76; // [xsp+10h] [xbp-80h] BYREF
  __int64 v77; // [xsp+20h] [xbp-70h]
  __int128 v78; // [xsp+28h] [xbp-68h] BYREF
  __int64 v79; // [xsp+38h] [xbp-58h]
  _OWORD v80[4]; // [xsp+40h] [xbp-50h] BYREF

  v10 = sub_6781F08();
  v11 = v10 + 41303;
  if ( (v10 & (v10 - 1)) != 0 )
    v12 = v11 / v10 * v10;
  else
    v12 = v11 & -(__int64)v10;
  v13 = v12 + 0xFFFF;
  v14 = (v12 + 0xFFFF) & 0xFFFFFFFFFFFF0000LL;
  if ( a1 )
    v15 = (a1 + v14 + 0xFFFF) >> 16;
  else
    v15 = 512LL;
  if ( (unsigned __int64)sub_678000C() < 2 || (v16 = a4[108], v16 >= sub_6780DEC(0xEu)) )
  {
    v18 = sub_67814F4(3u);
    v17 = 1;
  }
  else
  {
    v17 = 0;
    v18 = 0;
  }
  v19 = a1 != 0 || v18;
  if ( a2 )
  {
    v20 = (v14 + 0x1FFFFFF) & 0xFFFFFFFFFE000000LL;
    v21 = v20 - v14 + a1;
    v22 = sub_6781F08();
    v23 = v22 + 41303;
    if ( (v22 & (v22 - 1)) != 0 )
      v24 = v23 / v22 * v22;
    else
      v24 = v23 & -(__int64)v22;
    v13 = v24 + 0xFFFF;
    v25 = (v21 + ((v24 + 0xFFFF) & 0xFFFFFFFFFFFF0000LL) + 0xFFFF) >> 16;
    if ( v21 )
      v15 = v25;
    else
      v15 = 512LL;
  }
  else
  {
    v20 = 0LL;
    a2 = 0x2000000LL;
  }
  v26 = v15 << 16;
  v27 = sub_677E0F0(v15 << 16, a2, v20, v19, v17, a3, &v78, a5);
  v28 = v27;
  if ( v27 )
  {
    v29 = v13 >> 16;
    if ( BYTE1(v79) )
    {
      *(_QWORD *)&v30 = -1LL;
      *((_QWORD *)&v30 + 1) = -1LL;
      v80[2] = v30;
      v80[3] = v30;
      v80[0] = v30;
      v80[1] = v30;
    }
    else
    {
      if ( v29 )
      {
        if ( v29 == 512 )
        {
          *(_QWORD *)&v31 = -1LL;
          *((_QWORD *)&v31 + 1) = -1LL;
          v80[2] = v31;
          v80[3] = v31;
          v80[0] = v31;
          v80[1] = v31;
        }
        else
        {
          if ( v29 >= 0x40 )
            v32 = 64LL;
          else
            v32 = v13 >> 16;
          *((_QWORD *)&v80[3] + 1) = 0LL;
          if ( v32 <= 0x3F )
            v33 = ~(-1LL << v32);
          else
            v33 = -1LL;
          v34 = v29 - v32;
          *(_OWORD *)((char *)&v80[2] + 8) = 0uLL;
          *(_OWORD *)((char *)&v80[1] + 8) = 0uLL;
          *(_OWORD *)((char *)v80 + 8) = 0uLL;
          *(_QWORD *)&v80[0] = v33;
          if ( v34 )
          {
            v35 = (__int64 *)v80 + 1;
            do
            {
              if ( v34 >= 0x40 )
                v36 = 64LL;
              else
                v36 = v34;
              if ( v36 <= 0x3F )
                v37 = ~(-1LL << v36);
              else
                v37 = -1LL;
              v34 -= v36;
              *v35++ = v37;
            }
            while ( v34 );
          }
        }
      }
      else
      {
        memset(v80, 0, sizeof(v80));
      }
      if ( (sub_6782B4C(v27, v13 & 0xFFFFFFFFFFFF0000LL, 0LL, a4[112]) & 1) == 0 )
      {
        v63 = a4[112];
        v76 = v78;
        v77 = v79;
        sub_677E570(v28, v15 << 16, 0LL, (__int64 *)&v76, v63, v38, v39, v40, (__int64)a6);
        return 0LL;
      }
    }
    v41 = v78;
    *(_QWORD *)(v28 + 16) = v79;
    *(_OWORD *)v28 = v41;
    v42 = (unsigned __int8)v79;
    *(_BYTE *)(v28 + 24) = v79 ^ 1;
    if ( v42 )
      v43 = 0;
    else
      v43 = sub_6780DEC(0xFu) >= 0;
    v44 = v80[0];
    v45 = v80[1];
    *(_BYTE *)(v28 + 25) = v43;
    *(_QWORD *)(v28 + 32) = v26;
    *(_QWORD *)(v28 + 104) = 0LL;
    v46 = v80[2];
    v47 = v80[3];
    *(_OWORD *)(v28 + 112) = v44;
    *(_OWORD *)(v28 + 128) = v45;
    *(_OWORD *)(v28 + 144) = v46;
    *(_OWORD *)(v28 + 160) = v47;
    *(_OWORD *)(v28 + 40) = 0u;
    *(_OWORD *)(v28 + 56) = 0u;
    *(_OWORD *)(v28 + 72) = 0u;
    *(_OWORD *)(v28 + 88) = 0u;
    atomic_store(0LL, (unsigned __int64 *)(v28 + 176));
    v48 = a4[112];
    if ( (v26 & 0x8000000000000000LL) != 0 )
    {
      sub_67886E8(v48, 1uLL);
      v49 = -1LL;
    }
    else
    {
      v49 = 1LL;
      sub_6788604(v48, 1LL);
    }
    v50 = a4[109];
    v51 = a4[108] + v49;
    a4[108] = v51;
    if ( v51 > v50 )
      a4[109] = v51;
    v52 = a4[111];
    v53 = a4[110] + v26;
    a4[110] = v53;
    if ( v53 > v52 )
      a4[111] = v53;
    sub_67883D4(v28);
    if ( !*(_BYTE *)(v28 + 18) )
      memset((void *)(v28 + 184), 0, 80 * v15 + 160);
    v54 = a1 != 0;
    if ( v15 >= 0x200 )
      v55 = 512LL;
    else
      v55 = v15;
    *(_QWORD *)(v28 + 224) = v15;
    *(_QWORD *)(v28 + 232) = v29;
    atomic_store(sub_677FEA8(), (unsigned __int64 *)(v28 + 256));
    v56 = qword_6C36378;
    *(_QWORD *)(v28 + 248) = v55;
    *(_DWORD *)(v28 + 240) = v54;
    v57 = *(_QWORD *)(v28 + 232) << 16;
    *(_QWORD *)(v28 + 216) = v56 ^ v28;
    sub_6788604(a4[112] + 192LL, v57);
    if ( sub_6787F30(v28, 0LL, v29, a4) )
    {
      v58 = *(_DWORD *)(v28 + 240);
      *(_QWORD *)(v28 + 208) = 0LL;
      if ( v58 )
      {
        *a6 = sub_6787F30(v28, v29, v15 - v29, a4);
      }
      else
      {
        v59 = *(_QWORD *)(v28 + 248);
        v60 = atomic_load((unsigned __int64 *)(v28 + 256));
        v61 = v59 - v29;
        if ( v60 )
        {
          if ( v61 >= 2 )
          {
            v65 = __clz(v61 - 1);
            v62 = v59 - v29;
            if ( 63 - v65 >= 3 )
              v62 = (((v61 - 1) >> (61 - (unsigned __int8)v65)) & 3 | (4 * (63 - v65))) - 4;
          }
          else
          {
            v62 = v59 - v29;
          }
          v64 = &a4[3 * v62];
        }
        else
        {
          v64 = 0LL;
        }
        if ( !v61 )
          v61 = 1LL;
        v66 = v28 + 80 * v29;
        *(_DWORD *)(v66 + 264) = v61;
        *(_DWORD *)(v66 + 268) = 0;
        if ( v61 >= 2 )
        {
          v67 = (_DWORD *)(v28 + 80 * (v29 + v61));
          v67[46] = 0;
          v67[47] = 80 * v61 - 80;
          v67[53] = 0;
        }
        if ( v64 )
        {
          v68 = v66 + 264;
          v69 = v28 + 80 * v29;
          *(_QWORD *)(v69 + 328) = 0LL;
          v70 = *v64;
          *(_QWORD *)(v69 + 320) = *v64;
          v71 = (unsigned __int64 *)(v70 + 64);
          *v64 = v68;
          v72 = v64 + 1;
          if ( !v70 )
            v71 = v72;
          *v71 = v68;
        }
        *(_DWORD *)(v28 + 80 * v29 + 292) = 0;
      }
    }
    else
    {
      return 0LL;
    }
  }
  return v28;
}


================================================================================
Function: sub_6787F30 (0x6787F30)
================================================================================

_DWORD *__fastcall sub_6787F30(signed __int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v7; // x22
  __int64 v8; // x25
  bool v9; // w8
  unsigned __int64 v10; // x27
  __int64 v11; // x26
  __int64 v12; // x28
  unsigned __int64 v13; // x24
  int64x2_t v14; // q0
  int64x2_t v15; // q1
  unsigned __int64 v16; // d2
  unsigned __int64 v17; // d2
  __int64 v18; // x8
  __int64 v19; // x9
  int8x16_t v20; // q2
  __int64 v21; // x23
  unsigned __int64 v22; // x0
  int8x16_t v23; // q3
  __int64 v24; // x8
  int8x16_t v25; // q1
  __int64 v26; // x9
  int8x16_t v27; // q2
  __int64 v28; // x8
  __int64 v29; // x9
  __int64 v30; // x10
  __int64 v31; // x11
  __int64 v32; // x12
  __int64 v33; // x13
  __int64 v34; // x14
  __int64 v35; // x15
  __int64 v36; // x23
  __int64 v37; // x0
  unsigned __int64 v38; // x11
  unsigned int v39; // w12
  unsigned __int64 v40; // x8
  _DWORD *v41; // x10
  _DWORD *result; // x0
  unsigned __int64 v43; // x9
  __int64 v44; // x13
  unsigned __int64 v45; // x12
  _DWORD *v46; // x14
  _DWORD *v47; // x8
  signed __int64 v48; // x8
  char v49; // w9
  int8x16_t v50; // [xsp+0h] [xbp-110h]
  int8x16_t v51; // [xsp+10h] [xbp-100h]
  __int64 v52; // [xsp+20h] [xbp-F0h]
  int8x16_t v53; // [xsp+20h] [xbp-F0h]
  unsigned __int64 v54; // [xsp+38h] [xbp-D8h]
  unsigned __int64 v55; // [xsp+40h] [xbp-D0h]
  unsigned __int64 v56; // [xsp+48h] [xbp-C8h]
  __int64 v57; // [xsp+50h] [xbp-C0h]
  _BYTE v58[4]; // [xsp+5Ch] [xbp-B4h] BYREF
  unsigned __int64 v59; // [xsp+60h] [xbp-B0h] BYREF
  __int64 v60; // [xsp+68h] [xbp-A8h] BYREF
  _OWORD v61[3]; // [xsp+70h] [xbp-A0h] BYREF
  __int64 v62; // [xsp+A0h] [xbp-70h]
  __int64 v63; // [xsp+A8h] [xbp-68h]
  int8x16_t v64; // [xsp+B0h] [xbp-60h] BYREF
  int8x16_t v65; // [xsp+C0h] [xbp-50h]
  _BYTE v66[24]; // [xsp+D0h] [xbp-40h]
  __int64 v67; // [xsp+E8h] [xbp-28h]

  v7 = a3 << 16;
  v8 = *(_QWORD *)(a4 + 896);
  if ( *(_QWORD *)(a1 + 112) != -1LL
    || *(_QWORD *)(a1 + 120) != -1LL
    || *(_QWORD *)(a1 + 128) != -1LL
    || *(_QWORD *)(a1 + 136) != -1LL
    || *(_QWORD *)(a1 + 144) != -1LL
    || *(_QWORD *)(a1 + 152) != -1LL
    || *(_QWORD *)(a1 + 160) != -1LL
    || *(_QWORD *)(a1 + 168) != -1LL
    || *(_QWORD *)(a1 + 48)
    || *(_QWORD *)(a1 + 56)
    || *(_QWORD *)(a1 + 64)
    || *(_QWORD *)(a1 + 72)
    || *(_QWORD *)(a1 + 80)
    || *(_QWORD *)(a1 + 88)
    || *(_QWORD *)(a1 + 96)
    || *(_QWORD *)(a1 + 104) )
  {
    v59 = 0LL;
    v60 = 0LL;
    sub_6787864(a1, 0, (char *)(a1 + (a2 << 16)), v7, &v60, &v59, &v64);
    v9 = 0;
    v10 = v64.n128_u64[0];
    v11 = *(_QWORD *)&v66[16];
    v12 = *(_QWORD *)v66;
    if ( *(_OWORD *)&v64 == 0LL
      && *(_OWORD *)&v65 == 0LL
      && !*(_QWORD *)v66
      && __PAIR128__(*(unsigned __int64 *)&v66[8], 0LL) == *(unsigned __int64 *)&v66[16] )
    {
      v9 = v67 == 0;
    }
    if ( !v9 )
    {
      v13 = v59;
      if ( v59 )
      {
        v55 = v65.n128_u64[0];
        v56 = v64.n128_u64[1];
        v54 = v65.n128_u64[1];
        v57 = *(_QWORD *)&v66[8];
        v14 = vandq_s8(*(int8x16_t *)(a1 + 112), v64);
        v15 = vandq_s8(*(int8x16_t *)(a1 + 128), v65);
        v16 = vmovn_s64(vceqq_s64(v14, v64)).n64_u64[0];
        if ( (v16 & 1) == 0
          || (v16 & 0x100000000LL) == 0
          || (v17 = vmovn_s64(vceqq_s64(v15, v65)).n64_u64[0], (v17 & 1) == 0)
          || (v17 & 0x100000000LL) == 0
          || (*(_QWORD *)v66 & ~*(_QWORD *)(a1 + 144)) != 0LL
          || (*(_OWORD *)&v66[8] & ~*(_OWORD *)(a1 + 152)) != 0LL
          || (v52 = v67, (v67 & ~*(_QWORD *)(a1 + 168)) != 0) )
        {
          v18 = *(_QWORD *)(a1 + 160);
          v19 = *(_QWORD *)(a1 + 168);
          v20 = *(int8x16_t *)(a1 + 144);
          v51 = v64;
          v53 = v65;
          v21 = v67;
          v58[0] = 0;
          v61[0] = v14;
          v61[1] = v15;
          v50 = *(int8x16_t *)v66;
          v61[2] = vandq_s8(v20, *(int8x16_t *)v66);
          v62 = v18 & *(_QWORD *)&v66[16];
          v63 = v67 & v19;
          v22 = sub_6785700((unsigned __int64 *)v61, 0x2000000uLL);
          sub_67886E8((unsigned __int64)&unk_7289F60, v22);
          if ( (sub_6782B4C(v60, v13, v58, v8) & 1) == 0 )
            return 0LL;
          v23 = v53;
          v52 = v21;
          v24 = *(_QWORD *)(a1 + 160) | v11;
          v25 = vorrq_s8(*(int8x16_t *)(a1 + 128), v23);
          v26 = *(_QWORD *)(a1 + 168) | v21;
          v27 = vorrq_s8(*(int8x16_t *)(a1 + 144), v50);
          *(int8x16_t *)(a1 + 112) = vorrq_s8(*(int8x16_t *)(a1 + 112), v51);
          *(int8x16_t *)(a1 + 128) = v25;
          *(_QWORD *)(a1 + 160) = v24;
          *(_QWORD *)(a1 + 168) = v26;
          *(int8x16_t *)(a1 + 144) = v27;
        }
        v28 = *(_QWORD *)(a1 + 48);
        if ( (v28 & v10) != 0
          || (v29 = *(_QWORD *)(a1 + 56), (v29 & v56) != 0)
          || (v30 = *(_QWORD *)(a1 + 64), (v30 & v55) != 0)
          || (v31 = *(_QWORD *)(a1 + 72), (v31 & v54) != 0)
          || (v32 = *(_QWORD *)(a1 + 80), (v32 & v12) != 0)
          || (v33 = *(_QWORD *)(a1 + 88), (v33 & v57) != 0)
          || (v34 = *(_QWORD *)(a1 + 96), (v34 & v11) != 0)
          || (v35 = *(_QWORD *)(a1 + 104), (v35 & v52) != 0) )
        {
          v36 = sub_6789348();
          v37 = sub_6780DEC(0xFu);
          v28 = *(_QWORD *)(a1 + 48);
          v29 = *(_QWORD *)(a1 + 56);
          v30 = *(_QWORD *)(a1 + 64);
          v31 = *(_QWORD *)(a1 + 72);
          v32 = *(_QWORD *)(a1 + 80);
          v33 = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 40) = v37 + v36;
          v34 = *(_QWORD *)(a1 + 96);
          v35 = *(_QWORD *)(a1 + 104);
        }
        *(_QWORD *)(a1 + 48) = v28 & ~v10;
        *(_QWORD *)(a1 + 56) = v29 & ~v56;
        *(_QWORD *)(a1 + 64) = v30 & ~v55;
        *(_QWORD *)(a1 + 72) = v31 & ~v54;
        *(_QWORD *)(a1 + 80) = v32 & ~v12;
        *(_QWORD *)(a1 + 88) = v33 & ~v57;
        *(_QWORD *)(a1 + 96) = v34 & ~v11;
        *(_QWORD *)(a1 + 104) = v35 & ~v52;
      }
    }
  }
  v38 = a3 - 1;
  if ( v7 >> 31 )
    v39 = 0x80000000;
  else
    v39 = v7;
  v40 = *(_QWORD *)(a1 + 248);
  if ( v38 >= 0xFF )
    v38 = 255LL;
  v41 = (_DWORD *)(a1 + 80 * a2);
  result = v41 + 66;
  v43 = v40 + ~a2;
  if ( v38 + a2 < v40 )
    v43 = v38;
  *result = a3;
  v41[67] = 0;
  v41[73] = v39;
  if ( v43 )
  {
    v44 = 0LL;
    v45 = 1LL;
    do
    {
      v46 = (_DWORD *)(a1 + 80 * a2 + v44);
      v44 += 80LL;
      ++v45;
      v46[87] = v44;
      v46[86] = 0;
      v46[93] = 1;
    }
    while ( v45 <= v43 );
  }
  v47 = (_DWORD *)(a1 + 80 * v40 + 264);
  if ( &result[20 * a3 - 20] <= v47 )
    v47 = &result[20 * a3 - 20];
  if ( v47 > result )
  {
    *v47 = 0;
    v47[1] = (_DWORD)v47 - (_DWORD)result;
    v47[7] = 1;
  }
  v48 = a1 + 80 * a2;
  v49 = *(_BYTE *)(v48 + 272);
  ++*(_QWORD *)(a1 + 208);
  *(_BYTE *)(v48 + 272) = v49 | 1;
  return result;
}


================================================================================
Function: sub_67883D4 (0x67883D4)
================================================================================

unsigned __int64 __fastcall sub_67883D4(unsigned __int64 result)
{
  unsigned __int64 v1; // x20
  unsigned __int64 v2; // x19
  __int64 v3; // x22
  bool v4; // zf

  if ( result >> 43 <= 4 )
  {
    v1 = result >> 31;
    if ( result >> 31 != 20480 )
    {
      v2 = qword_7292408[v1];
      v3 = 1LL << (result >> 25);
      do
      {
        result = sub_67EFFD0(v2, v2 | v3, (atomic_ullong *)&qword_7292408[v1]);
        v4 = result == v2;
        v2 = result;
      }
      while ( !v4 );
    }
  }
  return result;
}


================================================================================
Function: sub_6788440 (0x6788440)
================================================================================

unsigned __int64 __fastcall sub_6788440(unsigned __int64 result)
{
  unsigned __int64 v1; // x20
  unsigned __int64 v2; // x19
  __int64 v3; // x22
  bool v4; // zf

  if ( result >> 43 <= 4 )
  {
    v1 = result >> 31;
    if ( result >> 31 != 20480 )
    {
      v2 = qword_7292408[v1];
      v3 = ~(1LL << (result >> 25));
      do
      {
        result = sub_67EFFD0(v2, v2 & v3, (atomic_ullong *)&qword_7292408[v1]);
        v4 = result == v2;
        v2 = result;
      }
      while ( !v4 );
    }
  }
  return result;
}


================================================================================
Function: sub_6788598 (0x6788598)
================================================================================

unsigned __int64 __fastcall sub_6788598(unsigned __int64 result, unsigned __int64 a2)
{
  atomic_ullong *v2; // x19
  int64x2_t v5; // q0

  v2 = (atomic_ullong *)result;
  if ( result < (unsigned __int64)&unk_7289F00 || result >= (unsigned __int64)qword_728A180 )
  {
    v5 = vdupq_n_s64(1uLL);
    v5.n128_u64[0] = a2;
    *(int64x2_t *)result = vaddq_s64(*(int64x2_t *)result, v5);
  }
  else
  {
    sub_67F0410(1uLL, (atomic_ullong *)(result + 8));
    return sub_67F0410(a2, v2);
  }
  return result;
}


================================================================================
Function: sub_6788604 (0x6788604)
================================================================================

unsigned __int64 __fastcall sub_6788604(unsigned __int64 result, signed __int64 a2)
{
  unsigned __int64 v3; // x19
  unsigned __int64 v4; // x0
  signed __int64 v5; // x22
  signed __int64 v6; // x21
  unsigned __int64 v7; // x0
  bool v8; // zf
  signed __int64 v9; // x9
  signed __int64 v10; // x8

  if ( a2 )
  {
    v3 = result;
    if ( result < (unsigned __int64)&unk_7289F00 || result >= (unsigned __int64)&qword_728A180 )
    {
      v9 = *(_QWORD *)(result + 16);
      v10 = *(_QWORD *)(result + 24) + a2;
      *(_QWORD *)(result + 24) = v10;
      if ( v10 > v9 )
        *(_QWORD *)(result + 16) = v10;
      if ( a2 < 1 )
        *(_QWORD *)(result + 8) -= a2;
      else
        *(_QWORD *)result += a2;
    }
    else
    {
      v4 = sub_67F0410(a2, (atomic_ullong *)(result + 24));
      v5 = *(_QWORD *)(v3 + 16);
      v6 = v4 + a2;
      do
      {
        if ( v5 >= v6 )
          break;
        v7 = sub_67EFFD0(v5, v6, (atomic_ullong *)(v3 + 16));
        v8 = v7 == v5;
        v5 = v7;
      }
      while ( !v8 );
      if ( a2 < 1 )
        return sub_67F0410(-a2, (atomic_ullong *)(v3 + 8));
      else
        return sub_67F0410(a2, (atomic_ullong *)v3);
    }
  }
  return result;
}


================================================================================
Function: sub_67886E8 (0x67886E8)
================================================================================

unsigned __int64 __fastcall sub_67886E8(unsigned __int64 result, unsigned __int64 a2)
{
  unsigned __int64 v3; // x19
  unsigned __int64 v4; // x0
  signed __int64 v5; // x23
  signed __int64 v6; // x22
  unsigned __int64 v7; // x0
  bool v8; // zf
  signed __int64 v9; // x9
  signed __int64 v10; // x8

  if ( a2 )
  {
    v3 = result;
    if ( result < (unsigned __int64)&unk_7289F00 || result >= (unsigned __int64)&qword_728A180 )
    {
      v9 = *(_QWORD *)(result + 16);
      v10 = *(_QWORD *)(result + 24) - a2;
      *(_QWORD *)(result + 24) = v10;
      if ( v10 > v9 )
        *(_QWORD *)(result + 16) = v10;
      if ( (a2 & 0x8000000000000000LL) != 0 )
        *(_QWORD *)result -= a2;
      else
        *(_QWORD *)(result + 8) += a2;
    }
    else
    {
      v4 = sub_67F0410(-(__int64)a2, (atomic_ullong *)(result + 24));
      v5 = *(_QWORD *)(v3 + 16);
      v6 = v4 - a2;
      do
      {
        if ( v5 >= v6 )
          break;
        v7 = sub_67EFFD0(v5, v6, (atomic_ullong *)(v3 + 16));
        v8 = v7 == v5;
        v5 = v7;
      }
      while ( !v8 );
      if ( (a2 & 0x8000000000000000LL) != 0 )
        return sub_67F0410(-(__int64)a2, (atomic_ullong *)v3);
      else
        return sub_67F0410(a2, (atomic_ullong *)(v3 + 8));
    }
  }
  return result;
}


================================================================================
Function: sub_67887D0 (0x67887D0)
================================================================================

__int64 sub_67887D0()
{
  void *v0; // x0
  __int64 result; // x0
  __int64 v2; // x19

  v0 = (void *)(*(_QWORD *)sub_677DC88() + 960LL);
  if ( v0 != &unk_7289F00 )
    memset(v0, 0, 0x280uLL);
  result = (__int64)memset(&unk_7289F00, 0, 0x280uLL);
  if ( !qword_72BA410 )
  {
    if ( !qword_72BA418 )
    {
      v2 = sub_6789FE4();
      qword_72BA418 = sub_6789FE4() - v2;
    }
    result = sub_6789FE4();
    qword_72BA410 = result;
  }
  return result;
}


================================================================================
Function: sub_6788860 (0x6788860)
================================================================================

__int64 sub_6788860()
{
  __int64 v0; // x19

  if ( !qword_72BA418 )
  {
    v0 = sub_6789FE4();
    qword_72BA418 = sub_6789FE4() - v0;
  }
  return sub_6789FE4();
}


================================================================================
Function: sub_6789348 (0x6789348)
================================================================================

// attributes: thunk
__int64 sub_6789348()
{
  return sub_6789FE4();
}


================================================================================
Function: sub_678934C (0x678934C)
================================================================================

__int64 __fastcall sub_678934C(__int64 a1)
{
  return sub_6789FE4() - (qword_72BA418 + a1);
}


================================================================================
Function: sub_6789974 (0x6789974)
================================================================================

__int64 __fastcall sub_6789974(__int64 a1)
{
  __int64 v2; // x0
  __int64 result; // x0
  int v4; // w20
  bool v5; // w22
  char v6; // w8
  _BYTE buf[32]; // [xsp+8h] [xbp-28h] BYREF

  v2 = sysconf(39);
  if ( v2 >= 1 )
  {
    *(_QWORD *)a1 = v2;
    *(_QWORD *)(a1 + 16) = v2;
  }
  *(_QWORD *)(a1 + 8) = 0x200000LL;
  result = __open_2("/proc/sys/vm/overcommit_memory", 0LL);
  if ( (result & 0x80000000) != 0 )
  {
    v6 = 1;
  }
  else
  {
    v4 = result;
    v5 = read(result, buf, 0x20uLL) < 1;
    result = close(v4);
    v6 = v5 || (buf[0] & 0xFE) == 48;
  }
  *(_BYTE *)(a1 + 24) = v6;
  *(_WORD *)(a1 + 25) = 256;
  return result;
}


================================================================================
Function: sub_6789A40 (0x6789A40)
================================================================================

__int64 __fastcall sub_6789A40(void *a1, size_t a2)
{
  __int64 v2; // x0

  v2 = munmap(a1, a2);
  if ( (_DWORD)v2 == -1 )
    return *(unsigned int *)__errno(v2);
  else
    return 0LL;
}


================================================================================
Function: sub_6789A70 (0x6789A70)
================================================================================

__int64 __fastcall sub_6789A70(__int64 a1, __int64 a2, char a3, unsigned int a4, __int64 a5, _BYTE *a6, __int64 *a7)
{
  __int64 v9; // x3
  __int64 v10; // x8
  __int64 result; // x0

  if ( (a3 & 1) != 0 )
    v9 = 3LL;
  else
    v9 = 0LL;
  *a6 = 1;
  v10 = sub_6789ADC(0LL, a1, a2, v9, 0LL, a4, a5);
  result = 0LL;
  *a7 = v10;
  if ( !v10 )
    return *(unsigned int *)__errno(0LL);
  return result;
}


================================================================================
Function: sub_6789ADC (0x6789ADC)
================================================================================

void *__fastcall sub_6789ADC(void *a1, size_t a2, __int64 a3, int a4, int a5, char a6, _BYTE *a7)
{
  int v14; // w25
  unsigned __int64 v15; // x0
  int v16; // w4
  void *v17; // x27
  _DWORD *v18; // x0

  if ( (sub_6781EF0() & 1) != 0 )
    v14 = 16418;
  else
    v14 = 34;
  if ( (a5 & 1) != 0 )
  {
    if ( (a6 & 1) != 0 )
    {
      atomic_load(&qword_72BA420);
      goto LABEL_11;
    }
LABEL_20:
    *a7 = 0;
    v17 = (void *)sub_678A228(a1, a2, a3, a4, v14);
    if ( v17 && (a6 & 1) != 0 && (sub_6781F14(a2, a3) & 1) != 0 && !madvise(v17, a2, 14) )
      *a7 = 1;
    return v17;
  }
  if ( (sub_6781F14(a2, a3) & 1) == 0 || (a6 & 1) == 0 )
    goto LABEL_20;
  v15 = atomic_load(&qword_72BA420);
  if ( v15 )
  {
    sub_67F0010(v15, v15 - 1, (atomic_ullong *)&qword_72BA420);
    goto LABEL_20;
  }
LABEL_11:
  if ( (a2 & 0x3FFFFFFF) != 0 || byte_72BA428 == 1 )
    v16 = 1409548322;
  else
    v16 = 2013528098;
  *a7 = 1;
  v17 = (void *)sub_678A228(a1, a2, a3, a4, v16);
  if ( !v17 )
  {
    byte_72BA428 = 1;
    v18 = (_DWORD *)__errno(0LL);
    sub_6781928(
      (signed __int64)"unable to allocate huge (1GiB) page, trying large (2MiB) pages instead (errno: %i)\n",
      *v18);
    v17 = (void *)sub_678A228(a1, a2, a3, a4, 1409548322);
    if ( ((a5 ^ 1) & (v17 == 0LL)) == 1 )
    {
      v17 = 0LL;
      atomic_store(8uLL, &qword_72BA420);
    }
    if ( (a5 & 1) == 0 && !v17 )
      goto LABEL_20;
  }
  return v17;
}


================================================================================
Function: sub_6789CBC (0x6789CBC)
================================================================================

__int64 __fastcall sub_6789CBC(void *a1, size_t a2, _BYTE *a3)
{
  __int64 result; // x0

  *a3 = 0;
  result = mprotect(a1, a2, 3);
  if ( (_DWORD)result )
    return *(unsigned int *)__errno(result);
  return result;
}


================================================================================
Function: sub_6789CE4 (0x6789CE4)
================================================================================

__int64 __fastcall sub_6789CE4(void *a1, size_t a2, _BYTE *a3)
{
  __int64 result; // x0

  result = madvise(a1, a2, 4);
  *a3 = 0;
  return result;
}


================================================================================
Function: sub_6789D0C (0x6789D0C)
================================================================================

__int64 __fastcall sub_6789D0C(void *a1, size_t a2)
{
  int v4; // w21
  unsigned int v5; // w22
  int *v6; // x0
  int v7; // w8
  int *v8; // x23

  v4 = qword_6C367D8;
  v5 = madvise(a1, a2, qword_6C367D8);
  if ( v5 )
  {
    v6 = (int *)__errno();
    v7 = *v6;
    if ( *v6 == 11 )
    {
      v8 = v6;
      while ( 1 )
      {
        *v8 = 0;
        v5 = madvise(a1, a2, v4);
        if ( !v5 )
          break;
        v7 = *v8;
        if ( *v8 != 11 )
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      if ( v7 == 22 && v4 == 8 )
      {
        atomic_store(4uLL, (unsigned __int64 *)&qword_6C367D8);
        return madvise(a1, a2, 4);
      }
    }
  }
  return v5;
}


================================================================================
Function: sub_6789DD4 (0x6789DD4)
================================================================================

__int64 __fastcall sub_6789DD4(void *a1, size_t a2, __int64 a3, _BYTE *a4, _QWORD *a5)
{
  int v8; // w4
  void *v9; // x0
  void *v10; // x8
  __int64 result; // x0
  _DWORD *v12; // x0
  void *v13; // x0

  *a4 = 1;
  sub_6781EF0();
  atomic_load(&qword_72BA420);
  if ( (a2 & 0x3FFFFFFF) != 0 || byte_72BA428 == 1 )
    v8 = 1409548322;
  else
    v8 = 2013528098;
  v9 = sub_678A228(a1, a2, 0x2000000uLL, 3, v8);
  if ( v9 )
  {
    v10 = v9;
    result = 0LL;
    *a5 = v10;
  }
  else
  {
    byte_72BA428 = 1;
    v12 = (_DWORD *)__errno(0LL);
    sub_6781928(
      (signed __int64)"unable to allocate huge (1GiB) page, trying large (2MiB) pages instead (errno: %i)\n",
      *v12);
    v13 = sub_678A228(a1, a2, 0x2000000uLL, 3, 1409548322);
    *a5 = v13;
    if ( v13 )
      return 0LL;
    else
      return *(unsigned int *)__errno(0LL);
  }
  return result;
}


================================================================================
Function: sub_6789EC0 (0x6789EC0)
================================================================================

__int64 sub_6789EC0()
{
  return 0LL;
}


================================================================================
Function: sub_6789EC8 (0x6789EC8)
================================================================================

__int64 __fastcall sub_6789EC8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x8
  __int64 v5; // x19
  int v6; // w0
  char name[128]; // [xsp+8h] [xbp-88h] BYREF

  v4 = 1LL;
  do
  {
    v5 = v4;
    if ( (_DWORD)v4 == 257 )
      break;
    sub_6789F40(name, a2, a3, a4, (unsigned int)v4);
    v6 = access(name, 4);
    v4 = v5 + 1;
  }
  while ( !v6 );
  return v5;
}


================================================================================
Function: sub_6789F40 (0x6789F40)
================================================================================

__int64 sub_6789F40(char *a1, __int64 a2, __int64 a3, __int64 a4, ...)
{
  gcc_va_list arg; // [xsp+A0h] [xbp-50h] BYREF
  gcc_va_list va; // [xsp+C8h] [xbp-28h] BYREF

  va_start(va, a4);
  va_copy(arg, va);
  return vsnprintf(a1, 0x7FuLL, "/sys/devices/system/node/node%u", arg);
}


================================================================================
Function: sub_6789FE4 (0x6789FE4)
================================================================================

__int64 sub_6789FE4()
{
  __int64 v1; // [xsp+8h] [xbp-18h] BYREF
  __int64 v2; // [xsp+10h] [xbp-10h]

  clock_gettime(1, (struct timespec *)&v1);
  return v2 / 1000000 + 1000 * v1;
}


================================================================================
Function: sub_678A114 (0x678A114)
================================================================================

__int64 __fastcall sub_678A114(__int64 result, __int64 a2, __int64 a3)
{
  __int64 v4; // x21
  char **v6; // x24
  __int64 v7; // x22
  __int64 i; // x25
  char *v9; // x23

  if ( result )
  {
    v4 = result;
    result = sub_6781C74();
    if ( result )
    {
      v6 = environ;
      if ( environ )
      {
        v7 = result;
        for ( i = 10000LL; i; --i )
        {
          v9 = *v6;
          if ( !*v6 )
            break;
          if ( !(unsigned int)sub_6781BBC(v4, *v6, v7) && v9[v7] == 61 )
          {
            sub_6781C34(a2, &v9[v7 + 1], a3);
            return 1LL;
          }
          ++v6;
        }
      }
      return 0LL;
    }
  }
  return result;
}


================================================================================
Function: sub_678A1CC (0x678A1CC)
================================================================================

__int64 __fastcall sub_678A1CC(void *a1, size_t a2)
{
  arc4random_buf(a1, a2);
  return 1LL;
}


================================================================================
Function: sub_678A1E4 (0x678A1E4)
================================================================================

__int64 sub_678A1E4()
{
  return pthread_key_create((pthread_key_t *)&dword_6C367E0, (void (*)(void *))sub_678A1F8);
}


================================================================================
Function: sub_678A208 (0x678A208)
================================================================================

const void *__fastcall sub_678A208(const void *pointer)
{
  if ( dword_6C367E0 != -1 )
    return (const void *)pthread_setspecific(dword_6C367E0, pointer);
  return pointer;
}


================================================================================
Function: sub_678A228 (0x678A228)
================================================================================

void *__fastcall sub_678A228(void *addr, size_t len, unsigned __int64 a3, int prot, int flags)
{
  void *v9; // x0
  unsigned __int64 v10; // x25
  void *v13; // x0
  const void *v14; // x24
  unsigned __int64 v15; // x0
  _DWORD *v16; // x0
  _DWORD *v17; // x0

  if ( addr )
    goto LABEL_2;
  v13 = (void *)sub_6782008(a3, len);
  if ( !v13 )
    goto LABEL_2;
  v14 = v13;
  v15 = (unsigned __int64)mmap(v13, len, prot, flags, -1, 0LL);
  if ( v15 == -1LL )
  {
    v17 = (_DWORD *)__errno(-1LL);
    sub_6781928(
      (signed __int64)"unable to directly request hinted aligned OS memory (error: %d (0x%x), size: 0x%zx bytes, alignmen"
                      "t: 0x%zx, hint address: %p)\n",
      *v17,
      *v17,
      len,
      a3,
      v14);
LABEL_2:
    v9 = mmap(addr, len, prot, flags, -1, 0LL);
    if ( v9 == (void *)-1LL )
      return 0LL;
    else
      return v9;
  }
  v10 = v15;
  if ( v15 % a3 )
  {
    v16 = (_DWORD *)__errno(v15);
    sub_6781928(
      (signed __int64)"unable to directly request hinted aligned OS memory (error: %d (0x%x), size: 0x%zx bytes, alignmen"
                      "t: 0x%zx, hint address: %p)\n",
      *v16,
      *v16,
      len,
      a3,
      v14);
  }
  return (void *)v10;
}


================================================================================
Function: sub_678E980 (0x678E980)
================================================================================

__int64 sub_678E980()
{
  unsigned __int8 v0; // w9
  _QWORD *v1; // x8
  int v3; // w0

  v0 = atomic_load(byte_72BA438);
  v1 = &unk_72BA000;
  if ( (v0 & 1) == 0 )
  {
    v3 = sub_67EB6E0((__int64)byte_72BA438);
    v1 = &unk_72BA000;
    if ( v3 )
    {
      qword_72BA430 = (__int64)&qword_72BA440;
      qword_72BA440 = (__int64)off_6BE0948;
      sub_67EB838(byte_72BA438);
      v1 = (_QWORD *)&unk_72BA000;
    }
  }
  return v1[134];
}


================================================================================
Function: sub_678FD08 (0x678FD08)
================================================================================

__int64 __fastcall sub_678FD08(time_t *a1, __int64 a2)
{
  __int128 v3; // q1
  int tm_isdst; // w8
  struct tm v6; // [xsp+0h] [xbp-50h] BYREF
  time_t timer; // [xsp+40h] [xbp-10h] BYREF

  timer = *a1;
  if ( !gmtime_r(&timer, &v6) )
    return 0LL;
  v3 = *(_OWORD *)&v6.tm_mon;
  tm_isdst = v6.tm_isdst;
  *(_OWORD *)a2 = *(_OWORD *)&v6.tm_sec;
  *(_OWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 32) = tm_isdst;
  return a2;
}


================================================================================
Function: sub_678FF08 (0x678FF08)
================================================================================

void __fastcall __noreturn sub_678FF08(__int64 a1)
{
  __int64 v2; // x19

  v2 = sub_67EAFB8(16LL);
  sub_678FF58(v2, a1);
  sub_67EB030(v2, (__int64)&`typeinfo for'fmt::v8::format_error, (__int64)sub_678FF84);
}


================================================================================
Function: sub_678FF58 (0x678FF58)
================================================================================

__int64 __fastcall sub_678FF58(_QWORD *a1, char *a2)
{
  __int64 result; // x0

  result = sub_67D2554((int)a1, a2);
  *a1 = off_6BE0B30;
  return result;
}


================================================================================
Function: sub_678FFAC (0x678FFAC)
================================================================================

_BYTE *__usercall sub_678FFAC@<X0>(
        char *a1@<X0>,
        __int64 a2@<X1>,
        unsigned __int64 a3@<X2>,
        unsigned int *a4@<X3>,
        unsigned __int64 *a5@<X8>)
{
  size_t v6; // x20
  const void *v7; // x21
  void *v8; // x19
  unsigned __int64 v9; // x22
  __int64 v10; // x0
  _BYTE *result; // x0
  _UNKNOWN **v12; // [xsp+0h] [xbp-220h] BYREF
  _BYTE *v13; // [xsp+8h] [xbp-218h]
  __int128 v14; // [xsp+10h] [xbp-210h]
  _BYTE v15[504]; // [xsp+20h] [xbp-200h] BYREF

  v12 = &off_6BE0B98;
  v13 = v15;
  v14 = xmmword_AFDC90;
  sub_67900D8((__int64)&v12, a1, a2, a3, a4, 0LL);
  v7 = v13;
  v6 = v14;
  if ( (unsigned __int64)v14 >= 0x17 )
  {
    v9 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v10 = sub_6575418();
    a5[1] = v6;
    a5[2] = v10;
    *a5 = v9 | 1;
    v8 = (void *)v10;
    goto LABEL_5;
  }
  *(_BYTE *)a5 = 2 * v14;
  v8 = (char *)a5 + 1;
  if ( v6 )
LABEL_5:
    memcpy(v8, v7, v6);
  result = v13;
  *((_BYTE *)v8 + v6) = 0;
  if ( result != v15 )
    return (_BYTE *)sub_6575460();
  return result;
}


================================================================================
Function: sub_67900C8 (0x67900C8)
================================================================================

void __fastcall __noreturn sub_67900C8(__int64 a1, __int64 a2)
{
  sub_678FF08(a2);
}


================================================================================
Function: sub_67900D8 (0x67900D8)
================================================================================

__int64 __fastcall sub_67900D8(__int64 result, char *a2, __int64 a3, unsigned __int64 a4, unsigned int *a5, __int64 a6)
{
  _BYTE *v6; // x21
  __int64 v7; // x19
  char *v8; // x20
  char *v9; // x19
  int v10; // w8
  int v11; // t1
  __int64 v12; // x0
  void *v13; // x19
  unsigned int v14; // w8
  unsigned int v15; // w10
  __int64 (__fastcall *v16)(unsigned __int64, unsigned __int64 **, unsigned __int64 *); // x8
  unsigned int v17; // w9
  float v18; // w20
  const char *v19; // x8
  __int64 v20; // x2
  __int64 v21; // x8
  __int64 v22; // x1
  __int64 v23; // x9
  const char *v24; // x20
  const char *v25; // x1
  unsigned __int64 v26; // x20
  __int64 v27; // x2
  unsigned __int64 v28; // x8
  bool v29; // cc
  long double v30; // [xsp+0h] [xbp-70h]
  unsigned __int64 *v31; // [xsp+10h] [xbp-60h] BYREF
  __int64 v32; // [xsp+18h] [xbp-58h]
  int v33; // [xsp+20h] [xbp-50h]
  unsigned __int64 v34; // [xsp+28h] [xbp-48h] BYREF
  _WORD *v35; // [xsp+30h] [xbp-40h]
  unsigned int *v36; // [xsp+38h] [xbp-38h]
  __int64 v37; // [xsp+40h] [xbp-30h]
  __int64 v38; // [xsp+48h] [xbp-28h]
  unsigned __int64 v39; // [xsp+50h] [xbp-20h]
  unsigned int *v40; // [xsp+58h] [xbp-18h]
  __int64 v41; // [xsp+60h] [xbp-10h]

  v6 = a2;
  v7 = result;
  if ( a3 == 2 && *(_WORD *)a2 == 32123 )
  {
    if ( (a4 & 0x8000000000000000LL) != 0 )
    {
      if ( (int)a4 <= 0 || (v14 = a5[4]) == 0 )
LABEL_52:
        sub_678FF08("argument not found");
    }
    else
    {
      v14 = a4 & 0xF;
      if ( (a4 & 0xF) == 0 )
        goto LABEL_52;
    }
    v15 = v14 - 1;
    v16 = (__int64 (__fastcall *)(unsigned __int64, unsigned __int64 **, unsigned __int64 *))*((_QWORD *)a5 + 1);
    v18 = *(float *)a5;
    v17 = a5[1];
    switch ( v15 )
    {
      case 0u:
        result = sub_6793834(result, LODWORD(v18));
        break;
      case 1u:
        result = sub_679238C(result, LODWORD(v18));
        break;
      case 2u:
        result = sub_6793A20(result, *a5 | ((unsigned __int64)v17 << 32));
        break;
      case 3u:
        result = sub_6793C30(result, *a5 | ((unsigned __int64)v17 << 32));
        break;
      case 4u:
        result = sub_6793DE4(result, a2, *a5 | ((unsigned __int64)v17 << 32), *((_QWORD *)a5 + 1));
        break;
      case 5u:
        result = sub_679410C(result, a2, *a5 | ((unsigned __int64)v17 << 32), *((_QWORD *)a5 + 1));
        break;
      case 6u:
        *(_DWORD *)((char *)&v32 + 3) = 32;
        v19 = "true";
        if ( LOBYTE(v18) )
        {
          v20 = 4LL;
        }
        else
        {
          v19 = "false";
          v20 = 5LL;
        }
        LOBYTE(v32) = 0;
        v31 = (unsigned __int64 *)0xFFFFFFFF00000000LL;
        *(_WORD *)((char *)&v32 + 1) = 0;
        HIBYTE(v32) = 1;
        v34 = (unsigned __int64)v19;
        v35 = (_WORD *)v20;
        result = sub_67943D8(result, &v31);
        break;
      case 7u:
        v21 = *(_QWORD *)(result + 16);
        v22 = v21 + 1;
        if ( *(_QWORD *)(result + 24) < (unsigned __int64)(v21 + 1) )
        {
          result = (**(__int64 (__fastcall ***)(__int64))result)(result);
          v21 = *(_QWORD *)(v7 + 16);
          v22 = v21 + 1;
        }
        v23 = *(_QWORD *)(v7 + 8);
        *(_QWORD *)(v7 + 16) = v22;
        *(_BYTE *)(v23 + v21) = LOBYTE(v18);
        break;
      case 8u:
        result = sub_67945DC(result, v18);
        break;
      case 9u:
        result = sub_6795C64(result, COERCE_DOUBLE(*a5 | ((unsigned __int64)v17 << 32)));
        break;
      case 0xAu:
        *(_QWORD *)&v30 = *a5 | ((unsigned __int64)v17 << 32);
        *((_QWORD *)&v30 + 1) = *((_QWORD *)a5 + 1);
        result = sub_6796F3C(result, 0xFFFFFFFF00000000LL, 0x100000020000000LL, 0LL, v30);
        break;
      case 0xBu:
        v24 = (const char *)(*a5 | ((unsigned __int64)v17 << 32));
        if ( !v24 )
          sub_678FF08("string pointer is null");
        v25 = &v24[strlen(v24)];
        goto LABEL_47;
      case 0xCu:
        v24 = (const char *)(*a5 | ((unsigned __int64)v17 << 32));
        v25 = (char *)v16 + (_QWORD)v24;
LABEL_47:
        result = sub_6797CE0(v24, v25, v7);
        break;
      case 0xDu:
        v26 = *a5 | ((unsigned __int64)v17 << 32);
        v27 = 2LL;
        v28 = v26;
        v32 = 0x100000020000000LL;
        v31 = (unsigned __int64 *)0xFFFFFFFF00000000LL;
        do
        {
          v29 = v28 > 0xF;
          ++v27;
          v28 >>= 4;
        }
        while ( v29 );
        v34 = v26;
        LODWORD(v35) = v27 - 2;
        result = sub_67989DC(result, &v31, v27, v27, &v34);
        break;
      case 0xEu:
        v31 = 0LL;
        v32 = 0LL;
        v33 = 0;
        v34 = result;
        v35 = (_WORD *)a4;
        v36 = a5;
        v37 = a6;
        result = v16(LODWORD(v18) | ((unsigned __int64)v17 << 32), &v31, &v34);
        break;
      default:
        return result;
    }
    return result;
  }
  v8 = &a2[a3];
  v35 = a2;
  v36 = (unsigned int *)a3;
  LODWORD(v37) = 0;
  v38 = result;
  v39 = a4;
  v40 = a5;
  v41 = a6;
  if ( a3 > 31 )
  {
    v31 = &v34;
    while ( 1 )
    {
      v13 = v6;
      if ( *v6 != 123 )
      {
        v13 = memchr(v6 + 1, 123, v8 - (v6 + 1));
        if ( !v13 )
          break;
      }
      sub_679908C((int)&v31, v6);
      result = sub_6798BA8(v13, v8, &v34);
      v6 = (_BYTE *)result;
      if ( (char *)result == v8 )
        return result;
    }
    return sub_679908C((int)&v31, v6);
  }
  else
  {
    if ( a3 )
    {
      v9 = a2;
      do
      {
        v11 = (unsigned __int8)*a2++;
        v10 = v11;
        if ( v11 == 125 )
        {
          if ( a2 == v8 || *a2 != 125 )
            sub_678FF08("unmatched '}' in format string");
          v12 = sub_6797CE0(v6, a2, v38);
          a2 = v9 + 2;
          v38 = v12;
          v6 = v9 + 2;
        }
        else if ( v10 == 123 )
        {
          v38 = sub_6797CE0(v6, v9, v38);
          a2 = (char *)sub_6798BA8(v9, v8, &v34);
          v6 = a2;
        }
        v9 = a2;
      }
      while ( a2 != v8 );
      v7 = v38;
    }
    return sub_6797CE0(v6, v8, v7);
  }
}


================================================================================
Function: sub_6790624 (0x6790624)
================================================================================

unsigned __int64 __fastcall sub_6790624(float a1)
{
  int v1; // w16
  signed int v2; // w9
  unsigned int v3; // w8
  int v4; // w0
  unsigned __int64 v5; // x13
  int v6; // w14
  __int64 v7; // x12
  __int64 v8; // x10
  __int64 v9; // x15
  unsigned __int64 v10; // x11
  unsigned int v11; // w17
  unsigned __int64 v12; // x15
  unsigned int v13; // w15
  unsigned int v14; // w16
  int v15; // w11
  unsigned int v16; // w16
  unsigned int v17; // w11
  bool v18; // cc
  unsigned __int64 v19; // x10
  char v20; // w13
  unsigned int v21; // kr00_4
  unsigned __int64 v22; // x13
  unsigned int v23; // w12
  unsigned int v24; // w10
  __int64 v25; // x0
  unsigned int v26; // w9
  int v27; // w10
  unsigned int v28; // w11
  int v29; // w9
  unsigned int v30; // w8
  _BOOL4 v31; // w12
  unsigned int v32; // w9
  int v33; // w10
  unsigned int v34; // w12
  _BOOL4 v35; // w11
  unsigned int v37; // w14
  unsigned int v38; // w11

  v1 = LODWORD(a1) & 0x7FFFFF;
  if ( (LODWORD(a1) & 0x7F800000) != 0 )
  {
    v2 = ((LODWORD(a1) & 0x7F800000u) >> 23) - 150;
    if ( !v1 )
    {
      v3 = (1262611 * v2 - 524031) >> 22;
      v19 = qword_173DD60[31 - v3];
      v20 = 40 - (((LODWORD(a1) & 0x7F800000u) >> 23) + 106 + ((int)(-1741647 * v3) >> 19));
      v21 = (v19 + (v19 >> 24)) >> v20;
      v22 = (v19 - (v19 >> 25)) >> v20;
      v23 = v21 / 0xA;
      if ( (v2 & 0xFFFFFFFE) != 2 )
        LODWORD(v22) = v22 + 1;
      if ( 10 * v23 < (unsigned int)v22 )
      {
        v24 = ((unsigned int)(v19 >> (39
                                    - ((unsigned __int8)((LODWORD(a1) & 0x7F800000u) >> 23)
                                     + 106
                                     + ((int)(-1741647 * v3) >> 19))))
             + 1) >> 1;
        if ( (LODWORD(a1) & 0x7F800000u) >> 23 == 115 )
        {
          v17 = v24 & 0x7FFFFFFE;
        }
        else if ( v24 >= (unsigned int)v22 )
        {
          v17 = v24;
        }
        else
        {
          v17 = v24 + 1;
        }
        return v17 | ((unsigned __int64)v3 << 32);
      }
      v26 = __clz(__rbit32(v23));
      if ( v26 >= 7 )
        v27 = 7;
      else
        v27 = v26;
      if ( (unsigned int)v27 >= 2 && (v28 = -1030792151 * v23, -1030792151 * v23 <= 0xA3D70A3) )
      {
        v29 = v27 & 6;
        if ( v27 >= 4 )
        {
          if ( 989560465 * v23 <= 0xA3D70A3 )
          {
            v28 = 989560465 * v23;
            if ( v27 >= 6 )
            {
              v28 = 1757569337 * v23;
              if ( 1757569337 * v23 > 0xA3D70A3 )
              {
                v28 = 989560465 * v23;
                v29 = 4;
              }
            }
          }
          else
          {
            v29 = 2;
          }
        }
      }
      else
      {
        v29 = 0;
        v28 = v21 / 0xA;
      }
      v30 = v3 + 1;
      if ( v29 < v27 )
      {
        v31 = -858993459 * v28 < 0x33333334;
        if ( -858993459 * v28 < 0x33333334 )
          v28 *= -858993459;
        v29 |= v31;
      }
      v17 = v28 >> v29;
LABEL_64:
      v3 = v30 + v29;
      return v17 | ((unsigned __int64)v3 << 32);
    }
    v1 |= 0x800000u;
  }
  else
  {
    if ( !v1 )
    {
      v17 = 0;
      v3 = 0;
      return v17 | ((unsigned __int64)v3 << 32);
    }
    v2 = -149;
  }
  v3 = (1262611 * v2) >> 22;
  v4 = (2 * (v1 & 0xFFFFFF)) | 1;
  v5 = qword_173DD60[32 - v3];
  v6 = v2 + ((int)(1741647 - 1741647 * v3) >> 19);
  v7 = ((__int64)(1262611 * v2) >> 22) - 1;
  v8 = (unsigned int)(2 * v1);
  v9 = ((unsigned int)(v4 << (v2 + ((int)(1741647 - 1741647 * v3) >> 19))) * (unsigned __int128)v5) >> 64;
  v10 = (unsigned __int64)(1374389535 * v9) >> 37;
  v11 = (unsigned int)v9 % 0x64;
  v12 = v5 >> (63 - ((unsigned __int8)v2 + (unsigned __int8)((int)(1741647 - 1741647 * v3) >> 19)));
  if ( v11 > (unsigned int)v12 )
    goto LABEL_7;
  if ( v11 >= (unsigned int)v12 )
  {
    v25 = (unsigned int)(v8 - 1);
    if ( (v1 & 1) == 0
      && v2 >= -1
      && (v2 < 7
       || (unsigned int)v2 <= 0x27 && (unsigned int)(dword_173E76C[2 * (int)v7] * v25) <= dword_173E76C[2 * (int)v7 + 1])
      || (((v5 * v25) >> -(char)v6) & 1) != 0 )
    {
      goto LABEL_53;
    }
  }
  else
  {
    if ( (v1 & 1) == 0
      || (!v11 ? (v18 = v2 < -1) : (v18 = 1),
          v18
       || v2 >= 7 && ((unsigned int)v2 > 0x27 || (unsigned int)(dword_173E76C[2 * v7] * v4) > dword_173E76C[2 * v7 + 1])) )
    {
LABEL_53:
      v32 = __clz(__rbit32(v10));
      if ( v32 >= 7 )
        v33 = 7;
      else
        v33 = v32;
      if ( (unsigned int)v33 >= 2 && (v34 = -1030792151 * v10, (unsigned int)(-1030792151 * v10) <= 0xA3D70A3) )
      {
        v29 = v33 & 6;
        if ( v33 >= 4 )
        {
          v37 = 989560465 * v10;
          if ( (unsigned int)(989560465 * v10) <= 0xA3D70A3 )
          {
            v34 = 989560465 * v10;
            if ( v33 >= 6 )
            {
              v38 = 1757569337 * v10;
              v34 = v38 <= 0xA3D70A3 ? v38 : v37;
              if ( v38 > 0xA3D70A3 )
                v29 = 4;
            }
          }
          else
          {
            v29 = 2;
          }
        }
      }
      else
      {
        v29 = 0;
        v34 = v10;
      }
      v30 = v3 + 1;
      if ( v29 < v33 )
      {
        v35 = -858993459 * v34 < 0x33333334;
        if ( -858993459 * v34 < 0x33333334 )
          v34 *= -858993459;
        v29 |= v35;
      }
      v17 = v34 >> v29;
      goto LABEL_64;
    }
    LODWORD(v10) = v10 - 1;
    v11 = 100;
  }
LABEL_7:
  v13 = v11 - ((unsigned int)v12 >> 1);
  v14 = v13 + 5;
  v15 = 10 * v10;
  if ( ((v13 + 5) & 1) != 0 )
  {
    v17 = v15 + ((52429 * v14) >> 19);
  }
  else
  {
    v16 = 52429 * (v14 >> 1);
    v17 = v15 + (v16 >> 18);
    if ( (unsigned __int16)((unsigned __int16)v16 >> 2) <= 0xCCCu )
    {
      if ( (((unsigned int)((v5 * v8) >> -(char)v6) ^ ((v13 & 1) == 0)) & 1) != 0 )
      {
        if ( v2 <= 39 )
        {
          if ( v2 < 7 )
          {
            if ( v2 > -3 || (int)__clz(__rbit32(v8)) > (int)v7 - v2 )
              goto LABEL_81;
          }
          else if ( (unsigned int)(dword_173E76C[2 * (int)v7] * v8) <= dword_173E76C[2 * (int)v7 + 1] )
          {
LABEL_81:
            v17 &= ~1u;
          }
        }
      }
      else
      {
        --v17;
      }
    }
  }
  return v17 | ((unsigned __int64)v3 << 32);
}


================================================================================
Function: sub_6790A84 (0x6790A84)
================================================================================

unsigned __int64 __fastcall sub_6790A84(double a1)
{
  __int64 v1; // x8
  __int64 v2; // x13
  int v3; // w9
  int v4; // w8
  __int64 v5; // x10
  unsigned int v6; // w11
  unsigned int v7; // w17
  unsigned __int64 *v8; // x15
  int v9; // w1
  int v10; // w0
  unsigned __int64 v11; // x11
  unsigned __int64 v12; // x12
  int v13; // w15
  _BOOL8 v14; // x17
  unsigned __int64 v15; // x2
  unsigned __int64 v16; // x12
  int v17; // w16
  __int64 v18; // x1
  unsigned __int64 v19; // x11
  unsigned __int64 v20; // x12
  char v21; // w15
  __int64 v22; // x1
  unsigned __int64 v23; // x14
  unsigned __int64 result; // x0
  unsigned int v25; // w17
  unsigned __int64 v26; // x16
  unsigned __int64 v27; // x14
  unsigned int v28; // w13
  __int64 v29; // x16
  unsigned int v30; // w17
  bool v31; // cc
  int v32; // w8
  int v33; // w12
  unsigned int v34; // w10
  unsigned int v35; // w14
  __int64 *v36; // x16
  char v37; // w10
  signed int v38; // w13
  unsigned __int64 v39; // x11
  __int64 v40; // x16
  bool v41; // cf
  int v42; // w14
  unsigned __int64 v43; // x15
  __int64 v44; // x17
  unsigned __int64 v45; // x16
  int v46; // w12
  unsigned __int64 v47; // x12
  unsigned __int64 v48; // x13
  unsigned __int64 v49; // x10
  unsigned __int64 v50; // x1
  unsigned int v51; // w9
  unsigned __int64 v52; // x11
  int v53; // w10
  int v54; // w14
  unsigned int v55; // w17
  unsigned __int64 v56; // x10
  int v57; // w11
  int v58; // w11
  unsigned int v59; // w14
  unsigned int v61; // w13
  unsigned int v63; // w9

  v1 = (*(_QWORD *)&a1 >> 52) & 0x7FFLL;
  v2 = *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL;
  if ( (_DWORD)v1 )
  {
    v3 = v1 - 1075;
    if ( !v2 )
    {
      v32 = (1262611 * v3 - 524031) >> 22;
      v33 = (-1741647 * v32) >> 19;
      v34 = (((12137 * (unsigned int)(unsigned __int16)(292 - v32)) >> 16)
           + ((unsigned __int16)((292 - v32 - ((12137 * (unsigned int)(unsigned __int16)(292 - v32)) >> 16)) & 0xFFFE) >> 1)) >> 4;
      v35 = 27 * v34;
      v36 = (__int64 *)((char *)&unk_173DFD0 + 16 * v34);
      v37 = v33 + v3;
      v38 = v35 - 292 + v32;
      v39 = v36[1];
      if ( v38 )
      {
        v40 = *v36;
        v41 = v35 >= 0x124;
        v42 = 1741647 * (v35 - 292);
        v44 = !v41;
        v45 = v40 - v44;
        v46 = v38 - (v42 >> 19) + v33;
        v43 = qword_173E140[-v38];
        v39 = (((v39 * (unsigned __int128)v43 + ((v43 * (unsigned __int128)v45) >> 64)) >> 64 << -(char)v46) | ((unsigned __int64)(v39 * v43 + ((v43 * (unsigned __int128)v45) >> 64)) >> v46))
            + __CFADD__(
                ((((v43 * (unsigned __int128)v45) >> 64) + v39 * v43) << -(char)v46) | ((v43 * v45) >> v46),
                v44);
      }
      v47 = (v39 + (v39 >> 53)) >> (11 - v37);
      v48 = (v39 - (v39 >> 54)) >> (11 - v37);
      result = v47 / 0xA;
      if ( (v3 & 0xFFFFFFFE) != 2 )
        ++v48;
      if ( 10 * (v47 / 0xA) < v48 )
      {
        v49 = ((v39 >> (10 - v37)) + 1) >> 1;
        if ( v3 == -77 )
          return v49 & 0x7FFFFFFFFFFFFFFELL;
        if ( v49 >= v48 )
          return v49;
        return v49 + 1;
      }
      v51 = __clz(__rbit64(result));
      if ( v51 >= 0x10 )
        v51 = 16;
      if ( v51 < 8 )
      {
        if ( !v51 )
          return result;
      }
      else if ( 0xC767074B22E90E21LL * result < 0x2AF31DC46119LL )
      {
        v52 = (0xC767074B22E90E21LL * result) >> 8;
        if ( v51 >= 9 )
        {
          v53 = 8;
          while ( 1 )
          {
            v54 = -858993459 * v52;
            if ( (unsigned int)(-858993459 * v52) > 0x33333333 )
              break;
            ++v53;
            LODWORD(v52) = -858993459 * v52;
            if ( v51 == v53 )
            {
LABEL_62:
              LODWORD(v52) = v54;
              LOBYTE(v53) = v51;
              return (unsigned int)v52 >> (v53 - 8);
            }
          }
          return (unsigned int)v52 >> (v53 - 8);
        }
        goto LABEL_74;
      }
      v58 = result - 100000000 * (v47 / 0x3B9ACA00);
      if ( (unsigned int)(-858993459 * v58) > 0x33333333 )
        return result;
      v59 = -1030792151 * v58;
      if ( v51 == 1 || v59 > 0x33333333 )
        return ((unsigned int)(-858993459 * v58) >> 1) + 10000000LL * (unsigned int)(v47 / 0x3B9ACA00);
      v61 = 652835029 * v58;
      if ( v51 == 2 || v61 > 0x33333333 )
        return (v59 >> 2) + 1000000LL * (unsigned int)(v47 / 0x3B9ACA00);
      if ( v51 == 3 || (unsigned int)(989560465 * v58) > 0x33333333 )
        return (v61 >> 3) + 100000LL * (unsigned int)(v47 / 0x3B9ACA00);
      if ( v51 == 4 || (unsigned int)(197912093 * v58) > 0x33333333 )
        return ((unsigned int)(989560465 * v58) >> 4) + 10000LL * (unsigned int)(v47 / 0x3B9ACA00);
      if ( v51 == 5 || (unsigned int)(1757569337 * v58) > 0x33333333 )
        return ((unsigned int)(197912093 * v58) >> 5) + 1000LL * (unsigned int)(v47 / 0x3B9ACA00);
      if ( v51 == 6 )
        return ((unsigned int)(1757569337 * v58) >> 6) + 100LL * (unsigned int)(v47 / 0x3B9ACA00);
      v63 = -1366473051 * v58;
      if ( (unsigned int)(-1366473051 * v58) > 0x33333333 )
        return ((unsigned int)(1757569337 * v58) >> 6) + 100LL * (unsigned int)(v47 / 0x3B9ACA00);
      v56 = (unsigned int)(v47 / 0x3B9ACA00);
      return (v63 >> 7) + 10 * v56;
    }
    v2 |= 0x10000000000000uLL;
  }
  else
  {
    if ( !v2 )
      return 0LL;
    v3 = -1074;
  }
  v4 = (1262611 * v3) >> 22;
  v5 = ((__int64)(1262611 * v3) >> 22) - 2;
  v6 = (((12137 * (unsigned int)(unsigned __int16)(294 - ((__int16)((unsigned int)(1262611 * v3) >> 16) >> 6))) >> 16)
      + ((unsigned __int16)((294
                           - ((__int16)((unsigned int)(1262611 * v3) >> 16) >> 6)
                           - ((12137
                             * (unsigned int)(unsigned __int16)(294
                                                              - ((__int16)((unsigned int)(1262611 * v3) >> 16) >> 6))) >> 16)) & 0xFFFE) >> 1)) >> 4;
  v7 = 27 * v6;
  v8 = (unsigned __int64 *)((char *)&unk_173DFD0 + 16 * v6);
  v9 = 27 * v6 - 292;
  v10 = 2 - v4 - v9;
  v12 = *v8;
  v11 = v8[1];
  v13 = (1741647 * (2 - v4)) >> 19;
  if ( 2 - v4 != v9 )
  {
    v14 = v7 < 0x124;
    v15 = qword_173E140[v10];
    v16 = v12 - v14;
    v17 = v13 - (v10 + ((1741647 * v9) >> 19));
    v18 = (v11 * (unsigned __int128)v15 + ((v15 * (unsigned __int128)v16) >> 64)) >> 64;
    v19 = (__PAIR128__(v11, v16) * v15) >> 64;
    v20 = (v19 << -(char)v17) | ((v15 * v16) >> v17);
    v11 = __CFADD__(v20, v14) + ((v18 << -(char)v17) | (v19 >> v17));
    v12 = v20 + v14 + (((unsigned __int64)dword_173E218[(unsigned int)(294 - v4) >> 4] >> ((2 * (38 - v4)) & 0x1E)) & 3);
  }
  v21 = v13 + v3;
  v22 = (2 * (v2 & 0x1FFFFFFFFFFFFFLL)) | 1;
  v23 = __CFADD__((v12 * (unsigned __int128)(unsigned __int64)(v22 << v21)) >> 64, v11 * (v22 << v21))
      + ((v11 * (unsigned __int128)(unsigned __int64)(v22 << v21)) >> 64);
  result = (unsigned __int64)((v23 * (unsigned __int128)0x83126E978D4FDF3CLL) >> 64) >> 9;
  v25 = v23 - 1000 * result;
  v26 = v11 >> (63 - v21);
  v27 = 2 * v2;
  if ( (unsigned int)v26 >= v25 )
  {
    if ( (unsigned int)v26 <= v25 )
    {
      v50 = v27 - 1;
      if ( ((v2 & 1) != 0
         || v3 < -2
         || v3 >= 10 && ((unsigned int)v3 > 0x56 || qword_173E7C8[2 * (int)v5] * v50 > qword_173E7C8[2 * (int)v5 + 1]))
        && (((unsigned __int64)((__PAIR128__(v11, v12) * v50) >> 64) >> -v21) & 1) == 0 )
      {
        goto LABEL_9;
      }
    }
    else if ( (v2 & 1) != 0 )
    {
      v31 = v25 || v3 < -2;
      if ( !v31
        && (v3 < 10
         || (unsigned int)v3 <= 0x56 && (unsigned __int64)(qword_173E7C8[2 * v5] * v22) <= qword_173E7C8[2 * v5 + 1]) )
      {
        --result;
        v25 = 1000;
        goto LABEL_9;
      }
    }
    v51 = __clz(__rbit64(result));
    if ( v51 >= 0x10 )
      v51 = 16;
    if ( v51 < 8 )
    {
      if ( !v51 )
        return result;
    }
    else if ( 0xC767074B22E90E21LL * result < 0x2AF31DC46119LL )
    {
      v52 = (0xC767074B22E90E21LL * result) >> 8;
      if ( v51 >= 9 )
      {
        v53 = 8;
        while ( 1 )
        {
          v54 = -858993459 * v52;
          if ( (unsigned int)(-858993459 * v52) > 0x33333333 )
            return (unsigned int)v52 >> (v53 - 8);
          ++v53;
          LODWORD(v52) = -858993459 * v52;
          if ( v51 == v53 )
            goto LABEL_62;
        }
      }
LABEL_74:
      LOBYTE(v53) = 8;
      return (unsigned int)v52 >> (v53 - 8);
    }
    v56 = result / 0x5F5E100;
    v57 = result % 0x5F5E100;
    if ( (unsigned int)(-858993459 * v57) > 0x33333333 )
      return result;
    if ( v51 == 1 || (unsigned int)(-1030792151 * v57) > 0x33333333 )
      return ((unsigned int)(-858993459 * v57) >> 1) + 10000000 * v56;
    if ( v51 == 2 || (unsigned int)(652835029 * v57) > 0x33333333 )
      return ((unsigned int)(-1030792151 * v57) >> 2) + 1000000 * v56;
    if ( v51 == 3 || (unsigned int)(989560465 * v57) > 0x33333333 )
      return ((unsigned int)(652835029 * v57) >> 3) + 100000 * v56;
    if ( v51 == 4 || (unsigned int)(197912093 * v57) > 0x33333333 )
      return ((unsigned int)(989560465 * v57) >> 4) + 10000 * v56;
    if ( v51 == 5 || (unsigned int)(1757569337 * v57) > 0x33333333 )
      return ((unsigned int)(197912093 * v57) >> 5) + 1000 * v56;
    if ( v51 == 6 )
      return ((unsigned int)(1757569337 * v57) >> 6) + 100 * v56;
    v63 = -1366473051 * v57;
    if ( (unsigned int)(-1366473051 * v57) > 0x33333333 )
      return ((unsigned int)(1757569337 * v57) >> 6) + 100 * v56;
    return (v63 >> 7) + 10 * v56;
  }
LABEL_9:
  v28 = v25 - ((unsigned int)v26 >> 1);
  v29 = 10 * result;
  v30 = v28 + 50;
  if ( ((v28 + 50) & 3) != 0 )
    return v29 + ((41944 * v30) >> 22);
  v55 = 42025 * (v30 >> 2);
  result = v29 + (v55 >> 20);
  if ( (unsigned __int8)v55 <= 0xAu )
  {
    if ( (((unsigned int)((unsigned __int64)((__PAIR128__(v11, v12) * v27) >> 64) >> -v21) ^ ((v28 & 1) == 0)) & 1) == 0 )
      return --result;
    if ( v3 <= 86 )
    {
      if ( v3 >= 10 )
      {
        if ( qword_173E7C8[2 * (int)v5] * v27 > qword_173E7C8[2 * (int)v5 + 1] )
          return result;
LABEL_88:
        result &= ~1uLL;
        return result;
      }
      if ( v3 > -5 || (int)v5 - v3 < (int)__clz(__rbit64(v27)) )
        goto LABEL_88;
    }
  }
  return result;
}


================================================================================
Function: sub_6791320 (0x6791320)
================================================================================

long double __usercall sub_6791320@<Q0>(__int64 *a1@<X0>, __int64 a2@<X8>)
{
  __int64 v3; // x2
  __int64 *v4; // x20
  unsigned __int64 v5; // x8
  char v6; // w0
  long double result; // q0
  __int64 v8; // x8
  long double v9; // [xsp+0h] [xbp-20h] BYREF
  __int64 v10; // [xsp+10h] [xbp-10h]

  if ( a1 )
    sub_67C4814((__int64 *)&v9, a1);
  else
    sub_67C4788(&v9);
  v4 = sub_67C4BB8((__int64 *)&v9, (__int64)&qword_795CEA8, v3);
  sub_67C482C(&v9);
  (*(void (__fastcall **)(long double *__return_ptr, __int64 *))(*v4 + 40))(&v9, v4);
  if ( (LOBYTE(v9) & 1) != 0 )
    v5 = *((_QWORD *)&v9 + 1);
  else
    v5 = (unsigned __int64)LOBYTE(v9) >> 1;
  if ( v5 )
    v6 = (*(__int64 (__fastcall **)(__int64 *))(*v4 + 32))(v4);
  else
    v6 = 0;
  result = v9;
  *(_BYTE *)(a2 + 24) = v6;
  v8 = v10;
  *(long double *)a2 = result;
  *(_QWORD *)(a2 + 16) = v8;
  return result;
}


================================================================================
Function: sub_6791430 (0x6791430)
================================================================================

__int64 __fastcall sub_6791430(int a1, __int64 a2, __int64 a3, double a4)
{
  int v4; // w27
  int v7; // w9
  unsigned int v8; // w20
  char *v9; // x9
  char v10; // w8
  __int64 v11; // x28
  __int64 v12; // x26
  __int64 v13; // x8
  unsigned __int64 v14; // x1
  __int64 v15; // x25
  __int64 v16; // x21
  size_t v17; // x24
  char *v18; // x0
  unsigned int v19; // w23
  unsigned __int64 v20; // x8
  __int64 v21; // x24
  __int64 v22; // x8
  __int64 v23; // x9
  unsigned __int64 v24; // x20
  __int64 result; // x0
  __int64 v26; // x10
  __int64 v27; // x8
  __int64 v28; // x11
  __int64 v29; // x9
  int v30; // w11
  int v31; // w10
  int v32; // w14
  int v33; // w22
  unsigned int v34; // w23
  __int64 v35; // x10
  int v36; // w9
  int v37; // w11
  unsigned __int64 v38; // x20
  char v39; // [xsp+0h] [xbp-20h] BYREF
  char v40; // [xsp+1h] [xbp-1Fh] BYREF
  _BYTE v41[6]; // [xsp+2h] [xbp-1Eh] BYREF

  v4 = BYTE4(a2);
  v7 = a1 - 1;
  if ( a1 < 0 )
    v7 = 5;
  if ( BYTE4(a2) >= 2u )
    v8 = a1;
  else
    v8 = v7;
  v9 = &v40;
  v39 = 37;
  if ( (a2 & 0x10000000000000LL) != 0 && BYTE4(a2) == 3 )
  {
    v9 = v41;
    v40 = 35;
  }
  if ( (v8 & 0x80000000) == 0 )
  {
    *(_WORD *)v9 = 10798;
    v9 += 2;
  }
  if ( BYTE4(a2) == 3 )
  {
    if ( (a2 & 0x1000000000000LL) != 0 )
      v10 = 65;
    else
      v10 = 97;
  }
  else if ( BYTE4(a2) == 2 )
  {
    v10 = 102;
  }
  else
  {
    v10 = 101;
  }
  *v9 = v10;
  v9[1] = 0;
  v11 = *(_QWORD *)(a3 + 16);
  v12 = v11 + 1;
  while ( 1 )
  {
    while ( 1 )
    {
      v15 = *(_QWORD *)(a3 + 8);
      v16 = v15 + v11;
      v17 = *(_QWORD *)(a3 + 24) - v11;
      v18 = (char *)(v15 + v11);
      if ( (v8 & 0x80000000) == 0 )
        break;
      v19 = snprintf(v18, v17, &v39, a4);
      if ( (v19 & 0x80000000) == 0 )
        goto LABEL_26;
LABEL_19:
      v13 = *(_QWORD *)(a3 + 24);
      if ( v13 != -1 )
      {
        v14 = v13 + 1;
        goto LABEL_21;
      }
    }
    v19 = snprintf(v18, v17, &v39, v8, a4);
    if ( (v19 & 0x80000000) != 0 )
      goto LABEL_19;
LABEL_26:
    if ( v17 > v19 )
      break;
    v14 = v12 + v19;
    if ( *(_QWORD *)(a3 + 24) < v14 )
LABEL_21:
      (**(void (__fastcall ***)(__int64, unsigned __int64))a3)(a3, v14);
  }
  if ( v4 == 2 )
  {
    if ( v8 )
    {
      v21 = 0LL;
      v22 = v16 + v19;
      do
        v23 = v22 + v21--;
      while ( (unsigned int)*(unsigned __int8 *)(v23 - 1) - 48 < 0xA );
      memmove((void *)(v22 + v21), (const void *)(v22 + v21 + 1), (unsigned int)~(_DWORD)v21);
      v20 = *(_QWORD *)(a3 + 24);
      v24 = v19 - 1;
      if ( v20 < v24 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a3)(a3, v19 - 1);
        v20 = *(_QWORD *)(a3 + 24);
      }
      result = (unsigned int)(v21 + 1);
      if ( v20 >= v24 )
        v20 = v19 - 1;
    }
    else
    {
      v20 = *(_QWORD *)(a3 + 24);
      if ( v20 < v19 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a3)(a3, v19);
        v20 = *(_QWORD *)(a3 + 24);
      }
      if ( v20 >= v19 )
        v20 = v19;
LABEL_65:
      result = 0LL;
    }
  }
  else
  {
    if ( v4 == 3 )
    {
      v20 = *(_QWORD *)(a3 + 24);
      if ( v20 < v11 + (unsigned __int64)v19 )
      {
        (**(void (__fastcall ***)(__int64, __int64))a3)(a3, v11 + v19);
        v20 = *(_QWORD *)(a3 + 24);
      }
      if ( v20 >= v11 + (unsigned __int64)v19 )
        v20 = v11 + v19;
      goto LABEL_65;
    }
    v26 = 1LL;
    v27 = v19;
    do
    {
      v28 = v27--;
      v29 = v26--;
    }
    while ( *(_BYTE *)(v16 + v27) != 101 );
    v30 = *(unsigned __int8 *)(v16 + v28);
    v31 = 0;
    do
    {
      v32 = *(char *)(v16 + v19 + v29++);
      v31 = v32 + 10 * v31 - 48;
    }
    while ( v29 );
    if ( v30 == 45 )
      v33 = -v31;
    else
      v33 = v31;
    if ( v27 == 1 )
    {
      v34 = 0;
    }
    else
    {
      v35 = v11 + v15 - 1;
      v36 = -1;
      do
      {
        v37 = *(unsigned __int8 *)(v35 + v27);
        --v36;
        --v35;
      }
      while ( v37 == 48 );
      v34 = v27 + v36;
      memmove((void *)(v16 + 1), (const void *)(v16 + 2), (unsigned int)(v27 + v36));
    }
    v20 = *(_QWORD *)(a3 + 24);
    v38 = v12 + v34;
    if ( v20 < v38 )
    {
      (**(void (__fastcall ***)(__int64, __int64))a3)(a3, v12 + v34);
      v20 = *(_QWORD *)(a3 + 24);
    }
    result = v33 - v34;
    if ( v20 >= v38 )
      v20 = v12 + v34;
  }
  *(_QWORD *)(a3 + 16) = v20;
  return result;
}


================================================================================
Function: sub_6791778 (0x6791778)
================================================================================

__int64 __fastcall sub_6791778(int a1, __int64 a2, __int64 a3, double a4)
{
  int v4; // w27
  int v6; // w9
  unsigned int v7; // w20
  char *v8; // x9
  char v9; // w8
  __int64 v10; // x28
  __int64 v11; // x26
  __int64 v12; // x8
  unsigned __int64 v13; // x1
  __int64 v14; // x25
  __int64 v15; // x21
  size_t v16; // x24
  char *v17; // x0
  unsigned int v18; // w23
  unsigned __int64 v19; // x8
  __int64 v20; // x24
  __int64 v21; // x8
  __int64 v22; // x9
  unsigned __int64 v23; // x20
  __int64 result; // x0
  __int64 v25; // x10
  __int64 v26; // x8
  __int64 v27; // x11
  __int64 v28; // x9
  int v29; // w11
  int v30; // w10
  int v31; // w14
  int v32; // w22
  unsigned int v33; // w23
  __int64 v34; // x10
  int v35; // w9
  int v36; // w11
  unsigned __int64 v37; // x20
  char format; // [xsp+10h] [xbp-10h] BYREF
  char v40; // [xsp+11h] [xbp-Fh] BYREF
  _BYTE v41[6]; // [xsp+12h] [xbp-Eh] BYREF

  v4 = BYTE4(a2);
  v6 = a1 - 1;
  if ( a1 < 0 )
    v6 = 5;
  if ( BYTE4(a2) >= 2u )
    v7 = a1;
  else
    v7 = v6;
  v8 = &v40;
  format = 37;
  if ( (a2 & 0x10000000000000LL) != 0 && BYTE4(a2) == 3 )
  {
    v8 = v41;
    v40 = 35;
  }
  if ( (v7 & 0x80000000) == 0 )
  {
    *(_WORD *)v8 = 10798;
    v8 += 2;
  }
  *v8 = 76;
  if ( BYTE4(a2) == 3 )
  {
    if ( (a2 & 0x1000000000000LL) != 0 )
      v9 = 65;
    else
      v9 = 97;
  }
  else if ( BYTE4(a2) == 2 )
  {
    v9 = 102;
  }
  else
  {
    v9 = 101;
  }
  v8[1] = v9;
  v8[2] = 0;
  v10 = *(_QWORD *)(a3 + 16);
  v11 = v10 + 1;
  while ( 1 )
  {
    while ( 1 )
    {
      v14 = *(_QWORD *)(a3 + 8);
      v15 = v14 + v10;
      v16 = *(_QWORD *)(a3 + 24) - v10;
      v17 = (char *)(v14 + v10);
      if ( (v7 & 0x80000000) == 0 )
        break;
      v18 = snprintf(v17, v16, &format, a4);
      if ( (v18 & 0x80000000) == 0 )
        goto LABEL_26;
LABEL_19:
      v12 = *(_QWORD *)(a3 + 24);
      if ( v12 != -1 )
      {
        v13 = v12 + 1;
        goto LABEL_21;
      }
    }
    v18 = snprintf(v17, v16, &format, v7, a4);
    if ( (v18 & 0x80000000) != 0 )
      goto LABEL_19;
LABEL_26:
    if ( v16 > v18 )
      break;
    v13 = v11 + v18;
    if ( *(_QWORD *)(a3 + 24) < v13 )
LABEL_21:
      (**(void (__fastcall ***)(__int64, unsigned __int64))a3)(a3, v13);
  }
  if ( v4 == 2 )
  {
    if ( v7 )
    {
      v20 = 0LL;
      v21 = v15 + v18;
      do
        v22 = v21 + v20--;
      while ( (unsigned int)*(unsigned __int8 *)(v22 - 1) - 48 < 0xA );
      memmove((void *)(v21 + v20), (const void *)(v21 + v20 + 1), (unsigned int)~(_DWORD)v20);
      v19 = *(_QWORD *)(a3 + 24);
      v23 = v18 - 1;
      if ( v19 < v23 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a3)(a3, v18 - 1);
        v19 = *(_QWORD *)(a3 + 24);
      }
      result = (unsigned int)(v20 + 1);
      if ( v19 >= v23 )
        v19 = v18 - 1;
    }
    else
    {
      v19 = *(_QWORD *)(a3 + 24);
      if ( v19 < v18 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a3)(a3, v18);
        v19 = *(_QWORD *)(a3 + 24);
      }
      if ( v19 >= v18 )
        v19 = v18;
LABEL_65:
      result = 0LL;
    }
  }
  else
  {
    if ( v4 == 3 )
    {
      v19 = *(_QWORD *)(a3 + 24);
      if ( v19 < v10 + (unsigned __int64)v18 )
      {
        (**(void (__fastcall ***)(__int64, __int64))a3)(a3, v10 + v18);
        v19 = *(_QWORD *)(a3 + 24);
      }
      if ( v19 >= v10 + (unsigned __int64)v18 )
        v19 = v10 + v18;
      goto LABEL_65;
    }
    v25 = 1LL;
    v26 = v18;
    do
    {
      v27 = v26--;
      v28 = v25--;
    }
    while ( *(_BYTE *)(v15 + v26) != 101 );
    v29 = *(unsigned __int8 *)(v15 + v27);
    v30 = 0;
    do
    {
      v31 = *(char *)(v15 + v18 + v28++);
      v30 = v31 + 10 * v30 - 48;
    }
    while ( v28 );
    if ( v29 == 45 )
      v32 = -v30;
    else
      v32 = v30;
    if ( v26 == 1 )
    {
      v33 = 0;
    }
    else
    {
      v34 = v10 + v14 - 1;
      v35 = -1;
      do
      {
        v36 = *(unsigned __int8 *)(v34 + v26);
        --v35;
        --v34;
      }
      while ( v36 == 48 );
      v33 = v26 + v35;
      memmove((void *)(v15 + 1), (const void *)(v15 + 2), (unsigned int)(v26 + v35));
    }
    v19 = *(_QWORD *)(a3 + 24);
    v37 = v11 + v33;
    if ( v19 < v37 )
    {
      (**(void (__fastcall ***)(__int64, __int64))a3)(a3, v11 + v33);
      v19 = *(_QWORD *)(a3 + 24);
    }
    result = v32 - v33;
    if ( v19 >= v37 )
      v19 = v11 + v33;
  }
  *(_QWORD *)(a3 + 16) = v19;
  return result;
}


================================================================================
Function: sub_6791AC0 (0x6791AC0)
================================================================================

__int64 __fastcall sub_6791AC0(size_t n, unsigned __int64 a2, _QWORD *a3, double a4)
{
  int v5; // w20
  unsigned __int64 v6; // x21
  __int64 v7; // x0
  __int64 v8; // x16
  __int64 v9; // x10
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x10
  unsigned __int64 v12; // x11
  __int64 v13; // x10
  int v14; // w23
  unsigned __int64 v15; // x11
  int v16; // w12
  int v17; // w11
  __int64 v18; // x11
  __int16 v19; // w14
  int v20; // w13
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // x26
  char *v23; // x12
  unsigned __int64 v24; // x10
  unsigned __int64 v25; // x3
  unsigned __int64 v27; // x15
  __int64 v28; // x17
  int v29; // w16
  __int64 v30; // x13
  unsigned __int64 v31; // x4
  __int64 v32; // x2
  unsigned int v33; // w27
  unsigned int v34; // w1
  int v35; // w9
  __int64 v36; // x3
  unsigned int v37; // w16
  unsigned __int64 v38; // x9
  unsigned __int64 v39; // x8
  unsigned __int64 v40; // x10
  __int64 v41; // x11
  unsigned __int64 v42; // x8
  unsigned __int64 v43; // x8
  void *v44; // x0
  unsigned __int64 v45; // x20
  __int64 v47; // x8
  __int64 v48; // x1
  __int64 v49; // x9
  unsigned __int64 v50; // x0
  int v51; // w1
  unsigned __int64 v52; // x10
  __int64 v53; // x9
  unsigned int v54; // w8
  float v55; // s0
  unsigned __int64 v56; // x0
  __int64 v57; // x8
  unsigned __int64 v58; // x10
  __int64 v59; // x10
  unsigned __int64 v60; // x17
  char *v61; // x8
  bool v62; // cf
  unsigned __int64 v63; // x8
  __int64 v64; // x8
  __int64 v65; // x10
  __int64 v66; // x13
  __int64 v67; // x11
  __int64 v68; // x14
  __int64 v69; // x15
  unsigned int v70; // w1
  char v71; // w2
  float v72; // s0
  int v73; // w3
  char v74; // w8
  unsigned __int64 v75; // x20
  unsigned __int64 v76; // x8
  unsigned __int64 v77; // x20
  __int64 v78; // x8
  unsigned __int64 v79; // x8
  _QWORD *v80; // x19
  int v81; // [xsp+4h] [xbp-2Ch]
  unsigned int v82; // [xsp+8h] [xbp-28h]
  int v83; // [xsp+20h] [xbp-10h]
  int v84; // [xsp+24h] [xbp-Ch] BYREF

  v5 = n;
  v6 = HIDWORD(a2);
  if ( a4 <= 0.0 )
  {
    if ( (int)n >= 1 && BYTE4(a2) == 2 )
    {
      v43 = a3[3];
      if ( v43 < (unsigned int)n )
      {
        (*(void (__fastcall **)(_QWORD *, _QWORD))*a3)(a3, (unsigned int)n);
        v43 = a3[3];
      }
      v44 = (void *)a3[1];
      if ( v43 >= (unsigned int)v5 )
        v43 = (unsigned int)v5;
      a3[2] = v43;
      memset(v44, 48, (unsigned int)v5);
      LODWORD(v45) = -v5;
    }
    else
    {
      v47 = a3[2];
      v48 = v47 + 1;
      if ( a3[3] < (unsigned __int64)(v47 + 1) )
      {
        (*(void (__fastcall **)(_QWORD *))*a3)(a3);
        v47 = a3[2];
        v48 = v47 + 1;
      }
      v49 = a3[1];
      LODWORD(v45) = 0;
      a3[2] = v48;
      *(_BYTE *)(v49 + v47) = 48;
    }
  }
  else
  {
    if ( (a2 & 0x8000000000000LL) != 0 )
      return sub_6791430((unsigned int)n, a2, a3, a4);
    if ( (n & 0x80000000) == 0 )
    {
      if ( ((*(_QWORD *)&a4 >> 52) & 0x7FF) != 0 )
        v7 = *(_QWORD *)&a4 & 0xFFFFFFFFFFFFFLL | 0x10000000000000LL;
      else
        v7 = *(_QWORD *)&a4 & 0xFFFFFFFFFFFFFLL;
      if ( ((*(_QWORD *)&a4 >> 52) & 0x7FF) != 0 )
        v8 = (unsigned int)((*(_QWORD *)&a4 >> 52) & 0x7FF) - 1075;
      else
        v8 = 4294966222LL;
      v9 = v7;
      v10 = v8;
      if ( (v7 & 0x10000000000000LL) == 0 )
      {
        v11 = __clz(*(_QWORD *)&a4 & 0xFFFFFFFFFFFFFLL) - 11;
        v10 = v8;
        v12 = v11;
        do
        {
          v10 = (unsigned int)(v10 - 1) | v10 & 0xFFFFFFFF00000000LL;
          --v12;
        }
        while ( v12 );
        v9 = v7 << v11;
      }
      v13 = v9 << 11;
      v14 = BYTE4(a2);
      v15 = (unsigned __int64)(1292913986 * ((__int64)(0xFFFFFFCE00000000LL - (v10 << 32)) >> 32) + 0xFFFFFFFFLL) >> 32;
      v16 = v15 + 347;
      v17 = v15 + 354;
      if ( v16 >= 0 )
        v17 = v16;
      v18 = ((__int64)v17 >> 3) + 1;
      LODWORD(a2) = 8 * v18;
      v19 = -53 - (v10 + word_173E580[v18]);
      v20 = 348 - 8 * v18;
      v21 = ((qword_173E2C8[v18] * (unsigned __int128)(unsigned __int64)v13) >> 64) + ((qword_173E2C8[v18] * v13) >> 63);
      v22 = v21 >> v19;
      v23 = (char *)a3[1];
      v24 = qword_1017C38[__clz((v21 >> v19) | 1) ^ 0x1F] + (unsigned int)(v21 >> v19);
      v25 = HIDWORD(v24);
      v84 = HIDWORD(v24);
      if ( BYTE4(a2) == 2 )
      {
        if ( v20 + HIDWORD(v24) >= 1 && 0x7FFFFFFF - (v20 + HIDWORD(v24)) < v5 )
        {
          v80 = (_QWORD *)sub_67EAFB8(16LL);
          sub_678FF58(v80, "number is too big");
          sub_67EB030((__int64)v80, (__int64)&`typeinfo for'fmt::v8::format_error, (__int64)sub_678FF84);
        }
        v5 += v20 + HIDWORD(v24);
        if ( v5 <= 0 )
        {
          if ( v5 < 0 )
          {
            v37 = 0;
          }
          else
          {
            v57 = qword_173E630[(__int64)(v24 - 0x100000000LL) >> 32] << v19;
            v58 = v21 / 0xA;
            if ( v57 - v21 / 0xA >= v21 / 0xA && v57 - 2 * v58 > 0x13 )
            {
              v74 = 48;
            }
            else
            {
              if ( v21 < 0x64 || v58 - 10 < v57 - (v58 - 10) )
              {
                v82 = v8;
                v37 = 0;
                v5 = 0;
                goto LABEL_96;
              }
              v74 = 49;
            }
            v37 = 1;
            *v23 = v74;
          }
          goto LABEL_115;
        }
      }
      v27 = 1LL << v19;
      v83 = 8 * v18;
      v82 = v8;
      v28 = (1LL << v19) - 1;
      if ( v5 <= 1 )
        v29 = 1;
      else
        v29 = v5;
      v81 = 348 - 8 * v18;
      v30 = 0LL;
      v31 = v28 & v21;
      v32 = (unsigned int)(v29 - 1);
      while ( 1 )
      {
        v33 = 0;
        LOBYTE(v34) = v22;
        switch ( (int)v25 )
        {
          case 1:
            break;
          case 2:
            v34 = (unsigned int)v22 / 0xA;
            v35 = 10;
            goto LABEL_31;
          case 3:
            v34 = (unsigned int)v22 / 0x64;
            v35 = 100;
            goto LABEL_31;
          case 4:
            v34 = (unsigned int)v22 / 0x3E8;
            v35 = 1000;
LABEL_31:
            v33 = v22 - v34 * v35;
            break;
          case 5:
            v34 = (unsigned int)v22 / 0x2710;
            v33 = (unsigned int)v22 % 0x2710;
            break;
          case 6:
            v34 = (unsigned int)v22 / 0x186A0;
            v33 = (unsigned int)v22 % 0x186A0;
            break;
          case 7:
            v34 = (unsigned int)v22 / 0xF4240;
            v33 = (unsigned int)v22 % 0xF4240;
            break;
          case 8:
            v34 = (unsigned int)v22 / 0x989680;
            v33 = (unsigned int)v22 % 0x989680;
            break;
          case 9:
            v34 = (unsigned int)v22 / 0x5F5E100;
            v33 = (unsigned int)v22 % 0x5F5E100;
            break;
          case 10:
            v34 = (unsigned int)v22 / 0x3B9ACA00;
            v33 = (unsigned int)v22 % 0x3B9ACA00;
            break;
          default:
            LOBYTE(v34) = 0;
            v33 = v22;
            break;
        }
        v36 = (int)v25 - 1LL;
        v84 = v36;
        v23[v30] = v34 + 48;
        if ( v32 == v30 )
          break;
        LODWORD(v25) = v84;
        ++v30;
        LODWORD(v22) = v33;
        if ( v84 <= 0 )
        {
          v37 = v30 + 1;
          v38 = (10 * v31) >> v19;
          v39 = (10 * v31) & v28;
          --v84;
          v23[v30] = v38 + 48;
          if ( v39 <= 0xA )
            goto LABEL_95;
          if ( v5 > (int)v37 )
          {
            v40 = 10LL;
            while ( 1 )
            {
              v41 = v40;
              v42 = 10 * v39;
              v38 = v42 >> v19;
              v39 = v42 & v28;
              v40 *= 10LL;
              --v84;
              v23[v30 + 1] = v38 + 48;
              if ( v39 <= v40 )
                break;
              if ( v5 <= (int)++v30 + 1 )
              {
                v37 = v30 + 1;
                goto LABEL_80;
              }
            }
            v37 = v30 + 2;
LABEL_95:
            LODWORD(a2) = v83;
LABEL_96:
            v84 += v37 - a2 + 347;
            if ( (v6 & 0x40000) != 0 )
            {
              v72 = a4;
              if ( LODWORD(v72) >= 0x800000 )
                v7 = LODWORD(v72) & 0x7FFFFF | 0x800000LL;
              else
                v7 = LODWORD(v72) & 0x7FFFFF;
              if ( LODWORD(v72) >= 0x800000 )
                v70 = (LODWORD(v72) >> 23) - 150;
              else
                v70 = -149;
              v71 = HIBYTE(LODWORD(v72)) != 0 && (LODWORD(v72) & 0x7FFFFF) == 0;
            }
            else
            {
              v70 = v82;
              v71 = (*(_QWORD *)&a4 & 0xFFFFFFFFFFFFFLL) == 0 && ((unsigned __int16)(*(_QWORD *)&a4 >> 52) & 0x7FFu) > 1;
            }
            if ( v5 >= 767 )
              v73 = 767;
            else
              v73 = v5;
            sub_67926CC(v7, v70, v71, v73, (__int64)a3, (unsigned int *)&v84);
            if ( v14 == 2 )
            {
LABEL_130:
              LODWORD(v45) = v84;
              return (unsigned int)v45;
            }
LABEL_120:
            if ( (v6 & 0x100000) != 0 )
              goto LABEL_130;
            v77 = a3[2];
            if ( v77 )
            {
              v78 = a3[1] - 1LL;
              while ( *(_BYTE *)(v78 + v77) == 48 )
              {
                --v77;
                ++v84;
                if ( !v77 )
                  goto LABEL_125;
              }
              v79 = a3[3];
              if ( v79 < v77 )
              {
                (*(void (__fastcall **)(_QWORD *, unsigned __int64))*a3)(a3, v77);
LABEL_126:
                v79 = a3[3];
              }
              if ( v79 >= v77 )
                v79 = v77;
              a3[2] = v79;
              goto LABEL_130;
            }
LABEL_125:
            v77 = 0LL;
            goto LABEL_126;
          }
          v41 = 1LL;
          v40 = 10LL;
LABEL_80:
          LODWORD(a2) = v83;
          if ( v27 <= v40 || v27 - v40 <= v40 )
            goto LABEL_96;
          if ( v27 - v39 >= v39 && 20 * v41 <= v27 - 2 * v39 )
            goto LABEL_112;
          v62 = v39 >= v40;
          v63 = v39 - v40;
          if ( !v62 || v63 < v27 - v63 )
            goto LABEL_96;
          v64 = v37;
          v65 = (unsigned int)v30;
          v66 = v37;
          v23[v65] = v38 + 49;
          do
          {
            v67 = v66 - 1;
            v68 = (unsigned int)(v66 - 1);
            if ( v23[v68] <= 57 )
              break;
            v69 = (unsigned int)(v66 - 2);
            v23[v68] = 48;
            --v66;
            ++v23[v69];
          }
          while ( (unsigned __int64)(v67 + 1) > 2 );
          if ( *v23 <= 57 )
          {
LABEL_112:
            v20 = v81;
          }
          else
          {
            v20 = v81;
            *v23 = 49;
            if ( BYTE4(a2) == 2 )
            {
              v37 = v65 + 2;
              v23[v64] = 48;
            }
            else
            {
              v20 = 349 - v83;
            }
          }
LABEL_115:
          v75 = v37;
          v76 = a3[3];
          v84 += v20;
          if ( v76 < v37 )
          {
            (*(void (__fastcall **)(_QWORD *, _QWORD))*a3)(a3, v37);
            v76 = a3[3];
          }
          if ( v76 >= v75 )
            v76 = v75;
          a3[2] = v76;
          if ( v14 == 2 )
            goto LABEL_130;
          goto LABEL_120;
        }
      }
      v52 = ((unsigned __int64)v33 << v19) + v31;
      v53 = qword_173E630[v36] << v19;
      v54 = v30 + 1;
      if ( v53 - v52 >= v52 )
      {
        if ( v53 - 2 * v52 >= 2 )
          goto LABEL_78;
        if ( !v52 )
        {
LABEL_63:
          LODWORD(a2) = 8 * v18;
          v37 = v30 + 1;
          goto LABEL_96;
        }
      }
      if ( v52 - 1 < v53 - (v52 - 1) )
        goto LABEL_63;
      v23[v32] = v34 + 49;
      if ( v29 != 1 )
      {
        v59 = v30;
        do
        {
          if ( v23[(unsigned int)v59] <= 57 )
            break;
          v23[(unsigned int)v59] = 48;
          v60 = v59-- + 1;
          ++v23[(unsigned int)v59];
        }
        while ( v60 > 2 );
      }
      if ( *v23 > 57 )
      {
        *v23 = 49;
        if ( BYTE4(a2) == 2 )
        {
          v61 = &v23[v30];
          v20 = 348 - 8 * v18;
          v37 = v29 + 1;
          v61[1] = 48;
        }
        else
        {
          v37 = v30 + 1;
          v20 = 349 - v83;
        }
        goto LABEL_115;
      }
LABEL_78:
      v20 = 348 - 8 * v18;
      v37 = v54;
      goto LABEL_115;
    }
    if ( (a2 & 0x4000000000000LL) != 0 )
    {
      v55 = a4;
      v56 = sub_6790624(v55);
      v45 = HIDWORD(v56);
      sub_679238C(a3, v56);
    }
    else
    {
      v50 = sub_6790A84(a4);
      LODWORD(v45) = v51;
      sub_6792518(a3, v50);
    }
  }
  return (unsigned int)v45;
}


================================================================================
Function: sub_679238C (0x679238C)
================================================================================

__int64 __fastcall sub_679238C(_QWORD *a1, unsigned int a2)
{
  _QWORD *v2; // x2
  __int64 v3; // x9
  __int64 v4; // x8
  __int64 v5; // x11
  __int64 v6; // x8
  unsigned int v7; // w14
  unsigned int v8; // w10
  unsigned int v9; // w13
  _BYTE *v10; // x8
  _BYTE *v11; // x9
  unsigned int v12; // w15
  unsigned int v13; // w10
  unsigned int v14; // w14
  _BYTE v16[12]; // [xsp+Ch] [xbp-14h] BYREF

  v2 = a1;
  v3 = a1[2];
  v4 = (__int64)(qword_1017C38[__clz(a2 | 1) ^ 0x1F] + a2) >> 32;
  if ( a1[3] < (unsigned __int64)(v4 + v3) || (v5 = a1[1], a1[2] = v4 + v3, !v5) )
  {
    v10 = &v16[v4];
    if ( a2 < 0x64 )
    {
      v11 = v10;
      v13 = a2;
      if ( a2 <= 9 )
      {
LABEL_11:
        *(v11 - 1) = v13 + 48;
        return sub_53712B8(v16, v10, a1);
      }
    }
    else
    {
      v11 = v10;
      do
      {
        v12 = a2 >> 4;
        v13 = a2 / 0x64;
        v14 = a2 % 0x64;
        a2 /= 0x64u;
        *((_WORD *)v11 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
        v11 -= 2;
      }
      while ( v12 > 0x270 );
      if ( v13 <= 9 )
        goto LABEL_11;
    }
    *((_WORD *)v11 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
    return sub_53712B8(v16, v10, a1);
  }
  v6 = v5 + v3 + v4;
  if ( a2 >= 0x64 )
  {
    do
    {
      v7 = a2 >> 4;
      v8 = a2 / 0x64;
      v9 = a2 % 0x64;
      a2 /= 0x64u;
      *(_WORD *)(v6 - 2) = *(_WORD *)&a00010203040506_1[2 * v9];
      v6 -= 2LL;
    }
    while ( v7 > 0x270 );
    if ( v8 <= 9 )
      goto LABEL_6;
LABEL_17:
    *(_WORD *)(v6 - 2) = *(_WORD *)&a00010203040506_1[2 * v8];
    return (__int64)v2;
  }
  v8 = a2;
  if ( a2 > 9 )
    goto LABEL_17;
LABEL_6:
  *(_BYTE *)(v6 - 1) = v8 + 48;
  return (__int64)v2;
}


================================================================================
Function: sub_6792518 (0x6792518)
================================================================================

__int64 __fastcall sub_6792518(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // x2
  unsigned __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x8
  __int64 v6; // x11
  __int64 v7; // x8
  bool v8; // cc
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x13
  _BYTE *v11; // x8
  _BYTE *v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x14
  _BYTE v16[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v2 = a1;
  v3 = byte_1017AEE[__clz(a2 | 1) ^ 0x3F];
  v4 = a1[2];
  v5 = (__PAIR128__(v3, a2) - qword_1017B30[v3]) >> 64;
  if ( a1[3] < (unsigned __int64)(v5 + v4) || (v6 = a1[1], a1[2] = v5 + v4, !v6) )
  {
    v11 = &v16[v5];
    if ( a2 < 0x64 )
    {
      v12 = v11;
      v13 = a2;
      if ( a2 <= 9 )
      {
LABEL_11:
        *(v12 - 1) = v13 + 48;
        return sub_53712B8((unsigned __int64)v16, (__int64)v11, (__int64)a1);
      }
    }
    else
    {
      v12 = v11;
      do
      {
        v8 = a2 >> 4 > 0x270;
        v13 = a2 / 0x64;
        v14 = a2 % 0x64;
        a2 /= 0x64uLL;
        *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
        v12 -= 2;
      }
      while ( v8 );
      if ( v13 <= 9 )
        goto LABEL_11;
    }
    *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
    return sub_53712B8((unsigned __int64)v16, (__int64)v11, (__int64)a1);
  }
  v7 = v6 + v4 + v5;
  if ( a2 >= 0x64 )
  {
    do
    {
      v8 = a2 >> 4 > 0x270;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64uLL;
      *(_WORD *)(v7 - 2) = *(_WORD *)&a00010203040506_1[2 * v10];
      v7 -= 2LL;
    }
    while ( v8 );
    if ( v9 <= 9 )
      goto LABEL_6;
LABEL_17:
    *(_WORD *)(v7 - 2) = *(_WORD *)&a00010203040506_1[2 * v9];
    return (__int64)v2;
  }
  v9 = a2;
  if ( a2 > 9 )
    goto LABEL_17;
LABEL_6:
  *(_BYTE *)(v7 - 1) = v9 + 48;
  return (__int64)v2;
}


================================================================================
Function: sub_67926CC (0x67926CC)
================================================================================

const void *__fastcall sub_67926CC(__int64 a1, unsigned int a2, char a3, int a4, __int64 a5, unsigned int *a6)
{
  long double v6; // q0
  unsigned int v7; // w25
  __int64 v8; // x21
  char v11; // w23
  unsigned __int64 v12; // x19
  unsigned __int64 v13; // x20
  char *v14; // x9
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x19
  unsigned int v17; // w26
  unsigned __int64 v18; // x20
  unsigned __int64 v19; // x8
  unsigned __int64 v20; // x19
  unsigned __int64 v21; // x8
  __int64 v22; // x8
  long double v23; // q0
  __int64 v24; // x8
  __int64 (__fastcall ***v25)(); // x22
  __int64 v26; // x19
  __int64 v27; // x0
  unsigned __int64 v28; // x8
  __int64 v29; // x20
  __int64 v30; // x8
  __int64 v31; // x10
  unsigned __int64 v32; // x24
  _DWORD *v33; // x9
  __int64 v34; // x11
  unsigned __int64 v35; // x12
  __int64 v36; // x1
  int v37; // w0
  int v38; // w10
  int v39; // w11
  __int64 v40; // x5
  __int64 (__fastcall ***v41)(); // x24
  __int64 v42; // x21
  int v43; // w23
  __int64 *v44; // x25
  __int128 *v45; // x27
  void **p_dest; // x8
  __int64 v47; // x20
  char v48; // w0
  int v49; // w10
  int v50; // w9
  bool v51; // cc
  int v52; // w11
  unsigned int v53; // w12
  int v54; // w13
  int v55; // w11
  int v56; // w15
  unsigned int v57; // w1
  unsigned int v58; // w17
  int v59; // w10
  int v60; // w11
  int v61; // w12
  int v62; // w15
  int v63; // w14
  int v64; // w8
  int v65; // w15
  unsigned __int64 v66; // x1
  int v67; // w5
  int v68; // w6
  unsigned int v69; // w7
  unsigned int v70; // w19
  unsigned int v71; // w26
  unsigned __int64 v72; // x7
  unsigned __int64 v73; // x1
  bool v74; // cf
  unsigned __int64 v75; // x1
  int v76; // w8
  __int64 v77; // x19
  __int64 v78; // x8
  __int64 v79; // x10
  unsigned __int64 v80; // x20
  _DWORD *v81; // x9
  __int64 v82; // x11
  unsigned __int64 v83; // x12
  __int64 v84; // x1
  __int64 v85; // x8
  __int64 v86; // x10
  unsigned __int64 v87; // x20
  _DWORD *v88; // x9
  __int64 v89; // x11
  unsigned __int64 v90; // x12
  __int64 v91; // x1
  __int64 v92; // x8
  __int64 v93; // x10
  unsigned __int64 v94; // x26
  __int64 v95; // x9
  __int64 v96; // x11
  unsigned __int64 v97; // x12
  __int64 v98; // x1
  int v99; // w10
  int v100; // w11
  int v101; // w12
  unsigned __int64 v102; // x17
  int v103; // w15
  int v104; // w16
  int v105; // w1
  unsigned int v106; // w3
  __int64 v107; // x2
  unsigned int v108; // w4
  unsigned __int64 v109; // x2
  unsigned __int64 v110; // x17
  unsigned __int64 v111; // x2
  bool v112; // w8
  __int64 v113; // x12
  __int64 v114; // x20
  __int64 v115; // x9
  unsigned __int64 v116; // x19
  _BYTE *v117; // x8
  __int64 v118; // x11
  unsigned __int64 v119; // x13
  __int64 v120; // x1
  int v121; // w10
  int v122; // w11
  char v123; // w19
  int v124; // w12
  unsigned __int64 v125; // x17
  int v126; // w15
  int v127; // w16
  int v128; // w1
  unsigned int v129; // w3
  __int64 v130; // x2
  unsigned int v131; // w4
  unsigned __int64 v132; // x2
  unsigned __int64 v133; // x17
  unsigned __int64 v134; // x2
  bool v135; // w8
  unsigned __int64 v136; // x26
  unsigned __int64 v137; // x8
  __int64 v138; // x8
  __int64 v139; // x1
  __int64 v140; // x9
  int v141; // w8
  unsigned __int64 v142; // x22
  unsigned __int64 v143; // x8
  unsigned __int64 v144; // x8
  __int64 v145; // x8
  __int64 v146; // x8
  int v147; // w13
  unsigned __int64 v148; // x17
  int v149; // w16
  int v150; // w12
  int v151; // w0
  unsigned int v152; // w2
  __int64 v153; // x1
  unsigned int v154; // w3
  unsigned __int64 v155; // x1
  unsigned __int64 v156; // x17
  unsigned __int64 v157; // x17
  __int64 v158; // x8
  __int64 v159; // x10
  _BYTE *v160; // x8
  __int64 v161; // x8
  unsigned __int64 v162; // x20
  __int64 v163; // x10
  _DWORD *v164; // x9
  __int64 v165; // x13
  __int64 v166; // x14
  unsigned __int64 v167; // x15
  __int64 v168; // x8
  __int64 v169; // x1
  unsigned __int64 v170; // x8
  const void *result; // x0
  void **v172; // [xsp+8h] [xbp-308h]
  __int64 *v174; // [xsp+30h] [xbp-2E0h]
  __int64 (__fastcall **v176)(); // [xsp+40h] [xbp-2D0h] BYREF
  void *v177; // [xsp+48h] [xbp-2C8h]
  __int128 v178; // [xsp+50h] [xbp-2C0h]
  _BYTE v179[136]; // [xsp+60h] [xbp-2B0h] BYREF
  int v180; // [xsp+E8h] [xbp-228h]
  __int64 (__fastcall **v181)(); // [xsp+F0h] [xbp-220h] BYREF
  void *dest; // [xsp+F8h] [xbp-218h] BYREF
  __int128 v183; // [xsp+100h] [xbp-210h] BYREF
  _BYTE v184[136]; // [xsp+110h] [xbp-200h] BYREF
  int v185; // [xsp+198h] [xbp-178h]
  __int64 (__fastcall **v186)(); // [xsp+1A0h] [xbp-170h] BYREF
  _BYTE *v187; // [xsp+1A8h] [xbp-168h]
  __int128 v188; // [xsp+1B0h] [xbp-160h]
  _BYTE v189[136]; // [xsp+1C0h] [xbp-150h] BYREF
  int v190; // [xsp+248h] [xbp-C8h]
  __int64 (__fastcall **v191)(); // [xsp+250h] [xbp-C0h] BYREF
  unsigned int *v192; // [xsp+258h] [xbp-B8h]
  __int128 v193; // [xsp+260h] [xbp-B0h]
  _DWORD v194[34]; // [xsp+270h] [xbp-A0h] BYREF
  int v195; // [xsp+2F8h] [xbp-18h]

  v6 = *(long double *)&xmmword_AF9ED0;
  if ( (a3 & 1) != 0 )
    v7 = 2;
  else
    v7 = 1;
  LODWORD(v8) = a4;
  v11 = a1;
  v12 = a1 << v7;
  v191 = off_6BE0B58;
  v192 = v194;
  v193 = xmmword_AF9ED0;
  v186 = off_6BE0B58;
  v187 = v189;
  v195 = 0;
  v188 = xmmword_AF9ED0;
  v181 = off_6BE0B58;
  dest = v184;
  v190 = 0;
  v183 = xmmword_AF9ED0;
  v185 = 0;
  v176 = off_6BE0B58;
  v177 = v179;
  v178 = xmmword_AF9ED0;
  v180 = 0;
  if ( (a2 & 0x80000000) != 0 )
  {
    v17 = *a6;
    if ( (*a6 & 0x80000000) == 0 )
    {
      v18 = 0LL;
      do
      {
        v194[v18] = v12;
        v12 >>= 32;
        ++v18;
      }
      while ( v12 );
      v19 = v18 - 1;
      if ( v18 - 1 >= 0x20 )
      {
        if ( v19 >= 0x30 )
        {
          v20 = v18;
          if ( v19 >= 0x3FFFFFFFFFFFFFFFLL )
            sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        }
        else
        {
          v20 = 48LL;
        }
        v192 = (unsigned int *)sub_6575418();
        *((_QWORD *)&v193 + 1) = v20;
      }
      else
      {
        v20 = 32LL;
      }
      v195 = 0;
      if ( v20 >= v18 )
        v144 = v18;
      else
        v144 = v20;
      *(_QWORD *)&v193 = v144;
      sub_679D038(&v186, v17, v6);
      sub_679CF0C(&v186, v7 - a2);
      *(_DWORD *)dest = 1;
      v145 = *((_QWORD *)&v183 + 1);
      if ( !*((_QWORD *)&v183 + 1) )
      {
        ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v181)(&v181, 1LL);
        v145 = *((_QWORD *)&v183 + 1);
      }
      v185 = 0;
      *(_QWORD *)&v183 = v145 != 0;
      if ( (a3 & 1) != 0 )
      {
        *(_DWORD *)v177 = 2;
        v146 = *((_QWORD *)&v178 + 1);
        if ( !*((_QWORD *)&v178 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v176)(&v176, 1LL);
          v146 = *((_QWORD *)&v178 + 1);
        }
        v25 = &v176;
        v180 = 0;
        *(_QWORD *)&v178 = v146 != 0;
      }
      else
      {
        v25 = 0LL;
      }
      goto LABEL_29;
    }
    sub_679D038(&v191, -v17, *(long double *)&xmmword_AF9ED0);
    v136 = v193;
    if ( *((_QWORD *)&v183 + 1) >= (unsigned __int64)v193 )
    {
      *(_QWORD *)&v183 = v193;
      if ( !(_QWORD)v193 )
        goto LABEL_187;
    }
    else
    {
      ((void (__fastcall *)(__int64 (__fastcall ***)(), _QWORD))*v181)(&v181, v193);
      v137 = *((_QWORD *)&v183 + 1);
      if ( *((_QWORD *)&v183 + 1) >= v136 )
        v137 = v136;
      *(_QWORD *)&v183 = v137;
    }
    memmove(dest, v192, 4 * v136);
LABEL_187:
    v141 = v195;
    v185 = v195;
    if ( (a3 & 1) == 0 )
    {
      v25 = 0LL;
      goto LABEL_235;
    }
    v142 = v193;
    if ( *((_QWORD *)&v178 + 1) >= (unsigned __int64)v193 )
    {
      *(_QWORD *)&v178 = v193;
      if ( !(_QWORD)v193 )
      {
LABEL_234:
        v25 = &v176;
        v180 = v141;
        sub_679CF0C(&v176, 1LL);
LABEL_235:
        v161 = v193;
        if ( (_QWORD)v193 )
        {
          v162 = 0LL;
          v163 = 0LL;
          v164 = v192;
          do
          {
            v165 = v163++;
            v166 = (unsigned int)v164[v165];
            v167 = ((unsigned int)v12 & 0xFFFFFFFE) * v166 + (unsigned int)v162;
            v162 = HIDWORD(v12) * v166 + HIDWORD(v162) + HIDWORD(v167);
            v164[v165] = v167;
          }
          while ( v161 != v163 );
          for ( ; v162; v161 = v169 )
          {
            v169 = v161 + 1;
            if ( *((_QWORD *)&v193 + 1) < (unsigned __int64)(v161 + 1) )
            {
              ((void (__fastcall *)(__int64 (__fastcall ***)()))*v191)(&v191);
              v164 = v192;
              v161 = v193;
              v169 = v193 + 1;
            }
            *(_QWORD *)&v193 = v169;
            v164[v161] = v162;
            v162 >>= 32;
          }
        }
        *(_DWORD *)v187 = 1;
        v168 = *((_QWORD *)&v188 + 1);
        if ( !*((_QWORD *)&v188 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v186)(&v186, 1LL);
          v168 = *((_QWORD *)&v188 + 1);
        }
        v190 = 0;
        *(_QWORD *)&v188 = v168 != 0;
        sub_679CF0C(&v186, v7 - a2);
        goto LABEL_29;
      }
    }
    else
    {
      ((void (__fastcall *)(__int64 (__fastcall ***)(), _QWORD))*v176)(&v176, v193);
      v143 = *((_QWORD *)&v178 + 1);
      if ( *((_QWORD *)&v178 + 1) >= v142 )
        v143 = v142;
      *(_QWORD *)&v178 = v143;
    }
    memmove(v177, v192, 4 * v142);
    v141 = v195;
    goto LABEL_234;
  }
  v13 = 0LL;
  do
  {
    v14 = (char *)&v191 + 4 * v13++;
    *((_DWORD *)v14 + 8) = v12;
    v12 >>= 32;
  }
  while ( v12 );
  v15 = v13 - 1;
  if ( v13 - 1 >= 0x20 )
  {
    if ( v15 >= 0x30 )
    {
      v16 = v13;
      if ( v15 >= 0x3FFFFFFFFFFFFFFFLL )
        sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    }
    else
    {
      v16 = 48LL;
    }
    v192 = (unsigned int *)sub_6575418();
    *((_QWORD *)&v193 + 1) = v16;
  }
  else
  {
    v16 = 32LL;
  }
  v195 = 0;
  if ( v16 >= v13 )
    v21 = v13;
  else
    v21 = v16;
  *(_QWORD *)&v193 = v21;
  sub_679CF0C(&v191, a2);
  *(_DWORD *)dest = 1;
  v22 = *((_QWORD *)&v183 + 1);
  if ( !*((_QWORD *)&v183 + 1) )
  {
    ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v181)(&v181, 1LL);
    v22 = *((_QWORD *)&v183 + 1);
  }
  v185 = 0;
  *(_QWORD *)&v183 = v22 != 0;
  sub_679CF0C(&v181, a2);
  if ( (a3 & 1) != 0 )
  {
    *(_DWORD *)v177 = 1;
    v24 = *((_QWORD *)&v178 + 1);
    if ( !*((_QWORD *)&v178 + 1) )
    {
      ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))*v176)(&v176, 1LL);
      v24 = *((_QWORD *)&v178 + 1);
    }
    v25 = &v176;
    v180 = 0;
    *(_QWORD *)&v178 = v24 != 0;
    sub_679CF0C(&v176, a2 + 1);
  }
  else
  {
    v25 = 0LL;
  }
  sub_679D038(&v186, *a6, v23);
  sub_679CF0C(&v186, v7);
LABEL_29:
  if ( (v8 & 0x80000000) == 0 )
  {
    v26 = (int)v8 - 1LL;
    *a6 -= v26;
    if ( (_DWORD)v8 )
    {
      v27 = a5;
      v28 = *(_QWORD *)(a5 + 24);
      if ( v28 < (unsigned int)v8 )
      {
        (**(void (__fastcall ***)(__int64, _QWORD))a5)(a5, (unsigned int)v8);
        v27 = a5;
        v28 = *(_QWORD *)(a5 + 24);
      }
      if ( v28 >= (unsigned int)v8 )
        v28 = (unsigned int)v8;
      *(_QWORD *)(v27 + 16) = v28;
      if ( (unsigned int)v8 >= 2 )
      {
        v29 = 0LL;
        do
        {
          *(_BYTE *)(*(_QWORD *)(a5 + 8) + v29) = sub_679D1A8(&v191, &v186) + 48;
          v30 = v193;
          if ( (_QWORD)v193 )
          {
            v31 = 0LL;
            v32 = 0LL;
            v33 = v192;
            do
            {
              v34 = v31++;
              v35 = v32 + 10LL * (unsigned int)v33[v34];
              v32 = HIDWORD(v35);
              v33[v34] = v35;
            }
            while ( v30 != v31 );
            if ( HIDWORD(v35) )
            {
              v36 = v30 + 1;
              if ( *((_QWORD *)&v193 + 1) < (unsigned __int64)(v30 + 1) )
              {
                ((void (__fastcall *)(__int64 (__fastcall ***)()))*v191)(&v191);
                v33 = v192;
                v30 = v193;
                v36 = v193 + 1;
              }
              *(_QWORD *)&v193 = v36;
              v33[v30] = v32;
            }
          }
          ++v29;
        }
        while ( v29 != (unsigned int)v26 );
      }
      v37 = sub_679D1A8(&v191, &v186);
      v38 = v195 + v193;
      v39 = v190 + v188;
      if ( v195 + (int)v193 + 1 >= v190 + (int)v188 )
      {
        v40 = a5;
        if ( v38 <= v39 )
        {
          if ( v190 >= v195 )
            v124 = v195;
          else
            v124 = v190;
          if ( v39 <= v124 )
          {
            v135 = 0;
LABEL_222:
            if ( (v37 & 1) == 0 || v135 )
              goto LABEL_231;
          }
          else
          {
            v125 = 0LL;
            v126 = ~v195;
            v127 = v188 - 1;
            v128 = v190 + v188;
            while ( 1 )
            {
              v129 = 0;
              v130 = 0LL;
              if ( v128 > v195 && v38 >= v128 )
              {
                v130 = v192[v126 + v128];
                v129 = v192[v126 + v128];
              }
              v131 = 0;
              if ( v128 > v190 && v39 >= v128 )
                v131 = *(_DWORD *)&v187[4 * v127];
              v132 = v130 + v129;
              v133 = v125 | v131;
              v74 = v133 >= v132;
              v134 = v133 - v132;
              if ( !v74 )
                break;
              if ( v134 > 1 )
                goto LABEL_231;
              --v128;
              v125 = v134 << 32;
              --v127;
              if ( v128 <= v124 )
              {
                v135 = v134 != 0;
                goto LABEL_222;
              }
            }
          }
        }
        if ( v37 == 9 )
        {
          v158 = (unsigned int)(v8 - 2);
          *(_BYTE *)(*(_QWORD *)(a5 + 8) + v26) = 58;
          if ( (unsigned int)v8 >= 2 )
          {
            do
            {
              v8 = (unsigned int)(v8 - 1);
              v159 = *(_QWORD *)(a5 + 8);
              if ( *(_BYTE *)(v159 + v8) != 58 )
                break;
              *(_BYTE *)(v159 + v8) = 48;
              ++*(_BYTE *)(*(_QWORD *)(a5 + 8) + v158--);
            }
            while ( (int)v8 > 1 );
          }
          v160 = *(_BYTE **)(a5 + 8);
          if ( *v160 == 58 )
          {
            *v160 = 49;
            ++*a6;
          }
          goto LABEL_254;
        }
        LOBYTE(v37) = v37 + 1;
      }
      else
      {
        v40 = a5;
      }
LABEL_231:
      *(_BYTE *)(*(_QWORD *)(v40 + 8) + v26) = v37 + 48;
      goto LABEL_254;
    }
    v113 = v188;
    v114 = a5;
    if ( (_QWORD)v188 )
    {
      v115 = 0LL;
      v116 = 0LL;
      v117 = v187;
      do
      {
        v118 = 4 * v115++;
        v119 = v116 + 10LL * *(unsigned int *)&v117[v118];
        v116 = HIDWORD(v119);
        *(_DWORD *)&v117[v118] = v119;
      }
      while ( v113 != v115 );
      if ( HIDWORD(v119) )
      {
        v120 = v113 + 1;
        if ( *((_QWORD *)&v188 + 1) < (unsigned __int64)(v113 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)()))*v186)(&v186);
          v117 = v187;
          v113 = v188;
          v120 = v188 + 1;
        }
        *(_QWORD *)&v188 = v120;
        *(_DWORD *)&v117[4 * v113] = v116;
        LODWORD(v113) = v120;
      }
      v114 = a5;
    }
    v121 = v195 + v193;
    v122 = v190 + v113;
    if ( v195 + (int)v193 + 1 < v190 + (int)v113 )
      goto LABEL_156;
    if ( v121 <= v122 )
    {
      if ( v190 >= v195 )
        v147 = v195;
      else
        v147 = v190;
      if ( v122 <= v147 )
      {
LABEL_156:
        v123 = 48;
LABEL_182:
        v138 = *(_QWORD *)(v114 + 16);
        v139 = v138 + 1;
        if ( *(_QWORD *)(v114 + 24) < (unsigned __int64)(v138 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v114)(v114);
          v138 = *(_QWORD *)(v114 + 16);
          v139 = v138 + 1;
        }
        v140 = *(_QWORD *)(v114 + 8);
        *(_QWORD *)(v114 + 16) = v139;
        *(_BYTE *)(v140 + v138) = v123;
        goto LABEL_254;
      }
      v148 = 0LL;
      v149 = ~v195;
      v150 = v113 - 1;
      v151 = v122;
      v123 = 48;
      while ( 1 )
      {
        v152 = 0;
        v153 = 0LL;
        if ( v151 > v195 && v121 >= v151 )
        {
          v153 = v192[v149 + v151];
          v152 = v192[v149 + v151];
        }
        v154 = 0;
        if ( v151 > v190 && v122 >= v151 )
          v154 = *(_DWORD *)&v187[4 * v150];
        v155 = v153 + v152;
        v156 = v148 | v154;
        v74 = v156 >= v155;
        v157 = v156 - v155;
        if ( !v74 )
          break;
        if ( v157 <= 1 )
        {
          --v151;
          v148 = v157 << 32;
          --v150;
          if ( v151 > v147 )
            continue;
        }
        goto LABEL_182;
      }
    }
    v123 = 49;
    goto LABEL_182;
  }
  if ( v25 )
    v41 = v25;
  else
    v41 = &v181;
  v42 = *(_QWORD *)(a5 + 8);
  v43 = (v11 & 1) == 0;
  v44 = (__int64 *)(v25 + 2);
  if ( v25 )
    v45 = (__int128 *)(v25 + 2);
  else
    v45 = &v183;
  if ( v25 )
    p_dest = (void **)(v25 + 1);
  else
    p_dest = &dest;
  v47 = 0LL;
  v174 = (__int64 *)(v25 + 1);
  v172 = p_dest;
  while ( 1 )
  {
    v48 = sub_679D1A8(&v191, &v186);
    v49 = v193;
    v50 = v195 + v193;
    v51 = v195 + (int)v193 <= v185 + (int)v183;
    if ( v195 + (_DWORD)v193 != v185 + (_DWORD)v183 )
    {
LABEL_66:
      if ( v51 )
        v59 = -1;
      else
        v59 = 1;
      goto LABEL_69;
    }
    v52 = v193 - 1;
    v53 = v183 - 1;
    v54 = (v52 - v53) & ~((int)(v52 - v53) >> 31);
    if ( v54 >= (int)v193 )
    {
      v51 = v52 <= (int)v53;
      if ( v52 != v53 )
        goto LABEL_66;
    }
    else
    {
      v55 = v54 - 1;
      v56 = v183 + ~(_DWORD)v193 + v54;
      do
      {
        --v49;
        v57 = *((_DWORD *)dest + v53);
        v58 = v192[v49];
        if ( v58 != v57 )
        {
          if ( v58 > v57 )
            v59 = 1;
          else
            v59 = -1;
          goto LABEL_69;
        }
        --v53;
      }
      while ( v49 > v54 );
      v51 = v55 <= v56;
      if ( v55 != v56 )
        goto LABEL_66;
    }
    v59 = 0;
LABEL_69:
    v60 = *((_DWORD *)v41 + 42);
    v61 = v60 + *(_DWORD *)v45;
    v62 = v50 >= v61 ? v195 + v193 : v60 + *(_DWORD *)v45;
    v63 = v190 + v188;
    if ( v62 + 1 >= v190 + (int)v188 )
    {
      if ( v62 > v63 )
        goto LABEL_75;
      if ( v60 >= v195 )
        v65 = v195;
      else
        v65 = *((_DWORD *)v41 + 42);
      if ( v190 < v65 )
        v65 = v190;
      if ( v63 > v65 )
      {
        v66 = 0LL;
        v67 = v188 - 1;
        v68 = v190 + v188;
        while ( 1 )
        {
          v69 = 0;
          if ( v68 > v195 && v50 >= v68 )
            v69 = v192[~v195 + v68];
          v70 = 0;
          if ( v68 > v60 && v61 >= v68 )
            v70 = *((_DWORD *)*v172 + (unsigned int)(~v60 + v68));
          v71 = 0;
          if ( v68 > v190 && v63 >= v68 )
            v71 = *(_DWORD *)&v187[4 * v67];
          v72 = v69 + (unsigned __int64)v70;
          v73 = v66 | v71;
          v74 = v73 >= v72;
          v75 = v73 - v72;
          if ( !v74 )
            break;
          if ( v75 > 1 )
            goto LABEL_73;
          --v68;
          v66 = v75 << 32;
          --v67;
          if ( v68 <= v65 )
            goto LABEL_101;
        }
LABEL_75:
        v64 = 1;
        goto LABEL_104;
      }
      v66 = 0LL;
LABEL_101:
      v64 = v66 ? -1 : 0;
    }
    else
    {
LABEL_73:
      v64 = -1;
    }
LABEL_104:
    v76 = v64 + v43;
    v77 = v47 + 1;
    *(_BYTE *)(v42 + v47) = v48 + 48;
    if ( v59 < v43 || v76 >= 1 )
      break;
    v78 = v193;
    if ( (_QWORD)v193 )
    {
      v79 = 0LL;
      v80 = 0LL;
      v81 = v192;
      do
      {
        v82 = v79++;
        v83 = v80 + 10LL * (unsigned int)v81[v82];
        v80 = HIDWORD(v83);
        v81[v82] = v83;
      }
      while ( v78 != v79 );
      if ( HIDWORD(v83) )
      {
        v84 = v78 + 1;
        if ( *((_QWORD *)&v193 + 1) < (unsigned __int64)(v78 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)()))*v191)(&v191);
          v81 = v192;
          v78 = v193;
          v84 = v193 + 1;
        }
        *(_QWORD *)&v193 = v84;
        v81[v78] = v80;
      }
    }
    v85 = v183;
    if ( (_QWORD)v183 )
    {
      v86 = 0LL;
      v87 = 0LL;
      v88 = dest;
      do
      {
        v89 = v86++;
        v90 = v87 + 10LL * (unsigned int)v88[v89];
        v87 = HIDWORD(v90);
        v88[v89] = v90;
      }
      while ( v85 != v86 );
      if ( HIDWORD(v90) )
      {
        v91 = v85 + 1;
        if ( *((_QWORD *)&v183 + 1) < (unsigned __int64)(v85 + 1) )
        {
          ((void (__fastcall *)(__int64 (__fastcall ***)()))*v181)(&v181);
          v88 = dest;
          v85 = v183;
          v91 = v183 + 1;
        }
        *(_QWORD *)&v183 = v91;
        v88[v85] = v87;
      }
    }
    v47 = v77;
    if ( v25 )
    {
      v92 = *v44;
      v47 = v77;
      if ( *v44 )
      {
        v93 = 0LL;
        v94 = 0LL;
        v95 = *v174;
        do
        {
          v96 = 4 * v93++;
          v97 = v94 + 10LL * *(unsigned int *)(v95 + v96);
          v94 = HIDWORD(v97);
          *(_DWORD *)(v95 + v96) = v97;
        }
        while ( v92 != v93 );
        v47 = v77;
        if ( HIDWORD(v97) )
        {
          v98 = v92 + 1;
          if ( (unsigned __int64)v25[3] < v92 + 1 )
          {
            ((void (__fastcall *)(__int64 (__fastcall ***)()))**v41)(v25);
            v92 = *v44;
            v98 = *v44 + 1;
            v95 = *v174;
          }
          v47 = v77;
          *v44 = v98;
          *(_DWORD *)(v95 + 4 * v92) = v94;
        }
      }
    }
  }
  if ( v59 >= v43 )
    goto LABEL_248;
  if ( v76 >= 1 )
  {
    v99 = v195 + v193;
    v100 = v190 + v188;
    if ( v195 + (int)v193 + 1 >= v190 + (int)v188 )
    {
      if ( v99 > v100 )
        goto LABEL_248;
      if ( v190 >= v195 )
        v101 = v195;
      else
        v101 = v190;
      if ( v100 > v101 )
      {
        v102 = 0LL;
        v103 = ~v195;
        v104 = v188 - 1;
        v105 = v190 + v188;
        while ( 1 )
        {
          v106 = 0;
          v107 = 0LL;
          if ( v105 > v195 && v99 >= v105 )
          {
            v107 = v192[v103 + v105];
            v106 = v192[v103 + v105];
          }
          v108 = 0;
          if ( v105 > v190 && v100 >= v105 )
            v108 = *(_DWORD *)&v187[4 * v104];
          v109 = v107 + v106;
          v110 = v102 | v108;
          v74 = v110 >= v109;
          v111 = v110 - v109;
          if ( !v74 )
            goto LABEL_248;
          if ( v111 > 1 )
            goto LABEL_249;
          --v105;
          v102 = v111 << 32;
          --v104;
          if ( v105 <= v101 )
          {
            v112 = v111 != 0;
            goto LABEL_246;
          }
        }
      }
      v112 = 0;
LABEL_246:
      if ( (v48 & 1) != 0 && !v112 )
LABEL_248:
        *(_BYTE *)(v42 + (unsigned int)v47) = v48 + 49;
    }
  }
LABEL_249:
  v170 = *(_QWORD *)(a5 + 24);
  if ( v170 < (unsigned int)(v47 + 1) )
  {
    (**(void (__fastcall ***)(__int64, _QWORD))a5)(a5, (unsigned int)(v47 + 1));
    v170 = *(_QWORD *)(a5 + 24);
  }
  if ( v170 >= (unsigned int)(v47 + 1) )
    v170 = (unsigned int)(v47 + 1);
  *(_QWORD *)(a5 + 16) = v170;
  *a6 -= v47;
LABEL_254:
  if ( v177 != v179 )
    sub_6575460();
  if ( dest != v184 )
    sub_6575460();
  if ( v187 != v189 )
    sub_6575460();
  result = v192;
  if ( v192 != v194 )
    return (const void *)sub_6575460();
  return result;
}


================================================================================
Function: sub_67935A0 (0x67935A0)
================================================================================

__int64 __fastcall sub_67935A0(unsigned int a1, unsigned __int64 a2, _QWORD *a3, long double a4)
{
  unsigned __int64 v7; // x23
  __int64 v8; // x1
  __int64 v9; // x0
  __int64 v10; // x2
  unsigned __int64 v11; // x8
  void *v12; // x0
  unsigned __int64 v13; // x20
  __int64 v15; // x8
  __int64 v16; // x1
  __int64 v17; // x9
  double v18; // d0
  unsigned __int64 v19; // x0
  int v20; // w1
  long double v21; // q0
  __int64 v22; // x3
  unsigned __int64 v23; // x20
  __int64 v24; // x8
  unsigned __int64 v25; // x8
  long double v26; // q0
  unsigned __int64 v27; // x0
  int v29; // [xsp+14h] [xbp-Ch] BYREF

  v7 = HIDWORD(a2);
  if ( (int)sub_67EE758(a4, *(long double *)&xmmword_AF69A0) <= 0 )
  {
    if ( (int)a1 >= 1 && (unsigned __int8)v7 == 2 )
    {
      v11 = a3[3];
      if ( v11 < a1 )
      {
        (*(void (__fastcall **)(_QWORD *, _QWORD))*a3)(a3, a1);
        v11 = a3[3];
      }
      v12 = (void *)a3[1];
      if ( v11 >= a1 )
        v11 = a1;
      a3[2] = v11;
      memset(v12, 48, a1);
      LODWORD(v13) = -a1;
    }
    else
    {
      v15 = a3[2];
      v16 = v15 + 1;
      if ( a3[3] < (unsigned __int64)(v15 + 1) )
      {
        (*(void (__fastcall **)(_QWORD *))*a3)(a3);
        v15 = a3[2];
        v16 = v15 + 1;
      }
      v17 = a3[1];
      LODWORD(v13) = 0;
      a3[2] = v16;
      *(_BYTE *)(v17 + v15) = 48;
    }
    return (unsigned int)v13;
  }
  if ( (v7 & 0x80000) != 0 )
    return sub_6791778(a1, a2, a3, a4);
  if ( (a1 & 0x80000000) != 0 )
  {
    if ( (v7 & 0x40000) != 0 )
    {
      v26 = sub_67EF4DC(a4);
      v27 = sub_6790624(v26);
      v13 = HIDWORD(v27);
      sub_679238C(a3, v27);
    }
    else
    {
      v18 = sub_67EF318(a4);
      v19 = sub_6790A84(v18);
      LODWORD(v13) = v20;
      sub_6792518(a3, v19);
    }
    return (unsigned int)v13;
  }
  v29 = 0;
  if ( (v7 & 0x40000) != 0 )
  {
    v21 = sub_67EF4DC(a4);
    if ( LODWORD(v21) >= 0x800000 )
      v9 = LODWORD(v21) & 0x7FFFFF | 0x800000LL;
    else
      v9 = LODWORD(v21) & 0x7FFFFF;
    if ( LODWORD(v21) >= 0x800000 )
      v8 = (unsigned int)((LODWORD(v21) >> 23) - 150);
    else
      v8 = 4294967147LL;
    v10 = (HIBYTE(LODWORD(v21)) != 0) & (unsigned __int8)((LODWORD(v21) & 0x7FFFFF) == 0);
  }
  else
  {
    v8 = 0LL;
    v9 = 0LL;
    v10 = 0LL;
  }
  if ( a1 >= 0x2FF )
    v22 = 767LL;
  else
    v22 = a1;
  sub_67926CC(v9, v8, v10, v22, a3, &v29);
  if ( BYTE4(a2) != 2 && (v7 & 0x100000) == 0 )
  {
    v23 = a3[2];
    if ( v23 )
    {
      v24 = a3[1] - 1LL;
      while ( *(_BYTE *)(v24 + v23) == 48 )
      {
        --v23;
        ++v29;
        if ( !v23 )
          goto LABEL_35;
      }
      v25 = a3[3];
      if ( v25 >= v23 )
        goto LABEL_37;
      (*(void (__fastcall **)(_QWORD *, unsigned __int64))*a3)(a3, v23);
    }
    else
    {
LABEL_35:
      v23 = 0LL;
    }
    v25 = a3[3];
LABEL_37:
    if ( v25 >= v23 )
      v25 = v23;
    a3[2] = v25;
  }
  LODWORD(v13) = v29;
  return (unsigned int)v13;
}


================================================================================
Function: sub_6793834 (0x6793834)
================================================================================

__int64 __fastcall sub_6793834(__int64 a1, int a2)
{
  __int64 v2; // x21
  __int64 v3; // x19
  __int64 v4; // x8
  __int64 v5; // x22
  unsigned __int64 v6; // x9
  __int64 v7; // x10
  _BYTE *v8; // x8
  _BYTE *v9; // x8
  unsigned int v10; // w14
  unsigned int v11; // w10
  unsigned int v12; // w13
  __int64 v13; // x8
  __int64 v14; // x1
  __int64 v15; // x9
  _BYTE *v16; // x8
  unsigned int v17; // w14
  unsigned int v18; // w9
  unsigned int v19; // w13
  _BYTE v21[12]; // [xsp+Ch] [xbp-14h] BYREF

  if ( a2 >= 0 )
    v2 = (unsigned int)a2;
  else
    v2 = (unsigned int)-a2;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 16);
  v5 = (qword_1017C38[__clz(v2 | 1) ^ 0x1F] + v2) >> 32;
  v6 = v4 + ((unsigned int)a2 >> 31) + v5;
  if ( *(_QWORD *)(a1 + 24) < v6 || (v7 = *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16) = v6, !v7) )
  {
    if ( a2 < 0 )
    {
      v13 = *(_QWORD *)(a1 + 16);
      v14 = v13 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v13 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v13 = *(_QWORD *)(v3 + 16);
        v14 = v13 + 1;
      }
      v15 = *(_QWORD *)(v3 + 8);
      *(_QWORD *)(v3 + 16) = v14;
      *(_BYTE *)(v15 + v13) = 45;
    }
    if ( (unsigned int)v2 < 0x64 )
    {
      v16 = &v21[v5];
      v18 = v2;
      if ( (unsigned int)v2 <= 9 )
      {
LABEL_20:
        *(v16 - 1) = v18 + 48;
        return sub_53712B8(v21, &v21[v5], v3);
      }
    }
    else
    {
      v16 = &v21[v5];
      do
      {
        v17 = (unsigned int)v2 >> 4;
        v18 = (unsigned int)v2 / 0x64;
        v19 = (unsigned int)v2 % 0x64;
        LODWORD(v2) = (unsigned int)v2 / 0x64;
        *((_WORD *)v16 - 1) = *(_WORD *)&a00010203040506_1[2 * v19];
        v16 -= 2;
      }
      while ( v17 > 0x270 );
      if ( v18 <= 9 )
        goto LABEL_20;
    }
    *((_WORD *)v16 - 1) = *(_WORD *)&a00010203040506_1[2 * v18];
    return sub_53712B8(v21, &v21[v5], v3);
  }
  v8 = (_BYTE *)(v7 + v4);
  if ( a2 < 0 )
    *v8++ = 45;
  v9 = &v8[v5];
  if ( (unsigned int)v2 >= 0x64 )
  {
    do
    {
      v10 = (unsigned int)v2 >> 4;
      v11 = (unsigned int)v2 / 0x64;
      v12 = (unsigned int)v2 % 0x64;
      LODWORD(v2) = (unsigned int)v2 / 0x64;
      *((_WORD *)v9 - 1) = *(_WORD *)&a00010203040506_1[2 * v12];
      v9 -= 2;
    }
    while ( v10 > 0x270 );
    if ( v11 <= 9 )
      goto LABEL_11;
LABEL_26:
    *((_WORD *)v9 - 1) = *(_WORD *)&a00010203040506_1[2 * v11];
    return v3;
  }
  v11 = v2;
  if ( (unsigned int)v2 > 9 )
    goto LABEL_26;
LABEL_11:
  *(v9 - 1) = v11 + 48;
  return v3;
}


================================================================================
Function: sub_6793A20 (0x6793A20)
================================================================================

__int64 __fastcall sub_6793A20(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // x21
  __int64 v3; // x19
  unsigned __int64 v4; // x9
  __int64 v5; // x8
  __int64 v6; // x22
  unsigned __int64 v7; // x9
  __int64 v8; // x10
  _BYTE *v9; // x8
  _BYTE *v10; // x8
  bool v11; // cc
  unsigned __int64 v12; // x10
  unsigned __int64 v13; // x13
  __int64 v14; // x8
  __int64 v15; // x1
  __int64 v16; // x9
  _BYTE *v17; // x8
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x13
  _BYTE v21[20]; // [xsp+4h] [xbp-1Ch] BYREF

  if ( a2 >= 0 )
    v2 = a2;
  else
    v2 = -a2;
  v3 = a1;
  v4 = byte_1017AEE[__clz(v2 | 1) ^ 0x3F];
  v5 = *(_QWORD *)(a1 + 16);
  v6 = (__PAIR128__(v4, v2) - qword_1017B30[v4]) >> 64;
  v7 = v5 + ((unsigned __int64)a2 >> 63) + v6;
  if ( *(_QWORD *)(a1 + 24) < v7 || (v8 = *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16) = v7, !v8) )
  {
    if ( a2 < 0 )
    {
      v14 = *(_QWORD *)(a1 + 16);
      v15 = v14 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v14 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v14 = *(_QWORD *)(v3 + 16);
        v15 = v14 + 1;
      }
      v16 = *(_QWORD *)(v3 + 8);
      *(_QWORD *)(v3 + 16) = v15;
      *(_BYTE *)(v16 + v14) = 45;
    }
    if ( v2 < 0x64 )
    {
      v17 = &v21[v6];
      v18 = v2;
      if ( v2 <= 9 )
      {
LABEL_20:
        *(v17 - 1) = v18 + 48;
        return sub_53712B8(v21, &v21[v6], v3);
      }
    }
    else
    {
      v17 = &v21[v6];
      do
      {
        v11 = v2 >> 4 > 0x270;
        v18 = v2 / 0x64;
        v19 = v2 % 0x64;
        v2 /= 0x64uLL;
        *((_WORD *)v17 - 1) = *(_WORD *)&a00010203040506_1[2 * v19];
        v17 -= 2;
      }
      while ( v11 );
      if ( v18 <= 9 )
        goto LABEL_20;
    }
    *((_WORD *)v17 - 1) = *(_WORD *)&a00010203040506_1[2 * v18];
    return sub_53712B8(v21, &v21[v6], v3);
  }
  v9 = (_BYTE *)(v8 + v5);
  if ( a2 < 0 )
    *v9++ = 45;
  v10 = &v9[v6];
  if ( v2 >= 0x64 )
  {
    do
    {
      v11 = v2 >> 4 > 0x270;
      v12 = v2 / 0x64;
      v13 = v2 % 0x64;
      v2 /= 0x64uLL;
      *((_WORD *)v10 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
      v10 -= 2;
    }
    while ( v11 );
    if ( v12 <= 9 )
      goto LABEL_11;
LABEL_26:
    *((_WORD *)v10 - 1) = *(_WORD *)&a00010203040506_1[2 * v12];
    return v3;
  }
  v12 = v2;
  if ( v2 > 9 )
    goto LABEL_26;
LABEL_11:
  *(v10 - 1) = v12 + 48;
  return v3;
}


================================================================================
Function: sub_6793C30 (0x6793C30)
================================================================================

__int64 __fastcall sub_6793C30(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // x2
  unsigned __int64 v3; // x8
  __int64 v4; // x9
  __int64 v5; // x8
  __int64 v6; // x11
  __int64 v7; // x8
  bool v8; // cc
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x13
  _BYTE *v11; // x8
  _BYTE *v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x14
  _BYTE v16[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v2 = a1;
  v3 = byte_1017AEE[__clz(a2 | 1) ^ 0x3F];
  v4 = a1[2];
  v5 = (__PAIR128__(v3, a2) - qword_1017B30[v3]) >> 64;
  if ( a1[3] < (unsigned __int64)(v5 + v4) || (v6 = a1[1], a1[2] = v5 + v4, !v6) )
  {
    v11 = &v16[v5];
    if ( a2 < 0x64 )
    {
      v12 = v11;
      v13 = a2;
      if ( a2 <= 9 )
      {
LABEL_11:
        *(v12 - 1) = v13 + 48;
        return sub_53712B8(v16, v11, a1);
      }
    }
    else
    {
      v12 = v11;
      do
      {
        v8 = a2 >> 4 > 0x270;
        v13 = a2 / 0x64;
        v14 = a2 % 0x64;
        a2 /= 0x64uLL;
        *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
        v12 -= 2;
      }
      while ( v8 );
      if ( v13 <= 9 )
        goto LABEL_11;
    }
    *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
    return sub_53712B8(v16, v11, a1);
  }
  v7 = v6 + v4 + v5;
  if ( a2 >= 0x64 )
  {
    do
    {
      v8 = a2 >> 4 > 0x270;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64uLL;
      *(_WORD *)(v7 - 2) = *(_WORD *)&a00010203040506_1[2 * v10];
      v7 -= 2LL;
    }
    while ( v8 );
    if ( v9 <= 9 )
      goto LABEL_6;
LABEL_17:
    *(_WORD *)(v7 - 2) = *(_WORD *)&a00010203040506_1[2 * v9];
    return (__int64)v2;
  }
  v9 = a2;
  if ( a2 > 9 )
    goto LABEL_17;
LABEL_6:
  *(_BYTE *)(v7 - 1) = v9 + 48;
  return (__int64)v2;
}


================================================================================
Function: sub_6793DE4 (0x6793DE4)
================================================================================

__int64 __fastcall sub_6793DE4(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // x9
  unsigned __int64 v5; // x9
  unsigned __int64 v8; // x21
  unsigned __int64 v9; // x20
  bool v10; // w8
  int v11; // w26
  unsigned __int64 v12; // x24
  unsigned __int64 v13; // x23
  bool v14; // w8
  bool v15; // w8
  __int128 v16; // t2
  bool v17; // w9
  bool v18; // w8
  __int64 v19; // x0
  __int128 v20; // t2
  unsigned __int64 v21; // x9
  unsigned __int64 v22; // x1
  bool v23; // w8
  bool v24; // zf
  bool v25; // w9
  __int64 v26; // x8
  unsigned __int64 v27; // x9
  __int64 v28; // x10
  _BYTE *v29; // x8
  _BYTE *v30; // x22
  bool v31; // w9
  unsigned __int64 v32; // x0
  unsigned __int64 v33; // x1
  __int128 v34; // t2
  unsigned __int64 v35; // x9
  bool v36; // w10
  __int16 v37; // w8
  bool v38; // w9
  __int64 v39; // x8
  __int64 v40; // x1
  __int64 v41; // x9
  bool v42; // w8
  _BYTE *v43; // x23
  unsigned __int64 v44; // x0
  unsigned __int64 v45; // x1
  __int128 v46; // t2
  unsigned __int64 v47; // x9
  bool v48; // w10
  __int16 v49; // w8
  bool v50; // w9
  bool v51; // w8
  bool v53; // w8
  _BYTE v54[40]; // [xsp+0h] [xbp-30h] BYREF

  v5 = (unsigned __int128)-(__int128)__PAIR128__(v4, a3) >> 64;
  if ( a4 >= 0 )
    v8 = a3;
  else
    v8 = -(__int64)a3;
  if ( a4 >= 0 )
    v9 = a4;
  else
    v9 = v5;
  v10 = v8 < 0xA;
  if ( v9 )
    v10 = 0;
  if ( v10 )
  {
    v11 = 1;
  }
  else
  {
    v11 = 4;
    v12 = v8;
    v13 = v9;
    while ( 1 )
    {
      v14 = v12 > 0x63;
      if ( v13 )
        v14 = 1;
      if ( !v14 )
      {
        v11 -= 2;
        goto LABEL_28;
      }
      v15 = v12 > 0x3E7;
      if ( v13 )
        v15 = 1;
      if ( !v15 )
        break;
      *((_QWORD *)&v16 + 1) = v13;
      *(_QWORD *)&v16 = v12;
      v17 = (unsigned __int64)(v16 >> 4) < 0x271;
      if ( v13 >> 4 )
        v18 = 0;
      else
        v18 = v17;
      if ( v18 )
        goto LABEL_28;
      v19 = sub_67EF95C(v12, v13, 10000LL, 0LL);
      *((_QWORD *)&v20 + 1) = v13;
      *(_QWORD *)&v20 = v12;
      v21 = v13 >> 5;
      v11 += 4;
      v12 = v19;
      v13 = v22;
      v23 = (unsigned __int64)(v20 >> 5) > 0xC34;
      v24 = v21 == 0;
      v25 = v21 != 0;
      if ( !v24 )
        v23 = v25;
      if ( !v23 )
      {
        v11 -= 3;
        goto LABEL_28;
      }
    }
    --v11;
  }
LABEL_28:
  v26 = *(_QWORD *)(a1 + 16);
  v27 = v11 + ((unsigned __int64)a4 >> 63) + v26;
  if ( *(_QWORD *)(a1 + 24) >= v27 && (v28 = *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16) = v27, v28) )
  {
    v29 = (_BYTE *)(v28 + v26);
    if ( a4 < 0 )
      *v29++ = 45;
    v30 = &v29[v11];
    v31 = v8 < 0x64;
    if ( v9 )
      v31 = 0;
    if ( v31 )
    {
      v32 = v8;
      v33 = v9;
    }
    else
    {
      do
      {
        v32 = sub_67EF95C(v8, v9, 100LL, 0LL);
        *((_QWORD *)&v34 + 1) = v9;
        *(_QWORD *)&v34 = v8;
        v35 = v8 - 100 * v32;
        v8 = v32;
        v36 = (unsigned __int64)(v34 >> 4) > 0x270;
        v37 = *(_WORD *)&a00010203040506_1[2 * v35];
        v38 = v9 >> 4 != 0;
        if ( !(v9 >> 4) )
          v38 = v36;
        v9 = v33;
        *((_WORD *)v30 - 1) = v37;
        v30 -= 2;
      }
      while ( v38 );
    }
    v53 = v32 > 9;
    if ( v33 )
      v53 = 1;
    if ( v53 )
      *((_WORD *)v30 - 1) = *(_WORD *)&a00010203040506_1[2 * v32];
    else
      *(v30 - 1) = v32 + 48;
  }
  else
  {
    if ( a4 < 0 )
    {
      v39 = *(_QWORD *)(a1 + 16);
      v40 = v39 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v39 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v39 = *(_QWORD *)(a1 + 16);
        v40 = v39 + 1;
      }
      v41 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v40;
      *(_BYTE *)(v41 + v39) = 45;
    }
    if ( v9 )
      v42 = 0;
    else
      v42 = v8 < 0x64;
    if ( v42 )
    {
      v43 = &v54[v11];
      v44 = v8;
      v45 = v9;
    }
    else
    {
      v43 = &v54[v11];
      do
      {
        v44 = sub_67EF95C(v8, v9, 100LL, 0LL);
        *((_QWORD *)&v46 + 1) = v9;
        *(_QWORD *)&v46 = v8;
        v47 = v8 - 100 * v44;
        v8 = v44;
        v48 = (unsigned __int64)(v46 >> 4) > 0x270;
        v49 = *(_WORD *)&a00010203040506_1[2 * v47];
        v50 = v9 >> 4 != 0;
        if ( !(v9 >> 4) )
          v50 = v48;
        v9 = v45;
        *((_WORD *)v43 - 1) = v49;
        v43 -= 2;
      }
      while ( v50 );
    }
    v51 = v44 > 9;
    if ( v45 )
      v51 = 1;
    if ( v51 )
      *((_WORD *)v43 - 1) = *(_WORD *)&a00010203040506_1[2 * v44];
    else
      *(v43 - 1) = v44 + 48;
    return sub_53712B8(v54, &v54[v11], a1);
  }
  return a1;
}


================================================================================
Function: sub_679410C (0x679410C)
================================================================================

__int64 __fastcall sub_679410C(_QWORD *a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  bool v4; // w8
  unsigned __int64 v5; // x20
  unsigned __int64 v6; // x21
  int v8; // w25
  unsigned __int64 v9; // x23
  unsigned __int64 v10; // x22
  bool v11; // w8
  bool v12; // w8
  __int128 v13; // t2
  bool v14; // w9
  bool v15; // w8
  __int64 v16; // x0
  __int128 v17; // t2
  unsigned __int64 v18; // x9
  unsigned __int64 v19; // x1
  bool v20; // w8
  bool v21; // zf
  bool v22; // w9
  __int64 v23; // x9
  unsigned __int64 v24; // x11
  __int64 v25; // x10
  __int64 v26; // x9
  bool v27; // w10
  __int64 v28; // x22
  unsigned __int64 v29; // x0
  unsigned __int64 v30; // x1
  __int128 v31; // t2
  unsigned __int64 v32; // x9
  bool v33; // w10
  __int16 v34; // w8
  bool v35; // w9
  bool v36; // w9
  _BYTE *v37; // x23
  unsigned __int64 v38; // x0
  unsigned __int64 v39; // x1
  __int128 v40; // t2
  unsigned __int64 v41; // x9
  bool v42; // w10
  __int16 v43; // w8
  bool v44; // w9
  bool v45; // w8
  bool v47; // w8
  _BYTE v48[40]; // [xsp+0h] [xbp-30h] BYREF

  v4 = a3 < 0xA;
  v5 = a4;
  v6 = a3;
  if ( a4 )
    v4 = 0;
  if ( v4 )
  {
    v8 = 1;
  }
  else
  {
    v8 = 4;
    v9 = a3;
    v10 = a4;
    while ( 1 )
    {
      v11 = v9 > 0x63;
      if ( v10 )
        v11 = 1;
      if ( !v11 )
      {
        v8 -= 2;
        goto LABEL_22;
      }
      v12 = v9 > 0x3E7;
      if ( v10 )
        v12 = 1;
      if ( !v12 )
        break;
      *((_QWORD *)&v13 + 1) = v10;
      *(_QWORD *)&v13 = v9;
      v14 = (unsigned __int64)(v13 >> 4) < 0x271;
      if ( v10 >> 4 )
        v15 = 0;
      else
        v15 = v14;
      if ( v15 )
        goto LABEL_22;
      v16 = sub_67EF95C(v9, v10, 10000LL, 0LL);
      *((_QWORD *)&v17 + 1) = v10;
      *(_QWORD *)&v17 = v9;
      v18 = v10 >> 5;
      v8 += 4;
      v9 = v16;
      v10 = v19;
      v20 = (unsigned __int64)(v17 >> 5) > 0xC34;
      v21 = v18 == 0;
      v22 = v18 != 0;
      if ( !v21 )
        v20 = v22;
      if ( !v20 )
      {
        v8 -= 3;
        goto LABEL_22;
      }
    }
    --v8;
  }
LABEL_22:
  v23 = a1[2];
  v24 = v23 + v8;
  if ( a1[3] >= v24 && (v25 = a1[1], a1[2] = v24, v25) )
  {
    v26 = v25 + v23;
    if ( v5 )
      v27 = 0;
    else
      v27 = v6 < 0x64;
    v28 = v26 + v8;
    if ( v27 )
    {
      v29 = v6;
      v30 = v5;
    }
    else
    {
      do
      {
        v29 = sub_67EF95C(v6, v5, 100LL, 0LL);
        *((_QWORD *)&v31 + 1) = v5;
        *(_QWORD *)&v31 = v6;
        v32 = v6 - 100 * v29;
        v6 = v29;
        v33 = (unsigned __int64)(v31 >> 4) > 0x270;
        v34 = *(_WORD *)&a00010203040506_1[2 * v32];
        v35 = v5 >> 4 != 0;
        if ( !(v5 >> 4) )
          v35 = v33;
        v5 = v30;
        *(_WORD *)(v28 - 2) = v34;
        v28 -= 2LL;
      }
      while ( v35 );
    }
    v47 = v29 > 9;
    if ( v30 )
      v47 = 1;
    if ( v47 )
      *(_WORD *)(v28 - 2) = *(_WORD *)&a00010203040506_1[2 * v29];
    else
      *(_BYTE *)(v28 - 1) = v29 + 48;
  }
  else
  {
    v36 = v6 < 0x64;
    if ( v5 )
      v36 = 0;
    if ( v36 )
    {
      v37 = &v48[v8];
      v38 = v6;
      v39 = v5;
    }
    else
    {
      v37 = &v48[v8];
      do
      {
        v38 = sub_67EF95C(v6, v5, 100LL, 0LL);
        *((_QWORD *)&v40 + 1) = v5;
        *(_QWORD *)&v40 = v6;
        v41 = v6 - 100 * v38;
        v6 = v38;
        v42 = (unsigned __int64)(v40 >> 4) > 0x270;
        v43 = *(_WORD *)&a00010203040506_1[2 * v41];
        v44 = v5 >> 4 != 0;
        if ( !(v5 >> 4) )
          v44 = v42;
        v5 = v39;
        *((_WORD *)v37 - 1) = v43;
        v37 -= 2;
      }
      while ( v44 );
    }
    v45 = v38 > 9;
    if ( v39 )
      v45 = 1;
    if ( v45 )
      *((_WORD *)v37 - 1) = *(_WORD *)&a00010203040506_1[2 * v38];
    else
      *(v37 - 1) = v38 + 48;
    return sub_53712B8(v48, &v48[v8], a1);
  }
  return (__int64)a1;
}


================================================================================
Function: sub_67943D8 (0x67943D8)
================================================================================

__int64 __fastcall sub_67943D8(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 *a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x19
  char *v8; // x20
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x21
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x21
  unsigned __int64 v14; // x22
  __int64 v15; // x10
  __int64 v16; // x23
  __int64 v17; // x24
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x12
  unsigned __int64 v20; // x8
  __int64 v21; // x11
  _BYTE *v22; // x9
  char *v23; // x13
  unsigned __int64 v24; // x14
  __int64 v25; // x15
  _OWORD *v26; // x13
  __int128 *v27; // x14
  unsigned __int64 v28; // x16
  __int128 v29; // q0
  __int128 v30; // q1
  __int64 *v31; // x16
  _QWORD *v32; // x11
  __int64 v33; // x15
  __int64 v34; // t1
  char v35; // t1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_173E2B9[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_24EFF44(a1, v10 >> v9, v8);
  v12 = a5[1];
  v13 = v10 - v11;
  if ( v12 )
  {
    v14 = *a5;
    v15 = *(_QWORD *)(v7 + 16);
    v16 = v14 + v12;
    v17 = v12 + v14;
    do
    {
      v18 = *(_QWORD *)(v7 + 24);
      if ( v18 < v16 - v14 + v15 )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v15 = *(_QWORD *)(v7 + 16);
        v18 = *(_QWORD *)(v7 + 24);
      }
      v19 = v18 - v15;
      if ( v18 - v15 >= v16 - v14 )
        v20 = v16 - v14;
      else
        v20 = v18 - v15;
      if ( !v20 )
        goto LABEL_9;
      v21 = *(_QWORD *)(v7 + 8);
      v22 = (_BYTE *)(v21 + v15);
      if ( v20 >= 8 )
      {
        if ( (unsigned __int64)v22 >= v14 + v20 || (v24 = v20, v23 = (char *)v14, v14 >= v21 + v15 + v20) )
        {
          if ( v20 < 0x20 )
          {
            v25 = 0LL;
LABEL_26:
            v31 = (__int64 *)(v14 + v25);
            if ( v17 - v14 < v19 )
              v19 = v17 - v14;
            v32 = (_QWORD *)(v21 + v15 + v25);
            v23 = (char *)(v14 + (v19 & 0xFFFFFFFFFFFFFFF8LL));
            v22 += v19 & 0xFFFFFFFFFFFFFFF8LL;
            v24 = v20 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            v33 = v25 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v34 = *v31++;
              v33 += 8LL;
              *v32++ = v34;
            }
            while ( v33 );
            if ( v19 == (v19 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_8;
            goto LABEL_33;
          }
          v25 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          v26 = (_OWORD *)(v21 + v15 + 16);
          v27 = (__int128 *)(v14 + 16);
          v28 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v29 = *(v27 - 1);
            v30 = *v27;
            v27 += 2;
            v28 -= 32LL;
            *(v26 - 1) = v29;
            *v26 = v30;
            v26 += 2;
          }
          while ( v28 );
          if ( v20 == v25 )
            goto LABEL_8;
          if ( (v20 & 0x18) != 0 )
            goto LABEL_26;
          v24 = v20 & 0x1F;
          v22 += v25;
          v23 = (char *)(v14 + v25);
        }
      }
      else
      {
        v23 = (char *)v14;
        v24 = v20;
      }
      do
      {
LABEL_33:
        v35 = *v23++;
        --v24;
        *v22++ = v35;
      }
      while ( v24 );
LABEL_8:
      v15 = *(_QWORD *)(v7 + 16);
LABEL_9:
      v15 += v20;
      v14 += v20;
      *(_QWORD *)(v7 + 16) = v15;
    }
    while ( v14 != v16 );
  }
  result = v7;
  if ( v13 )
    return sub_24EFF44(v7, v13, v8);
  return result;
}


================================================================================
Function: sub_67945DC (0x67945DC)
================================================================================

__int64 __fastcall sub_67945DC(__int64 a1, long double a2)
{
  int v3; // w8
  float v4; // s0
  __int64 v5; // x2
  unsigned int v6; // w8
  const char *v7; // x9
  __int64 v9; // x21
  unsigned int v10; // [xsp+0h] [xbp-40h] BYREF
  const char *v11; // [xsp+8h] [xbp-38h]
  __int128 v12; // [xsp+10h] [xbp-30h] BYREF
  __int128 v13; // [xsp+20h] [xbp-20h] BYREF

  v3 = LODWORD(a2);
  v13 = xmmword_AF97E0;
  if ( (~LODWORD(a2) & 0x7F800000) != 0 )
  {
    v9 = (LODWORD(a2) >> 23) & 0x100;
    if ( SLODWORD(a2) < 0 )
      *(float *)&a2 = -*(float *)&a2;
    *(_QWORD *)&v12 = sub_6790624(a2);
    return sub_679492C(a1, &v12, &v13, v9 << 32, 0LL);
  }
  else
  {
    v4 = fabsf(*(float *)&a2);
    if ( v3 >= 0 )
      v5 = 3LL;
    else
      v5 = 4LL;
    v6 = (unsigned int)v3 >> 31;
    v7 = "nan";
    if ( v4 == INFINITY )
      v7 = "inf";
    v12 = xmmword_AF97E0;
    v10 = v6;
    v11 = v7;
    return sub_67946E0(a1, &v12, v5, v5, &v10);
  }
}


================================================================================
Function: sub_67946E0 (0x67946E0)
================================================================================

__int64 __fastcall sub_67946E0(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned int *a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x19
  char *v8; // x20
  char v9; // w8
  unsigned __int64 v10; // x25
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x8
  char v14; // w23
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x24
  __int64 v18; // x23
  unsigned __int64 v19; // x21
  __int64 v20; // x11
  unsigned __int64 v21; // x8
  unsigned __int64 v22; // x12
  unsigned __int64 v23; // x8
  __int64 v24; // x13
  char *v25; // x9
  _BYTE *v26; // x10
  unsigned __int64 v27; // x14
  unsigned __int64 v28; // x15
  _OWORD *v29; // x14
  __int128 *v30; // x16
  unsigned __int64 v31; // x17
  __int128 v32; // q0
  __int128 v33; // q1
  __int64 v34; // x16
  unsigned __int64 v35; // x11
  _QWORD *v36; // x13
  __int64 *v37; // x16
  unsigned __int64 v38; // x15
  __int64 v39; // t1
  char v40; // t1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_173E2B9[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_24EFF44(a1, v10 >> v9, v8);
  v12 = *a5;
  if ( (_DWORD)v12 )
  {
    v13 = *(_QWORD *)(v7 + 16);
    v14 = byte_173E2BE[v12];
    v15 = v13 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v13 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v13 = *(_QWORD *)(v7 + 16);
      v15 = v13 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v13) = v14;
  }
  v17 = *((_QWORD *)a5 + 1);
  v18 = 0LL;
  v19 = v10 - v11;
  v20 = *(_QWORD *)(v7 + 16);
  do
  {
    v21 = *(_QWORD *)(v7 + 24);
    if ( v21 < 3 - v18 + v20 )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v20 = *(_QWORD *)(v7 + 16);
      v21 = *(_QWORD *)(v7 + 24);
    }
    v22 = v21 - v20;
    if ( v21 - v20 >= 3 - v18 )
      v23 = 3 - v18;
    else
      v23 = v21 - v20;
    if ( v23 )
    {
      v24 = *(_QWORD *)(v7 + 8);
      v25 = (char *)(v17 + v18);
      v26 = (_BYTE *)(v24 + v20);
      if ( v23 < 8 )
      {
        v27 = v23;
        goto LABEL_37;
      }
      if ( (unsigned __int64)v26 < v17 + v18 + v23 )
      {
        v27 = v23;
        if ( (unsigned __int64)v25 < v24 + v20 + v23 )
          goto LABEL_37;
      }
      if ( v23 >= 0x20 )
      {
        v28 = v23 & 0xFFFFFFFFFFFFFFE0LL;
        v29 = (_OWORD *)(v24 + v20 + 16);
        v30 = (__int128 *)(v17 + 16 + v18);
        v31 = v23 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          v32 = *(v30 - 1);
          v33 = *v30;
          v30 += 2;
          v31 -= 32LL;
          *(v29 - 1) = v32;
          *v29 = v33;
          v29 += 2;
        }
        while ( v31 );
        if ( v23 == v28 )
          goto LABEL_11;
        if ( (v23 & 0x18) == 0 )
        {
          v27 = v23 & 0x1F;
          v26 += v28;
          v25 += v28;
          do
          {
LABEL_37:
            v40 = *v25++;
            --v27;
            *v26++ = v40;
          }
          while ( v27 );
LABEL_11:
          v20 = *(_QWORD *)(v7 + 16);
          goto LABEL_12;
        }
      }
      else
      {
        v28 = 0LL;
      }
      v34 = v20 + v28;
      if ( v22 >= 3 - v18 )
        v35 = 3 - v18;
      else
        v35 = v22;
      v36 = (_QWORD *)(v24 + v34);
      v37 = (__int64 *)(v17 + v28 + v18);
      v25 += v35 & 0xFFFFFFFFFFFFFFF8LL;
      v26 += v35 & 0xFFFFFFFFFFFFFFF8LL;
      v27 = v23 - (v35 & 0xFFFFFFFFFFFFFFF8LL);
      v38 = v28 - (v35 & 0xFFFFFFFFFFFFFFF8LL);
      do
      {
        v39 = *v37++;
        v38 += 8LL;
        *v36++ = v39;
      }
      while ( v38 );
      if ( v35 == (v35 & 0xFFFFFFFFFFFFFFF8LL) )
        goto LABEL_11;
      goto LABEL_37;
    }
LABEL_12:
    v20 += v23;
    v18 += v23;
    *(_QWORD *)(v7 + 16) = v20;
  }
  while ( v18 != 3 );
  result = v7;
  if ( v19 )
    return sub_24EFF44(v7, v19, v8);
  return result;
}


================================================================================
Function: sub_679492C (0x679492C)
================================================================================

__int64 __fastcall sub_679492C(__int64 a1, unsigned int *a2, unsigned int *a3, unsigned __int64 a4, __int64 *a5)
{
  unsigned int v5; // w19
  unsigned int *v7; // x21
  __int64 v9; // x15
  unsigned __int64 v10; // x28
  __int64 v11; // x25
  __int64 v12; // x8
  unsigned __int64 v13; // x26
  __int64 v14; // x22
  char v15; // w24
  __int64 *v17; // x21
  __int64 v18; // x2
  __int64 *v19; // x0
  __int64 v20; // x9
  int v21; // w8
  int v22; // w10
  int v23; // w8
  __int64 v24; // x23
  __int64 v25; // x24
  int v26; // w9
  __int64 v27; // x10
  __int64 v28; // x20
  __int64 v29; // x19
  unsigned __int8 *v30; // x9
  unsigned __int64 v31; // x11
  unsigned int v32; // w8
  int v33; // w10
  unsigned __int8 *v34; // x11
  __int64 v35; // x0
  unsigned int *v36; // x1
  int v37; // w12
  int v38; // w8
  char v39; // w12
  unsigned __int64 v40; // x11
  __int64 v41; // x9
  __int64 v42; // x13
  __int64 v43; // x12
  _BYTE *v44; // x20
  char v45; // w8
  unsigned __int64 v46; // x9
  bool v47; // cf
  unsigned __int64 v48; // x9
  __int64 v49; // x21
  __int64 v50; // x19
  unsigned __int8 *v52; // x9
  unsigned __int64 v53; // x11
  unsigned int v54; // w8
  int v55; // w10
  unsigned __int8 *v56; // x11
  __int64 v57; // x1
  int v58; // w12
  char v59; // w12
  unsigned __int64 v60; // x8
  unsigned __int64 v61; // x11
  char v62; // w9
  unsigned __int64 v63; // x8
  unsigned __int64 v64; // x22
  unsigned __int64 v65; // x21
  __int64 v66; // x0
  __int64 v67; // x0
  bool v68; // cc
  int v70; // w8
  int v72; // w9
  unsigned __int64 v73; // x13
  unsigned __int64 v74; // x8
  unsigned __int64 v75; // x8
  char v76; // w10
  int *v78; // [xsp+8h] [xbp-98h] BYREF
  int *v79; // [xsp+10h] [xbp-90h]
  int *v80; // [xsp+18h] [xbp-88h]
  int *v81; // [xsp+20h] [xbp-80h]
  int *v82; // [xsp+28h] [xbp-78h]
  int *v83; // [xsp+30h] [xbp-70h]
  int *v84; // [xsp+38h] [xbp-68h]
  int *v85; // [xsp+40h] [xbp-60h]
  _BYTE *v86; // [xsp+48h] [xbp-58h]
  int v87; // [xsp+54h] [xbp-4Ch] BYREF
  int v88; // [xsp+58h] [xbp-48h] BYREF
  _BYTE v89[4]; // [xsp+5Ch] [xbp-44h] BYREF
  int v90; // [xsp+60h] [xbp-40h] BYREF
  _BYTE v91[4]; // [xsp+64h] [xbp-3Ch] BYREF
  int v92; // [xsp+68h] [xbp-38h] BYREF
  int v93; // [xsp+6Ch] [xbp-34h] BYREF
  unsigned __int64 v94; // [xsp+70h] [xbp-30h] BYREF
  int v95; // [xsp+78h] [xbp-28h] BYREF
  unsigned __int64 v96; // [xsp+80h] [xbp-20h]
  unsigned __int8 *v97; // [xsp+88h] [xbp-18h]
  char v98; // [xsp+90h] [xbp-10h]

  v5 = BYTE5(a4);
  v7 = a2;
  v9 = a1;
  v10 = HIDWORD(a4);
  v11 = *a2;
  v94 = a4;
  v90 = BYTE5(a4);
  v12 = qword_1017C38[__clz(v11 | 1) ^ 0x1F];
  v91[0] = 48;
  v13 = (unsigned __int64)(v12 + v11) >> 32;
  if ( BYTE5(a4) )
    v14 = (unsigned int)(v13 + 1);
  else
    v14 = (unsigned int)v13;
  v92 = (unsigned __int64)(v12 + v11) >> 32;
  v93 = v11;
  if ( (a4 & 0x2000000000000LL) != 0 )
  {
    if ( a5 )
    {
      v17 = a5;
      sub_67C4814((__int64 *)&v78, a5);
    }
    else
    {
      v17 = 0LL;
      sub_67C4788(&v78);
    }
    v19 = sub_67C4BB8((__int64 *)&v78, (__int64)&qword_795CEA8, v18);
    v15 = (*(__int64 (__fastcall **)(__int64 *))(*v19 + 24))(v19);
    sub_67C482C(&v78);
    v9 = a1;
    a5 = v17;
    v7 = a2;
  }
  else
  {
    v15 = 46;
  }
  v20 = v7[1];
  v89[0] = v15;
  v21 = v20 + v13;
  if ( BYTE4(a4) != 1 )
  {
    if ( BYTE4(a4) || ((int)a4 <= 0 ? (v22 = 16) : (v22 = a4), v21 >= -3 && v21 <= v22) )
    {
      v88 = v20 + v13;
      if ( (v20 & 0x80000000) == 0 )
      {
        v23 = a4 - v21;
        v24 = v14 + v20;
        v87 = v23;
        if ( (v10 & 0x100000) == 0 )
        {
          v25 = v9;
LABEL_63:
          sub_5370BA8(&v95, a5, ((unsigned int)v10 >> 17) & 1);
          v52 = v97;
          if ( (v95 & 1) != 0 )
          {
            v53 = v96;
          }
          else
          {
            v52 = (unsigned __int8 *)&v95 + 1;
            v53 = (unsigned __int64)(unsigned __int8)v95 >> 1;
          }
          v54 = 0;
          if ( v98 )
          {
            v55 = 0;
            v56 = &v52[v53];
            v57 = v25;
            if ( v56 == v52 )
              goto LABEL_70;
LABEL_68:
            v58 = *v52;
            if ( (unsigned int)(v58 - 127) >= 0xFFFFFF82 )
            {
              ++v52;
              while ( 1 )
              {
                v55 += v58;
                if ( v55 >= (int)v13 )
                  break;
                ++v54;
                if ( v56 != v52 )
                  goto LABEL_68;
LABEL_70:
                v58 = (char)*(v56 - 1);
              }
            }
          }
          else
          {
            v57 = v25;
          }
          v59 = *(_WORD *)((char *)a3 + 9);
          v60 = v24 + v54;
          v78 = &v90;
          v79 = &v93;
          v80 = &v92;
          v81 = (int *)v7;
          v61 = *a3;
          v82 = &v95;
          v83 = (int *)&v94;
          v62 = byte_173E2B4[v59 & 0xF];
          v47 = v61 >= v60;
          v63 = v61 - v60;
          if ( v47 )
            v64 = v63;
          else
            v64 = 0LL;
          v65 = v64 >> v62;
          v84 = (int *)v89;
          v85 = &v87;
          v86 = v91;
          if ( v64 >> v62 )
            v57 = sub_24EFF44(v57, v64 >> v62, (_BYTE *)a3 + 11);
          v66 = sub_67953D8(&v78, v57);
          v50 = v66;
          if ( v64 == v65 )
            goto LABEL_96;
          v67 = sub_24EFF44(v66, v64 - v65, (_BYTE *)a3 + 11);
LABEL_95:
          v50 = v67;
LABEL_96:
          if ( (v95 & 1) != 0 )
            sub_6575460();
          return v50;
        }
        if ( v23 > 0 || (unsigned __int8)v10 == 2 )
        {
          v25 = v9;
          if ( v23 < 1 )
            goto LABEL_63;
        }
        else
        {
          v23 = 1;
          v25 = v9;
          v87 = 1;
        }
        v24 += (unsigned int)(v23 + 1);
        goto LABEL_63;
      }
      if ( v21 >= 1 )
      {
        v28 = v9;
        v87 = (a4 - v13) & ((int)((_DWORD)v10 << 11) >> 31);
        v29 = v14 + (v87 & (unsigned int)~(v87 >> 31)) + 1;
        sub_5370BA8(&v95, a5, ((unsigned int)v10 >> 17) & 1);
        v30 = v97;
        if ( (v95 & 1) != 0 )
        {
          v31 = v96;
        }
        else
        {
          v30 = (unsigned __int8 *)&v95 + 1;
          v31 = (unsigned __int64)(unsigned __int8)v95 >> 1;
        }
        v32 = 0;
        if ( v98 )
        {
          v33 = 0;
          v34 = &v30[v31];
          v35 = v28;
          v36 = a3;
          if ( v34 == v30 )
            goto LABEL_32;
LABEL_30:
          v37 = *v30;
          if ( (unsigned int)(v37 - 127) >= 0xFFFFFF82 )
          {
            ++v30;
            while ( 1 )
            {
              v33 += v37;
              if ( v33 >= (int)v13 )
                break;
              ++v32;
              if ( v34 != v30 )
                goto LABEL_30;
LABEL_32:
              v37 = (char)*(v34 - 1);
            }
          }
        }
        else
        {
          v35 = v28;
          v36 = a3;
        }
        v78 = &v90;
        v79 = &v93;
        v80 = &v92;
        v81 = &v88;
        v82 = (int *)v89;
        v83 = &v95;
        v84 = &v87;
        v85 = (int *)v91;
        v67 = sub_67957B4(v35, v36, v29 + v32, v29 + v32, &v78);
        goto LABEL_95;
      }
      v68 = (int)a4 >= -v21 || (int)a4 <= -1;
      if ( !v68 && (_DWORD)v13 == 0 )
        v70 = a4;
      else
        v70 = -v21;
      v95 = v70;
      if ( v70 | (unsigned int)v13 )
      {
        LOBYTE(v87) = 1;
      }
      else
      {
        LOBYTE(v87) = (v10 & 0x100000) != 0;
        if ( (v10 & 0x100000) == 0 )
        {
          v72 = 1;
          goto LABEL_102;
        }
      }
      v72 = 2;
LABEL_102:
      v73 = *a3;
      v74 = v14 + (unsigned int)(v72 + v70);
      v47 = v73 >= v74;
      v75 = v73 - v74;
      if ( !v47 )
        v75 = 0LL;
      v76 = byte_173E2B4[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v78 = &v90;
      v79 = (int *)v91;
      v44 = (char *)a3 + 11;
      v80 = &v87;
      v81 = (int *)v89;
      v49 = v75 - (v75 >> v76);
      v82 = &v95;
      v83 = &v93;
      v84 = &v92;
      if ( v75 >> v76 )
        v9 = sub_24EFF44(v9, v75 >> v76, (_BYTE *)a3 + 11);
      v50 = sub_6795A44(&v78, v9);
      if ( !v49 )
        return v50;
      return sub_24EFF44(v50, v49, v44);
    }
  }
  v26 = v21 - 1;
  if ( (v10 & 0x100000) != 0 )
  {
    v27 = ((_DWORD)a4 - (_DWORD)v13) & (unsigned int)~(((int)a4 - (int)v13) >> 31);
    v14 += v27;
  }
  else if ( (_DWORD)v13 == 1 )
  {
    v15 = 0;
    LODWORD(v27) = 0;
    v89[0] = 0;
  }
  else
  {
    LODWORD(v27) = 0;
  }
  v68 = v21 <= 0;
  v38 = 1 - v21;
  if ( !v68 )
    v38 = v26;
  if ( (v10 & 0x10000) != 0 )
    v39 = 69;
  else
    v39 = 101;
  v40 = *a3;
  v78 = (int *)__PAIR64__(v11, v5);
  LODWORD(v79) = v13;
  BYTE4(v79) = v15;
  LODWORD(v80) = v27;
  BYTE4(v80) = 48;
  BYTE5(v80) = v39;
  LODWORD(v81) = v26;
  if ( (int)v40 < 1 )
    return sub_6794F48(&v78, v9);
  v41 = 2LL;
  v42 = 3LL;
  if ( v15 )
    v43 = 3LL;
  else
    v43 = 2LL;
  if ( v38 > 999 )
    v42 = 4LL;
  if ( v38 > 99 )
    v41 = v42;
  v44 = (char *)a3 + 11;
  v45 = byte_173E2B4[*(_WORD *)((_BYTE *)a3 + 9) & 0xFLL];
  v46 = v14 + v41 + v43;
  v47 = v40 >= v46;
  v48 = v40 - v46;
  if ( !v47 )
    v48 = 0LL;
  v49 = v48 - (v48 >> v45);
  if ( v48 >> v45 )
    v9 = sub_24EFF44(v9, v48 >> v45, (_BYTE *)a3 + 11);
  v50 = sub_6794F48(&v78, v9);
  if ( v49 )
    return sub_24EFF44(v50, v49, v44);
  return v50;
}


================================================================================
Function: sub_6794F48 (0x6794F48)
================================================================================

__int64 __fastcall sub_6794F48(unsigned int *a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w22
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x0
  int v12; // w22
  __int64 v13; // x20
  __int64 v14; // x8
  char v15; // w22
  __int64 v16; // x1
  __int64 v17; // x9
  char v19; // w9
  __int64 v20; // x10
  __int64 v21; // x8
  __int64 v22; // x1
  _BYTE v23[12]; // [xsp+Ch] [xbp-14h] BYREF

  v4 = *a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_173E2BE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_6795258(v23, a1[1], a1[2], 1LL, *((unsigned __int8 *)a1 + 12));
  v11 = sub_53712B8((unsigned __int64)v23, v10, a2);
  v12 = a1[4];
  v13 = v11;
  if ( v12 >= 1 )
  {
    do
    {
      v21 = *(_QWORD *)(v13 + 16);
      v22 = v21 + 1;
      if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v21 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v13)(v13);
        v21 = *(_QWORD *)(v13 + 16);
        v22 = v21 + 1;
      }
      --v12;
      v19 = *((_BYTE *)a1 + 20);
      v20 = *(_QWORD *)(v13 + 8);
      *(_QWORD *)(v13 + 16) = v22;
      *(_BYTE *)(v20 + v21) = v19;
    }
    while ( v12 );
  }
  v14 = *(_QWORD *)(v13 + 16);
  v15 = *((_BYTE *)a1 + 21);
  v16 = v14 + 1;
  if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v14 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v13)(v13);
    v14 = *(_QWORD *)(v13 + 16);
    v16 = v14 + 1;
  }
  v17 = *(_QWORD *)(v13 + 8);
  *(_QWORD *)(v13 + 16) = v16;
  *(_BYTE *)(v17 + v14) = v15;
  return sub_67950A0(a1[6], v13);
}


================================================================================
Function: sub_67950A0 (0x67950A0)
================================================================================

__int64 __fastcall sub_67950A0(unsigned int a1, __int64 a2)
{
  __int64 v2; // x8
  unsigned __int64 v3; // x9
  unsigned int v5; // w20
  __int64 v6; // x1
  __int64 v7; // x9
  char v8; // w10
  char *v9; // x23
  __int64 v10; // x8
  char v11; // w24
  __int64 v12; // x1
  __int64 v13; // x9
  __int64 v14; // x8
  char v15; // w23
  __int64 v16; // x1
  __int64 v17; // x8
  char *v18; // x20
  char v19; // w21
  __int64 v20; // x1
  __int64 v21; // x9
  char v22; // w20
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 v25; // x9
  __int64 result; // x0

  v2 = *(_QWORD *)(a2 + 16);
  v3 = *(_QWORD *)(a2 + 24);
  v5 = a1;
  v6 = v2 + 1;
  if ( (a1 & 0x80000000) != 0 )
  {
    if ( v3 < v2 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v2 = *(_QWORD *)(a2 + 16);
      v6 = v2 + 1;
    }
    v7 = *(_QWORD *)(a2 + 8);
    v8 = 45;
    v5 = -v5;
  }
  else
  {
    if ( v3 < v2 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v2 = *(_QWORD *)(a2 + 16);
      v6 = v2 + 1;
    }
    v7 = *(_QWORD *)(a2 + 8);
    v8 = 43;
  }
  *(_QWORD *)(a2 + 16) = v6;
  *(_BYTE *)(v7 + v2) = v8;
  if ( v5 >= 0x64 )
  {
    v9 = &a00010203040506_1[2 * (v5 / 0x64)];
    if ( v5 >= 0x3E8 )
    {
      v10 = *(_QWORD *)(a2 + 16);
      v11 = *v9;
      v12 = v10 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v10 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v10 = *(_QWORD *)(a2 + 16);
        v12 = v10 + 1;
      }
      v13 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v12;
      *(_BYTE *)(v13 + v10) = v11;
    }
    v14 = *(_QWORD *)(a2 + 16);
    v15 = v9[1];
    v16 = v14 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v14 = *(_QWORD *)(a2 + 16);
      v16 = v14 + 1;
    }
    *(_QWORD *)(a2 + 16) = v16;
    v5 %= 0x64u;
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + v14) = v15;
  }
  v17 = *(_QWORD *)(a2 + 16);
  v18 = &a00010203040506_1[2 * v5];
  v19 = *v18;
  v20 = v17 + 1;
  if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v17 + 1) )
  {
    (**(void (__fastcall ***)(__int64))a2)(a2);
    v17 = *(_QWORD *)(a2 + 16);
    v20 = v17 + 1;
  }
  v21 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 16) = v20;
  v22 = v18[1];
  *(_BYTE *)(v21 + v17) = v19;
  v23 = *(_QWORD *)(a2 + 16);
  v24 = v23 + 1;
  if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v23 + 1) )
  {
    (**(void (__fastcall ***)(__int64))a2)(a2);
    v23 = *(_QWORD *)(a2 + 16);
    v24 = v23 + 1;
  }
  v25 = *(_QWORD *)(a2 + 8);
  result = a2;
  *(_QWORD *)(a2 + 16) = v24;
  *(_BYTE *)(v25 + v23) = v22;
  return result;
}


================================================================================
Function: sub_6795258 (0x6795258)
================================================================================

__int64 __fastcall sub_6795258(__int64 a1, unsigned int a2, int a3, int a4, char a5)
{
  unsigned int v5; // w11
  __int64 result; // x0
  unsigned int v7; // w13
  __int64 v8; // x9
  unsigned int v9; // w10
  unsigned int v10; // w15
  unsigned int v11; // w12
  __int64 v12; // x9
  unsigned int v13; // w15
  unsigned int v14; // w11
  unsigned int v15; // w14
  __int64 v16; // x8
  unsigned int v17; // w14
  unsigned int v18; // w9
  unsigned int v19; // w13

  if ( !a5 )
  {
    result = a1 + a3;
    if ( a2 < 0x64 )
    {
      v16 = result;
      v18 = a2;
      if ( a2 <= 9 )
      {
LABEL_15:
        *(_BYTE *)(v16 - 1) = v18 + 48;
        return result;
      }
    }
    else
    {
      v16 = result;
      do
      {
        v17 = a2 >> 4;
        v18 = a2 / 0x64;
        v19 = a2 % 0x64;
        a2 /= 0x64u;
        *(_WORD *)(v16 - 2) = *(_WORD *)&a00010203040506_1[2 * v19];
        v16 -= 2LL;
      }
      while ( v17 > 0x270 );
      if ( v18 <= 9 )
        goto LABEL_15;
    }
    *(_WORD *)(v16 - 2) = *(_WORD *)&a00010203040506_1[2 * v18];
    return result;
  }
  v5 = a3 - a4;
  result = a1 + a3 + 1;
  if ( a3 - a4 < 2 )
  {
    v9 = a2;
    v8 = result;
    if ( (v5 & 1) == 0 )
      goto LABEL_7;
  }
  else
  {
    v7 = (v5 >> 1) + 1;
    v8 = result;
    do
    {
      --v7;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64u;
      *(_WORD *)(v8 - 2) = *(_WORD *)&a00010203040506_1[2 * v10];
      v8 -= 2LL;
    }
    while ( v7 > 1 );
    if ( (v5 & 1) == 0 )
      goto LABEL_7;
  }
  v11 = (v9 % 0xA) | 0x30;
  v9 /= 0xAu;
  *(_BYTE *)--v8 = v11;
LABEL_7:
  *(_BYTE *)(v8 - 1) = a5;
  v12 = v8 - 1;
  if ( v9 < 0x64 )
  {
    v14 = v9;
    if ( v9 <= 9 )
    {
LABEL_10:
      *(_BYTE *)(v12 - 1) = v14 + 48;
      return result;
    }
  }
  else
  {
    do
    {
      v13 = v9 >> 4;
      v14 = v9 / 0x64;
      v15 = v9 % 0x64;
      v9 /= 0x64u;
      *(_WORD *)(v12 - 2) = *(_WORD *)&a00010203040506_1[2 * v15];
      v12 -= 2LL;
    }
    while ( v13 > 0x270 );
    if ( v14 <= 9 )
      goto LABEL_10;
  }
  *(_WORD *)(v12 - 2) = *(_WORD *)&a00010203040506_1[2 * v14];
  return result;
}


================================================================================
Function: sub_67953D8 (0x67953D8)
================================================================================

__int64 __fastcall sub_67953D8(unsigned int **a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x20
  __int64 v12; // x8
  unsigned int *v13; // x21
  __int64 v14; // x1
  char v15; // w9
  int v16; // w21
  unsigned int *v17; // x19
  char v18; // w9
  __int64 v19; // x10
  __int64 v20; // x8
  __int64 v21; // x1

  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_173E2BE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_6795514(a2, *a1[1], *a1[2], a1[3][1], a1[4]);
  v11 = v10;
  if ( (*((_BYTE *)a1[5] + 6) & 0x10) != 0 )
  {
    v12 = *(_QWORD *)(v10 + 16);
    v13 = a1[6];
    v14 = v12 + 1;
    if ( *(_QWORD *)(v10 + 24) < (unsigned __int64)(v12 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v10)(v10);
      v12 = *(_QWORD *)(v11 + 16);
      v14 = v12 + 1;
    }
    v15 = *(_BYTE *)v13;
    *(_QWORD *)(v11 + 16) = v14;
    *(_BYTE *)(*(_QWORD *)(v11 + 8) + v12) = v15;
    v16 = *a1[7];
    if ( v16 >= 1 )
    {
      v17 = a1[8];
      do
      {
        v20 = *(_QWORD *)(v11 + 16);
        v21 = v20 + 1;
        if ( *(_QWORD *)(v11 + 24) < (unsigned __int64)(v20 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v11)(v11);
          v20 = *(_QWORD *)(v11 + 16);
          v21 = v20 + 1;
        }
        --v16;
        v18 = *(_BYTE *)v17;
        v19 = *(_QWORD *)(v11 + 8);
        *(_QWORD *)(v11 + 16) = v21;
        *(_BYTE *)(v19 + v20) = v18;
      }
      while ( v16 );
    }
  }
  return v11;
}


================================================================================
Function: sub_6795514 (0x6795514)
================================================================================

__int64 __fastcall sub_6795514(__int64 a1, unsigned int a2, int a3, int a4, __int64 a5)
{
  _BYTE *v8; // x9
  unsigned int v9; // w15
  unsigned int v10; // w10
  unsigned int v11; // w14
  char *v12; // x9
  unsigned int v13; // w15
  unsigned int v14; // w10
  unsigned int v15; // w14
  __int64 v16; // x8
  __int64 v17; // x1
  __int64 v18; // x20
  __int64 v19; // x9
  __int64 v20; // x8
  __int64 v21; // x1
  void (__fastcall **v23)(_QWORD); // [xsp+0h] [xbp-230h] BYREF
  _BYTE *v24; // [xsp+8h] [xbp-228h]
  __int128 v25; // [xsp+10h] [xbp-220h]
  _BYTE v26[508]; // [xsp+20h] [xbp-210h] BYREF
  _BYTE v27[12]; // [xsp+21Ch] [xbp-14h] BYREF

  if ( *(_BYTE *)(a5 + 24) )
  {
    v23 = (void (__fastcall **)(_QWORD))&off_6BE0B98;
    v24 = v26;
    v25 = xmmword_AFDC90;
    if ( a2 < 0x64 )
    {
      v8 = &v27[a3];
      v10 = a2;
      if ( a2 <= 9 )
      {
LABEL_6:
        *(v8 - 1) = v10 + 48;
LABEL_14:
        sub_53712B8((unsigned __int64)v27, (__int64)&v27[a3], (__int64)&v23);
        if ( a4 >= 1 )
        {
          do
          {
            v16 = v25;
            v17 = v25 + 1;
            if ( *((_QWORD *)&v25 + 1) < (unsigned __int64)(v25 + 1) )
            {
              (*v23)(&v23);
              v16 = v25;
              v17 = v25 + 1;
            }
            --a4;
            *(_QWORD *)&v25 = v17;
            v24[v16] = 48;
          }
          while ( a4 );
        }
        v18 = sub_5370F24(a5, a1, v24, v25);
        if ( v24 != v26 )
          sub_6575460();
        return v18;
      }
    }
    else
    {
      v8 = &v27[a3];
      do
      {
        v9 = a2 >> 4;
        v10 = a2 / 0x64;
        v11 = a2 % 0x64;
        a2 /= 0x64u;
        *((_WORD *)v8 - 1) = *(_WORD *)&a00010203040506_1[2 * v11];
        v8 -= 2;
      }
      while ( v9 > 0x270 );
      if ( v10 <= 9 )
        goto LABEL_6;
    }
    *((_WORD *)v8 - 1) = *(_WORD *)&a00010203040506_1[2 * v10];
    goto LABEL_14;
  }
  if ( a2 < 0x64 )
  {
    v12 = (char *)&v23 + a3;
    v14 = a2;
    if ( a2 <= 9 )
    {
LABEL_11:
      *(v12 - 1) = v14 + 48;
      goto LABEL_23;
    }
  }
  else
  {
    v12 = (char *)&v23 + a3;
    do
    {
      v13 = a2 >> 4;
      v14 = a2 / 0x64;
      v15 = a2 % 0x64;
      a2 /= 0x64u;
      *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v15];
      v12 -= 2;
    }
    while ( v13 > 0x270 );
    if ( v14 <= 9 )
      goto LABEL_11;
  }
  *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
LABEL_23:
  v18 = sub_53712B8((unsigned __int64)&v23, (__int64)&v23 + a3, a1);
  if ( a4 >= 1 )
  {
    do
    {
      v20 = *(_QWORD *)(v18 + 16);
      v21 = v20 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v20 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v20 = *(_QWORD *)(v18 + 16);
        v21 = v20 + 1;
      }
      --a4;
      v19 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v21;
      *(_BYTE *)(v19 + v20) = 48;
    }
    while ( a4 );
  }
  return v18;
}


================================================================================
Function: sub_67957B4 (0x67957B4)
================================================================================

__int64 __fastcall sub_67957B4(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x8
  char v14; // w24
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x22
  __int64 v18; // x21
  int v19; // w23
  unsigned int *v20; // x20
  char v21; // w9
  __int64 v22; // x10
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_173E2B4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_24EFF44(a1, v10 >> v9, v8);
  v12 = **a5;
  if ( (_DWORD)v12 )
  {
    v13 = *(_QWORD *)(v7 + 16);
    v14 = byte_173E2BE[v12];
    v15 = v13 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v13 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v13 = *(_QWORD *)(v7 + 16);
      v15 = v13 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v13) = v14;
  }
  v17 = v10 - v11;
  v18 = sub_679591C(v7, *a5[1], *a5[2], *a5[3], *(unsigned __int8 *)a5[4], a5[5]);
  v19 = *a5[6];
  if ( v19 >= 1 )
  {
    v20 = a5[7];
    do
    {
      v23 = *(_QWORD *)(v18 + 16);
      v24 = v23 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v23 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v23 = *(_QWORD *)(v18 + 16);
        v24 = v23 + 1;
      }
      --v19;
      v21 = *(_BYTE *)v20;
      v22 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v24;
      *(_BYTE *)(v22 + v23) = v21;
    }
    while ( v19 );
  }
  result = v18;
  if ( v17 )
    return sub_24EFF44(v18, v17, v8);
  return result;
}


================================================================================
Function: sub_679591C (0x679591C)
================================================================================

__int64 __fastcall sub_679591C(__int64 a1, unsigned int a2, int a3, int a4, char a5, __int64 a6)
{
  __int64 v9; // x0
  __int64 v10; // x19
  __int64 v11; // x0
  _UNKNOWN **v13; // [xsp+0h] [xbp-230h] BYREF
  _BYTE *v14; // [xsp+8h] [xbp-228h]
  __int128 v15; // [xsp+10h] [xbp-220h]
  _BYTE v16[508]; // [xsp+20h] [xbp-210h] BYREF
  _BYTE v17[12]; // [xsp+21Ch] [xbp-14h] BYREF

  if ( *(_BYTE *)(a6 + 24) )
  {
    v13 = &off_6BE0B98;
    v14 = v16;
    v15 = xmmword_AFDC90;
    v9 = sub_6795258((__int64)v17, a2, a3, a4, a5);
    sub_53712B8((unsigned __int64)v17, v9, (__int64)&v13);
    sub_5370F24(a6, a1, v14, (unsigned int)a4);
    v10 = sub_53712B8((unsigned __int64)&v14[a4], (__int64)&v14[v15], a1);
    if ( v14 != v16 )
      sub_6575460();
  }
  else
  {
    v11 = sub_6795258((__int64)&v13, a2, a3, a4, a5);
    return sub_53712B8((unsigned __int64)&v13, v11, a1);
  }
  return v10;
}


================================================================================
Function: sub_6795A44 (0x6795A44)
================================================================================

__int64 __fastcall sub_6795A44(unsigned int **a1, __int64 a2)
{
  __int64 v3; // x19
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w22
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x8
  unsigned int *v11; // x22
  __int64 v12; // x1
  char v13; // w9
  __int64 v14; // x8
  unsigned int *v15; // x22
  __int64 v16; // x1
  char v17; // w9
  int v18; // w22
  unsigned int *v19; // x23
  char v20; // w9
  __int64 v21; // x10
  __int64 v22; // x8
  __int64 v23; // x1
  unsigned int v24; // w10
  _BYTE *v25; // x1
  _BYTE *v26; // x9
  unsigned int v27; // w15
  unsigned int v28; // w11
  unsigned int v29; // w14
  _BYTE v31[12]; // [xsp+Ch] [xbp-14h] BYREF

  v3 = a2;
  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_173E2BE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))v3)(v3);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(v3 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = *(_QWORD *)(v3 + 16);
  v11 = a1[1];
  v12 = v10 + 1;
  if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v10 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v3)(v3);
    v10 = *(_QWORD *)(v3 + 16);
    v12 = v10 + 1;
  }
  v13 = *(_BYTE *)v11;
  *(_QWORD *)(v3 + 16) = v12;
  *(_BYTE *)(*(_QWORD *)(v3 + 8) + v10) = v13;
  if ( *(_BYTE *)a1[2] )
  {
    v14 = *(_QWORD *)(v3 + 16);
    v15 = a1[3];
    v16 = v14 + 1;
    if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v3)(v3);
      v14 = *(_QWORD *)(v3 + 16);
      v16 = v14 + 1;
    }
    v17 = *(_BYTE *)v15;
    *(_QWORD *)(v3 + 16) = v16;
    *(_BYTE *)(*(_QWORD *)(v3 + 8) + v14) = v17;
    v18 = *a1[4];
    if ( v18 >= 1 )
    {
      v19 = a1[1];
      do
      {
        v22 = *(_QWORD *)(v3 + 16);
        v23 = v22 + 1;
        if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v22 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v3)(v3);
          v22 = *(_QWORD *)(v3 + 16);
          v23 = v22 + 1;
        }
        --v18;
        v20 = *(_BYTE *)v19;
        v21 = *(_QWORD *)(v3 + 8);
        *(_QWORD *)(v3 + 16) = v23;
        *(_BYTE *)(v21 + v22) = v20;
      }
      while ( v18 );
    }
    v24 = *a1[5];
    v25 = &v31[*a1[6]];
    if ( v24 < 0x64 )
    {
      v26 = &v31[*a1[6]];
      v28 = *a1[5];
      if ( v24 <= 9 )
      {
LABEL_19:
        *(v26 - 1) = v28 + 48;
        return sub_53712B8((unsigned __int64)v31, (__int64)v25, v3);
      }
    }
    else
    {
      v26 = &v31[*a1[6]];
      do
      {
        v27 = v24 >> 4;
        v28 = v24 / 0x64;
        v29 = v24 % 0x64;
        v24 /= 0x64u;
        *((_WORD *)v26 - 1) = *(_WORD *)&a00010203040506_1[2 * v29];
        v26 -= 2;
      }
      while ( v27 > 0x270 );
      if ( v28 <= 9 )
        goto LABEL_19;
    }
    *((_WORD *)v26 - 1) = *(_WORD *)&a00010203040506_1[2 * v28];
    return sub_53712B8((unsigned __int64)v31, (__int64)v25, v3);
  }
  return v3;
}


================================================================================
Function: sub_6795C64 (0x6795C64)
================================================================================

__int64 __fastcall sub_6795C64(__int64 a1, long double a2)
{
  __int64 v3; // x21
  double v4; // d0
  __int64 v5; // x2
  const char *v6; // x9
  __int64 v8; // x1
  unsigned int v9; // [xsp+0h] [xbp-40h] BYREF
  const char *v10; // [xsp+8h] [xbp-38h]
  __int128 v11; // [xsp+10h] [xbp-30h] BYREF
  __int128 v12; // [xsp+20h] [xbp-20h] BYREF

  v3 = *(_QWORD *)&a2 >> 55;
  v12 = xmmword_AF97E0;
  if ( (~*(_QWORD *)&a2 & 0x7FF0000000000000LL) != 0 )
  {
    if ( *(__int64 *)&a2 < 0 )
      *(double *)&a2 = -*(double *)&a2;
    *(_QWORD *)&v11 = sub_6790A84(a2);
    *((_QWORD *)&v11 + 1) = v8;
    return sub_6795D68(a1, &v11, &v12, (v3 << 32) & 0x10000000000LL, 0LL);
  }
  else
  {
    v4 = fabs(*(double *)&a2);
    if ( (unsigned int)v3 < 0x100 )
      v5 = 3LL;
    else
      v5 = 4LL;
    v6 = "nan";
    if ( v4 == INFINITY )
      v6 = "inf";
    v11 = xmmword_AF97E0;
    v9 = (unsigned int)v3 >> 8;
    v10 = v6;
    return sub_67946E0(a1, &v11, v5, v5, &v9);
  }
}


================================================================================
Function: sub_6795D68 (0x6795D68)
================================================================================

__int64 __fastcall sub_6795D68(__int64 a1, unsigned __int64 *a2, unsigned int *a3, unsigned __int64 a4, __int64 *a5)
{
  unsigned __int64 *v6; // x21
  __int64 v8; // x15
  unsigned __int64 v9; // x28
  unsigned __int64 v10; // x25
  __int64 v11; // x9
  signed int v12; // w26
  int v13; // w19
  __int64 v14; // x22
  char v15; // w24
  __int64 *v17; // x21
  __int64 v18; // x2
  __int64 *v19; // x0
  __int64 v20; // x9
  int v21; // w8
  int v22; // w10
  bool v23; // cc
  int v24; // w9
  __int64 v25; // x10
  int v26; // w8
  __int64 v27; // x23
  __int64 v28; // x24
  __int64 v29; // x20
  __int64 v30; // x19
  unsigned __int8 *v31; // x9
  unsigned __int64 v32; // x11
  unsigned int v33; // w8
  int v34; // w10
  unsigned __int8 *v35; // x11
  __int64 v36; // x0
  unsigned int *v37; // x1
  int v38; // w12
  int v40; // w8
  char v41; // w12
  unsigned __int64 v42; // x11
  __int64 v43; // x9
  __int64 v44; // x13
  __int64 v45; // x12
  char *v46; // x20
  char v47; // w8
  unsigned __int64 v48; // x9
  bool v49; // cf
  unsigned __int64 v50; // x9
  unsigned __int64 v51; // x21
  __int64 v52; // x19
  unsigned __int8 *v54; // x9
  unsigned __int64 v55; // x11
  unsigned int v56; // w8
  int v57; // w10
  unsigned __int8 *v58; // x11
  __int64 v59; // x1
  int v60; // w12
  char v61; // w12
  unsigned __int64 v62; // x8
  unsigned __int64 v63; // x11
  char v64; // w9
  unsigned __int64 v65; // x8
  unsigned __int64 v66; // x22
  unsigned __int64 v67; // x21
  __int64 v68; // x0
  __int64 v69; // x0
  int v72; // w8
  int v74; // w9
  unsigned __int64 v75; // x13
  unsigned __int64 v76; // x8
  unsigned __int64 v77; // x8
  char v78; // w10
  int v80; // [xsp+8h] [xbp-98h] BYREF
  int v81; // [xsp+Ch] [xbp-94h] BYREF
  _BYTE v82[4]; // [xsp+10h] [xbp-90h] BYREF
  int v83; // [xsp+14h] [xbp-8Ch] BYREF
  _BYTE v84[4]; // [xsp+18h] [xbp-88h] BYREF
  int v85; // [xsp+1Ch] [xbp-84h] BYREF
  unsigned __int64 v86; // [xsp+20h] [xbp-80h] BYREF
  unsigned __int64 v87; // [xsp+28h] [xbp-78h] BYREF
  int *v88; // [xsp+30h] [xbp-70h] BYREF
  _BYTE *v89; // [xsp+38h] [xbp-68h]
  int *v90; // [xsp+40h] [xbp-60h]
  unsigned __int64 *v91; // [xsp+48h] [xbp-58h]
  int *v92; // [xsp+50h] [xbp-50h]
  __int64 *v93; // [xsp+58h] [xbp-48h]
  int *v94; // [xsp+60h] [xbp-40h]
  int *v95; // [xsp+68h] [xbp-38h]
  _BYTE *v96; // [xsp+70h] [xbp-30h]
  int v97; // [xsp+78h] [xbp-28h] BYREF
  unsigned __int64 v98; // [xsp+80h] [xbp-20h]
  unsigned __int8 *v99; // [xsp+88h] [xbp-18h]
  char v100; // [xsp+90h] [xbp-10h]

  v6 = a2;
  v8 = a1;
  v9 = HIDWORD(a4);
  v10 = *a2;
  v84[0] = 48;
  v86 = v10;
  v87 = a4;
  v11 = byte_1017AEE[__clz(v10 | 1) ^ 0x3F];
  v12 = v11 - (qword_1017B30[v11] > v10);
  v13 = BYTE5(a4);
  if ( BYTE5(a4) )
    v14 = (unsigned int)(v12 + 1);
  else
    v14 = (unsigned int)v12;
  v85 = v11 - (qword_1017B30[v11] > v10);
  v83 = BYTE5(a4);
  if ( (a4 & 0x2000000000000LL) != 0 )
  {
    if ( a5 )
    {
      v17 = a5;
      sub_67C4814((__int64 *)&v88, a5);
    }
    else
    {
      v17 = 0LL;
      sub_67C4788(&v88);
    }
    v19 = sub_67C4BB8((__int64 *)&v88, (__int64)&qword_795CEA8, v18);
    v15 = (*(__int64 (__fastcall **)(__int64 *))(*v19 + 24))(v19);
    sub_67C482C(&v88);
    v8 = a1;
    a5 = v17;
    v6 = a2;
  }
  else
  {
    v15 = 46;
  }
  v20 = *((unsigned int *)v6 + 2);
  v82[0] = v15;
  v21 = v12 + v20;
  if ( BYTE4(a4) != 1 )
  {
    if ( BYTE4(a4) || ((int)a4 <= 0 ? (v22 = 16) : (v22 = a4), v21 >= -3 ? (v23 = v21 <= v22) : (v23 = 0), v23) )
    {
      v81 = v12 + v20;
      if ( (v20 & 0x80000000) == 0 )
      {
        v26 = a4 - v21;
        v27 = v20 + v14;
        v80 = v26;
        if ( (v9 & 0x100000) != 0 )
        {
          v28 = v8;
          if ( v26 > 0 || (unsigned __int8)v9 == 2 )
          {
            if ( v26 < 1 )
              goto LABEL_68;
          }
          else
          {
            v26 = 1;
            v80 = 1;
          }
          v27 += (unsigned int)(v26 + 1);
        }
        else
        {
          v28 = v8;
        }
LABEL_68:
        sub_5370BA8(&v97, a5, ((unsigned int)v9 >> 17) & 1);
        v54 = v99;
        if ( (v97 & 1) != 0 )
        {
          v55 = v98;
        }
        else
        {
          v54 = (unsigned __int8 *)&v97 + 1;
          v55 = (unsigned __int64)(unsigned __int8)v97 >> 1;
        }
        v56 = 0;
        if ( v100 )
        {
          v57 = 0;
          v58 = &v54[v55];
          v59 = v28;
          if ( v58 == v54 )
            goto LABEL_75;
LABEL_73:
          v60 = *v54;
          if ( (unsigned int)(v60 - 127) >= 0xFFFFFF82 )
          {
            ++v54;
            while ( 1 )
            {
              v57 += v60;
              if ( v57 >= v12 )
                break;
              ++v56;
              if ( v58 != v54 )
                goto LABEL_73;
LABEL_75:
              v60 = (char)*(v58 - 1);
            }
          }
        }
        else
        {
          v59 = v28;
        }
        v61 = *(_WORD *)((char *)a3 + 9);
        v62 = v27 + v56;
        v88 = &v83;
        v89 = &v86;
        v90 = &v85;
        v91 = v6;
        v63 = *a3;
        v92 = &v97;
        v93 = (__int64 *)&v87;
        v64 = byte_173E2B4[v61 & 0xF];
        v49 = v63 >= v62;
        v65 = v63 - v62;
        if ( v49 )
          v66 = v65;
        else
          v66 = 0LL;
        v67 = v66 >> v64;
        v94 = (int *)v82;
        v95 = &v80;
        v96 = v84;
        if ( v66 >> v64 )
          v59 = sub_24EFF44(v59, v66 >> v64, (char *)a3 + 11);
        v68 = sub_679668C(&v88, v59);
        v52 = v68;
        if ( v66 == v67 )
          goto LABEL_101;
        v69 = sub_24EFF44(v68, v66 - v67, (char *)a3 + 11);
LABEL_100:
        v52 = v69;
LABEL_101:
        if ( (v97 & 1) != 0 )
          sub_6575460();
        return v52;
      }
      if ( v21 >= 1 )
      {
        v29 = v8;
        v80 = (a4 - v12) & ((int)((_DWORD)v9 << 11) >> 31);
        sub_5370BA8(&v97, a5, ((unsigned int)v9 >> 17) & 1);
        v31 = v99;
        if ( (v97 & 1) != 0 )
        {
          v32 = v98;
        }
        else
        {
          v31 = (unsigned __int8 *)&v97 + 1;
          v32 = (unsigned __int64)(unsigned __int8)v97 >> 1;
        }
        v33 = 0;
        if ( v100 )
        {
          v34 = 0;
          v35 = &v31[v32];
          v36 = v29;
          v37 = a3;
          if ( v35 == v31 )
            goto LABEL_34;
LABEL_32:
          v38 = *v31;
          if ( (unsigned int)(v38 - 127) >= 0xFFFFFF82 )
          {
            ++v31;
            while ( 1 )
            {
              v34 += v38;
              if ( v34 >= v12 )
                break;
              ++v33;
              if ( v35 != v31 )
                goto LABEL_32;
LABEL_34:
              v38 = (char)*(v35 - 1);
            }
          }
        }
        else
        {
          v36 = v29;
          v37 = a3;
        }
        v88 = &v83;
        v89 = &v86;
        v90 = &v85;
        v91 = (unsigned __int64 *)&v81;
        v92 = (int *)v82;
        v93 = (__int64 *)&v97;
        v94 = &v80;
        v95 = (int *)v84;
        v30 = (((_DWORD)a4 - v12) & ((int)((_DWORD)v9 << 11) >> 31) & (unsigned int)~((int)((a4 - v12) & ((int)((_DWORD)v9 << 11) >> 31)) >> 31))
            + 1
            + v14;
        v69 = sub_6796A80(v36, v37, v30 + v33, v30 + v33, &v88);
        goto LABEL_100;
      }
      if ( (int)a4 < -v21 && (int)a4 > -1 && v12 == 0 )
        v72 = a4;
      else
        v72 = -v21;
      v97 = v72;
      if ( v72 | v12 )
      {
        LOBYTE(v80) = 1;
      }
      else
      {
        LOBYTE(v80) = (v9 & 0x100000) != 0;
        if ( (v9 & 0x100000) == 0 )
        {
          v74 = 1;
          goto LABEL_107;
        }
      }
      v74 = 2;
LABEL_107:
      v75 = *a3;
      v76 = (unsigned int)(v74 + v72) + v14;
      v49 = v75 >= v76;
      v77 = v75 - v76;
      if ( !v49 )
        v77 = 0LL;
      v78 = byte_173E2B4[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v88 = &v83;
      v89 = v84;
      v46 = (char *)a3 + 11;
      v90 = &v80;
      v91 = (unsigned __int64 *)v82;
      v51 = v77 - (v77 >> v78);
      v92 = &v97;
      v93 = (__int64 *)&v86;
      v94 = &v85;
      if ( v77 >> v78 )
        v8 = sub_24EFF44(v8, v77 >> v78, (char *)a3 + 11);
      v52 = sub_6796D10(&v88, v8);
      if ( v51 )
        return sub_24EFF44(v52, v51, v46);
      return v52;
    }
  }
  v24 = v21 - 1;
  if ( (v9 & 0x100000) != 0 )
  {
    v25 = ((_DWORD)a4 - v12) & (unsigned int)~(((int)a4 - v12) >> 31);
    v14 += v25;
  }
  else if ( v12 == 1 )
  {
    v15 = 0;
    LODWORD(v25) = 0;
    v82[0] = 0;
  }
  else
  {
    LODWORD(v25) = 0;
  }
  v23 = v21 <= 0;
  v40 = 1 - v21;
  if ( !v23 )
    v40 = v24;
  if ( (v9 & 0x10000) != 0 )
    v41 = 69;
  else
    v41 = 101;
  v42 = *a3;
  LODWORD(v88) = v13;
  v89 = (_BYTE *)v10;
  LODWORD(v90) = v12;
  BYTE4(v90) = v15;
  LODWORD(v91) = v25;
  BYTE4(v91) = 48;
  BYTE5(v91) = v41;
  LODWORD(v92) = v24;
  if ( (int)v42 < 1 )
    return sub_679638C(&v88, v8);
  v43 = 2LL;
  v44 = 3LL;
  if ( v15 )
    v45 = 3LL;
  else
    v45 = 2LL;
  if ( v40 > 999 )
    v44 = 4LL;
  if ( v40 > 99 )
    v43 = v44;
  v46 = (char *)a3 + 11;
  v47 = byte_173E2B4[*(_WORD *)((_BYTE *)a3 + 9) & 0xFLL];
  v48 = v14 + v43 + v45;
  v49 = v42 >= v48;
  v50 = v42 - v48;
  if ( !v49 )
    v50 = 0LL;
  v51 = v50 - (v50 >> v47);
  if ( v50 >> v47 )
    v8 = sub_24EFF44(v8, v50 >> v47, (char *)a3 + 11);
  v52 = sub_679638C(&v88, v8);
  if ( v51 )
    return sub_24EFF44(v52, v51, v46);
  return v52;
}


================================================================================
Function: sub_679638C (0x679638C)
================================================================================

__int64 __fastcall sub_679638C(unsigned int *a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w22
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x0
  int v12; // w22
  __int64 v13; // x20
  __int64 v14; // x8
  char v15; // w22
  __int64 v16; // x1
  __int64 v17; // x9
  char v19; // w9
  __int64 v20; // x10
  __int64 v21; // x8
  __int64 v22; // x1
  _BYTE v23[24]; // [xsp+0h] [xbp-20h] BYREF

  v4 = *a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_173E2BE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_67964E8(v23, *((_QWORD *)a1 + 1), a1[4], 1LL, *((unsigned __int8 *)a1 + 20));
  v11 = sub_53712B8((unsigned __int64)v23, v10, a2);
  v12 = a1[6];
  v13 = v11;
  if ( v12 >= 1 )
  {
    do
    {
      v21 = *(_QWORD *)(v13 + 16);
      v22 = v21 + 1;
      if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v21 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v13)(v13);
        v21 = *(_QWORD *)(v13 + 16);
        v22 = v21 + 1;
      }
      --v12;
      v19 = *((_BYTE *)a1 + 28);
      v20 = *(_QWORD *)(v13 + 8);
      *(_QWORD *)(v13 + 16) = v22;
      *(_BYTE *)(v20 + v21) = v19;
    }
    while ( v12 );
  }
  v14 = *(_QWORD *)(v13 + 16);
  v15 = *((_BYTE *)a1 + 29);
  v16 = v14 + 1;
  if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v14 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v13)(v13);
    v14 = *(_QWORD *)(v13 + 16);
    v16 = v14 + 1;
  }
  v17 = *(_QWORD *)(v13 + 8);
  *(_QWORD *)(v13 + 16) = v16;
  *(_BYTE *)(v17 + v14) = v15;
  return sub_67950A0(a1[8], v13);
}


================================================================================
Function: sub_67964E8 (0x67964E8)
================================================================================

__int64 __fastcall sub_67964E8(__int64 a1, unsigned __int64 a2, int a3, int a4, char a5)
{
  unsigned int v5; // w11
  __int64 result; // x0
  unsigned int v7; // w13
  __int64 v8; // x9
  unsigned __int64 v9; // x10
  unsigned __int64 v10; // x15
  char v11; // w12
  __int64 v12; // x9
  bool v13; // cc
  unsigned __int64 v14; // x11
  unsigned __int64 v15; // x14
  __int64 v16; // x8
  unsigned __int64 v17; // x9
  unsigned __int64 v18; // x13

  if ( !a5 )
  {
    result = a1 + a3;
    if ( a2 < 0x64 )
    {
      v16 = result;
      v17 = a2;
      if ( a2 <= 9 )
      {
LABEL_15:
        *(_BYTE *)(v16 - 1) = v17 + 48;
        return result;
      }
    }
    else
    {
      v16 = result;
      do
      {
        v13 = a2 >> 4 > 0x270;
        v17 = a2 / 0x64;
        v18 = a2 % 0x64;
        a2 /= 0x64uLL;
        *(_WORD *)(v16 - 2) = *(_WORD *)&a00010203040506_1[2 * v18];
        v16 -= 2LL;
      }
      while ( v13 );
      if ( v17 <= 9 )
        goto LABEL_15;
    }
    *(_WORD *)(v16 - 2) = *(_WORD *)&a00010203040506_1[2 * v17];
    return result;
  }
  v5 = a3 - a4;
  result = a1 + a3 + 1;
  if ( a3 - a4 < 2 )
  {
    v9 = a2;
    v8 = result;
    if ( (v5 & 1) == 0 )
      goto LABEL_7;
  }
  else
  {
    v7 = (v5 >> 1) + 1;
    v8 = result;
    do
    {
      --v7;
      v9 = a2 / 0x64;
      v10 = a2 % 0x64;
      a2 /= 0x64uLL;
      *(_WORD *)(v8 - 2) = *(_WORD *)&a00010203040506_1[2 * v10];
      v8 -= 2LL;
    }
    while ( v7 > 1 );
    if ( (v5 & 1) == 0 )
      goto LABEL_7;
  }
  v11 = (v9 % 0xA) | 0x30;
  v9 /= 0xAuLL;
  *(_BYTE *)--v8 = v11;
LABEL_7:
  *(_BYTE *)(v8 - 1) = a5;
  v12 = v8 - 1;
  if ( v9 < 0x64 )
  {
    v14 = v9;
    if ( v9 <= 9 )
    {
LABEL_10:
      *(_BYTE *)(v12 - 1) = v14 + 48;
      return result;
    }
  }
  else
  {
    do
    {
      v13 = v9 >> 4 > 0x270;
      v14 = v9 / 0x64;
      v15 = v9 % 0x64;
      v9 /= 0x64uLL;
      *(_WORD *)(v12 - 2) = *(_WORD *)&a00010203040506_1[2 * v15];
      v12 -= 2LL;
    }
    while ( v13 );
    if ( v14 <= 9 )
      goto LABEL_10;
  }
  *(_WORD *)(v12 - 2) = *(_WORD *)&a00010203040506_1[2 * v14];
  return result;
}


================================================================================
Function: sub_679668C (0x679668C)
================================================================================

__int64 __fastcall sub_679668C(unsigned int **a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x20
  __int64 v12; // x8
  unsigned int *v13; // x21
  __int64 v14; // x1
  char v15; // w9
  int v16; // w21
  unsigned int *v17; // x19
  char v18; // w9
  __int64 v19; // x10
  __int64 v20; // x8
  __int64 v21; // x1

  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_173E2BE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_67967C8(a2, *(_QWORD *)a1[1], *a1[2], a1[3][2], a1[4]);
  v11 = v10;
  if ( (*((_BYTE *)a1[5] + 6) & 0x10) != 0 )
  {
    v12 = *(_QWORD *)(v10 + 16);
    v13 = a1[6];
    v14 = v12 + 1;
    if ( *(_QWORD *)(v10 + 24) < (unsigned __int64)(v12 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v10)(v10);
      v12 = *(_QWORD *)(v11 + 16);
      v14 = v12 + 1;
    }
    v15 = *(_BYTE *)v13;
    *(_QWORD *)(v11 + 16) = v14;
    *(_BYTE *)(*(_QWORD *)(v11 + 8) + v12) = v15;
    v16 = *a1[7];
    if ( v16 >= 1 )
    {
      v17 = a1[8];
      do
      {
        v20 = *(_QWORD *)(v11 + 16);
        v21 = v20 + 1;
        if ( *(_QWORD *)(v11 + 24) < (unsigned __int64)(v20 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v11)(v11);
          v20 = *(_QWORD *)(v11 + 16);
          v21 = v20 + 1;
        }
        --v16;
        v18 = *(_BYTE *)v17;
        v19 = *(_QWORD *)(v11 + 8);
        *(_QWORD *)(v11 + 16) = v21;
        *(_BYTE *)(v19 + v20) = v18;
      }
      while ( v16 );
    }
  }
  return v11;
}


================================================================================
Function: sub_67967C8 (0x67967C8)
================================================================================

__int64 __fastcall sub_67967C8(__int64 a1, unsigned __int64 a2, int a3, int a4, __int64 a5)
{
  _BYTE *v8; // x9
  bool v9; // cc
  unsigned __int64 v10; // x10
  unsigned __int64 v11; // x14
  char *v12; // x9
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x14
  __int64 v15; // x8
  __int64 v16; // x1
  __int64 v17; // x20
  __int64 v18; // x9
  __int64 v19; // x8
  __int64 v20; // x1
  void (__fastcall **v22)(_QWORD); // [xsp+8h] [xbp-238h] BYREF
  _BYTE *v23; // [xsp+10h] [xbp-230h]
  __int128 v24; // [xsp+18h] [xbp-228h]
  _BYTE v25[508]; // [xsp+28h] [xbp-218h] BYREF
  _BYTE v26[20]; // [xsp+224h] [xbp-1Ch] BYREF

  if ( *(_BYTE *)(a5 + 24) )
  {
    v22 = (void (__fastcall **)(_QWORD))&off_6BE0B98;
    v23 = v25;
    v24 = xmmword_AFDC90;
    if ( a2 < 0x64 )
    {
      v8 = &v26[a3];
      v10 = a2;
      if ( a2 <= 9 )
      {
LABEL_6:
        *(v8 - 1) = v10 + 48;
LABEL_14:
        sub_53712B8((unsigned __int64)v26, (__int64)&v26[a3], (__int64)&v22);
        if ( a4 >= 1 )
        {
          do
          {
            v15 = v24;
            v16 = v24 + 1;
            if ( *((_QWORD *)&v24 + 1) < (unsigned __int64)(v24 + 1) )
            {
              (*v22)(&v22);
              v15 = v24;
              v16 = v24 + 1;
            }
            --a4;
            *(_QWORD *)&v24 = v16;
            v23[v15] = 48;
          }
          while ( a4 );
        }
        v17 = sub_5370F24(a5, a1, v23, v24);
        if ( v23 != v25 )
          sub_6575460();
        return v17;
      }
    }
    else
    {
      v8 = &v26[a3];
      do
      {
        v9 = a2 >> 4 > 0x270;
        v10 = a2 / 0x64;
        v11 = a2 % 0x64;
        a2 /= 0x64uLL;
        *((_WORD *)v8 - 1) = *(_WORD *)&a00010203040506_1[2 * v11];
        v8 -= 2;
      }
      while ( v9 );
      if ( v10 <= 9 )
        goto LABEL_6;
    }
    *((_WORD *)v8 - 1) = *(_WORD *)&a00010203040506_1[2 * v10];
    goto LABEL_14;
  }
  if ( a2 < 0x64 )
  {
    v12 = (char *)&v22 + a3;
    v13 = a2;
    if ( a2 <= 9 )
    {
LABEL_11:
      *(v12 - 1) = v13 + 48;
      goto LABEL_23;
    }
  }
  else
  {
    v12 = (char *)&v22 + a3;
    do
    {
      v9 = a2 >> 4 > 0x270;
      v13 = a2 / 0x64;
      v14 = a2 % 0x64;
      a2 /= 0x64uLL;
      *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v14];
      v12 -= 2;
    }
    while ( v9 );
    if ( v13 <= 9 )
      goto LABEL_11;
  }
  *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
LABEL_23:
  v17 = sub_53712B8((unsigned __int64)&v22, (__int64)&v22 + a3, a1);
  if ( a4 >= 1 )
  {
    do
    {
      v19 = *(_QWORD *)(v17 + 16);
      v20 = v19 + 1;
      if ( *(_QWORD *)(v17 + 24) < (unsigned __int64)(v19 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v17)(v17);
        v19 = *(_QWORD *)(v17 + 16);
        v20 = v19 + 1;
      }
      --a4;
      v18 = *(_QWORD *)(v17 + 8);
      *(_QWORD *)(v17 + 16) = v20;
      *(_BYTE *)(v18 + v19) = 48;
    }
    while ( a4 );
  }
  return v17;
}


================================================================================
Function: sub_6796A80 (0x6796A80)
================================================================================

__int64 __fastcall sub_6796A80(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x8
  char v14; // w24
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x22
  __int64 v18; // x21
  int v19; // w23
  unsigned int *v20; // x20
  char v21; // w9
  __int64 v22; // x10
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_173E2B4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_24EFF44(a1, v10 >> v9, v8);
  v12 = **a5;
  if ( (_DWORD)v12 )
  {
    v13 = *(_QWORD *)(v7 + 16);
    v14 = byte_173E2BE[v12];
    v15 = v13 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v13 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v13 = *(_QWORD *)(v7 + 16);
      v15 = v13 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v13) = v14;
  }
  v17 = v10 - v11;
  v18 = sub_6796BE8(v7, *(_QWORD *)a5[1], *a5[2], *a5[3], *(unsigned __int8 *)a5[4], a5[5]);
  v19 = *a5[6];
  if ( v19 >= 1 )
  {
    v20 = a5[7];
    do
    {
      v23 = *(_QWORD *)(v18 + 16);
      v24 = v23 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v23 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v23 = *(_QWORD *)(v18 + 16);
        v24 = v23 + 1;
      }
      --v19;
      v21 = *(_BYTE *)v20;
      v22 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v24;
      *(_BYTE *)(v22 + v23) = v21;
    }
    while ( v19 );
  }
  result = v18;
  if ( v17 )
    return sub_24EFF44(v18, v17, v8);
  return result;
}


================================================================================
Function: sub_6796BE8 (0x6796BE8)
================================================================================

__int64 __fastcall sub_6796BE8(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6)
{
  __int64 v9; // x0
  __int64 v10; // x19
  __int64 v11; // x0
  _UNKNOWN **v13; // [xsp+8h] [xbp-238h] BYREF
  _BYTE *v14; // [xsp+10h] [xbp-230h]
  __int128 v15; // [xsp+18h] [xbp-228h]
  _BYTE v16[504]; // [xsp+28h] [xbp-218h] BYREF
  _BYTE v17[24]; // [xsp+220h] [xbp-20h] BYREF

  if ( *(_BYTE *)(a6 + 24) )
  {
    v13 = &off_6BE0B98;
    v14 = v16;
    v15 = xmmword_AFDC90;
    v9 = sub_67964E8(v17, a2, a3, a4, a5);
    sub_53712B8((unsigned __int64)v17, v9, (__int64)&v13);
    sub_5370F24(a6, a1, v14, a4);
    v10 = sub_53712B8((unsigned __int64)&v14[a4], (__int64)&v14[v15], a1);
    if ( v14 != v16 )
      sub_6575460();
  }
  else
  {
    v11 = sub_67964E8(&v13, a2, a3, a4, a5);
    return sub_53712B8((unsigned __int64)&v13, v11, a1);
  }
  return v10;
}


================================================================================
Function: sub_6796D10 (0x6796D10)
================================================================================

__int64 __fastcall sub_6796D10(unsigned int **a1, __int64 a2)
{
  __int64 v3; // x19
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w22
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x8
  unsigned int *v11; // x22
  __int64 v12; // x1
  char v13; // w9
  __int64 v14; // x8
  unsigned int *v15; // x22
  __int64 v16; // x1
  char v17; // w9
  int v18; // w22
  unsigned int *v19; // x23
  char v20; // w9
  __int64 v21; // x10
  __int64 v22; // x8
  __int64 v23; // x1
  unsigned __int64 v24; // x10
  _BYTE *v25; // x1
  _BYTE *v26; // x9
  bool v27; // cc
  unsigned __int64 v28; // x11
  unsigned __int64 v29; // x14
  _BYTE v31[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v3 = a2;
  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_173E2BE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))v3)(v3);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(v3 + 8);
    *(_QWORD *)(v3 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = *(_QWORD *)(v3 + 16);
  v11 = a1[1];
  v12 = v10 + 1;
  if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v10 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v3)(v3);
    v10 = *(_QWORD *)(v3 + 16);
    v12 = v10 + 1;
  }
  v13 = *(_BYTE *)v11;
  *(_QWORD *)(v3 + 16) = v12;
  *(_BYTE *)(*(_QWORD *)(v3 + 8) + v10) = v13;
  if ( *(_BYTE *)a1[2] )
  {
    v14 = *(_QWORD *)(v3 + 16);
    v15 = a1[3];
    v16 = v14 + 1;
    if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v3)(v3);
      v14 = *(_QWORD *)(v3 + 16);
      v16 = v14 + 1;
    }
    v17 = *(_BYTE *)v15;
    *(_QWORD *)(v3 + 16) = v16;
    *(_BYTE *)(*(_QWORD *)(v3 + 8) + v14) = v17;
    v18 = *a1[4];
    if ( v18 >= 1 )
    {
      v19 = a1[1];
      do
      {
        v22 = *(_QWORD *)(v3 + 16);
        v23 = v22 + 1;
        if ( *(_QWORD *)(v3 + 24) < (unsigned __int64)(v22 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v3)(v3);
          v22 = *(_QWORD *)(v3 + 16);
          v23 = v22 + 1;
        }
        --v18;
        v20 = *(_BYTE *)v19;
        v21 = *(_QWORD *)(v3 + 8);
        *(_QWORD *)(v3 + 16) = v23;
        *(_BYTE *)(v21 + v22) = v20;
      }
      while ( v18 );
    }
    v24 = *(_QWORD *)a1[5];
    v25 = &v31[*a1[6]];
    if ( v24 < 0x64 )
    {
      v26 = &v31[*a1[6]];
      v28 = *(_QWORD *)a1[5];
      if ( v24 <= 9 )
      {
LABEL_19:
        *(v26 - 1) = v28 + 48;
        return sub_53712B8((unsigned __int64)v31, (__int64)v25, v3);
      }
    }
    else
    {
      v26 = &v31[*a1[6]];
      do
      {
        v27 = v24 >> 4 > 0x270;
        v28 = v24 / 0x64;
        v29 = v24 % 0x64;
        v24 /= 0x64uLL;
        *((_WORD *)v26 - 1) = *(_WORD *)&a00010203040506_1[2 * v29];
        v26 -= 2;
      }
      while ( v27 );
      if ( v28 <= 9 )
        goto LABEL_19;
    }
    *((_WORD *)v26 - 1) = *(_WORD *)&a00010203040506_1[2 * v28];
    return sub_53712B8((unsigned __int64)v31, (__int64)v25, v3);
  }
  return v3;
}


================================================================================
Function: sub_6796F3C (0x6796F3C)
================================================================================

__int64 __fastcall sub_6796F3C(__int64 a1, _UNKNOWN **a2, _BYTE *a3, __int64 a4, long double a5)
{
  __int64 v7; // x0
  long double v8; // q0
  char v9; // w22
  unsigned int v10; // w21
  unsigned int v11; // w8
  int v12; // w9
  unsigned int v13; // w24
  int v14; // w0
  __int64 v15; // x8
  char v16; // w22
  __int64 v17; // x1
  __int64 v18; // x9
  char v19; // w8
  __int64 v20; // x0
  const char *v21; // x21
  const char *v22; // x22
  const char *v23; // x9
  __int64 v24; // x2
  __int64 v25; // x19
  bool v26; // cc
  unsigned int v27; // w22
  __int64 v28; // x24
  unsigned int v29; // w0
  long double v32; // [xsp+20h] [xbp-280h]
  long double v33; // [xsp+30h] [xbp-270h]
  long double v34; // [xsp+40h] [xbp-260h]
  _BYTE *v35; // [xsp+60h] [xbp-240h] BYREF
  unsigned __int64 v36; // [xsp+68h] [xbp-238h]
  _UNKNOWN **v37; // [xsp+70h] [xbp-230h] BYREF
  _BYTE *v38; // [xsp+78h] [xbp-228h]
  __int128 v39; // [xsp+80h] [xbp-220h]
  _BYTE v40[504]; // [xsp+90h] [xbp-210h] BYREF
  _UNKNOWN **v41; // [xsp+288h] [xbp-18h] BYREF
  unsigned __int64 v42; // [xsp+290h] [xbp-10h]

  v41 = a2;
  v42 = (unsigned __int64)a3;
  v7 = sub_67972A4(&v41, &v37);
  v8 = a5;
  v9 = BYTE1(v42);
  v10 = v7;
  v11 = HIDWORD(v7) & 0xFFFF00FF;
  if ( (*((_QWORD *)&a5 + 1) & 0x8000000000000000LL) != 0 )
  {
    v34 = a5;
    v13 = v11 | 0x100;
    HIBYTE(v34) = HIBYTE(a5) ^ 0x80;
    v8 = v34;
  }
  else
  {
    v12 = (16 * *(unsigned __int16 *)((char *)&v42 + 1)) & 0x700;
    if ( v12 == 256 )
      v12 = 0;
    v13 = v11 | v12;
  }
  v32 = v8;
  v33 = v8;
  HIBYTE(v33) = HIBYTE(v8) & 0x7F;
  v14 = ((__int64 (*)(void))sub_67EE758)();
  if ( (unsigned int)sub_67EE830(v33, *(long double *)&xmmword_AFC770) == 0 && v14 != 0 )
  {
    if ( (v9 & 0xF) == 4 && (v13 & 0xFF00) != 0 )
    {
      v15 = *(_QWORD *)(a1 + 16);
      v16 = byte_173E2BE[BYTE1(v13)];
      v17 = v15 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v15 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v15 = *(_QWORD *)(a1 + 16);
        v17 = v15 + 1;
      }
      v18 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v17;
      v13 &= 0xFFFF00FF;
      *(_BYTE *)(v18 + v15) = v16;
      if ( (_DWORD)v41 )
        LODWORD(v41) = (_DWORD)v41 - 1;
    }
    v37 = &off_6BE0B98;
    v38 = v40;
    v39 = xmmword_AFDC90;
    if ( (unsigned __int8)v13 == 3 )
    {
      if ( (v13 & 0xFF00) != 0 )
      {
        v19 = byte_173E2BE[BYTE1(v13)];
        *(_QWORD *)&v39 = 1LL;
        v40[0] = v19;
      }
      sub_6791778(HIDWORD(v41), v10 | ((unsigned __int64)v13 << 32), &v37, v32);
      v35 = v38;
      v36 = v39;
      v20 = sub_679735C(a1, &v41, v39, v39, &v35);
    }
    else
    {
      if ( (_BYTE)v42 )
        v26 = SHIDWORD(v41) <= -1;
      else
        v26 = 0;
      if ( v26 )
        v27 = 6;
      else
        v27 = HIDWORD(v41);
      if ( (unsigned __int8)v13 == 1 )
      {
        if ( v27 == 0x7FFFFFFF )
          sub_678FF08("number is too big");
        ++v27;
      }
      v28 = v13 | 0x80000;
      v29 = sub_67935A0(v27, v10 | ((unsigned __int64)(unsigned int)v28 << 32), &v37, v32);
      v35 = v38;
      v36 = __PAIR64__(v29, v39);
      v20 = sub_6797560(a1, &v35, &v41, (v28 << 32) | v27, a4);
    }
    v25 = v20;
    if ( v38 != v40 )
      sub_6575460();
  }
  else
  {
    v37 = v41;
    v38 = (_BYTE *)v42;
    if ( (v42 & 0xFF000000FF000000LL) == 0x100000030000000LL )
      BYTE3(v38) = 32;
    if ( (v13 & 0x10000) != 0 )
      v21 = "INF";
    else
      v21 = "inf";
    if ( (v13 & 0x10000) != 0 )
      v22 = "NAN";
    else
      v22 = "nan";
    if ( (unsigned int)sub_67EE758(v33, *(long double *)&xmmword_AFC770) )
      v23 = v22;
    else
      v23 = v21;
    if ( BYTE1(v13) )
      v24 = 4LL;
    else
      v24 = 3LL;
    LODWORD(v35) = BYTE1(v13);
    v36 = (unsigned __int64)v23;
    return sub_67946E0(a1, &v37, v24, v24, &v35);
  }
  return v25;
}


================================================================================
Function: sub_67972A4 (0x67972A4)
================================================================================

__int64 __fastcall sub_67972A4(__int64 a1)
{
  unsigned int v1; // w8
  int v2; // w9
  __int64 v3; // x8

  v1 = *(unsigned __int16 *)(a1 + 9);
  v2 = (v1 >> 7) & 1;
  v3 = (((v1 >> 8) & 1) << 17) & 0xFFEFFFFF | (v2 << 20);
  switch ( *(_BYTE *)(a1 + 8) )
  {
    case 0:
      return v3 << 32;
    case 7:
      goto LABEL_3;
    case 8:
      LODWORD(v3) = v3 | 0x10000;
LABEL_3:
      v3 = v3 & 0x1FFF00 | 3;
      return v3 << 32;
    case 9:
      goto LABEL_5;
    case 0xA:
      LODWORD(v3) = v3 | 0x10000;
LABEL_5:
      v3 = v3 & 0xFFF00 | (((*(_DWORD *)(a1 + 4) != 0) | (unsigned int)v2) << 20) | 1;
      return v3 << 32;
    case 0xB:
      goto LABEL_7;
    case 0xC:
      LODWORD(v3) = v3 | 0x10000;
LABEL_7:
      v3 = v3 & 0xFFF00 | (((*(_DWORD *)(a1 + 4) != 0) | (unsigned int)v2) << 20) | 2;
      return v3 << 32;
    case 0xD:
      goto LABEL_9;
    case 0xE:
      LODWORD(v3) = v3 | 0x10000;
LABEL_9:
      v3 &= 0x1FFF00u;
      return v3 << 32;
    default:
      sub_678FF08((__int64)"invalid type specifier");
  }
}


================================================================================
Function: sub_679735C (0x679735C)
================================================================================

__int64 __fastcall sub_679735C(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned __int64 *a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x19
  char *v8; // x20
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x21
  unsigned __int64 v12; // x8
  unsigned __int64 v13; // x21
  unsigned __int64 v14; // x22
  __int64 v15; // x10
  __int64 v16; // x23
  __int64 v17; // x24
  unsigned __int64 v18; // x8
  unsigned __int64 v19; // x12
  unsigned __int64 v20; // x8
  __int64 v21; // x11
  _BYTE *v22; // x9
  char *v23; // x13
  unsigned __int64 v24; // x14
  __int64 v25; // x15
  _OWORD *v26; // x13
  __int128 *v27; // x14
  unsigned __int64 v28; // x16
  __int128 v29; // q0
  __int128 v30; // q1
  __int64 *v31; // x16
  _QWORD *v32; // x11
  __int64 v33; // x15
  __int64 v34; // t1
  char v35; // t1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_173E2B4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_24EFF44(a1, v10 >> v9, v8);
  v12 = a5[1];
  v13 = v10 - v11;
  if ( v12 )
  {
    v14 = *a5;
    v15 = *(_QWORD *)(v7 + 16);
    v16 = v14 + v12;
    v17 = v12 + v14;
    do
    {
      v18 = *(_QWORD *)(v7 + 24);
      if ( v18 < v16 - v14 + v15 )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v15 = *(_QWORD *)(v7 + 16);
        v18 = *(_QWORD *)(v7 + 24);
      }
      v19 = v18 - v15;
      if ( v18 - v15 >= v16 - v14 )
        v20 = v16 - v14;
      else
        v20 = v18 - v15;
      if ( !v20 )
        goto LABEL_9;
      v21 = *(_QWORD *)(v7 + 8);
      v22 = (_BYTE *)(v21 + v15);
      if ( v20 >= 8 )
      {
        if ( (unsigned __int64)v22 >= v14 + v20 || (v24 = v20, v23 = (char *)v14, v14 >= v21 + v15 + v20) )
        {
          if ( v20 < 0x20 )
          {
            v25 = 0LL;
LABEL_26:
            v31 = (__int64 *)(v14 + v25);
            if ( v17 - v14 < v19 )
              v19 = v17 - v14;
            v32 = (_QWORD *)(v21 + v15 + v25);
            v23 = (char *)(v14 + (v19 & 0xFFFFFFFFFFFFFFF8LL));
            v22 += v19 & 0xFFFFFFFFFFFFFFF8LL;
            v24 = v20 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            v33 = v25 - (v19 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v34 = *v31++;
              v33 += 8LL;
              *v32++ = v34;
            }
            while ( v33 );
            if ( v19 == (v19 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_8;
            goto LABEL_33;
          }
          v25 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          v26 = (_OWORD *)(v21 + v15 + 16);
          v27 = (__int128 *)(v14 + 16);
          v28 = v20 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v29 = *(v27 - 1);
            v30 = *v27;
            v27 += 2;
            v28 -= 32LL;
            *(v26 - 1) = v29;
            *v26 = v30;
            v26 += 2;
          }
          while ( v28 );
          if ( v20 == v25 )
            goto LABEL_8;
          if ( (v20 & 0x18) != 0 )
            goto LABEL_26;
          v24 = v20 & 0x1F;
          v22 += v25;
          v23 = (char *)(v14 + v25);
        }
      }
      else
      {
        v23 = (char *)v14;
        v24 = v20;
      }
      do
      {
LABEL_33:
        v35 = *v23++;
        --v24;
        *v22++ = v35;
      }
      while ( v24 );
LABEL_8:
      v15 = *(_QWORD *)(v7 + 16);
LABEL_9:
      v15 += v20;
      v14 += v20;
      *(_QWORD *)(v7 + 16) = v15;
    }
    while ( v14 != v16 );
  }
  result = v7;
  if ( v13 )
    return sub_24EFF44(v7, v13, v8);
  return result;
}


================================================================================
Function: sub_6797560 (0x6797560)
================================================================================

__int64 __fastcall sub_6797560(__int64 a1, __int64 a2, unsigned int *a3, unsigned __int64 a4, __int64 *a5)
{
  __int64 v8; // x15
  unsigned __int64 v9; // x28
  signed int v10; // w26
  int v11; // w19
  _BYTE *v12; // x25
  __int64 v13; // x14
  char v14; // w24
  __int64 *v16; // x22
  __int64 v17; // x2
  __int64 *v18; // x0
  __int64 v19; // x9
  int v20; // w8
  int v21; // w10
  int v22; // w8
  __int64 v23; // x23
  __int64 v24; // x24
  int v25; // w9
  __int64 v26; // x10
  __int64 v27; // x20
  __int64 v28; // x19
  unsigned __int8 *v29; // x9
  unsigned __int64 v30; // x11
  unsigned int v31; // w8
  int v32; // w10
  unsigned __int8 *v33; // x11
  __int64 v34; // x0
  unsigned int *v35; // x1
  int v36; // w12
  int v37; // w8
  char v38; // w12
  unsigned __int64 v39; // x11
  __int64 v40; // x9
  __int64 v41; // x13
  __int64 v42; // x12
  char *v43; // x20
  char v44; // w8
  unsigned __int64 v45; // x9
  bool v46; // cf
  unsigned __int64 v47; // x9
  unsigned __int64 v48; // x21
  __int64 v49; // x19
  unsigned __int8 *v51; // x9
  unsigned __int64 v52; // x11
  unsigned int v53; // w8
  int v54; // w10
  unsigned __int8 *v55; // x11
  __int64 v56; // x1
  int v57; // w12
  char v58; // w12
  unsigned __int64 v59; // x8
  unsigned __int64 v60; // x11
  char v61; // w9
  unsigned __int64 v62; // x8
  unsigned __int64 v63; // x22
  unsigned __int64 v64; // x21
  __int64 v65; // x0
  __int64 v66; // x0
  bool v67; // cc
  int v69; // w8
  int v71; // w9
  unsigned __int64 v72; // x13
  unsigned __int64 v73; // x8
  unsigned __int64 v74; // x8
  char v75; // w10
  __int64 v76; // [xsp+0h] [xbp-A0h]
  int v77; // [xsp+8h] [xbp-98h] BYREF
  int v78; // [xsp+Ch] [xbp-94h] BYREF
  _BYTE v79[4]; // [xsp+10h] [xbp-90h] BYREF
  int v80; // [xsp+14h] [xbp-8Ch] BYREF
  _BYTE v81[4]; // [xsp+18h] [xbp-88h] BYREF
  int v82; // [xsp+1Ch] [xbp-84h] BYREF
  _BYTE *v83; // [xsp+20h] [xbp-80h] BYREF
  unsigned __int64 v84; // [xsp+28h] [xbp-78h] BYREF
  int *v85; // [xsp+30h] [xbp-70h] BYREF
  _BYTE *v86; // [xsp+38h] [xbp-68h]
  int *v87; // [xsp+40h] [xbp-60h]
  int *v88; // [xsp+48h] [xbp-58h]
  int *v89; // [xsp+50h] [xbp-50h]
  int *v90; // [xsp+58h] [xbp-48h]
  int *v91; // [xsp+60h] [xbp-40h]
  int *v92; // [xsp+68h] [xbp-38h]
  _BYTE *v93; // [xsp+70h] [xbp-30h]
  int v94; // [xsp+78h] [xbp-28h] BYREF
  unsigned __int64 v95; // [xsp+80h] [xbp-20h]
  unsigned __int8 *v96; // [xsp+88h] [xbp-18h]
  char v97; // [xsp+90h] [xbp-10h]

  v8 = a1;
  v9 = HIDWORD(a4);
  v10 = *(_DWORD *)(a2 + 8);
  v11 = BYTE5(a4);
  v12 = *(_BYTE **)a2;
  v81[0] = 48;
  if ( BYTE5(a4) )
    v13 = (unsigned int)(v10 + 1);
  else
    v13 = (unsigned int)v10;
  v82 = v10;
  v83 = v12;
  v84 = a4;
  v80 = BYTE5(a4);
  if ( (a4 & 0x2000000000000LL) != 0 )
  {
    v76 = v13;
    if ( a5 )
    {
      v16 = a5;
      sub_67C4814((__int64 *)&v85, a5);
    }
    else
    {
      v16 = 0LL;
      sub_67C4788(&v85);
    }
    v18 = sub_67C4BB8((__int64 *)&v85, (__int64)&qword_795CEA8, v17);
    v14 = (*(__int64 (__fastcall **)(__int64 *))(*v18 + 24))(v18);
    sub_67C482C(&v85);
    v8 = a1;
    v13 = v76;
    a5 = v16;
  }
  else
  {
    v14 = 46;
  }
  v19 = *(unsigned int *)(a2 + 12);
  v79[0] = v14;
  v20 = v10 + v19;
  if ( BYTE4(a4) != 1 )
  {
    if ( BYTE4(a4) || ((int)a4 <= 0 ? (v21 = 16) : (v21 = a4), v20 >= -3 && v20 <= v21) )
    {
      v78 = v10 + v19;
      if ( (v19 & 0x80000000) == 0 )
      {
        v22 = a4 - v20;
        v23 = v19 + v13;
        v77 = v22;
        if ( (v9 & 0x100000) == 0 )
        {
          v24 = v8;
LABEL_63:
          sub_5370BA8(&v94, a5, ((unsigned int)v9 >> 17) & 1);
          v51 = v96;
          if ( (v94 & 1) != 0 )
          {
            v52 = v95;
          }
          else
          {
            v51 = (unsigned __int8 *)&v94 + 1;
            v52 = (unsigned __int64)(unsigned __int8)v94 >> 1;
          }
          v53 = 0;
          if ( v97 )
          {
            v54 = 0;
            v55 = &v51[v52];
            v56 = v24;
            if ( v55 == v51 )
              goto LABEL_70;
LABEL_68:
            v57 = *v51;
            if ( (unsigned int)(v57 - 127) >= 0xFFFFFF82 )
            {
              ++v51;
              while ( 1 )
              {
                v54 += v57;
                if ( v54 >= v10 )
                  break;
                ++v53;
                if ( v55 != v51 )
                  goto LABEL_68;
LABEL_70:
                v57 = (char)*(v55 - 1);
              }
            }
          }
          else
          {
            v56 = v24;
          }
          v58 = *(_WORD *)((char *)a3 + 9);
          v59 = v23 + v53;
          v85 = &v80;
          v86 = &v83;
          v87 = &v82;
          v88 = (int *)a2;
          v60 = *a3;
          v89 = &v94;
          v90 = (int *)&v84;
          v61 = byte_173E2B4[v58 & 0xF];
          v46 = v60 >= v59;
          v62 = v60 - v59;
          if ( v46 )
            v63 = v62;
          else
            v63 = 0LL;
          v64 = v63 >> v61;
          v91 = (int *)v79;
          v92 = &v77;
          v93 = v81;
          if ( v63 >> v61 )
            v56 = sub_24EFF44(v56, v63 >> v61, (char *)a3 + 11);
          v65 = sub_6797E60(&v85, v56);
          v49 = v65;
          if ( v63 == v64 )
            goto LABEL_96;
          v66 = sub_24EFF44(v65, v63 - v64, (char *)a3 + 11);
LABEL_95:
          v49 = v66;
LABEL_96:
          if ( (v94 & 1) != 0 )
            sub_6575460();
          return v49;
        }
        if ( v22 > 0 || (unsigned __int8)v9 == 2 )
        {
          v24 = v8;
          if ( v22 < 1 )
            goto LABEL_63;
        }
        else
        {
          v22 = 1;
          v24 = v8;
          v77 = 1;
        }
        v23 += (unsigned int)(v22 + 1);
        goto LABEL_63;
      }
      if ( v20 >= 1 )
      {
        v27 = v8;
        v77 = (a4 - v10) & ((int)((_DWORD)v9 << 11) >> 31);
        v28 = (v77 & (unsigned int)~(v77 >> 31)) + 1 + v13;
        sub_5370BA8(&v94, a5, ((unsigned int)v9 >> 17) & 1);
        v29 = v96;
        if ( (v94 & 1) != 0 )
        {
          v30 = v95;
        }
        else
        {
          v29 = (unsigned __int8 *)&v94 + 1;
          v30 = (unsigned __int64)(unsigned __int8)v94 >> 1;
        }
        v31 = 0;
        if ( v97 )
        {
          v32 = 0;
          v33 = &v29[v30];
          v34 = v27;
          v35 = a3;
          if ( v33 == v29 )
            goto LABEL_32;
LABEL_30:
          v36 = *v29;
          if ( (unsigned int)(v36 - 127) >= 0xFFFFFF82 )
          {
            ++v29;
            while ( 1 )
            {
              v32 += v36;
              if ( v32 >= v10 )
                break;
              ++v31;
              if ( v33 != v29 )
                goto LABEL_30;
LABEL_32:
              v36 = (char)*(v33 - 1);
            }
          }
        }
        else
        {
          v34 = v27;
          v35 = a3;
        }
        v85 = &v80;
        v86 = &v83;
        v87 = &v82;
        v88 = &v78;
        v89 = (int *)v79;
        v90 = &v94;
        v91 = &v77;
        v92 = (int *)v81;
        v66 = sub_67983D4(v34, v35, v28 + v31, v28 + v31, &v85);
        goto LABEL_95;
      }
      v67 = (int)a4 >= -v20 || (int)a4 <= -1;
      if ( !v67 && v10 == 0 )
        v69 = a4;
      else
        v69 = -v20;
      v94 = v69;
      if ( v69 | v10 )
      {
        LOBYTE(v77) = 1;
      }
      else
      {
        LOBYTE(v77) = (v9 & 0x100000) != 0;
        if ( (v9 & 0x100000) == 0 )
        {
          v71 = 1;
          goto LABEL_102;
        }
      }
      v71 = 2;
LABEL_102:
      v72 = *a3;
      v73 = (unsigned int)(v71 + v69) + v13;
      v46 = v72 >= v73;
      v74 = v72 - v73;
      if ( !v46 )
        v74 = 0LL;
      v75 = byte_173E2B4[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v85 = &v80;
      v86 = v81;
      v43 = (char *)a3 + 11;
      v87 = &v77;
      v88 = (int *)v79;
      v48 = v74 - (v74 >> v75);
      v89 = &v94;
      v90 = (int *)&v83;
      v91 = &v82;
      if ( v74 >> v75 )
        v8 = sub_24EFF44(v8, v74 >> v75, (char *)a3 + 11);
      v49 = sub_6798724(&v85, v8);
      if ( !v48 )
        return v49;
      return sub_24EFF44(v49, v48, v43);
    }
  }
  v25 = v20 - 1;
  if ( (v9 & 0x100000) != 0 )
  {
    v26 = ((_DWORD)a4 - v10) & (unsigned int)~(((int)a4 - v10) >> 31);
    v13 += v26;
  }
  else if ( v10 == 1 )
  {
    v14 = 0;
    LODWORD(v26) = 0;
    v79[0] = 0;
  }
  else
  {
    LODWORD(v26) = 0;
  }
  v67 = v20 <= 0;
  v37 = 1 - v20;
  if ( !v67 )
    v37 = v25;
  if ( (v9 & 0x10000) != 0 )
    v38 = 69;
  else
    v38 = 101;
  v39 = *a3;
  LODWORD(v85) = v11;
  v86 = v12;
  LODWORD(v87) = v10;
  BYTE4(v87) = v14;
  LODWORD(v88) = v26;
  BYTE4(v88) = 48;
  BYTE5(v88) = v38;
  LODWORD(v89) = v25;
  if ( (int)v39 < 1 )
    return sub_6797B64(&v85, v8);
  v40 = 2LL;
  v41 = 3LL;
  if ( v14 )
    v42 = 3LL;
  else
    v42 = 2LL;
  if ( v37 > 999 )
    v41 = 4LL;
  if ( v37 > 99 )
    v40 = v41;
  v43 = (char *)a3 + 11;
  v44 = byte_173E2B4[*(_WORD *)((_BYTE *)a3 + 9) & 0xFLL];
  v45 = v13 + v40 + v42;
  v46 = v39 >= v45;
  v47 = v39 - v45;
  if ( !v46 )
    v47 = 0LL;
  v48 = v47 - (v47 >> v44);
  if ( v47 >> v44 )
    v8 = sub_24EFF44(v8, v47 >> v44, (char *)a3 + 11);
  v49 = sub_6797B64(&v85, v8);
  if ( v48 )
    return sub_24EFF44(v49, v48, v43);
  return v49;
}


================================================================================
Function: sub_6797B64 (0x6797B64)
================================================================================

__int64 __fastcall sub_6797B64(unsigned int *a1, __int64 a2)
{
  __int64 v3; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  unsigned __int64 v10; // x21
  __int64 v11; // x23
  int v12; // w24
  __int64 v13; // x0
  __int64 v14; // x20
  __int64 v15; // x9
  __int64 v16; // x1
  int v17; // w21
  __int64 v18; // x8
  char v19; // w21
  __int64 v20; // x1
  __int64 v21; // x9
  char v23; // w9
  __int64 v24; // x10
  __int64 v25; // x8
  __int64 v26; // x1

  v3 = *a1;
  if ( (_DWORD)v3 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_173E2BE[v3];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = *((_QWORD *)a1 + 1);
  v11 = (int)a1[4];
  v12 = *((unsigned __int8 *)a1 + 20);
  v13 = sub_6797CE0(v10, v10 + 1, a2);
  v14 = v13;
  if ( v12 )
  {
    v15 = *(_QWORD *)(v13 + 16);
    v16 = v15 + 1;
    if ( *(_QWORD *)(v13 + 24) < (unsigned __int64)(v15 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v13)(v13);
      v15 = *(_QWORD *)(v14 + 16);
      v16 = v15 + 1;
    }
    *(_QWORD *)(v14 + 16) = v16;
    *(_BYTE *)(*(_QWORD *)(v14 + 8) + v15) = v12;
    v14 = sub_6797CE0(v10 + 1, v10 + v11, v14);
  }
  v17 = a1[6];
  if ( v17 >= 1 )
  {
    do
    {
      v25 = *(_QWORD *)(v14 + 16);
      v26 = v25 + 1;
      if ( *(_QWORD *)(v14 + 24) < (unsigned __int64)(v25 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v14)(v14);
        v25 = *(_QWORD *)(v14 + 16);
        v26 = v25 + 1;
      }
      --v17;
      v23 = *((_BYTE *)a1 + 28);
      v24 = *(_QWORD *)(v14 + 8);
      *(_QWORD *)(v14 + 16) = v26;
      *(_BYTE *)(v24 + v25) = v23;
    }
    while ( v17 );
  }
  v18 = *(_QWORD *)(v14 + 16);
  v19 = *((_BYTE *)a1 + 29);
  v20 = v18 + 1;
  if ( *(_QWORD *)(v14 + 24) < (unsigned __int64)(v18 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v14)(v14);
    v18 = *(_QWORD *)(v14 + 16);
    v20 = v18 + 1;
  }
  v21 = *(_QWORD *)(v14 + 8);
  *(_QWORD *)(v14 + 16) = v20;
  *(_BYTE *)(v21 + v18) = v19;
  return sub_67950A0(a1[8], v14);
}


================================================================================
Function: sub_6797CE0 (0x6797CE0)
================================================================================

__int64 __fastcall sub_6797CE0(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v5; // x21
  __int64 v6; // x10
  unsigned __int64 v7; // x8
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x12
  unsigned __int64 v10; // x8
  __int64 v11; // x11
  _BYTE *v12; // x9
  char *v13; // x13
  unsigned __int64 v14; // x14
  __int64 v15; // x15
  _OWORD *v16; // x13
  __int128 *v17; // x14
  unsigned __int64 v18; // x16
  __int128 v19; // q0
  __int128 v20; // q1
  _QWORD *v21; // x11
  __int64 *v22; // x16
  __int64 v23; // x15
  __int64 v24; // t1
  char v25; // t1

  if ( a1 != a2 )
  {
    v5 = a1;
    v6 = *(_QWORD *)(a3 + 16);
    do
    {
      v7 = *(_QWORD *)(a3 + 24);
      v8 = a2 - v5;
      if ( v7 < a2 - v5 + v6 )
      {
        (**(void (__fastcall ***)(__int64))a3)(a3);
        v6 = *(_QWORD *)(a3 + 16);
        v7 = *(_QWORD *)(a3 + 24);
      }
      v9 = v7 - v6;
      if ( v7 - v6 >= v8 )
        v10 = a2 - v5;
      else
        v10 = v7 - v6;
      if ( !v10 )
        goto LABEL_4;
      v11 = *(_QWORD *)(a3 + 8);
      v12 = (_BYTE *)(v11 + v6);
      if ( v10 >= 8 )
      {
        if ( (unsigned __int64)v12 >= v5 + v10 || (v14 = v10, v13 = (char *)v5, v5 >= v11 + v6 + v10) )
        {
          if ( v10 < 0x20 )
          {
            v15 = 0LL;
LABEL_21:
            if ( v9 >= v8 )
              v9 = a2 - v5;
            v21 = (_QWORD *)(v11 + v6 + v15);
            v22 = (__int64 *)(v5 + v15);
            v13 = (char *)(v5 + (v9 & 0xFFFFFFFFFFFFFFF8LL));
            v12 += v9 & 0xFFFFFFFFFFFFFFF8LL;
            v14 = v10 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
            v23 = v15 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v24 = *v22++;
              v23 += 8LL;
              *v21++ = v24;
            }
            while ( v23 );
            if ( v9 == (v9 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_3;
            goto LABEL_28;
          }
          v15 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          v16 = (_OWORD *)(v11 + v6 + 16);
          v17 = (__int128 *)(v5 + 16);
          v18 = v10 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v19 = *(v17 - 1);
            v20 = *v17;
            v17 += 2;
            v18 -= 32LL;
            *(v16 - 1) = v19;
            *v16 = v20;
            v16 += 2;
          }
          while ( v18 );
          if ( v10 == v15 )
            goto LABEL_3;
          if ( (v10 & 0x18) != 0 )
            goto LABEL_21;
          v14 = v10 & 0x1F;
          v12 += v15;
          v13 = (char *)(v5 + v15);
        }
      }
      else
      {
        v13 = (char *)v5;
        v14 = v10;
      }
      do
      {
LABEL_28:
        v25 = *v13++;
        --v14;
        *v12++ = v25;
      }
      while ( v14 );
LABEL_3:
      v6 = *(_QWORD *)(a3 + 16);
LABEL_4:
      v6 += v10;
      v5 += v10;
      *(_QWORD *)(a3 + 16) = v6;
    }
    while ( v5 != a2 );
  }
  return a3;
}


================================================================================
Function: sub_6797E60 (0x6797E60)
================================================================================

__int64 __fastcall sub_6797E60(unsigned int **a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x0
  __int64 v11; // x20
  __int64 v12; // x8
  unsigned int *v13; // x21
  __int64 v14; // x1
  char v15; // w9
  int v16; // w21
  unsigned int *v17; // x19
  char v18; // w9
  __int64 v19; // x10
  __int64 v20; // x8
  __int64 v21; // x1

  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_173E2BE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = sub_6797F9C(a2, *(_QWORD *)a1[1], *a1[2], a1[3][3], a1[4]);
  v11 = v10;
  if ( (*((_BYTE *)a1[5] + 6) & 0x10) != 0 )
  {
    v12 = *(_QWORD *)(v10 + 16);
    v13 = a1[6];
    v14 = v12 + 1;
    if ( *(_QWORD *)(v10 + 24) < (unsigned __int64)(v12 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v10)(v10);
      v12 = *(_QWORD *)(v11 + 16);
      v14 = v12 + 1;
    }
    v15 = *(_BYTE *)v13;
    *(_QWORD *)(v11 + 16) = v14;
    *(_BYTE *)(*(_QWORD *)(v11 + 8) + v12) = v15;
    v16 = *a1[7];
    if ( v16 >= 1 )
    {
      v17 = a1[8];
      do
      {
        v20 = *(_QWORD *)(v11 + 16);
        v21 = v20 + 1;
        if ( *(_QWORD *)(v11 + 24) < (unsigned __int64)(v20 + 1) )
        {
          (**(void (__fastcall ***)(__int64))v11)(v11);
          v20 = *(_QWORD *)(v11 + 16);
          v21 = v20 + 1;
        }
        --v16;
        v18 = *(_BYTE *)v17;
        v19 = *(_QWORD *)(v11 + 8);
        *(_QWORD *)(v11 + 16) = v21;
        *(_BYTE *)(v19 + v20) = v18;
      }
      while ( v16 );
    }
  }
  return v11;
}


================================================================================
Function: sub_6797F9C (0x6797F9C)
================================================================================

__int64 __fastcall sub_6797F9C(__int64 a1, unsigned __int64 a2, int a3, int a4, __int64 a5)
{
  unsigned __int64 v6; // x21
  __int64 v7; // x19
  __int64 v9; // x3
  __int64 v10; // x25
  unsigned __int64 i; // x8
  unsigned __int64 v12; // x26
  unsigned __int64 v13; // x11
  unsigned __int64 v14; // x8
  _BYTE *v15; // x10
  _BYTE *v16; // x9
  char *v17; // x12
  unsigned __int64 v18; // x13
  unsigned __int64 v19; // x14
  _OWORD *v20; // x12
  __int128 *v21; // x13
  unsigned __int64 v22; // x15
  __int128 v23; // q0
  __int128 v24; // q1
  _QWORD *v25; // x10
  __int64 *v26; // x16
  unsigned __int64 v27; // x14
  __int64 v28; // t1
  char v29; // t1
  __int64 v30; // x1
  __int64 v31; // x10
  __int64 v32; // x22
  unsigned __int64 v33; // x8
  unsigned __int64 v34; // x24
  unsigned __int64 v35; // x12
  unsigned __int64 v36; // x8
  __int64 v37; // x11
  _BYTE *v38; // x9
  char *v39; // x13
  unsigned __int64 v40; // x14
  __int64 v41; // x15
  _OWORD *v42; // x13
  __int128 *v43; // x14
  unsigned __int64 v44; // x16
  __int128 v45; // q0
  __int128 v46; // q1
  _QWORD *v47; // x11
  __int64 *v48; // x16
  __int64 v49; // x15
  __int64 v50; // t1
  char v51; // t1
  __int64 v52; // x9
  __int64 v53; // x8
  __int64 v54; // x1
  void (__fastcall **v56)(_QWORD); // [xsp+0h] [xbp-220h] BYREF
  _BYTE *v57; // [xsp+8h] [xbp-218h]
  __int128 v58; // [xsp+10h] [xbp-210h]
  _BYTE v59[504]; // [xsp+20h] [xbp-200h] BYREF

  v6 = a2;
  v7 = a1;
  if ( !*(_BYTE *)(a5 + 24) )
  {
    if ( !a3 )
    {
LABEL_67:
      if ( a4 >= 1 )
      {
        do
        {
          v53 = *(_QWORD *)(v7 + 16);
          v54 = v53 + 1;
          if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v53 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v7)(v7);
            v53 = *(_QWORD *)(v7 + 16);
            v54 = v53 + 1;
          }
          --a4;
          v52 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 16) = v54;
          *(_BYTE *)(v52 + v53) = 48;
        }
        while ( a4 );
      }
      return v7;
    }
    v31 = *(_QWORD *)(a1 + 16);
    v32 = a2 + a3;
    while ( 1 )
    {
      v33 = *(_QWORD *)(v7 + 24);
      v34 = v32 - v6;
      if ( v33 < v32 - v6 + v31 )
      {
        (**(void (__fastcall ***)(__int64))v7)(v7);
        v31 = *(_QWORD *)(v7 + 16);
        v33 = *(_QWORD *)(v7 + 24);
      }
      v35 = v33 - v31;
      if ( v33 - v31 >= v34 )
        v36 = v32 - v6;
      else
        v36 = v33 - v31;
      if ( !v36 )
        goto LABEL_41;
      v37 = *(_QWORD *)(v7 + 8);
      v38 = (_BYTE *)(v37 + v31);
      if ( v36 >= 8 )
      {
        if ( (unsigned __int64)v38 >= v6 + v36 || (v40 = v36, v39 = (char *)v6, v6 >= v37 + v31 + v36) )
        {
          if ( v36 < 0x20 )
          {
            v41 = 0LL;
LABEL_58:
            if ( v34 < v35 )
              v35 = v32 - v6;
            v47 = (_QWORD *)(v37 + v31 + v41);
            v48 = (__int64 *)(v6 + v41);
            v39 = (char *)(v6 + (v35 & 0xFFFFFFFFFFFFFFF8LL));
            v38 += v35 & 0xFFFFFFFFFFFFFFF8LL;
            v40 = v36 - (v35 & 0xFFFFFFFFFFFFFFF8LL);
            v49 = v41 - (v35 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              v50 = *v48++;
              v49 += 8LL;
              *v47++ = v50;
            }
            while ( v49 );
            if ( v35 == (v35 & 0xFFFFFFFFFFFFFFF8LL) )
              goto LABEL_40;
            goto LABEL_65;
          }
          v41 = v36 & 0xFFFFFFFFFFFFFFE0LL;
          v42 = (_OWORD *)(v37 + v31 + 16);
          v43 = (__int128 *)(v6 + 16);
          v44 = v36 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            v45 = *(v43 - 1);
            v46 = *v43;
            v43 += 2;
            v44 -= 32LL;
            *(v42 - 1) = v45;
            *v42 = v46;
            v42 += 2;
          }
          while ( v44 );
          if ( v36 == v41 )
            goto LABEL_40;
          if ( (v36 & 0x18) != 0 )
            goto LABEL_58;
          v40 = v36 & 0x1F;
          v38 += v41;
          v39 = (char *)(v6 + v41);
        }
      }
      else
      {
        v39 = (char *)v6;
        v40 = v36;
      }
      do
      {
LABEL_65:
        v51 = *v39++;
        --v40;
        *v38++ = v51;
      }
      while ( v40 );
LABEL_40:
      v31 = *(_QWORD *)(v7 + 16);
LABEL_41:
      v31 += v36;
      v6 += v36;
      *(_QWORD *)(v7 + 16) = v31;
      if ( v6 == v32 )
        goto LABEL_67;
    }
  }
  v9 = 0LL;
  v56 = (void (__fastcall **)(_QWORD))&off_6BE0B98;
  v57 = v59;
  v58 = xmmword_AFDC90;
  if ( a3 )
  {
    v10 = a2 + a3;
    for ( i = 500LL; ; i = *((_QWORD *)&v58 + 1) )
    {
      v12 = v10 - v6;
      if ( i < v10 - v6 + v9 )
      {
        (*v56)(&v56);
        i = *((_QWORD *)&v58 + 1);
        v9 = v58;
      }
      v13 = i - v9;
      v14 = i - v9 >= v12 ? v10 - v6 : i - v9;
      if ( v14 )
        break;
LABEL_29:
      v9 += v14;
      v6 += v14;
      *(_QWORD *)&v58 = v9;
      if ( v6 == v10 )
        goto LABEL_31;
    }
    v15 = v57;
    v16 = &v57[v9];
    if ( v14 < 8 )
    {
      v17 = (char *)v6;
      v18 = v14;
      goto LABEL_27;
    }
    if ( (unsigned __int64)v16 < v6 + v14 )
    {
      v18 = v14;
      v17 = (char *)v6;
      if ( v6 < (unsigned __int64)&v57[v9 + v14] )
        goto LABEL_27;
    }
    if ( v14 >= 0x20 )
    {
      v19 = v14 & 0xFFFFFFFFFFFFFFE0LL;
      v20 = &v57[v9 + 16];
      v21 = (__int128 *)(v6 + 16);
      v22 = v14 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        v23 = *(v21 - 1);
        v24 = *v21;
        v21 += 2;
        v22 -= 32LL;
        *(v20 - 1) = v23;
        *v20 = v24;
        v20 += 2;
      }
      while ( v22 );
      if ( v14 == v19 )
        goto LABEL_28;
      if ( (v14 & 0x18) == 0 )
      {
        v18 = v14 & 0x1F;
        v16 += v19;
        v17 = (char *)(v6 + v19);
        do
        {
LABEL_27:
          v29 = *v17++;
          --v18;
          *v16++ = v29;
        }
        while ( v18 );
LABEL_28:
        v9 = v58;
        goto LABEL_29;
      }
    }
    else
    {
      v19 = 0LL;
    }
    if ( v12 < v13 )
      v13 = v10 - v6;
    v25 = &v15[v9 + v19];
    v26 = (__int64 *)(v6 + v19);
    v17 = (char *)(v6 + (v13 & 0xFFFFFFFFFFFFFFF8LL));
    v16 += v13 & 0xFFFFFFFFFFFFFFF8LL;
    v18 = v14 - (v13 & 0xFFFFFFFFFFFFFFF8LL);
    v27 = v19 - (v13 & 0xFFFFFFFFFFFFFFF8LL);
    do
    {
      v28 = *v26++;
      v27 += 8LL;
      *v25++ = v28;
    }
    while ( v27 );
    if ( v13 == (v13 & 0xFFFFFFFFFFFFFFF8LL) )
      goto LABEL_28;
    goto LABEL_27;
  }
LABEL_31:
  if ( a4 >= 1 )
  {
    do
    {
      v30 = v9 + 1;
      if ( *((_QWORD *)&v58 + 1) < (unsigned __int64)(v9 + 1) )
      {
        (*v56)(&v56);
        v9 = v58;
        v30 = v58 + 1;
      }
      *(_QWORD *)&v58 = v30;
      --a4;
      v57[v9] = 48;
      v9 = v58;
    }
    while ( a4 );
  }
  v7 = sub_5370F24(a5, v7, v57, v9);
  if ( v57 != v59 )
    sub_6575460();
  return v7;
}


================================================================================
Function: sub_67983D4 (0x67983D4)
================================================================================

__int64 __fastcall sub_67983D4(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, unsigned int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x23
  unsigned __int64 v11; // x22
  __int64 v12; // x9
  __int64 v13; // x8
  char v14; // w24
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x22
  __int64 v18; // x21
  int v19; // w23
  unsigned int *v20; // x20
  char v21; // w9
  __int64 v22; // x10
  __int64 v23; // x8
  __int64 v24; // x1
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_173E2B4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_24EFF44(a1, v10 >> v9, v8);
  v12 = **a5;
  if ( (_DWORD)v12 )
  {
    v13 = *(_QWORD *)(v7 + 16);
    v14 = byte_173E2BE[v12];
    v15 = v13 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v13 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v13 = *(_QWORD *)(v7 + 16);
      v15 = v13 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v13) = v14;
  }
  v17 = v10 - v11;
  v18 = sub_679853C(v7, *(_QWORD *)a5[1], *a5[2], *a5[3], *(unsigned __int8 *)a5[4], a5[5]);
  v19 = *a5[6];
  if ( v19 >= 1 )
  {
    v20 = a5[7];
    do
    {
      v23 = *(_QWORD *)(v18 + 16);
      v24 = v23 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v23 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v23 = *(_QWORD *)(v18 + 16);
        v24 = v23 + 1;
      }
      --v19;
      v21 = *(_BYTE *)v20;
      v22 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v24;
      *(_BYTE *)(v22 + v23) = v21;
    }
    while ( v19 );
  }
  result = v18;
  if ( v17 )
    return sub_24EFF44(v18, v17, v8);
  return result;
}


================================================================================
Function: sub_679853C (0x679853C)
================================================================================

__int64 __fastcall sub_679853C(__int64 a1, unsigned __int64 a2, int a3, unsigned int a4, char a5, __int64 a6)
{
  __int64 v12; // x0
  __int64 v13; // x9
  __int64 v14; // x26
  __int64 v15; // x1
  __int64 v16; // x10
  __int64 v17; // x22
  __int64 v18; // x0
  __int64 v19; // x9
  __int64 v20; // x1
  _UNKNOWN **v22; // [xsp+8h] [xbp-228h] BYREF
  _BYTE *v23; // [xsp+10h] [xbp-220h]
  __int128 v24; // [xsp+18h] [xbp-218h]
  _BYTE v25[504]; // [xsp+28h] [xbp-208h] BYREF

  if ( *(_BYTE *)(a6 + 24) )
  {
    v22 = &off_6BE0B98;
    v23 = v25;
    v24 = xmmword_AFDC90;
    v12 = sub_6797CE0(a2, a2 + (int)a4, (__int64)&v22);
    if ( a5 )
    {
      v13 = *(_QWORD *)(v12 + 16);
      v14 = v12;
      v15 = v13 + 1;
      if ( *(_QWORD *)(v12 + 24) < (unsigned __int64)(v13 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v12)(v12);
        v13 = *(_QWORD *)(v14 + 16);
        v15 = v13 + 1;
      }
      v16 = *(_QWORD *)(v14 + 8);
      *(_QWORD *)(v14 + 16) = v15;
      *(_BYTE *)(v16 + v13) = a5;
      sub_6797CE0(a2 + (int)a4, a2 + a3, v14);
    }
    sub_5370F24(a6, a1, v23, a4);
    v17 = sub_53712B8((unsigned __int64)&v23[a4], (__int64)&v23[v24], a1);
    if ( v23 != v25 )
      sub_6575460();
  }
  else
  {
    v18 = sub_6797CE0(a2, a2 + (int)a4, a1);
    v17 = v18;
    if ( a5 )
    {
      v19 = *(_QWORD *)(v18 + 16);
      v20 = v19 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v19 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v19 = *(_QWORD *)(v17 + 16);
        v20 = v19 + 1;
      }
      *(_QWORD *)(v17 + 16) = v20;
      *(_BYTE *)(*(_QWORD *)(v17 + 8) + v19) = a5;
      return sub_6797CE0(a2 + (int)a4, a2 + a3, v17);
    }
  }
  return v17;
}


================================================================================
Function: sub_6798724 (0x6798724)
================================================================================

__int64 __fastcall sub_6798724(unsigned int **a1, __int64 a2)
{
  __int64 v4; // x9
  __int64 v5; // x8
  unsigned __int64 v6; // x11
  char v7; // w21
  __int64 v8; // x1
  __int64 v9; // x9
  __int64 v10; // x8
  unsigned int *v11; // x21
  __int64 v12; // x1
  char v13; // w9
  __int64 v14; // x8
  unsigned int *v15; // x21
  __int64 v16; // x1
  char v17; // w9
  int v18; // w21
  unsigned int *v19; // x22
  char v20; // w9
  __int64 v21; // x10
  __int64 v22; // x8
  __int64 v23; // x1
  __int64 v24; // x8
  __int64 v25; // x10
  unsigned __int64 v26; // x20
  __int64 v27; // x21
  unsigned __int64 v28; // x8
  unsigned __int64 v29; // x22
  unsigned __int64 v30; // x12
  unsigned __int64 v31; // x8
  __int64 v32; // x11
  _BYTE *v33; // x9
  char *v34; // x13
  unsigned __int64 v35; // x14
  __int64 v36; // x15
  _OWORD *v37; // x13
  __int128 *v38; // x14
  unsigned __int64 v39; // x16
  __int128 v40; // q0
  __int128 v41; // q1
  _QWORD *v42; // x11
  __int64 *v43; // x16
  __int64 v44; // x15
  __int64 v45; // t1
  char v46; // t1

  v4 = **a1;
  if ( (_DWORD)v4 )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = byte_173E2BE[v4];
    v8 = v5 + 1;
    if ( v6 < v5 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v5 = *(_QWORD *)(a2 + 16);
      v8 = v5 + 1;
    }
    v9 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v8;
    *(_BYTE *)(v9 + v5) = v7;
  }
  v10 = *(_QWORD *)(a2 + 16);
  v11 = a1[1];
  v12 = v10 + 1;
  if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v10 + 1) )
  {
    (**(void (__fastcall ***)(__int64))a2)(a2);
    v10 = *(_QWORD *)(a2 + 16);
    v12 = v10 + 1;
  }
  v13 = *(_BYTE *)v11;
  *(_QWORD *)(a2 + 16) = v12;
  *(_BYTE *)(*(_QWORD *)(a2 + 8) + v10) = v13;
  if ( *(_BYTE *)a1[2] )
  {
    v14 = *(_QWORD *)(a2 + 16);
    v15 = a1[3];
    v16 = v14 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v14 = *(_QWORD *)(a2 + 16);
      v16 = v14 + 1;
    }
    v17 = *(_BYTE *)v15;
    *(_QWORD *)(a2 + 16) = v16;
    *(_BYTE *)(*(_QWORD *)(a2 + 8) + v14) = v17;
    v18 = *a1[4];
    if ( v18 >= 1 )
    {
      v19 = a1[1];
      do
      {
        v22 = *(_QWORD *)(a2 + 16);
        v23 = v22 + 1;
        if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v22 + 1) )
        {
          (**(void (__fastcall ***)(__int64))a2)(a2);
          v22 = *(_QWORD *)(a2 + 16);
          v23 = v22 + 1;
        }
        --v18;
        v20 = *(_BYTE *)v19;
        v21 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a2 + 16) = v23;
        *(_BYTE *)(v21 + v22) = v20;
      }
      while ( v18 );
    }
    v24 = (int)*a1[6];
    if ( (_DWORD)v24 )
    {
      v25 = *(_QWORD *)(a2 + 16);
      v26 = *(_QWORD *)a1[5];
      v27 = v26 + v24;
      do
      {
        v28 = *(_QWORD *)(a2 + 24);
        v29 = v27 - v26;
        if ( v28 < v27 - v26 + v25 )
        {
          (**(void (__fastcall ***)(__int64))a2)(a2);
          v25 = *(_QWORD *)(a2 + 16);
          v28 = *(_QWORD *)(a2 + 24);
        }
        v30 = v28 - v25;
        if ( v28 - v25 >= v29 )
          v31 = v27 - v26;
        else
          v31 = v28 - v25;
        if ( !v31 )
          goto LABEL_18;
        v32 = *(_QWORD *)(a2 + 8);
        v33 = (_BYTE *)(v32 + v25);
        if ( v31 >= 8 )
        {
          if ( (unsigned __int64)v33 >= v26 + v31 || (v35 = v31, v34 = (char *)v26, v26 >= v32 + v25 + v31) )
          {
            if ( v31 < 0x20 )
            {
              v36 = 0LL;
LABEL_35:
              if ( v29 < v30 )
                v30 = v27 - v26;
              v42 = (_QWORD *)(v32 + v25 + v36);
              v43 = (__int64 *)(v26 + v36);
              v34 = (char *)(v26 + (v30 & 0xFFFFFFFFFFFFFFF8LL));
              v33 += v30 & 0xFFFFFFFFFFFFFFF8LL;
              v35 = v31 - (v30 & 0xFFFFFFFFFFFFFFF8LL);
              v44 = v36 - (v30 & 0xFFFFFFFFFFFFFFF8LL);
              do
              {
                v45 = *v43++;
                v44 += 8LL;
                *v42++ = v45;
              }
              while ( v44 );
              if ( v30 == (v30 & 0xFFFFFFFFFFFFFFF8LL) )
                goto LABEL_17;
              goto LABEL_42;
            }
            v36 = v31 & 0xFFFFFFFFFFFFFFE0LL;
            v37 = (_OWORD *)(v32 + v25 + 16);
            v38 = (__int128 *)(v26 + 16);
            v39 = v31 & 0xFFFFFFFFFFFFFFE0LL;
            do
            {
              v40 = *(v38 - 1);
              v41 = *v38;
              v38 += 2;
              v39 -= 32LL;
              *(v37 - 1) = v40;
              *v37 = v41;
              v37 += 2;
            }
            while ( v39 );
            if ( v31 == v36 )
              goto LABEL_17;
            if ( (v31 & 0x18) != 0 )
              goto LABEL_35;
            v35 = v31 & 0x1F;
            v33 += v36;
            v34 = (char *)(v26 + v36);
          }
        }
        else
        {
          v34 = (char *)v26;
          v35 = v31;
        }
        do
        {
LABEL_42:
          v46 = *v34++;
          --v35;
          *v33++ = v46;
        }
        while ( v35 );
LABEL_17:
        v25 = *(_QWORD *)(a2 + 16);
LABEL_18:
        v25 += v31;
        v26 += v31;
        *(_QWORD *)(a2 + 16) = v25;
      }
      while ( v26 != v27 );
    }
  }
  return a2;
}


================================================================================
Function: sub_67989DC (0x67989DC)
================================================================================

__int64 __fastcall sub_67989DC(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, __int64 a5)
{
  __int64 v6; // x19
  char *v7; // x20
  unsigned __int64 v8; // x9
  bool v9; // cf
  unsigned __int64 v10; // x9
  unsigned __int64 v11; // x24
  char v12; // w8
  unsigned __int64 v13; // x22
  __int64 v14; // x8
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 v17; // x8
  __int64 v18; // x1
  __int64 v19; // x9
  unsigned __int64 v20; // x22
  __int64 v21; // x9
  __int64 v22; // x11
  unsigned __int64 v23; // x8
  __int64 v24; // x10
  unsigned __int64 v25; // x11
  __int64 v26; // x12
  _BYTE *v27; // x9
  unsigned __int64 v28; // x11
  _BYTE *v30; // x9
  unsigned __int64 v31; // x11
  bool v32; // cc
  _BYTE v33[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v6 = a1;
  v7 = (char *)a2 + 11;
  v8 = *a2;
  v9 = v8 >= a4;
  v10 = v8 - a4;
  if ( v9 )
    v11 = v10;
  else
    v11 = 0LL;
  v12 = byte_173E2B4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  v13 = v11 >> v12;
  if ( v11 >> v12 )
    v6 = sub_24EFF44(a1, v11 >> v12, v7);
  v14 = *(_QWORD *)(v6 + 16);
  v15 = v14 + 1;
  if ( *(_QWORD *)(v6 + 24) < (unsigned __int64)(v14 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v6)(v6);
    v14 = *(_QWORD *)(v6 + 16);
    v15 = v14 + 1;
  }
  v16 = *(_QWORD *)(v6 + 8);
  *(_QWORD *)(v6 + 16) = v15;
  *(_BYTE *)(v16 + v14) = 48;
  v17 = *(_QWORD *)(v6 + 16);
  v18 = v17 + 1;
  if ( *(_QWORD *)(v6 + 24) < (unsigned __int64)(v17 + 1) )
  {
    (**(void (__fastcall ***)(__int64))v6)(v6);
    v17 = *(_QWORD *)(v6 + 16);
    v18 = v17 + 1;
  }
  v19 = *(_QWORD *)(v6 + 8);
  *(_QWORD *)(v6 + 16) = v18;
  v20 = v11 - v13;
  *(_BYTE *)(v19 + v17) = 120;
  v21 = *(_QWORD *)(v6 + 16);
  v22 = *(unsigned int *)(a5 + 8);
  v23 = *(_QWORD *)a5;
  v24 = (int)v22;
  v25 = v21 + v22;
  if ( *(_QWORD *)(v6 + 24) >= v25 && (v26 = *(_QWORD *)(v6 + 8), *(_QWORD *)(v6 + 16) = v25, v26) )
  {
    v27 = (_BYTE *)(v21 + v24 + v26 - 1);
    do
    {
      v28 = v23 & 0xF;
      v9 = v23 >= 0x10;
      v23 >>= 4;
      *v27-- = a0123456789abcd_1[v28];
    }
    while ( v9 );
    if ( v20 )
      return sub_24EFF44(v6, v20, v7);
  }
  else
  {
    v30 = &v33[v24 - 1];
    do
    {
      v31 = v23 & 0xF;
      v32 = v23 > 0xF;
      v23 >>= 4;
      *v30-- = a0123456789abcd_1[v31];
    }
    while ( v32 );
    v6 = sub_53712B8(v33, &v33[v24], v6);
    if ( v20 )
      return sub_24EFF44(v6, v20, v7);
  }
  return v6;
}


================================================================================
Function: sub_6798BA8 (0x6798BA8)
================================================================================

unsigned __int8 *__fastcall sub_6798BA8(__int64 a1, __int64 a2, __int64 a3, long double a4)
{
  char *v4; // x19
  int v5; // w8
  __int64 v7; // x10
  unsigned __int64 v8; // x8
  __int64 v9; // x12
  __int64 v10; // x9
  unsigned int *v11; // x11
  int v13; // w8
  int v14; // w8
  __int64 v15; // x10
  unsigned int *v16; // x11
  char *v17; // x0
  __int64 v18; // x21
  void (__fastcall *v19)(unsigned __int64, unsigned __int64 *, __int64 *); // x3
  unsigned int v20; // w10
  float v21; // w22
  __int64 v22; // x0
  long double v23; // q0
  int v24; // w12
  __int64 v25; // x0
  const char *v26; // x8
  __int64 v27; // x2
  __int64 v28; // x8
  __int64 v29; // x1
  __int64 v30; // x9
  const char *v31; // x22
  __int64 v32; // x1
  __int64 v33; // x11
  unsigned __int64 v34; // x22
  __int64 v35; // x2
  unsigned __int64 v36; // x8
  bool v37; // cc
  unsigned __int64 v38; // x8
  long double v40; // [xsp+0h] [xbp-70h]
  long double v41; // [xsp+10h] [xbp-60h]
  __int64 v42; // [xsp+20h] [xbp-50h] BYREF
  int v43; // [xsp+28h] [xbp-48h]
  __int64 v44; // [xsp+30h] [xbp-40h] BYREF
  __int64 v45; // [xsp+38h] [xbp-38h]
  __int64 v46; // [xsp+40h] [xbp-30h]
  __int64 v47; // [xsp+48h] [xbp-28h]
  unsigned __int64 v48; // [xsp+50h] [xbp-20h] BYREF
  __int64 v49; // [xsp+58h] [xbp-18h]
  int v50; // [xsp+60h] [xbp-10h]

  v4 = (char *)(a1 + 1);
  if ( a1 + 1 == a2 )
    sub_678FF08((__int64)"invalid format string");
  v5 = (unsigned __int8)*v4;
  if ( v5 == 123 )
  {
    *(_QWORD *)(a3 + 32) = sub_6797CE0(a1 + 1, a1 + 2, *(_QWORD *)(a3 + 32));
    return (unsigned __int8 *)(v4 + 1);
  }
  if ( v5 == 125 )
  {
    v7 = *(unsigned int *)(a3 + 24);
    if ( (v7 & 0x80000000) == 0 )
    {
      v8 = *(_QWORD *)(a3 + 40);
      *(_DWORD *)(a3 + 24) = v7 + 1;
      if ( (v8 & 0x8000000000000000LL) != 0 )
      {
        if ( (int)v7 < (int)v8 )
        {
          v10 = *(_QWORD *)(a3 + 48);
          v11 = (unsigned int *)(v10 + 32 * v7);
          LODWORD(v9) = v11[4];
          if ( (_DWORD)v9 )
            goto LABEL_26;
        }
      }
      else if ( (unsigned int)v7 <= 0xE )
      {
        v9 = (v8 >> (4 * (unsigned __int8)v7)) & 0xF;
        if ( ((v8 >> (4 * (unsigned __int8)v7)) & 0xF) != 0 )
        {
          v10 = *(_QWORD *)(a3 + 48);
          v11 = (unsigned int *)(v10 + 16 * v7);
LABEL_26:
          v18 = *(_QWORD *)(a3 + 32);
          v19 = (void (__fastcall *)(unsigned __int64, unsigned __int64 *, __int64 *))*((_QWORD *)v11 + 1);
          v21 = *(float *)v11;
          v20 = v11[1];
          switch ( (int)v9 )
          {
            case 1:
              goto LABEL_31;
            case 2:
              goto LABEL_32;
            case 3:
              goto LABEL_33;
            case 4:
              goto LABEL_34;
            case 5:
              goto LABEL_35;
            case 6:
              goto LABEL_36;
            case 7:
              goto LABEL_37;
            case 8:
              goto LABEL_41;
            case 9:
              goto LABEL_44;
            case 10:
              goto LABEL_45;
            case 11:
              v22 = *(_QWORD *)(a3 + 32);
              *(_QWORD *)&v41 = *v11 | ((unsigned __int64)v20 << 32);
              *((_QWORD *)&v41 + 1) = *((_QWORD *)v11 + 1);
              v23 = v41;
              goto LABEL_56;
            case 12:
              goto LABEL_46;
            case 13:
              goto LABEL_48;
            case 14:
              v34 = *v11 | ((unsigned __int64)v20 << 32);
              v35 = 2LL;
              v36 = v34;
              v49 = 0x100000020000000LL;
              v48 = 0xFFFFFFFF00000000LL;
              do
              {
                v37 = v36 > 0xF;
                ++v35;
                v36 >>= 4;
              }
              while ( v37 );
              goto LABEL_59;
            case 15:
              goto LABEL_50;
            default:
              goto LABEL_51;
          }
        }
      }
LABEL_63:
      sub_678FF08((__int64)"argument not found");
    }
LABEL_64:
    sub_678FF08((__int64)"cannot switch from manual to automatic argument indexing");
  }
  v42 = a3;
  v43 = 0;
  if ( v5 == 58 )
  {
    v13 = *(_DWORD *)(a3 + 24);
    if ( v13 < 0 )
      goto LABEL_64;
    v43 = *(_DWORD *)(a3 + 24);
    *(_DWORD *)(a3 + 24) = v13 + 1;
  }
  else
  {
    v4 = (char *)sub_6799908(a1 + 1, a2, &v42);
  }
  if ( v4 == (char *)a2 )
    goto LABEL_65;
  v14 = *v4;
  if ( v14 == 58 )
  {
    v17 = (char *)sub_679913C(a3, v43, v4 + 1);
    if ( v17 == (char *)a2 || (v4 = v17, *v17 != 125) )
      sub_678FF08((__int64)"unknown format specifier");
    return (unsigned __int8 *)(v4 + 1);
  }
  if ( v14 != 125 )
LABEL_65:
    sub_678FF08((__int64)"missing '}' in format string");
  v8 = *(_QWORD *)(a3 + 40);
  if ( (v8 & 0x8000000000000000LL) != 0 )
  {
    if ( v43 >= (int)v8 )
      goto LABEL_63;
    v10 = *(_QWORD *)(a3 + 48);
    v16 = (unsigned int *)(v10 + 32LL * v43);
    LODWORD(v15) = v16[4];
    if ( !(_DWORD)v15 )
      goto LABEL_63;
  }
  else
  {
    if ( v43 > 14 )
      goto LABEL_63;
    v15 = (v8 >> (4 * (unsigned __int8)v43)) & 0xF;
    if ( ((v8 >> (4 * (unsigned __int8)v43)) & 0xF) == 0 )
      goto LABEL_63;
    v10 = *(_QWORD *)(a3 + 48);
    v16 = (unsigned int *)(v10 + 16LL * v43);
  }
  v18 = *(_QWORD *)(a3 + 32);
  v24 = v15 - 1;
  v19 = (void (__fastcall *)(unsigned __int64, unsigned __int64 *, __int64 *))*((_QWORD *)v16 + 1);
  v21 = *(float *)v16;
  v20 = v16[1];
  switch ( v24 )
  {
    case 0:
LABEL_31:
      v25 = sub_6793834(v18, LODWORD(v21));
      goto LABEL_60;
    case 1:
LABEL_32:
      v25 = sub_679238C(v18, LODWORD(v21));
      goto LABEL_60;
    case 2:
LABEL_33:
      v25 = sub_6793A20(v18, LODWORD(v21) | ((unsigned __int64)v20 << 32));
      goto LABEL_60;
    case 3:
LABEL_34:
      v25 = sub_6793C30(v18, LODWORD(v21) | ((unsigned __int64)v20 << 32));
      goto LABEL_60;
    case 4:
LABEL_35:
      v25 = sub_6793DE4(v18, a2, LODWORD(v21) | ((unsigned __int64)v20 << 32), (__int64)v19);
      goto LABEL_60;
    case 5:
LABEL_36:
      v25 = sub_679410C(v18, a2, LODWORD(v21) | ((unsigned __int64)v20 << 32), v19);
      goto LABEL_60;
    case 6:
LABEL_37:
      *(_DWORD *)((char *)&v49 + 3) = 32;
      v26 = "true";
      if ( LOBYTE(v21) )
      {
        v27 = 4LL;
      }
      else
      {
        v26 = "false";
        v27 = 5LL;
      }
      LOBYTE(v49) = 0;
      v48 = 0xFFFFFFFF00000000LL;
      *(_WORD *)((char *)&v49 + 1) = 0;
      HIBYTE(v49) = 1;
      v44 = (__int64)v26;
      v45 = v27;
      v25 = sub_67943D8(v18, &v48);
      goto LABEL_60;
    case 7:
LABEL_41:
      v28 = *(_QWORD *)(v18 + 16);
      v29 = v28 + 1;
      if ( *(_QWORD *)(v18 + 24) < (unsigned __int64)(v28 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v18)(v18);
        v28 = *(_QWORD *)(v18 + 16);
        v29 = v28 + 1;
      }
      v30 = *(_QWORD *)(v18 + 8);
      *(_QWORD *)(v18 + 16) = v29;
      *(_BYTE *)(v30 + v28) = LOBYTE(v21);
      goto LABEL_51;
    case 8:
LABEL_44:
      v25 = sub_67945DC(v18, v21);
      goto LABEL_60;
    case 9:
LABEL_45:
      *(_QWORD *)&a4 = LODWORD(v21) | ((unsigned __int64)v20 << 32);
      v25 = sub_6795C64(v18, a4);
      goto LABEL_60;
    case 10:
      v22 = *(_QWORD *)(a3 + 32);
      *(_QWORD *)&v40 = *v16 | ((unsigned __int64)v20 << 32);
      *((_QWORD *)&v40 + 1) = *((_QWORD *)v16 + 1);
      v23 = v40;
LABEL_56:
      v25 = sub_6796F3C(v22, (_UNKNOWN **)0xFFFFFFFF00000000LL, (_BYTE *)0x100000020000000LL, 0LL, v23);
      goto LABEL_60;
    case 11:
LABEL_46:
      v31 = (const char *)(LODWORD(v21) | ((unsigned __int64)v20 << 32));
      if ( !v31 )
        sub_678FF08((__int64)"string pointer is null");
      v32 = (__int64)&v31[strlen(v31)];
      goto LABEL_49;
    case 12:
LABEL_48:
      v31 = (const char *)(LODWORD(v21) | ((unsigned __int64)v20 << 32));
      v32 = (__int64)v19 + (_QWORD)v31;
LABEL_49:
      v25 = sub_6797CE0((unsigned __int64)v31, v32, v18);
      goto LABEL_60;
    case 13:
      v34 = *v16 | ((unsigned __int64)v20 << 32);
      v35 = 2LL;
      v38 = v34;
      v49 = 0x100000020000000LL;
      v48 = 0xFFFFFFFF00000000LL;
      do
      {
        v37 = v38 > 0xF;
        ++v35;
        v38 >>= 4;
      }
      while ( v37 );
LABEL_59:
      v44 = v34;
      LODWORD(v45) = v35 - 2;
      v25 = sub_67989DC(v18, &v48, v35, v35, &v44);
LABEL_60:
      *(_QWORD *)(a3 + 32) = v25;
      return (unsigned __int8 *)(v4 + 1);
    case 14:
LABEL_50:
      v33 = *(_QWORD *)(a3 + 56);
      v48 = 0LL;
      v49 = 0LL;
      v50 = 0;
      v44 = v18;
      v45 = v8;
      v46 = v10;
      v47 = v33;
      v19(LODWORD(v21) | ((unsigned __int64)v20 << 32), &v48, &v44);
      v18 = v44;
      goto LABEL_51;
    default:
LABEL_51:
      *(_QWORD *)(a3 + 32) = v18;
      break;
  }
  return (unsigned __int8 *)(v4 + 1);
}


================================================================================
Function: sub_679908C (0x679908C)
================================================================================

__int64 __fastcall sub_679908C(__int64 result, char *s, char *a3)
{
  char *v4; // x21
  __int64 v5; // x20
  signed __int64 v6; // x23
  char *v7; // x0
  char *v8; // x22
  _BYTE *v9; // x1
  __int64 v10; // x23
  __int64 v11; // x0
  __int64 v12; // x19

  if ( s != a3 )
  {
    v4 = s;
    v5 = result;
    while ( 1 )
    {
      v6 = a3 - v4;
      v7 = (char *)memchr(v4, 125, a3 - v4);
      if ( !v7 )
        break;
      v8 = v7;
      v9 = v7 + 1;
      if ( v7 + 1 == a3 || *v9 != 125 )
        sub_678FF08((__int64)"unmatched '}' in format string");
      v10 = *(_QWORD *)v5;
      v11 = sub_6797CE0((unsigned __int64)v4, (__int64)v9, *(_QWORD *)(*(_QWORD *)v5 + 32LL));
      v4 = v8 + 2;
      *(_QWORD *)(v10 + 32) = v11;
    }
    v12 = *(_QWORD *)v5;
    result = sub_6797CE0((unsigned __int64)v4, (__int64)&v4[v6], *(_QWORD *)(*(_QWORD *)v5 + 32LL));
    *(_QWORD *)(v12 + 32) = result;
  }
  return result;
}


================================================================================
Function: sub_679913C (0x679913C)
================================================================================

unsigned __int8 *__fastcall sub_679913C(_QWORD *a1, int a2, unsigned __int8 *src, unsigned __int8 *a4)
{
  unsigned __int8 *v5; // x8
  unsigned __int64 v7; // x9
  unsigned int v8; // w27
  __int64 v9; // x9
  float v10; // w20
  unsigned int v11; // w26
  __int64 *v12; // x19
  void (__fastcall *v13)(unsigned __int64, _QWORD *, __int64 *); // x11
  __int64 v14; // x9
  __int64 v15; // x10
  _QWORD *v16; // x23
  unsigned __int8 *v17; // x21
  int v18; // w0
  char v19; // w0
  unsigned __int64 v20; // x9
  __int64 v21; // x12
  char *v22; // x25
  int v23; // w10
  bool v24; // zf
  __int16 v25; // w28
  size_t v26; // x21
  int v27; // w9
  __int16 v28; // w9
  int v29; // w9
  unsigned __int8 *v30; // x0
  int v31; // w8
  unsigned __int8 *v32; // x0
  __int64 v33; // x24
  __int64 v34; // x4
  unsigned __int64 v35; // x8
  __int64 v36; // x0
  unsigned __int64 v37; // x1
  unsigned __int64 v38; // x20
  unsigned __int64 v39; // x8
  __int64 v40; // x2
  __int64 v41; // x0
  unsigned __int64 v42; // x20
  __int64 v43; // x10
  int v44; // w8
  const char *v45; // x8
  __int64 v46; // x2
  __int64 v47; // x0
  const char *v48; // x20
  __int64 v49; // x2
  unsigned __int64 v50; // x8
  bool v51; // cc
  unsigned __int64 v52; // x8
  __int64 v53; // x0
  bool v54; // cf
  size_t v56; // x0
  __int64 v57; // x4
  __int64 v58; // [xsp+8h] [xbp-78h]
  long double v59; // [xsp+10h] [xbp-70h]
  _QWORD v60[3]; // [xsp+20h] [xbp-60h] BYREF
  unsigned int v61; // [xsp+38h] [xbp-48h]
  _UNKNOWN **v62; // [xsp+40h] [xbp-40h] BYREF
  _BYTE *v63; // [xsp+48h] [xbp-38h] BYREF
  unsigned __int64 v64; // [xsp+50h] [xbp-30h] BYREF
  __int64 v65; // [xsp+58h] [xbp-28h]
  int v66; // [xsp+60h] [xbp-20h]

  v5 = src;
  v7 = a1[5];
  if ( (v7 & 0x8000000000000000LL) == 0 )
  {
    if ( a2 <= 14 )
    {
      v8 = (v7 >> (4 * (unsigned __int8)a2)) & 0xF;
      if ( v8 )
      {
        v9 = a1[6] + 16LL * a2;
        goto LABEL_7;
      }
    }
LABEL_129:
    sub_678FF08((__int64)"argument not found");
  }
  if ( (int)v7 <= a2 )
    goto LABEL_129;
  v9 = a1[6] + 32LL * a2;
  v8 = *(_DWORD *)(v9 + 16);
  if ( !v8 )
    goto LABEL_129;
LABEL_7:
  v10 = *(float *)v9;
  v11 = *(_DWORD *)(v9 + 4);
  v12 = a1 + 4;
  v13 = *(void (__fastcall **)(unsigned __int64, _QWORD *, __int64 *))(v9 + 8);
  if ( v8 == 15 )
  {
    v14 = a1[1];
    v15 = a1[2];
    v16 = a1 + 1;
    a1[1] = src;
    a1[2] = v15 + v14 - (_QWORD)src;
    v13(LODWORD(v10) | ((unsigned __int64)v11 << 32), a1 + 1, v12);
    return (unsigned __int8 *)*v16;
  }
  v58 = *(_QWORD *)(v9 + 8);
  LOBYTE(v63) = 0;
  *(_DWORD *)((char *)&v63 + 3) = 32;
  *(_WORD *)((char *)&v63 + 1) = 0;
  HIBYTE(v63) = 1;
  v60[0] = &v62;
  v60[1] = a1 + 1;
  v62 = (_UNKNOWN **)0xFFFFFFFF00000000LL;
  v60[2] = a1 + 4;
  v61 = v8;
  if ( a4 - src >= 2 )
  {
    v17 = src + 1;
    if ( src[1] == 125 )
    {
      v18 = *src;
      if ( (unsigned __int8)((v18 & 0xDF) - 91) >= 0xE6u && v18 != 76 )
      {
        v19 = sub_24EEE24();
        if ( !v19 )
LABEL_131:
          sub_678FF08((__int64)"invalid type specifier");
        goto LABEL_77;
      }
    }
  }
  if ( src == a4 )
    goto LABEL_128;
  v20 = *src;
  v21 = byte_D13A40[v20 >> 3];
  v22 = (char *)(&src[((0x80FF0000uLL >> (*src >> 3)) & 1) + v21] >= a4
               ? src
               : &src[((0x80FF0000uLL >> (*src >> 3)) & 1) + v21]);
  while ( 1 )
  {
    v23 = *v22;
    if ( v23 == 94 )
      break;
    if ( v23 == 62 )
    {
      v25 = 2;
      v26 = v22 - (char *)src;
      if ( v22 == (char *)src )
        goto LABEL_26;
      goto LABEL_30;
    }
    if ( v23 == 60 )
    {
      v25 = 1;
      v26 = v22 - (char *)src;
      if ( v22 != (char *)src )
        goto LABEL_30;
LABEL_26:
      v22 = (char *)src;
      goto LABEL_35;
    }
    v24 = v22 == (char *)src;
    v22 = (char *)src;
    if ( v24 )
    {
      v25 = 0;
      goto LABEL_36;
    }
  }
  v25 = 3;
  v26 = v22 - (char *)src;
  if ( v22 == (char *)src )
    goto LABEL_26;
LABEL_30:
  if ( (_DWORD)v20 == 123 )
    sub_678FF08((__int64)"invalid fill character '{'");
  if ( v26 > 4 )
    sub_678FF08((__int64)"invalid fill");
  if ( v26 )
    memcpy((char *)&v63 + 3, src, v26);
  HIBYTE(v63) = v26;
LABEL_35:
  v5 = (unsigned __int8 *)(v22 + 1);
  *(_WORD *)((char *)&v63 + 1) = v25;
LABEL_36:
  if ( v5 == a4 )
    goto LABEL_128;
  v27 = (char)*v5;
  switch ( v27 )
  {
    case ' ':
      if ( v8 - 1 >= 0xB )
        goto LABEL_130;
      if ( v8 - 1 > 7 || v8 <= 8 && ((1 << v8) & 0x10A) != 0 )
      {
        v28 = 48;
        goto LABEL_55;
      }
LABEL_134:
      sub_678FF08((__int64)"format specifier requires signed argument");
    case '-':
      if ( v8 - 1 >= 0xB )
        goto LABEL_130;
      if ( v8 - 1 > 7 || v8 <= 8 && ((1 << v8) & 0x10A) != 0 )
      {
        v28 = 16;
        goto LABEL_55;
      }
      goto LABEL_134;
    case '+':
      if ( v8 - 1 >= 0xB )
        goto LABEL_130;
      if ( v8 - 1 > 7 || v8 <= 8 && ((1 << v8) & 0x10A) != 0 )
      {
        v28 = 32;
LABEL_55:
        v25 |= v28;
        ++v5;
        *(_WORD *)((char *)&v63 + 1) = v25;
        break;
      }
      goto LABEL_134;
  }
  if ( v5 == a4 )
    goto LABEL_128;
  v29 = *v5;
  if ( v29 == 35 )
  {
    if ( v8 - 1 >= 0xB )
      goto LABEL_130;
    v25 |= 0x80u;
    ++v5;
    *(_WORD *)((char *)&v63 + 1) = v25;
    if ( v5 == a4 )
      goto LABEL_128;
    v29 = *v5;
  }
  if ( v29 == 48 )
  {
    if ( v8 - 1 >= 0xB )
      goto LABEL_130;
    if ( (v25 & 0xF) == 0 )
      *(_WORD *)((char *)&v63 + 1) = v25 & 0xF0 | 4;
    ++v5;
    BYTE3(v63) = 48;
    if ( v5 == a4 )
LABEL_128:
      sub_678FF08((__int64)"missing '}' in format string");
  }
  v30 = (unsigned __int8 *)sub_6799B34(v5, a4, v60);
  if ( v30 == a4 )
    goto LABEL_128;
  v31 = *v30;
  v17 = v30;
  if ( v31 == 46 )
  {
    v32 = (unsigned __int8 *)sub_6799CA4(v30, a4, v60);
    if ( v32 == a4 )
      goto LABEL_128;
    v17 = v32;
    v31 = *v32;
  }
  if ( v31 == 76 )
  {
    if ( v61 - 1 < 0xB )
    {
      ++v17;
      *(_WORD *)(v60[0] + 9LL) |= 0x100u;
      goto LABEL_73;
    }
LABEL_130:
    sub_678FF08((__int64)"format specifier requires numeric argument");
  }
LABEL_73:
  if ( v17 == a4 )
    goto LABEL_128;
  if ( *v17 != 125 )
  {
    v19 = sub_24EEE24();
    if ( !v19 )
      goto LABEL_131;
    ++v17;
LABEL_77:
    *(_BYTE *)(v60[0] + 8LL) = v19;
  }
  if ( v17 == a4 || *v17 != 125 )
    goto LABEL_128;
  v33 = a1[4];
  v34 = a1[7];
  switch ( v8 )
  {
    case 1u:
      if ( (LODWORD(v10) & 0x80000000) != 0 )
      {
        LODWORD(v10) = -LODWORD(v10);
        v35 = 0x100002D00000000LL;
      }
      else
      {
        v35 = (unsigned __int64)dword_AF83F0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7] << 32;
      }
      v37 = v35 | LODWORD(v10);
      v36 = a1[4];
      goto LABEL_118;
    case 2u:
      v36 = a1[4];
      v37 = LODWORD(v10) | ((unsigned __int64)dword_AF83F0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7] << 32);
LABEL_118:
      v41 = sub_53700C0(v36, v37, &v62, a1[7], v34);
      goto LABEL_123;
    case 3u:
      v38 = LODWORD(v10) | ((unsigned __int64)v11 << 32);
      if ( (v38 & 0x8000000000000000LL) != 0 )
      {
        v38 = -(__int64)v38;
        v40 = 16777261LL;
      }
      else
      {
        v39 = *(unsigned __int16 *)((char *)&v63 + 1);
LABEL_87:
        v40 = dword_AF83F0[(v39 >> 4) & 7];
      }
      v41 = sub_679A56C(a1[4], v38, v40, &v62, v34);
      goto LABEL_123;
    case 4u:
      v39 = *(unsigned __int16 *)((char *)&v63 + 1);
      v38 = LODWORD(v10) | ((unsigned __int64)v11 << 32);
      goto LABEL_87;
    case 5u:
      v42 = LODWORD(v10) | ((unsigned __int64)v11 << 32);
      v43 = v58;
      if ( v58 < 0 )
      {
        v54 = v42 == 0;
        v42 = -(__int64)v42;
        v43 = -(v58 + !v54);
        v44 = 16777261;
      }
      else
      {
        v44 = dword_AF83F0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7];
      }
      v64 = v42;
      v65 = v43;
      goto LABEL_122;
    case 6u:
      v64 = __PAIR64__(v11, LODWORD(v10));
      v44 = dword_AF83F0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7];
      v65 = v58;
LABEL_122:
      v66 = v44;
      v41 = sub_679B430(v33, &v64, &v62, v34);
      goto LABEL_123;
    case 7u:
      if ( ((unsigned __int8)v63 | 0x10) == 0x10 )
      {
        v45 = "true";
        if ( LOBYTE(v10) )
          v46 = 4LL;
        else
          v46 = 5LL;
        if ( !LOBYTE(v10) )
          v45 = "false";
        v47 = a1[4];
        v64 = (unsigned __int64)v45;
        v65 = v46;
        v41 = sub_67943D8(v47, (unsigned int *)&v62, v46, v46, &v64);
      }
      else
      {
        v41 = sub_53700C0(
                a1[4],
                LOBYTE(v10) | ((unsigned __int64)dword_AF83F0[((unsigned __int64)*(unsigned __int16 *)((char *)&v63 + 1) >> 4) & 7] << 32),
                &v62,
                0LL,
                v34);
      }
      goto LABEL_123;
    case 8u:
      v41 = sub_536FEF8(a1[4], LODWORD(v10), &v62, a1[7]);
      goto LABEL_123;
    case 9u:
      v41 = sub_679C8C0(a1[4], v62, v63, a1[7], v10);
      goto LABEL_123;
    case 0xAu:
      v41 = sub_679CBE8(a1[4], v62, v63, a1[7], COERCE_DOUBLE(LODWORD(v10) | ((unsigned __int64)v11 << 32)));
      goto LABEL_123;
    case 0xBu:
      *(_QWORD *)&v59 = LODWORD(v10) | ((unsigned __int64)v11 << 32);
      *((_QWORD *)&v59 + 1) = v58;
      v41 = sub_6796F3C(a1[4], v62, v63, a1[7], v59);
      goto LABEL_123;
    case 0xCu:
      if ( (unsigned int)(unsigned __int8)v63 - 16 >= 2 && (_BYTE)v63 )
        goto LABEL_131;
      v48 = (const char *)(LODWORD(v10) | ((unsigned __int64)v11 << 32));
      if ( ((unsigned __int8)v63 & 0xEF) != 0 )
      {
        v49 = 2LL;
        v50 = (unsigned __int64)v48;
        do
        {
          v51 = v50 > 0xF;
          ++v49;
          v50 >>= 4;
        }
        while ( v51 );
LABEL_115:
        v53 = a1[4];
        v64 = (unsigned __int64)v48;
        LODWORD(v65) = v49 - 2;
        v41 = sub_67989DC(v53, (unsigned int *)&v62, v49, v49, (__int64)&v64);
      }
      else
      {
        v56 = strlen(v48);
        v41 = sub_24EF9D8(v33, v48, v56, &v62, v57);
      }
LABEL_123:
      v33 = v41;
LABEL_124:
      *v12 = v33;
      break;
    case 0xDu:
      if ( ((unsigned __int8)v63 & 0xEF) != 0 )
        goto LABEL_131;
      v41 = sub_24EF9D8(a1[4], LODWORD(v10) | ((unsigned __int64)v11 << 32), v58, &v62, v34);
      goto LABEL_123;
    case 0xEu:
      if ( (_BYTE)v63 && (unsigned __int8)v63 != 17 )
        goto LABEL_131;
      v48 = (const char *)(LODWORD(v10) | ((unsigned __int64)v11 << 32));
      v49 = 2LL;
      v52 = (unsigned __int64)v48;
      do
      {
        v51 = v52 > 0xF;
        ++v49;
        v52 >>= 4;
      }
      while ( v51 );
      goto LABEL_115;
    default:
      goto LABEL_124;
  }
  return v17;
}


================================================================================
Function: sub_6799908 (0x6799908)
================================================================================

unsigned __int8 *__fastcall sub_6799908(unsigned __int64 a1, unsigned __int8 *a2, _DWORD *a3)
{
  int v3; // w11
  int v7; // w8
  unsigned __int8 *result; // x0
  unsigned __int8 *v9; // x8
  int v10; // w9
  int v11; // t1
  unsigned __int8 *v12; // x12
  unsigned __int8 *v13; // x9
  unsigned int v14; // w10
  int v15; // t1
  int v16; // w9

  v3 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v3 - 48) <= 9 )
  {
    if ( v3 == 48 )
    {
      v7 = 0;
      result = (unsigned __int8 *)(a1 + 1);
    }
    else
    {
      v7 = 0;
      v12 = (unsigned __int8 *)(a1 + 1);
      v13 = &a2[~a1 + a1];
      while ( 1 )
      {
        v14 = v7;
        v7 = v3 + 10 * v7 - 48;
        if ( v12 == a2 )
          break;
        v15 = *v12++;
        v3 = v15;
        if ( (unsigned int)(v15 - 48) >= 0xA )
        {
          v13 = v12 - 2;
          result = v12 - 1;
          goto LABEL_18;
        }
      }
      result = a2;
LABEL_18:
      if ( (__int64)&result[-a1] >= 10
        && (&result[-a1] != (unsigned __int8 *)&byte_9[1]
         || ((unsigned int)((char)*v13 - 48) + 10 * (unsigned __int64)v14) >> 31) )
      {
        v7 = 0x7FFFFFFF;
      }
    }
    if ( result != a2 )
    {
      v16 = *result;
      if ( v16 == 58 || v16 == 125 )
      {
        if ( *(int *)(*(_QWORD *)a3 + 24LL) >= 1 )
          sub_678FF08((__int64)"cannot switch from automatic to manual argument indexing");
        *(_DWORD *)(*(_QWORD *)a3 + 24LL) = -1;
        goto LABEL_27;
      }
    }
LABEL_28:
    sub_678FF08((__int64)"invalid format string");
  }
  if ( v3 != 95 && (v3 & 0xFFFFFFDF) - 65 > 0x19 )
    goto LABEL_28;
  v9 = (unsigned __int8 *)(a1 + 1);
  while ( v9 != a2 )
  {
    v11 = *v9++;
    v10 = v11;
    if ( (unsigned int)(v11 - 48) >= 0xA && v10 != 95 && (v10 & 0xFFFFFFDF) - 65 >= 0x1A )
    {
      a2 = v9 - 1;
      break;
    }
  }
  v7 = sub_6799A80(*(_QWORD *)a3, a1, &a2[-a1]);
  result = a2;
LABEL_27:
  a3[2] = v7;
  return result;
}


================================================================================
Function: sub_6799A80 (0x6799A80)
================================================================================

__int64 __fastcall sub_6799A80(__int64 a1, const void *a2, size_t a3)
{
  __int64 v3; // x8
  bool v4; // nf
  __int64 v5; // x8
  _QWORD *v6; // x8
  __int64 v7; // x23
  unsigned int *v10; // x24
  const char *v11; // x22
  size_t v12; // x0
  bool v13; // zf
  size_t v14; // x2
  size_t v15; // x21
  __int64 result; // x0

  v3 = *(_QWORD *)(a1 + 40);
  if ( (v3 & 0x4000000000000000LL) == 0 )
    goto LABEL_15;
  v4 = v3 < 0;
  v5 = -32LL;
  if ( !v4 )
    v5 = -16LL;
  v6 = (_QWORD *)(*(_QWORD *)(a1 + 48) + v5);
  v7 = v6[1];
  if ( !v7 )
    goto LABEL_15;
  v10 = (unsigned int *)(*v6 + 8LL);
  while ( 1 )
  {
    v11 = (const char *)*((_QWORD *)v10 - 1);
    v12 = strlen(v11);
    v13 = v12 == a3;
    v14 = v12 >= a3 ? a3 : v12;
    if ( v14 )
    {
      v15 = v12;
      v13 = !memcmp(v11, a2, v14) && v15 == a3;
    }
    if ( v13 )
      break;
    v10 += 4;
    if ( !--v7 )
      goto LABEL_15;
  }
  result = *v10;
  if ( (result & 0x80000000) != 0 )
LABEL_15:
    sub_678FF08((__int64)"argument not found");
  return result;
}


================================================================================
Function: sub_6799B34 (0x6799B34)
================================================================================

unsigned __int8 *__fastcall sub_6799B34(unsigned __int64 a1, unsigned __int8 *a2, int **a3)
{
  unsigned __int8 *v3; // x19
  int v4; // w11
  int v5; // w8
  unsigned __int8 *v6; // x12
  unsigned __int8 *v7; // x9
  unsigned int v8; // w10
  int v9; // t1
  unsigned __int8 *v10; // x20
  int v11; // w8
  int **v13; // [xsp+0h] [xbp-10h] BYREF

  v3 = a2;
  v4 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v4 - 48) > 9 )
  {
    if ( v4 != 123 )
      return (unsigned __int8 *)a1;
    v10 = (unsigned __int8 *)(a1 + 1);
    if ( (unsigned __int8 *)(a1 + 1) != a2 )
    {
      v11 = *v10;
      v13 = a3;
      if ( v11 == 58 || v11 == 125 )
      {
        sub_679A01C(&v13);
        if ( v10 == v3 )
          goto LABEL_22;
      }
      else
      {
        v10 = (unsigned __int8 *)sub_6799E5C(a1 + 1, a2, &v13);
        if ( v10 == v3 )
          goto LABEL_22;
      }
      if ( *v10 == 125 )
        return v10 + 1;
    }
LABEL_22:
    sub_678FF08((__int64)"invalid format string");
  }
  v5 = 0;
  v6 = (unsigned __int8 *)(a1 + 1);
  v7 = &a2[~a1 + a1];
  while ( 1 )
  {
    v8 = v5;
    v5 = v4 + 10 * v5 - 48;
    if ( v6 == a2 )
      break;
    v9 = *v6++;
    v4 = v9;
    if ( (unsigned int)(v9 - 48) >= 0xA )
    {
      v7 = v6 - 2;
      v3 = v6 - 1;
      break;
    }
  }
  if ( (__int64)&v3[-a1] >= 10
    && (&v3[-a1] != (unsigned __int8 *)&byte_9[1] || ((unsigned int)((char)*v7 - 48) + 10 * (unsigned __int64)v8) >> 31)
    || v5 == -1 )
  {
    sub_678FF08((__int64)"number is too big");
  }
  **a3 = v5;
  return v3;
}


================================================================================
Function: sub_6799CA4 (0x6799CA4)
================================================================================

unsigned __int8 *__fastcall sub_6799CA4(__int64 a1, unsigned __int8 *a2, _DWORD *a3)
{
  char *v3; // x9
  unsigned __int8 *v5; // x19
  int v6; // w12
  int v7; // w8
  unsigned __int8 *v8; // x13
  unsigned __int8 *v9; // x10
  unsigned int v10; // w11
  int v11; // t1
  __int64 v12; // x9
  unsigned __int8 *v13; // x21
  int v14; // w8
  unsigned __int8 *v15; // x21
  int v16; // t1
  unsigned int v17; // w8
  _DWORD *v19; // [xsp+0h] [xbp-10h] BYREF

  v3 = (char *)(a1 + 1);
  if ( (unsigned __int8 *)(a1 + 1) == a2 )
    goto LABEL_25;
  v5 = a2;
  v6 = (unsigned __int8)*v3;
  if ( (unsigned int)(*v3 - 48) > 9 )
  {
    if ( v6 == 123 )
    {
      v13 = (unsigned __int8 *)(a1 + 2);
      if ( (unsigned __int8 *)(a1 + 2) == a2 )
        goto LABEL_26;
      v14 = *v13;
      v19 = a3;
      if ( v14 == 58 || v14 == 125 )
      {
        sub_679A3A4(&v19);
        if ( v13 == v5 )
          goto LABEL_26;
      }
      else
      {
        v13 = (unsigned __int8 *)sub_679A1E4(a1 + 2, a2, &v19);
        if ( v13 == v5 )
          goto LABEL_26;
      }
      v16 = *v13;
      v15 = v13 + 1;
      if ( v16 == 125 )
      {
        v5 = v15;
        goto LABEL_21;
      }
LABEL_26:
      sub_678FF08((__int64)"invalid format string");
    }
LABEL_25:
    sub_678FF08((__int64)"missing precision specifier");
  }
  v7 = 0;
  v8 = (unsigned __int8 *)(a1 + 2);
  v9 = &a2[~(unsigned __int64)v3 + (_QWORD)v3];
  while ( 1 )
  {
    v10 = v7;
    v7 = 10 * v7 + (char)v6 - 48;
    if ( v8 == a2 )
      break;
    v11 = *v8++;
    LOBYTE(v6) = v11;
    if ( (unsigned int)(v11 - 48) >= 0xA )
    {
      v9 = v8 - 2;
      v5 = v8 - 1;
      break;
    }
  }
  v12 = v5 - (unsigned __int8 *)v3;
  if ( v12 >= 10 && (v12 != 10 || ((unsigned int)((char)*v9 - 48) + 10 * (unsigned __int64)v10) >> 31) || v7 == -1 )
    sub_678FF08((__int64)"number is too big");
  *(_DWORD *)(*(_QWORD *)a3 + 4LL) = v7;
LABEL_21:
  v17 = a3[6];
  if ( v17 <= 0xE && ((1 << v17) & 0x41FE) != 0 )
    sub_678FF08((__int64)"precision not allowed for this argument type");
  return v5;
}


================================================================================
Function: sub_6799E5C (0x6799E5C)
================================================================================

unsigned __int8 *__fastcall sub_6799E5C(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3)
{
  int v3; // w12
  unsigned int v4; // w8
  unsigned __int8 *v5; // x19
  unsigned __int8 *v6; // x8
  int v7; // w10
  int v8; // t1
  _DWORD **v9; // x21
  unsigned __int8 *v10; // x13
  unsigned __int8 *v11; // x10
  unsigned int v12; // w11
  int v13; // t1
  int v14; // w9
  _QWORD v16[2]; // [xsp+0h] [xbp-30h] BYREF
  int v17; // [xsp+10h] [xbp-20h]

  v3 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v3 - 48) <= 9 )
  {
    if ( v3 == 48 )
    {
      v4 = 0;
      v5 = (unsigned __int8 *)(a1 + 1);
    }
    else
    {
      v4 = 0;
      v10 = (unsigned __int8 *)(a1 + 1);
      v11 = &a2[~a1 + a1];
      while ( 1 )
      {
        v12 = v4;
        v4 = v3 + 10 * v4 - 48;
        if ( v10 == a2 )
          break;
        v13 = *v10++;
        v3 = v13;
        if ( (unsigned int)(v13 - 48) >= 0xA )
        {
          v11 = v10 - 2;
          v5 = v10 - 1;
          goto LABEL_20;
        }
      }
      v5 = a2;
LABEL_20:
      if ( (__int64)&v5[-a1] >= 10
        && (&v5[-a1] != (unsigned __int8 *)&byte_9[1]
         || ((unsigned int)((char)*v11 - 48) + 10 * (unsigned __int64)v12) >> 31) )
      {
        v4 = 0x7FFFFFFF;
      }
    }
    if ( v5 != a2 )
    {
      v14 = *v5;
      if ( v14 == 58 || v14 == 125 )
      {
        sub_679A0FC(a3, v4);
        return v5;
      }
    }
LABEL_29:
    sub_678FF08((__int64)"invalid format string");
  }
  if ( v3 != 95 && (v3 & 0xFFFFFFDF) - 65 > 0x19 )
    goto LABEL_29;
  v6 = (unsigned __int8 *)(a1 + 1);
  while ( v6 != a2 )
  {
    v8 = *v6++;
    v7 = v8;
    if ( (unsigned int)(v8 - 48) >= 0xA && v7 != 95 && (v7 & 0xFFFFFFDF) - 65 >= 0x1A )
    {
      v5 = v6 - 1;
      goto LABEL_13;
    }
  }
  v5 = a2;
LABEL_13:
  v9 = *(_DWORD ***)a3;
  sub_24EF7F8(v16, *(_QWORD *)(*(_QWORD *)a3 + 16LL) + 8LL, a1, &v5[-a1]);
  if ( !v17 )
    sub_678FF08((__int64)"argument not found");
  **v9 = sub_24EF72C(v16);
  return v5;
}


================================================================================
Function: sub_679A01C (0x679A01C)
================================================================================

__int64 __fastcall sub_679A01C(__int64 *a1)
{
  __int64 v1; // x20
  __int64 v2; // x10
  __int64 v3; // x8
  __int64 v4; // x9
  unsigned __int64 v5; // x10
  __int64 v6; // x8
  __int128 v7; // q0
  __int64 result; // x0
  __int128 v9; // [xsp+0h] [xbp-30h] BYREF
  int v10; // [xsp+10h] [xbp-20h]

  v1 = *a1;
  v2 = *(_QWORD *)(*a1 + 8);
  v3 = *(unsigned int *)(v2 + 16);
  if ( (v3 & 0x80000000) != 0 )
    sub_678FF08((__int64)"cannot switch from manual to automatic argument indexing");
  v4 = *(_QWORD *)(v1 + 16);
  *(_DWORD *)(v2 + 16) = v3 + 1;
  v5 = *(_QWORD *)(v4 + 8);
  if ( (v5 & 0x8000000000000000LL) == 0 )
  {
    if ( (unsigned int)v3 <= 0xE )
    {
      v10 = (v5 >> (4 * (unsigned __int8)v3)) & 0xF;
      if ( v10 )
      {
        v9 = *(_OWORD *)(*(_QWORD *)(v4 + 16) + 16 * v3);
        goto LABEL_8;
      }
    }
LABEL_9:
    sub_678FF08((__int64)"argument not found");
  }
  if ( (int)v3 >= (int)v5 )
    goto LABEL_9;
  v6 = *(_QWORD *)(v4 + 16) + 32 * v3;
  v7 = *(_OWORD *)v6;
  LODWORD(v6) = *(_DWORD *)(v6 + 16);
  v9 = v7;
  v10 = v6;
  if ( !(_DWORD)v6 )
    goto LABEL_9;
LABEL_8:
  result = sub_24EF72C(&v9);
  **(_DWORD **)v1 = result;
  return result;
}


================================================================================
Function: sub_679A0FC (0x679A0FC)
================================================================================

unsigned __int64 __fastcall sub_679A0FC(__int64 *a1, int a2)
{
  __int64 v2; // x20
  __int64 v3; // x8
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  __int64 v6; // x8
  __int128 v7; // q0
  unsigned __int64 result; // x0
  __int128 v9; // [xsp+0h] [xbp-30h] BYREF
  int v10; // [xsp+10h] [xbp-20h]

  v2 = *a1;
  v3 = *(_QWORD *)(*a1 + 8);
  if ( *(int *)(v3 + 16) >= 1 )
    sub_678FF08((__int64)"cannot switch from automatic to manual argument indexing");
  *(_DWORD *)(v3 + 16) = -1;
  v4 = *(_QWORD *)(v2 + 16);
  v5 = *(_QWORD *)(v4 + 8);
  if ( (v5 & 0x8000000000000000LL) == 0 )
  {
    if ( a2 <= 14 )
    {
      v10 = (v5 >> (4 * (unsigned __int8)a2)) & 0xF;
      if ( v10 )
      {
        v9 = *(_OWORD *)(*(_QWORD *)(v4 + 16) + 16LL * a2);
        goto LABEL_8;
      }
    }
LABEL_9:
    sub_678FF08((__int64)"argument not found");
  }
  if ( (int)v5 <= a2 )
    goto LABEL_9;
  v6 = *(_QWORD *)(v4 + 16) + 32LL * a2;
  v7 = *(_OWORD *)v6;
  LODWORD(v6) = *(_DWORD *)(v6 + 16);
  v9 = v7;
  v10 = v6;
  if ( !(_DWORD)v6 )
    goto LABEL_9;
LABEL_8:
  result = sub_24EF72C((unsigned int *)&v9, a2);
  **(_DWORD **)v2 = result;
  return result;
}


================================================================================
Function: sub_679A1E4 (0x679A1E4)
================================================================================

unsigned __int8 *__fastcall sub_679A1E4(unsigned __int64 a1, unsigned __int8 *a2, __int64 *a3)
{
  int v3; // w12
  unsigned int v4; // w8
  unsigned __int8 *v5; // x19
  unsigned __int8 *v6; // x8
  int v7; // w10
  int v8; // t1
  __int64 v9; // x21
  unsigned __int8 *v10; // x13
  unsigned __int8 *v11; // x10
  unsigned int v12; // w11
  int v13; // t1
  int v14; // w9
  _QWORD v16[2]; // [xsp+0h] [xbp-30h] BYREF
  int v17; // [xsp+10h] [xbp-20h]

  v3 = *(unsigned __int8 *)a1;
  if ( (unsigned int)(v3 - 48) <= 9 )
  {
    if ( v3 == 48 )
    {
      v4 = 0;
      v5 = (unsigned __int8 *)(a1 + 1);
    }
    else
    {
      v4 = 0;
      v10 = (unsigned __int8 *)(a1 + 1);
      v11 = &a2[~a1 + a1];
      while ( 1 )
      {
        v12 = v4;
        v4 = v3 + 10 * v4 - 48;
        if ( v10 == a2 )
          break;
        v13 = *v10++;
        v3 = v13;
        if ( (unsigned int)(v13 - 48) >= 0xA )
        {
          v11 = v10 - 2;
          v5 = v10 - 1;
          goto LABEL_20;
        }
      }
      v5 = a2;
LABEL_20:
      if ( (__int64)&v5[-a1] >= 10
        && (&v5[-a1] != (unsigned __int8 *)&byte_9[1]
         || ((unsigned int)((char)*v11 - 48) + 10 * (unsigned __int64)v12) >> 31) )
      {
        v4 = 0x7FFFFFFF;
      }
    }
    if ( v5 != a2 )
    {
      v14 = *v5;
      if ( v14 == 58 || v14 == 125 )
      {
        sub_679A484(a3, v4);
        return v5;
      }
    }
LABEL_29:
    sub_678FF08((__int64)"invalid format string");
  }
  if ( v3 != 95 && (v3 & 0xFFFFFFDF) - 65 > 0x19 )
    goto LABEL_29;
  v6 = (unsigned __int8 *)(a1 + 1);
  while ( v6 != a2 )
  {
    v8 = *v6++;
    v7 = v8;
    if ( (unsigned int)(v8 - 48) >= 0xA && v7 != 95 && (v7 & 0xFFFFFFDF) - 65 >= 0x1A )
    {
      v5 = v6 - 1;
      goto LABEL_13;
    }
  }
  v5 = a2;
LABEL_13:
  v9 = *a3;
  sub_24EF7F8(v16, *(_QWORD *)(*a3 + 16) + 8LL, a1, &v5[-a1]);
  if ( !v17 )
    sub_678FF08((__int64)"argument not found");
  *(_DWORD *)(*(_QWORD *)v9 + 4LL) = sub_24EF90C(v16);
  return v5;
}


================================================================================
Function: sub_679A3A4 (0x679A3A4)
================================================================================

__int64 __fastcall sub_679A3A4(__int64 a1)
{
  _QWORD *v1; // x20
  __int64 v2; // x10
  __int64 v3; // x8
  __int64 v4; // x9
  unsigned __int64 v5; // x10
  __int64 v6; // x8
  __int128 v7; // q0
  __int64 result; // x0
  __int128 v9; // [xsp+0h] [xbp-30h] BYREF
  int v10; // [xsp+10h] [xbp-20h]

  v1 = *(_QWORD **)a1;
  v2 = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
  v3 = *(unsigned int *)(v2 + 16);
  if ( (v3 & 0x80000000) != 0 )
    sub_678FF08((__int64)"cannot switch from manual to automatic argument indexing");
  v4 = v1[2];
  *(_DWORD *)(v2 + 16) = v3 + 1;
  v5 = *(_QWORD *)(v4 + 8);
  if ( (v5 & 0x8000000000000000LL) == 0 )
  {
    if ( (unsigned int)v3 <= 0xE )
    {
      v10 = (v5 >> (4 * (unsigned __int8)v3)) & 0xF;
      if ( v10 )
      {
        v9 = *(_OWORD *)(*(_QWORD *)(v4 + 16) + 16 * v3);
        goto LABEL_8;
      }
    }
LABEL_9:
    sub_678FF08((__int64)"argument not found");
  }
  if ( (int)v3 >= (int)v5 )
    goto LABEL_9;
  v6 = *(_QWORD *)(v4 + 16) + 32 * v3;
  v7 = *(_OWORD *)v6;
  LODWORD(v6) = *(_DWORD *)(v6 + 16);
  v9 = v7;
  v10 = v6;
  if ( !(_DWORD)v6 )
    goto LABEL_9;
LABEL_8:
  result = sub_24EF90C(&v9);
  *(_DWORD *)(*v1 + 4LL) = result;
  return result;
}


================================================================================
Function: sub_679A484 (0x679A484)
================================================================================

unsigned __int64 __fastcall sub_679A484(__int64 a1, int a2)
{
  _QWORD *v2; // x20
  __int64 v3; // x8
  __int64 v4; // x8
  unsigned __int64 v5; // x9
  __int64 v6; // x8
  __int128 v7; // q0
  unsigned __int64 result; // x0
  __int128 v9; // [xsp+0h] [xbp-30h] BYREF
  int v10; // [xsp+10h] [xbp-20h]

  v2 = *(_QWORD **)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
  if ( *(int *)(v3 + 16) >= 1 )
    sub_678FF08((__int64)"cannot switch from automatic to manual argument indexing");
  *(_DWORD *)(v3 + 16) = -1;
  v4 = v2[2];
  v5 = *(_QWORD *)(v4 + 8);
  if ( (v5 & 0x8000000000000000LL) == 0 )
  {
    if ( a2 <= 14 )
    {
      v10 = (v5 >> (4 * (unsigned __int8)a2)) & 0xF;
      if ( v10 )
      {
        v9 = *(_OWORD *)(*(_QWORD *)(v4 + 16) + 16LL * a2);
        goto LABEL_8;
      }
    }
LABEL_9:
    sub_678FF08((__int64)"argument not found");
  }
  if ( (int)v5 <= a2 )
    goto LABEL_9;
  v6 = *(_QWORD *)(v4 + 16) + 32LL * a2;
  v7 = *(_OWORD *)v6;
  LODWORD(v6) = *(_DWORD *)(v6 + 16);
  v9 = v7;
  v10 = v6;
  if ( !(_DWORD)v6 )
    goto LABEL_9;
LABEL_8:
  result = sub_24EF90C((unsigned int *)&v9, a2);
  *(_DWORD *)(*v2 + 4LL) = result;
  return result;
}


================================================================================
Function: sub_679A56C (0x679A56C)
================================================================================

__int64 __fastcall sub_679A56C(__int64 a1, unsigned __int64 a2, unsigned int a3, unsigned int *a4, __int64 a5)
{
  int v5; // w23
  unsigned int v7; // w21
  unsigned __int64 v8; // x20
  __int64 v9; // x19
  __int16 v10; // w10
  unsigned __int64 v11; // x9
  unsigned __int64 v12; // x8
  int v13; // w12
  __int64 v14; // x25
  int v15; // w10
  unsigned __int64 v16; // x9
  unsigned __int64 v17; // x11
  __int16 v18; // w9
  int v19; // w8
  __int64 v20; // x25
  unsigned __int64 v21; // x11
  unsigned __int64 v22; // x8
  bool v23; // cc
  unsigned __int64 v24; // x8
  int v25; // w13
  char *v26; // x26
  unsigned __int64 v27; // x12
  int v28; // w9
  __int64 v29; // x27
  __int16 v30; // w10
  int v31; // w8
  __int64 v32; // x25
  unsigned __int64 v33; // x13
  unsigned __int64 v34; // x8
  unsigned __int64 v35; // x8
  int v36; // w14
  unsigned __int64 v37; // x11
  int v38; // w10
  unsigned __int64 v39; // x12
  __int64 v40; // x25
  unsigned __int64 v41; // x8
  __int16 v42; // w10
  int v43; // w9
  int v44; // w8
  unsigned __int64 v45; // x8
  char *v46; // x26
  int v47; // w10
  __int64 v48; // x12
  unsigned __int64 v49; // x11
  unsigned __int64 v50; // x9
  unsigned __int64 v51; // x27
  __int64 v52; // x9
  bool v53; // cf
  unsigned __int64 v54; // x9
  unsigned __int64 v55; // x25
  char v56; // w8
  unsigned __int64 v57; // x23
  __int64 v58; // x8
  __int64 v59; // x1
  __int64 v60; // x9
  unsigned int v62; // w21
  __int64 v63; // x8
  __int64 v64; // x10
  _BYTE *v65; // x8
  char v66; // w10
  __int64 v67; // x9
  __int64 v68; // x8
  __int64 v69; // x1
  unsigned int v70; // w21
  __int64 v71; // x8
  __int64 v72; // x9
  __int64 v73; // x9
  const char *v74; // x8
  _BYTE *v75; // x9
  unsigned __int64 v76; // x10
  __int64 v77; // x9
  __int64 v78; // x8
  __int64 v79; // x1
  char *v80; // x1
  char v81; // w9
  const char *v82; // x9
  char *v83; // x8
  unsigned __int64 v84; // x10
  unsigned int v85; // w21
  __int64 v86; // x8
  __int64 v87; // x10
  _BYTE *v88; // x8
  char v89; // w10
  __int64 v90; // x9
  __int64 v91; // x8
  __int64 v92; // x1
  unsigned int v93; // w21
  char *v94; // x8
  unsigned __int64 v95; // x9
  unsigned __int64 v96; // x13
  __int64 v97; // x9
  __int64 v98; // x8
  __int64 v99; // x1
  unsigned __int64 v100; // x8
  unsigned __int64 v101; // x28
  _BYTE *v102; // x22
  char v103; // w9
  unsigned __int64 v104; // x23
  unsigned int v105; // w21
  __int64 v106; // x9
  __int64 v107; // x8
  __int64 v108; // x1
  __int64 v109; // x9
  __int64 v110; // x8
  __int64 v111; // x1
  __int64 v112; // x8
  __int64 v113; // x21
  __int64 v114; // x10
  _BYTE *v115; // x8
  char v116; // w10
  char *v117; // x1
  char v118; // w9
  unsigned __int64 v119; // x8
  char v120; // w10
  __int64 v121; // x21
  __int64 v122; // x0
  __int64 v123; // x1
  _BYTE *v124; // x2
  char v125; // w9
  unsigned __int64 v127; // x8
  unsigned __int64 v128; // x28
  char v129; // w9
  unsigned __int64 v130; // x23
  unsigned int v131; // w21
  __int64 v132; // x9
  __int64 v133; // x8
  __int64 v134; // x1
  __int64 v135; // x9
  __int64 v136; // x8
  __int64 v137; // x1
  __int64 v138; // x8
  __int64 v139; // x10
  _BYTE *v140; // x8
  char v141; // w10
  char v142; // w9
  unsigned __int64 v143; // x8
  char v144; // w10
  __int64 v145; // x23
  _DWORD v146[2]; // [xsp+0h] [xbp-50h] BYREF
  unsigned __int64 v147; // [xsp+8h] [xbp-48h]
  unsigned __int64 v148; // [xsp+10h] [xbp-40h]
  unsigned __int64 v149; // [xsp+18h] [xbp-38h]
  int v150; // [xsp+20h] [xbp-30h]
  char v151; // [xsp+24h] [xbp-2Ch]

  v5 = *((unsigned __int8 *)a4 + 8);
  v7 = a3;
  v8 = a2;
  v9 = a1;
  switch ( *((_BYTE *)a4 + 8) )
  {
    case 0:
    case 1:
      v10 = *(_WORD *)((char *)a4 + 9);
      if ( (v10 & 0x100) != 0 )
      {
        sub_5370BA8((__int64)v146, a5, 1);
        v9 = sub_5370CA8(v9, v8, v7, a4, v146);
        if ( (v146[0] & 1) != 0 )
          sub_6575460();
        return v9;
      }
      v11 = byte_1017AEE[__clz(a2 | 1) ^ 0x3F];
      v12 = *a4;
      v13 = a4[1];
      v14 = (__PAIR128__(v11, a2) - qword_1017B30[v11]) >> 64;
      if ( !((v13 + 1) | (unsigned int)v12) )
      {
        if ( a3 )
        {
          v93 = a3 & 0xFFFFFF;
          if ( (a3 & 0xFFFFFF) != 0 )
          {
            do
            {
              v98 = *(_QWORD *)(v9 + 16);
              v99 = v98 + 1;
              if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v98 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v9)(v9);
                v98 = *(_QWORD *)(v9 + 16);
                v99 = v98 + 1;
              }
              v97 = *(_QWORD *)(v9 + 8);
              *(_QWORD *)(v9 + 16) = v99;
              v23 = v93 > 0xFF;
              *(_BYTE *)(v97 + v98) = v93;
              v93 >>= 8;
            }
            while ( v23 );
          }
        }
        v80 = (char *)v146 + v14;
        if ( v8 < 0x64 )
        {
          v94 = (char *)v146 + v14;
          v95 = v8;
          if ( v8 <= 9 )
          {
LABEL_123:
            *(v94 - 1) = v95 + 48;
            return sub_53712B8((unsigned __int64)v146, (__int64)v80, v9);
          }
        }
        else
        {
          v94 = (char *)v146 + v14;
          do
          {
            v23 = v8 >> 4 > 0x270;
            v95 = v8 / 0x64;
            v96 = v8 % 0x64;
            v8 /= 0x64uLL;
            *((_WORD *)v94 - 1) = *(_WORD *)&a00010203040506_1[2 * v96];
            v94 -= 2;
          }
          while ( v23 );
          if ( v95 <= 9 )
            goto LABEL_123;
        }
        *((_WORD *)v94 - 1) = *(_WORD *)&a00010203040506_1[2 * v95];
        return sub_53712B8((unsigned __int64)v146, (__int64)v80, v9);
      }
      v15 = v10 & 0xF;
      v16 = (unsigned int)v14 + HIBYTE(a3);
      if ( v15 == 4 )
      {
        v17 = v12 - v16;
        if ( (unsigned int)v12 > (unsigned int)v16 )
        {
          v16 = (unsigned int)v12;
        }
        else
        {
          v17 = 0LL;
          v16 = (unsigned int)v16;
        }
      }
      else
      {
        v17 = (unsigned int)(v13 - v14);
        if ( v13 <= (int)v14 )
          v17 = 0LL;
        else
          v16 = v13 + HIBYTE(a3);
      }
      v53 = v12 >= v16;
      v143 = v12 - v16;
      if ( !v53 )
        v143 = 0LL;
      v146[0] = a3;
      v144 = byte_173E2B4[v15];
      v147 = v16;
      v148 = v17;
      v149 = a2;
      v150 = v14;
      v145 = v143 - (v143 >> v144);
      if ( v143 >> v144 )
        v9 = sub_24EFF44(a1, v143 >> v144, (_BYTE *)a4 + 11);
      v122 = sub_679B0D4(v146, v9);
      v9 = v122;
      if ( !v145 )
        return v9;
      v123 = v145;
      v124 = (char *)a4 + 11;
      return sub_24EFF44(v122, v123, v124);
    case 2:
      v40 = 0LL;
      v41 = a2;
      do
      {
        v23 = v41 > 7;
        ++v40;
        v41 >>= 3;
      }
      while ( v23 );
      v42 = *(_WORD *)((char *)a4 + 9);
      v43 = a4[1];
      if ( (v42 & 0x80) != 0 && v43 <= (int)v40 && a2 )
      {
        if ( a3 )
          v44 = 12288;
        else
          v44 = 48;
        v7 = (v44 | a3) + 0x1000000;
      }
      v45 = *a4;
      v46 = (char *)v146 + v40 - 1;
      if ( (unsigned int)v45 | (v43 + 1) )
      {
        v47 = v42 & 0xF;
        v48 = v40 + ((unsigned __int64)v7 >> 24);
        v49 = (unsigned int)v40 + HIBYTE(v7);
        if ( v47 == 4 )
        {
          v50 = v45 - v49;
          if ( (unsigned int)v45 <= (unsigned int)v48 )
            v49 = (unsigned int)v48;
          else
            v49 = (unsigned int)v45;
          if ( (unsigned int)v45 <= (unsigned int)v48 )
            v51 = 0LL;
          else
            v51 = v50;
        }
        else if ( v43 <= (int)v40 )
        {
          v51 = 0LL;
        }
        else
        {
          v51 = (unsigned int)(v43 - v40);
          v49 = HIBYTE(v7) + v43;
        }
        v53 = v45 >= v49;
        v127 = v45 - v49;
        if ( v53 )
          v128 = v127;
        else
          v128 = 0LL;
        v102 = (char *)a4 + 11;
        v129 = byte_173E2B4[v47];
        v130 = v128 >> v129;
        if ( v128 >> v129 )
          v9 = sub_24EFF44(a1, v128 >> v129, (_BYTE *)a4 + 11);
        v131 = v7 & 0xFFFFFF;
        if ( v131 )
        {
          do
          {
            v133 = *(_QWORD *)(v9 + 16);
            v134 = v133 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v133 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v133 = *(_QWORD *)(v9 + 16);
              v134 = v133 + 1;
            }
            v132 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v134;
            v53 = v131 >= 0x100;
            *(_BYTE *)(v132 + v133) = v131;
            v131 >>= 8;
          }
          while ( v53 );
        }
        for ( ; v51; *(_BYTE *)(v135 + v136) = 48 )
        {
          v136 = *(_QWORD *)(v9 + 16);
          v137 = v136 + 1;
          if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v136 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v9)(v9);
            v136 = *(_QWORD *)(v9 + 16);
            v137 = v136 + 1;
          }
          --v51;
          v135 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v137;
        }
        v138 = *(_QWORD *)(v9 + 16);
        v113 = v128 - v130;
        if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v138 + v40) )
        {
          v139 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v138 + v40;
          if ( v139 )
          {
            v140 = (_BYTE *)(v139 + v138 + v40 - 1);
            do
            {
              v141 = v8 & 7 | 0x30;
              v53 = v8 >= 8;
              v8 >>= 3;
              *v140-- = v141;
            }
            while ( v53 );
            goto LABEL_193;
          }
        }
        v117 = (char *)v146 + v40;
        do
        {
          v142 = v8 & 7 | 0x30;
          v23 = v8 > 7;
          v8 >>= 3;
          *v46-- = v142;
        }
        while ( v23 );
        goto LABEL_192;
      }
      if ( v7 )
      {
        v85 = v7 & 0xFFFFFF;
        if ( v85 )
        {
          do
          {
            v91 = *(_QWORD *)(v9 + 16);
            v92 = v91 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v91 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v91 = *(_QWORD *)(v9 + 16);
              v92 = v91 + 1;
            }
            v90 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v92;
            v23 = v85 > 0xFF;
            *(_BYTE *)(v90 + v91) = v85;
            v85 >>= 8;
          }
          while ( v23 );
        }
      }
      v86 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v86 + v40) )
      {
        v87 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v86 + v40;
        if ( v87 )
        {
          v88 = (_BYTE *)(v87 + v86 + v40 - 1);
          do
          {
            v89 = v8 & 7 | 0x30;
            v53 = v8 >= 8;
            v8 >>= 3;
            *v88-- = v89;
          }
          while ( v53 );
          return v9;
        }
      }
      v80 = (char *)v146 + v40;
      do
      {
        v125 = v8 & 7 | 0x30;
        v23 = v8 > 7;
        v8 >>= 3;
        *v46-- = v125;
      }
      while ( v23 );
      return sub_53712B8((unsigned __int64)v146, (__int64)v80, v9);
    case 3:
    case 4:
      v30 = *(_WORD *)((char *)a4 + 9);
      if ( (v30 & 0x80) != 0 )
      {
        if ( v5 == 4 )
          v31 = 22576;
        else
          v31 = 30768;
        if ( a3 )
          v31 <<= 8;
        v7 = (v31 | a3) + 0x2000000;
      }
      v32 = 0LL;
      v33 = (unsigned __int64)v7 >> 24;
      v34 = a2;
      do
      {
        v23 = v34 > 0xF;
        ++v32;
        ++v33;
        v34 >>= 4;
      }
      while ( v23 );
      v35 = *a4;
      v36 = a4[1];
      if ( (v36 + 1) | (unsigned int)v35 )
      {
        v37 = v32 + ((unsigned __int64)v7 >> 24);
        v38 = v30 & 0xF;
        if ( v38 == 4 )
        {
          if ( v33 <= v35 )
            v33 = *a4;
          if ( (unsigned int)v35 <= (unsigned int)v37 )
            v37 = (unsigned int)v37;
          else
            v37 = (unsigned int)v35;
          v39 = v33 - ((unsigned __int64)v7 >> 24) - v32;
        }
        else if ( v36 <= (int)v32 )
        {
          v39 = 0LL;
        }
        else
        {
          v39 = (unsigned int)(v36 - v32);
          v37 = v36 + HIBYTE(v7);
        }
        v53 = v35 >= v37;
        v119 = v35 - v37;
        if ( !v53 )
          v119 = 0LL;
        v146[0] = v7;
        v120 = byte_173E2B4[v38];
        v147 = v37;
        v148 = v39;
        v149 = a2;
        v150 = v32;
        v151 = (v32 | ((unsigned __int64)(v5 == 4) << 32)) >> 32;
        v121 = v119 - (v119 >> v120);
        if ( v119 >> v120 )
          v9 = sub_24EFF44(a1, v119 >> v120, (_BYTE *)a4 + 11);
        v122 = sub_679B26C(v146, v9);
        v9 = v122;
        if ( v121 )
        {
          v123 = v121;
          v124 = (char *)a4 + 11;
          return sub_24EFF44(v122, v123, v124);
        }
        return v9;
      }
      if ( v7 )
      {
        v70 = v7 & 0xFFFFFF;
        if ( v70 )
        {
          do
          {
            v78 = *(_QWORD *)(v9 + 16);
            v79 = v78 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v78 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v78 = *(_QWORD *)(v9 + 16);
              v79 = v78 + 1;
            }
            v77 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v79;
            v23 = v70 > 0xFF;
            *(_BYTE *)(v77 + v78) = v70;
            v70 >>= 8;
          }
          while ( v23 );
        }
      }
      v71 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v71 + v32) )
      {
        v72 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v71 + v32;
        if ( v72 )
        {
          v73 = v72 + v71 + v32;
          if ( v5 == 4 )
            v74 = "0123456789ABCDEF";
          else
            v74 = "0123456789abcdef";
          v75 = (_BYTE *)(v73 - 1);
          do
          {
            v76 = v8 & 0xF;
            v53 = v8 >= 0x10;
            v8 >>= 4;
            *v75-- = v74[v76];
          }
          while ( v53 );
          return v9;
        }
      }
      v82 = "0123456789abcdef";
      v83 = (char *)&v146[-1] + v32 + 3;
      v80 = (char *)v146 + v32;
      if ( v5 == 4 )
        v82 = "0123456789ABCDEF";
      do
      {
        v84 = v8 & 0xF;
        v23 = v8 > 0xF;
        v8 >>= 4;
        *v83-- = v82[v84];
      }
      while ( v23 );
      return sub_53712B8((unsigned __int64)v146, (__int64)v80, v9);
    case 5:
    case 6:
      v18 = *(_WORD *)((char *)a4 + 9);
      if ( (v18 & 0x80) != 0 )
      {
        if ( v5 == 6 )
          v19 = 16944;
        else
          v19 = 25136;
        if ( a3 )
          v19 <<= 8;
        v7 = (v19 | a3) + 0x2000000;
      }
      v20 = 0LL;
      v21 = (unsigned __int64)v7 >> 24;
      v22 = a2;
      do
      {
        v23 = v22 > 1;
        ++v20;
        ++v21;
        v22 >>= 1;
      }
      while ( v23 );
      v24 = *a4;
      v25 = a4[1];
      v26 = (char *)&v146[-1] + v20 + 3;
      if ( (v25 + 1) | (unsigned int)v24 )
      {
        v27 = v20 + ((unsigned __int64)v7 >> 24);
        v28 = v18 & 0xF;
        if ( v28 == 4 )
        {
          if ( (unsigned int)v24 <= (unsigned int)v27 )
            v27 = (unsigned int)v27;
          else
            v27 = (unsigned int)v24;
          if ( v21 <= v24 )
            v21 = *a4;
          v29 = v21 - ((unsigned __int64)v7 >> 24) - v20;
        }
        else if ( v25 <= (int)v20 )
        {
          v29 = 0LL;
        }
        else
        {
          v29 = (unsigned int)(v25 - v20);
          v27 = v25 + HIBYTE(v7);
        }
        v53 = v24 >= v27;
        v100 = v24 - v27;
        if ( v53 )
          v101 = v100;
        else
          v101 = 0LL;
        v102 = (char *)a4 + 11;
        v103 = byte_173E2B4[v28];
        v104 = v101 >> v103;
        if ( v101 >> v103 )
          v9 = sub_24EFF44(a1, v101 >> v103, (_BYTE *)a4 + 11);
        v105 = v7 & 0xFFFFFF;
        if ( v105 )
        {
          do
          {
            v107 = *(_QWORD *)(v9 + 16);
            v108 = v107 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v107 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v107 = *(_QWORD *)(v9 + 16);
              v108 = v107 + 1;
            }
            v106 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v108;
            v53 = v105 >= 0x100;
            *(_BYTE *)(v106 + v107) = v105;
            v105 >>= 8;
          }
          while ( v53 );
        }
        for ( ; v29; *(_BYTE *)(v109 + v110) = 48 )
        {
          v110 = *(_QWORD *)(v9 + 16);
          v111 = v110 + 1;
          if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v110 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v9)(v9);
            v110 = *(_QWORD *)(v9 + 16);
            v111 = v110 + 1;
          }
          --v29;
          v109 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v111;
        }
        v112 = *(_QWORD *)(v9 + 16);
        v113 = v101 - v104;
        if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v112 + v20)
          && (v114 = *(_QWORD *)(v9 + 8), *(_QWORD *)(v9 + 16) = v112 + v20, v114) )
        {
          v115 = (_BYTE *)(v114 + v112 + v20 - 1);
          do
          {
            v116 = v8 & 1 | 0x30;
            v53 = v8 >= 2;
            v8 >>= 1;
            *v115-- = v116;
          }
          while ( v53 );
        }
        else
        {
          v117 = (char *)v146 + v20;
          do
          {
            v118 = v8 & 1 | 0x30;
            v23 = v8 > 1;
            v8 >>= 1;
            *v26-- = v118;
          }
          while ( v23 );
LABEL_192:
          v9 = sub_53712B8((unsigned __int64)v146, (__int64)v117, v9);
        }
LABEL_193:
        if ( v113 )
        {
          v122 = v9;
          v123 = v113;
          v124 = v102;
          return sub_24EFF44(v122, v123, v124);
        }
        return v9;
      }
      if ( v7 )
      {
        v62 = v7 & 0xFFFFFF;
        if ( v62 )
        {
          do
          {
            v68 = *(_QWORD *)(v9 + 16);
            v69 = v68 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v68 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v68 = *(_QWORD *)(v9 + 16);
              v69 = v68 + 1;
            }
            v67 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v69;
            v23 = v62 > 0xFF;
            *(_BYTE *)(v67 + v68) = v62;
            v62 >>= 8;
          }
          while ( v23 );
        }
      }
      v63 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v63 + v20) )
      {
        v64 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v63 + v20;
        if ( v64 )
        {
          v65 = (_BYTE *)(v64 + v63 + v20 - 1);
          do
          {
            v66 = v8 & 1 | 0x30;
            v53 = v8 >= 2;
            v8 >>= 1;
            *v65-- = v66;
          }
          while ( v53 );
          return v9;
        }
      }
      v80 = (char *)v146 + v20;
      do
      {
        v81 = v8 & 1 | 0x30;
        v23 = v8 > 1;
        v8 >>= 1;
        *v26-- = v81;
      }
      while ( v23 );
      return sub_53712B8((unsigned __int64)v146, (__int64)v80, v9);
    case 0xF:
      v52 = *a4;
      v53 = v52 != 0;
      v54 = v52 - 1;
      if ( v53 )
        v55 = v54;
      else
        v55 = 0LL;
      v56 = byte_173E2B9[*(_WORD *)((_BYTE *)a4 + 9) & 0xF];
      v57 = v55 >> v56;
      if ( v55 >> v56 )
        v9 = sub_24EFF44(a1, v55 >> v56, (_BYTE *)a4 + 11);
      v58 = *(_QWORD *)(v9 + 16);
      v59 = v58 + 1;
      if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v58 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v9)(v9);
        v58 = *(_QWORD *)(v9 + 16);
        v59 = v58 + 1;
      }
      v60 = *(_QWORD *)(v9 + 8);
      *(_QWORD *)(v9 + 16) = v59;
      *(_BYTE *)(v60 + v58) = v8;
      if ( v55 == v57 )
        return v9;
      return sub_24EFF44(v9, v55 - v57, (_BYTE *)a4 + 11);
    default:
      sub_678FF08((__int64)"invalid type specifier");
  }
}


================================================================================
Function: sub_679B0D4 (0x679B0D4)
================================================================================

__int64 __fastcall sub_679B0D4(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  unsigned __int64 v13; // x10
  _BYTE *v14; // x1
  _BYTE *v15; // x9
  bool v16; // cc
  unsigned __int64 v17; // x11
  unsigned __int64 v18; // x14
  _BYTE v20[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_QWORD *)(a1 + 24);
  v14 = &v20[*(int *)(a1 + 32)];
  if ( v13 >= 0x64 )
  {
    v15 = &v20[*(int *)(a1 + 32)];
    do
    {
      v16 = v13 >> 4 > 0x270;
      v17 = v13 / 0x64;
      v18 = v13 % 0x64;
      v13 /= 0x64uLL;
      *((_WORD *)v15 - 1) = *(_WORD *)&a00010203040506_1[2 * v18];
      v15 -= 2;
    }
    while ( v16 );
    if ( v17 <= 9 )
      goto LABEL_15;
LABEL_17:
    *((_WORD *)v15 - 1) = *(_WORD *)&a00010203040506_1[2 * v17];
    return sub_53712B8((unsigned __int64)v20, (__int64)v14, a2);
  }
  v15 = &v20[*(int *)(a1 + 32)];
  v17 = *(_QWORD *)(a1 + 24);
  if ( v13 > 9 )
    goto LABEL_17;
LABEL_15:
  *(v15 - 1) = v17 + 48;
  return sub_53712B8((unsigned __int64)v20, (__int64)v14, a2);
}


================================================================================
Function: sub_679B26C (0x679B26C)
================================================================================

__int64 __fastcall sub_679B26C(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  __int64 v13; // x11
  __int64 v14; // x10
  unsigned __int64 v15; // x8
  __int64 v16; // x9
  unsigned __int64 v17; // x13
  int v18; // w10
  __int64 v19; // x12
  bool v20; // zf
  __int64 v21; // x10
  const char *v22; // x9
  _BYTE *v23; // x10
  unsigned __int64 v24; // x11
  _BYTE *v25; // x1
  _BYTE *v26; // x10
  const char *v27; // x9
  unsigned __int64 v28; // x11
  bool v29; // cc
  _BYTE v31[20]; // [xsp+4h] [xbp-1Ch] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_QWORD *)(a2 + 16);
  v14 = *(unsigned int *)(a1 + 32);
  v15 = *(_QWORD *)(a1 + 24);
  v16 = (int)v14;
  v17 = v13 + v14;
  v18 = *(unsigned __int8 *)(a1 + 36);
  if ( *(_QWORD *)(a2 + 24) >= v17 && (v19 = *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16) = v17, v19) )
  {
    v20 = v18 == 0;
    v21 = v13 + v16 + v19;
    if ( v20 )
      v22 = "0123456789abcdef";
    else
      v22 = "0123456789ABCDEF";
    v23 = (_BYTE *)(v21 - 1);
    do
    {
      v24 = v15 & 0xF;
      v7 = v15 >= 0x10;
      v15 >>= 4;
      *v23-- = v22[v24];
    }
    while ( v7 );
  }
  else
  {
    v25 = &v31[v16];
    v20 = v18 == 0;
    v26 = &v31[v16 - 1];
    if ( v20 )
      v27 = "0123456789abcdef";
    else
      v27 = "0123456789ABCDEF";
    do
    {
      v28 = v15 & 0xF;
      v29 = v15 > 0xF;
      v15 >>= 4;
      *v26-- = v27[v28];
    }
    while ( v29 );
    return sub_53712B8((unsigned __int64)v31, (__int64)v25, a2);
  }
  return a2;
}


================================================================================
Function: sub_679B430 (0x679B430)
================================================================================

__int64 __fastcall sub_679B430(__int64 a1, __int64 a2, unsigned int *a3, __int64 a4)
{
  int v4; // w25
  unsigned int v5; // w22
  unsigned __int64 v6; // x20
  unsigned __int64 v7; // x21
  __int64 v9; // x19
  __int16 v10; // w26
  bool v11; // w8
  int v12; // w27
  __int16 v13; // w8
  int v14; // w9
  __int64 v15; // x27
  unsigned __int64 v16; // x11
  unsigned __int64 v17; // x10
  unsigned __int64 v18; // x12
  bool v19; // cc
  __int128 v20; // t2
  char v21; // w13
  bool v22; // zf
  bool v23; // w14
  unsigned __int64 v24; // x10
  int v25; // w13
  char *v26; // x25
  unsigned __int64 v27; // x12
  int v28; // w8
  __int64 v29; // x28
  __int16 v30; // w10
  int v31; // w9
  __int64 v32; // x24
  unsigned __int64 v33; // x13
  unsigned __int64 v34; // x9
  unsigned __int64 v35; // x12
  __int128 v36; // t2
  char v37; // w14
  bool v38; // w15
  unsigned __int64 v39; // x9
  int v40; // w14
  unsigned __int64 v41; // x12
  int v42; // w10
  unsigned __int64 v43; // x11
  __int64 v44; // x25
  unsigned __int64 v45; // x8
  unsigned __int64 v46; // x9
  __int128 v47; // t2
  char v48; // w10
  bool v49; // w11
  __int16 v50; // w10
  int v51; // w9
  int v52; // w8
  unsigned __int64 v53; // x8
  char *v54; // x27
  int v55; // w10
  __int64 v56; // x12
  unsigned __int64 v57; // x11
  unsigned __int64 v58; // x9
  unsigned __int64 v59; // x28
  __int64 v60; // x9
  bool v61; // cf
  unsigned __int64 v62; // x9
  unsigned __int64 v63; // x24
  char v64; // w8
  unsigned __int64 v65; // x22
  __int64 v66; // x8
  __int64 v67; // x22
  __int64 v68; // x1
  __int64 v69; // x9
  __int64 v71; // x1
  unsigned int v72; // w22
  __int64 v73; // x8
  __int64 v74; // x10
  _BYTE *v75; // x8
  unsigned __int64 v76; // x9
  __int128 v77; // t2
  bool v78; // w11
  char v79; // w12
  __int64 v80; // x9
  __int64 v81; // x8
  __int64 v82; // x1
  unsigned int v83; // w22
  __int64 v84; // x8
  __int64 v85; // x9
  __int64 v86; // x9
  const char *v87; // x8
  char *v88; // x9
  unsigned __int64 v89; // x10
  bool v90; // w12
  __int128 v91; // t2
  char v92; // w10
  __int64 v93; // x9
  __int64 v94; // x8
  __int64 v95; // x1
  char *v96; // x1
  unsigned __int64 v97; // x8
  __int128 v98; // t2
  bool v99; // w9
  bool v100; // w11
  char v101; // w10
  const char *v102; // x9
  char *v103; // x8
  unsigned __int64 v104; // x10
  bool v105; // w11
  bool v106; // w12
  __int128 v107; // t2
  char v108; // w10
  unsigned __int64 v109; // x25
  unsigned __int64 v110; // x24
  bool v111; // w8
  bool v112; // w8
  __int128 v113; // t2
  bool v114; // w9
  bool v115; // w8
  __int64 v116; // x0
  __int128 v117; // t2
  unsigned __int64 v118; // x9
  unsigned __int64 v119; // x1
  bool v120; // w8
  bool v121; // w9
  unsigned int v122; // w22
  __int64 v123; // x8
  __int64 v124; // x10
  _BYTE *v125; // x8
  unsigned __int64 v126; // x9
  __int128 v127; // t2
  bool v128; // w11
  char v129; // w12
  __int64 v130; // x9
  __int64 v131; // x8
  __int64 v132; // x1
  _BYTE *v133; // x23
  char v134; // w8
  unsigned __int64 v135; // x26
  unsigned __int64 v136; // x24
  unsigned int v137; // w22
  __int64 v138; // x9
  __int64 v139; // x8
  __int64 v140; // x1
  __int64 v141; // x9
  __int64 v142; // x8
  __int64 v143; // x1
  __int64 v144; // x8
  __int64 v145; // x22
  __int64 v146; // x10
  _BYTE *v147; // x8
  unsigned __int64 v148; // x9
  __int128 v149; // t2
  bool v150; // w11
  char v151; // w12
  char *v152; // x1
  unsigned __int64 v153; // x8
  __int128 v154; // t2
  bool v155; // w9
  bool v156; // w11
  char v157; // w10
  unsigned __int64 v158; // x9
  char v159; // w10
  __int64 v160; // x21
  __int64 v161; // x0
  __int64 v162; // x1
  _BYTE *v163; // x2
  unsigned __int64 v164; // x8
  __int128 v165; // t2
  bool v166; // w9
  bool v167; // w11
  char v168; // w10
  unsigned __int64 v169; // x8
  unsigned __int64 v170; // x26
  char v171; // w9
  unsigned __int64 v172; // x24
  unsigned int v173; // w22
  __int64 v174; // x9
  __int64 v175; // x8
  __int64 v176; // x1
  __int64 v177; // x9
  __int64 v178; // x8
  __int64 v179; // x1
  __int64 v180; // x8
  __int64 v181; // x10
  _BYTE *v182; // x8
  unsigned __int64 v183; // x9
  __int128 v184; // t2
  bool v185; // w11
  char v186; // w12
  unsigned __int64 v187; // x8
  __int128 v188; // t2
  bool v189; // w9
  bool v190; // w11
  char v191; // w10
  unsigned __int64 v192; // x8
  signed int v193; // w12
  unsigned __int64 v194; // x9
  unsigned __int64 v195; // x11
  unsigned int v196; // w22
  bool v197; // w8
  char *v198; // x23
  unsigned __int64 v199; // x0
  unsigned __int64 v200; // x1
  __int128 v201; // t2
  unsigned __int64 v202; // x9
  bool v203; // w10
  __int16 v204; // w8
  bool v205; // w9
  __int64 v206; // x9
  __int64 v207; // x8
  __int64 v208; // x1
  bool v209; // w8
  unsigned __int64 v211; // x8
  char v212; // w10
  __int64 v213; // x24
  _DWORD v214[2]; // [xsp+0h] [xbp-90h] BYREF
  unsigned __int64 v215; // [xsp+8h] [xbp-88h]
  unsigned __int64 v216; // [xsp+10h] [xbp-80h]
  unsigned __int64 v217; // [xsp+20h] [xbp-70h]
  unsigned __int64 v218; // [xsp+28h] [xbp-68h]
  int v219; // [xsp+30h] [xbp-60h]
  bool v220; // [xsp+34h] [xbp-5Ch]

  v4 = *((unsigned __int8 *)a3 + 8);
  v5 = *(_DWORD *)(a2 + 16);
  v6 = *(_QWORD *)a2;
  v7 = *(_QWORD *)(a2 + 8);
  v9 = a1;
  switch ( *((_BYTE *)a3 + 8) )
  {
    case 0:
    case 1:
      v10 = *(_WORD *)((char *)a3 + 9);
      if ( (v10 & 0x100) != 0 )
      {
        sub_5370BA8((__int64)v214, a4, 1);
        v9 = sub_679C180(v9, v71, v6, v7, v5, a3, v214);
        if ( (v214[0] & 1) != 0 )
          sub_6575460();
        return v9;
      }
      v11 = v6 < 0xA;
      if ( v7 )
        v11 = 0;
      if ( v11 )
      {
        v12 = 1;
        goto LABEL_230;
      }
      v12 = 4;
      v109 = *(_QWORD *)a2;
      v110 = *(_QWORD *)(a2 + 8);
      while ( 2 )
      {
        v111 = v109 > 0x63;
        if ( v110 )
          v111 = 1;
        if ( v111 )
        {
          v112 = v109 > 0x3E7;
          if ( v110 )
            v112 = 1;
          if ( v112 )
          {
            *((_QWORD *)&v113 + 1) = v110;
            *(_QWORD *)&v113 = v109;
            v114 = (unsigned __int64)(v113 >> 4) < 0x271;
            if ( v110 >> 4 )
              v115 = 0;
            else
              v115 = v114;
            if ( v115 )
              break;
            v116 = sub_67EF95C(v109, v110, 10000LL, 0LL);
            *((_QWORD *)&v117 + 1) = v110;
            *(_QWORD *)&v117 = v109;
            v118 = v110 >> 5;
            v12 += 4;
            v109 = v116;
            v110 = v119;
            v120 = (unsigned __int64)(v117 >> 5) > 0xC34;
            v22 = v118 == 0;
            v121 = v118 != 0;
            if ( !v22 )
              v120 = v121;
            if ( !v120 )
            {
              v12 -= 3;
              break;
            }
            continue;
          }
          --v12;
        }
        else
        {
          v12 -= 2;
        }
        break;
      }
LABEL_230:
      v192 = *a3;
      v193 = a3[1];
      if ( !((v193 + 1) | (unsigned int)v192) )
      {
        if ( v5 )
        {
          v196 = v5 & 0xFFFFFF;
          if ( v196 )
          {
            do
            {
              v207 = *(_QWORD *)(v9 + 16);
              v208 = v207 + 1;
              if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v207 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v9)(v9);
                v207 = *(_QWORD *)(v9 + 16);
                v208 = v207 + 1;
              }
              v206 = *(_QWORD *)(v9 + 8);
              *(_QWORD *)(v9 + 16) = v208;
              v19 = v196 > 0xFF;
              *(_BYTE *)(v206 + v207) = v196;
              v196 >>= 8;
            }
            while ( v19 );
          }
        }
        v197 = v6 < 0x64;
        if ( v7 )
          v197 = 0;
        if ( v197 )
        {
          v198 = (char *)v214 + v12;
          v199 = v6;
          v200 = v7;
        }
        else
        {
          v198 = (char *)v214 + v12;
          do
          {
            v199 = sub_67EF95C(v6, v7, 100LL, 0LL);
            *((_QWORD *)&v201 + 1) = v7;
            *(_QWORD *)&v201 = v6;
            v202 = v6 - 100 * v199;
            v6 = v199;
            v203 = (unsigned __int64)(v201 >> 4) > 0x270;
            v204 = *(_WORD *)&a00010203040506_1[2 * v202];
            v205 = v7 >> 4 != 0;
            if ( !(v7 >> 4) )
              v205 = v203;
            v7 = v200;
            *((_WORD *)v198 - 1) = v204;
            v198 -= 2;
          }
          while ( v205 );
        }
        v209 = v199 > 9;
        if ( v200 )
          v209 = 1;
        if ( v209 )
          *((_WORD *)v198 - 1) = *(_WORD *)&a00010203040506_1[2 * v199];
        else
          *(v198 - 1) = v199 + 48;
        v96 = (char *)v214 + v12;
        return sub_53712B8((unsigned __int64)v214, (__int64)v96, v9);
      }
      v194 = v12 + HIBYTE(v5);
      if ( (v10 & 0xF) == 4 )
      {
        v195 = v192 - v194;
        if ( (unsigned int)v192 > (unsigned int)v194 )
        {
          v194 = (unsigned int)v192;
        }
        else
        {
          v195 = 0LL;
          v194 = (unsigned int)v194;
        }
      }
      else
      {
        v195 = (unsigned int)(v193 - v12);
        if ( v193 <= v12 )
          v195 = 0LL;
        else
          v194 = v193 + HIBYTE(v5);
      }
      v61 = v192 >= v194;
      v211 = v192 - v194;
      if ( !v61 )
        v211 = 0LL;
      v214[0] = v5;
      v212 = byte_173E2B4[v10 & 0xF];
      v215 = v194;
      v216 = v195;
      v217 = v6;
      v218 = v7;
      v219 = v12;
      v213 = v211 - (v211 >> v212);
      if ( v211 >> v212 )
        v9 = sub_24EFF44(v9, v211 >> v212, (_BYTE *)a3 + 11);
      v161 = sub_679C50C(v214, v9);
      v9 = v161;
      if ( v213 )
      {
        v162 = v213;
        v163 = (char *)a3 + 11;
        return sub_24EFF44(v161, v162, v163);
      }
      return v9;
    case 2:
      v44 = 0LL;
      v45 = *(_QWORD *)a2;
      v46 = *(_QWORD *)(a2 + 8);
      do
      {
        v19 = v45 > 7;
        *((_QWORD *)&v47 + 1) = v46;
        *(_QWORD *)&v47 = v45;
        v45 = v47 >> 3;
        v48 = v19;
        v22 = v46 == 0;
        v49 = v46 != 0;
        v46 >>= 3;
        if ( !v22 )
          v48 = v49;
        ++v44;
      }
      while ( (v48 & 1) != 0 );
      v50 = *(_WORD *)((char *)a3 + 9);
      v51 = a3[1];
      if ( (v50 & 0x80) != 0 && v51 <= (int)v44 && v6 | v7 )
      {
        if ( v5 )
          v52 = 12288;
        else
          v52 = 48;
        v5 = (v52 | v5) + 0x1000000;
      }
      v53 = *a3;
      v54 = (char *)v214 + v44 - 1;
      if ( (unsigned int)v53 | (v51 + 1) )
      {
        v55 = v50 & 0xF;
        v56 = v44 + ((unsigned __int64)v5 >> 24);
        v57 = (unsigned int)v44 + HIBYTE(v5);
        if ( v55 == 4 )
        {
          v58 = v53 - v57;
          if ( (unsigned int)v53 <= (unsigned int)v56 )
            v57 = (unsigned int)v56;
          else
            v57 = (unsigned int)v53;
          if ( (unsigned int)v53 <= (unsigned int)v56 )
            v59 = 0LL;
          else
            v59 = v58;
        }
        else if ( v51 <= (int)v44 )
        {
          v59 = 0LL;
        }
        else
        {
          v59 = (unsigned int)(v51 - v44);
          v57 = HIBYTE(v5) + v51;
        }
        v61 = v53 >= v57;
        v169 = v53 - v57;
        if ( v61 )
          v170 = v169;
        else
          v170 = 0LL;
        v133 = (char *)a3 + 11;
        v171 = byte_173E2B4[v55];
        v172 = v170 >> v171;
        if ( v170 >> v171 )
          v9 = sub_24EFF44(a1, v170 >> v171, (_BYTE *)a3 + 11);
        v173 = v5 & 0xFFFFFF;
        if ( v173 )
        {
          do
          {
            v175 = *(_QWORD *)(v9 + 16);
            v176 = v175 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v175 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v175 = *(_QWORD *)(v9 + 16);
              v176 = v175 + 1;
            }
            v174 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v176;
            v61 = v173 >= 0x100;
            *(_BYTE *)(v174 + v175) = v173;
            v173 >>= 8;
          }
          while ( v61 );
        }
        for ( ; v59; *(_BYTE *)(v177 + v178) = 48 )
        {
          v178 = *(_QWORD *)(v9 + 16);
          v179 = v178 + 1;
          if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v178 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v9)(v9);
            v178 = *(_QWORD *)(v9 + 16);
            v179 = v178 + 1;
          }
          --v59;
          v177 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v179;
        }
        v180 = *(_QWORD *)(v9 + 16);
        v145 = v170 - v172;
        if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v180 + v44) )
        {
          v181 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v180 + v44;
          if ( v181 )
          {
            v182 = (_BYTE *)(v181 + v180 + v44 - 1);
            do
            {
              *((_QWORD *)&v184 + 1) = v7;
              *(_QWORD *)&v184 = v6;
              v183 = v184 >> 3;
              v185 = v6 < 8;
              v186 = v6 & 7 | 0x30;
              if ( v7 )
                v185 = 0;
              v6 = v183;
              v7 >>= 3;
              *v182-- = v186;
            }
            while ( !v185 );
            goto LABEL_226;
          }
        }
        v152 = (char *)v214 + v44;
        do
        {
          *((_QWORD *)&v188 + 1) = v7;
          *(_QWORD *)&v188 = v6;
          v187 = v188 >> 3;
          v189 = v6 > 7;
          v22 = v7 == 0;
          v190 = v7 != 0;
          v7 >>= 3;
          v191 = v6 & 7 | 0x30;
          if ( !v22 )
            v189 = v190;
          v6 = v187;
          *v54-- = v191;
        }
        while ( v189 );
        goto LABEL_225;
      }
      if ( v5 )
      {
        v122 = v5 & 0xFFFFFF;
        if ( v122 )
        {
          do
          {
            v131 = *(_QWORD *)(v9 + 16);
            v132 = v131 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v131 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v131 = *(_QWORD *)(v9 + 16);
              v132 = v131 + 1;
            }
            v130 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v132;
            v19 = v122 > 0xFF;
            *(_BYTE *)(v130 + v131) = v122;
            v122 >>= 8;
          }
          while ( v19 );
        }
      }
      v123 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v123 + v44) )
      {
        v124 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v123 + v44;
        if ( v124 )
        {
          v125 = (_BYTE *)(v124 + v123 + v44 - 1);
          do
          {
            *((_QWORD *)&v127 + 1) = v7;
            *(_QWORD *)&v127 = v6;
            v126 = v127 >> 3;
            v128 = v6 < 8;
            v129 = v6 & 7 | 0x30;
            if ( v7 )
              v128 = 0;
            v6 = v126;
            v7 >>= 3;
            *v125-- = v129;
          }
          while ( !v128 );
          return v9;
        }
      }
      v96 = (char *)v214 + v44;
      do
      {
        *((_QWORD *)&v165 + 1) = v7;
        *(_QWORD *)&v165 = v6;
        v164 = v165 >> 3;
        v166 = v6 > 7;
        v22 = v7 == 0;
        v167 = v7 != 0;
        v7 >>= 3;
        v168 = v6 & 7 | 0x30;
        if ( !v22 )
          v166 = v167;
        v6 = v164;
        *v54-- = v168;
      }
      while ( v166 );
      return sub_53712B8((unsigned __int64)v214, (__int64)v96, v9);
    case 3:
    case 4:
      v30 = *(_WORD *)((char *)a3 + 9);
      if ( (v30 & 0x80) != 0 )
      {
        if ( v4 == 4 )
          v31 = 22576;
        else
          v31 = 30768;
        if ( v5 )
          v31 <<= 8;
        v5 = (v31 | v5) + 0x2000000;
      }
      v32 = 0LL;
      v33 = (unsigned __int64)v5 >> 24;
      v34 = *(_QWORD *)a2;
      v35 = *(_QWORD *)(a2 + 8);
      do
      {
        v19 = v34 > 0xF;
        *((_QWORD *)&v36 + 1) = v35;
        *(_QWORD *)&v36 = v34;
        v34 = v36 >> 4;
        v37 = v19;
        v22 = v35 == 0;
        v38 = v35 != 0;
        v35 >>= 4;
        if ( !v22 )
          v37 = v38;
        ++v32;
        ++v33;
      }
      while ( (v37 & 1) != 0 );
      v39 = *a3;
      v40 = a3[1];
      if ( (v40 + 1) | (unsigned int)v39 )
      {
        v41 = v32 + ((unsigned __int64)v5 >> 24);
        v42 = v30 & 0xF;
        if ( v42 == 4 )
        {
          if ( v33 <= v39 )
            v33 = *a3;
          if ( (unsigned int)v39 <= (unsigned int)v41 )
            v41 = (unsigned int)v41;
          else
            v41 = (unsigned int)v39;
          v43 = v33 - ((unsigned __int64)v5 >> 24) - v32;
        }
        else if ( v40 <= (int)v32 )
        {
          v43 = 0LL;
        }
        else
        {
          v41 = v40 + HIBYTE(v5);
          v43 = (unsigned int)(v40 - v32);
        }
        v61 = v39 >= v41;
        v158 = v39 - v41;
        if ( !v61 )
          v158 = 0LL;
        v217 = *(_QWORD *)a2;
        v218 = v7;
        v159 = byte_173E2B4[v42];
        v214[0] = v5;
        v215 = v41;
        v216 = v43;
        v219 = v32;
        v220 = v4 == 4;
        v160 = v158 - (v158 >> v159);
        if ( v158 >> v159 )
          v9 = sub_24EFF44(a1, v158 >> v159, (_BYTE *)a3 + 11);
        v161 = sub_679C6DC(v214, v9);
        v9 = v161;
        if ( v160 )
        {
          v162 = v160;
          v163 = (char *)a3 + 11;
          return sub_24EFF44(v161, v162, v163);
        }
        return v9;
      }
      if ( v5 )
      {
        v83 = v5 & 0xFFFFFF;
        if ( v83 )
        {
          do
          {
            v94 = *(_QWORD *)(v9 + 16);
            v95 = v94 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v94 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v94 = *(_QWORD *)(v9 + 16);
              v95 = v94 + 1;
            }
            v93 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v95;
            v19 = v83 > 0xFF;
            *(_BYTE *)(v93 + v94) = v83;
            v83 >>= 8;
          }
          while ( v19 );
        }
      }
      v84 = *(_QWORD *)(v9 + 16);
      if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v84 + v32) )
      {
        v85 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = v84 + v32;
        if ( v85 )
        {
          v86 = v85 + v84 + v32;
          if ( v4 == 4 )
            v87 = "0123456789ABCDEF";
          else
            v87 = "0123456789abcdef";
          v88 = (char *)(v86 - 1);
          do
          {
            v89 = v6 & 0xF;
            v90 = v6 < 0x10;
            *((_QWORD *)&v91 + 1) = v7;
            *(_QWORD *)&v91 = v6;
            v6 = v91 >> 4;
            v92 = v87[v89];
            if ( v7 )
              v90 = 0;
            v7 >>= 4;
            *v88-- = v92;
          }
          while ( !v90 );
          return v9;
        }
      }
      v102 = "0123456789abcdef";
      v103 = (char *)&v214[-1] + v32 + 3;
      v96 = (char *)v214 + v32;
      if ( v4 == 4 )
        v102 = "0123456789ABCDEF";
      do
      {
        v104 = v6 & 0xF;
        v105 = v6 > 0xF;
        v22 = v7 == 0;
        v106 = v7 != 0;
        *((_QWORD *)&v107 + 1) = v7;
        *(_QWORD *)&v107 = v6;
        v6 = v107 >> 4;
        v108 = v102[v104];
        v7 >>= 4;
        if ( !v22 )
          v105 = v106;
        *v103-- = v108;
      }
      while ( v105 );
      return sub_53712B8((unsigned __int64)v214, (__int64)v96, v9);
    case 5:
    case 6:
      v13 = *(_WORD *)((char *)a3 + 9);
      if ( (v13 & 0x80) != 0 )
      {
        if ( v4 == 6 )
          v14 = 16944;
        else
          v14 = 25136;
        if ( v5 )
          v14 <<= 8;
        v5 = (v14 | v5) + 0x2000000;
      }
      v15 = 0LL;
      v16 = (unsigned __int64)v5 >> 24;
      v17 = *(_QWORD *)a2;
      v18 = *(_QWORD *)(a2 + 8);
      do
      {
        v19 = v17 > 1;
        *((_QWORD *)&v20 + 1) = v18;
        *(_QWORD *)&v20 = v17;
        v17 = v20 >> 1;
        v21 = v19;
        v22 = v18 == 0;
        v23 = v18 != 0;
        v18 >>= 1;
        if ( !v22 )
          v21 = v23;
        ++v15;
        ++v16;
      }
      while ( (v21 & 1) != 0 );
      v24 = *a3;
      v25 = a3[1];
      v26 = (char *)&v214[-1] + v15 + 3;
      if ( (v25 + 1) | (unsigned int)v24 )
      {
        v27 = v15 + ((unsigned __int64)v5 >> 24);
        v28 = v13 & 0xF;
        if ( v28 == 4 )
        {
          if ( (unsigned int)v24 <= (unsigned int)v27 )
            v27 = (unsigned int)v27;
          else
            v27 = (unsigned int)v24;
          if ( v16 <= v24 )
            v16 = *a3;
          v29 = v16 - ((unsigned __int64)v5 >> 24) - v15;
        }
        else if ( v25 <= (int)v15 )
        {
          v29 = 0LL;
        }
        else
        {
          v29 = (unsigned int)(v25 - v15);
          v27 = v25 + HIBYTE(v5);
        }
        v133 = (char *)a3 + 11;
        v134 = byte_173E2B4[v28];
        if ( v24 >= v27 )
          v135 = v24 - v27;
        else
          v135 = 0LL;
        v136 = v135 >> v134;
        if ( v135 >> v134 )
          v9 = sub_24EFF44(a1, v135 >> v134, (_BYTE *)a3 + 11);
        v137 = v5 & 0xFFFFFF;
        if ( v137 )
        {
          do
          {
            v139 = *(_QWORD *)(v9 + 16);
            v140 = v139 + 1;
            if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v139 + 1) )
            {
              (**(void (__fastcall ***)(__int64))v9)(v9);
              v139 = *(_QWORD *)(v9 + 16);
              v140 = v139 + 1;
            }
            v138 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 16) = v140;
            v61 = v137 >= 0x100;
            *(_BYTE *)(v138 + v139) = v137;
            v137 >>= 8;
          }
          while ( v61 );
        }
        for ( ; v29; *(_BYTE *)(v141 + v142) = 48 )
        {
          v142 = *(_QWORD *)(v9 + 16);
          v143 = v142 + 1;
          if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v142 + 1) )
          {
            (**(void (__fastcall ***)(__int64))v9)(v9);
            v142 = *(_QWORD *)(v9 + 16);
            v143 = v142 + 1;
          }
          --v29;
          v141 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 16) = v143;
        }
        v144 = *(_QWORD *)(v9 + 16);
        v145 = v135 - v136;
        if ( *(_QWORD *)(v9 + 24) >= (unsigned __int64)(v144 + v15)
          && (v146 = *(_QWORD *)(v9 + 8), *(_QWORD *)(v9 + 16) = v144 + v15, v146) )
        {
          v147 = (_BYTE *)(v146 + v144 + v15 - 1);
          do
          {
            *((_QWORD *)&v149 + 1) = v7;
            *(_QWORD *)&v149 = v6;
            v148 = v149 >> 1;
            v150 = v6 < 2;
            v151 = v6 & 1 | 0x30;
            if ( v7 )
              v150 = 0;
            v6 = v148;
            v7 >>= 1;
            *v147-- = v151;
          }
          while ( !v150 );
        }
        else
        {
          v152 = (char *)v214 + v15;
          do
          {
            *((_QWORD *)&v154 + 1) = v7;
            *(_QWORD *)&v154 = v6;
            v153 = v154 >> 1;
            v155 = v6 > 1;
            v22 = v7 == 0;
            v156 = v7 != 0;
            v7 >>= 1;
            v157 = v6 & 1 | 0x30;
            if ( !v22 )
              v155 = v156;
            v6 = v153;
            *v26-- = v157;
          }
          while ( v155 );
LABEL_225:
          v9 = sub_53712B8((unsigned __int64)v214, (__int64)v152, v9);
        }
LABEL_226:
        if ( v145 )
        {
          v161 = v9;
          v162 = v145;
          v163 = v133;
          return sub_24EFF44(v161, v162, v163);
        }
      }
      else
      {
        if ( v5 )
        {
          v72 = v5 & 0xFFFFFF;
          if ( v72 )
          {
            do
            {
              v81 = *(_QWORD *)(v9 + 16);
              v82 = v81 + 1;
              if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v81 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v9)(v9);
                v81 = *(_QWORD *)(v9 + 16);
                v82 = v81 + 1;
              }
              v80 = *(_QWORD *)(v9 + 8);
              *(_QWORD *)(v9 + 16) = v82;
              v19 = v72 > 0xFF;
              *(_BYTE *)(v80 + v81) = v72;
              v72 >>= 8;
            }
            while ( v19 );
          }
        }
        v73 = *(_QWORD *)(v9 + 16);
        if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v73 + v15)
          || (v74 = *(_QWORD *)(v9 + 8), *(_QWORD *)(v9 + 16) = v73 + v15, !v74) )
        {
          v96 = (char *)v214 + v15;
          do
          {
            *((_QWORD *)&v98 + 1) = v7;
            *(_QWORD *)&v98 = v6;
            v97 = v98 >> 1;
            v99 = v6 > 1;
            v22 = v7 == 0;
            v100 = v7 != 0;
            v7 >>= 1;
            v101 = v6 & 1 | 0x30;
            if ( !v22 )
              v99 = v100;
            v6 = v97;
            *v26-- = v101;
          }
          while ( v99 );
          return sub_53712B8((unsigned __int64)v214, (__int64)v96, v9);
        }
        v75 = (_BYTE *)(v74 + v73 + v15 - 1);
        do
        {
          *((_QWORD *)&v77 + 1) = v7;
          *(_QWORD *)&v77 = v6;
          v76 = v77 >> 1;
          v78 = v6 < 2;
          v79 = v6 & 1 | 0x30;
          if ( v7 )
            v78 = 0;
          v6 = v76;
          v7 >>= 1;
          *v75-- = v79;
        }
        while ( !v78 );
      }
      return v9;
    case 0xF:
      v60 = *a3;
      v61 = v60 != 0;
      v62 = v60 - 1;
      if ( v61 )
        v63 = v62;
      else
        v63 = 0LL;
      v64 = byte_173E2B9[*(_WORD *)((_BYTE *)a3 + 9) & 0xF];
      v65 = v63 >> v64;
      if ( v63 >> v64 )
        v9 = sub_24EFF44(a1, v63 >> v64, (_BYTE *)a3 + 11);
      v66 = *(_QWORD *)(v9 + 16);
      v67 = v63 - v65;
      v68 = v66 + 1;
      if ( *(_QWORD *)(v9 + 24) < (unsigned __int64)(v66 + 1) )
      {
        (**(void (__fastcall ***)(__int64))v9)(v9);
        v66 = *(_QWORD *)(v9 + 16);
        v68 = v66 + 1;
      }
      v69 = *(_QWORD *)(v9 + 8);
      *(_QWORD *)(v9 + 16) = v68;
      *(_BYTE *)(v69 + v66) = v6;
      if ( !v67 )
        return v9;
      return sub_24EFF44(v9, v67, (_BYTE *)a3 + 11);
    default:
      sub_678FF08((__int64)"invalid type specifier");
  }
}


================================================================================
Function: sub_679C180 (0x679C180)
================================================================================

__int64 __fastcall sub_679C180(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        int a5,
        __int64 a6,
        unsigned __int8 *a7)
{
  bool v7; // w9
  unsigned __int64 v10; // x22
  _BYTE *v12; // x24
  unsigned __int64 v13; // x0
  unsigned __int64 v14; // x23
  int v15; // w27
  unsigned __int64 v16; // x25
  unsigned __int64 v17; // x24
  bool v18; // w8
  bool v19; // w8
  __int128 v20; // t2
  bool v21; // w9
  bool v22; // w8
  __int64 v23; // x0
  __int128 v24; // t2
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x1
  bool v27; // w8
  bool v28; // w9
  bool v29; // w8
  unsigned __int64 v30; // x1
  __int128 v31; // t2
  unsigned __int64 v32; // x9
  bool v33; // w10
  __int16 v34; // w8
  bool v35; // w9
  bool v36; // w8
  unsigned __int64 v37; // x9
  bool v38; // zf
  unsigned __int64 v39; // x9
  unsigned __int64 v40; // x13
  int v41; // w9
  unsigned __int8 *v42; // x11
  int v43; // w10
  int v44; // w12
  unsigned __int8 *v45; // x13
  int v46; // w14
  _QWORD v48[4]; // [xsp+8h] [xbp-58h] BYREF
  int v49; // [xsp+28h] [xbp-38h] BYREF
  int v50; // [xsp+2Ch] [xbp-34h] BYREF
  char v51; // [xsp+30h] [xbp-30h] BYREF
  _BYTE v52[7]; // [xsp+31h] [xbp-2Fh] BYREF

  v7 = a3 < 0xA;
  v10 = a3;
  if ( a4 )
    v7 = 0;
  v50 = a5;
  if ( v7 )
  {
    v12 = v52;
    LOBYTE(v13) = a3;
    v49 = 1;
  }
  else
  {
    v14 = a4;
    v15 = 4;
    v16 = a3;
    v17 = a4;
    while ( 1 )
    {
      v18 = v16 > 0x63;
      if ( v17 )
        v18 = 1;
      if ( !v18 )
      {
        v15 -= 2;
        goto LABEL_22;
      }
      v19 = v16 > 0x3E7;
      if ( v17 )
        v19 = 1;
      if ( !v19 )
        break;
      *((_QWORD *)&v20 + 1) = v17;
      *(_QWORD *)&v20 = v16;
      v21 = (unsigned __int64)(v20 >> 4) < 0x271;
      if ( v17 >> 4 )
        v22 = 0;
      else
        v22 = v21;
      if ( v22 )
        goto LABEL_22;
      v23 = sub_67EF95C(v16, v17, 10000LL, 0LL);
      *((_QWORD *)&v24 + 1) = v17;
      *(_QWORD *)&v24 = v16;
      v25 = v17 >> 5;
      v15 += 4;
      v16 = v23;
      v17 = v26;
      v27 = (unsigned __int64)(v24 >> 5) > 0xC34;
      v38 = v25 == 0;
      v28 = v25 != 0;
      if ( !v38 )
        v27 = v28;
      if ( !v27 )
      {
        v15 -= 3;
        goto LABEL_22;
      }
    }
    --v15;
LABEL_22:
    v29 = v10 < 0x64;
    if ( v14 )
      v29 = 0;
    v12 = &v52[v15 - 1];
    v49 = v15;
    if ( v29 )
    {
      v13 = v10;
      v30 = v14;
    }
    else
    {
      do
      {
        v13 = sub_67EF95C(v10, v14, 100LL, 0LL);
        *((_QWORD *)&v31 + 1) = v14;
        *(_QWORD *)&v31 = v10;
        v32 = v10 - 100 * v13;
        v10 = v13;
        v33 = (unsigned __int64)(v31 >> 4) > 0x270;
        v34 = *(_WORD *)&a00010203040506_1[2 * v32];
        v35 = v14 >> 4 != 0;
        if ( !(v14 >> 4) )
          v35 = v33;
        v14 = v30;
        *((_WORD *)v12 - 1) = v34;
        v12 -= 2;
      }
      while ( v35 );
    }
    v36 = v13 > 9;
    if ( v30 )
      v36 = 1;
    if ( v36 )
    {
      *((_WORD *)v12 - 1) = *(_WORD *)&a00010203040506_1[2 * v13];
      goto LABEL_35;
    }
  }
  *(v12 - 1) = v13 + 48;
LABEL_35:
  v37 = *a7;
  v38 = (v37 & 1) == 0;
  v39 = v37 >> 1;
  if ( v38 )
    v40 = v39;
  else
    v40 = *((_QWORD *)a7 + 1);
  v41 = v49;
  if ( v38 )
    v42 = a7 + 1;
  else
    v42 = (unsigned __int8 *)*((_QWORD *)a7 + 2);
  v43 = 0;
  if ( a7[24] )
  {
    v44 = 0;
    v45 = &v42[v40];
    if ( v45 == v42 )
      goto LABEL_45;
LABEL_43:
    v46 = *v42;
    if ( (unsigned int)(v46 - 127) >= 0xFFFFFF82 )
    {
      ++v42;
      while ( 1 )
      {
        v44 += v46;
        if ( v44 >= v49 )
          break;
        ++v43;
        if ( v45 != v42 )
          goto LABEL_43;
LABEL_45:
        v46 = (char)*(v45 - 1);
      }
    }
  }
  if ( v50 )
    v41 = v49 + 1;
  v48[0] = &v50;
  v48[1] = a7;
  v48[2] = &v51;
  v48[3] = &v49;
  return sub_679C424(a1, a6, (unsigned int)(v41 + v43), (unsigned int)(v41 + v43), v48);
}


================================================================================
Function: sub_679C424 (0x679C424)
================================================================================

__int64 __fastcall sub_679C424(__int64 a1, unsigned int *a2, __int64 a3, unsigned __int64 a4, int **a5)
{
  unsigned __int64 v5; // x10
  __int64 v7; // x21
  _BYTE *v8; // x19
  char v9; // w8
  unsigned __int64 v10; // x24
  unsigned __int64 v11; // x22
  __int64 v12; // x22
  int v13; // w23
  __int64 v14; // x8
  __int64 v15; // x1
  __int64 v16; // x9
  __int64 result; // x0

  v5 = *a2;
  v7 = a1;
  v8 = (char *)a2 + 11;
  v9 = byte_173E2B4[*(_WORD *)((_BYTE *)a2 + 9) & 0xF];
  if ( v5 >= a4 )
    v10 = v5 - a4;
  else
    v10 = 0LL;
  v11 = v10 >> v9;
  if ( v10 >> v9 )
    v7 = sub_24EFF44(a1, v10 >> v9, v8);
  v12 = v10 - v11;
  v13 = **a5;
  if ( v13 )
  {
    v14 = *(_QWORD *)(v7 + 16);
    v15 = v14 + 1;
    if ( *(_QWORD *)(v7 + 24) < (unsigned __int64)(v14 + 1) )
    {
      (**(void (__fastcall ***)(__int64))v7)(v7);
      v14 = *(_QWORD *)(v7 + 16);
      v15 = v14 + 1;
    }
    v16 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 16) = v15;
    *(_BYTE *)(v16 + v14) = v13;
  }
  result = sub_5370F24((unsigned __int8 *)a5[1], v7, (char *)a5[2], *a5[3]);
  if ( v12 )
    return sub_24EFF44(result, v12, v8);
  return result;
}


================================================================================
Function: sub_679C50C (0x679C50C)
================================================================================

__int64 __fastcall sub_679C50C(__int64 a1, __int64 a2)
{
  unsigned int v4; // w21
  __int64 i; // x21
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  unsigned __int64 v13; // x21
  unsigned __int64 v14; // x22
  __int64 v15; // x8
  bool v16; // w9
  _BYTE *v17; // x20
  _BYTE *v18; // x25
  unsigned __int64 v19; // x0
  unsigned __int64 v20; // x1
  __int128 v21; // t2
  unsigned __int64 v22; // x9
  bool v23; // w10
  __int16 v24; // w8
  bool v25; // w9
  bool v26; // w8
  _BYTE v28[40]; // [xsp+0h] [xbp-30h] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v14 = *(_QWORD *)(a1 + 32);
  v13 = *(_QWORD *)(a1 + 40);
  v15 = *(int *)(a1 + 48);
  v16 = v14 < 0x64;
  if ( v13 )
    v16 = 0;
  v17 = &v28[v15];
  if ( v16 )
  {
    v18 = &v28[v15];
    v19 = v14;
    v20 = v13;
  }
  else
  {
    v18 = &v28[v15];
    do
    {
      v19 = sub_67EF95C(v14, v13, 100LL, 0LL);
      *((_QWORD *)&v21 + 1) = v13;
      *(_QWORD *)&v21 = v14;
      v22 = v14 - 100 * v19;
      v14 = v19;
      v23 = (unsigned __int64)(v21 >> 4) > 0x270;
      v24 = *(_WORD *)&a00010203040506_1[2 * v22];
      v25 = v13 >> 4 != 0;
      if ( !(v13 >> 4) )
        v25 = v23;
      v13 = v20;
      *((_WORD *)v18 - 1) = v24;
      v18 -= 2;
    }
    while ( v25 );
  }
  v26 = v19 > 9;
  if ( v20 )
    v26 = 1;
  if ( v26 )
    *((_WORD *)v18 - 1) = *(_WORD *)&a00010203040506_1[2 * v19];
  else
    *(v18 - 1) = v19 + 48;
  return sub_53712B8((unsigned __int64)v28, (__int64)v17, a2);
}


================================================================================
Function: sub_679C6DC (0x679C6DC)
================================================================================

__int64 __fastcall sub_679C6DC(__int64 a1, __int64 a2)
{
  unsigned int v4; // w22
  __int64 i; // x22
  __int64 v6; // x9
  bool v7; // cf
  __int64 v8; // x8
  __int64 v9; // x1
  __int64 v10; // x9
  __int64 v11; // x8
  __int64 v12; // x1
  __int64 v13; // x12
  __int64 v14; // x11
  unsigned __int64 v15; // x8
  unsigned __int64 v16; // x9
  __int64 v17; // x10
  unsigned __int64 v18; // x14
  int v19; // w11
  __int64 v20; // x13
  bool v21; // zf
  __int64 v22; // x11
  const char *v23; // x10
  char *v24; // x11
  unsigned __int64 v25; // x12
  bool v26; // w14
  __int128 v27; // t2
  char v28; // w12
  _BYTE *v29; // x1
  char *v30; // x11
  const char *v31; // x10
  unsigned __int64 v32; // x12
  bool v33; // w13
  bool v34; // w14
  __int128 v35; // t2
  char v36; // w12
  _BYTE v38[36]; // [xsp+4h] [xbp-2Ch] BYREF

  v4 = *(_DWORD *)a1 & 0xFFFFFF;
  if ( v4 )
  {
    do
    {
      v8 = *(_QWORD *)(a2 + 16);
      v9 = v8 + 1;
      if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v8 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a2)(a2);
        v8 = *(_QWORD *)(a2 + 16);
        v9 = v8 + 1;
      }
      v6 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 16) = v9;
      v7 = v4 >= 0x100;
      *(_BYTE *)(v6 + v8) = v4;
      v4 >>= 8;
    }
    while ( v7 );
  }
  for ( i = *(_QWORD *)(a1 + 16); i; *(_BYTE *)(v10 + v11) = 48 )
  {
    v11 = *(_QWORD *)(a2 + 16);
    v12 = v11 + 1;
    if ( *(_QWORD *)(a2 + 24) < (unsigned __int64)(v11 + 1) )
    {
      (**(void (__fastcall ***)(__int64))a2)(a2);
      v11 = *(_QWORD *)(a2 + 16);
      v12 = v11 + 1;
    }
    --i;
    v10 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 16) = v12;
  }
  v13 = *(_QWORD *)(a2 + 16);
  v14 = *(unsigned int *)(a1 + 48);
  v16 = *(_QWORD *)(a1 + 32);
  v15 = *(_QWORD *)(a1 + 40);
  v17 = (int)v14;
  v18 = v13 + v14;
  v19 = *(unsigned __int8 *)(a1 + 52);
  if ( *(_QWORD *)(a2 + 24) >= v18 && (v20 = *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16) = v18, v20) )
  {
    v21 = v19 == 0;
    v22 = v13 + v17 + v20;
    if ( v21 )
      v23 = "0123456789abcdef";
    else
      v23 = "0123456789ABCDEF";
    v24 = (char *)(v22 - 1);
    do
    {
      v25 = v16 & 0xF;
      v26 = v16 < 0x10;
      *((_QWORD *)&v27 + 1) = v15;
      *(_QWORD *)&v27 = v16;
      v16 = v27 >> 4;
      v28 = v23[v25];
      if ( v15 )
        v26 = 0;
      v15 >>= 4;
      *v24-- = v28;
    }
    while ( !v26 );
  }
  else
  {
    v29 = &v38[v17];
    v21 = v19 == 0;
    v30 = &v38[v17 - 1];
    if ( v21 )
      v31 = "0123456789abcdef";
    else
      v31 = "0123456789ABCDEF";
    do
    {
      v32 = v16 & 0xF;
      v33 = v16 > 0xF;
      v21 = v15 == 0;
      v34 = v15 != 0;
      *((_QWORD *)&v35 + 1) = v15;
      *(_QWORD *)&v35 = v16;
      v16 = v35 >> 4;
      v36 = v31[v32];
      v15 >>= 4;
      if ( !v21 )
        v33 = v34;
      *v30-- = v36;
    }
    while ( v33 );
    return sub_53712B8((unsigned __int64)v38, (__int64)v29, a2);
  }
  return a2;
}


================================================================================
Function: sub_679C8C0 (0x679C8C0)
================================================================================

__int64 __fastcall sub_679C8C0(__int64 a1, _UNKNOWN **a2, _BYTE *a3, __int64 *a4, float a5)
{
  __int64 v8; // x0
  unsigned int v9; // w21
  unsigned int v10; // w9
  int v11; // w10
  unsigned int v12; // w25
  float v13; // s0
  const char *v14; // x10
  const char *v15; // x9
  __int64 v16; // x2
  __int64 v17; // x19
  __int64 v18; // x8
  char v19; // w22
  __int64 v20; // x1
  __int64 v21; // x9
  char v22; // w8
  __int64 v23; // x0
  bool v24; // cc
  unsigned int v25; // w22
  _BYTE *v27; // [xsp+0h] [xbp-250h] BYREF
  __int64 v28; // [xsp+8h] [xbp-248h]
  _UNKNOWN **v29; // [xsp+10h] [xbp-240h] BYREF
  _BYTE *v30; // [xsp+18h] [xbp-238h]
  __int128 v31; // [xsp+20h] [xbp-230h]
  _BYTE v32[504]; // [xsp+30h] [xbp-220h] BYREF
  _UNKNOWN **v33; // [xsp+228h] [xbp-28h] BYREF
  unsigned __int64 v34; // [xsp+230h] [xbp-20h]

  v33 = a2;
  v34 = (unsigned __int64)a3;
  v8 = sub_67972A4((__int64)&v33);
  v9 = v8;
  v10 = HIDWORD(v8) & 0xFFFF00FF;
  if ( (LODWORD(a5) & 0x80000000) != 0 )
  {
    a5 = -a5;
    v12 = v10 | 0x100;
  }
  else
  {
    v11 = (16 * *(unsigned __int16 *)((char *)&v34 + 1)) & 0x700;
    if ( v11 == 256 )
      v11 = 0;
    v12 = v10 | v11;
  }
  v13 = fabsf(a5);
  if ( v13 < INFINITY || v13 > INFINITY )
  {
    if ( (BYTE1(v34) & 0xF) == 4 && (v12 & 0xFF00) != 0 )
    {
      v18 = *(_QWORD *)(a1 + 16);
      v19 = byte_173E2BE[BYTE1(v12)];
      v20 = v18 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v18 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v18 = *(_QWORD *)(a1 + 16);
        v20 = v18 + 1;
      }
      v21 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v20;
      v12 &= 0xFFFF00FF;
      *(_BYTE *)(v21 + v18) = v19;
      if ( (_DWORD)v33 )
        LODWORD(v33) = (_DWORD)v33 - 1;
    }
    v29 = &off_6BE0B98;
    v30 = v32;
    v31 = xmmword_AFDC90;
    if ( (unsigned __int8)v12 == 3 )
    {
      if ( (v12 & 0xFF00) != 0 )
      {
        v22 = byte_173E2BE[BYTE1(v12)];
        *(_QWORD *)&v31 = 1LL;
        v32[0] = v22;
      }
      sub_6791430(HIDWORD(v33), v9 | ((unsigned __int64)v12 << 32), &v29, a5);
      v27 = v30;
      v28 = v31;
      v23 = sub_679735C(a1, (unsigned int *)&v33, v31, v31, (unsigned __int64 *)&v27);
    }
    else
    {
      if ( (_BYTE)v34 )
        v24 = SHIDWORD(v33) <= -1;
      else
        v24 = 0;
      if ( v24 )
        v25 = 6;
      else
        v25 = HIDWORD(v33);
      if ( (unsigned __int8)v12 == 1 )
      {
        if ( v25 == 0x7FFFFFFF )
          sub_678FF08((__int64)"number is too big");
        ++v25;
      }
      v27 = v30;
      LODWORD(v28) = v31;
      HIDWORD(v28) = sub_6791AC0(v25);
      v23 = sub_6797560(a1, (__int64)&v27, (unsigned int *)&v33, ((unsigned __int64)(v12 | 0x40000) << 32) | v25, a4);
    }
    v17 = v23;
    if ( v30 != v32 )
      sub_6575460();
  }
  else
  {
    v29 = v33;
    v30 = (_BYTE *)v34;
    if ( (v34 & 0xFF000000FF000000LL) == 0x100000030000000LL )
      BYTE3(v30) = 32;
    v14 = "INF";
    if ( (v12 & 0x10000) == 0 )
      v14 = "inf";
    v15 = "NAN";
    if ( (v12 & 0x10000) == 0 )
      v15 = "nan";
    LODWORD(v27) = BYTE1(v12);
    if ( v13 == INFINITY )
      v15 = v14;
    if ( BYTE1(v12) )
      v16 = 4LL;
    else
      v16 = 3LL;
    v28 = (__int64)v15;
    return sub_67946E0(a1, (unsigned int *)&v29, v16, v16, (unsigned int *)&v27);
  }
  return v17;
}


================================================================================
Function: sub_679CBE8 (0x679CBE8)
================================================================================

__int64 __fastcall sub_679CBE8(__int64 a1, _UNKNOWN **a2, _BYTE *a3, __int64 *a4, double a5)
{
  __int64 v8; // x0
  unsigned int v9; // w21
  unsigned int v10; // w9
  int v11; // w10
  __int64 v12; // x24
  double v13; // d0
  const char *v14; // x10
  const char *v15; // x9
  __int64 v16; // x2
  __int64 v17; // x19
  __int64 v18; // x8
  char v19; // w22
  __int64 v20; // x1
  __int64 v21; // x9
  char v22; // w8
  __int64 v23; // x0
  bool v24; // cc
  unsigned int v25; // w22
  _BYTE *v27; // [xsp+0h] [xbp-250h] BYREF
  __int64 v28; // [xsp+8h] [xbp-248h]
  _UNKNOWN **v29; // [xsp+10h] [xbp-240h] BYREF
  _BYTE *v30; // [xsp+18h] [xbp-238h]
  __int128 v31; // [xsp+20h] [xbp-230h]
  _BYTE v32[504]; // [xsp+30h] [xbp-220h] BYREF
  _UNKNOWN **v33; // [xsp+228h] [xbp-28h] BYREF
  unsigned __int64 v34; // [xsp+230h] [xbp-20h]

  v33 = a2;
  v34 = (unsigned __int64)a3;
  v8 = sub_67972A4((__int64)&v33);
  v9 = v8;
  v10 = HIDWORD(v8) & 0xFFFF00FF;
  if ( (*(_QWORD *)&a5 & 0x8000000000000000LL) != 0 )
  {
    a5 = -a5;
    v12 = v10 | 0x100;
  }
  else
  {
    v11 = (16 * *(unsigned __int16 *)((char *)&v34 + 1)) & 0x700;
    if ( v11 == 256 )
      v11 = 0;
    v12 = v10 | v11;
  }
  v13 = fabs(a5);
  if ( v13 < INFINITY || v13 > INFINITY )
  {
    if ( (BYTE1(v34) & 0xF) == 4 && (v12 & 0xFF00) != 0 )
    {
      v18 = *(_QWORD *)(a1 + 16);
      v19 = byte_173E2BE[BYTE1(v12)];
      v20 = v18 + 1;
      if ( *(_QWORD *)(a1 + 24) < (unsigned __int64)(v18 + 1) )
      {
        (**(void (__fastcall ***)(__int64))a1)(a1);
        v18 = *(_QWORD *)(a1 + 16);
        v20 = v18 + 1;
      }
      v21 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = v20;
      v12 = (unsigned int)v12 & 0xFFFF00FF;
      *(_BYTE *)(v21 + v18) = v19;
      if ( (_DWORD)v33 )
        LODWORD(v33) = (_DWORD)v33 - 1;
    }
    v29 = &off_6BE0B98;
    v30 = v32;
    v31 = xmmword_AFDC90;
    if ( (unsigned __int8)v12 == 3 )
    {
      if ( (v12 & 0xFF00) != 0 )
      {
        v22 = byte_173E2BE[BYTE1(v12)];
        *(_QWORD *)&v31 = 1LL;
        v32[0] = v22;
      }
      sub_6791430(HIDWORD(v33), v9 | ((unsigned __int64)(unsigned int)v12 << 32), &v29, a5);
      v27 = v30;
      v28 = v31;
      v23 = sub_679735C(a1, (unsigned int *)&v33, v31, v31, (unsigned __int64 *)&v27);
    }
    else
    {
      if ( (_BYTE)v34 )
        v24 = SHIDWORD(v33) <= -1;
      else
        v24 = 0;
      if ( v24 )
        v25 = 6;
      else
        v25 = HIDWORD(v33);
      if ( (unsigned __int8)v12 == 1 )
      {
        if ( v25 == 0x7FFFFFFF )
          sub_678FF08((__int64)"number is too big");
        ++v25;
      }
      v27 = v30;
      LODWORD(v28) = v31;
      HIDWORD(v28) = sub_6791AC0(v25);
      v23 = sub_6797560(a1, (__int64)&v27, (unsigned int *)&v33, (v12 << 32) | v25, a4);
    }
    v17 = v23;
    if ( v30 != v32 )
      sub_6575460();
  }
  else
  {
    v29 = v33;
    v30 = (_BYTE *)v34;
    if ( (v34 & 0xFF000000FF000000LL) == 0x100000030000000LL )
      BYTE3(v30) = 32;
    v14 = "INF";
    if ( (v12 & 0x10000) == 0 )
      v14 = "inf";
    v15 = "NAN";
    if ( (v12 & 0x10000) == 0 )
      v15 = "nan";
    LODWORD(v27) = BYTE1(v12);
    if ( v13 == INFINITY )
      v15 = v14;
    if ( BYTE1(v12) )
      v16 = 4LL;
    else
      v16 = 3LL;
    v28 = (__int64)v15;
    return sub_67946E0(a1, (unsigned int *)&v29, v16, v16, (unsigned int *)&v27);
  }
  return v17;
}


================================================================================
Function: sub_679CF0C (0x679CF0C)
================================================================================

__int64 __usercall sub_679CF0C@<X0>(__int64 a1@<X0>, int a2@<W1>, int a3@<W8>)
{
  unsigned int v4; // w8
  unsigned int v5; // w10
  unsigned __int64 v6; // x8
  uint32x4_t *v7; // x9
  unsigned int v8; // w11
  unsigned __int64 v9; // x12
  unsigned __int32 v10; // w20
  int8x16_t v11; // q0
  uint32x4_t *v12; // x13
  uint32x4_t v13; // q1
  unsigned __int64 v14; // x14
  uint32x4_t v15; // q2
  uint32x4_t v16; // q3
  int8x16_t v17; // q6
  int8x16_t v18; // q5
  int32x4_t v19; // q4
  unsigned __int64 v20; // x13
  unsigned __int32 *v21; // x12
  unsigned __int32 v22; // w14
  unsigned __int32 v23; // w15
  unsigned __int64 v24; // x1

  v4 = a3 & 0xFFFFFFE0;
  v5 = a2 - v4;
  *(_DWORD *)(a1 + 168) += a2 / 32;
  if ( a2 == v4 )
    return a1;
  v6 = *(_QWORD *)(a1 + 16);
  if ( !v6 )
    return a1;
  v7 = *(uint32x4_t **)(a1 + 8);
  v8 = 32 - v5;
  if ( v6 < 8 )
  {
    v9 = 0LL;
    v10 = 0;
LABEL_8:
    v20 = v6 - v9;
    v21 = (unsigned __int32 *)v7 + v9;
    v22 = v10;
    do
    {
      --v20;
      v10 = *v21 >> v8;
      v23 = (*v21 << v5) + v22;
      v22 = v10;
      *v21++ = v23;
    }
    while ( v20 );
    goto LABEL_10;
  }
  v9 = v6 & 0xFFFFFFFFFFFFFFF8LL;
  v11 = 0uLL;
  v12 = v7 + 1;
  v13 = vnegq_s32(vdupq_n_s32(v8));
  v14 = v6 & 0xFFFFFFFFFFFFFFF8LL;
  v15 = vdupq_n_s32(v5);
  do
  {
    v16 = v12[-1];
    v17 = v11;
    v14 -= 8LL;
    v18 = vshlq_u32(v16, v13);
    v11 = vshlq_u32(*v12, v13);
    v19 = vaddq_s32(vshlq_u32(*v12, v15), vextq_s8(v18, v11, 0xCuLL));
    v12[-1] = vaddq_s32(vshlq_u32(v16, v15), vextq_s8(v17, v18, 0xCuLL));
    *v12 = v19;
    v12 += 2;
  }
  while ( v14 );
  v10 = v11.n128_u32[3];
  if ( v6 != v9 )
    goto LABEL_8;
LABEL_10:
  if ( v10 )
  {
    v24 = v6 + 1;
    if ( *(_QWORD *)(a1 + 24) < v6 + 1 )
    {
      (**(void (__fastcall ***)(__int64))a1)(a1);
      v7 = *(uint32x4_t **)(a1 + 8);
      v6 = *(_QWORD *)(a1 + 16);
      v24 = v6 + 1;
    }
    *(_QWORD *)(a1 + 16) = v24;
    v7->n128_u32[v6] = v10;
  }
  return a1;
}


================================================================================
Function: sub_679D038 (0x679D038)
================================================================================

__int64 __fastcall sub_679D038(__int64 result, int a2)
{
  __int64 v2; // x19
  int v4; // w8
  int v5; // w21
  __int64 v6; // x10
  __int64 v7; // x8
  __int64 v8; // x8
  int v9; // w21
  bool v10; // cc
  __int64 v11; // x8
  __int64 v12; // x10
  unsigned __int64 v13; // x22
  __int64 v14; // x9
  __int64 v15; // x11
  unsigned __int64 v16; // x12
  __int64 v17; // x1

  v2 = result;
  if ( a2 )
  {
    v4 = 1;
    do
    {
      v5 = v4;
      v4 *= 2;
    }
    while ( v5 <= a2 );
    v6 = *(_QWORD *)(result + 24);
    **(_DWORD **)(result + 8) = 5;
    if ( v6 )
    {
      v7 = 1LL;
    }
    else
    {
      (**(void (__fastcall ***)(__int64, __int64))result)(result, 1LL);
      v7 = *(_QWORD *)(v2 + 24) != 0LL;
    }
    *(_QWORD *)(v2 + 16) = v7;
    *(_DWORD *)(v2 + 168) = 0;
    if ( (unsigned int)v5 >= 4 )
    {
      v9 = v5 >> 2;
      do
      {
        sub_679D638(v2);
        if ( (v9 & a2) != 0 )
        {
          v11 = *(_QWORD *)(v2 + 16);
          if ( v11 )
          {
            v12 = 0LL;
            v13 = 0LL;
            v14 = *(_QWORD *)(v2 + 8);
            do
            {
              v15 = 4 * v12++;
              v16 = 5LL * *(unsigned int *)(v14 + v15) + v13;
              v13 = HIDWORD(v16);
              *(_DWORD *)(v14 + v15) = v16;
            }
            while ( v11 != v12 );
            if ( HIDWORD(v16) )
            {
              v17 = v11 + 1;
              if ( *(_QWORD *)(v2 + 24) < (unsigned __int64)(v11 + 1) )
              {
                (**(void (__fastcall ***)(__int64))v2)(v2);
                v14 = *(_QWORD *)(v2 + 8);
                v11 = *(_QWORD *)(v2 + 16);
                v17 = v11 + 1;
              }
              *(_QWORD *)(v2 + 16) = v17;
              *(_DWORD *)(v14 + 4 * v11) = v13;
            }
          }
        }
        LODWORD(v7) = v9 >> 1;
        v10 = (unsigned int)v9 > 1;
        v9 >>= 1;
      }
      while ( v10 );
    }
    return sub_679CF0C(v2, a2, v7);
  }
  else
  {
    v8 = *(_QWORD *)(result + 24);
    **(_DWORD **)(result + 8) = 1;
    if ( !v8 )
    {
      result = (**(__int64 (__fastcall ***)(__int64, __int64))result)(result, 1LL);
      v8 = *(_QWORD *)(v2 + 24);
    }
    *(_DWORD *)(v2 + 168) = 0;
    *(_QWORD *)(v2 + 16) = v8 != 0;
  }
  return result;
}


================================================================================
Function: sub_679D1A8 (0x679D1A8)
================================================================================

__int64 __fastcall sub_679D1A8(__int64 a1, __int64 a2)
{
  __int64 v2; // x24
  int v4; // w10
  __int64 v6; // x9
  int v7; // w11
  int v8; // w8
  unsigned int v9; // w12
  int v10; // w13
  int v11; // w17
  unsigned int v12; // w1
  unsigned int v13; // w0
  int v14; // w22
  __int64 v15; // x23
  unsigned __int64 v16; // x8
  unsigned __int64 v17; // x21
  char *v18; // x0
  __int64 v19; // x9
  __int64 v20; // x10
  char *v21; // x13
  char *v22; // x14
  __int64 v23; // x11
  char *v24; // x13
  __int64 v25; // x12
  char *v26; // x14
  __int64 v27; // x15
  __int128 v28; // q0
  __int128 v29; // q1
  __int64 v30; // x10
  int v31; // w11
  unsigned int v32; // w21
  __int64 v34; // x12
  __int64 v35; // x14
  unsigned int *v36; // x13
  __int64 v37; // x10
  __int64 v38; // x11
  __int64 v39; // x15
  unsigned int v40; // t1
  __int64 v41; // x11
  __int64 v42; // x9
  __int64 v43; // x11
  __int64 v44; // x9
  unsigned __int64 v46; // x9
  unsigned __int64 v47; // x22
  int v48; // w13
  unsigned int v49; // w14
  int v50; // w12
  int v51; // w15
  int v52; // w17
  unsigned int v53; // w2
  unsigned int v54; // w1

  v2 = *(_QWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 168);
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_DWORD *)(a2 + 168);
  if ( v4 + (_DWORD)v2 != v7 + (_DWORD)v6 )
  {
    if ( v4 + (int)v2 > v7 + (int)v6 )
      goto LABEL_7;
    return 0;
  }
  v8 = v2 - 1;
  v9 = v6 - 1;
  v10 = (v8 - v9) & ~((int)(v8 - v9) >> 31);
  if ( v10 < (int)v2 )
  {
    v11 = *(_QWORD *)(a1 + 16);
    while ( 1 )
    {
      --v11;
      v12 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4LL * v9);
      v13 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4LL * (unsigned int)v11);
      if ( v13 != v12 )
        break;
      --v9;
      if ( v11 <= v10 )
      {
        if ( v10 - 1 < (int)v6 + ~(_DWORD)v2 + v10 )
          return 0;
        goto LABEL_7;
      }
    }
    if ( v13 <= v12 )
      return 0;
    goto LABEL_7;
  }
  if ( v8 < (int)v9 )
    return 0;
LABEL_7:
  v14 = v4 - v7;
  v15 = (unsigned int)(v4 - v7 - 1);
  if ( v4 - v7 < 1 )
  {
    LODWORD(v16) = v2;
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 24);
    v17 = (unsigned int)(v14 + v2);
    if ( v16 < v17 )
    {
      (**(void (__fastcall ***)(__int64, _QWORD))a1)(a1, (unsigned int)(v14 + v2));
      v16 = *(_QWORD *)(a1 + 24);
    }
    v18 = *(char **)(a1 + 8);
    if ( v16 >= v17 )
      v16 = (unsigned int)(v14 + v2);
    v19 = (unsigned int)(v2 - 1);
    *(_QWORD *)(a1 + 16) = v16;
    if ( (int)v2 < 1 )
      goto LABEL_24;
    v20 = v14 + (int)v19;
    if ( (unsigned int)v19 < 7 )
      goto LABEL_21;
    if ( &v18[4 * v20 + -4 * v19] > &v18[4 * v20] )
      goto LABEL_21;
    if ( v18 > &v18[4 * v19] )
      goto LABEL_21;
    v21 = &v18[4 * v19];
    v22 = &v18[4 * v20];
    if ( &v18[4 * (v20 - v19)] < v21 + 4 && v18 < v22 + 4 )
      goto LABEL_21;
    v23 = v19 + 1;
    v24 = v21 - 12;
    v25 = (v19 + 1) & 0x1FFFFFFF8LL;
    v26 = v22 - 12;
    v19 -= v25;
    v20 -= v25;
    v27 = v25;
    do
    {
      v29 = *((_OWORD *)v24 - 1);
      v28 = *(_OWORD *)v24;
      v27 -= 8LL;
      v24 -= 32;
      *((_OWORD *)v26 - 1) = v29;
      *(_OWORD *)v26 = v28;
      v26 -= 32;
    }
    while ( v27 );
    if ( v23 != v25 )
    {
LABEL_21:
      v30 = 4 * v20;
      do
      {
        v31 = *(_DWORD *)&v18[4 * v19--];
        *(_DWORD *)&v18[v30] = v31;
        v30 -= 4LL;
      }
      while ( v19 != -1 );
    }
    if ( v14 >= 1 )
    {
LABEL_24:
      memset(v18, 0, 4 * v15 + 4);
      LODWORD(v16) = *(_DWORD *)(a1 + 16);
    }
    v4 = *(_DWORD *)(a1 + 168) - v14;
    v6 = *(_QWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 168) = v4;
    v7 = *(_DWORD *)(a2 + 168);
  }
  v32 = 0;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v34 = *(_QWORD *)(a1 + 8);
        if ( v6 )
        {
          v35 = 0LL;
          v36 = *(unsigned int **)(a2 + 8);
          LODWORD(v37) = v7 - v4;
          do
          {
            v38 = (unsigned int)v37;
            v37 = (unsigned int)(v37 + 1);
            v39 = 4 * v38;
            --v6;
            v40 = *v36++;
            v41 = v35 - v40 + *(unsigned int *)(v34 + 4 * v38);
            v35 = v41 >> 63;
            *(_DWORD *)(v34 + v39) = v41;
          }
          while ( v6 );
          v34 = *(_QWORD *)(a1 + 8);
          if ( v41 < 0 )
          {
            LODWORD(v42) = *(_DWORD *)(v34 + 4 * v37);
            v43 = -1LL;
            do
            {
              v42 = v43 + (unsigned int)v42;
              v43 = v42 >> 63;
            }
            while ( v42 < 0 );
            *(_DWORD *)(v34 + 4 * v37) = v42;
            v34 = *(_QWORD *)(a1 + 8);
          }
        }
        v44 = (unsigned int)v16;
        if ( (int)v16 >= 1 )
          LODWORD(v16) = 1;
        while ( (int)v44 >= 2 )
        {
          if ( *(_DWORD *)(v34 - 4 + 4 * v44--) )
          {
            LODWORD(v16) = v44 + 1;
            break;
          }
        }
        v46 = *(_QWORD *)(a1 + 24);
        v47 = (unsigned int)v16;
        if ( v46 < (unsigned int)v16 )
        {
          (**(void (__fastcall ***)(__int64, _QWORD))a1)(a1, (unsigned int)v16);
          v46 = *(_QWORD *)(a1 + 24);
        }
        v4 = *(_DWORD *)(a1 + 168);
        v16 = v46 >= v47 ? v47 : v46;
        v7 = *(_DWORD *)(a2 + 168);
        ++v32;
        *(_QWORD *)(a1 + 16) = v16;
        v6 = *(_QWORD *)(a2 + 16);
        if ( v4 + (_DWORD)v16 == v7 + (_DWORD)v6 )
          break;
        if ( v4 + (int)v16 <= v7 + (int)v6 )
          return v32;
      }
      v48 = v16 - 1;
      v49 = v6 - 1;
      v50 = v16;
      v51 = (v48 - v49) & ~((int)(v48 - v49) >> 31);
      if ( v51 >= (int)v16 )
        break;
      v48 = v51 - 1;
      v52 = v6 + ~(_DWORD)v16 + v51;
      while ( 1 )
      {
        --v50;
        v53 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4LL * v49);
        v54 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4LL * (unsigned int)v50);
        if ( v54 != v53 )
          break;
        --v49;
        if ( v50 <= v51 )
          goto LABEL_58;
      }
      if ( v54 <= v53 )
        return v32;
    }
    v52 = v6 - 1;
LABEL_58:
    ;
  }
  while ( v48 >= v52 );
  return v32;
}


================================================================================
Function: sub_679D638 (0x679D638)
================================================================================

uint32x4_t *__fastcall sub_679D638(__int64 a1)
{
  __int64 v2; // x22
  unsigned __int64 v3; // x20
  unsigned __int64 v4; // x2
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x9
  __int64 v7; // x10
  unsigned __int64 v8; // x14
  unsigned __int64 v9; // x13
  unsigned __int64 v10; // x12
  __int64 v11; // x15
  __int64 v12; // x17
  __int128 v13; // t2
  unsigned __int64 v14; // x1
  unsigned __int64 v15; // x24
  unsigned __int64 v16; // x23
  unsigned __int64 v17; // x7
  unsigned __int64 v18; // x6
  unsigned __int64 v19; // x5
  unsigned __int64 v20; // x4
  unsigned __int64 v21; // x25
  int32x4_t *v22; // x26
  uint32x4_t *v23; // x21
  int32x4_t v24; // t1
  int32x4_t v25; // q0
  uint32x4_t v26; // t1
  int8x16_t v27; // q0
  uint32x4_t v28; // q0
  uint64x2_t v29; // q2
  uint64x2_t v30; // q0
  unsigned __int64 v31; // kr00_8
  unsigned __int64 v32; // kr10_8
  unsigned __int64 v33; // kr20_8
  unsigned __int64 v34; // kr30_8
  __int64 v35; // x3
  __int64 v36; // x4
  int v37; // w14
  int v38; // w3
  unsigned int v39; // w0
  unsigned int v40; // w1
  __int128 v41; // t2
  __int64 v42; // x4
  __int64 v43; // x5
  __int64 v44; // x4
  __int64 v45; // x23
  __int64 v46; // x26
  unsigned __int64 v47; // x27
  unsigned __int64 v48; // x25
  unsigned __int64 v49; // x24
  unsigned __int64 v50; // x20
  unsigned __int64 v51; // x7
  unsigned __int64 v52; // x6
  __int64 v53; // x28
  int32x4_t *v54; // x30
  uint32x4_t *v55; // x21
  int32x4_t v56; // t1
  int32x4_t v57; // q0
  uint32x4_t v58; // t1
  int8x16_t v59; // q0
  uint32x4_t v60; // q0
  uint64x2_t v61; // q2
  uint64x2_t v62; // q0
  unsigned __int64 v63; // kr60_8
  unsigned __int64 v64; // kr70_8
  unsigned __int64 v65; // kr80_8
  unsigned __int64 v66; // kr90_8
  unsigned int *v67; // x3
  unsigned int *v68; // x5
  int v69; // w4
  __int64 v70; // x8
  unsigned int v71; // t1
  unsigned int v72; // t1
  __int64 v73; // x10
  unsigned int v74; // w11
  unsigned __int64 v76; // x9
  unsigned __int64 v77; // x20
  int v78; // w8
  uint32x4_t *result; // x0
  unsigned __int64 v80; // [xsp+8h] [xbp-C8h]
  char v81[8]; // [xsp+18h] [xbp-B8h] BYREF
  uint32x4_t *v82; // [xsp+20h] [xbp-B0h]
  __int64 v83; // [xsp+38h] [xbp-98h] BYREF

  v2 = *(_QWORD *)(a1 + 16);
  v3 = (unsigned int)(2 * v2);
  sub_679DA50(v81, a1);
  v5 = *(_QWORD *)(a1 + 24);
  if ( v5 < v3 )
  {
    (**(void (__fastcall ***)(__int64, _QWORD))a1)(a1, (unsigned int)(2 * v2));
    v5 = *(_QWORD *)(a1 + 24);
  }
  if ( v5 >= v3 )
    v6 = (unsigned int)(2 * v2);
  else
    v6 = v5;
  v7 = *(_QWORD *)(a1 + 8);
  v80 = v5;
  *(_QWORD *)(a1 + 16) = v6;
  if ( (int)v2 < 1 )
  {
    v9 = 0LL;
    v10 = 0LL;
    if ( (int)v3 <= (int)v2 )
      goto LABEL_32;
    goto LABEL_20;
  }
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = -3LL;
  v12 = 1LL;
  do
  {
    if ( v8 < 3 )
    {
      v14 = 0LL;
      v4 = v8;
LABEL_14:
      v4 *= 4LL;
      do
      {
        v35 = v82->n128_u32[v14++];
        v36 = *(unsigned int *)((char *)v82->n128_u32 + v4);
        v4 -= 4LL;
        v10 = (__PAIR128__(v10, v9) + (unsigned __int64)(v36 * v35)) >> 64;
        v9 += v36 * v35;
      }
      while ( v12 != v14 );
      goto LABEL_8;
    }
    v15 = 0LL;
    v14 = (v8 + 1) & 0xFFFFFFFFFFFFFFFCLL;
    v16 = 0LL;
    v17 = 0LL;
    v18 = 0LL;
    v19 = 0LL;
    v20 = 0LL;
    v21 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    v4 = v8 - v14;
    v22 = (uint32x4_t *)((char *)v82 + 4 * v11);
    v23 = v82;
    do
    {
      v24 = *v22--;
      v25 = v24;
      v26 = *v23++;
      v27 = vrev64q_s32(v25);
      v28 = vextq_s8(v27, v27, 8uLL);
      v29 = vmull_u32((uint32x2_t)v28.n128_u64[0], (uint32x2_t)v26.n128_u64[0]);
      v30 = vmull_high_u32(v28, v26);
      v31 = v9 + v29.n128_u64[0];
      v10 = (__PAIR128__(v10, v9) + v29.n128_u64[0]) >> 64;
      v9 += v29.n128_u64[0];
      v32 = v17 + v30.n128_u64[0];
      v18 = (__PAIR128__(v18, v17) + v30.n128_u64[0]) >> 64;
      v17 += v30.n128_u64[0];
      v33 = v19 + v30.n128_u64[1];
      v20 = (__PAIR128__(v20, v19) + v30.n128_u64[1]) >> 64;
      v19 += v30.n128_u64[1];
      v34 = v15 + v29.n128_u64[1];
      v16 = (__PAIR128__(v16, v15) + v29.n128_u64[1]) >> 64;
      v15 += v29.n128_u64[1];
      v21 -= 4LL;
    }
    while ( v21 );
    v10 = (__PAIR128__(v10, v31) + __PAIR128__(v16, v34) + __PAIR128__(v18, v32) + __PAIR128__(v20, v33)) >> 64;
    v9 = v31 + v34 + v32 + v33;
    if ( v8 + 1 != v14 )
      goto LABEL_14;
LABEL_8:
    *(_DWORD *)(v7 + 4 * v8) = v9;
    *((_QWORD *)&v13 + 1) = v10;
    *(_QWORD *)&v13 = v9;
    v9 = v13 >> 32;
    v10 >>= 32;
    ++v8;
    ++v12;
    ++v11;
  }
  while ( v8 != (unsigned int)v2 );
  v7 = *(_QWORD *)(a1 + 8);
  if ( (int)v3 > (int)v2 )
  {
LABEL_20:
    v37 = 0;
    v38 = 1;
    v39 = v2 - 2;
    v40 = v2;
    while ( 1 )
    {
      v4 = v38;
      if ( (int)(v40 - (v2 - 1)) < (int)v2 )
      {
        v42 = (unsigned int)(v2 - 2 - v37);
        if ( (unsigned int)v42 >= 3 )
        {
          v45 = v42 + 1;
          v46 = (v42 + 1) & 0x1FFFFFFFCLL;
          v47 = 0LL;
          v48 = 0LL;
          v49 = 0LL;
          v50 = 0LL;
          v51 = 0LL;
          v52 = 0LL;
          v53 = (v39 + 1LL) & 0x1FFFFFFFCLL;
          v43 = (int)v2 - v46;
          v44 = v46 + v38;
          v54 = (uint32x4_t *)((char *)v82 + 4 * (int)v2 - 16);
          v55 = (uint32x4_t *)((char *)v82 + 4 * v38);
          do
          {
            v56 = *v54--;
            v57 = v56;
            v58 = *v55++;
            v59 = vrev64q_s32(v57);
            v60 = vextq_s8(v59, v59, 8uLL);
            v61 = vmull_u32((uint32x2_t)v60.n128_u64[0], (uint32x2_t)v58.n128_u64[0]);
            v62 = vmull_high_u32(v60, v58);
            v63 = v9 + v61.n128_u64[0];
            v10 = (__PAIR128__(v10, v9) + v61.n128_u64[0]) >> 64;
            v64 = v49 + v62.n128_u64[0];
            v50 = (__PAIR128__(v50, v49) + v62.n128_u64[0]) >> 64;
            v49 += v62.n128_u64[0];
            v65 = v51 + v62.n128_u64[1];
            v52 = (__PAIR128__(v52, v51) + v62.n128_u64[1]) >> 64;
            v51 += v62.n128_u64[1];
            v66 = v47 + v61.n128_u64[1];
            v48 = (__PAIR128__(v48, v47) + v61.n128_u64[1]) >> 64;
            v47 += v61.n128_u64[1];
            v9 += v61.n128_u64[0];
            v53 -= 4LL;
          }
          while ( v53 );
          v10 = (__PAIR128__(v10, v63) + __PAIR128__(v48, v66) + __PAIR128__(v50, v64) + __PAIR128__(v52, v65)) >> 64;
          v9 = v63 + v66 + v64 + v65;
          if ( v45 == v46 )
            goto LABEL_21;
        }
        else
        {
          v43 = (int)v2;
          v44 = v38;
        }
        v67 = (unsigned int *)v82 + v44;
        v68 = (unsigned int *)v82 + v43 - 1;
        v69 = v2 - v44;
        do
        {
          v71 = *v67++;
          v70 = v71;
          v72 = *v68--;
          v10 = (__PAIR128__(v10, v9) + (unsigned __int64)v72 * v70) >> 64;
          v9 += v72 * v70;
          --v69;
        }
        while ( v69 );
      }
LABEL_21:
      *(_DWORD *)(v7 + 4LL * v40) = v9;
      *((_QWORD *)&v41 + 1) = v10;
      *(_QWORD *)&v41 = v9;
      v9 = v41 >> 32;
      v10 >>= 32;
      ++v40;
      v38 = v4 + 1;
      ++v37;
      --v39;
      if ( (_DWORD)v4 == (_DWORD)v2 )
      {
        v7 = *(_QWORD *)(a1 + 8);
        break;
      }
    }
  }
LABEL_32:
  v73 = v7 - 4;
  if ( (int)v6 >= 1 )
    v74 = 1;
  else
    v74 = v6;
  while ( (int)v6 >= 2 )
  {
    if ( *(_DWORD *)(v73 + 4 * v6--) )
    {
      v74 = v6 + 1;
      break;
    }
  }
  v76 = v80;
  v77 = v74;
  if ( v80 < v74 )
  {
    (**(void (__fastcall ***)(__int64, _QWORD, unsigned __int64))a1)(a1, v74, v4);
    v76 = *(_QWORD *)(a1 + 24);
  }
  v78 = *(_DWORD *)(a1 + 168);
  result = v82;
  if ( v76 >= v77 )
    v76 = v77;
  *(_QWORD *)(a1 + 16) = v76;
  *(_DWORD *)(a1 + 168) = 2 * v78;
  if ( result != (uint32x4_t *)&v83 )
    return (uint32x4_t *)sub_6575460();
  return result;
}


================================================================================
Function: sub_679DA50 (0x679DA50)
================================================================================

_QWORD *__fastcall sub_679DA50(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2; // x19
  unsigned __int64 v3; // x13
  unsigned __int64 v4; // x21
  unsigned __int64 v5; // x9
  int *v6; // x10
  unsigned __int64 v7; // x22
  _DWORD *v8; // x11
  char *v9; // x12
  char *v10; // x15
  _OWORD *v11; // x16
  unsigned __int64 v12; // x14
  __int64 v13; // x10
  __int64 v14; // x17
  char *v15; // x11
  __int128 *v16; // x13
  __int128 v17; // q0
  __int128 v18; // q1
  int *v19; // x12
  int v20; // t1
  unsigned __int64 v21; // x9
  _QWORD *v22; // x20
  unsigned __int64 v23; // x8

  result[2] = 0LL;
  result[3] = 0LL;
  v2 = result;
  result[1] = 0LL;
  v3 = a2[1];
  v4 = a2[2];
  *result = off_6BE0B58;
  v5 = a2[3];
  v6 = (int *)v3;
  v7 = v4;
  if ( (_QWORD *)v3 == a2 + 4 )
  {
    v8 = result + 4;
    result[3] = v5;
    result[1] = result + 4;
    if ( v4 )
    {
      v9 = (char *)a2 + 4 * v4;
      if ( (unsigned __int64)&v9[-v3] >= 0xFFFFFFFFFFFFFFE4LL )
        goto LABEL_10;
      v10 = (char *)a2 + 4 * v4 - v3;
      if ( (unsigned __int64)(result + 4) < ((unsigned __int64)(v10 + 28) & 0xFFFFFFFFFFFFFFFCLL) + v3 + 4
        && (unsigned __int64)result + ((unsigned __int64)(v10 + 64) & 0xFFFFFFFFFFFFFFFCLL) > v3 )
      {
        goto LABEL_10;
      }
      v11 = result + 6;
      v12 = ((unsigned __int64)&v9[-v3 + 28] >> 2) + 1;
      v13 = 4 * (v12 & 0x7FFFFFFFFFFFFFF8LL);
      v14 = v12 & 0x7FFFFFFFFFFFFFF8LL;
      v15 = (char *)result + v13;
      v6 = (int *)(v3 + v13);
      v8 = v15 + 32;
      v16 = (__int128 *)(v3 + 16);
      do
      {
        v17 = *(v16 - 1);
        v18 = *v16;
        v16 += 2;
        v14 -= 8LL;
        *(v11 - 1) = v17;
        *v11 = v18;
        v11 += 2;
      }
      while ( v14 );
      if ( v12 != (v12 & 0x7FFFFFFFFFFFFFF8LL) )
      {
LABEL_10:
        v19 = (int *)(v9 + 32);
        do
        {
          v20 = *v6++;
          *v8++ = v20;
        }
        while ( v6 != v19 );
      }
    }
  }
  else
  {
    result[3] = v5;
    a2[3] = 0LL;
    v5 = result[3];
    result[1] = v3;
    a2[1] = a2 + 4;
  }
  if ( v5 >= v4 )
  {
    v7 = v5;
  }
  else
  {
    v21 = v5 + (v5 >> 1);
    if ( v21 >= v4 )
    {
      v7 = v21;
      if ( v21 >> 62 )
      {
        if ( v4 >> 62 )
          goto LABEL_26;
        v7 = 0x3FFFFFFFFFFFFFFFLL;
      }
    }
    else if ( v4 >> 62 )
    {
LABEL_26:
      sub_24DE568((__int64)"allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
    }
    v22 = (_QWORD *)result[1];
    result = (_QWORD *)sub_6575418();
    v2[1] = result;
    v2[3] = v7;
    if ( v22 != v2 + 4 )
    {
      result = (_QWORD *)sub_6575460();
      v7 = v2[3];
    }
  }
  if ( v7 >= v4 )
    v23 = v4;
  else
    v23 = v7;
  v2[2] = v23;
  return result;
}


================================================================================
Function: sub_67A2C10 (0x67A2C10)
================================================================================

__int64 sub_67A2C10()
{
  unsigned int *v1; // x0
  __int64 v2; // [xsp+8h] [xbp-18h] BYREF
  __int64 v3; // [xsp+10h] [xbp-10h]
  __int64 v4; // [xsp+18h] [xbp-8h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( clock_gettime(0, (struct timespec *)&v2) )
  {
    v1 = (unsigned int *)__errno();
    sub_67D662C(*v1, "clock_gettime(CLOCK_REALTIME) failed");
  }
  return v3 / 1000 + 1000000 * v2;
}


================================================================================
Function: sub_67A2CE8 (0x67A2CE8)
================================================================================

__int64 sub_67A2CE8()
{
  int *v1; // x0
  __int64 v2; // [xsp+8h] [xbp-18h] BYREF
  __int64 v3; // [xsp+10h] [xbp-10h]
  __int64 v4; // [xsp+18h] [xbp-8h]

  v4 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( clock_gettime(1, (struct timespec *)&v2) )
  {
    v1 = (int *)__errno();
    sub_67D662C(*v1, "clock_gettime(CLOCK_MONOTONIC) failed");
  }
  return v3 + 1000000000 * v2;
}


================================================================================
Function: sub_67A2D6C (0x67A2D6C)
================================================================================

__int64 __fastcall sub_67A2D6C(pthread_cond_t *a1)
{
  return pthread_cond_signal(a1);
}


================================================================================
Function: sub_67A2D8C (0x67A2D8C)
================================================================================

__int64 __fastcall sub_67A2D8C(pthread_cond_t *a1)
{
  return pthread_cond_broadcast(a1);
}


================================================================================
Function: sub_67A2EE8 (0x67A2EE8)
================================================================================

bool sub_67A2EE8()
{
  return (int)sub_67EB670() > 0;
}


================================================================================
Function: sub_67A4870 (0x67A4870)
================================================================================

unsigned __int64 __fastcall sub_67A4870(unsigned __int64 a1)
{
  unsigned __int64 v1; // x9
  unsigned int *v2; // x8
  unsigned __int64 v3; // x10
  unsigned int *v4; // x12
  unsigned int *v5; // x12
  unsigned int v6; // t1
  unsigned __int64 result; // x0
  unsigned __int64 v8; // x12
  unsigned __int64 v9; // x8
  __int64 v10; // x13
  unsigned int *v11; // x11
  unsigned __int64 v12; // x14
  unsigned int *v13; // x16
  unsigned int *v14; // x16
  unsigned int v15; // t1
  __int64 v16; // x10
  __int64 v17; // x13
  unsigned __int64 v18; // x14
  unsigned __int64 v19; // x13
  unsigned __int64 v20; // x15
  unsigned __int64 v21; // x16
  unsigned __int64 v22; // x16
  unsigned __int64 v23; // x16
  unsigned __int64 v24; // x16
  unsigned __int64 v25; // x16
  unsigned __int64 v26; // x16
  unsigned __int64 v27; // x16
  unsigned __int64 v28; // x16
  unsigned __int64 v29; // x16
  unsigned __int64 v30; // x16
  unsigned __int64 v31; // x16
  unsigned __int64 v32; // x16
  unsigned __int64 v33; // x16
  unsigned __int64 v34; // x16
  unsigned __int64 v35; // x16
  unsigned __int64 v36; // x16
  unsigned __int64 v37; // x16
  unsigned __int64 v38; // x16
  unsigned __int64 v39; // x16
  unsigned __int64 v40; // x16
  unsigned __int64 v41; // x16
  unsigned __int64 v42; // x16
  unsigned __int64 v43; // x16
  unsigned __int64 v44; // x16
  unsigned __int64 v45; // x16
  unsigned __int64 v46; // x16
  unsigned __int64 v47; // x16
  unsigned __int64 v48; // x16
  unsigned __int64 v49; // x16
  unsigned __int64 v50; // x16
  unsigned __int64 v51; // x16
  unsigned __int64 v52; // x16
  unsigned __int64 v53; // x16
  unsigned __int64 v54; // x16
  unsigned __int64 v55; // x16
  unsigned __int64 v56; // x16
  unsigned __int64 v57; // x16
  unsigned __int64 v58; // x16
  unsigned __int64 v59; // x16
  unsigned __int64 v60; // x16
  unsigned __int64 v61; // x16
  unsigned __int64 v62; // x16
  unsigned __int64 v63; // x16
  unsigned __int64 v64; // x16
  unsigned __int64 v65; // x16
  unsigned __int64 v66; // x16
  unsigned __int64 v67; // x14

  if ( a1 > 0xD3 )
  {
    if ( a1 >= 0xFFFFFFFFFFFFFFC6LL )
      sub_67A4F90("__next_prime overflow");
    v8 = 48LL;
    v9 = a1 / 0xD2;
    v10 = 210 * (a1 / 0xD2);
    v11 = dword_173EB58;
    do
    {
      v12 = v8 >> 1;
      v13 = &v11[v8 >> 1];
      v8 += ~(v8 >> 1);
      v15 = *v13;
      v14 = v13 + 1;
      if ( a1 % 0xD2 > v15 )
        v11 = v14;
      else
        v8 = v12;
    }
    while ( v8 );
    v16 = v11 - dword_173EB58;
LABEL_16:
    result = v10 + dword_173EB58[v16];
    v17 = 20LL;
    while ( 1 )
    {
      v18 = *(unsigned int *)((char *)&unk_173EA98 + v17);
      if ( result / v18 < v18 )
        break;
      if ( result == result / v18 * v18 )
      {
LABEL_117:
        if ( v16 == 47 )
        {
          ++v9;
          v16 = 0LL;
        }
        else
        {
          ++v16;
        }
        v10 = 210 * v9;
        goto LABEL_16;
      }
      v17 += 4LL;
      if ( v17 == 188 )
      {
        v19 = 419LL;
        while ( 1 )
        {
          v20 = result / (v19 - 208);
          if ( v20 < v19 - 208 )
            return result;
          if ( result == v20 * (v19 - 208) )
            goto LABEL_117;
          v21 = result / (v19 - 198);
          if ( v21 < v19 - 198 )
            return result;
          if ( result == v21 * (v19 - 198) )
            goto LABEL_117;
          v22 = result / (v19 - 196);
          if ( v22 < v19 - 196 )
            return result;
          if ( result == v22 * (v19 - 196) )
            goto LABEL_117;
          v23 = result / (v19 - 192);
          if ( v23 < v19 - 192 )
            return result;
          if ( result == v23 * (v19 - 192) )
            goto LABEL_117;
          v24 = result / (v19 - 190);
          if ( v24 < v19 - 190 )
            return result;
          if ( result == v24 * (v19 - 190) )
            goto LABEL_117;
          v25 = result / (v19 - 186);
          if ( v25 < v19 - 186 )
            return result;
          if ( result == v25 * (v19 - 186) )
            goto LABEL_117;
          v26 = result / (v19 - 180);
          if ( v26 < v19 - 180 )
            return result;
          if ( result == v26 * (v19 - 180) )
            goto LABEL_117;
          v27 = result / (v19 - 178);
          if ( v27 < v19 - 178 )
            return result;
          if ( result == v27 * (v19 - 178) )
            goto LABEL_117;
          v28 = result / (v19 - 172);
          if ( v28 < v19 - 172 )
            return result;
          if ( result == v28 * (v19 - 172) )
            goto LABEL_117;
          v29 = result / (v19 - 168);
          if ( v29 < v19 - 168 )
            return result;
          if ( result == v29 * (v19 - 168) )
            goto LABEL_117;
          v30 = result / (v19 - 166);
          if ( v30 < v19 - 166 )
            return result;
          if ( result == v30 * (v19 - 166) )
            goto LABEL_117;
          v31 = result / (v19 - 162);
          if ( v31 < v19 - 162 )
            return result;
          if ( result == v31 * (v19 - 162) )
            goto LABEL_117;
          v32 = result / (v19 - 156);
          if ( v32 < v19 - 156 )
            return result;
          if ( result == v32 * (v19 - 156) )
            goto LABEL_117;
          v33 = result / (v19 - 150);
          if ( v33 < v19 - 150 )
            return result;
          if ( result == v33 * (v19 - 150) )
            goto LABEL_117;
          v34 = result / (v19 - 148);
          if ( v34 < v19 - 148 )
            return result;
          if ( result == v34 * (v19 - 148) )
            goto LABEL_117;
          v35 = result / (v19 - 142);
          if ( v35 < v19 - 142 )
            return result;
          if ( result == v35 * (v19 - 142) )
            goto LABEL_117;
          v36 = result / (v19 - 138);
          if ( v36 < v19 - 138 )
            return result;
          if ( result == v36 * (v19 - 138) )
            goto LABEL_117;
          v37 = result / (v19 - 136);
          if ( v37 < v19 - 136 )
            return result;
          if ( result == v37 * (v19 - 136) )
            goto LABEL_117;
          v38 = result / (v19 - 130);
          if ( v38 < v19 - 130 )
            return result;
          if ( result == v38 * (v19 - 130) )
            goto LABEL_117;
          v39 = result / (v19 - 126);
          if ( v39 < v19 - 126 )
            return result;
          if ( result == v39 * (v19 - 126) )
            goto LABEL_117;
          v40 = result / (v19 - 120);
          if ( v40 < v19 - 120 )
            return result;
          if ( result == v40 * (v19 - 120) )
            goto LABEL_117;
          v41 = result / (v19 - 112);
          if ( v41 < v19 - 112 )
            return result;
          if ( result == v41 * (v19 - 112) )
            goto LABEL_117;
          v42 = result / (v19 - 108);
          if ( v42 < v19 - 108 )
            return result;
          if ( result == v42 * (v19 - 108) )
            goto LABEL_117;
          v43 = result / (v19 - 106);
          if ( v43 < v19 - 106 )
            return result;
          if ( result == v43 * (v19 - 106) )
            goto LABEL_117;
          v44 = result / (v19 - 102);
          if ( v44 < v19 - 102 )
            return result;
          if ( result == v44 * (v19 - 102) )
            goto LABEL_117;
          v45 = result / (v19 - 100);
          if ( v45 < v19 - 100 )
            return result;
          if ( result == v45 * (v19 - 100) )
            goto LABEL_117;
          v46 = result / (v19 - 96);
          if ( v46 < v19 - 96 )
            return result;
          if ( result == v46 * (v19 - 96) )
            goto LABEL_117;
          v47 = result / (v19 - 88);
          if ( v47 < v19 - 88 )
            return result;
          if ( result == v47 * (v19 - 88) )
            goto LABEL_117;
          v48 = result / (v19 - 82);
          if ( v48 < v19 - 82 )
            return result;
          if ( result == v48 * (v19 - 82) )
            goto LABEL_117;
          v49 = result / (v19 - 78);
          if ( v49 < v19 - 78 )
            return result;
          if ( result == v49 * (v19 - 78) )
            goto LABEL_117;
          v50 = result / (v19 - 72);
          if ( v50 < v19 - 72 )
            return result;
          if ( result == v50 * (v19 - 72) )
            goto LABEL_117;
          v51 = result / (v19 - 70);
          if ( v51 < v19 - 70 )
            return result;
          if ( result == v51 * (v19 - 70) )
            goto LABEL_117;
          v52 = result / (v19 - 66);
          if ( v52 < v19 - 66 )
            return result;
          if ( result == v52 * (v19 - 66) )
            goto LABEL_117;
          v53 = result / (v19 - 60);
          if ( v53 < v19 - 60 )
            return result;
          if ( result == v53 * (v19 - 60) )
            goto LABEL_117;
          v54 = result / (v19 - 58);
          if ( v54 < v19 - 58 )
            return result;
          if ( result == v54 * (v19 - 58) )
            goto LABEL_117;
          v55 = result / (v19 - 52);
          if ( v55 < v19 - 52 )
            return result;
          if ( result == v55 * (v19 - 52) )
            goto LABEL_117;
          v56 = result / (v19 - 46);
          if ( v56 < v19 - 46 )
            return result;
          if ( result == v56 * (v19 - 46) )
            goto LABEL_117;
          v57 = result / (v19 - 42);
          if ( v57 < v19 - 42 )
            return result;
          if ( result == v57 * (v19 - 42) )
            goto LABEL_117;
          v58 = result / (v19 - 40);
          if ( v58 < v19 - 40 )
            return result;
          if ( result == v58 * (v19 - 40) )
            goto LABEL_117;
          v59 = result / (v19 - 36);
          if ( v59 < v19 - 36 )
            return result;
          if ( result == v59 * (v19 - 36) )
            goto LABEL_117;
          v60 = result / (v19 - 30);
          if ( v60 < v19 - 30 )
            return result;
          if ( result == v60 * (v19 - 30) )
            goto LABEL_117;
          v61 = result / (v19 - 28);
          if ( v61 < v19 - 28 )
            return result;
          if ( result == v61 * (v19 - 28) )
            goto LABEL_117;
          v62 = result / (v19 - 22);
          if ( v62 < v19 - 22 )
            return result;
          if ( result == v62 * (v19 - 22) )
            goto LABEL_117;
          v63 = result / (v19 - 18);
          if ( v63 < v19 - 18 )
            return result;
          if ( result == v63 * (v19 - 18) )
            goto LABEL_117;
          v64 = result / (v19 - 16);
          if ( v64 < v19 - 16 )
            return result;
          if ( result == v64 * (v19 - 16) )
            goto LABEL_117;
          v65 = result / (v19 - 12);
          if ( v65 < v19 - 12 )
            return result;
          if ( result == v65 * (v19 - 12) )
            goto LABEL_117;
          v66 = result / (v19 - 10);
          if ( v66 < v19 - 10 )
            return result;
          if ( result == v66 * (v19 - 10) )
            goto LABEL_117;
          if ( result / v19 < v19 )
            return result;
          v67 = result / v19 * v19;
          v19 += 210LL;
          if ( result == v67 )
            goto LABEL_117;
        }
      }
    }
  }
  else
  {
    v1 = 48LL;
    v2 = (unsigned int *)&unk_173EA98;
    do
    {
      v3 = v1 >> 1;
      v4 = &v2[v1 >> 1];
      v1 += ~(v1 >> 1);
      v6 = *v4;
      v5 = v4 + 1;
      if ( v6 < a1 )
        v2 = v5;
      else
        v1 = v3;
    }
    while ( v1 );
    return *v2;
  }
  return result;
}


================================================================================
Function: sub_67A4F90 (0x67A4F90)
================================================================================

void __fastcall __noreturn sub_67A4F90(__int64 a1)
{
  __int64 v2; // x19

  v2 = sub_67EAFB8(16LL);
  sub_67A4FE4(v2, a1);
  sub_67EB030(v2, (__int64)&`typeinfo for'std::overflow_error, (__int64)sub_67EE34C);
}


================================================================================
Function: sub_67A4FE4 (0x67A4FE4)
================================================================================

__int64 __fastcall sub_67A4FE4(_QWORD *a1, char *a2)
{
  __int64 result; // x0

  result = sub_67D2554((int)a1, a2);
  *a1 = off_6BE61F0;
  return result;
}


================================================================================
Function: sub_67A501C (0x67A501C)
================================================================================

__int64 sub_67A501C()
{
  return sub_67A5024();
}


================================================================================
Function: sub_67A5024 (0x67A5024)
================================================================================

unsigned __int64 __fastcall sub_67A5024(_QWORD *a1)
{
  __int64 v2; // x8
  __int64 v3; // x20

  v2 = a1[9];
  *a1 = off_6BE0F28;
  if ( v2 )
  {
    v3 = v2 - 1;
    do
    {
      (*(void (__fastcall **)(_QWORD, _QWORD *, _QWORD))(a1[7] + 8 * v3))(0LL, a1, *(unsigned int *)(a1[8] + 4 * v3));
      --v3;
    }
    while ( v3 != -1 );
  }
  sub_67C482C(a1 + 6);
  sub_677CBEC(a1[7]);
  sub_677CBEC(a1[8]);
  sub_677CBEC(a1[11]);
  return sub_677CBEC(a1[14]);
}


================================================================================
Function: sub_67A5110 (0x67A5110)
================================================================================

long double __fastcall sub_67A5110(__int64 a1)
{
  long double result; // q0

  *(_QWORD *)a1 = off_6BAF0D8;
  sub_67C4788(a1 + 8);
  *(_OWORD *)&result = 0uLL;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}


================================================================================
Function: sub_67A5550 (0x67A5550)
================================================================================

void sub_67A5550()
{
  ;
}


================================================================================
Function: sub_67A5558 (0x67A5558)
================================================================================

__int64 __fastcall sub_67A5558(__int64 result, _QWORD *a2, char a3)
{
  char *v3; // x8
  int v4; // w9
  int v5; // w10
  int v6; // w9
  _BYTE *v7; // x19
  __int64 *v10; // x8
  __int64 v11; // x2
  __int64 *v12; // x21
  _QWORD *v13; // x22
  unsigned __int8 *v14; // x8
  __int64 v15; // x8
  char *v16; // x8
  int v17; // w11
  int v18; // w9
  __int64 v19[2]; // [xsp+0h] [xbp-10h] BYREF

  v19[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_BYTE *)result = 0;
  v3 = (char *)a2 + *(_QWORD *)(*a2 - 24LL);
  v4 = *((_DWORD *)v3 + 8);
  if ( v4 )
  {
    v5 = *((_DWORD *)v3 + 9);
    v6 = v4 | (*((_QWORD *)v3 + 5) == 0LL) | 4;
    *((_DWORD *)v3 + 8) = v6;
    if ( (v6 & v5) != 0 )
      goto LABEL_3;
  }
  else
  {
    v7 = (_BYTE *)result;
    result = *((_QWORD *)v3 + 17);
    if ( result )
      result = sub_65885D4();
    if ( (a3 & 1) == 0 )
    {
      v10 = (_QWORD *)((char *)a2 + *(_QWORD *)(*a2 - 24LL));
      if ( (*((_BYTE *)v10 + 9) & 0x10) != 0 )
      {
        sub_67C4814(v19, v10 + 6);
        v12 = sub_67C4BB8(v19, (__int64)&qword_795CE58, v11);
        result = sub_67C482C(v19);
        v13 = *(_QWORD **)((char *)a2 + *(_QWORD *)(*a2 - 24LL) + 40);
        if ( !v13 )
          goto LABEL_22;
        while ( 1 )
        {
          if ( v13[3] == v13[4] )
          {
            result = (*(__int64 (__fastcall **)(_QWORD *))(*v13 + 72LL))(v13);
            if ( (_DWORD)result == -1 )
              goto LABEL_22;
          }
          v14 = (unsigned __int8 *)v13[3];
          if ( v14 == (unsigned __int8 *)v13[4] )
          {
            result = (*(__int64 (__fastcall **)(_QWORD *))(*v13 + 72LL))(v13);
            if ( (result & 0x80) != 0 )
              break;
          }
          else
          {
            result = *v14;
            if ( (result & 0x80) != 0 )
              break;
          }
          if ( (*(_QWORD *)(v12[2] + 8LL * (unsigned __int8)result) & 1) == 0 )
            break;
          v15 = v13[3];
          if ( v15 == v13[4] )
            (*(void (__fastcall **)(_QWORD *))(*v13 + 80LL))(v13);
          else
            v13[3] = v15 + 1;
        }
        if ( v13[3] == v13[4] )
        {
          result = (*(__int64 (__fastcall **)(_QWORD *))(*v13 + 72LL))(v13);
          if ( (_DWORD)result == -1 )
          {
LABEL_22:
            v16 = (char *)a2 + *(_QWORD *)(*a2 - 24LL);
            v17 = *((_DWORD *)v16 + 9);
            v18 = *((_DWORD *)v16 + 8) | (*((_QWORD *)v16 + 5) == 0LL) | 6;
            *((_DWORD *)v16 + 8) = v18;
            if ( (v18 & v17) != 0 )
LABEL_3:
              sub_67A8454("ios_base::clear");
          }
        }
      }
    }
    *v7 = *(_DWORD *)((char *)a2 + *(_QWORD *)(*a2 - 24LL) + 32) == 0;
  }
  return result;
}


================================================================================
Function: sub_67A577C (0x67A577C)
================================================================================

__int64 __usercall sub_67A577C@<X0>(__int64 a1@<X0>, __int64 *a2@<X8>)
{
  return sub_67C4814(a2, (__int64 *)(a1 + 48));
}


================================================================================
Function: sub_67A5C50 (0x67A5C50)
================================================================================

char *__fastcall sub_67A5C50(char *a1, __int64 a2)
{
  __int64 v4; // x0
  char *v5; // x8
  int v6; // w10
  int v7; // w9
  char v9[8]; // [xsp+8h] [xbp-18h] BYREF
  char v10[4]; // [xsp+10h] [xbp-10h] BYREF
  int v11; // [xsp+14h] [xbp-Ch] BYREF
  __int64 v12; // [xsp+18h] [xbp-8h]

  v12 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v11 = 0;
  sub_67A5558(v10, a1, 0LL);
  if ( v10[0] )
  {
    sub_67C4814(v9, &a1[*(_QWORD *)(*(_QWORD *)a1 - 24LL) + 48]);
    v4 = sub_67C4BB8(v9, &qword_795CCE0);
    (*(void (__fastcall **)(__int64, _QWORD, _QWORD, char *, int *, __int64))(*(_QWORD *)v4 + 64LL))(
      v4,
      *(_QWORD *)&a1[*(_QWORD *)(*(_QWORD *)a1 - 24LL) + 40],
      0LL,
      &a1[*(_QWORD *)(*(_QWORD *)a1 - 24LL)],
      &v11,
      a2);
    sub_67C482C(v9);
    v5 = &a1[*(_QWORD *)(*(_QWORD *)a1 - 24LL)];
    v6 = *((_DWORD *)v5 + 9);
    v7 = *((_DWORD *)v5 + 8) | v11 | (*((_QWORD *)v5 + 5) == 0LL);
    *((_DWORD *)v5 + 8) = v7;
    if ( (v7 & v6) != 0 )
      sub_67A8454("ios_base::clear");
  }
  return a1;
}


================================================================================
Function: sub_67A6D5C (0x67A6D5C)
================================================================================

_QWORD *__fastcall sub_67A6D5C(_QWORD *result, __int64 *a2)
{
  __int64 v2; // x8
  char *v3; // x8
  _BYTE *v4; // x19

  v2 = *a2;
  *(_BYTE *)result = 0;
  result[1] = a2;
  v3 = (char *)a2 + *(_QWORD *)(v2 - 24);
  if ( !*((_DWORD *)v3 + 8) )
  {
    v4 = result;
    result = (_QWORD *)*((_QWORD *)v3 + 17);
    if ( result )
      result = sub_65885D4(result);
    *v4 = 1;
  }
  return result;
}


================================================================================
Function: sub_67A6DB0 (0x67A6DB0)
================================================================================

__int64 __fastcall sub_67A6DB0(__int64 result)
{
  __int64 v1; // x8
  __int64 v2; // x19
  __int64 v3; // x0
  __int64 v4; // x8
  int v5; // w10
  int v6; // w9

  v1 = *(_QWORD *)(result + 8) + *(_QWORD *)(**(_QWORD **)(result + 8) - 24LL);
  if ( *(_QWORD *)(v1 + 40) )
  {
    if ( !*(_DWORD *)(v1 + 32) && (*(_BYTE *)(v1 + 9) & 0x20) != 0 )
    {
      v2 = result;
      result = sub_67A2EE8(result);
      if ( (result & 1) == 0 )
      {
        v3 = *(_QWORD *)(*(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL) + 40LL);
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 48LL))(v3);
        if ( (_DWORD)result == -1 )
        {
          v4 = *(_QWORD *)(v2 + 8) + *(_QWORD *)(**(_QWORD **)(v2 + 8) - 24LL);
          v5 = *(_DWORD *)(v4 + 36);
          v6 = *(_DWORD *)(v4 + 32) | 1;
          *(_DWORD *)(v4 + 32) = v6;
          if ( (v5 & v6) != 0 )
            sub_67A8454("ios_base::clear");
        }
      }
    }
  }
  return result;
}


================================================================================
Function: sub_67A8410 (0x67A8410)
================================================================================

__int64 __fastcall sub_67A8410(__int64 result, int a2)
{
  int v2; // w9
  int v3; // w8

  v2 = *(_DWORD *)(result + 36);
  v3 = (*(_QWORD *)(result + 40) == 0LL) | a2;
  *(_DWORD *)(result + 32) = v3;
  if ( (v2 & v3) != 0 )
    sub_67A8454("ios_base::clear");
  return result;
}


================================================================================
Function: sub_67A8454 (0x67A8454)
================================================================================

void __fastcall __noreturn sub_67A8454(char *a1)
{
  _QWORD *v2; // x19
  unsigned __int8 v3; // w8

  v2 = (_QWORD *)sub_67EAFB8(32LL);
  v3 = atomic_load(byte_795C518);
  if ( (v3 & 1) == 0 )
  {
    if ( (unsigned int)sub_67EB6E0((__int64)byte_795C518) )
    {
      sub_67D5DC8(&qword_795C510);
      qword_795C510 = (__int64)off_6BE10B8;
      __cxa_atexit((void (*)(void *))sub_67D66D8, &qword_795C510, &off_67F7780);
      sub_67EB838(byte_795C518);
    }
  }
  sub_67D6484((__int64)v2, 1LL, (__int64)&qword_795C510, a1);
  *v2 = off_6BE0F00;
  sub_67EB030((__int64)v2, (__int64)&`typeinfo for'std::ios_base::failure, (__int64)sub_67A831C);
}


================================================================================
Function: sub_67A8530 (0x67A8530)
================================================================================

__int64 __fastcall sub_67A8530(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 40) = a2;
  *(_DWORD *)(a1 + 32) = a2 == 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_OWORD *)(a1 + 16) = xmmword_AFCB80;
  *(_DWORD *)(a1 + 8) = 4098;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  return sub_67C4788(a1 + 48);
}


================================================================================
Function: sub_67BFBCC (0x67BFBCC)
================================================================================

__int64 __fastcall sub_67BFBCC(__int64 a1, __int64 a2)
{
  unsigned __int8 v3; // w8
  unsigned __int8 v4; // w8
  unsigned __int8 v5; // w8

  *(_BYTE *)(a1 + 272) = 1;
  *(_QWORD *)a1 = &off_6BE1378;
  *(_QWORD *)(a1 + 8) = a2 - 1;
  *(_WORD *)(a1 + 288) = 17154;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 32) = a1 + 272;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_BYTE *)(a1 + 290) = 0;
  *(_QWORD *)(a1 + 16) = a1 + 48;
  *(_QWORD *)(a1 + 24) = a1 + 48;
  qword_795D7E0 = (__int64)off_6BE1B78;
  *(_QWORD *)algn_795D7E8 = 0LL;
  sub_67C01CC();
  qword_795D7F0 = (__int64)off_6BE1BB8;
  *(_QWORD *)algn_795D7F8 = 0LL;
  sub_67C02F4(a1);
  byte_795D818 = 0;
  qword_795D810 = (__int64)&unk_173F130;
  qword_795D800 = (__int64)off_6BE1420;
  *(_QWORD *)algn_795D808 = 0LL;
  sub_67C041C(a1);
  qword_795D820 = (__int64)off_6BE1758;
  *(_QWORD *)algn_795D828 = 0LL;
  sub_67C0544(a1);
  qword_795D830 = (__int64)off_6BE1828;
  *(_QWORD *)algn_795D838 = 0LL;
  sub_67C066C(a1);
  qword_795D840 = (__int64)off_6BE1578;
  *(_QWORD *)algn_795D848 = 0LL;
  v3 = atomic_load(byte_795CE08);
  if ( (v3 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_795CE08) )
  {
    qword_795CE00 = newlocale(8127LL, "C", 0LL);
    sub_67EB838(byte_795CE08);
  }
  qword_795D850 = qword_795CE00;
  sub_67C0794(a1, &qword_795D840);
  qword_795D860 = (__int64)off_6BE18D0;
  *(_QWORD *)algn_795D868 = 0LL;
  sub_67C08BC(a1);
  qword_795D870 = (__int64)off_6BE1968;
  *(_QWORD *)algn_795D878 = 0LL;
  sub_67C09E4(a1);
  qword_795D8A0 = 0LL;
  unk_795D8A8 = 0LL;
  word_795D890 = 11310;
  qword_795D898 = 0LL;
  qword_795D880 = (__int64)off_6BE15D8;
  *(_QWORD *)algn_795D888 = 0LL;
  sub_67C0B0C(a1);
  qword_795D8D0 = 0LL;
  unk_795D8D8 = 0LL;
  qword_795D8C8 = 0LL;
  qword_795D8C0 = 0x2C0000002ELL;
  qword_795D8B0 = (__int64)off_6BE1628;
  *(_QWORD *)algn_795D8B8 = 0LL;
  sub_67C0C34(a1);
  qword_795D8E0 = (__int64)off_6BE1BF8;
  *(_QWORD *)algn_795D8E8 = 0LL;
  sub_67C0D5C(a1);
  qword_795D8F0 = (__int64)off_6BE1CE8;
  *(_QWORD *)algn_795D8F8 = 0LL;
  sub_67C0E84(a1);
  qword_795D900 = (__int64)off_6BE1DC8;
  *(_QWORD *)algn_795D908 = 0LL;
  sub_67C0FAC(a1);
  qword_795D910 = (__int64)off_6BE1EA0;
  *(_QWORD *)algn_795D918 = 0LL;
  sub_67C10D4(a1);
  qword_795D920 = (__int64)off_6BE2558;
  *(_QWORD *)algn_795D928 = 0LL;
  sub_67C11FC(a1);
  qword_795D930 = (__int64)off_6BE2610;
  *(_QWORD *)algn_795D938 = 0LL;
  sub_67C1324(a1);
  qword_795D940 = (__int64)off_6BE26B8;
  *(_QWORD *)algn_795D948 = 0LL;
  sub_67C144C(a1);
  qword_795D950 = (__int64)off_6BE2760;
  *(_QWORD *)algn_795D958 = 0LL;
  sub_67C1574(a1);
  qword_795D960 = (__int64)off_6BE2A28;
  *(_QWORD *)algn_795D968 = 0LL;
  sub_67C169C(a1);
  qword_795D970 = (__int64)off_6BE2AA8;
  *(_QWORD *)algn_795D978 = 0LL;
  sub_67C17C4(a1);
  qword_795D980 = (__int64)off_6BE2B28;
  *(_QWORD *)algn_795D988 = 0LL;
  sub_67C18EC(a1);
  qword_795D990 = (__int64)off_6BE2BA8;
  *(_QWORD *)algn_795D998 = 0LL;
  sub_67C1A14(a1);
  qword_795D9A0 = (__int64)off_6BE1F68;
  *(_QWORD *)algn_795D9A8 = 0LL;
  qword_795D9B0 = (__int64)off_6BE1FC8;
  sub_67C1B3C(a1);
  qword_795D9C0 = (__int64)off_6BE2078;
  *(_QWORD *)algn_795D9C8 = 0LL;
  qword_795D9D0 = (__int64)off_6BE20D8;
  sub_67C1C64(a1);
  qword_795D9E0 = (__int64)off_6BE1718;
  *(_QWORD *)algn_795D9E8 = 0LL;
  v4 = atomic_load(byte_795CE08);
  if ( (v4 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_795CE08) )
  {
    qword_795CE00 = newlocale(8127LL, "C", 0LL);
    sub_67EB838(byte_795CE08);
  }
  qword_795D9F0 = qword_795CE00;
  qword_795D9E0 = (__int64)off_6BE23E8;
  sub_67C1D8C(a1, &qword_795D9E0);
  qword_795DA00 = (__int64)off_6BE1718;
  *(_QWORD *)algn_795DA08 = 0LL;
  v5 = atomic_load(byte_795CE08);
  if ( (v5 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_795CE08) )
  {
    qword_795CE00 = newlocale(8127LL, "C", 0LL);
    sub_67EB838(byte_795CE08);
  }
  qword_795DA10 = qword_795CE00;
  qword_795DA00 = (__int64)off_6BE2460;
  sub_67C1EB4(a1, &qword_795DA00);
  qword_795DA20 = (__int64)off_6BE2C28;
  *(_QWORD *)algn_795DA28 = 0LL;
  sub_67C1FDC(a1);
  qword_795DA30 = (__int64)off_6BE2CB0;
  *(_QWORD *)algn_795DA38 = 0LL;
  return sub_67C2104(a1);
}


================================================================================
Function: sub_67C01CC (0x67C01CC)
================================================================================

__int64 __fastcall sub_67C01CC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CCC0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CCC0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CCC0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CCC8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C02F4 (0x67C02F4)
================================================================================

__int64 __fastcall sub_67C02F4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CCD0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CCD0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CCD0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CCD8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C041C (0x67C041C)
================================================================================

__int64 __fastcall sub_67C041C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CE58;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CE58);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CE58, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CE60 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C0544 (0x67C0544)
================================================================================

__int64 __fastcall sub_67C0544(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CE48;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CE48);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CE48, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CE50 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C066C (0x67C066C)
================================================================================

__int64 __fastcall sub_67C066C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CE68;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CE68);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CE68, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CE70 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C0794 (0x67C0794)
================================================================================

__int64 __fastcall sub_67C0794(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CE78;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CE78);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CE78, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CE80 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C08BC (0x67C08BC)
================================================================================

__int64 __fastcall sub_67C08BC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CE88;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CE88);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CE88, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CE90 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C09E4 (0x67C09E4)
================================================================================

__int64 __fastcall sub_67C09E4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CE98;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CE98);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CE98, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CEA0 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C0B0C (0x67C0B0C)
================================================================================

__int64 __fastcall sub_67C0B0C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CEA8;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CEA8);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CEA8, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CEB0 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C0C34 (0x67C0C34)
================================================================================

__int64 __fastcall sub_67C0C34(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CEB8;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CEB8);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CEB8, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CEC0 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C0D5C (0x67C0D5C)
================================================================================

__int64 __fastcall sub_67C0D5C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CCE0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CCE0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CCE0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CCE8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C0E84 (0x67C0E84)
================================================================================

__int64 __fastcall sub_67C0E84(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CCF0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CCF0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CCF0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CCF8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C0FAC (0x67C0FAC)
================================================================================

__int64 __fastcall sub_67C0FAC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD00;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD00);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD00, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD08 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C10D4 (0x67C10D4)
================================================================================

__int64 __fastcall sub_67C10D4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD10;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD10);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD10, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD18 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C11FC (0x67C11FC)
================================================================================

__int64 __fastcall sub_67C11FC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD60;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD60);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD60, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD68 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C1324 (0x67C1324)
================================================================================

__int64 __fastcall sub_67C1324(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD70;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD70);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD70, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD78 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C144C (0x67C144C)
================================================================================

__int64 __fastcall sub_67C144C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD80;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD80);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD80, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD88 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C1574 (0x67C1574)
================================================================================

__int64 __fastcall sub_67C1574(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD90;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD90);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD90, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD98 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C169C (0x67C169C)
================================================================================

__int64 __fastcall sub_67C169C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CDA0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CDA0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CDA0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CDA8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C17C4 (0x67C17C4)
================================================================================

__int64 __fastcall sub_67C17C4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CDB0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CDB0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CDB0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CDB8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C18EC (0x67C18EC)
================================================================================

__int64 __fastcall sub_67C18EC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CDC0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CDC0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CDC0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CDC8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C1A14 (0x67C1A14)
================================================================================

__int64 __fastcall sub_67C1A14(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CDD0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CDD0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CDD0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CDD8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C1B3C (0x67C1B3C)
================================================================================

__int64 __fastcall sub_67C1B3C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD20;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD20);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD20, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD28 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C1C64 (0x67C1C64)
================================================================================

__int64 __fastcall sub_67C1C64(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD30;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD30);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD30, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD38 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C1D8C (0x67C1D8C)
================================================================================

__int64 __fastcall sub_67C1D8C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD40;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD40);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD40, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD48 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C1EB4 (0x67C1EB4)
================================================================================

__int64 __fastcall sub_67C1EB4(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CD50;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CD50);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CD50, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CD58 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C1FDC (0x67C1FDC)
================================================================================

__int64 __fastcall sub_67C1FDC(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CDE0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CDE0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CDE0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CDE8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C2104 (0x67C2104)
================================================================================

__int64 __fastcall sub_67C2104(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // x8
  unsigned __int64 v5; // x23
  __int64 v6; // x8
  __int64 *v7; // x20
  unsigned __int64 v8; // x10
  __int64 result; // x0
  _QWORD v10[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v11; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v12[2]; // [xsp+20h] [xbp-10h] BYREF

  v12[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v10[2] = 0LL;
  v10[0] = &qword_795CDF0;
  v10[1] = sub_67C4DD0;
  v4 = atomic_load(&qword_795CDF0);
  if ( v4 != -1LL )
  {
    v12[0] = v10;
    v11 = v12;
    sub_67D1B3C(&qword_795CDF0, (__int64)&v11, (void (__fastcall *)(__int64))sub_67D05C4);
  }
  v5 = dword_795CDF8 - 1LL;
  sub_67D17B4(a2);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (__int64 *)(a1 + 16);
  v8 = (*(_QWORD *)(a1 + 24) - v6) >> 3;
  if ( v8 <= v5 )
  {
    if ( v5 + 1 <= v8 )
    {
      if ( v5 + 1 < v8 )
        *(_QWORD *)(a1 + 24) = v6 + 8 * (v5 + 1);
    }
    else
    {
      sub_67D046C(a1 + 16, v5 + 1 - v8);
      v6 = *v7;
    }
  }
  result = *(_QWORD *)(v6 + 8 * v5);
  if ( result )
  {
    result = sub_67D17D8(result);
    v6 = *v7;
  }
  *(_QWORD *)(v6 + 8 * v5) = a2;
  return result;
}


================================================================================
Function: sub_67C46DC (0x67C46DC)
================================================================================

__int64 *sub_67C46DC()
{
  unsigned __int8 v0; // w8

  v0 = atomic_load(byte_795CE20);
  if ( (v0 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_795CE20) )
  {
    sub_67BFBCC(&unk_795DA40, 1LL);
    qword_795CE10 = (__int64)&unk_795DA40;
    qword_795CE18 = (__int64)&qword_795CE10;
    sub_67EB838(byte_795CE20);
  }
  qword_795CE28 = qword_795CE10;
  sub_67D17B4(qword_795CE10);
  return &qword_795CE28;
}


================================================================================
Function: sub_67C4788 (0x67C4788)
================================================================================

__int64 __fastcall sub_67C4788(_QWORD *a1)
{
  unsigned __int8 v2; // w8

  v2 = atomic_load(byte_795CE38);
  if ( (v2 & 1) == 0 && (unsigned int)sub_67EB6E0((__int64)byte_795CE38) )
  {
    sub_67C46DC();
    qword_795CE30 = (__int64)&qword_795CE28;
    sub_67EB838(byte_795CE38);
  }
  *a1 = qword_795CE28;
  return sub_67D17B4();
}


================================================================================
Function: sub_67C4814 (0x67C4814)
================================================================================

__int64 __fastcall sub_67C4814(__int64 *a1, __int64 *a2)
{
  __int64 v3; // x0

  v3 = *a2;
  *a1 = *a2;
  return sub_67D17B4(v3);
}


================================================================================
Function: sub_67C482C (0x67C482C)
================================================================================

__int64 __fastcall sub_67C482C(_QWORD *a1)
{
  return sub_67D17D8(*a1);
}


================================================================================
Function: sub_67C4BB8 (0x67C4BB8)
================================================================================

__int64 *__fastcall sub_67C4BB8(__int64 *result, __int64 a2, __int64 a3)
{
  __int64 v4; // x21
  unsigned __int64 v5; // x8
  __int64 v6; // x8
  unsigned __int64 v7; // x9
  _QWORD v8[3]; // [xsp+0h] [xbp-30h] BYREF
  _QWORD *v9; // [xsp+18h] [xbp-18h] BYREF
  _QWORD v10[2]; // [xsp+20h] [xbp-10h] BYREF

  v10[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v8[2] = 0LL;
  v4 = *result;
  v8[0] = a2;
  v8[1] = sub_67C4DD0;
  v5 = atomic_load((unsigned __int64 *)a2);
  if ( v5 != -1LL )
  {
    v10[0] = v8;
    v9 = v10;
    result = (__int64 *)sub_67D1B3C(a2, &v9, sub_67D05C4);
  }
  v6 = *(_QWORD *)(v4 + 16);
  v7 = *(int *)(a2 + 8) - 1LL;
  if ( v7 >= (*(_QWORD *)(v4 + 24) - v6) >> 3 || (result = *(__int64 **)(v6 + 8 * v7)) == 0LL )
    sub_251B288(result, a2, a3);
  return result;
}


================================================================================
Function: sub_67D046C (0x67D046C)
================================================================================

char *__fastcall sub_67D046C(char *result, size_t n)
{
  __int64 v2; // x8
  char *v3; // x21
  char **v4; // x19
  char *v6; // x22
  __int64 v7; // x21
  unsigned __int64 v8; // x9
  __int64 v9; // x8
  unsigned __int64 v10; // x23
  __int64 v12; // x0
  size_t v13; // x20
  char *v14; // x21
  size_t v15; // x20
  unsigned __int64 v16; // x23
  char *v17; // x1
  char *v18; // x24
  signed __int64 v19; // x2
  char *v20; // x20

  v3 = (char *)*((_QWORD *)result + 1);
  v2 = *((_QWORD *)result + 2);
  v4 = (char **)result;
  if ( n <= (v2 - (__int64)v3) >> 3 )
  {
    if ( n )
    {
      v13 = 8 * n;
      result = (char *)memset(*((void **)result + 1), 0, 8 * n);
      v3 += v13;
    }
    v4[1] = v3;
  }
  else
  {
    v6 = result + 32;
    v7 = (__int64)&v3[-*(_QWORD *)result] >> 3;
    v8 = v7 + n;
    if ( (v7 + n) >> 61 )
      sub_67D6BD4();
    v9 = v2 - *(_QWORD *)result;
    if ( v9 >> 2 >= v8 )
      v8 = v9 >> 2;
    if ( (unsigned __int64)v9 >= 0x7FFFFFFFFFFFFFF8LL )
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if ( v10 )
    {
      if ( v10 <= 0x1C && result[256] == 0 )
      {
        v12 = (__int64)(result + 32);
        *((_BYTE *)v4 + 256) = 1;
      }
      else
      {
        v12 = sub_6575418();
      }
    }
    else
    {
      v12 = 0LL;
    }
    v14 = (char *)(v12 + 8 * v7);
    v15 = 8 * n;
    v16 = v12 + 8 * v10;
    result = (char *)memset(v14, 0, v15);
    v17 = *v4;
    v18 = &v14[v15];
    v19 = v4[1] - *v4;
    v20 = &v14[-v19];
    if ( v19 >= 1 )
    {
      result = (char *)memcpy(&v14[-v19], v17, v19);
      v17 = *v4;
    }
    *v4 = v20;
    v4[1] = v18;
    v4[2] = (char *)v16;
    if ( v17 )
    {
      if ( v17 == v6 )
        *((_BYTE *)v4 + 256) = 0;
      else
        return (char *)sub_6575460();
    }
  }
  return result;
}


================================================================================
Function: sub_67D17B4 (0x67D17B4)
================================================================================

unsigned __int64 __fastcall sub_67D17B4(__int64 a1)
{
  return sub_67F0410(1uLL, (atomic_ullong *)(a1 + 8));
}


================================================================================
Function: sub_67D17D8 (0x67D17D8)
================================================================================

bool __fastcall sub_67D17D8(__int64 a1)
{
  unsigned __int64 v2; // x20

  v2 = sub_67F04A0(0xFFFFFFFFFFFFFFFFLL, (atomic_ullong *)(a1 + 8));
  if ( !v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1);
  return v2 == 0;
}


================================================================================
Function: sub_67D18A4 (0x67D18A4)
================================================================================

__int64 __fastcall sub_67D18A4(unsigned __int64 *a1)
{
  __int64 result; // x0

  if ( !atomic_load(a1 + 2) )
    return (*(__int64 (__fastcall **)(unsigned __int64 *))(*a1 + 32))(a1);
  result = sub_67F04A0(-1LL, a1 + 2);
  if ( !result )
    return (*(__int64 (__fastcall **)(unsigned __int64 *))(*a1 + 32))(a1);
  return result;
}


================================================================================
Function: sub_67D1968 (0x67D1968)
================================================================================

__int64 __fastcall sub_67D1968(pthread_mutex_t *a1)
{
  __int64 result; // x0
  __int64 v2; // x0

  result = pthread_mutex_lock(a1);
  if ( (_DWORD)result )
  {
    v2 = sub_67D662C(result, "mutex lock failed");
    return sub_67D1994(v2);
  }
  return result;
}


================================================================================
Function: sub_67D1994 (0x67D1994)
================================================================================

bool __fastcall sub_67D1994(pthread_mutex_t *a1)
{
  return pthread_mutex_trylock(a1) == 0;
}


================================================================================
Function: sub_67D19BC (0x67D19BC)
================================================================================

__int64 __fastcall sub_67D19BC(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1);
}


================================================================================
Function: sub_67D19DC (0x67D19DC)
================================================================================

__int64 __fastcall sub_67D19DC(pthread_mutex_t *a1)
{
  int v2; // w0
  int v3; // w0
  int v4; // w20
  __int64 result; // x0
  int v6; // [xsp+Ch] [xbp-14h]
  int v7; // [xsp+Ch] [xbp-14h]
  pthread_mutexattr_t attr; // [xsp+10h] [xbp-10h] BYREF
  __int64 v9; // [xsp+18h] [xbp-8h]

  v9 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v2 = pthread_mutexattr_init(&attr);
  if ( v2 )
    sub_67D662C(v2, "recursive_mutex constructor failed");
  v3 = pthread_mutexattr_settype(&attr, 1);
  if ( v3 )
  {
    v6 = v3;
    pthread_mutexattr_destroy(&attr);
    sub_67D662C(v6, "recursive_mutex constructor failed");
  }
  v4 = pthread_mutex_init(a1, &attr);
  result = pthread_mutexattr_destroy(&attr);
  if ( v4 )
    sub_67D662C(v4, "recursive_mutex constructor failed");
  if ( (_DWORD)result )
  {
    v7 = result;
    pthread_mutex_destroy(a1);
    sub_67D662C(v7, "recursive_mutex constructor failed");
  }
  return result;
}


================================================================================
Function: sub_67D1AC8 (0x67D1AC8)
================================================================================

__int64 __fastcall sub_67D1AC8(pthread_mutex_t *a1)
{
  __int64 result; // x0

  result = pthread_mutex_lock(a1);
  if ( (_DWORD)result )
    sub_67D662C(result, "recursive_mutex lock failed");
  return result;
}


================================================================================
Function: sub_67D1AF4 (0x67D1AF4)
================================================================================

__int64 __fastcall sub_67D1AF4(pthread_mutex_t *a1)
{
  return pthread_mutex_unlock(a1);
}


================================================================================
Function: sub_67D1B14 (0x67D1B14)
================================================================================

bool __fastcall sub_67D1B14(pthread_mutex_t *a1)
{
  return pthread_mutex_trylock(a1) == 0;
}


================================================================================
Function: sub_67D1B3C (0x67D1B3C)
================================================================================

__int64 __fastcall sub_67D1B3C(unsigned __int64 *a1, __int64 a2, void (__fastcall *a3)(__int64))
{
  pthread_mutex_lock(&stru_795DB80);
  while ( *a1 == 1 )
    pthread_cond_wait(&stru_795DBA8, &stru_795DB80);
  if ( *a1 )
    return pthread_mutex_unlock(&stru_795DB80);
  *a1 = 1LL;
  pthread_mutex_unlock(&stru_795DB80);
  a3(a2);
  pthread_mutex_lock(&stru_795DB80);
  atomic_store(0xFFFFFFFFFFFFFFFFLL, a1);
  pthread_mutex_unlock(&stru_795DB80);
  return pthread_cond_broadcast(&stru_795DBA8);
}


================================================================================
Function: sub_67D2360 (0x67D2360)
================================================================================

void *__fastcall sub_67D2360(_QWORD *a1, char *a2)
{
  char v3; // w9
  const char *v4; // x20
  size_t v5; // x21
  __int64 v6; // x0
  __int64 v7; // x22
  void *result; // x0

  v3 = *a2;
  *a1 = off_6BE6030;
  if ( (v3 & 1) != 0 )
    v4 = (const char *)*((_QWORD *)a2 + 2);
  else
    v4 = a2 + 1;
  v5 = __strlen_chk(v4, 0xFFFFFFFFFFFFFFFFLL);
  v6 = sub_6575418();
  v7 = v6 + 24;
  *(_QWORD *)v6 = v5;
  *(_QWORD *)(v6 + 8) = v5;
  *(_DWORD *)(v6 + 16) = 0;
  result = memcpy((void *)(v6 + 24), v4, v5 + 1);
  a1[1] = v7;
  return result;
}


================================================================================
Function: sub_67D23F8 (0x67D23F8)
================================================================================

void *__fastcall sub_67D23F8(_QWORD *a1, char *a2)
{
  size_t v4; // x21
  __int64 v5; // x0
  __int64 v6; // x22
  void *result; // x0

  *a1 = off_6BE6030;
  v4 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
  v5 = sub_6575418();
  v6 = v5 + 24;
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = v4;
  *(_DWORD *)(v5 + 16) = 0;
  result = memcpy((void *)(v5 + 24), a2, v4 + 1);
  a1[1] = v6;
  return result;
}


================================================================================
Function: sub_67D2484 (0x67D2484)
================================================================================

__int64 __fastcall sub_67D2484(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x9

  v2 = *(_QWORD *)(a2 + 8);
  *a1 = off_6BE6030;
  a1[1] = v2;
  return sub_67F03E0(1u, (atomic_uint *)(v2 - 8));
}


================================================================================
Function: sub_67D24BC (0x67D24BC)
================================================================================

void *__fastcall sub_67D24BC(_QWORD *a1, char *a2)
{
  char v3; // w9
  const char *v4; // x20
  size_t v5; // x21
  __int64 v6; // x0
  __int64 v7; // x22
  void *result; // x0

  v3 = *a2;
  *a1 = off_6BE6058;
  if ( (v3 & 1) != 0 )
    v4 = (const char *)*((_QWORD *)a2 + 2);
  else
    v4 = a2 + 1;
  v5 = __strlen_chk(v4, 0xFFFFFFFFFFFFFFFFLL);
  v6 = sub_6575418();
  v7 = v6 + 24;
  *(_QWORD *)v6 = v5;
  *(_QWORD *)(v6 + 8) = v5;
  *(_DWORD *)(v6 + 16) = 0;
  result = memcpy((void *)(v6 + 24), v4, v5 + 1);
  a1[1] = v7;
  return result;
}


================================================================================
Function: sub_67D2554 (0x67D2554)
================================================================================

void *__fastcall sub_67D2554(_QWORD *a1, char *a2)
{
  size_t v4; // x21
  __int64 v5; // x0
  __int64 v6; // x22
  void *result; // x0

  *a1 = off_6BE6058;
  v4 = __strlen_chk(a2, 0xFFFFFFFFFFFFFFFFLL);
  v5 = sub_6575418();
  v6 = v5 + 24;
  *(_QWORD *)v5 = v4;
  *(_QWORD *)(v5 + 8) = v4;
  *(_DWORD *)(v5 + 16) = 0;
  result = memcpy((void *)(v5 + 24), a2, v4 + 1);
  a1[1] = v6;
  return result;
}


================================================================================
Function: sub_67D25E0 (0x67D25E0)
================================================================================

__int64 __fastcall sub_67D25E0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // x9

  v2 = *(_QWORD *)(a2 + 8);
  *a1 = off_6BE6058;
  a1[1] = v2;
  return sub_67F03E0(1u, (atomic_uint *)(v2 - 8));
}


================================================================================
Function: sub_67D2618 (0x67D2618)
================================================================================

void __noreturn sub_67D2618()
{
  sub_24DE568("basic_string");
}


================================================================================
Function: sub_67D2630 (0x67D2630)
================================================================================

void __noreturn sub_67D2630()
{
  sub_2512CE8("basic_string");
}


================================================================================
Function: sub_67D2648 (0x67D2648)
================================================================================

_BYTE *__fastcall sub_67D2648(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        size_t a5,
        __int64 a6,
        size_t a7,
        const void *a8)
{
  char *v15; // x24
  unsigned __int64 v16; // x8
  unsigned __int64 v17; // x27
  _BYTE *result; // x0
  _BYTE *v19; // x28
  size_t v20; // x25
  size_t v21; // x9

  if ( -18LL - a2 < a3 )
    sub_67D2618();
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v15 = *(char **)(a1 + 16);
  else
    v15 = (char *)(a1 + 1);
  if ( a2 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v17 = -17LL;
  }
  else
  {
    v16 = a3 + a2;
    if ( a3 + a2 < 2 * a2 )
      v16 = 2 * a2;
    if ( v16 >= 0x17 )
      v17 = (v16 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v17 = 23LL;
  }
  result = (_BYTE *)sub_6575418();
  v19 = result;
  if ( a5 )
    result = memcpy(result, v15, a5);
  if ( a7 )
    result = memcpy(&v19[a5], a8, a7);
  v20 = a4 - (a5 + a6);
  if ( v20 )
    result = memcpy(&v19[a5 + a7], &v15[a5 + a6], v20);
  if ( a2 != 22 )
    result = (_BYTE *)sub_6575460();
  v21 = a7 + a5 + v20;
  *(_QWORD *)a1 = v17 | 1;
  *(_QWORD *)(a1 + 8) = v21;
  *(_QWORD *)(a1 + 16) = v19;
  v19[v21] = 0;
  return result;
}


================================================================================
Function: sub_67D2788 (0x67D2788)
================================================================================

unsigned __int64 *__fastcall sub_67D2788(unsigned __int64 *result, __int128 *a2)
{
  unsigned __int64 *v2; // x19
  __int128 v3; // q0
  const void *v4; // x20
  unsigned __int64 v5; // x22
  void *v6; // x19
  __int64 v7; // x0

  v2 = result;
  if ( (*(_BYTE *)a2 & 1) != 0 )
  {
    v5 = *((_QWORD *)a2 + 1);
    v4 = (const void *)*((_QWORD *)a2 + 2);
    if ( v5 > 0x16 )
    {
      if ( v5 >= 0xFFFFFFFFFFFFFFF0LL )
        sub_67D2618(result);
      v7 = sub_6575418();
      v2[1] = v5;
      v2[2] = v7;
      *v2 = (v5 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
      v6 = (void *)v7;
    }
    else
    {
      *(_BYTE *)result = 2 * v5;
      v6 = (char *)result + 1;
    }
    return (unsigned __int64 *)memcpy(v6, v4, v5 + 1);
  }
  else
  {
    v3 = *a2;
    result[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)result = v3;
  }
  return result;
}


================================================================================
Function: sub_67D29A8 (0x67D29A8)
================================================================================

char *__fastcall sub_67D29A8(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        size_t a5,
        __int64 a6,
        __int64 a7)
{
  char *v13; // x23
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x26
  char *result; // x0
  char *v17; // x27

  if ( -17LL - a2 < a3 )
    sub_67D2618();
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v13 = *(char **)(a1 + 16);
  else
    v13 = (char *)(a1 + 1);
  if ( a2 > 0x7FFFFFFFFFFFFFE6LL )
  {
    v15 = -17LL;
  }
  else
  {
    v14 = a3 + a2;
    if ( a3 + a2 < 2 * a2 )
      v14 = 2 * a2;
    if ( v14 >= 0x17 )
      v15 = (v14 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    else
      v15 = 23LL;
  }
  result = (char *)sub_6575418();
  v17 = result;
  if ( a5 )
    result = (char *)memcpy(result, v13, a5);
  if ( a4 != a5 + a6 )
    result = (char *)memcpy(&v17[a5 + a7], &v13[a5 + a6], a4 - (a5 + a6));
  if ( a2 != 22 )
    result = (char *)sub_6575460();
  *(_QWORD *)(a1 + 16) = v17;
  *(_QWORD *)a1 = v15 | 1;
  return result;
}


================================================================================
Function: sub_67D2AC0 (0x67D2AC0)
================================================================================

__int64 __fastcall sub_67D2AC0(__int64 result, char a2)
{
  _BYTE *v2; // x8

  if ( (*(_BYTE *)result & 1) != 0 )
  {
    v2 = *(_BYTE **)(result + 16);
    *(_QWORD *)(result + 8) = 1LL;
  }
  else
  {
    *(_BYTE *)result = 2;
    v2 = (_BYTE *)(result + 1);
  }
  *v2 = a2;
  v2[1] = 0;
  return result;
}


================================================================================
Function: sub_67D2CC8 (0x67D2CC8)
================================================================================

size_t *__fastcall sub_67D2CC8(size_t *result, unsigned __int8 *a2, unsigned __int64 a3, size_t a4)
{
  unsigned __int64 v4; // x8
  size_t *v5; // x19
  unsigned __int64 v6; // x9
  bool v7; // cf
  size_t v8; // x9
  unsigned __int8 *v9; // x23
  size_t v10; // x21
  void *v12; // x19
  __int64 v13; // x0

  v4 = *a2;
  v5 = result;
  v6 = *((_QWORD *)a2 + 1);
  if ( (v4 & 1) == 0 )
    v6 = v4 >> 1;
  v7 = v6 >= a3;
  v8 = v6 - a3;
  if ( !v7 )
    sub_67D2630(result);
  if ( (v4 & 1) != 0 )
    v9 = (unsigned __int8 *)*((_QWORD *)a2 + 2);
  else
    v9 = a2 + 1;
  if ( v8 >= a4 )
    v10 = a4;
  else
    v10 = v8;
  if ( v10 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618(result);
  if ( v10 >= 0x17 )
  {
    v13 = sub_6575418();
    v5[1] = v10;
    v5[2] = v13;
    *v5 = (v10 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    v12 = (void *)v13;
  }
  else
  {
    *(_BYTE *)result = 2 * v10;
    v12 = (char *)result + 1;
    if ( !v10 )
      goto LABEL_17;
  }
  result = (size_t *)memcpy(v12, &v9[a3], v10);
LABEL_17:
  *((_BYTE *)v12 + v10) = 0;
  return result;
}


================================================================================
Function: sub_67D2D94 (0x67D2D94)
================================================================================

__int64 __fastcall sub_67D2D94(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x8
  unsigned __int8 *v5; // x19
  bool v6; // zf
  bool v7; // cc
  size_t v8; // x8
  _BYTE *v9; // x0

  v3 = *a1;
  v6 = (v3 & 1) == 0;
  v4 = v3 >> 1;
  if ( v6 )
  {
    v5 = a1 + 1;
  }
  else
  {
    v4 = *((_QWORD *)a1 + 1);
    v5 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  }
  v6 = v4 == a3;
  v7 = v4 > a3;
  v8 = v4 - a3;
  if ( !v7 )
    return -1LL;
  if ( v6 )
    v9 = 0LL;
  else
    v9 = memchr(&v5[a3], a2, v8);
  if ( v9 )
    return v9 - v5;
  else
    return -1LL;
}


================================================================================
Function: sub_67D2E9C (0x67D2E9C)
================================================================================

unsigned __int8 *__fastcall sub_67D2E9C(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v5; // x20
  unsigned __int64 v6; // x9
  unsigned __int8 *v7; // x21
  unsigned __int64 v8; // x22
  unsigned __int64 v9; // x9

  v3 = *a1;
  if ( (v3 & 1) != 0 )
    v5 = *((_QWORD *)a1 + 1);
  else
    v5 = v3 >> 1;
  v6 = v5 - a2;
  if ( v5 < a2 )
    sub_67D2630();
  if ( a3 )
  {
    if ( a3 == -1LL )
    {
      if ( (v3 & 1) != 0 )
      {
        *(_BYTE *)(*((_QWORD *)a1 + 2) + a2) = 0;
        *((_QWORD *)a1 + 1) = a2;
      }
      else
      {
        a1[a2 + 1] = 0;
        *a1 = 2 * a2;
      }
    }
    else
    {
      if ( (v3 & 1) != 0 )
        v7 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      else
        v7 = a1 + 1;
      if ( v6 >= a3 )
        v8 = a3;
      else
        v8 = v5 - a2;
      if ( v6 != v8 )
      {
        memmove(&v7[a2], &v7[a2 + v8], v6 - v8);
        LOBYTE(v3) = *a1;
      }
      v9 = v5 - v8;
      if ( (v3 & 1) != 0 )
        *((_QWORD *)a1 + 1) = v9;
      else
        *a1 = 2 * v9;
      v7[v9] = 0;
    }
  }
  return a1;
}


================================================================================
Function: sub_67D3100 (0x67D3100)
================================================================================

__int64 __fastcall sub_67D3100(unsigned __int8 *a1, unsigned __int64 a2, size_t a3, void *s2, size_t a5)
{
  unsigned __int64 v5; // x8
  unsigned __int64 v6; // x9
  bool v7; // cf
  size_t v8; // x9
  size_t v10; // x20
  size_t v11; // x2
  unsigned __int8 *v12; // x8
  __int64 result; // x0

  v5 = *a1;
  v6 = *((_QWORD *)a1 + 1);
  if ( (v5 & 1) == 0 )
    v6 = v5 >> 1;
  if ( a5 == -1LL || (v7 = v6 >= a2, v8 = v6 - a2, !v7) )
    sub_67D2630();
  if ( v8 >= a3 )
    v10 = a3;
  else
    v10 = v8;
  if ( v10 <= a5 )
    v11 = v10;
  else
    v11 = a5;
  if ( !v11
    || ((v5 & 1) == 0 ? (v12 = a1 + 1) : (v12 = (unsigned __int8 *)*((_QWORD *)a1 + 2)),
        result = memcmp(&v12[a2], s2, v11),
        !(_DWORD)result) )
  {
    if ( v10 < a5 )
      return 0xFFFFFFFFLL;
    else
      return v10 > a5;
  }
  return result;
}


================================================================================
Function: sub_67D3284 (0x67D3284)
================================================================================

_QWORD *__fastcall sub_67D3284(_QWORD *a1, char *s)
{
  size_t v4; // x0
  unsigned int v5; // w8
  size_t v6; // x20
  unsigned __int64 v7; // x1
  __int64 v8; // x3
  void *v9; // x22

  v4 = strlen(s);
  v5 = *(unsigned __int8 *)a1;
  v6 = v4;
  if ( (v5 & 1) != 0 )
    v7 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v7 = 22LL;
  if ( v4 <= v7 )
  {
    if ( (v5 & 1) != 0 )
      v9 = (void *)a1[2];
    else
      v9 = (char *)a1 + 1;
    if ( v4 )
      memmove(v9, s, v4);
    *((_BYTE *)v9 + v6) = 0;
    if ( (*(_BYTE *)a1 & 1) != 0 )
      a1[1] = v6;
    else
      *(_BYTE *)a1 = 2 * v6;
  }
  else
  {
    if ( (v5 & 1) != 0 )
      v8 = a1[1];
    else
      v8 = v5 >> 1;
    sub_67D2648((__int64)a1, v7, v4 - v7, v8, 0LL, v8, v4, s);
  }
  return a1;
}


================================================================================
Function: sub_67D3420 (0x67D3420)
================================================================================

unsigned __int8 *__fastcall sub_67D3420(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v3; // w8
  unsigned int v4; // w9
  __int128 v5; // q0
  bool v6; // zf
  size_t v7; // x9
  __int64 v8; // x11
  size_t v9; // x20
  const void *v10; // x7
  unsigned __int64 v11; // x8
  void *v12; // x21
  __int64 v13; // x2
  __int64 v14; // x3
  __int64 v15; // x1

  if ( a1 == a2 )
    return a1;
  v3 = *a1;
  v4 = *a2;
  if ( (v3 & 1) == 0 )
  {
    if ( (v4 & 1) == 0 )
    {
      v5 = *(_OWORD *)a2;
      *((_QWORD *)a1 + 2) = *((_QWORD *)a2 + 2);
      *(_OWORD *)a1 = v5;
      return a1;
    }
    v9 = *((_QWORD *)a2 + 1);
    v10 = (const void *)*((_QWORD *)a2 + 2);
    v13 = v9 - 22;
    if ( v9 <= 0x16 )
    {
      *a1 = 2 * v9;
      if ( v9 )
        memcpy(a1 + 1, v10, v9);
      a1[v9 + 1] = 0;
      return a1;
    }
    v14 = v3 >> 1;
    v15 = 22LL;
LABEL_21:
    sub_67D2648(a1, v15, v13, v14, 0LL, v14, v9, v10);
    return a1;
  }
  v6 = (v4 & 1) == 0;
  v7 = v4 >> 1;
  v8 = *(_QWORD *)a1;
  if ( v6 )
    v9 = v7;
  else
    v9 = *((_QWORD *)a2 + 1);
  if ( v6 )
    v10 = a2 + 1;
  else
    v10 = (const void *)*((_QWORD *)a2 + 2);
  v11 = v8 & 0xFFFFFFFFFFFFFFFELL;
  if ( (v8 & 0xFFFFFFFFFFFFFFFELL) <= v9 )
  {
    v14 = *((_QWORD *)a1 + 1);
    v15 = v11 - 1;
    v13 = v9 - v11 + 1;
    goto LABEL_21;
  }
  v12 = (void *)*((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 1) = v9;
  if ( v9 )
    memcpy(v12, v10, v9);
  *((_BYTE *)v12 + v9) = 0;
  return a1;
}


================================================================================
Function: sub_67D352C (0x67D352C)
================================================================================

_QWORD *__fastcall sub_67D352C(_QWORD *a1, char *s)
{
  size_t v4; // x0
  size_t v5; // x21
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x1
  unsigned __int64 v8; // x22
  char *v9; // x23
  size_t v10; // x8

  v4 = strlen(s);
  v5 = v4;
  v6 = *(unsigned __int8 *)a1;
  if ( (v6 & 1) != 0 )
    v7 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v7 = 22LL;
  if ( (v6 & 1) != 0 )
    v8 = a1[1];
  else
    v8 = v6 >> 1;
  if ( v7 - v8 >= v4 )
  {
    if ( v4 )
    {
      if ( (v6 & 1) != 0 )
        v9 = (char *)a1[2];
      else
        v9 = (char *)a1 + 1;
      memcpy(&v9[v8], s, v4);
      v10 = v8 + v5;
      if ( (*(_BYTE *)a1 & 1) != 0 )
        a1[1] = v10;
      else
        *(_BYTE *)a1 = 2 * v10;
      v9[v10] = 0;
    }
  }
  else
  {
    sub_67D2648(a1, v7, v8 + v4 - v7, v8, v8, 0LL, v4, s);
  }
  return a1;
}


================================================================================
Function: sub_67D360C (0x67D360C)
================================================================================

char *__fastcall sub_67D360C(_QWORD *a1, __int64 a2, char a3)
{
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x8
  bool v7; // zf
  unsigned __int64 v8; // x9
  unsigned __int64 v9; // x22
  char *v10; // x23
  size_t v11; // x21
  unsigned __int64 v12; // x10
  char *v13; // x8
  char v14; // w9

  v5 = *(unsigned __int8 *)a1;
  v6 = 22LL;
  v7 = (v5 & 1) == 0;
  v8 = v5 >> 1;
  if ( v7 )
    v9 = v8;
  else
    v9 = a1[1];
  if ( v7 )
    v10 = (char *)a1 + 1;
  else
    v10 = (char *)a1[2];
  v11 = a2 - (_QWORD)v10;
  if ( !v7 )
    v6 = (*a1 & 0xFFFFFFFFFFFFFFFELL) - 1;
  if ( v6 == v9 )
  {
    sub_67D29A8((__int64)a1, v9, 1uLL, v9, v11, 0LL, 1LL);
    v10 = (char *)a1[2];
  }
  else if ( v9 != v11 )
  {
    memmove((void *)(a2 + 1), (const void *)a2, v9 - v11);
  }
  v12 = v9 + 1;
  v10[v11] = a3;
  v13 = (char *)a1 + 1;
  v10[v9 + 1] = 0;
  v14 = *(_BYTE *)a1;
  if ( (*(_BYTE *)a1 & 1) != 0 )
    a1[1] = v12;
  else
    *(_BYTE *)a1 = 2 * v12;
  if ( (v14 & 1) != 0 )
    v13 = (char *)a1[2];
  return &v13[v11];
}


================================================================================
Function: sub_67D36F0 (0x67D36F0)
================================================================================

unsigned __int8 *__fastcall sub_67D36F0(unsigned __int8 *result, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // x8
  unsigned __int64 v4; // x9

  v3 = *result;
  v4 = *((_QWORD *)result + 1);
  if ( (v3 & 1) == 0 )
    v4 = v3 >> 1;
  if ( v4 < a2 )
    return (unsigned __int8 *)sub_6588000((int)result, a2 - v4, a3);
  if ( (v3 & 1) != 0 )
  {
    *(_BYTE *)(*((_QWORD *)result + 2) + a2) = 0;
    *((_QWORD *)result + 1) = a2;
  }
  else
  {
    result[a2 + 1] = 0;
    *result = 2 * a2;
  }
  return result;
}


================================================================================
Function: sub_67D4090 (0x67D4090)
================================================================================

size_t __usercall sub_67D4090@<X0>(const char *a1@<X0>, unsigned __int8 *a2@<X1>, unsigned __int64 *a3@<X8>)
{
  size_t result; // x0
  unsigned __int64 v7; // x26
  size_t v8; // x20
  unsigned __int64 v9; // x8
  size_t v10; // x23
  void *v11; // x24
  unsigned __int64 v12; // x8
  const void *v13; // x7
  unsigned __int64 v14; // x1
  size_t v15; // x21
  unsigned __int64 v16; // x25
  char *v17; // x22
  size_t v18; // x8

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  result = strlen(a1);
  v7 = *a2;
  if ( (v7 & 1) != 0 )
    v8 = *((_QWORD *)a2 + 1);
  else
    v8 = v7 >> 1;
  v9 = v8 + result;
  if ( v8 + result >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v10 = result;
  if ( v9 <= 0x16 )
  {
    *(_BYTE *)a3 = 2 * result;
    v11 = (char *)a3 + 1;
    if ( !result )
      goto LABEL_8;
    goto LABEL_7;
  }
  v16 = (v9 + 16) & 0xFFFFFFFFFFFFFFF0LL;
  result = sub_6575418();
  v11 = (void *)result;
  a3[1] = v10;
  a3[2] = result;
  *a3 = v16 | 1;
  if ( v10 )
LABEL_7:
    result = (size_t)memcpy(v11, a1, v10);
LABEL_8:
  *((_BYTE *)v11 + v10) = 0;
  v12 = *(unsigned __int8 *)a3;
  if ( (v7 & 1) != 0 )
    v13 = (const void *)*((_QWORD *)a2 + 2);
  else
    v13 = a2 + 1;
  if ( (v12 & 1) != 0 )
    v14 = (*a3 & 0xFFFFFFFFFFFFFFFELL) - 1;
  else
    v14 = 22LL;
  if ( (v12 & 1) != 0 )
    v15 = a3[1];
  else
    v15 = v12 >> 1;
  if ( v14 - v15 < v8 )
    return (size_t)sub_67D2648((__int64)a3, v14, v15 + v8 - v14, v15, v15, 0LL, v8, v13);
  if ( v8 )
  {
    if ( (v12 & 1) != 0 )
      v17 = (char *)a3[2];
    else
      v17 = (char *)a3 + 1;
    result = (size_t)memcpy(&v17[v15], v13, v8);
    v18 = v15 + v8;
    if ( (*(_BYTE *)a3 & 1) != 0 )
      a3[1] = v18;
    else
      *(_BYTE *)a3 = 2 * v18;
    v17[v18] = 0;
  }
  return result;
}


================================================================================
Function: sub_67D4DB0 (0x67D4DB0)
================================================================================

__int64 __usercall sub_67D4DB0@<X0>(__int64 result@<X0>, unsigned __int64 *a2@<X8>)
{
  char *p_src; // x1
  char *v4; // x20
  unsigned int v5; // w9
  unsigned __int64 v6; // x21
  _BYTE *v7; // x19
  char src; // [xsp+Ch] [xbp-14h] BYREF
  _BYTE v9[3]; // [xsp+Dh] [xbp-13h] BYREF
  _BYTE v10[9]; // [xsp+17h] [xbp-9h] BYREF

  p_src = &src;
  v4 = v10;
  *(_QWORD *)&v10[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (result & 0x80000000) != 0 )
  {
    p_src = v9;
    result = (unsigned int)-(int)result;
    src = 45;
  }
  if ( v10 - p_src > 9
    || (v5 = (1233 * (32 - __clz(result | 1))) >> 12,
        v10 - p_src >= (unsigned int)(((__PAIR64__(v5, result) - dword_1740550[v5]) >> 32) + 1)) )
  {
    result = sub_67D58E4(result);
    v4 = (char *)result;
  }
  v6 = v4 - &src;
  if ( (unsigned __int64)(v4 - &src) >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  if ( v6 > 0x16 )
  {
    result = sub_6575418();
    a2[1] = v6;
    a2[2] = result;
    *a2 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    v7 = (_BYTE *)result;
  }
  else
  {
    *(_BYTE *)a2 = 2 * v6;
    v7 = (char *)a2 + 1;
  }
  if ( &src != v4 )
  {
    result = (__int64)memcpy(v7, &src, v4 - &src);
    v7 += v6;
  }
  *v7 = 0;
  return result;
}


================================================================================
Function: sub_67D523C (0x67D523C)
================================================================================

__int64 __usercall sub_67D523C@<X0>(__int64 a1@<X0>, size_t *a2@<X8>)
{
  __int64 result; // x0
  size_t v4; // x20
  _QWORD *v5; // x21
  _BYTE *v6; // x19
  _QWORD v7[4]; // [xsp+0h] [xbp-20h] BYREF

  v7[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  result = sub_67D5B74(a1, v7);
  v4 = result - (_QWORD)v7;
  if ( (unsigned __int64)(result - (_QWORD)v7) >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v5 = (_QWORD *)result;
  if ( v4 > 0x16 )
  {
    result = sub_6575418();
    a2[1] = v4;
    a2[2] = result;
    *a2 = (v4 + 16) & 0xFFFFFFFFFFFFFFF0LL | 1;
    v6 = (_BYTE *)result;
  }
  else
  {
    *(_BYTE *)a2 = 2 * v4;
    v6 = (char *)a2 + 1;
  }
  if ( v7 != v5 )
  {
    result = (__int64)memcpy(v6, v7, v4);
    v6 += v4;
  }
  *v6 = 0;
  return result;
}


================================================================================
Function: sub_67D58E4 (0x67D58E4)
================================================================================

__int64 __fastcall sub_67D58E4(unsigned int a1, _WORD *a2)
{
  __int64 result; // x0
  unsigned int v3; // w10
  unsigned int v4; // w9
  char v5; // w11
  __int64 v6; // x10
  __int16 v7; // w11
  _WORD *v8; // x10
  unsigned int v9; // w11
  unsigned int v10; // w9
  __int16 v11; // w12
  __int16 v12; // w13
  __int16 v13; // w8

  if ( a1 < 0x5F5E100 )
    return sub_67D59B8(a2, a1);
  v3 = a1 / 0x5F5E100;
  v4 = a1 % 0x5F5E100;
  if ( a1 > 0x3B9AC9FF )
  {
    v7 = word_1740618[v3];
    v6 = 2LL;
    *a2 = v7;
  }
  else
  {
    v5 = v3 + 48;
    v6 = 1LL;
    *(_BYTE *)a2 = v5;
  }
  v8 = (_WORD *)((char *)a2 + v6);
  result = (__int64)(v8 + 4);
  v9 = v4 / 0x2710;
  v10 = v4 % 0x2710;
  v11 = word_1740618[(unsigned __int16)v9 / 0x64u];
  v12 = word_1740618[(unsigned __int16)v10 / 0x64u];
  LOWORD(v9) = word_1740618[(unsigned __int16)v9 % 0x64u];
  *v8 = v11;
  v13 = word_1740618[(unsigned __int16)v10 % 0x64u];
  v8[2] = v12;
  v8[1] = v9;
  v8[3] = v13;
  return result;
}


================================================================================
Function: sub_67D59B8 (0x67D59B8)
================================================================================

_WORD *__fastcall sub_67D59B8(_WORD *a1, unsigned int a2)
{
  _WORD *result; // x0
  unsigned int v3; // w9
  __int64 v4; // x10
  unsigned int v5; // w8
  __int16 v6; // w9
  __int16 v7; // w11
  _WORD *v8; // x10
  unsigned __int16 v9; // w9
  __int16 v10; // w8

  if ( a2 >> 4 > 0x270 )
  {
    v3 = a2 / 0x2710;
    if ( a2 >= 0xF4240 )
    {
      if ( a2 > 0x98967F )
      {
        v4 = 4LL;
        v7 = word_1740618[v3 % 0x64];
        *a1 = word_1740618[a2 / 0xF4240];
        a1[1] = v7;
      }
      else
      {
        v4 = 3LL;
        *(_BYTE *)a1 = (unsigned __int16)v3 / 0x64u + 48;
        *(_WORD *)((char *)a1 + 1) = word_1740618[(unsigned __int16)v3 % 0x64u];
      }
    }
    else if ( a2 >> 5 > 0xC34 )
    {
      v4 = 2LL;
      *a1 = word_1740618[v3];
    }
    else
    {
      v4 = 1LL;
      *(_BYTE *)a1 = v3 + 48;
    }
    v8 = (_WORD *)((char *)a1 + v4);
    v9 = a2 % 0x2710;
    result = v8 + 2;
    v10 = word_1740618[v9 % 0x64u];
    *v8 = word_1740618[v9 / 0x64u];
    v8[1] = v10;
  }
  else if ( a2 > 0x63 )
  {
    v5 = (unsigned __int16)a2 / 0x64u;
    v6 = word_1740618[(unsigned __int16)a2 % 0x64u];
    if ( a2 > 0x3E7 )
    {
      *a1 = word_1740618[v5];
      a1[1] = v6;
      return a1 + 2;
    }
    else
    {
      *(_BYTE *)a1 = v5 + 48;
      *(_WORD *)((char *)a1 + 1) = v6;
      return (_WORD *)((char *)a1 + 3);
    }
  }
  else if ( a2 > 9 )
  {
    *a1 = word_1740618[a2];
    return a1 + 1;
  }
  else
  {
    *(_BYTE *)a1 = a2 + 48;
    return (_WORD *)((char *)a1 + 1);
  }
  return result;
}


================================================================================
Function: sub_67D5B74 (0x67D5B74)
================================================================================

_WORD *__fastcall sub_67D5B74(unsigned __int64 a1, _WORD *a2)
{
  _WORD *result; // x0
  unsigned __int64 v3; // x19
  _WORD *v4; // x8
  __int16 v5; // w12
  __int16 v6; // w9
  __int16 v7; // w10
  unsigned __int64 v8; // x11
  unsigned __int64 v9; // x9
  char v10; // w12
  __int64 v11; // x11
  unsigned int v12; // w12
  __int16 v13; // w13
  __int16 v14; // w12
  __int16 v15; // w13
  unsigned __int64 v16; // x12
  __int64 v17; // x14
  unsigned int v18; // w10
  _WORD *v19; // x9
  unsigned __int64 v20; // x11
  unsigned int v21; // w13
  __int16 v22; // w15
  __int16 v23; // w16
  __int16 v24; // w17
  __int16 v25; // w8

  if ( a1 < 0x5F5E100 )
    return sub_67D59B8(a2, a1);
  if ( a1 >= 0x2386F26FC10000LL )
  {
    v8 = a1 / 0x2386F26FC10000LL;
    v9 = a1 % 0x2386F26FC10000LL;
    if ( (unsigned int)(a1 / 0x2386F26FC10000LL) > 0x63 )
    {
      v12 = (unsigned __int16)v8 / 0x64u;
      if ( (unsigned int)v8 > 0x3E7 )
      {
        *a2 = word_1740618[v12];
        v15 = word_1740618[(unsigned __int16)v8 % 0x64u];
        v11 = 4LL;
        a2[1] = v15;
      }
      else
      {
        *(_BYTE *)a2 = v12 + 48;
        v13 = word_1740618[(unsigned __int16)v8 % 0x64u];
        v11 = 3LL;
        *(_WORD *)((char *)a2 + 1) = v13;
      }
    }
    else if ( (unsigned int)v8 > 9 )
    {
      v14 = word_1740618[v8];
      v11 = 2LL;
      *a2 = v14;
    }
    else
    {
      v10 = v8 + 48;
      v11 = 1LL;
      *(_BYTE *)a2 = v10;
    }
    v16 = v9 / 0x5F5E100;
    v17 = (unsigned int)(v9 / 0x5F5E100);
    v18 = v9 % 0x5F5E100;
    v19 = (_WORD *)((char *)a2 + v11);
    v20 = (unsigned __int64)(3518437209LL * v17) >> 45;
    v21 = v18 / 0x2710;
    LOWORD(v16) = v16 - 10000 * v20;
    v18 %= 0x2710u;
    v22 = word_1740618[(unsigned __int16)v20 / 0x64u];
    v23 = word_1740618[(unsigned __int16)v21 / 0x64u];
    v24 = word_1740618[(unsigned __int16)v16 / 0x64u];
    result = v19 + 8;
    LOWORD(v20) = word_1740618[(unsigned __int16)v20 % 0x64u];
    LOWORD(v16) = word_1740618[(unsigned __int16)v16 % 0x64u];
    *v19 = v22;
    LOWORD(v21) = word_1740618[(unsigned __int16)v21 % 0x64u];
    v19[4] = v23;
    LOWORD(v17) = word_1740618[(unsigned __int16)v18 / 0x64u];
    v19[2] = v24;
    v25 = word_1740618[(unsigned __int16)v18 % 0x64u];
    v19[1] = v20;
    v19[3] = v16;
    v19[5] = v21;
    v19[6] = v17;
    v19[7] = v25;
  }
  else
  {
    v3 = a1 % 0x5F5E100;
    v4 = sub_67D59B8(a2, a1 / 0x5F5E100);
    v5 = word_1740618[(unsigned int)v3 % 0x2710 / 0x64];
    v6 = word_1740618[(unsigned __int16)((unsigned int)v3 / 0x2710) % 0x64u];
    *v4 = word_1740618[(unsigned __int16)((unsigned int)v3 / 0x2710) / 0x64u];
    v7 = word_1740618[(unsigned int)v3 % 0x2710 % 0x64];
    v4[2] = v5;
    v4[1] = v6;
    result = v4 + 4;
    v4[3] = v7;
  }
  return result;
}


================================================================================
Function: sub_67D5DC8 (0x67D5DC8)
================================================================================

_QWORD *__fastcall sub_67D5DC8(_QWORD *result)
{
  *result = off_6BE39B0;
  return result;
}


================================================================================
Function: sub_67D6278 (0x67D6278)
================================================================================

long double __usercall sub_67D6278@<Q0>(long double *__return_ptr a1@<X8>, __int64 a2@<X0>, unsigned __int8 *a3@<X1>)
{
  unsigned __int64 v5; // x8
  unsigned __int64 v7; // x8
  char *v8; // x1
  size_t v9; // x2
  long double result; // q0
  __int64 v11; // x8
  _QWORD v12[4]; // [xsp+0h] [xbp-20h] BYREF

  v12[3] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( *(_DWORD *)a2 )
  {
    v5 = *a3;
    if ( (v5 & 1) != 0 )
      v7 = *((_QWORD *)a3 + 1);
    else
      v7 = v5 >> 1;
    if ( v7 )
      sub_67D352C((int)a3, ": ");
    (*(void (__fastcall **)(_QWORD *__return_ptr))(**(_QWORD **)(a2 + 8) + 48LL))(v12);
    if ( (v12[0] & 1) != 0 )
      v8 = (char *)v12[2];
    else
      v8 = (char *)v12 + 1;
    if ( (v12[0] & 1) != 0 )
      v9 = v12[1];
    else
      v9 = (unsigned __int64)LOBYTE(v12[0]) >> 1;
    sub_6588400((int)a3, v8, v9);
    if ( (v12[0] & 1) != 0 )
      sub_6575460();
  }
  result = *(long double *)a3;
  *(_QWORD *)a3 = 0LL;
  v11 = *((_QWORD *)a3 + 2);
  *((_QWORD *)a3 + 1) = 0LL;
  *((_QWORD *)a3 + 2) = 0LL;
  *a1 = result;
  *((_QWORD *)a1 + 2) = v11;
  return result;
}


================================================================================
Function: sub_67D6484 (0x67D6484)
================================================================================

long double __fastcall sub_67D6484(__int64 a1, __int64 a2, __int64 a3, char *s)
{
  size_t v6; // x0
  size_t v7; // x21
  char *v8; // x22
  unsigned __int64 v9; // x23
  long double result; // q0
  _QWORD v11[3]; // [xsp+8h] [xbp-48h] BYREF
  __int64 v12[2]; // [xsp+20h] [xbp-30h] BYREF
  long double v13; // [xsp+38h] [xbp-18h] BYREF
  __int64 v14; // [xsp+48h] [xbp-8h]

  v14 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *(_QWORD *)&v13 = a2;
  *((_QWORD *)&v13 + 1) = a3;
  v6 = strlen(s);
  if ( v6 >= 0xFFFFFFFFFFFFFFF0LL )
    sub_67D2618();
  v7 = v6;
  if ( v6 >= 0x17 )
  {
    v9 = (v6 + 16) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = (char *)sub_6575418();
    v11[1] = v7;
    v11[2] = v8;
    v11[0] = v9 | 1;
    goto LABEL_6;
  }
  v8 = (char *)v11 + 1;
  LOBYTE(v11[0]) = 2 * v6;
  if ( v6 )
LABEL_6:
    memcpy(v8, s, v7);
  v8[v7] = 0;
  sub_67D6278(v12, (int)&v13, (int)v11);
  sub_67D24BC(a1, v12);
  if ( (v12[0] & 1) != 0 )
    sub_6575460();
  if ( (v11[0] & 1) != 0 )
    sub_6575460();
  result = v13;
  *(long double *)(a1 + 16) = v13;
  *(_QWORD *)a1 = off_6BE39F8;
  return result;
}


================================================================================
Function: sub_67D662C (0x67D662C)
================================================================================

void __fastcall __noreturn sub_67D662C(int a1, char *a2)
{
  __int64 v4; // x19
  unsigned __int8 v5; // w8

  v4 = sub_67EAFB8(32LL);
  v5 = atomic_load(byte_795DBF0);
  if ( (v5 & 1) == 0 )
  {
    if ( (unsigned int)sub_67EB6E0((__int64)byte_795DBF0) )
    {
      qword_795DBE8 = (__int64)off_6BE3AC0;
      sub_67EB838(byte_795DBF0);
    }
  }
  sub_67D6484(v4, a1, (int)&qword_795DBE8, a2);
  sub_67EB030(v4, (__int64)&`typeinfo for'std::system_error, (__int64)sub_67D65F8);
}


================================================================================
Function: sub_67D6798 (0x67D6798)
================================================================================

_QWORD *__fastcall sub_67D6798(_QWORD *result)
{
  if ( *result )
    sub_67EB9A0();
  return result;
}


================================================================================
Function: sub_67D6ACC (0x67D6ACC)
================================================================================

long double __fastcall sub_67D6ACC(_QWORD *a1)
{
  _OWORD *v2; // x0
  long double result; // q0

  v2 = (_OWORD *)sub_6575418();
  *(_OWORD *)&result = 0uLL;
  *a1 = v2;
  *v2 = 0u;
  v2[1] = 0u;
  v2[2] = 0u;
  return result;
}


================================================================================
Function: sub_67D6BD4 (0x67D6BD4)
================================================================================

void __noreturn sub_67D6BD4()
{
  sub_24DE568((__int64)"vector");
}


================================================================================
Function: sub_67D6DB4 (0x67D6DB4)
================================================================================

void __noreturn sub_67D6DB4(char *format, ...)
{
  gcc_va_list va2; // [xsp+C0h] [xbp-90h] BYREF
  gcc_va_list va; // [xsp+E8h] [xbp-68h] BYREF
  char *ptr; // [xsp+108h] [xbp-48h] BYREF
  gcc_va_list arg; // [xsp+110h] [xbp-40h] BYREF
  gcc_va_list va1; // [xsp+130h] [xbp-20h] BYREF

  va_start(va, format);
  va_start(va1, format);
  va_copy(arg, va1);
  vfprintf((FILE *)((char *)&_sF + 304), format, arg);
  fputc(10, (FILE *)((char *)&_sF + 304));
  va_copy(va2, va);
  vasprintf(&ptr, format, va2);
  android_set_abort_message(ptr);
  openlog("libc++abi", 0, 0);
  syslog(2, "%s", ptr);
  closelog();
  abort();
}


================================================================================
Function: sub_67EAF94 (0x67EAF94)
================================================================================

bool __fastcall sub_67EAF94(_QWORD *a1)
{
  return *a1 >> 8 == 0x434C4E47432B2BLL;
}


================================================================================
Function: sub_67EAFB8 (0x67EAFB8)
================================================================================

__int64 __fastcall sub_67EAFB8(__int64 a1)
{
  size_t v1; // x19
  void *v2; // x0
  void *v3; // x20
  __int64 v5; // x0
  __int64 v6; // x0

  v1 = (a1 + 143) & 0xFFFFFFFFFFFFFFF0LL;
  v2 = (void *)sub_67EC900(v1);
  v3 = v2;
  if ( v2 )
  {
    memset(v2, 0, v1);
    return (__int64)v3 + 128;
  }
  else
  {
    v5 = sub_67EB9A0();
    v6 = sub_67EC1B8(v5);
    return sub_67EB00C(v6);
  }
}


================================================================================
Function: sub_67EB00C (0x67EB00C)
================================================================================

__int64 __fastcall sub_67EB00C(__int64 a1)
{
  return sub_67ECA6C(a1 - 128);
}


================================================================================
Function: sub_67EB030 (0x67EB030)
================================================================================

void __fastcall __noreturn sub_67EB030(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x22
  int v7; // w8

  v6 = sub_67EB698();
  *(_QWORD *)(a1 - 96) = sub_67EB98C();
  *(_QWORD *)(a1 - 88) = sub_67EBA00();
  *(_QWORD *)(a1 - 112) = a2;
  *(_QWORD *)(a1 - 104) = a3;
  sub_67EB0B0(a1 - 32);
  v7 = *(_DWORD *)(v6 + 8) + 1;
  *(_QWORD *)(a1 - 120) = 1LL;
  *(_QWORD *)(a1 - 24) = sub_67EB0CC;
  *(_DWORD *)(v6 + 8) = v7;
  sub_67F0650(a1 - 32);
  sub_67EB134(a1 - 128);
}


================================================================================
Function: sub_67EB0B0 (0x67EB0B0)
================================================================================

_QWORD *__fastcall sub_67EB0B0(_QWORD *result)
{
  *result = 0x434C4E47432B2B00LL;
  return result;
}


================================================================================
Function: sub_67EB134 (0x67EB134)
================================================================================

void __fastcall __noreturn sub_67EB134(__int64 a1)
{
  sub_67EB164(a1 + 96);
  sub_67EBA14(*(_QWORD *)(a1 + 40));
}


================================================================================
Function: sub_67EB164 (0x67EB164)
================================================================================

_QWORD *__fastcall sub_67EB164(unsigned __int64 *a1)
{
  unsigned __int64 v2; // x20
  unsigned __int64 *v3; // x0
  unsigned __int64 *v4; // x9
  int v5; // w8
  int v6; // w10
  unsigned __int64 v7; // x8
  bool v8; // zf
  _QWORD *v9; // x8

  v2 = *a1;
  v3 = sub_67EB698();
  v4 = a1 - 12;
  if ( v2 >> 8 == 0x434C4E47432B2BLL )
  {
    v5 = *((_DWORD *)a1 - 10);
    if ( v5 >= 0 )
      v6 = *((_DWORD *)a1 - 10);
    else
      v6 = -v5;
    v7 = *v3;
    v8 = *v3 == (_QWORD)v4;
    *((_DWORD *)a1 - 10) = v6 + 1;
    if ( !v8 )
    {
      *(a1 - 6) = v7;
      *v3 = (unsigned __int64)v4;
    }
    v9 = (_QWORD *)*(a1 - 1);
    --*((_DWORD *)v3 + 2);
  }
  else
  {
    if ( *v3 )
      sub_67EB9A0();
    v9 = a1 + 4;
    *v3 = (unsigned __int64)v4;
  }
  return v9;
}


================================================================================
Function: sub_67EB670 (0x67EB670)
================================================================================

_QWORD *sub_67EB670()
{
  _QWORD *result; // x0

  result = sub_67EB6BC();
  if ( result )
    return (_QWORD *)*((unsigned int *)result + 2);
  return result;
}


================================================================================
Function: sub_67EB698 (0x67EB698)
================================================================================

_QWORD *sub_67EB698()
{
  return sub_67EF968(qword_6C36800);
}


================================================================================
Function: sub_67EB6BC (0x67EB6BC)
================================================================================

_QWORD *sub_67EB6BC()
{
  return sub_67EF968(qword_6C36800);
}


================================================================================
Function: sub_67EB6E0 (0x67EB6E0)
================================================================================

__int64 __fastcall sub_67EB6E0(__int64 a1)
{
  int v1; // w20
  unsigned int v3; // w21
  char v5; // w23
  int v6; // w21
  int v7; // w8

  if ( atomic_load((unsigned __int8 *)a1) )
  {
    return 0;
  }
  else
  {
    if ( pthread_mutex_lock(&stru_795DC08) )
      sub_67D6DB4("%s failed to acquire mutex");
    v5 = *(_BYTE *)(a1 + 1);
    if ( (v5 & 2) != 0 )
    {
      v6 = *(_DWORD *)(a1 + 4);
      v1 = syscall(178LL);
      if ( v6 == v1 )
        sub_67D6DB4("__cxa_guard_acquire detected recursive initialization");
    }
    while ( 1 )
    {
      v7 = *(unsigned __int8 *)(a1 + 1);
      if ( (v7 & 2) == 0 )
        break;
      *(_BYTE *)(a1 + 1) = v7 | 4;
      pthread_cond_wait(&stru_795DC30, &stru_795DC08);
    }
    if ( v7 == 1 )
    {
      v3 = 0;
    }
    else
    {
      if ( (v5 & 2) == 0 )
        v1 = syscall(178LL);
      v3 = 1;
      *(_DWORD *)(a1 + 4) = v1;
      *(_BYTE *)(a1 + 1) = 2;
    }
    if ( pthread_mutex_unlock(&stru_795DC08) )
      sub_67D6DB4("%s failed to release mutex");
  }
  return v3;
}


================================================================================
Function: sub_67EB838 (0x67EB838)
================================================================================

__int64 __fastcall sub_67EB838(unsigned __int8 *a1)
{
  unsigned __int8 v2; // w20
  __int64 result; // x0

  atomic_store(1u, a1);
  if ( pthread_mutex_lock(&stru_795DC08) )
    sub_67D6DB4("%s failed to acquire mutex");
  v2 = a1[1];
  a1[1] = 1;
  result = pthread_mutex_unlock(&stru_795DC08);
  if ( (_DWORD)result )
    sub_67D6DB4("%s failed to release mutex");
  if ( (v2 & 4) != 0 )
  {
    result = pthread_cond_broadcast(&stru_795DC30);
    if ( (_DWORD)result )
      sub_67D6DB4("%s failed to broadcast");
  }
  return result;
}


================================================================================
Function: sub_67EB98C (0x67EB98C)
================================================================================

unsigned __int64 sub_67EB98C()
{
  return atomic_load((unsigned __int64 *)&off_6C367F0);
}


================================================================================
Function: sub_67EB9A0 (0x67EB9A0)
================================================================================

void __noreturn sub_67EB9A0()
{
  __int64 *v0; // x0
  __int64 v1; // x19
  unsigned __int64 v2; // x0

  v0 = (__int64 *)sub_67EB6BC();
  if ( v0 )
  {
    v1 = *v0;
    if ( *v0 )
    {
      if ( (sub_67EAF94(v1 + 96) & 1) != 0 )
        sub_67EBA14(*(_QWORD *)(v1 + 40));
    }
  }
  v2 = atomic_load((unsigned __int64 *)off_6C367E8);
  sub_67EBA14(v2);
}


================================================================================
Function: sub_67EB9E4 (0x67EB9E4)
================================================================================

void __fastcall __noreturn sub_67EB9E4(void (*a1)(void))
{
  a1();
  sub_67D6DB4("unexpected_handler unexpectedly returned");
}


================================================================================
Function: sub_67EBA00 (0x67EBA00)
================================================================================

unsigned __int64 sub_67EBA00()
{
  return atomic_load((unsigned __int64 *)off_6C367E8);
}


================================================================================
Function: sub_67EBA14 (0x67EBA14)
================================================================================

void __fastcall __noreturn sub_67EBA14(void (*a1)(void))
{
  a1();
  sub_67D6DB4("terminate_handler unexpectedly returned");
}


================================================================================
Function: sub_67EC1B8 (0x67EC1B8)
================================================================================

void __fastcall __noreturn sub_67EC1B8(__int64 a1)
{
  __int64 v2; // x0

  if ( !a1 )
  {
    sub_67EB164();
    sub_67EB9A0();
  }
  sub_67EB164();
  if ( (sub_67EAF94(a1) & 1) != 0 )
  {
    v2 = *(_QWORD *)(a1 - 64);
  }
  else
  {
    sub_67EBA00();
    v2 = sub_67EB98C();
  }
  sub_67EB9E4(v2);
}


================================================================================
Function: sub_67EC670 (0x67EC670)
================================================================================

__int64 __fastcall sub_67EC670(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  unsigned __int8 v5; // w8
  _QWORD *v6; // x0
  _QWORD *v7; // x21
  __int64 *v8; // x8
  __int64 v9; // x9

  if ( &_cxa_thread_atexit_impl )
    return __cxa_thread_atexit_impl(a1, a2);
  v5 = atomic_load(byte_795DC68);
  if ( (v5 & 1) == 0 )
  {
    if ( (unsigned int)sub_67EB6E0((__int64)byte_795DC68) )
    {
      sub_67EC7A0();
      __cxa_atexit((void (*)(void *))&loc_67EC7DC, &unk_795DC60, &off_67F7780);
      sub_67EB838(byte_795DC68);
    }
  }
  if ( (*(_BYTE *)sub_67EF968(qword_6C36820) & 1) == 0 )
  {
    if ( pthread_setspecific(dword_795DC70, &dword_795DC70) )
      return 0xFFFFFFFFLL;
    *(_BYTE *)sub_67EF968(qword_6C36820) = 1;
  }
  v6 = (_QWORD *)sub_677CA08(0x18uLL);
  if ( v6 )
  {
    v7 = v6;
    *v6 = a1;
    v6[1] = a2;
    v8 = sub_67EF968(qword_6C36840);
    result = 0LL;
    v9 = *v8;
    *v8 = (__int64)v7;
    v7[2] = v9;
    return result;
  }
  return 0xFFFFFFFFLL;
}


================================================================================
Function: sub_67EC7A0 (0x67EC7A0)
================================================================================

__int64 sub_67EC7A0()
{
  __int64 result; // x0

  result = pthread_key_create((pthread_key_t *)&dword_795DC70, (void (*)(void *))sub_67EC868);
  if ( (_DWORD)result )
    sub_67D6DB4("std::__libcpp_tls_create() failed in __cxa_thread_atexit()");
  return result;
}


================================================================================
Function: sub_67EC900 (0x67EC900)
================================================================================

__int64 __fastcall sub_67EC900(__int64 a1)
{
  unsigned __int64 StatusReg; // x20
  __int64 v2; // x19
  _QWORD v4[2]; // [xsp+0h] [xbp-10h] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( a1 )
    v2 = a1;
  else
    v2 = 1LL;
  v4[1] = *(_QWORD *)(StatusReg + 40);
  if ( (unsigned int)sub_677CD24(v4, 16LL, v2) )
    return sub_67EC974(v2);
  else
    return v4[0];
}


================================================================================
Function: sub_67EC974 (0x67EC974)
================================================================================

unsigned __int16 *__fastcall sub_67EC974(__int64 a1)
{
  int *v2; // x11
  int *v3; // x12
  unsigned __int64 v4; // x10
  int *v5; // x19
  unsigned __int64 v6; // x11
  __int64 v7; // x13
  unsigned __int16 *v8; // x19
  unsigned __int16 *v9; // x9
  __int64 v10; // x10

  pthread_mutex_lock(&stru_795DC74);
  v2 = (int *)qword_795DCA0;
  if ( !qword_795DCA0 )
  {
    v2 = dword_795DCB0;
    qword_795DCA0 = (__int64)dword_795DCB0;
    dword_795DCB0[0] = 8388736;
  }
  if ( v2 == (int *)&byte_795DEB0 )
  {
LABEL_8:
    v8 = 0LL;
  }
  else
  {
    v3 = 0LL;
    v4 = ((unsigned __int64)(a1 + 3) >> 2) + 1;
    while ( 1 )
    {
      v5 = v2;
      v6 = *((unsigned __int16 *)v2 + 1);
      if ( v4 < v6 )
      {
        v9 = (unsigned __int16 *)&v5[(unsigned __int16)(v6 - v4)];
        *((_WORD *)v5 + 1) = v6 - v4;
        v8 = v9 + 2;
        *v9 = 0;
        v9[1] = v4;
        goto LABEL_13;
      }
      if ( v4 == v6 )
        break;
      v3 = v5;
      v7 = *(unsigned __int16 *)v5;
      v2 = &dword_795DCB0[v7];
      if ( v7 == 128 )
        goto LABEL_8;
    }
    v10 = *(unsigned __int16 *)v5;
    if ( v3 )
    {
      *(_WORD *)v3 = v10;
      *(_WORD *)v5 = 0;
      v8 = (unsigned __int16 *)(v5 + 1);
    }
    else
    {
      *(_WORD *)v5 = 0;
      v8 = (unsigned __int16 *)(v5 + 1);
      qword_795DCA0 = (__int64)&dword_795DCB0[v10];
    }
  }
LABEL_13:
  pthread_mutex_unlock(&stru_795DC74);
  return v8;
}


================================================================================
Function: sub_67ECA6C (0x67ECA6C)
================================================================================

unsigned __int64 __fastcall sub_67ECA6C(unsigned __int64 a1)
{
  int *v3; // x20
  int v4; // w9
  bool v5; // zf
  int *v6; // x11
  int *v7; // x10
  __int64 v8; // x13
  __int64 v9; // x14
  __int64 v10; // x13
  __int16 v11; // w9

  if ( a1 < (unsigned __int64)dword_795DCB0 || a1 >= (unsigned __int64)&byte_795DEB0 )
    return sub_677CBEC(a1);
  v3 = (int *)(a1 - 4);
  pthread_mutex_lock(&stru_795DC74);
  v4 = qword_795DCA0;
  if ( qword_795DCA0 )
    v5 = qword_795DCA0 == (_QWORD)&byte_795DEB0;
  else
    v5 = 1;
  if ( v5 )
  {
LABEL_13:
    qword_795DCA0 = (__int64)v3;
    *(_WORD *)v3 = (v4 - (unsigned int)dword_795DCB0) >> 2;
  }
  else
  {
    v6 = 0LL;
    v7 = (int *)qword_795DCA0;
    while ( 1 )
    {
      v8 = *((unsigned __int16 *)v7 + 1);
      if ( &v7[v8] == v3 )
      {
        *((_WORD *)v7 + 1) = *(_WORD *)(a1 - 2) + v8;
        return pthread_mutex_unlock(&stru_795DC74);
      }
      v9 = *(unsigned __int16 *)(a1 - 2);
      if ( &v3[v9] == v7 )
        break;
      v10 = *(unsigned __int16 *)v7;
      v6 = v7;
      v7 = &dword_795DCB0[v10];
      if ( v10 == 128 )
        goto LABEL_13;
    }
    *(_WORD *)(a1 - 2) = v9 + v8;
    if ( v6 )
    {
      *(_WORD *)v6 = ((unsigned int)v3 - (unsigned int)dword_795DCB0) >> 2;
    }
    else
    {
      v11 = *(_WORD *)v7;
      qword_795DCA0 = (__int64)v3;
      *(_WORD *)v3 = v11;
    }
  }
  return pthread_mutex_unlock(&stru_795DC74);
}


================================================================================
Function: sub_67EE258 (0x67EE258)
================================================================================

_QWORD *__fastcall sub_67EE258(_QWORD *result)
{
  *result = off_6BE5F78;
  return result;
}


================================================================================
Function: sub_67EE6B8 (0x67EE6B8)
================================================================================

_QWORD *__fastcall sub_67EE6B8(_QWORD *result)
{
  *result = off_6BE6270;
  return result;
}


================================================================================
Function: sub_67EE758 (0x67EE758)
================================================================================

__int64 sub_67EE758()
{
  __int64 result; // x0
  bool v1; // w10
  bool v2; // w13
  bool v3; // w12
  bool v4; // w12
  __int128 v5; // [xsp+0h] [xbp-20h]
  __int128 v6; // [xsp+10h] [xbp-10h]

  result = 1LL;
  v1 = (_QWORD)v6 != 0LL;
  if ( (*((_QWORD *)&v6 + 1) & 0x7FFFFFFFFFFFFFFFLL) != 0x7FFF000000000000LL )
    v1 = (*((_QWORD *)&v6 + 1) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FFF000000000000LL;
  if ( !v1 )
  {
    v2 = (*((_QWORD *)&v5 + 1) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FFF000000000000LL;
    if ( (*((_QWORD *)&v5 + 1) & 0x7FFFFFFFFFFFFFFFLL) == 0x7FFF000000000000LL )
      v2 = (_QWORD)v5 != 0LL;
    if ( !v2 )
    {
      if ( !((unsigned __int64)v5 | (unsigned __int64)v6 | *((_QWORD *)&v5 + 1) & 0x7FFFFFFFFFFFFFFFLL | *((_QWORD *)&v6 + 1) & 0x7FFFFFFFFFFFFFFFLL) )
        return 0LL;
      if ( (__int64)(*((_QWORD *)&v5 + 1) & *((_QWORD *)&v6 + 1)) < 0 != __OFSUB__(
                                                                           *((_QWORD *)&v5 + 1) & 0x7FFFFFFFFFFFFFFFLL,
                                                                           0x7FFF000000000000LL) )
      {
        v4 = (unsigned __int64)v6 > (unsigned __int64)v5;
        if ( *((_QWORD *)&v6 + 1) != *((_QWORD *)&v5 + 1) )
          v4 = *((_QWORD *)&v6 + 1) > *((_QWORD *)&v5 + 1);
        if ( v4 )
          return 0xFFFFFFFFLL;
      }
      else
      {
        v3 = (unsigned __int64)v6 < (unsigned __int64)v5;
        if ( *((_QWORD *)&v6 + 1) != *((_QWORD *)&v5 + 1) )
          v3 = *((_QWORD *)&v6 + 1) < *((_QWORD *)&v5 + 1);
        if ( v3 )
          return 0xFFFFFFFFLL;
      }
      return v6 != v5;
    }
  }
  return result;
}


================================================================================
Function: sub_67EE830 (0x67EE830)
================================================================================

__int64 sub_67EE830()
{
  _BOOL4 v0; // w9
  unsigned __int64 v1; // x10
  _BOOL4 v2; // w8
  __int64 v4; // [xsp+0h] [xbp-20h]
  __int64 v5; // [xsp+8h] [xbp-18h]
  __int64 v6; // [xsp+10h] [xbp-10h]
  __int64 v7; // [xsp+18h] [xbp-8h]

  v0 = v6 != 0;
  v1 = v5 & 0x7FFFFFFFFFFFFFFFLL;
  if ( (v7 & 0x7FFFFFFFFFFFFFFFLL) != 0x7FFF000000000000LL )
    v0 = (v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FFF000000000000LL;
  v2 = v1 > 0x7FFF000000000000LL;
  if ( v1 == 0x7FFF000000000000LL )
    v2 = v4 != 0;
  return v0 | (unsigned int)v2;
}


================================================================================
Function: sub_67EF318 (0x67EF318)
================================================================================

double sub_67EF318()
{
  unsigned __int64 v0; // x10
  __int64 v1; // x10
  __int64 v2; // x9
  double result; // d0
  bool v4; // w11
  unsigned __int64 v5; // x10
  char v6; // w11
  char v7; // w10
  unsigned __int64 v8; // x12
  bool v9; // zf
  unsigned __int64 v10; // x14
  unsigned __int64 v11; // x11
  unsigned __int64 v12; // x16
  __int64 v13; // x11
  unsigned __int64 v14; // x13
  __int64 v15; // x12
  bool v16; // zf
  unsigned __int64 v17; // x9
  unsigned __int64 v18; // x10
  __int64 v19; // x11
  __int128 v20; // t2
  __int128 v21; // [xsp+0h] [xbp-10h]

  v0 = *((_QWORD *)&v21 + 1) & 0x7FFFFFFFFFFFFFFFLL;
  if ( (*((_QWORD *)&v21 + 1) & 0x7FFFFFFFFFFFFFFFuLL) - 0x3C01000000000000LL >= (*((_QWORD *)&v21 + 1) & 0x7FFFFFFFFFFFFFFFuLL)
                                                                               - 0x43FF000000000000LL )
  {
    v4 = v0 < 0x7FFF000000000000LL;
    if ( v0 == 0x7FFF000000000000LL )
      v4 = (_QWORD)v21 == 0LL;
    if ( v4 )
    {
      if ( v0 <= 0x43FEFFFFFFFFFFFFLL )
      {
        v5 = HIWORD(v0);
        if ( (unsigned int)v5 >= 0x3B91 )
        {
          v6 = v5 + 127;
          v7 = 1 - v5;
          v8 = *((_QWORD *)&v21 + 1) & 0xFFFFFFFFFFFFLL | 0x1000000000000LL;
          v9 = (v6 & 0x40) == 0LL;
          v10 = (_QWORD)v21 << v6;
          v11 = (v8 << v6) | ((unsigned __int64)v21 >> 1 >> ~v6);
          if ( v9 )
            v12 = v10;
          else
            v12 = 0LL;
          if ( !v9 )
            v11 = v10;
          v9 = (v12 | v11) == 0;
          v13 = (2 * v8) << ~v7;
          v14 = v8 >> v7;
          v15 = !v9;
          v16 = (v7 & 0x40) == 0LL;
          v17 = v13 | ((unsigned __int64)v21 >> v7);
          if ( (v7 & 0x40) != 0 )
            v18 = 0LL;
          else
            v18 = v14;
          if ( !v16 )
            v17 = v14;
          v19 = v17 & 0xFFFFFFFFFFFFFFFLL;
          *((_QWORD *)&v20 + 1) = v18;
          *(_QWORD *)&v20 = v17;
          v2 = v20 >> 60;
          if ( (v19 | (unsigned __int64)v15) < 0x800000000000001LL )
          {
            if ( (v19 | v15) != 0x800000000000000LL )
              goto LABEL_5;
            v1 = v2 & 1;
            goto LABEL_4;
          }
          *(_QWORD *)&result = (v2 + 1) | *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
        }
        else
        {
          *(_QWORD *)&result = *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
        }
      }
      else
      {
        *(_QWORD *)&result = *((_QWORD *)&v21 + 1) & 0x8000000000000000LL | 0x7FF0000000000000LL;
      }
    }
    else
    {
      *(_QWORD *)&result = (v21 >> 60) & 0x7FFFFFFFFFFFFLL | 0x7FF8000000000000LL | *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
    }
  }
  else
  {
    v1 = v21 >> 60;
    if ( ((unsigned __int64)v21 & 0xFFFFFFFFFFFFFFFLL) >= 0x800000000000001LL )
    {
      v2 = 0x4000000000000001LL;
LABEL_4:
      v2 += v1;
LABEL_5:
      *(_QWORD *)&result = v2 | *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
      return result;
    }
    v2 = v1 + 0x4000000000000000LL;
    if ( (v21 & 0xFFFFFFFFFFFFFFFLL) != 0x800000000000000LL )
      goto LABEL_5;
    *(_QWORD *)&result = (v2 + (v1 & 1)) | *((_QWORD *)&v21 + 1) & 0x8000000000000000LL;
  }
  return result;
}


================================================================================
Function: sub_67EF4DC (0x67EF4DC)
================================================================================

float sub_67EF4DC()
{
  unsigned __int64 v0; // x10
  bool v1; // w12
  unsigned __int64 v2; // x11
  unsigned __int64 v3; // x9
  float result; // s0
  bool v5; // w11
  unsigned __int64 v6; // x10
  char v7; // w11
  char v8; // w10
  unsigned __int64 v9; // x12
  bool v10; // zf
  unsigned __int64 v11; // x14
  unsigned __int64 v12; // x11
  unsigned __int64 v13; // x16
  _BOOL8 v14; // x13
  __int64 v15; // x9
  unsigned __int64 v16; // x12
  __int64 v17; // x10
  bool v18; // w9
  bool v19; // w13
  unsigned __int64 v20; // [xsp+0h] [xbp-10h]
  unsigned __int64 v21; // [xsp+8h] [xbp-8h]

  v0 = v21 & 0x7FFFFFFFFFFFFFFFLL;
  if ( (v21 & 0x7FFFFFFFFFFFFFFFLL) - 0x3F81000000000000LL >= (v21 & 0x7FFFFFFFFFFFFFFFLL) - 0x407F000000000000LL )
  {
    v5 = v0 < 0x7FFF000000000000LL;
    if ( v0 == 0x7FFF000000000000LL )
      v5 = v20 == 0;
    if ( v5 )
    {
      if ( v0 <= 0x407EFFFFFFFFFFFFLL )
      {
        v6 = HIWORD(v0);
        if ( (unsigned int)v6 >= 0x3F11 )
        {
          v7 = v6 - 1;
          v8 = -127 - v6;
          v9 = v21 & 0xFFFFFFFFFFFFLL | 0x1000000000000LL;
          v10 = (v7 & 0x40) == 0LL;
          v11 = v20 << v7;
          v12 = (v9 << v7) | (v20 >> 1 >> ~v7);
          if ( v10 )
            v13 = v11;
          else
            v13 = 0LL;
          if ( !v10 )
            v12 = v11;
          v14 = (v13 | v12) != 0;
          v15 = ((2 * v9) << ~v8) | (v20 >> v8);
          if ( (v8 & 0x40) != 0 )
          {
            v15 = v9 >> v8;
            v16 = 0LL;
          }
          else
          {
            v16 = v9 >> v8;
          }
          v17 = v15 | v14;
          v18 = (v15 | v14) == 0;
          if ( (v16 & 0x1FFFFFF) == 0x1000000 )
            v19 = v18;
          else
            v19 = ((v16 >> 24) & 1) == 0;
          v3 = v16 >> 25;
          if ( v19 )
          {
            if ( v17 | v16 & 0x1FFFFFF ^ 0x1000000 )
              goto LABEL_6;
            LODWORD(result) = (((v16 & 0x2000000) != 0) + (unsigned int)(v16 >> 25)) | HIDWORD(v21) & 0x80000000;
          }
          else
          {
            LODWORD(result) = (v3 + 1) | HIDWORD(v21) & 0x80000000;
          }
        }
        else
        {
          LODWORD(result) = HIDWORD(v21) & 0x80000000;
        }
      }
      else
      {
        LODWORD(result) = HIDWORD(v21) & 0x80000000 | 0x7F800000;
      }
    }
    else
    {
      LODWORD(result) = (v21 >> 25) & 0x3FFFFF | 0x7FC00000 | HIDWORD(v21) & 0x80000000;
    }
  }
  else
  {
    v1 = v20 == 0;
    if ( (v21 & 0x1FFFFFF) != 0x1000000 )
      v1 = ((v21 >> 24) & 1) == 0;
    v2 = v21 >> 25;
    if ( !v1 )
    {
      LODWORD(v3) = v2 + 1073741825;
LABEL_6:
      LODWORD(result) = v3 | HIDWORD(v21) & 0x80000000;
      return result;
    }
    LODWORD(v3) = v2 + 0x40000000;
    if ( v20 | v21 & 0x1FFFFFF ^ 0x1000000 )
      goto LABEL_6;
    LODWORD(result) = (v3 + ((v21 & 0x2000000) != 0)) | HIDWORD(v21) & 0x80000000;
  }
  return result;
}


================================================================================
Function: sub_67EF6FC (0x67EF6FC)
================================================================================

__int64 __fastcall sub_67EF6FC(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 *a5)
{
  unsigned __int64 v5; // x8
  bool v6; // w9
  __int64 v7; // x9
  __int64 result; // x0
  int v9; // w12
  int v10; // w13
  int v11; // w9
  unsigned __int64 v12; // x11
  unsigned __int64 v13; // x10
  int v14; // w12
  __int64 v15; // x13
  __int128 v16; // t2
  char v18; // w10
  unsigned __int64 v19; // x11
  unsigned __int64 v20; // x13
  unsigned __int64 v21; // x9
  __int64 v22; // x14
  unsigned __int64 v23; // x8
  unsigned int v24; // w12
  unsigned __int64 v25; // x16
  unsigned __int64 v26; // x15
  unsigned __int64 v27; // x9
  unsigned __int64 v28; // x16
  unsigned __int64 v29; // x13
  __int64 v30; // x14
  unsigned __int64 v31; // x9
  unsigned __int64 v32; // x16
  unsigned __int64 v33; // x16
  unsigned __int64 v34; // x11
  unsigned __int64 v35; // x10

  v5 = a2;
  v6 = a3 <= a1;
  if ( a4 != a2 )
    v6 = a4 <= a2;
  if ( !v6 )
  {
    v7 = 0LL;
    if ( a5 )
    {
      *a5 = a1;
      a5[1] = a2;
      return 0LL;
    }
    return v7;
  }
  if ( a4 )
  {
    v9 = __clz(a4);
    v10 = __clz(a2);
    v11 = v9 - v10;
    v12 = a3 << ((unsigned __int8)v9 - (unsigned __int8)v10);
    if ( ((v9 - v10) & 0x40LL) != 0 )
      v13 = 0LL;
    else
      v13 = a3 << ((unsigned __int8)v9 - (unsigned __int8)v10);
    if ( (v11 & 0x40) == 0 )
      v12 = (a4 << ((unsigned __int8)v9 - (unsigned __int8)v10)) | (a3 >> 1 >> ~((unsigned __int8)v9
                                                                               - (unsigned __int8)v10));
    if ( v11 < 0 )
    {
      v7 = 0LL;
      if ( !a5 )
        return v7;
    }
    else
    {
      v7 = 0LL;
      v14 = ~v9 + v10;
      do
      {
        v15 = (__int64)(~v5 + __CFADD__(v13, ~a1) + v12) >> 63;
        v7 = 2 * v7 - v15;
        v5 = (__PAIR128__(v5, a1) - __PAIR128__(v15 & v12, v15 & v13)) >> 64;
        a1 -= v15 & v13;
        *((_QWORD *)&v16 + 1) = v12;
        *(_QWORD *)&v16 = v13;
        v13 = v16 >> 1;
        v12 >>= 1;
      }
      while ( !__CFADD__(v14++, 1) );
      if ( !a5 )
        return v7;
    }
    *a5 = a1;
    a5[1] = v5;
    return v7;
  }
  if ( a2 >= a3 )
  {
    v18 = __clz(a3);
    v19 = a3 << v18;
    v29 = a3 << v18 >> 32;
    v30 = (unsigned int)(a3 << v18);
    v24 = a1 << v18;
    v31 = ((a2 % a3) << v18) | (a1 >> 1 >> ~v18);
    v23 = v31 / v29;
    v32 = v31 % v29;
    do
    {
      if ( !HIDWORD(v23) && v23 * v30 <= ((a1 << v18 >> 32) | ((unsigned __int64)(unsigned int)v32 << 32)) )
        break;
      v32 += v29;
      --v23;
    }
    while ( !HIDWORD(v32) );
    v26 = ((a1 << v18 >> 32) | ((unsigned __int64)(unsigned int)v31 << 32)) - v23 * v19;
    v27 = v26 / v29;
    v33 = v26 % v29;
    do
    {
      if ( !HIDWORD(v27) && v27 * v30 <= (v24 | ((unsigned __int64)(unsigned int)v33 << 32)) )
        break;
      v33 += v29;
      --v27;
    }
    while ( !HIDWORD(v33) );
  }
  else
  {
    v18 = __clz(a3);
    v19 = a3 << v18;
    v20 = a3 << v18 >> 32;
    v21 = (a2 << v18) | (a1 >> 1 >> ~v18);
    v22 = (unsigned int)(a3 << v18);
    v23 = v21 / v20;
    v24 = a1 << v18;
    v25 = v21 % v20;
    do
    {
      if ( !HIDWORD(v23) && v23 * v22 <= ((a1 << v18 >> 32) | ((unsigned __int64)(unsigned int)v25 << 32)) )
        break;
      v25 += v20;
      --v23;
    }
    while ( !HIDWORD(v25) );
    v26 = ((a1 << v18 >> 32) | ((unsigned __int64)(unsigned int)v21 << 32)) - v23 * v19;
    v27 = v26 / v20;
    v28 = v26 % v20;
    do
    {
      if ( !HIDWORD(v27) && v27 * v22 <= (v24 | ((unsigned __int64)(unsigned int)v28 << 32)) )
        break;
      v28 += v20;
      --v27;
    }
    while ( !HIDWORD(v28) );
  }
  v34 = (v24 | ((unsigned __int64)(unsigned int)v26 << 32)) - v27 * v19;
  v7 = v27 + (v23 << 32);
  v35 = v34 >> v18;
  if ( !a5 )
    return v7;
  result = v7;
  *a5 = v35;
  a5[1] = 0LL;
  return result;
}


================================================================================
Function: sub_67EF95C (0x67EF95C)
================================================================================

__int64 __fastcall sub_67EF95C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_67EF6FC(a1, a2, a3, a4, 0LL);
}


================================================================================
Function: sub_67EF968 (0x67EF968)
================================================================================

_QWORD *__fastcall sub_67EF968(size_t *a1)
{
  unsigned __int64 v2; // x22
  _QWORD *v3; // x0
  unsigned __int64 v4; // x21
  _QWORD *v5; // x20
  unsigned __int64 v6; // x24
  __int64 v7; // x0
  __int64 v8; // x0
  pthread_key_t v9; // w0
  _QWORD *v10; // x22
  _QWORD *v11; // x20
  _QWORD *v12; // x22
  _QWORD *v13; // t1
  __int64 v14; // x20
  size_t v15; // x21
  __int64 v16; // x0
  const void *v17; // x1

  v2 = atomic_load(a1 + 2);
  if ( !v2 )
  {
    pthread_once(dword_795DEB8, (void (*)(void))sub_67EFB6C);
    pthread_mutex_lock(&stru_795DEC8);
    v2 = a1[2];
    if ( !v2 )
    {
      v2 = ++qword_795DEC0;
      atomic_store(qword_795DEC0, a1 + 2);
    }
    pthread_mutex_unlock(&stru_795DEC8);
    v3 = pthread_getspecific(dword_795DEB4);
    if ( v3 )
      goto LABEL_3;
LABEL_9:
    v6 = ((v2 + 17) & 0xFFFFFFFFFFFFFFF0LL) - 2;
    v8 = sub_677CA08(8 * v6 + 16);
    if ( !v8 )
      abort();
    v5 = (_QWORD *)v8;
    memset((void *)(v8 + 16), 0, 8 * v6);
    *v5 = 1LL;
    goto LABEL_11;
  }
  v3 = pthread_getspecific(dword_795DEB4);
  if ( !v3 )
    goto LABEL_9;
LABEL_3:
  v4 = v3[1];
  v5 = v3;
  if ( v4 >= v2 )
    goto LABEL_12;
  v6 = ((v2 + 17) & 0xFFFFFFFFFFFFFFF0LL) - 2;
  v7 = sub_677CB8C(v3, 8 * v6 + 16);
  if ( !v7 )
    abort();
  v5 = (_QWORD *)v7;
  memset((void *)(v7 + 8 * v4 + 16), 0, 8 * (v6 - v4));
LABEL_11:
  v9 = dword_795DEB4;
  v5[1] = v6;
  pthread_setspecific(v9, v5);
LABEL_12:
  v10 = &v5[v2 - 1];
  v13 = (_QWORD *)v10[2];
  v12 = v10 + 2;
  v11 = v13;
  if ( !v13 )
  {
    if ( a1[1] <= 8 )
      v14 = 8LL;
    else
      v14 = a1[1];
    if ( (v14 & (v14 - 1)) != 0 )
      abort();
    v15 = *a1;
    v16 = sub_677CA08(v14 + 7 + *a1);
    if ( !v16 )
      abort();
    v11 = (_QWORD *)((v16 + v14 + 7) & -v14);
    *(v11 - 1) = v16;
    v17 = (const void *)a1[3];
    if ( v17 )
      memcpy(v11, v17, v15);
    else
      memset(v11, 0, v15);
    *v12 = v11;
  }
  return v11;
}


================================================================================
Function: sub_67EFD50 (0x67EFD50)
================================================================================

char __fastcall sub_67EFD50(int a1, unsigned __int8 a2, atomic_uchar *a3)
{
  int v3; // w16

  if ( byte_795DEF0 )
  {
    atomic_compare_exchange_strong_explicit(a3, (unsigned __int8 *)&a1, a2, memory_order_release, memory_order_relaxed);
  }
  else
  {
    v3 = (unsigned __int8)a1;
    do
      a1 = __ldxr((unsigned __int8 *)a3);
    while ( a1 == v3 && __stlxr(a2, (unsigned __int8 *)a3) );
  }
  return a1;
}


================================================================================
Function: sub_67EFE10 (0x67EFE10)
================================================================================

__int16 __fastcall sub_67EFE10(int a1, unsigned __int16 a2, atomic_ushort *a3)
{
  int v3; // w16

  if ( byte_795DEF0 )
  {
    atomic_compare_exchange_strong(a3, (unsigned __int16 *)&a1, a2);
  }
  else
  {
    v3 = (unsigned __int16)a1;
    do
      a1 = __ldaxr((unsigned __int16 *)a3);
    while ( a1 == v3 && __stlxr(a2, (unsigned __int16 *)a3) );
  }
  return a1;
}


================================================================================
Function: sub_67EFE50 (0x67EFE50)
================================================================================

unsigned int __fastcall sub_67EFE50(unsigned int result, unsigned int a2, atomic_uint *a3)
{
  unsigned int v4; // w16

  if ( byte_795DEF0 )
  {
    atomic_compare_exchange_strong_explicit(a3, &result, a2, memory_order_relaxed, memory_order_relaxed);
  }
  else
  {
    v4 = result;
    do
      result = __ldxr((unsigned int *)a3);
    while ( result == v4 && __stxr(a2, (unsigned int *)a3) );
  }
  return result;
}


================================================================================
Function: sub_67EFF10 (0x67EFF10)
================================================================================

unsigned int __fastcall sub_67EFF10(unsigned int result, unsigned int a2, atomic_uint *a3)
{
  unsigned int v4; // w16

  if ( byte_795DEF0 )
  {
    atomic_compare_exchange_strong(a3, &result, a2);
  }
  else
  {
    v4 = result;
    do
      result = __ldaxr((unsigned int *)a3);
    while ( result == v4 && __stlxr(a2, (unsigned int *)a3) );
  }
  return result;
}


================================================================================
Function: sub_67EFF50 (0x67EFF50)
================================================================================

unsigned __int64 __fastcall sub_67EFF50(unsigned __int64 result, unsigned __int64 a2, atomic_ullong *a3)
{
  unsigned __int64 v4; // x16

  if ( byte_795DEF0 )
  {
    atomic_compare_exchange_strong_explicit(a3, &result, a2, memory_order_relaxed, memory_order_relaxed);
  }
  else
  {
    v4 = result;
    do
      result = __ldxr((unsigned __int64 *)a3);
    while ( result == v4 && __stxr(a2, (unsigned __int64 *)a3) );
  }
  return result;
}


================================================================================
Function: sub_67EFFD0 (0x67EFFD0)
================================================================================

unsigned __int64 __fastcall sub_67EFFD0(unsigned __int64 result, unsigned __int64 a2, atomic_ullong *a3)
{
  unsigned __int64 v4; // x16

  if ( byte_795DEF0 )
  {
    atomic_compare_exchange_strong_explicit(a3, &result, a2, memory_order_release, memory_order_relaxed);
  }
  else
  {
    v4 = result;
    do
      result = __ldxr((unsigned __int64 *)a3);
    while ( result == v4 && __stlxr(a2, (unsigned __int64 *)a3) );
  }
  return result;
}


================================================================================
Function: sub_67F0010 (0x67F0010)
================================================================================

unsigned __int64 __fastcall sub_67F0010(unsigned __int64 result, unsigned __int64 a2, atomic_ullong *a3)
{
  unsigned __int64 v4; // x16

  if ( byte_795DEF0 )
  {
    atomic_compare_exchange_strong(a3, &result, a2);
  }
  else
  {
    v4 = result;
    do
      result = __ldaxr((unsigned __int64 *)a3);
    while ( result == v4 && __stlxr(a2, (unsigned __int64 *)a3) );
  }
  return result;
}


================================================================================
Function: sub_67F0140 (0x67F0140)
================================================================================

__int64 __fastcall sub_67F0140(unsigned __int8 a1, atomic_uchar *a2)
{
  __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_exchange_explicit(a2, a1, memory_order_acquire);
  do
    result = __ldaxr((unsigned __int8 *)a2);
  while ( __stxr(a1, (unsigned __int8 *)a2) );
  return result;
}


================================================================================
Function: sub_67F01A0 (0x67F01A0)
================================================================================

__int64 __fastcall sub_67F01A0(unsigned int a1, atomic_uint *a2)
{
  __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_exchange_explicit(a2, a1, memory_order_acquire);
  do
    result = __ldaxr((unsigned int *)a2);
  while ( __stxr(a1, (unsigned int *)a2) );
  return result;
}


================================================================================
Function: sub_67F01D0 (0x67F01D0)
================================================================================

__int64 __fastcall sub_67F01D0(unsigned int a1, atomic_uint *a2)
{
  __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_exchange(a2, a1);
  do
    result = __ldaxr((unsigned int *)a2);
  while ( __stlxr(a1, (unsigned int *)a2) );
  return result;
}


================================================================================
Function: sub_67F0260 (0x67F0260)
================================================================================

unsigned __int64 __fastcall sub_67F0260(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_exchange(a2, a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_67F02C0 (0x67F02C0)
================================================================================

__int64 __fastcall sub_67F02C0(unsigned __int16 a1, atomic_ushort *a2)
{
  __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_relaxed);
  do
    result = __ldxr((unsigned __int16 *)a2);
  while ( __stxr(result + a1, (unsigned __int16 *)a2) );
  return result;
}


================================================================================
Function: sub_67F0350 (0x67F0350)
================================================================================

__int64 __fastcall sub_67F0350(unsigned __int16 a1, atomic_ushort *a2)
{
  __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_add(a2, a1);
  do
    result = __ldaxr((unsigned __int16 *)a2);
  while ( __stlxr(result + a1, (unsigned __int16 *)a2) );
  return result;
}


================================================================================
Function: sub_67F0380 (0x67F0380)
================================================================================

__int64 __fastcall sub_67F0380(unsigned int a1, atomic_uint *a2)
{
  __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_relaxed);
  do
    result = __ldxr((unsigned int *)a2);
  while ( __stxr(result + a1, (unsigned int *)a2) );
  return result;
}


================================================================================
Function: sub_67F03E0 (0x67F03E0)
================================================================================

__int64 __fastcall sub_67F03E0(unsigned int a1, atomic_uint *a2)
{
  __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_add(a2, a1);
  do
    result = __ldaxr((unsigned int *)a2);
  while ( __stlxr(result + a1, (unsigned int *)a2) );
  return result;
}


================================================================================
Function: sub_67F0410 (0x67F0410)
================================================================================

unsigned __int64 __fastcall sub_67F0410(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_relaxed);
  do
    result = __ldxr((unsigned __int64 *)a2);
  while ( __stxr(result + a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_67F0440 (0x67F0440)
================================================================================

unsigned __int64 __fastcall sub_67F0440(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_acquire);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stxr(result + a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_67F0470 (0x67F0470)
================================================================================

unsigned __int64 __fastcall sub_67F0470(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_add_explicit(a2, a1, memory_order_release);
  do
    result = __ldxr((unsigned __int64 *)a2);
  while ( __stlxr(result + a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_67F04A0 (0x67F04A0)
================================================================================

unsigned __int64 __fastcall sub_67F04A0(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_add(a2, a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(result + a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_67F0530 (0x67F0530)
================================================================================

unsigned __int64 __fastcall sub_67F0530(__int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_and(a2, ~a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(result & ~a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_67F05F0 (0x67F05F0)
================================================================================

unsigned __int64 __fastcall sub_67F05F0(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_or_explicit(a2, a1, memory_order_release);
  do
    result = __ldxr((unsigned __int64 *)a2);
  while ( __stlxr(result | a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_67F0620 (0x67F0620)
================================================================================

unsigned __int64 __fastcall sub_67F0620(unsigned __int64 a1, atomic_ullong *a2)
{
  unsigned __int64 result; // x0

  if ( byte_795DEF0 )
    return atomic_fetch_or(a2, a1);
  do
    result = __ldaxr((unsigned __int64 *)a2);
  while ( __stlxr(result | a1, (unsigned __int64 *)a2) );
  return result;
}


================================================================================
Function: sub_67F0650 (0x67F0650)
================================================================================

__int64 __fastcall sub_67F0650(_QWORD *a1)
{
  int v2; // w0
  int v4; // w0
  _BYTE v5[624]; // [xsp+0h] [xbp-4D0h] BYREF
  _BYTE v6[528]; // [xsp+270h] [xbp-260h] BYREF
  __int64 v7; // [xsp+480h] [xbp-50h] BYREF
  _BYTE v8[24]; // [xsp+488h] [xbp-48h] BYREF
  __int64 (__fastcall *v9)(__int64, __int64, _QWORD, _QWORD *, _BYTE *); // [xsp+4A0h] [xbp-30h]

  sub_67F44A0(v6);
  a1[2] = 0LL;
  a1[3] = 0LL;
  sub_67F0AC8(v5, v6);
  v2 = sub_67F0CDC(v5);
  if ( !v2 )
    return 5LL;
  while ( (v2 & 0x80000000) == 0 && !(unsigned int)sub_67F0D00(v5, v8) )
  {
    if ( v9 )
    {
      v4 = v9(1LL, 1LL, *a1, a1, v5);
      if ( v4 != 8 )
      {
        if ( v4 == 6 )
        {
          sub_67F0B74(v5, 4294967294LL, &v7);
          a1[3] = v7;
          return sub_67F0748(v6, v5, a1);
        }
        return 3LL;
      }
    }
    v2 = sub_67F0CDC(v5);
    if ( !v2 )
      return 5LL;
  }
  return 3LL;
}


================================================================================
Function: sub_67F0748 (0x67F0748)
================================================================================

__int64 __fastcall sub_67F0748(__int64 a1, __int64 a2, _QWORD *a3)
{
  int v5; // w0
  __int64 v6; // x1
  int v7; // w0
  __int64 v9; // [xsp+0h] [xbp-50h] BYREF
  __int64 (__fastcall *v10)(__int64, __int64, _QWORD, _QWORD *, __int64); // [xsp+18h] [xbp-38h]
  __int64 v11; // [xsp+48h] [xbp-8h] BYREF

  sub_67F0AC8(a2, a1);
  v5 = sub_67F0CDC(a2);
  if ( !v5 )
    return 5LL;
  while ( (v5 & 0x80000000) == 0 )
  {
    sub_67F0B74(a2, 4294967294LL, &v11);
    if ( (unsigned int)sub_67F0D00(a2, (__int64)&v9) )
      break;
    if ( v10 )
    {
      if ( v11 == a3[3] )
        v6 = 6LL;
      else
        v6 = 2LL;
      v7 = v10(1LL, v6, *a3, a3, a2);
      if ( v7 != 8 )
      {
        if ( v7 == 7 )
          sub_67F0D40(a2);
        return 2LL;
      }
      if ( v11 == a3[3] )
      {
        fprintf(
          (FILE *)((char *)&_sF + 304),
          "libunwind: %s - %s\n",
          "unwind_phase2",
          "during phase1 personality function said it would stop here, but now in phase2 it did not stop here");
        fflush((FILE *)((char *)&_sF + 304));
        abort();
      }
    }
    v5 = sub_67F0CDC(a2);
    if ( !v5 )
      return 5LL;
  }
  return 2LL;
}


================================================================================
Function: sub_67F0AC8 (0x67F0AC8)
================================================================================

__int64 __fastcall sub_67F0AC8(__int64 a1, _OWORD *a2)
{
  __int128 v4; // q0
  __int128 v5; // q2
  __int128 v6; // q3
  __int128 v7; // q0
  __int128 v8; // q2
  __int128 v9; // q3
  __int128 v10; // q0
  __int128 v11; // q2
  __int128 v12; // q3
  __int128 v13; // q1
  __int128 v14; // q2
  __int128 v15; // q3

  *(_QWORD *)a1 = off_6BE6300;
  *(_QWORD *)(a1 + 8) = &unk_795DEF1;
  memcpy((void *)(a1 + 16), a2, 0x110uLL);
  v4 = a2[20];
  v5 = a2[17];
  v6 = a2[18];
  *(_OWORD *)(a1 + 320) = a2[19];
  *(_OWORD *)(a1 + 336) = v4;
  *(_OWORD *)(a1 + 288) = v5;
  *(_OWORD *)(a1 + 304) = v6;
  v7 = a2[24];
  v8 = a2[21];
  v9 = a2[22];
  *(_OWORD *)(a1 + 384) = a2[23];
  *(_OWORD *)(a1 + 400) = v7;
  *(_OWORD *)(a1 + 352) = v8;
  *(_OWORD *)(a1 + 368) = v9;
  v10 = a2[28];
  v11 = a2[25];
  v12 = a2[26];
  *(_OWORD *)(a1 + 448) = a2[27];
  *(_OWORD *)(a1 + 464) = v10;
  *(_OWORD *)(a1 + 416) = v11;
  *(_OWORD *)(a1 + 432) = v12;
  v13 = a2[32];
  v15 = a2[29];
  v14 = a2[30];
  *(_OWORD *)(a1 + 512) = a2[31];
  *(_OWORD *)(a1 + 528) = v13;
  *(_OWORD *)(a1 + 603) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 480) = v15;
  *(_OWORD *)(a1 + 496) = v14;
  sub_67F15D4(a1, 0LL);
  return 0LL;
}


================================================================================
Function: sub_67F0B74 (0x67F0B74)
================================================================================

__int64 __fastcall sub_67F0B74(__int64 a1, unsigned int a2, __int64 *a3)
{
  __int64 v6; // x8
  __int64 result; // x0

  if ( ((*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL))(a1) & 1) == 0 )
    return 4294960754LL;
  v6 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 24LL))(a1, a2);
  result = 0LL;
  *a3 = v6;
  return result;
}


================================================================================
Function: sub_67F0CDC (0x67F0CDC)
================================================================================

__int64 __fastcall sub_67F0CDC(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 64LL))(a1);
}


================================================================================
Function: sub_67F0D00 (0x67F0D00)
================================================================================

__int64 __fastcall sub_67F0D00(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 72LL))(a1);
  if ( *(_QWORD *)(a2 + 8) )
    return 0LL;
  else
    return 4294960747LL;
}


================================================================================
Function: sub_67F0D40 (0x67F0D40)
================================================================================

__int64 __fastcall sub_67F0D40(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 80LL))(a1);
  return 4294960756LL;
}


================================================================================
Function: sub_67F0D68 (0x67F0D68)
================================================================================

const char *__fastcall sub_67F0D68(__int64 a1, unsigned int *a2, _QWORD *a3, __int64 a4, char a5)
{
  __int64 v9; // x23
  unsigned int *v10; // x24
  __int64 v11; // x8
  char *v12; // x1
  const char *result; // x0
  char *v14; // x23
  __int64 v15; // x3
  __int64 v16; // x24
  __int64 v17; // x0
  int v18; // w8
  __int64 v19; // x25
  __int64 v20; // x0
  unsigned int *v21; // x27
  int v22; // w8
  unsigned int *v23; // x26
  __int64 v24; // x3
  unsigned int *v25; // [xsp+18h] [xbp+18h] BYREF

  v10 = a2 + 1;
  v9 = *a2;
  if ( (_DWORD)v9 != -1 )
  {
    if ( *a2 )
      goto LABEL_3;
    return "FDE has zero length";
  }
  v9 = *(_QWORD *)(a2 + 1);
  v10 = a2 + 3;
  if ( !v9 )
    return "FDE has zero length";
LABEL_3:
  v11 = *v10;
  if ( !(_DWORD)v11 )
    return "FDE is really a CIE";
  v12 = (char *)v10 - v11;
  if ( (a5 & 1) != 0 )
  {
    if ( *(char **)a4 != v12 )
      return "CIE start does not match";
  }
  else
  {
    result = (const char *)sub_67F0EF8(a1, v12, a4);
    if ( result )
      return result;
  }
  v14 = (char *)v10 + v9;
  v15 = *(unsigned __int8 *)(a4 + 24);
  v25 = v10 + 1;
  v16 = sub_67F2B7C(a1, &v25, v14, v15, 0LL);
  v17 = sub_67F2B7C(a1, &v25, v14, *(_BYTE *)(a4 + 24) & 0xF, 0LL);
  v18 = *(unsigned __int8 *)(a4 + 49);
  v19 = v17;
  a3[5] = 0LL;
  if ( v18 )
  {
    v20 = sub_67F2E90(&v25, v14);
    v21 = v25;
    v22 = *(unsigned __int8 *)(a4 + 25);
    v23 = (unsigned int *)((char *)v25 + v20);
    if ( v22 != 255 )
    {
      if ( sub_67F2B7C(a1, &v25, v14, v22 & 0xF, 0LL) )
      {
        v24 = *(unsigned __int8 *)(a4 + 25);
        v25 = v21;
        a3[5] = sub_67F2B7C(a1, &v25, v14, v24, 0LL);
      }
    }
  }
  else
  {
    v23 = v25;
  }
  result = 0LL;
  a3[2] = v23;
  a3[3] = v16;
  *a3 = a2;
  a3[1] = v14 - (char *)a2;
  a3[4] = v19 + v16;
  return result;
}


================================================================================
Function: sub_67F0EF8 (0x67F0EF8)
================================================================================

const char *__fastcall sub_67F0EF8(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  char v4; // w20
  _BYTE *v6; // x8
  __int64 v7; // x9
  unsigned __int8 *v8; // x22
  const char *result; // x0
  __int64 v10; // x9
  int v11; // w24
  _BYTE *v12; // x23
  unsigned __int8 *v13; // x8
  int v15; // w0
  unsigned __int8 *v16; // x8
  int v17; // w11
  int v18; // w9
  unsigned __int8 *v19; // x10
  unsigned int v20; // w12
  unsigned int v21; // t1
  unsigned __int64 v22; // x13
  unsigned int v23; // w13
  __int64 v24; // x11
  char v29; // t1
  unsigned __int8 v30; // w3
  char v31; // w8
  unsigned __int8 v32; // t1
  char v33; // t1
  unsigned __int8 *v34; // x9
  unsigned __int8 *v35; // [xsp+18h] [xbp+18h] BYREF

  *(_BYTE *)(a3 + 51) = 0;
  *(_QWORD *)(a3 + 32) = 0LL;
  *(_QWORD *)(a3 + 40) = 0LL;
  *(_WORD *)(a3 + 48) = 0;
  v4 = (char)a2;
  *(_DWORD *)(a3 + 24) = 65280;
  *(_QWORD *)a3 = a2;
  v35 = a2;
  v6 = a2 + 4;
  v7 = *(unsigned int *)a2;
  v35 = a2 + 4;
  if ( (_DWORD)v7 != -1 )
  {
    v8 = &v6[v7];
    if ( v7 )
      goto LABEL_3;
    return 0LL;
  }
  v10 = *(_QWORD *)(a2 + 4);
  v6 = a2 + 12;
  v8 = &a2[v10 + 12];
  v35 = a2 + 12;
  if ( !v10 )
    return 0LL;
LABEL_3:
  if ( *(_DWORD *)v6 )
    return "CIE ID is not zero";
  v35 = v6 + 4;
  v11 = (unsigned __int8)v6[4];
  if ( (v11 & 0xFFFFFFFD) != 1 )
    return "CIE version is not 1 or 3";
  v12 = v6 + 5;
  v13 = v6 + 5;
  do
    v35 = v13;
  while ( *v13++ );
  v35 = v13;
  v15 = sub_67F2E90(&v35, v8);
  v16 = v35;
  v17 = 0;
  v18 = 0;
  *(_DWORD *)(a3 + 40) = v15;
  v19 = v16;
  do
  {
    if ( v19 == v8 )
    {
      fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    }
    v21 = *v19++;
    v20 = v21;
    ++v16;
    v22 = (unsigned __int64)(v21 & 0x7F) << v17;
    v17 += 7;
    v18 |= v22;
  }
  while ( (v21 & 0x80) != 0 );
  v23 = v17 - 7;
  v24 = -1LL << v17;
  v35 = v16;
  if ( ((v23 < 0x39) & (v20 >> 6)) == 0 )
    LODWORD(v24) = 0;
  *(_DWORD *)(a3 + 44) = v18 | v24;
  if ( v11 == 1 )
  {
    v35 = v16 + 1;
    *(_BYTE *)(a3 + 50) = *v19;
    if ( *v12 != 122 )
      goto LABEL_30;
LABEL_20:
    sub_67F2E90(&v35, v8);
    while ( 1 )
    {
      switch ( *v12 )
      {
        case 'B':
          __asm { BTI             j; jumptable 00000000067F10BC case 66 }
          *(_BYTE *)(a3 + 51) = 1;
          goto LABEL_22;
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'M':
        case 'N':
        case 'O':
        case 'Q':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '^':
        case '_':
        case '`':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
          goto LABEL_22;
        case 'L':
          __asm { BTI             j; jumptable 00000000067F10BC case 76 }
          ++v12;
          v29 = *v35++;
          *(_BYTE *)(a3 + 25) = v29;
          continue;
        case 'P':
          __asm { BTI             j; jumptable 00000000067F10BC case 80 }
          v32 = *v35;
          v30 = *v35++;
          v31 = (char)v35;
          *(_BYTE *)(a3 + 26) = v32;
          *(_BYTE *)(a3 + 27) = v31 - v4;
          *(_QWORD *)(a3 + 32) = sub_67F2B7C(a1, &v35, v8, v30, 0LL);
          ++v12;
          continue;
        case 'R':
          __asm { BTI             j; jumptable 00000000067F10BC case 82 }
          ++v12;
          v33 = *v35++;
          *(_BYTE *)(a3 + 24) = v33;
          continue;
        case 'S':
          __asm { BTI             j; jumptable 00000000067F10BC case 83 }
          *(_BYTE *)(a3 + 48) = 1;
          ++v12;
          continue;
        case 'z':
          __asm { BTI             j; jumptable 00000000067F10BC case 122 }
          *(_BYTE *)(a3 + 49) = 1;
          ++v12;
          continue;
        default:
          if ( !*v12 )
            goto LABEL_30;
LABEL_22:
          __asm { BTI             j; jumptable 00000000067F10BC cases 67-75,77-79,81,84-121 }
          ++v12;
          break;
      }
    }
  }
  *(_BYTE *)(a3 + 50) = sub_67F2E90(&v35, v8);
  if ( *v12 == 122 )
    goto LABEL_20;
LABEL_30:
  result = 0LL;
  v34 = v35;
  *(_QWORD *)(a3 + 8) = &v8[-*(_QWORD *)a3];
  *(_QWORD *)(a3 + 16) = v34;
  return result;
}


================================================================================
Function: sub_67F15D4 (0x67F15D4)
================================================================================

__int64 __fastcall sub_67F15D4(__int64 *a1, char a2)
{
  __int64 v2; // x8
  __int64 result; // x0
  __int64 v6; // x8
  unsigned __int64 v7; // x20
  __int64 *i; // x8
  __int64 v9; // x21
  __int64 v10; // x8
  __int64 v11; // x10
  __int64 v12; // x11
  __int128 v13; // q0
  __int64 v14; // x10
  _QWORD v15[7]; // [xsp+0h] [xbp-6B0h] BYREF
  __int64 v16; // [xsp+38h] [xbp-678h] BYREF
  __int64 v17; // [xsp+40h] [xbp-670h]
  __int128 v18; // [xsp+50h] [xbp-660h]
  __int64 v19; // [xsp+60h] [xbp-650h]
  _BYTE v20[16]; // [xsp+68h] [xbp-648h] BYREF
  __int64 v21; // [xsp+78h] [xbp-638h]
  _QWORD data[2]; // [xsp+98h] [xbp-618h] BYREF
  unsigned __int64 v23; // [xsp+A8h] [xbp-608h]

  v2 = *a1;
  *((_BYTE *)a1 + 618) = 0;
  result = (*(__int64 (__fastcall **)(__int64 *, __int64))(v2 + 24))(a1, 0xFFFFFFFFLL);
  if ( !result )
    goto LABEL_19;
  v6 = a1[1];
  v7 = result - (a2 & 1);
  v23 = v7;
  data[0] = v6;
  data[1] = v20;
  if ( !dl_iterate_phdr((int (*)(struct dl_phdr_info *, size_t, void *))sub_67F3D18, data)
    || !v21
    || (result = sub_67F3A24(a1, v7, v20, 0LL), (result & 1) == 0) )
  {
    pthread_rwlock_rdlock(&stru_795DEF4);
    for ( i = off_6C36860[0]; ; i += 4 )
    {
      if ( i >= off_6C36868 )
      {
        pthread_rwlock_unlock(&stru_795DEF4);
        goto LABEL_15;
      }
      if ( i[1] <= v7 && i[2] > v7 )
        break;
    }
    v9 = i[3];
    pthread_rwlock_unlock(&stru_795DEF4);
    if ( v9 )
    {
      if ( !sub_67F0D68(a1[1], v9, &v16, v15, 0LL) )
      {
        memset(data, 0, 0x618uLL);
        result = sub_67F1D64(a1[1], (int)&v16, (int)v15, v7, 4, data);
        if ( (result & 1) != 0 )
        {
          v10 = v19;
          v11 = v15[4];
          a1[76] = 0LL;
          v12 = (unsigned int)v23;
          a1[70] = v10;
          a1[71] = v11;
          v13 = v18;
          a1[72] = v12;
          *((_DWORD *)a1 + 148) = 50331648;
          v14 = v16;
          LODWORD(v10) = v17;
          *((_OWORD *)a1 + 34) = v13;
          a1[73] = 0LL;
          a1[75] = v14;
          *((_DWORD *)a1 + 149) = v10;
          return result;
        }
      }
    }
LABEL_15:
    result = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 24))(a1, 0xFFFFFFFFLL);
    if ( *(_DWORD *)result == -763358872 && *(_DWORD *)(result + 4) == -738197503 )
    {
      a1[76] = 0LL;
      *((_BYTE *)a1 + 618) = 1;
      *((_OWORD *)a1 + 36) = 0u;
      *((_OWORD *)a1 + 37) = 0u;
      *((_OWORD *)a1 + 34) = 0u;
      *((_OWORD *)a1 + 35) = 0u;
      return result;
    }
LABEL_19:
    *((_BYTE *)a1 + 616) = 1;
  }
  return result;
}


================================================================================
Function: sub_67F1D64 (0x67F1D64)
================================================================================

__int64 __fastcall sub_67F1D64(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, int a5, _BYTE *dest)
{
  unsigned __int8 **v6; // x28
  __int64 v7; // x11
  __int64 v11; // x9
  __int64 v12; // x10
  __int64 v13; // x12
  __int64 v14; // x11
  __int64 v15; // x13
  unsigned __int8 *v16; // x9
  unsigned __int8 *v17; // x24
  unsigned __int64 v18; // x21
  unsigned __int64 v20; // x25
  unsigned __int8 *v21; // x8
  int v22; // w10
  int v26; // w8
  unsigned __int8 *v27; // x9
  unsigned __int64 v28; // x26
  __int64 v29; // x0
  char *v30; // x8
  __int64 v31; // x9
  __int64 v32; // x9
  unsigned __int64 v33; // x0
  __int64 v34; // x8
  unsigned __int64 v35; // x0
  char *v36; // x9
  _BYTE *v37; // x9
  int v38; // t1
  unsigned __int64 v39; // x0
  char *v40; // x9
  _BYTE *v41; // x9
  int v42; // t1
  unsigned __int64 v43; // x26
  unsigned __int64 v44; // x0
  char *v45; // x8
  _QWORD *v46; // x26
  unsigned __int64 v47; // x26
  int v48; // w0
  unsigned __int64 v49; // x0
  unsigned __int64 v50; // x0
  char *v51; // x8
  int v52; // w9
  unsigned __int64 v53; // x0
  unsigned __int8 *v54; // x9
  int v55; // w10
  __int64 v56; // x8
  unsigned __int8 *v57; // x12
  unsigned int v58; // w11
  unsigned int v59; // t1
  unsigned __int64 v60; // x13
  char *v61; // x12
  _BOOL4 v62; // w14
  __int64 v63; // x10
  int v64; // w14
  __int64 v65; // x11
  __int64 v66; // x10
  __int64 v67; // x8
  int v68; // w9
  unsigned __int64 v69; // x0
  unsigned __int8 *v70; // x10
  int v71; // w9
  int v72; // w8
  unsigned __int8 *v73; // x12
  unsigned int v74; // w11
  unsigned int v75; // t1
  unsigned __int64 v76; // x13
  unsigned int v77; // w10
  __int64 v78; // x9
  int v79; // w10
  int v80; // w10
  int v81; // w9
  unsigned __int8 *v82; // x11
  unsigned int v83; // w12
  unsigned int v84; // t1
  unsigned __int64 v85; // x13
  unsigned int v86; // w11
  __int64 v87; // x10
  unsigned __int64 v88; // x0
  unsigned __int64 v89; // x26
  __int64 v90; // x0
  __int64 v91; // x9
  int v92; // w10
  unsigned __int64 v93; // x0
  unsigned __int8 *v94; // x9
  int v95; // w10
  __int64 v96; // x8
  unsigned __int8 *v97; // x12
  unsigned int v98; // w11
  unsigned int v99; // t1
  unsigned __int64 v100; // x13
  _BOOL4 v101; // w14
  __int64 v102; // x10
  int v103; // w14
  __int64 v104; // x11
  unsigned __int64 v105; // x0
  unsigned __int8 *v106; // x10
  __int64 v107; // x0
  __int64 v108; // x26
  int v109; // w8
  __int64 v110; // x0
  char *v111; // x8
  __int64 v112; // x9
  _BYTE *v113; // x8
  int v114; // t1
  __int64 v115; // x8
  char *v116; // x9
  unsigned __int64 v117; // x0
  unsigned __int64 v118; // x26
  __int64 v119; // x0
  __int64 v120; // x9
  __int64 **v122; // x8
  const char *v123; // x0
  size_t v124; // x1
  __int64 **v125; // x8
  FILE *v126; // x3
  _BYTE v127[12]; // [xsp+0h] [xbp-690h] BYREF
  int v128; // [xsp+Ch] [xbp-684h]
  __int64 *v129; // [xsp+10h] [xbp-680h]
  _OWORD *v130; // [xsp+18h] [xbp-678h]
  __int64 v131; // [xsp+20h] [xbp-670h]
  unsigned __int8 **v132; // [xsp+28h] [xbp-668h]
  _BYTE *v133; // [xsp+30h] [xbp-660h]
  _BYTE v134[568]; // [xsp+38h] [xbp-658h] BYREF
  __int64 v135; // [xsp+270h] [xbp-420h] BYREF
  unsigned __int8 *v136; // [xsp+650h] [xbp-40h] BYREF
  _QWORD v137[6]; // [xsp+658h] [xbp-38h] BYREF
  __int64 v138; // [xsp+688h] [xbp-8h] BYREF

  v6 = (unsigned __int8 **)v137;
  v7 = *(_QWORD *)(a3 + 16);
  v11 = *(_QWORD *)(a3 + 8) + *(_QWORD *)a3;
  v133 = 0LL;
  v12 = *a2;
  v13 = a2[1];
  v137[0] = v7;
  v137[1] = v11;
  v14 = a2[2];
  v15 = a2[3];
  v137[2] = -1LL;
  v137[3] = v14;
  v131 = a1;
  v132 = (unsigned __int8 **)&v138;
  v137[4] = v13 + v12;
  v137[5] = a4 - v15;
  v129 = &v135;
  v130 = dest + 568;
  while ( 1 )
  {
    v17 = v6[1];
    v18 = (unsigned __int64)v6[2];
    v136 = *v6;
    v16 = v136;
    _ZF = v136 >= v17 || v18 == 0;
    if ( !_ZF )
      break;
LABEL_2:
    v6 += 3;
    if ( v6 == v132 )
      return 1LL;
  }
  v20 = 0LL;
  while ( 2 )
  {
    v21 = v16 + 1;
    v22 = *v16;
    v136 = v16 + 1;
    switch ( v22 )
    {
      case 0:
        goto LABEL_113;
      case 1:
        __asm { BTI             j; jumptable 00000000067F1E3C case 1 }
        v20 = sub_67F2B7C(v131, &v136, v17, *(unsigned __int8 *)(a3 + 24), 0LL);
        goto LABEL_113;
      case 2:
        __asm { BTI             j; jumptable 00000000067F1E3C case 2 }
        v26 = v16[1];
        v27 = v16 + 2;
        goto LABEL_13;
      case 3:
        __asm { BTI             j; jumptable 00000000067F1E3C case 3 }
        v26 = *(unsigned __int16 *)(v16 + 1);
        v27 = v16 + 3;
        goto LABEL_13;
      case 4:
        __asm { BTI             j; jumptable 00000000067F1E3C case 4 }
        v26 = *(_DWORD *)(v16 + 1);
        v27 = v16 + 5;
LABEL_13:
        v20 += (unsigned int)(*(_DWORD *)(a3 + 40) * v26);
        v136 = v27;
        goto LABEL_113;
      case 5:
        __asm { BTI             j; jumptable 00000000067F1E3C case 5 }
        v28 = sub_67F2E90(&v136, v17);
        v29 = sub_67F2E90(&v136, v17);
        if ( v28 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_offset_extended DWARF unwind, reg too big\n";
          v124 = 70LL;
          goto LABEL_134;
        }
        v30 = &dest[16 * v28];
        v31 = *(int *)(a3 + 44);
        if ( !v30[28] )
        {
          *(_OWORD *)&v134[16 * v28 + 24] = *(_OWORD *)&dest[16 * v28 + 24];
          v30[28] = 1;
        }
        v32 = v29 * v31;
LABEL_107:
        v92 = 2;
LABEL_108:
        *((_DWORD *)v30 + 6) = v92;
        *((_QWORD *)v30 + 4) = v32;
        goto LABEL_113;
      case 6:
        __asm { BTI             j; jumptable 00000000067F1E3C case 6 }
        v33 = sub_67F2E90(&v136, v17);
        if ( v33 < 0x60 )
        {
          if ( dest[16 * v33 + 28] )
          {
            v34 = 16 * v33;
LABEL_112:
            *(_OWORD *)&dest[v34 + 24] = *(_OWORD *)&v134[v34 + 24];
          }
          goto LABEL_113;
        }
        v125 = off_6C00000;
        v123 = "libunwind: malformed DW_CFA_restore_extended DWARF unwind, reg too big\n";
        goto LABEL_124;
      case 7:
        __asm { BTI             j; jumptable 00000000067F1E3C case 7 }
        v35 = sub_67F2E90(&v136, v17);
        if ( v35 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_undefined DWARF unwind, reg too big\n";
LABEL_133:
          v124 = 64LL;
          goto LABEL_134;
        }
        v36 = &dest[16 * v35];
        v38 = (unsigned __int8)v36[28];
        v37 = v36 + 28;
        if ( !v38 )
        {
          *(_OWORD *)&v134[16 * v35 + 24] = *(_OWORD *)&dest[16 * v35 + 24];
          *v37 = 1;
        }
        *(_DWORD *)&dest[16 * v35 + 24] = 1;
        goto LABEL_113;
      case 8:
        __asm { BTI             j; jumptable 00000000067F1E3C case 8 }
        v39 = sub_67F2E90(&v136, v17);
        if ( v39 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_same_value DWARF unwind, reg too big\n";
          v124 = 65LL;
          goto LABEL_134;
        }
        v40 = &dest[16 * v39];
        v42 = (unsigned __int8)v40[28];
        v41 = v40 + 28;
        if ( !v42 )
        {
          *(_OWORD *)&v134[16 * v39 + 24] = *(_OWORD *)&dest[16 * v39 + 24];
          *v41 = 1;
        }
        *(_DWORD *)&dest[16 * v39 + 24] = 0;
        goto LABEL_113;
      case 9:
        __asm { BTI             j; jumptable 00000000067F1E3C case 9 }
        v43 = sub_67F2E90(&v136, v17);
        v44 = sub_67F2E90(&v136, v17);
        if ( v43 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_register DWARF unwind, reg too big\n";
          v124 = 63LL;
          goto LABEL_134;
        }
        if ( v44 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_register DWARF unwind, reg2 too big\n";
          goto LABEL_133;
        }
        v45 = &dest[16 * v43];
        if ( !v45[28] )
        {
          *(_OWORD *)&v134[16 * v43 + 24] = *(_OWORD *)&dest[16 * v43 + 24];
          v45[28] = 1;
        }
        *((_QWORD *)v45 + 4) = v44;
        *((_DWORD *)v45 + 6) = 4;
        goto LABEL_113;
      case 10:
        __asm { BTI             j; jumptable 00000000067F1E3C case 10 }
        *(_QWORD *)&v127[-1568] = v133;
        memcpy(&v127[-1560], dest, 0x618uLL);
        v133 = &v127[-1568];
        goto LABEL_113;
      case 11:
        __asm { BTI             j; jumptable 00000000067F1E3C case 11 }
        if ( !v133 )
          return 0LL;
        v46 = v133;
        memcpy(dest, v133 + 8, 0x618uLL);
        v133 = (_BYTE *)*v46;
        goto LABEL_113;
      case 12:
        __asm { BTI             j; jumptable 00000000067F1E3C case 12 }
        v47 = sub_67F2E90(&v136, v17);
        v48 = sub_67F2E90(&v136, v17);
        if ( v47 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_def_cfa DWARF unwind, reg too big\n";
          v124 = 62LL;
          goto LABEL_134;
        }
        *(_DWORD *)dest = v47;
        *((_DWORD *)dest + 1) = v48;
        goto LABEL_113;
      case 13:
        __asm { BTI             j; jumptable 00000000067F1E3C case 13 }
        v49 = sub_67F2E90(&v136, v17);
        if ( v49 >= 0x60 )
        {
          v125 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_def_cfa_register DWARF unwind, reg too big\n";
LABEL_124:
          v126 = (FILE *)(v125[141] + 38);
          v124 = 71LL;
          goto LABEL_135;
        }
        *(_DWORD *)dest = v49;
        goto LABEL_113;
      case 14:
        __asm { BTI             j; jumptable 00000000067F1E3C case 14 }
        *((_DWORD *)dest + 1) = sub_67F2E90(&v136, v17);
        goto LABEL_113;
      case 15:
        __asm { BTI             j; jumptable 00000000067F1E3C case 15 }
        *(_DWORD *)dest = 0;
        *((_QWORD *)dest + 1) = v21;
        goto LABEL_91;
      case 16:
        __asm { BTI             j; jumptable 00000000067F1E3C case 16 }
        v50 = sub_67F2E90(&v136, v17);
        if ( v50 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_expression DWARF unwind, reg too big\n";
          v124 = 65LL;
          goto LABEL_134;
        }
        v51 = &dest[16 * v50];
        if ( !v51[28] )
        {
          *(_OWORD *)&v134[16 * v50 + 24] = *(_OWORD *)&dest[16 * v50 + 24];
          v51[28] = 1;
        }
        v52 = 5;
LABEL_90:
        v106 = v136;
        *((_DWORD *)v51 + 6) = v52;
        *((_QWORD *)v51 + 4) = v106;
LABEL_91:
        v107 = sub_67F2E90(&v136, v17);
        v136 += v107;
        goto LABEL_113;
      case 17:
        __asm { BTI             j; jumptable 00000000067F1E3C case 17 }
        v53 = sub_67F2E90(&v136, v17);
        if ( v53 < 0x60 )
        {
          v54 = v136;
          v55 = 0;
          v56 = 0LL;
          v57 = v136;
          do
          {
            if ( v57 == v17 )
            {
              fprintf(
                (FILE *)((char *)&_sF + 304),
                "libunwind: %s - %s\n",
                "getSLEB128",
                "truncated sleb128 expression");
              fflush((FILE *)((char *)&_sF + 304));
              abort();
            }
            v59 = *v57++;
            v58 = v59;
            ++v54;
            v60 = (unsigned __int64)(v59 & 0x7F) << v55;
            v55 += 7;
            v56 |= v60;
          }
          while ( (v59 & 0x80) != 0 );
          v61 = &dest[16 * v53];
          v62 = (unsigned int)(v55 - 7) < 0x39;
          v63 = -1LL << v55;
          _ZF = (v62 & (v58 >> 6)) == 0;
          v64 = (unsigned __int8)v61[28];
          if ( _ZF )
            v65 = 0LL;
          else
            v65 = v63;
          v66 = *(int *)(a3 + 44);
          v136 = v54;
          if ( !v64 )
          {
            *(_OWORD *)&v134[16 * v53 + 24] = *(_OWORD *)&dest[16 * v53 + 24];
            v61[28] = 1;
          }
          v67 = v56 | v65;
          v68 = 2;
LABEL_85:
          *((_DWORD *)v61 + 6) = v68;
          *((_QWORD *)v61 + 4) = v67 * v66;
LABEL_113:
          __asm { BTI             j; jumptable 00000000067F1E3C case 0 }
          v16 = v136;
          if ( v136 >= v17 || v20 >= v18 )
            goto LABEL_2;
          continue;
        }
        v122 = off_6C00000;
        v123 = "libunwind: malformed DW_CFA_offset_extended_sf DWARF unwind, reg too big\n";
        v124 = 73LL;
LABEL_134:
        v126 = (FILE *)(v122[141] + 38);
LABEL_135:
        fwrite(v123, v124, 1uLL, v126);
        return 0LL;
      case 18:
        __asm { BTI             j; jumptable 00000000067F1E3C case 18 }
        v69 = sub_67F2E90(&v136, v17);
        v70 = v136;
        v71 = 0;
        v72 = 0;
        v73 = v136;
        do
        {
          if ( v73 == v17 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v75 = *v73++;
          v74 = v75;
          ++v70;
          v76 = (unsigned __int64)(v75 & 0x7F) << v71;
          v71 += 7;
          v72 |= v76;
        }
        while ( (v75 & 0x80) != 0 );
        v136 = v70;
        if ( v69 > 0x5F )
        {
          v123 = "libunwind: malformed DW_CFA_def_cfa_sf DWARF unwind, reg too big\n";
          v124 = 65LL;
          v126 = (FILE *)((char *)&_sF + 304);
          goto LABEL_135;
        }
        v77 = v71 - 7;
        v78 = -1LL << v71;
        _ZF = ((v77 < 0x39) & (v74 >> 6)) == 0;
        v79 = *(_DWORD *)(a3 + 44);
        if ( _ZF )
          LODWORD(v78) = 0;
        *(_DWORD *)dest = v69;
        *((_DWORD *)dest + 1) = v79 * (v72 | v78);
        goto LABEL_113;
      case 19:
        __asm { BTI             j; jumptable 00000000067F1E3C case 19 }
        v80 = 0;
        v81 = 0;
        v82 = v21;
        do
        {
          if ( v82 == v17 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v84 = *v82++;
          v83 = v84;
          ++v21;
          v85 = (unsigned __int64)(v84 & 0x7F) << v80;
          v80 += 7;
          v81 |= v85;
        }
        while ( (v84 & 0x80) != 0 );
        v86 = v80 - 7;
        v87 = -1LL << v80;
        v136 = v21;
        if ( ((v86 < 0x39) & (v83 >> 6)) == 0 )
          LODWORD(v87) = 0;
        *((_DWORD *)dest + 1) = *(_DWORD *)(a3 + 44) * (v81 | v87);
        goto LABEL_113;
      case 20:
        __asm { BTI             j; jumptable 00000000067F1E3C case 20 }
        v88 = sub_67F2E90(&v136, v17);
        v89 = v88;
        if ( v88 >= 0x60 )
        {
          fprintf(
            (FILE *)((char *)&_sF + 304),
            "libunwind: malformed DW_CFA_val_offset DWARF unwind, reg (%lu) out of range\n\n",
            v88);
          return 0LL;
        }
        v90 = sub_67F2E90(&v136, v17);
        v30 = &dest[16 * v89];
        v91 = *(int *)(a3 + 44);
        if ( !v30[28] )
        {
          *(_OWORD *)&v134[16 * v89 + 24] = *(_OWORD *)&dest[16 * v89 + 24];
          v30[28] = 1;
        }
        v32 = v90 * v91;
        v92 = 3;
        goto LABEL_108;
      case 21:
        __asm { BTI             j; jumptable 00000000067F1E3C case 21 }
        v93 = sub_67F2E90(&v136, v17);
        if ( v93 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_val_offset_sf DWARF unwind, reg too big\n";
          v124 = 68LL;
          goto LABEL_134;
        }
        v94 = v136;
        v95 = 0;
        v96 = 0LL;
        v97 = v136;
        do
        {
          if ( v97 == v17 )
          {
            fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
            fflush((FILE *)((char *)&_sF + 304));
            abort();
          }
          v99 = *v97++;
          v98 = v99;
          ++v94;
          v100 = (unsigned __int64)(v99 & 0x7F) << v95;
          v95 += 7;
          v96 |= v100;
        }
        while ( (v99 & 0x80) != 0 );
        v61 = &dest[16 * v93];
        v101 = (unsigned int)(v95 - 7) < 0x39;
        v102 = -1LL << v95;
        _ZF = (v101 & (v98 >> 6)) == 0;
        v103 = (unsigned __int8)v61[28];
        if ( _ZF )
          v104 = 0LL;
        else
          v104 = v102;
        v66 = *(int *)(a3 + 44);
        v136 = v94;
        if ( !v103 )
        {
          *(_OWORD *)&v134[16 * v93 + 24] = *(_OWORD *)&dest[16 * v93 + 24];
          v61[28] = 1;
        }
        v67 = v96 | v104;
        v68 = 3;
        goto LABEL_85;
      case 22:
        __asm { BTI             j; jumptable 00000000067F1E3C case 22 }
        v105 = sub_67F2E90(&v136, v17);
        if ( v105 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_val_expression DWARF unwind, reg too big\n";
          v124 = 69LL;
          goto LABEL_134;
        }
        v51 = &dest[16 * v105];
        if ( !v51[28] )
        {
          *(_OWORD *)&v134[16 * v105 + 24] = *(_OWORD *)&dest[16 * v105 + 24];
          v51[28] = 1;
        }
        v52 = 6;
        goto LABEL_90;
      case 45:
        __asm { BTI             j; jumptable 00000000067F1E3C case 45 }
        if ( a5 == 4 )
        {
          if ( !dest[572] )
          {
            *(_OWORD *)v129 = *v130;
            dest[572] = 1;
          }
          *((_QWORD *)dest + 72) ^= 1uLL;
        }
        goto LABEL_113;
      case 46:
        __asm { BTI             j; jumptable 00000000067F1E3C case 46 }
        *((_DWORD *)dest + 4) = sub_67F2E90(&v136, v17);
        goto LABEL_113;
      case 47:
        __asm { BTI             j; jumptable 00000000067F1E3C case 47 }
        v117 = sub_67F2E90(&v136, v17);
        if ( v117 >= 0x60 )
        {
          v122 = off_6C00000;
          v123 = "libunwind: malformed DW_CFA_GNU_negative_offset_extended DWARF unwind, reg too big\n";
          v124 = 83LL;
          goto LABEL_134;
        }
        v118 = v117;
        v119 = sub_67F2E90(&v136, v17);
        v30 = &dest[16 * v118];
        v120 = *(int *)(a3 + 44);
        if ( !v30[28] )
        {
          *(_OWORD *)&v134[16 * v118 + 24] = *(_OWORD *)&dest[16 * v118 + 24];
          v30[28] = 1;
        }
        v32 = -(v119 * v120);
        goto LABEL_107;
      default:
        __asm { BTI             j; jumptable 00000000067F1E3C default case, cases 23-44 }
        v108 = v22 & 0x3F;
        v109 = v22 & 0xC0;
        if ( v109 == 64 )
        {
          v20 += (unsigned int)(*(_DWORD *)(a3 + 40) * v108);
          goto LABEL_113;
        }
        if ( v109 != 192 )
        {
          if ( v109 != 128 )
            return 0LL;
          v128 = a5;
          v110 = sub_67F2E90(&v136, v17);
          v111 = &dest[16 * (unsigned int)v108];
          v112 = *(int *)(a3 + 44);
          v114 = (unsigned __int8)v111[28];
          v113 = v111 + 28;
          if ( !v114 )
          {
            *(_OWORD *)&v134[16 * (unsigned int)v108 + 24] = *(_OWORD *)&dest[16 * (unsigned int)v108 + 24];
            *v113 = 1;
          }
          v115 = v110 * v112;
          v116 = &dest[16 * (unsigned int)v108];
          a5 = v128;
          *((_DWORD *)v116 + 6) = 2;
          *((_QWORD *)v116 + 4) = v115;
          goto LABEL_113;
        }
        if ( !dest[16 * v108 + 28] )
          goto LABEL_113;
        v34 = 16 * v108;
        goto LABEL_112;
    }
  }
}


================================================================================
Function: sub_67F2B7C (0x67F2B7C)
================================================================================

unsigned __int64 __fastcall sub_67F2B7C(
        __int64 a1,
        unsigned __int8 **a2,
        unsigned __int8 *a3,
        unsigned __int8 a4,
        __int64 a5)
{
  unsigned __int8 *v5; // x21
  unsigned __int64 result; // x0
  int v13; // w10
  __int64 v14; // x8
  unsigned __int8 *v15; // x9
  unsigned __int8 *v16; // x11
  unsigned int v17; // w12
  unsigned int v18; // t1
  unsigned __int64 v19; // x13
  unsigned int v20; // w11
  __int64 v21; // x10

  v5 = *a2;
  switch ( a4 & 0xF )
  {
    case 0:
    case 4:
    case 0xC:
      __asm { BTI             j; jumptable 00000000067F2BBC cases 0,4,12 }
      result = *(_QWORD *)v5;
      *a2 = v5 + 8;
      break;
    case 1:
      __asm { BTI             j; jumptable 00000000067F2BBC case 1 }
      result = sub_67F2E90(a2, a3);
      break;
    case 2:
      __asm { BTI             j; jumptable 00000000067F2BBC case 2 }
      result = *(unsigned __int16 *)v5;
      *a2 = v5 + 2;
      break;
    case 3:
      __asm { BTI             j; jumptable 00000000067F2BBC case 3 }
      result = *(unsigned int *)v5;
      *a2 = v5 + 4;
      break;
    case 9:
      __asm { BTI             j; jumptable 00000000067F2BBC case 9 }
      v13 = 0;
      v14 = 0LL;
      v15 = *a2;
      v16 = *a2;
      do
      {
        if ( v16 == a3 )
        {
          fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getSLEB128", "truncated sleb128 expression");
          fflush((FILE *)((char *)&_sF + 304));
          abort();
        }
        v18 = *v16++;
        v17 = v18;
        ++v15;
        v19 = (unsigned __int64)(v18 & 0x7F) << v13;
        v13 += 7;
        v14 |= v19;
      }
      while ( (v18 & 0x80) != 0 );
      v20 = v13 - 7;
      v21 = -1LL << v13;
      *a2 = v15;
      if ( ((v20 < 0x39) & (v17 >> 6)) == 0 )
        v21 = 0LL;
      result = v14 | v21;
      break;
    case 0xA:
      __asm { BTI             j; jumptable 00000000067F2BBC case 10 }
      result = *(__int16 *)v5;
      *a2 = v5 + 2;
      break;
    case 0xB:
      __asm { BTI             j; jumptable 00000000067F2BBC case 11 }
      result = *(int *)v5;
      *a2 = v5 + 4;
      break;
    default:
      __asm { BTI             j; jumptable 00000000067F2BBC default case, cases 5-8 }
      fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getEncodedP", "unknown pointer encoding");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
  switch ( (a4 >> 4) & 7 )
  {
    case 0:
      goto LABEL_16;
    case 1:
      __asm { BTI             j; jumptable 00000000067F2CB8 case 1 }
      result += (unsigned __int64)v5;
LABEL_16:
      __asm { BTI             j; jumptable 00000000067F2CB8 case 0 }
      if ( (a4 & 0x80) != 0 )
        return *(_QWORD *)result;
      return result;
    case 2:
      __asm { BTI             j; jumptable 00000000067F2CB8 case 2 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getEncodedP",
        "DW_EH_PE_textrel pointer encoding not supported");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    case 3:
      __asm { BTI             j; jumptable 00000000067F2CB8 case 3 }
      if ( !a5 )
      {
        fprintf(
          (FILE *)((char *)&_sF + 304),
          "libunwind: %s - %s\n",
          "getEncodedP",
          "DW_EH_PE_datarel is invalid with a datarelBase of 0");
        fflush((FILE *)((char *)&_sF + 304));
        abort();
      }
      result += a5;
      if ( (a4 & 0x80) == 0 )
        return result;
      return *(_QWORD *)result;
    case 4:
      __asm { BTI             j; jumptable 00000000067F2CB8 case 4 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getEncodedP",
        "DW_EH_PE_funcrel pointer encoding not supported");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    case 5:
      __asm { BTI             j; jumptable 00000000067F2CB8 case 5 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getEncodedP",
        "DW_EH_PE_aligned pointer encoding not supported");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    default:
      fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getEncodedP", "unknown pointer encoding");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
}


================================================================================
Function: sub_67F2E90 (0x67F2E90)
================================================================================

unsigned __int64 __fastcall sub_67F2E90(_BYTE **a1, _BYTE *a2)
{
  _BYTE *v2; // x9
  _BYTE *v4; // x10
  unsigned __int64 result; // x0
  unsigned __int8 v6; // w11
  _BYTE *v7; // x10

  v2 = *a1;
  if ( *a1 == a2 )
    goto LABEL_25;
  v4 = v2 + 1;
  result = *v2 & 0x7F;
  if ( (*v2 & 0x80) == 0 )
  {
LABEL_3:
    *a1 = v4;
    return result;
  }
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | ((unsigned __int64)(v2[1] & 0x7F) << 7);
  v4 = v2 + 2;
  if ( ((char)v2[1] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14);
  v4 = v2 + 3;
  if ( ((char)v2[2] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFFFFFFFFF01FFFFFLL | ((unsigned __int64)(v2[3] & 0x7F) << 21);
  v4 = v2 + 4;
  if ( ((char)v2[3] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFFFFFFF8001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28);
  v4 = v2 + 5;
  if ( ((char)v2[4] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFFFFFC00001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0xFFFFFC07FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35);
  v4 = v2 + 6;
  if ( ((char)v2[5] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFFFE0000001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0xFFFE0007FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35) & 0xFFFE03FFFFFFFFFFLL | ((unsigned __int64)(v2[6] & 0x7F) << 42);
  v4 = v2 + 7;
  if ( ((char)v2[6] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0xFF000000001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0xFF000007FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35) & 0xFF0003FFFFFFFFFFLL | ((unsigned __int64)(v2[6] & 0x7F) << 42) & 0xFF01FFFFFFFFFFFFLL | ((unsigned __int64)(v2[7] & 0x7F) << 49);
  v4 = v2 + 8;
  if ( ((char)v2[7] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
    goto LABEL_25;
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0x80000000001FFFFFLL | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0x80000007FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35) & 0x800003FFFFFFFFFFLL | ((unsigned __int64)(v2[6] & 0x7F) << 42) & 0x8001FFFFFFFFFFFFLL | ((unsigned __int64)(v2[7] & 0x7F) << 49) & 0x80FFFFFFFFFFFFFFLL | ((unsigned __int64)(v2[8] & 0x7F) << 56);
  v4 = v2 + 9;
  if ( ((char)v2[8] & 0x80000000) == 0 )
    goto LABEL_3;
  if ( v4 == a2 )
  {
LABEL_25:
    fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getULEB128", "truncated uleb128 expression");
    fflush((FILE *)((char *)&_sF + 304));
    abort();
  }
  v6 = *v4;
  if ( (*v4 & 0x7E) != 0 )
  {
LABEL_26:
    fprintf((FILE *)((char *)&_sF + 304), "libunwind: %s - %s\n", "getULEB128", "malformed uleb128 expression");
    fflush((FILE *)((char *)&_sF + 304));
    abort();
  }
  v7 = v2 + 10;
  if ( (v6 & 0x80) != 0 )
  {
    if ( v7 == a2 )
      goto LABEL_25;
    goto LABEL_26;
  }
  result = *v2 & 0x7F | (unsigned __int64)(((v2[1] & 0x7F) << 7) & 0x3FFF) | ((unsigned __int64)(v2[2] & 0x7F) << 14) & 0x1FFFFF | ((v2[3] & 0x7F) << 21) & 0xFFFFFFF | ((unsigned __int64)(v2[4] & 0x7F) << 28) & 0x7FFFFFFFFLL | ((unsigned __int64)(v2[5] & 0x7F) << 35) & 0x3FFFFFFFFFFLL | ((unsigned __int64)(v2[6] & 0x7F) << 42) & 0x1FFFFFFFFFFFFLL | ((unsigned __int64)(v2[7] & 0x7F) << 49) & 0xFFFFFFFFFFFFFFLL | ((unsigned __int64)(v2[8] & 0x7F) << 56) & 0x7FFFFFFFFFFFFFFFLL | ((unsigned __int64)v6 << 63);
  *a1 = v7;
  return result;
}


================================================================================
Function: sub_67F3A24 (0x67F3A24)
================================================================================

__int64 __fastcall sub_67F3A24(__int64 a1, unsigned __int64 a2, __int64 *a3, unsigned int a4)
{
  __int64 v8; // x2
  int v9; // w24
  __int64 v10; // x23
  __int64 *v11; // x8
  __int64 v12; // x23
  char v13; // w8
  __int64 result; // x0
  __int64 v15; // x25
  __int64 v16; // d0
  __int64 v17; // x9
  __int64 v18; // x10
  __int64 v19; // x22
  int v20; // w8
  __int64 v21; // x23
  __int64 v22; // x24
  __int64 *v23; // x8
  __int64 *v24; // x19
  size_t v25; // x21
  signed __int64 v26; // x28
  signed __int64 v27; // x27
  char *v28; // x20
  __int64 v29; // [xsp+0h] [xbp-6A0h]
  _BYTE v30[32]; // [xsp+18h] [xbp-688h] BYREF
  __int64 v31; // [xsp+38h] [xbp-668h]
  __int64 v32; // [xsp+50h] [xbp-650h] BYREF
  __int64 v33; // [xsp+58h] [xbp-648h]
  __int64 v34; // [xsp+68h] [xbp-638h]
  __int128 v35; // [xsp+70h] [xbp-630h]
  _BYTE s[16]; // [xsp+80h] [xbp-620h] BYREF
  unsigned int v37; // [xsp+90h] [xbp-610h]

  if ( a4 && (sub_67F3ED8(*(_QWORD *)(a1 + 8), a2, a3[2], a3[3], a3[2] + a4, &v32, v30) & 1) != 0
    || (v8 = a3[4]) != 0 && (sub_67F40A0(*(_QWORD *)(a1 + 8), a2, v8, *((unsigned int *)a3 + 10), &v32, v30) & 1) != 0 )
  {
    v9 = 0;
    goto LABEL_22;
  }
  v10 = *a3;
  pthread_rwlock_rdlock(&stru_795DEF4);
  v11 = off_6C36860[0];
  if ( off_6C36860[0] >= off_6C36868 )
  {
LABEL_20:
    pthread_rwlock_unlock(&stru_795DEF4);
    goto LABEL_21;
  }
  if ( v10 == -1 )
  {
    while ( v11[1] > a2 || v11[2] <= a2 )
    {
      v11 += 4;
      if ( v11 >= off_6C36868 )
        goto LABEL_20;
    }
  }
  else
  {
    while ( *v11 != v10 || v11[1] > a2 || v11[2] <= a2 )
    {
      v11 += 4;
      if ( v11 >= off_6C36868 )
        goto LABEL_20;
    }
  }
  v12 = v11[3];
  pthread_rwlock_unlock(&stru_795DEF4);
  if ( !v12 || (sub_67F3ED8(*(_QWORD *)(a1 + 8), a2, a3[2], a3[3], v12, &v32, v30) & 1) == 0 )
  {
LABEL_21:
    v13 = sub_67F3ED8(*(_QWORD *)(a1 + 8), a2, a3[2], a3[3], 0LL, &v32, v30);
    v9 = 0;
    result = 0LL;
    if ( (v13 & 1) == 0 )
      return result;
    goto LABEL_22;
  }
  v9 = 1;
LABEL_22:
  v15 = *a3;
  memset(s, 0, 0x618uLL);
  if ( (sub_67F1D64(*(_QWORD *)(a1 + 8), &v32, (__int64)v30, a2, 4, s) & 1) == 0 )
    return 0LL;
  v16 = v35;
  v17 = v31;
  v18 = v37;
  result = 1LL;
  *(_OWORD *)(a1 + 552) = v35;
  v19 = v34;
  *(_QWORD *)(a1 + 568) = v17;
  *(_QWORD *)(a1 + 576) = v18;
  *(_DWORD *)(a1 + 592) = 50331648;
  v21 = v32;
  v20 = v33;
  *(_QWORD *)(a1 + 544) = v19;
  *(_QWORD *)(a1 + 584) = 0LL;
  *(_QWORD *)(a1 + 608) = v15;
  *(_QWORD *)(a1 + 600) = v21;
  *(_DWORD *)(a1 + 596) = v20;
  if ( ((a4 != 0) | v9) != 1 && !a3[4] )
  {
    v22 = *a3;
    v29 = v16;
    pthread_rwlock_wrlock(&stru_795DEF4);
    v23 = off_6C36868;
    if ( off_6C36868 >= (__int64 *)off_6C36870 )
    {
      v24 = off_6C36860[0];
      v25 = off_6C36870 - (_UNKNOWN *)off_6C36860[0];
      v26 = (off_6C36870 - (_UNKNOWN *)off_6C36860[0]) >> 5;
      v27 = (off_6C36870 - (_UNKNOWN *)off_6C36860[0]) >> 3;
      v28 = (char *)sub_677CA08(4 * (off_6C36870 - (_UNKNOWN *)off_6C36860[0]));
      memcpy(v28, v24, v25);
      if ( v24 != &qword_795DF30 )
        sub_677CBEC((unsigned __int64)v24);
      v23 = (__int64 *)&v28[32 * v26];
      off_6C36870 = &v28[32 * v27];
      off_6C36860[0] = (__int64 *)v28;
    }
    *v23 = v22;
    v23[1] = v19;
    v23[3] = v21;
    v23[2] = v29;
    off_6C36868 = v23 + 4;
    pthread_rwlock_unlock(&stru_795DEF4);
    return 1LL;
  }
  return result;
}


================================================================================
Function: sub_67F3ED8 (0x67F3ED8)
================================================================================

__int64 __fastcall sub_67F3ED8(
        __int64 a1,
        unsigned __int64 a2,
        _BYTE *a3,
        __int64 a4,
        _BYTE *a5,
        _QWORD *a6,
        _BYTE *a7)
{
  _BYTE *v7; // x22
  unsigned __int64 v8; // x27
  _BYTE *v14; // x26
  unsigned int *v15; // x8
  __int64 v16; // x9
  __int64 v17; // x10
  char *v18; // x1
  unsigned __int8 v19; // w3
  unsigned __int64 v20; // x25
  unsigned __int64 v21; // x0
  unsigned __int64 v22; // x28
  int v23; // w8
  unsigned __int64 v24; // x0
  _BYTE *v25; // x24
  int v26; // w8
  _BYTE *v27; // x23
  unsigned __int8 v28; // w3
  __int64 result; // x0
  _BYTE *i; // [xsp+8h] [xbp-8h] BYREF

  if ( a5 )
    v7 = a5;
  else
    v7 = a3;
  if ( a4 == -1 )
    v8 = -1LL;
  else
    v8 = (unsigned __int64)&a3[a4];
  for ( i = v7; (unsigned __int64)v7 < v8; i = v7 )
  {
    v14 = v7;
    v15 = (unsigned int *)(v7 + 4);
    v16 = *(unsigned int *)v7;
    i = v7 + 4;
    if ( (_DWORD)v16 == -1 )
    {
      v15 = (unsigned int *)(v7 + 12);
      v16 = *(_QWORD *)(v7 + 4);
      i = v7 + 12;
    }
    if ( !v16 )
      break;
    v17 = *v15;
    v7 = (char *)v15 + v16;
    if ( (_DWORD)v17 )
    {
      v18 = (char *)v15 - v17;
      if ( (char *)v15 - v17 >= a3 && (unsigned __int64)v18 < v8 && !sub_67F0EF8(a1, v18, a7) )
      {
        v19 = a7[24];
        i += 4;
        v20 = sub_67F2B7C(a1, &i, v7, v19, 0LL);
        v21 = sub_67F2B7C(a1, &i, v7, a7[24] & 0xF, 0LL);
        if ( v20 < a2 )
        {
          v22 = v21 + v20;
          if ( v21 + v20 >= a2 )
          {
            v23 = (unsigned __int8)a7[49];
            a6[5] = 0LL;
            if ( v23 )
            {
              v24 = sub_67F2E90(&i, v7);
              v25 = i;
              v26 = (unsigned __int8)a7[25];
              v27 = &i[v24];
              if ( v26 != 255 )
              {
                if ( sub_67F2B7C(a1, &i, v7, v26 & 0xF, 0LL) )
                {
                  v28 = a7[25];
                  i = v25;
                  a6[5] = sub_67F2B7C(a1, &i, v7, v28, 0LL);
                }
              }
            }
            else
            {
              v27 = i;
            }
            a6[2] = v27;
            a6[3] = v20;
            result = 1LL;
            a6[4] = v22;
            *a6 = v14;
            a6[1] = v7 - v14;
            return result;
          }
        }
      }
    }
  }
  return 0LL;
}


================================================================================
Function: sub_67F40A0 (0x67F40A0)
================================================================================

unsigned __int64 __fastcall sub_67F40A0(__int64 a1, unsigned __int64 a2, _BYTE *a3, int a4, _QWORD *a5, __int64 a6)
{
  unsigned __int8 v6; // w8
  int v8; // w26
  unsigned __int8 *v9; // x25
  unsigned __int64 result; // x0
  unsigned __int64 v14; // x26
  unsigned __int8 *v15; // x28
  __int64 v16; // x27
  __int64 v17; // x21
  unsigned __int8 *v18; // x19
  unsigned __int64 v19; // x0
  unsigned int *v20; // x0
  _QWORD *v21; // [xsp+10h] [xbp-20h]
  unsigned int v22; // [xsp+1Ch] [xbp-14h]
  unsigned __int8 *v24; // [xsp+28h] [xbp-8h] BYREF

  if ( *a3 == 1 )
  {
    v6 = a3[1];
    v8 = (unsigned __int8)a3[2];
    v9 = &a3[a4];
    v24 = a3 + 4;
    v22 = (unsigned __int8)a3[3];
    sub_67F2B7C(a1, &v24, v9, v6, (__int64)a3);
    if ( v8 != 255 )
    {
      result = sub_67F2B7C(a1, &v24, v9, v8, (__int64)a3);
      if ( !result )
        return result;
      v14 = result;
      v15 = v24;
      v21 = a5;
      v16 = sub_67F4270(v22);
      v17 = 0LL;
      while ( v14 > 1 )
      {
        v18 = &v15[((v14 >> 1) + v17) * v16];
        v24 = v18;
        v19 = sub_67F2B7C(a1, &v24, v9, v22, (__int64)a3);
        if ( v19 >= a2 )
        {
          v14 >>= 1;
        }
        else
        {
          v17 += v14 >> 1;
          v14 -= v14 >> 1;
        }
        if ( v19 == a2 )
          goto LABEL_15;
      }
      v18 = &v15[v17 * v16];
LABEL_15:
      v24 = v18;
      sub_67F2B7C(a1, &v24, v9, v22, (__int64)a3);
      v20 = (unsigned int *)sub_67F2B7C(a1, &v24, v9, v22, (__int64)a3);
      if ( !sub_67F0D68(a1, v20, v21, a6, 0) && v21[3] <= a2 && v21[4] > a2 )
        return 1LL;
    }
  }
  else
  {
    fwrite("libunwind: Unsupported .eh_frame_hdr version\n", 0x2DuLL, 1uLL, (FILE *)((char *)&_sF + 304));
  }
  return 0LL;
}


================================================================================
Function: sub_67F4270 (0x67F4270)
================================================================================

__int64 __fastcall sub_67F4270(char a1)
{
  int v1; // w8
  __int64 result; // x0

  v1 = (a1 & 0xF) - 1;
  result = 4LL;
  switch ( v1 )
  {
    case 0:
    case 8:
      __asm { BTI             j; jumptable 00000000067F42A8 cases 1,9 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getTableEntrySize",
        "Can't binary search on variable length encoded data.");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
    case 1:
    case 9:
      goto LABEL_3;
    case 2:
    case 10:
      __asm { BTI             j; jumptable 00000000067F42A8 cases 3,11 }
      result = 8LL;
LABEL_3:
      __asm { BTI             j; jumptable 00000000067F42A8 cases 2,10 }
      break;
    case 3:
    case 11:
      __asm { BTI             j; jumptable 00000000067F42A8 cases 4,12 }
      result = 16LL;
      break;
    default:
      __asm { BTI             j; jumptable 00000000067F42A8 default case, cases 5-8 }
      fprintf(
        (FILE *)((char *)&_sF + 304),
        "libunwind: %s - %s\n",
        "getTableEntrySize",
        "Unknown DWARF encoding for search table.");
      fflush((FILE *)((char *)&_sF + 304));
      abort();
  }
  return result;
}


================================================================================
Function: sub_67F44A0 (0x67F44A0)
================================================================================

__int64 __usercall sub_67F44A0@<X0>(
        __int64 a1@<X0>,
        __int64 a2@<X1>,
        __int64 a3@<X2>,
        __int64 a4@<X3>,
        __int64 a5@<X4>,
        __int64 a6@<X5>,
        __int64 a7@<X6>,
        __int64 a8@<X7>,
        __int64 a9@<X8>,
        double a10@<D0>,
        double a11@<D1>,
        double a12@<D2>,
        double a13@<D3>,
        double a14@<D4>,
        double a15@<D5>,
        double a16@<D6>,
        double a17@<D7>,
        __int64 a18)
{
  __int64 v18; // x9
  __int64 v19; // x10
  __int64 v20; // x11
  __int64 v21; // x12
  __int64 v22; // x13
  __int64 v23; // x14
  __int64 v24; // x15
  __int64 v25; // x16
  __int64 v26; // x17
  __int64 v27; // x18
  __int64 v28; // x19
  __int64 v29; // x20
  __int64 v30; // x21
  __int64 v31; // x22
  __int64 v32; // x23
  __int64 v33; // x24
  __int64 v34; // x25
  __int64 v35; // x26
  __int64 v36; // x27
  __int64 v37; // x28
  __int64 v38; // x29
  __int64 v39; // x30
  __int64 v40; // d8
  __int64 v41; // d9
  __int64 v42; // d10
  __int64 v43; // d11
  __int64 v44; // d12
  __int64 v45; // d13
  __int64 v46; // d14
  __int64 v47; // d15
  __int64 v48; // d16
  __int64 v49; // d17
  __int64 v50; // d18
  __int64 v51; // d19
  __int64 v52; // d20
  __int64 v53; // d21
  __int64 v54; // d22
  __int64 v55; // d23
  __int64 v56; // d24
  __int64 v57; // d25
  __int64 v58; // d26
  __int64 v59; // d27
  __int64 v60; // d28
  __int64 v61; // d29
  __int64 v62; // d30
  __int64 v63; // d31

  *(_QWORD *)a1 = a1;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = a4;
  *(_QWORD *)(a1 + 32) = a5;
  *(_QWORD *)(a1 + 40) = a6;
  *(_QWORD *)(a1 + 48) = a7;
  *(_QWORD *)(a1 + 56) = a8;
  *(_QWORD *)(a1 + 64) = a9;
  *(_QWORD *)(a1 + 72) = v18;
  *(_QWORD *)(a1 + 80) = v19;
  *(_QWORD *)(a1 + 88) = v20;
  *(_QWORD *)(a1 + 96) = v21;
  *(_QWORD *)(a1 + 104) = v22;
  *(_QWORD *)(a1 + 112) = v23;
  *(_QWORD *)(a1 + 120) = v24;
  *(_QWORD *)(a1 + 128) = v25;
  *(_QWORD *)(a1 + 136) = v26;
  *(_QWORD *)(a1 + 144) = v27;
  *(_QWORD *)(a1 + 152) = v28;
  *(_QWORD *)(a1 + 160) = v29;
  *(_QWORD *)(a1 + 168) = v30;
  *(_QWORD *)(a1 + 176) = v31;
  *(_QWORD *)(a1 + 184) = v32;
  *(_QWORD *)(a1 + 192) = v33;
  *(_QWORD *)(a1 + 200) = v34;
  *(_QWORD *)(a1 + 208) = v35;
  *(_QWORD *)(a1 + 216) = v36;
  *(_QWORD *)(a1 + 224) = v37;
  *(_QWORD *)(a1 + 232) = v38;
  *(_QWORD *)(a1 + 240) = v39;
  *(_QWORD *)(a1 + 248) = &a18;
  *(_QWORD *)(a1 + 256) = v39;
  *(double *)(a1 + 272) = a10;
  *(double *)(a1 + 280) = a11;
  *(double *)(a1 + 288) = a12;
  *(double *)(a1 + 296) = a13;
  *(double *)(a1 + 304) = a14;
  *(double *)(a1 + 312) = a15;
  *(double *)(a1 + 320) = a16;
  *(double *)(a1 + 328) = a17;
  *(_QWORD *)(a1 + 336) = v40;
  *(_QWORD *)(a1 + 344) = v41;
  *(_QWORD *)(a1 + 352) = v42;
  *(_QWORD *)(a1 + 360) = v43;
  *(_QWORD *)(a1 + 368) = v44;
  *(_QWORD *)(a1 + 376) = v45;
  *(_QWORD *)(a1 + 384) = v46;
  *(_QWORD *)(a1 + 392) = v47;
  *(_QWORD *)(a1 + 400) = v48;
  *(_QWORD *)(a1 + 408) = v49;
  *(_QWORD *)(a1 + 416) = v50;
  *(_QWORD *)(a1 + 424) = v51;
  *(_QWORD *)(a1 + 432) = v52;
  *(_QWORD *)(a1 + 440) = v53;
  *(_QWORD *)(a1 + 448) = v54;
  *(_QWORD *)(a1 + 456) = v55;
  *(_QWORD *)(a1 + 464) = v56;
  *(_QWORD *)(a1 + 472) = v57;
  *(_QWORD *)(a1 + 480) = v58;
  *(_QWORD *)(a1 + 488) = v59;
  *(_QWORD *)(a1 + 496) = v60;
  *(_QWORD *)(a1 + 504) = v61;
  *(_QWORD *)(a1 + 512) = v62;
  *(_QWORD *)(a1 + 520) = v63;
  return 0LL;
}


================================================================================
Function: .__cxa_atexit (0x67F4680)
================================================================================

// attributes: thunk
int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return _cxa_atexit(lpfunc, obj, lpdso_handle);
}


================================================================================
Function: .memcpy (0x67F46B0)
================================================================================

// attributes: thunk
void *memcpy(void *dest, const void *src, size_t n)
{
  return memcpy(dest, src, n);
}


================================================================================
Function: .strlen (0x67F46C0)
================================================================================

// attributes: thunk
size_t strlen(const char *s)
{
  return strlen(s);
}


================================================================================
Function: .memcmp (0x67F46E0)
================================================================================

// attributes: thunk
int memcmp(const void *s1, const void *s2, size_t n)
{
  return memcmp(s1, s2, n);
}


================================================================================
Function: .pthread_mutex_init (0x67F46F0)
================================================================================

// attributes: thunk
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr)
{
  return pthread_mutex_init(mutex, mutexattr);
}


================================================================================
Function: .pthread_mutex_destroy (0x67F4700)
================================================================================

// attributes: thunk
int pthread_mutex_destroy(pthread_mutex_t *mutex)
{
  return pthread_mutex_destroy(mutex);
}


================================================================================
Function: .memset (0x67F4710)
================================================================================

// attributes: thunk
void *memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}


================================================================================
Function: .__memcpy_chk (0x67F4720)
================================================================================

// attributes: thunk
__int64 __fastcall __memcpy_chk()
{
  return _memcpy_chk();
}


================================================================================
Function: .pthread_once (0x67F4730)
================================================================================

// attributes: thunk
int pthread_once(pthread_once_t *once_control, void (*init_routine)(void))
{
  return pthread_once(once_control, init_routine);
}


================================================================================
Function: .strncmp (0x67F4760)
================================================================================

// attributes: thunk
int strncmp(const char *s1, const char *s2, size_t n)
{
  return strncmp(s1, s2, n);
}


================================================================================
Function: .strcmp (0x67F47B0)
================================================================================

// attributes: thunk
int strcmp(const char *s1, const char *s2)
{
  return strcmp(s1, s2);
}


================================================================================
Function: .fopen (0x67F47C0)
================================================================================

// attributes: thunk
FILE *fopen(const char *filename, const char *modes)
{
  return fopen(filename, modes);
}


================================================================================
Function: .fclose (0x67F47D0)
================================================================================

// attributes: thunk
int fclose(FILE *stream)
{
  return fclose(stream);
}


================================================================================
Function: .fwrite (0x67F4800)
================================================================================

// attributes: thunk
size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)
{
  return fwrite(ptr, size, n, s);
}


================================================================================
Function: .fflush (0x67F4810)
================================================================================

// attributes: thunk
int fflush(FILE *stream)
{
  return fflush(stream);
}


================================================================================
Function: .memmove (0x67F4820)
================================================================================

// attributes: thunk
void *memmove(void *dest, const void *src, size_t n)
{
  return memmove(dest, src, n);
}


================================================================================
Function: .__open_2 (0x67F4860)
================================================================================

// attributes: thunk
__int64 __fastcall __open_2()
{
  return _open_2();
}


================================================================================
Function: .read (0x67F4870)
================================================================================

// attributes: thunk
ssize_t read(int fd, void *buf, size_t nbytes)
{
  return read(fd, buf, nbytes);
}


================================================================================
Function: .__errno (0x67F4880)
================================================================================

// attributes: thunk
__int64 __errno(void)
{
  return _errno();
}


================================================================================
Function: .close (0x67F4890)
================================================================================

// attributes: thunk
int close(int fd)
{
  return close(fd);
}


================================================================================
Function: .memchr (0x67F48C0)
================================================================================

// attributes: thunk
void *memchr(const void *s, int c, size_t n)
{
  return memchr(s, c, n);
}


================================================================================
Function: .pthread_create (0x67F4930)
================================================================================

// attributes: thunk
int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
{
  return pthread_create(newthread, attr, start_routine, arg);
}


================================================================================
Function: .pthread_setspecific (0x67F4940)
================================================================================

// attributes: thunk
int pthread_setspecific(pthread_key_t key, const void *pointer)
{
  return pthread_setspecific(key, pointer);
}


================================================================================
Function: .abort (0x67F4950)
================================================================================

// attributes: thunk
void __noreturn abort(void)
{
  abort();
}


================================================================================
Function: .strncpy (0x67F4960)
================================================================================

// attributes: thunk
char *strncpy(char *dest, const char *src, size_t n)
{
  return strncpy(dest, src, n);
}


================================================================================
Function: .__strlen_chk (0x67F4970)
================================================================================

// attributes: thunk
size_t __strlen_chk(const char *a1, size_t a2)
{
  return _strlen_chk(a1, a2);
}


================================================================================
Function: .pthread_mutex_lock (0x67F4980)
================================================================================

// attributes: thunk
int pthread_mutex_lock(pthread_mutex_t *mutex)
{
  return pthread_mutex_lock(mutex);
}


================================================================================
Function: .pthread_cond_signal (0x67F4990)
================================================================================

// attributes: thunk
int pthread_cond_signal(pthread_cond_t *cond)
{
  return pthread_cond_signal(cond);
}


================================================================================
Function: .pthread_mutex_unlock (0x67F49A0)
================================================================================

// attributes: thunk
int pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}


================================================================================
Function: .pthread_cond_wait (0x67F49D0)
================================================================================

// attributes: thunk
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
{
  return pthread_cond_wait(cond, mutex);
}


================================================================================
Function: .pthread_self (0x67F49E0)
================================================================================

// attributes: thunk
pthread_t pthread_self(void)
{
  return pthread_self();
}


================================================================================
Function: .pthread_cond_init (0x67F4A00)
================================================================================

// attributes: thunk
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr)
{
  return pthread_cond_init(cond, cond_attr);
}


================================================================================
Function: .stat (0x67F4A30)
================================================================================

// attributes: thunk
int stat(const char *file, struct stat *buf)
{
  return stat(file, buf);
}


================================================================================
Function: .pthread_cond_destroy (0x67F4A70)
================================================================================

// attributes: thunk
int pthread_cond_destroy(pthread_cond_t *cond)
{
  return pthread_cond_destroy(cond);
}


================================================================================
Function: .pthread_cond_broadcast (0x67F4A80)
================================================================================

// attributes: thunk
int pthread_cond_broadcast(pthread_cond_t *cond)
{
  return pthread_cond_broadcast(cond);
}


================================================================================
Function: .mkdir (0x67F4B00)
================================================================================

// attributes: thunk
int mkdir(const char *path, __mode_t mode)
{
  return mkdir(path, mode);
}


================================================================================
Function: .dl_iterate_phdr (0x67F4B10)
================================================================================

// attributes: thunk
int dl_iterate_phdr(int (*callback)(struct dl_phdr_info *, size_t, void *), void *data)
{
  return dl_iterate_phdr(callback, data);
}


================================================================================
Function: .access (0x67F4B30)
================================================================================

// attributes: thunk
int access(const char *name, int type)
{
  return access(name, type);
}


================================================================================
Function: .getenv (0x67F4B40)
================================================================================

// attributes: thunk
char *getenv(const char *name)
{
  return getenv(name);
}


================================================================================
Function: .vsnprintf (0x67F4C50)
================================================================================

// attributes: thunk
int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg)
{
  return vsnprintf(s, maxlen, format, arg);
}


================================================================================
Function: .gettimeofday (0x67F4CC0)
================================================================================

// attributes: thunk
int gettimeofday(struct timeval *tv, __timezone_ptr_t tz)
{
  return gettimeofday(tv, tz);
}


================================================================================
Function: .sched_yield (0x67F4CF0)
================================================================================

// attributes: thunk
int sched_yield(void)
{
  return sched_yield();
}


================================================================================
Function: .time (0x67F4D10)
================================================================================

// attributes: thunk
time_t time(time_t *timer)
{
  return time(timer);
}


================================================================================
Function: .__vsnprintf_chk (0x67F4D50)
================================================================================

// attributes: thunk
__int64 __fastcall __vsnprintf_chk()
{
  return _vsnprintf_chk();
}


================================================================================
Function: .pthread_cond_timedwait (0x67F4D60)
================================================================================

// attributes: thunk
int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime)
{
  return pthread_cond_timedwait(cond, mutex, abstime);
}


================================================================================
Function: .strtoll (0x67F4D70)
================================================================================

// attributes: thunk
__int64 strtoll(const char *nptr, char **endptr, int base)
{
  return strtoll(nptr, endptr, base);
}


================================================================================
Function: .fcntl (0x67F4E60)
================================================================================

// attributes: thunk
int fcntl(int fd, int cmd, ...)
{
  return fcntl(fd, cmd);
}


================================================================================
Function: .pipe (0x67F4E70)
================================================================================

// attributes: thunk
int pipe(int pipedes[2])
{
  return pipe(pipedes);
}


================================================================================
Function: .strcpy (0x67F4E80)
================================================================================

// attributes: thunk
char *strcpy(char *dest, const char *src)
{
  return strcpy(dest, src);
}


================================================================================
Function: .raise (0x67F4F30)
================================================================================

// attributes: thunk
int raise(int sig)
{
  return raise(sig);
}


================================================================================
Function: .fprintf (0x67F4F60)
================================================================================

// attributes: thunk
int fprintf(FILE *stream, const char *format, ...)
{
  return fprintf(stream, format);
}


================================================================================
Function: .clock_gettime (0x67F4F70)
================================================================================

// attributes: thunk
int clock_gettime(clockid_t clock_id, struct timespec *tp)
{
  return clock_gettime(clock_id, tp);
}


================================================================================
Function: .log (0x67F4F90)
================================================================================

// attributes: thunk
double log(double x)
{
  return log(x);
}


================================================================================
Function: .strstr (0x67F4FA0)
================================================================================

// attributes: thunk
char *strstr(const char *haystack, const char *needle)
{
  return strstr(haystack, needle);
}


================================================================================
Function: .strcasecmp (0x67F4FF0)
================================================================================

// attributes: thunk
int strcasecmp(const char *s1, const char *s2)
{
  return strcasecmp(s1, s2);
}


================================================================================
Function: .strcat (0x67F5000)
================================================================================

// attributes: thunk
char *strcat(char *dest, const char *src)
{
  return strcat(dest, src);
}


================================================================================
Function: .strchr (0x67F5010)
================================================================================

// attributes: thunk
char *strchr(const char *s, int c)
{
  return strchr(s, c);
}


================================================================================
Function: .getpid (0x67F5030)
================================================================================

// attributes: thunk
__pid_t getpid(void)
{
  return getpid();
}


================================================================================
Function: .pthread_mutexattr_init (0x67F5070)
================================================================================

// attributes: thunk
int pthread_mutexattr_init(pthread_mutexattr_t *attr)
{
  return pthread_mutexattr_init(attr);
}


================================================================================
Function: .pthread_mutexattr_settype (0x67F5080)
================================================================================

// attributes: thunk
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind)
{
  return pthread_mutexattr_settype(attr, kind);
}


================================================================================
Function: .pthread_mutexattr_destroy (0x67F5090)
================================================================================

// attributes: thunk
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr)
{
  return pthread_mutexattr_destroy(attr);
}


================================================================================
Function: .pthread_mutex_trylock (0x67F50A0)
================================================================================

// attributes: thunk
int pthread_mutex_trylock(pthread_mutex_t *mutex)
{
  return pthread_mutex_trylock(mutex);
}


================================================================================
Function: .pthread_join (0x67F50B0)
================================================================================

// attributes: thunk
int pthread_join(pthread_t th, void **thread_return)
{
  return pthread_join(th, thread_return);
}


================================================================================
Function: .vfprintf (0x67F50D0)
================================================================================

// attributes: thunk
int vfprintf(FILE *s, const char *format, __gnuc_va_list arg)
{
  return vfprintf(s, format, arg);
}


================================================================================
Function: .strtol (0x67F5180)
================================================================================

// attributes: thunk
__int64 strtol(const char *nptr, char **endptr, int base)
{
  return strtol(nptr, endptr, base);
}


================================================================================
Function: .inet_pton (0x67F51F0)
================================================================================

// attributes: thunk
int inet_pton(int af, const char *cp, void *buf)
{
  return inet_pton(af, cp, buf);
}


================================================================================
Function: .__FD_SET_chk (0x67F5270)
================================================================================

// attributes: thunk
__int64 __fastcall __FD_SET_chk()
{
  return _FD_SET_chk();
}


================================================================================
Function: .select (0x67F5280)
================================================================================

// attributes: thunk
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
{
  return select(nfds, readfds, writefds, exceptfds, timeout);
}


================================================================================
Function: .__FD_ISSET_chk (0x67F5290)
================================================================================

// attributes: thunk
__int64 __fastcall __FD_ISSET_chk()
{
  return _FD_ISSET_chk();
}


================================================================================
Function: .nanosleep (0x67F5300)
================================================================================

// attributes: thunk
int nanosleep(const struct timespec *requested_time, struct timespec *remaining)
{
  return nanosleep(requested_time, remaining);
}


================================================================================
Function: .fileno (0x67F5310)
================================================================================

// attributes: thunk
int fileno(FILE *stream)
{
  return fileno(stream);
}


================================================================================
Function: .fstat (0x67F5320)
================================================================================

// attributes: thunk
int fstat(int fd, struct stat *buf)
{
  return fstat(fd, buf);
}


================================================================================
Function: .qsort (0x67F5970)
================================================================================

// attributes: thunk
void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar)
{
  qsort(base, nmemb, size, compar);
}


================================================================================
Function: .feof (0x67F5980)
================================================================================

// attributes: thunk
int feof(FILE *stream)
{
  return feof(stream);
}


================================================================================
Function: .syscall (0x67F59B0)
================================================================================

// attributes: thunk
__int64 syscall(__int64 sysno, ...)
{
  return syscall(sysno);
}


================================================================================
Function: .strrchr (0x67F5A30)
================================================================================

// attributes: thunk
char *strrchr(const char *s, int c)
{
  return strrchr(s, c);
}


================================================================================
Function: .munmap (0x67F5A50)
================================================================================

// attributes: thunk
int munmap(void *addr, size_t len)
{
  return munmap(addr, len);
}


================================================================================
Function: .mprotect (0x67F5A60)
================================================================================

// attributes: thunk
int mprotect(void *addr, size_t len, int prot)
{
  return mprotect(addr, len, prot);
}


================================================================================
Function: .mmap (0x67F5A70)
================================================================================

// attributes: thunk
void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset)
{
  return mmap(addr, len, prot, flags, fd, offset);
}


================================================================================
Function: .sysconf (0x67F5A80)
================================================================================

// attributes: thunk
__int64 sysconf(int name)
{
  return sysconf(name);
}


================================================================================
Function: .fputc (0x67F5B00)
================================================================================

// attributes: thunk
int fputc(int c, FILE *stream)
{
  return fputc(c, stream);
}


================================================================================
Function: .strcspn (0x67F5B40)
================================================================================

// attributes: thunk
size_t strcspn(const char *s, const char *reject)
{
  return strcspn(s, reject);
}


================================================================================
Function: .strncat (0x67F5B50)
================================================================================

// attributes: thunk
char *strncat(char *dest, const char *src, size_t n)
{
  return strncat(dest, src, n);
}


================================================================================
Function: .gmtime_r (0x67F5B60)
================================================================================

// attributes: thunk
struct tm *gmtime_r(const time_t *timer, struct tm *tp)
{
  return gmtime_r(timer, tp);
}


================================================================================
Function: .fgets (0x67F5BE0)
================================================================================

// attributes: thunk
char *fgets(char *s, int n, FILE *stream)
{
  return fgets(s, n, stream);
}


================================================================================
Function: .fdopen (0x67F5C20)
================================================================================

// attributes: thunk
FILE *fdopen(int fd, const char *modes)
{
  return fdopen(fd, modes);
}


================================================================================
Function: .pthread_getspecific (0x67F5CF0)
================================================================================

// attributes: thunk
void *pthread_getspecific(pthread_key_t key)
{
  return pthread_getspecific(key);
}


================================================================================
Function: .pthread_key_create (0x67F5D00)
================================================================================

// attributes: thunk
int pthread_key_create(pthread_key_t *key, void (*destr_function)(void *))
{
  return pthread_key_create(key, destr_function);
}


================================================================================
Function: .sigaction (0x67F5E10)
================================================================================

// attributes: thunk
int sigaction(int sig, const struct sigaction *act, struct sigaction *oact)
{
  return sigaction(sig, act, oact);
}


================================================================================
Function: .strtok_r (0x67F5FE0)
================================================================================

// attributes: thunk
char *strtok_r(char *s, const char *delim, char **save_ptr)
{
  return strtok_r(s, delim, save_ptr);
}


================================================================================
Function: .pthread_detach (0x67F5FF0)
================================================================================

// attributes: thunk
int pthread_detach(pthread_t th)
{
  return pthread_detach(th);
}


================================================================================
Function: .unlink (0x67F6000)
================================================================================

// attributes: thunk
int unlink(const char *name)
{
  return unlink(name);
}


================================================================================
Function: .memrchr (0x67F6010)
================================================================================

// attributes: thunk
void *memrchr(const void *s, int c, size_t n)
{
  return memrchr(s, c, n);
}


================================================================================
Function: .open (0x67F6020)
================================================================================

// attributes: thunk
int open(const char *file, int oflag, ...)
{
  return open(file, oflag);
}


================================================================================
Function: .madvise (0x67F6190)
================================================================================

// attributes: thunk
int madvise(void *addr, size_t len, int advice)
{
  return madvise(addr, len, advice);
}


================================================================================
Function: .snprintf (0x67F61C0)
================================================================================

// attributes: thunk
int snprintf(char *s, size_t maxlen, const char *format, ...)
{
  return snprintf(s, maxlen, format);
}


================================================================================
Function: .pthread_rwlock_rdlock (0x67F63D0)
================================================================================

// attributes: thunk
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_rdlock(rwlock);
}


================================================================================
Function: .pthread_rwlock_unlock (0x67F63E0)
================================================================================

// attributes: thunk
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_unlock(rwlock);
}


================================================================================
Function: .pthread_rwlock_wrlock (0x67F63F0)
================================================================================

// attributes: thunk
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)
{
  return pthread_rwlock_wrlock(rwlock);
}


================================================================================
Function: .arc4random_buf (0x67F6440)
================================================================================

// attributes: thunk
void arc4random_buf(void *a1, size_t a2)
{
  arc4random_buf(a1, a2);
}


================================================================================
Function: .newlocale (0x67F6470)
================================================================================

// attributes: thunk
__int64 __fastcall newlocale(__int64 a1, __int64 a2, __int64 a3)
{
  return newlocale(a1, a2, a3);
}


================================================================================
Function: .vasprintf (0x67F64A0)
================================================================================

// attributes: thunk
int vasprintf(char **ptr, const char *f, __gnuc_va_list arg)
{
  return vasprintf(ptr, f, arg);
}


================================================================================
Function: .android_set_abort_message (0x67F6720)
================================================================================

// attributes: thunk
__int64 __fastcall android_set_abort_message()
{
  return android_set_abort_message();
}


================================================================================
Function: .openlog (0x67F6730)
================================================================================

// attributes: thunk
void openlog(const char *ident, int option, int facility)
{
  openlog(ident, option, facility);
}


================================================================================
Function: .syslog (0x67F6740)
================================================================================

// attributes: thunk
void syslog(int pri, const char *fmt, ...)
{
  syslog(pri, fmt);
}


================================================================================
Function: .closelog (0x67F6750)
================================================================================

// attributes: thunk
void closelog(void)
{
  closelog();
}


================================================================================
Function: .__cxa_thread_atexit_impl (0x67F6760)
================================================================================

// attributes: thunk
__int64 __fastcall __cxa_thread_atexit_impl()
{
  return _cxa_thread_atexit_impl();
}


